+;

        iCur %= TAB_MAX;
        TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), iCur);
        OnTabChange(NULL);
        }
   
NoKeys:    
    if (IsWindow(m_hwnd) && IsWindowVisible(m_hwnd))
        fEaten = ::IsDialogMessage(m_hwnd, pMsg);
        
    LeaveCriticalSection(&m_cs);
    return (fEaten ? S_OK : S_FALSE);
    }


//
//  FUNCTION:   CSpoolerDlg::GetWindow()
//
//  PURPOSE:    Returns the handle to the spooler dialog window.
//
//  PARAMETERS:
//      <out> pHwnd - Where we return the handle.
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::GetWindow(HWND *pHwnd)
    {
    HRESULT hr=S_OK;

    if (NULL == pHwnd)
        return E_INVALIDARG;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        *pHwnd = m_hwnd;

    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }


HRESULT CSpoolerDlg::Close(void)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        DestroyWindow(m_hwnd);

    // Unregister with Identity manager
    if (m_dwIdentCookie != 0)
    {
        MU_UnregisterIdentityNotifier(m_dwIdentCookie);
        m_dwIdentCookie = 0;
    }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CSpoolerDlg::ChangeHangupOption(BOOL fEnable, DWORD dwOption)
    {
    ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_HANGUP), fEnable ? SW_SHOW : SW_HIDE);
    ::EnableWindow(GetDlgItem(m_hwnd, IDC_SP_HANGUP), fEnable);
    SendDlgItemMessage(m_hwnd, IDC_SP_HANGUP, BM_SETCHECK, dwOption, 0);
    return (S_OK);
    }


//
//  FUNCTION:   CSpoolerDlg::PostDlgProc()
//
//  PURPOSE:    Dialog callback for the spooler dialog proc.
//
INT_PTR CALLBACK CSpoolerDlg::SpoolerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                          LPARAM lParam)
    {
    CSpoolerDlg *pThis = (CSpoolerDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
    LRESULT lResult;

    // Pass to spooler bind context
    if (pThis && pThis->m_pBindCtx && pThis->m_pBindCtx->OnWindowMessage(hwnd, uMsg, wParam, lParam) == S_OK)
        return (TRUE);
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stash the this pointer so we can use it later
            Assert(lParam);
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis = (CSpoolerDlg *) lParam;
            
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, 
                                               pThis->OnInitDialog);
                                        
        case WM_COMMAND:
            if (pThis)
                HANDLE_WM_COMMAND(hwnd, wParam, lParam, pThis->OnCommand);
            return (TRUE);  

        case WM_NOTIFY:
            if (pThis)
                {
                lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, pThis->OnNotify);
                SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
                }
            return (TRUE);
            
        case WM_DRAWITEM:
            if (pThis)
                HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, pThis->OnDrawItem);
            return (TRUE);

        case WM_MEASUREITEM:
            if (pThis)
                HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, pThis->OnMeasureItem);
            return (TRUE);

        case WM_DELETEITEM:
            if (pThis)
                HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, pThis->OnDeleteItem);
            return (TRUE);

#if 0
        case WM_SYSCOLORCHANGE:
        case WM_SETTINGCHANGE:
            if (pThis)
                HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, pThis->OnSysColorChange);
            return (TRUE);
#endif
        
        case WM_CLOSE:
            if (pThis)
                HANDLE_WM_CLOSE(hwnd, wParam, lParam, pThis->OnClose);
            return (TRUE);

        case WM_DESTROY:
            if (pThis)
                HANDLE_WM_DESTROY(hwnd, wParam, lParam, pThis->OnDestroy);
            return (TRUE);

        case IMAIL_SHOWWINDOW:
            ::ShowWindow(hwnd, (int) lParam);
            if (pThis)
                pThis->ToggleStatics(lParam == SW_HIDE);
            return (TRUE);

        case WM_QUERYENDSESSION:
            if (pThis && pThis->m_pBindCtx)
                {
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pThis->m_pBindCtx->QueryEndSession(wParam, lParam));
                return (TRUE);
                }
            break;

        case WM_CONTEXTMENU:
            if (pThis)
                {
                HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, pThis->OnContextMenu);
                return (TRUE);
                }
            break;
        }

    return (FALSE);
    }


//
//  FUNCTION:   CSpoolerDlg::OnInitDialog()
//
//  PURPOSE:    Initializes the dialog.
//
//  PARAMETERS:
//      <in> hwnd      - Handle of the dialog window.
//      <in> hwndFocus - Handle of the control that will start with the focus.
//      <in> lParam    - Extra data being passed to the dialog.
//
//  RETURN VALUE:
//      Return TRUE to set the focus to hwndFocus
//
BOOL CSpoolerDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
    m_hwnd = hwnd;

    // Bug #38692 - Set the font correctly for Intl charsets
    SetIntlFont(hwnd);
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_GENERAL_PROG));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_SPECIFIC_PROG));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_EVENTS));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_ERRORS));
    SetIntlFont(GetDlgItem(hwnd, IDC_SP_IDLETEXT));

    // Initialize the controls on the dialog
    InitializeTabs();
    InitializeLists();
    InitializeAnimation();
    InitializeToolbar();
    ToggleStatics(TRUE);

    // Hide the Hangup when done deal.
    // ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_HANGUP), SW_HIDE);

    // Set the hangup when done option
    Button_SetCheck(GetDlgItem(m_hwnd, IDC_SP_HANGUP), DwGetOption(OPT_DIALUP_HANGUP_DONE));

    // Get some information from the dialog template we'll need later
    GetDlgItemText(m_hwnd, IDC_SP_OVERALL_STATUS, m_szCount, ARRAYSIZE(m_szCount));

    // Initialize the rectangles that we'll need for sizing later
    RECT rcSep;
    GetWindowRect(GetDlgItem(hwnd, IDC_SP_SEPARATOR), &rcSep);
    GetWindowRect(hwnd, &m_rcDlg);
    m_cyCollapsed = rcSep.top - m_rcDlg.top;

    // Load the window size from the registry
    WINDOWPLACEMENT wp;
    wp.length = sizeof(WINDOWPLACEMENT);
    if (GetOption(OPT_SPOOLERDLGPOS, (LPVOID*) &wp, sizeof(WINDOWPLACEMENT)))
        {
        wp.showCmd = SW_HIDE;
        SetWindowPlacement(hwnd, &wp);
        ExpandCollapse(m_cyCollapsed < (DWORD) ((wp.rcNormalPosition.bottom - wp.rcNormalPosition.top)), FALSE);
        }
    else
        {
        // Center the dialog on the screen.
        CenterDialog(hwnd);
        ExpandCollapse(FALSE, FALSE);
        }

    // Set the state of the thumbtack
    DWORD dwTack;
    if (DwGetOption(OPT_SPOOLERTACK))
        {
        SendDlgItemMessage(hwnd, IDC_SP_TOOLBAR, TB_SETSTATE, IDC_SP_TACK, 
                           MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED, 0));
        SendMessage(hwnd, WM_COMMAND, IDC_SP_TACK, 0);
        }

    // Disable the stop button
    EnableWindow(GetDlgItem(hwnd, IDC_SP_STOP), FALSE);

    // Subclass the list box
    HWND hwnderr = GetDlgItem(hwnd, IDC_SP_ERRORS);
    WNDPROC proc = (WNDPROC) GetWindowLongPtr(hwnderr, GWLP_WNDPROC);
    SetProp(hwnderr, c_szWndProc, proc);
    SetWindowLongPtr(hwnderr, GWLP_WNDPROC, (LPARAM) ListSubClassProc);

    // BUG: 44376. ATOK11 has a hidden window. If we return TRUE user will do a setfocus on US, at this point the browser
    // thread is block waiting for the spooler to complete and when ATOK gets a WM_ACTIVATE they interthreadsendmsg on our blocked
    // browser window with inf. timeout. So we hang at startup. Don't set focus in here at startup time.
    return (FALSE);
    }

//
//  FUNCTION:   CSpoolerDlg::OnCommand()
//
//  PURPOSE:    Handle the various command messages dispatched from the dialog
//
void CSpoolerDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    switch (id)
        {
        case IDCANCEL:
        case IDC_SP_MINIMIZE:
            if (m_fShutdown)
                {
                Assert(m_pBindCtx);
                EnableWindow(GetDlgItem(hwnd, IDC_SP_MINIMIZE), FALSE);
                m_pBindCtx->UIShutdown();
                }
            else
                ShowWindow(SW_HIDE);
            break;

        case IDC_SP_STOP:
            if (m_pBindCtx)
                {
                m_pBindCtx->Cancel();
                if (GetFocus() == GetDlgItem(hwnd, IDC_SP_STOP))
                    SetFocus(GetDlgItem(hwnd, IDC_SP_MINIMIZE));
                EnableWindow(GetDlgItem(hwnd, IDC_SP_STOP), FALSE);
                }
            break;

        case IDC_SP_TACK:
            {
            UINT state = (UINT) SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETSTATE,
                                            IDC_SP_TACK, 0);
            SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_CHANGEBITMAP, 
                               IDC_SP_TACK, 
                               MAKELPARAM(state & TBSTATE_CHECKED ? IMAGE_TACK_IN : IMAGE_TACK_OUT, 0));
            }
            break;

        case IDC_SP_DETAILS:
            m_fSaveSize = TRUE;
            ExpandCollapse(!m_fExpanded);
            break;

        case IDC_SP_HANGUP:
            SetDwOption(OPT_DIALUP_HANGUP_DONE, BST_CHECKED == Button_GetCheck(hwndCtl), NULL, 0);
            break;
        }
    }


//
//  FUNCTION:   CSpoolerDlg::OnNotify
//
//  PURPOSE:    Handles notifications from the common controls on the dialog.
//
LRESULT CSpoolerDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
    switch (pnmhdr->code)
        {
        case TCN_SELCHANGE:
            OnTabChange(pnmhdr);
            return (0);
        }

    return (0);
    }

//
//  FUNCTION:   CSpoolerDlg::OnDrawItem()
//
//  PURPOSE:    Draws the link buttons
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the dialog window
//      <in> lpDrawItem - Pointer to a DRAWITEMSTRUCT with the info needed to 
//                        draw the button.
//
void CSpoolerDlg::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem)
    {
    HDC      hdc = lpDrawItem->hDC;
    COLORREF clrText, clrBack;
    RECT     rcText, rcFocus;
    SIZE     size;
    BOOL     fSelected = (lpDrawItem->itemState & ODS_SELECTED) && 
                         (GetFocus() == lpDrawItem->hwndItem);

    Assert(lpDrawItem->CtlType == ODT_LISTBOX);
    if (lpDrawItem->itemID == -1)
        goto exit;

    // Draw the bullet first
    ImageList_Draw(m_himlImages, 
                   IMAGE_BULLET, 
                   hdc, 
                   BULLET_INDENT, 
                   lpDrawItem->rcItem.top, 
                   fSelected ? ILD_SELECTED | ILD_TRANSPARENT : ILD_TRANSPARENT);

    // Set up the text rectangle
    rcText = lpDrawItem->rcItem;
    rcText.left += BULLET_WIDTH;

    // Set up the text and background colors
    clrBack = SetBkColor(hdc, GetSysColor(fSelected ? COLOR_HIGHLIGHT : COLOR_WINDOW));
    clrText = SetTextColor(hdc, GetSysColor(fSelected ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

    // Draw the text
    FillRect(hdc, &rcText, (HBRUSH)IntToPtr((fSelected ? COLOR_HIGHLIGHT : COLOR_WINDOW) + 1));
    InflateRect(&rcText, -2, -2);
    DrawText(hdc, ((LBDATA *) lpDrawItem->itemData)->pszText, -1, &rcText, DT_NOCLIP | DT_WORDBREAK);

    // If we need a focus rect, do that too
    if (lpDrawItem->itemState & ODS_FOCUS)
        {
        rcFocus = lpDrawItem->rcItem;
        rcFocus.left += BULLET_WIDTH;
//        InflateRect(&rcFocus, -2, -2);
        DrawFocusRect(hdc, &rcFocus);
        }

    SetBkColor(hdc, clrBack);
    SetTextColor(hdc, clrText);

exit:
    return;
    }


void CSpoolerDlg::OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT *pMeasureItem)
    {
    LBDATA *pData = NULL;

    EnterCriticalSection(&m_cs);

    // Set the height of the item
    if (NULL != (pData = (LBDATA *) ListBox_GetItemData(m_hwndErrors, pMeasureItem->itemID)))
        {
        pMeasureItem->itemHeight = pData->rcText.bottom;
        }

    LeaveCriticalSection(&m_cs);
    }


void CSpoolerDlg::OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem)
    {
    EnterCriticalSection(&m_cs);

    if (lpDeleteItem->itemData)
        {
        SafeMemFree(((LBDATA *)lpDeleteItem->itemData)->pszText);
        MemFree((LPVOID) lpDeleteItem->itemData);
        }

    LeaveCriticalSection(&m_cs);
    }


//
//  FUNCTION:   CSpoolerDlg::OnClose()
//
//  PURPOSE:    Handles the WM_CLOSE notification by sending an IDCANCEL to
//              the dialog.
//
void CSpoolerDlg::OnClose(HWND hwnd)
    {
    SendMessage(hwnd, WM_COMMAND, IDC_SP_MINIMIZE, 0);
    }     


//
//  FUNCTION:   CSpoolerDlg::OnDestroy()
//
//  PURPOSE:    Handles the WM_DESTROY notification by freeing the memory stored
//              in the listview items.
//
void CSpoolerDlg::OnDestroy(HWND hwnd)
    {
#ifndef _WIN64
    Animate_Close(GetDlgItem(m_hwnd, IDC_SP_ANIMATE));
#endif

    // Save the window placement
    WINDOWPLACEMENT wp;
    wp.length = sizeof(WINDOWPLACEMENT);
    if (GetWindowPlacement(hwnd, &wp))
        {
        if (!m_fSaveSize)
            {
            // Load the old size out of the registry
            WINDOWPLACEMENT wp2;

            if (GetOption(OPT_SPOOLERDLGPOS, (LPVOID*) &wp2, sizeof(WINDOWPLACEMENT)))
                {
                wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + (wp2.rcNormalPosition.bottom - wp2.rcNormalPosition.top);                
                }
            else
                {
                wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + m_cyCollapsed;
                }
            }

        SetOption(OPT_SPOOLERDLGPOS, (LPVOID) &wp, sizeof(WINDOWPLACEMENT), NULL, 0);
        }

    DWORD dwState;
    dwState = (DWORD) SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETSTATE, IDC_SP_TACK, 0);
    SetDwOption(OPT_SPOOLERTACK, !!(dwState & TBSTATE_CHECKED), NULL, 0);

    HIMAGELIST himl;
    himl = (HIMAGELIST)SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETIMAGELIST, 0, 0);
    if (himl)
        ImageList_Destroy(himl);

    HWND hwnderr = GetDlgItem(hwnd, IDC_SP_ERRORS);
    WNDPROC proc = (WNDPROC)GetProp(hwnderr, c_szWndProc);
    if (proc != NULL)
        {
        SetWindowLongPtr(hwnderr, GWLP_WNDPROC, (LPARAM)proc);
        RemoveProp(hwnderr, c_szWndProc);
        }
    }


//
//  FUNCTION:   CSpoolerDlg::InitializeTabs()
//
//  PURPOSE:    Initializes the tab control on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeTabs(void)
    {
    HWND    hwndTabs = GetDlgItem(m_hwnd, IDC_SP_TABS);
    TC_ITEM tci;
    TCHAR   szRes[CCHMAX_STRINGRES];

    // "Tasks"
    tci.mask = TCIF_TEXT;
    tci.pszText = AthLoadString(idsTasks, szRes, ARRAYSIZE(szRes));
    TabCtrl_InsertItem(hwndTabs, 0, &tci);
    
    // "Errors"
    tci.pszText = AthLoadString(idsErrors, szRes, ARRAYSIZE(szRes));
    TabCtrl_InsertItem(hwndTabs, 1, &tci);
    
    return (TRUE);
    }


//
//  FUNCTION:   CSpoolerDlg::InitializeLists()
//
//  PURPOSE:    Initializes the list control on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeLists(void)
    {
    LV_COLUMN lvc;
    TCHAR     szRes[CCHMAX_STRINGRES];
    RECT      rcClient;
    DWORD     cx;

    // Store the handle for the events list since we use it frequently
    m_hwndEvents = GetDlgItem(m_hwnd, IDC_SP_EVENTS);

    // Get the size of the client rect of the listview
    GetClientRect(m_hwndEvents, &rcClient);

    // "Tasks" column
    lvc.mask     = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_CENTER;
    lvc.cx       = rcClient.right / 2;
    lvc.pszText  = AthLoadString(idsTasks, szRes, ARRAYSIZE(szRes));
    lvc.iSubItem = 0;
    ListView_InsertColumn(m_hwndEvents, 0, &lvc);

    // "Status" column
    cx = (rcClient.right / 2 - GetSystemMetrics(SM_CXVSCROLL)) / 2;
    lvc.cx       = cx;
    lvc.pszText  = AthLoadString(idsStatusCol, szRes, ARRAYSIZE(szRes));
    lvc.iSubItem = 1;
    ListView_InsertColumn(m_hwndEvents, 1, &lvc);

    // "Connection" column
    lvc.cx       = cx;
    lvc.pszText  = AthLoadString(idsConnection, szRes, ARRAYSIZE(szRes));
    lvc.iSubItem = 2;
    ListView_InsertColumn(m_hwndEvents, 2, &lvc);

    // Set the listview image list
    m_himlImages = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbSpooler), 16, 0,
                                        RGB(255, 0, 255));

    if (m_himlImages)
        ListView_SetImageList(m_hwndEvents, m_himlImages, LVSIL_SMALL);

    // The listview looks better if we use full row select
    ListView_SetExtendedListViewStyle(m_hwndEvents, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    // Initialize the Error list
    m_hwndErrors = GetDlgItem(m_hwnd, IDC_SP_ERRORS);
    ::ShowWindow(m_hwndErrors, FALSE);
    EnableWindow(m_hwndErrors, FALSE);

    // Save the width of the error list
    GetClientRect(m_hwndErrors, &rcClient);
    m_cxErrors = rcClient.right;

    return (TRUE);
    }    


//
//  FUNCTION:   CSpoolerDlg::InitializeAnimation()
//
//  PURPOSE:    Initializes the animation controls on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeAnimation(void)
    {
#ifndef _WIN64

    HWND hwndAni = GetDlgItem(m_hwnd, IDC_SP_ANIMATE);

    Animate_OpenEx(hwndAni, g_hLocRes, MAKEINTRESOURCE(idanOutbox));
#endif
    return (0);
    }
    

//
//  FUNCTION:   CSpoolerDlg::InitializeToolbar()
//
//  PURPOSE:    What dialog would be complete without a toolbar, eh?
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
BOOL CSpoolerDlg::InitializeToolbar(void)
    {
    HWND hwndTool;
    RECT rcTabs;
    POINT point;

    HIMAGELIST himlImages = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbSpooler), 16, 0,
                                        RGB(255, 0, 255));

    GetWindowRect(GetDlgItem(m_hwnd, IDC_SP_TABS), &rcTabs);
    point.x = rcTabs.right - 22;
    point.y = rcTabs.bottom + 3;
    ScreenToClient(m_hwnd, &point);

    hwndTool = CreateWindowEx(0, TOOLBARCLASSNAME, NULL, 
                              CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN |
                              WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | TBSTYLE_FLAT,
                              point.x, point.y, 22, 22, 
                              m_hwnd, (HMENU) IDC_SP_TOOLBAR,
                              g_hInst, 0);
    if (hwndTool)
        {
#ifndef WIN16
        TBBUTTON tb = { IMAGE_TACK_OUT, IDC_SP_TACK, TBSTATE_ENABLED, TBSTYLE_CHECK, {0, 0}, 0, 0 };
#else
        TBBUTTON tb = { IMAGE_TACK_OUT, IDC_SP_TACK, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0 };
#endif
        SendMessage(hwndTool, TB_SETIMAGELIST, 0, (LPARAM) himlImages);
        SendMessage(hwndTool, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(hwndTool, TB_SETBUTTONSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_SETBITMAPSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_ADDBUTTONS, 1, (LPARAM) &tb);
        }
    return (0);
    }


//
//  FUNCTION:   CSpoolerDlg::ExpandCollapse()
//
//  PURPOSE:    Takes care of showing and hiding the "details" part of the
//              error dialog.
//
//  PARAMETERS:
//      <in> fExpand - TRUE if we should be expanding the dialog.
//
void CSpoolerDlg::ExpandCollapse(BOOL fExpand, BOOL fSetFocus)
    {
    RECT rcSep;
    TCHAR szBuf[64];
    
    m_fExpanded = fExpand;
    
    GetWindowRect(GetDlgItem(m_hwnd, IDC_SP_SEPARATOR), &rcSep);
    
    if (!m_fExpanded)
        SetWindowPos(m_hwnd, 0, 0, 0, m_rcDlg.right - m_rcDlg.left, 
                     m_cyCollapsed, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    else
        SetWindowPos(m_hwnd, 0, 0, 0, m_rcDlg.right - m_rcDlg.left,
                     m_rcDlg.bottom - m_rcDlg.top, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    // Make sure the entire dialog is visible on the screen.  If not,
    // then push it up
    RECT rc;
    RECT rcWorkArea;
    GetWindowRect(m_hwnd, &rc);
    SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID) &rcWorkArea, 0);
    if (rc.bottom > rcWorkArea.bottom)
        {
        rc.top = max(0, (int) rc.top - (rc.bottom - rcWorkArea.bottom));
        
        SetWindowPos(m_hwnd, 0, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
                
    AthLoadString(m_fExpanded ? idsHideDetails : idsShowDetails, szBuf, 
                  ARRAYSIZE(szBuf));     
    SetDlgItemText(m_hwnd, IDC_SP_DETAILS, szBuf);

    if (fExpand)
        {
        switch (m_iTab)
            {
            case TAB_TASKS:
                UpdateLists(TRUE, FALSE, FALSE);
                break;
            case TAB_ERRORS:
                UpdateLists(FALSE, TRUE, FALSE);
                break;
            }
        }
    else
        UpdateLists(FALSE, FALSE, FALSE);

    // Raid-34387: Spooler: Closing details with ALT-D while focus is on a task disables keyboard input
    if (!fExpand && fSetFocus)
        SetFocus(GetDlgItem(m_hwnd, IDC_SP_DETAILS));
    }


//
//  FUNCTION:   CSpoolerDlg::OnTabChange()
//
//  PURPOSE:    Gets called in response to the user changing which tab is
//              the selected tab.  In response, we update which listview
//              is currently visible.
//
//  PARAMETERS:
//      <in> pnmhdr - Pointer to the notification information
//
void CSpoolerDlg::OnTabChange(LPNMHDR pnmhdr)
    {
    HWND hwndDisable1, hwndDisable2 = 0, hwndEnable;

    // Find out which tab is currently active
    m_iTab = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS));
    if (-1 == m_iTab)
        return;

    // Update which listview is visible
    switch (m_iTab)
        {
        case TAB_TASKS:
            // Hide the error listview, show the tasks list
            UpdateLists(TRUE, FALSE, FALSE);
            break;

        case TAB_ERRORS:
            // Hide the error listview, show the tasks list
            UpdateLists(FALSE, TRUE, FALSE);
            break;
        }
    }


//
//  FUNCTION:   CSpoolerDlg::UpdateLists()
//
//  PURPOSE:    Does the work of hiding and showing the lists when the
//              tab selection changes.
//
//  PARAMETERS:
//      <in> fEvents - TRUE to display the events list
//      <in> fErrors - TRUE to display the error list
//      <in> fHistory - TRUE to display the history list
//
void CSpoolerDlg::UpdateLists(BOOL fEvents, BOOL fErrors, BOOL fHistory)
    {
    if (IsWindow(m_hwndEvents))
        {
        EnableWindow(m_hwndEvents, fEvents);
        ::ShowWindow(m_hwndEvents, fEvents ? SW_SHOWNA : SW_HIDE);
        }

    if (IsWindow(m_hwndErrors))
        {
        EnableWindow(m_hwndErrors, fErrors);
        ::ShowWindow(m_hwndErrors, fErrors ? SW_SHOWNA : SW_HIDE);
        }
    }

void CSpoolerDlg::ToggleStatics(BOOL fIdle)
    {
    m_fIdle = fIdle;

    if (fIdle)
        {
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), TRUE);


        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), SW_SHOWNA);
        }
    else
        {
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), FALSE);

        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_GENERAL_PROG), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_SPECIFIC_PROG), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), SW_SHOWNA);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLETEXT), SW_HIDE);
        ::ShowWindow(GetDlgItem(m_hwnd, IDC_SP_IDLEICON), SW_HIDE);
        }
    }


void CSpoolerDlg::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
    POINT pt = {xPos, yPos};
    RECT  rcError;
    LBDATA *pData = NULL;

    // Check to see if the error window is visible
    if (!IsWindowVisible(m_hwndErrors))
        return;

    // Check to see if the click was within the error window
    GetWindowRect(m_hwndErrors, &rcError);
    if (!PtInRect(&rcError, pt))
        return;

    // Do the context menu
    HMENU hMenu = CreatePopupMenu();

    // Add a "Copy..." item
    TCHAR szRes[CCHMAX_STRINGRES]; 
    AthLoadString(idsCopyTT, szRes, ARRAYSIZE(szRes));

    // Add it to the menu
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, ID_COPY, szRes);

    // If the click is on an item in the listbox, then enable the command
    ScreenToClient(m_hwndErrors, &pt);
    DWORD iItem = (DWORD) SendMessage(m_hwndErrors, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));

    if (iItem != -1)
    {
        EnterCriticalSection(&m_cs);
        pData = (LBDATA *) ListBox_GetItemData(m_hwndErrors, iItem);
        LeaveCriticalSection(&m_cs);
    }
    
    if (iItem == -1 || NULL == pData || ((LBDATA*)-1) == pData)
        EnableMenuItem(hMenu, ID_COPY, MF_BYCOMMAND | MF_GRAYED);

    // Show the menu
    DWORD id;
    id = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_NONOTIFY,
                          xPos, yPos, m_hwndErrors, NULL);
    if (id == ID_COPY)
    {
        // Get the item data for the item they clicked on
        LPTSTR pszDup;

        EnterCriticalSection(&m_cs);

        // Set the height of the item
        if (NULL != pData && ((LBDATA*)-1) != pData)
        {
            // Dupe the string.  Clipboard owns the copy.
            pszDup = PszDupA(pData->pszText);

            // Put it on the clipboard
            OpenClipboard(m_hwndErrors);
            EmptyClipboard();
            SetClipboardData(CF_TEXT, pszDup);
            CloseClipboard();
        }

        LeaveCriticalSection(&m_cs);
    }

    if (hMenu)
        DestroyMenu(hMenu);
}

HRESULT CSpoolerDlg::QuerySwitchIdentities()
{
    DWORD_PTR   dwResult;

    if (!IsWindowEnabled(m_hwnd))
        return E_PROCESS_CANCELLED_SWITCH;

    if (m_pBindCtx)
    {
        dwResult = m_pBindCtx->QueryEndSession(0, ENDSESSION_LOGOFF);
        SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, dwResult);

        if (dwResult != TRUE)
            return E_PROCESS_CANCELLED_SWITCH;
    }

    return S_OK;
}

HRESULT CSpoolerDlg::SwitchIdentities()
{
    return S_OK;
}

HRESULT CSpoolerDlg::IdentityInformationChanged(DWORD dwType)
{
    return S_OK;
}


LRESULT CALLBACK CSpoolerDlg::ListSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_KEYDOWN && wParam == 'C')
    {
        if (0 > GetAsyncKeyState(VK_CONTROL))
        {
            int iSel = (int) SendMessage(hwnd, LB_GETCURSEL, 0, 0);
            if (LB_ERR != iSel)
            {
                LBDATA *pData = NULL;
                LPTSTR pszDup;

                // Set the height of the item
                if (NULL != (pData = (LBDATA *) ListBox_GetItemData(hwnd, iSel)))
                {
                    // Dupe the string.  Clipboard owns the copy.
                    pszDup = PszDupA(pData->pszText);

                    // Put it on the clipboard
                    OpenClipboard(hwnd);
                    EmptyClipboard();
                    SetClipboardData(CF_TEXT, pszDup);
                    CloseClipboard();
                }
            }
        }
    }

    WNDPROC wp = (WNDPROC) GetProp(hwnd, c_szWndProc);
    return (CallWindowProc(wp, hwnd, uMsg, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\spoolui.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     spoolui.h
//
//  PURPOSE:    Defines the spooler UI classes, prototypes, constants, etc.
//

#ifndef __SPOOLUI_H__
#define __SPOOLUI_H__

#include "spoolapi.h"
#include "msident.h"

class CNewsTask;


/////////////////////////////////////////////////////////////////////////////
// Spooler UI class
//
class CSpoolerDlg : 
        public ISpoolerUI,
        public IIdentityChangeNotify

    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    CSpoolerDlg();
    ~CSpoolerDlg();
    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    
    /////////////////////////////////////////////////////////////////////////
    // ISpoolerUI Interface
    STDMETHOD(Init)(HWND hwndParent);
    STDMETHOD(RegisterBindContext)(ISpoolerBindContext *pBindCtx);
    STDMETHOD(InsertEvent)(EVENTID eid, LPCSTR pszDescription,
                           LPCWSTR pwszConnection);
    STDMETHOD(InsertError)(EVENTID eid, LPCSTR pszError);
    STDMETHOD(UpdateEventState)(EVENTID eid, INT nImage, LPCSTR pszDescription,
                             LPCSTR pszStatus);
    STDMETHOD(SetProgressRange)(WORD wMax);
    STDMETHOD(IncrementProgress)(WORD wDelta);
    STDMETHOD(SetProgressPosition)(WORD wPos);
    STDMETHOD(SetGeneralProgress)(LPCSTR pszProgress);
    STDMETHOD(SetSpecificProgress)(LPCSTR pszProgress);
    STDMETHOD(SetAnimation)(int nAnimationId, BOOL fPlay);
    STDMETHOD(EnsureVisible)(EVENTID eid);
    STDMETHOD(ShowWindow)(int nCmdShow);
    STDMETHOD(GetWindow)(HWND *pHwnd);
    STDMETHOD(StartDelivery)(void); 
    STDMETHOD(GoIdle)(BOOL fErrors, BOOL fShutdown, BOOL fNoSync);
    STDMETHOD(ClearEvents)(void);
    STDMETHOD(SetTaskCounts)(DWORD cSucceeded, DWORD cTotal);
    STDMETHOD(IsDialogMessage)(LPMSG pMsg);
    STDMETHOD(Close)(void);
    STDMETHOD(ChangeHangupOption)(BOOL fEnable, DWORD dwOption);
    STDMETHOD(AreThereErrors)(void);
    STDMETHOD(Shutdown)(void);

    /////////////////////////////////////////////////////////////////////////
    // IIdentityChangeNotify Interface
    virtual STDMETHODIMP QuerySwitchIdentities();
    virtual STDMETHODIMP SwitchIdentities();
    virtual STDMETHODIMP IdentityInformationChanged(DWORD dwType);

    /////////////////////////////////////////////////////////////////////////
    // Dialog message handling
protected:
    static INT_PTR CALLBACK SpoolerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ListSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem);
    void OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpMeasureItem);
    void OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem);
    void OnClose(HWND hwnd);
    void OnDestroy(HWND hwnd);
    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
    void OnTabChange(LPNMHDR pnmhdr);

    
    /////////////////////////////////////////////////////////////////////////
    // UI Utility functions
    BOOL InitializeTabs(void);
    BOOL InitializeLists(void);
    BOOL InitializeAnimation(void);
    BOOL InitializeToolbar(void);
    void ExpandCollapse(BOOL fExpand, BOOL fSetFocus=TRUE);
    void UpdateLists(BOOL fEvents, BOOL fErrors, BOOL fHistory);
    void ToggleStatics(BOOL fIdle);

    /////////////////////////////////////////////////////////////////////////
    // Class member data
private:    
    ULONG                   m_cRef;         // Object reference count
    
    // Interfaces
    ISpoolerBindContext    *m_pBindCtx;     // Interface to communicate with the engine
    
    // Window handles
    HWND                    m_hwnd;         // Handle of the primary dialog window
    HWND                    m_hwndOwner;    // Handle of the window that parents the dialog
    HWND                    m_hwndEvents;   // Handle of the listview which displays the event list
    HWND                    m_hwndErrors;   // Handle of the listview which displays errors
    
    CRITICAL_SECTION        m_cs;           // Thread safety
    
    // Drawing info
    HIMAGELIST              m_himlImages;   // Images shared by the list views
    DWORD                   m_cxErrors;     // Width of the error list box

    // State
    BOOL                    m_fTack;        // TRUE if the tack is pressed
    BOOL                    m_iTab;         // Which tab currently has the foreground

    BOOL                    m_fExpanded;    // TRUE if the details part of the dialog is visible
    RECT                    m_rcDlg;        // Size of the fully expanded dialog
    DWORD                   m_cyCollapsed;  // Height of the collapsed dialog
    BOOL                    m_fIdle;        // TRUE if we're in an idle state
    BOOL                    m_fErrors;      // Are errors in the error box
    BOOL                    m_fShutdown;    // Are we in shutdown mode
    BOOL                    m_fSaveSize;    // Set to TRUE if we should persist our expanded / collapsed state
    
    // Strings
    TCHAR                   m_szCount[256];

    HICON                   m_hIcon,
                            m_hIconSm;    

    DWORD                   m_dwIdentCookie;
    };


/////////////////////////////////////////////////////////////////////////////
// Structures
//
typedef struct tagLBDATA 
    {
    LPTSTR  pszText;
    RECT    rcText;
    EVENTID eid;
    } LBDATA;

    
/////////////////////////////////////////////////////////////////////////////
// Images
//
enum {
    IMAGE_BLANK = 0,
    IMAGE_TACK_IN,
    IMAGE_TACK_OUT,
    IMAGE_ERROR,
    IMAGE_CHECK,
    IMAGE_BULLET,
    IMAGE_EXECUTE,
    IMAGE_WARNING,
    IMAGE_MAX
};

#define BULLET_WIDTH  20
#define BULLET_INDENT 2

/////////////////////////////////////////////////////////////////////////////
// Tabs on the details dialog
// 
enum { 
    TAB_TASKS,
    TAB_ERRORS,
    TAB_MAX
};

const int c_cxImage = 16;
const int c_cyImage = 16;
    
    
/////////////////////////////////////////////////////////////////////////////
// Resource ID's
//
#define IDC_SP_MINIMIZE                 1001
#define IDC_SP_STOP                     1002
#define IDC_SP_DETAILS                  1003
#define IDC_SP_SEPARATOR                1004
#define IDC_SP_ANIMATE                  1006
#define IDC_SP_PROGRESS_BAR             1007
#define IDC_SP_GENERAL_PROG             1009
#define IDC_SP_SPECIFIC_PROG            1010
#define IDC_SP_TABS                     1011
#define IDC_SP_SKIP_TASK                1012
#define IDC_SP_TACK                     1015
#define IDC_SP_OVERALL_STATUS           1016
#define IDC_SP_EVENTS                   1017
#define IDC_SP_ERRORS                   1018
#define IDC_SP_TOOLBAR                  1019
#define IDC_SP_HANGUP                   1020
#define IDC_SP_IDLETEXT                 1021
#define IDC_SP_IDLEICON                 1022
#define IDC_SP_PROGSTAT                 1023

#endif // __SPOOLUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\watchtsk.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     watchtsk.cpp
//
//  PURPOSE:    Implements the spooler task that is responsible for checking
//              for watched messages.
//


#include "pch.hxx"
#include "watchtsk.h"
#include "storutil.h"
#include "storsync.h"

ASSERTDATA

/////////////////////////////////////////////////////////////////////////////
// State Machine dispatch table
//

static const PFNWSTATEFUNC g_rgpfnState[WTS_MAX] = 
{
    NULL,
    NULL,
    &CWatchTask::_Watch_Init,
    &CWatchTask::_Watch_NextFolder,
    NULL,
    &CWatchTask::_Watch_Done
};

/////////////////////////////////////////////////////////////////////////////
// Local Data
//

static const TCHAR c_szWatchWndClass[] = "Outlook Express Watch Spooler Task Window";
static const TCHAR c_szThis[] = "this";

//
//  FUNCTION:   CWatchTask::CWatchTask()
//
//  PURPOSE:    Initializes the member variables of the object.
//
CWatchTask::CWatchTask()
{
    m_cRef = 1;

    m_fInited = FALSE;
    m_dwFlags = 0;
    *m_szAccount = 0;
    *m_szAccountId = 0;
    m_idAccount = 0;
    m_eidCur = 0;

    m_pBindCtx = NULL;
    m_pUI = NULL;
    m_pAccount = NULL;
    m_pServer = NULL;
    m_pCancel = NULL;

    m_idFolderCheck = FOLDERID_INVALID;
    m_rgidFolders = 0;
    m_cFolders = 0;
    m_hwnd = 0;
    m_hTimeout = 0;

    m_state = WTS_IDLE;
    m_fCancel = FALSE;
    m_cCurFolder = 0;
    m_cFailed = 0;
    m_tyOperation = SOT_INVALID;
};


//
//  FUNCTION:   CWatchTask::~CWatchTask()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
CWatchTask::~CWatchTask()    
{
    SafeRelease(m_pBindCtx);
    SafeRelease(m_pAccount);
    SafeRelease(m_pServer);
    SafeRelease(m_pCancel);
    SafeMemFree(m_rgidFolders);

    // Don't RIP
    if (m_hwnd)
        DestroyWindow(m_hwnd);
};

/////////////////////////////////////////////////////////////////////////////
// IUnknown
//

HRESULT CWatchTask::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) (ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_ISpoolerTask))
        *ppvObj = (LPVOID) (ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (LPVOID) (IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (LPVOID) (ITimeoutCallback *) this;

    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return S_OK;
}


ULONG CWatchTask::AddRef(void)
{
    return InterlockedIncrement((LONG *) &m_cRef);
}

ULONG CWatchTask::Release(void)
{
    InterlockedDecrement((LONG *) &m_cRef);
    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }
    return (m_cRef);
}


//
//  FUNCTION:   CWatchTask::Init()
//
//  PURPOSE:    Called by the spooler engine to tell us what type of task to 
//              execute and to provide us with a pointer to our bind context.
//
//  PARAMETERS:
//      <in> dwFlags  - Flags to tell us what types of things to do
//      <in> pBindCtx - Pointer to the bind context interface we are to use
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_ALREADYINITIALIZED
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT CWatchTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    HRESULT hr = S_OK;

    // Validate the args
    if (NULL == pBindCtx)
        return (E_INVALIDARG);

    // Check to see if we've already been initialized
    if (m_fInited)
    {
        hr = SP_E_ALREADYINITIALIZED;
        goto exit;
    }

    // Copy the flags for later
    m_dwFlags = dwFlags;

    // Copy the bind context pointer
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();

    // Register the window class
    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szWatchWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = _TaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szWatchWndClass;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    m_fInited = TRUE;

exit:
    return (hr);
}


//
//  FUNCTION:   CWatchTask::BuildEvents()
//
//  PURPOSE:    This method is called by the spooler engine telling us to create
//              and event list for the account specified.  
//
//  PARAMETERS:
//      <in> pAccount - Account object to build the event list for
//
//  RETURN VALUE:
//      SP_E_UNINITALIZED
//      E_INVALIDARG
//      S_OK
//
HRESULT CWatchTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, 
                                FOLDERID idFolder)
{
    HRESULT hr = S_OK;
    DWORD   dwPoll;
    DWORD   dw;

    // Validate the args
    if (pSpoolerUI == NULL || pAccount == NULL)
        return (E_INVALIDARG);

    // Make sure we've been initialized
    if (!m_fInited)
        return (SP_E_UNINITIALIZED);

    // Figure out which account this is
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId))))
        goto exit;

    // We only do this for accounts that have polling turned on
    if (0 == (m_dwFlags & DELIVER_NOSKIP))
    {
        if (FAILED(hr = pAccount->GetPropDw(AP_NNTP_POLL, &dw)) || dw == 0)
            goto exit;
    }

    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccount, ARRAYSIZE(m_szAccount))))
        goto exit;

    // Get the folder ID for this account from the store
    if (FAILED(hr = g_pStore->FindServerId(m_szAccountId, &m_idAccount)))
        goto exit;

    // Hold on to the UI object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Also hold on to the account
    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Also hold on to the folder ID
    m_idFolderCheck = idFolder;

    // Check to see if any folders that are part of this account have watched
    // messages within them.
    if (_ChildFoldersHaveWatched(m_idAccount))
    {
        TCHAR      szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        EVENTID    eid;

        // Create the string for the event description
        AthLoadString(idsCheckWatchedMessgesServer, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, m_szAccount);

        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, 0, pAccount, &eid);
    }
    else
    {
        // Do this so stuff at the end get's released correctly
        hr = E_FAIL;
    }

exit:
    // If we failed, we should clean up all the info we accumulated along 
    // the way so we don't accidentially think we're initalized later.
    if (FAILED(hr))
    {
        SafeRelease(m_pUI);
        SafeRelease(m_pAccount);
        SafeMemFree(m_rgidFolders);

        *m_szAccountId = 0;
        *m_szAccount = 0;
        m_idAccount = FOLDERID_INVALID;
    }

    return (hr);
}


//
//  FUNCTION:   CWatchTask::Execute()
//
//  PURPOSE:    Called by the spooler to when it's our turn to run.
//
HRESULT CWatchTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    // Double check that we're idle.
    Assert(m_state == WTS_IDLE && m_eidCur == NULL);

    // Make sure we're initialized
    if (FALSE == m_fInited || NULL == m_pUI)
        return (SP_E_UNINITIALIZED);

    // Copy the event ID
    m_eidCur = eid;

    // Create our internal window now
    if (!m_hwnd)
    {
        m_hwnd = CreateWindow(c_szWatchWndClass, NULL, WS_POPUP, 10, 10, 10, 10,
                              GetDesktopWindow(), NULL, g_hInst, this);
    }

    // Set up the UI to show progress for us
    m_pUI->SetProgressRange(1);

    AthLoadString(idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, m_szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    m_pUI->SetAnimation(idanDownloadNews, TRUE);

    // Start the state machine
    m_state = WTS_INIT;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return (S_OK);
}


//  
//  FUNCTION:   CWatchTask::CancelEvent()
//
//  PURPOSE:    Called by the spooler when it needs to free us before 
//              executing our events.  This gives us an opporutnity to free
//              our cookie.
//
HRESULT CWatchTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // We have no cookie now, so there's nothing to do.
    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::ShowProperties()
//
//  PURPOSE:    Not Implemented
//
HRESULT CWatchTask::ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CWatchTask::GetExtendedDetails()
//
//  PURPOSE:    Called by the spooler to get more information about an error
//              that has occured.
//
HRESULT CWatchTask::GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CWatchTask::Cancel()
//
//  PURPOSE:    Called by the spooler when the user presses the <Cancel> button
//              on the spooler dialog.
//
HRESULT CWatchTask::Cancel(void)
{
    // This happens if the user cancel's out of the Connect dialog
    if (m_state == WTS_IDLE)
        return (S_OK);

    // Drop the server connection
    if (m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_fCancel = TRUE;

    // Clean up
    m_state = WTS_END;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::IsDialogMessage()
//
//  PURPOSE:    Gives the task an opportunity to see window messages.
//
HRESULT CWatchTask::IsDialogMessage(LPMSG pMsg)
{
    return (S_FALSE);
}


//
//  FUNCTION:   CWatchTask::OnFlagsChanged()
//
//  PURPOSE:    Called by the spooler to notify us when current stae flags
//              have changed (such as visible, background etc)
//
HRESULT CWatchTask::OnFlagsChanged(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::OnBegin()
//
//  PURPOSE:    Called by the server object when it begins some operation we
//              requested.
//
HRESULT CWatchTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo,
                            IOperationCancel *pCancel)
{
    // Hold on to the operation type
    Assert(m_tyOperation == SOT_INVALID);
    m_tyOperation = tyOperation;

    if (tyOperation == SOT_GET_WATCH_INFO)
        m_cMsgs = 0;

    // Keep the pointer to the cancel object too
    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return (S_OK);
}


// 
//  FUNCTION:   CWatchTask::OnProgress()
//
//  PURPOSE:    Called by the server to give us progress on the current operation
//
HRESULT CWatchTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, 
                               DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog that might be present
    CallbackCloseTimeout(&m_hTimeout);

    if (tyOperation == SOT_GET_WATCH_INFO)
    {
        m_cMsgs = dwMax;
    }

    return (S_OK);
}


// 
//  FUNCTION:   CWatchTask::OnTimeout()
//
//  PURPOSE:    Get's called when we timeout waiting for a server response.  If
//              the user has the spooler window visible, we show the timeout
//              dialog.  If not, we eat it and fail.
//
HRESULT CWatchTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return (E_FAIL);

    // Display the dialog
    return (CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *) this, &m_hTimeout));
}


// 
//  FUNCTION:   CWatchTask::CanConnect()
//
//  PURPOSE:    Get's called when we need to dial the phone to connect to the
//              server.  If we have our UI visible, we go ahead and show the UI,
//              otherwise we eat it.
//
HRESULT CWatchTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;

    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}


// 
//  FUNCTION:   CWatchTask::OnLogonPrompt()
//
//  PURPOSE:    Get's called when we need to prompt the user for their password
//              to connect to the server.
//
HRESULT CWatchTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(S_FALSE);

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}


//
//  FUNCTION:   CWatchTask::OnComplete()
//
//  PURPOSE:    Called by the server when it completes a requested task.
//
HRESULT CWatchTask::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, 
                                   LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    LPCSTR pszError;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_tyOperation != tyOperation)
        return (S_OK);

    if (SOT_GET_WATCH_INFO == tyOperation)
    {
        if (FAILED(hrComplete))
        {
            // If an error detail was returned, insert that
            pszError = pErrorInfo->pszDetails;
            if (pszError == NULL || *pszError == 0)
                pszError = pErrorInfo->pszProblem;

            if (pszError != NULL && *pszError != 0)
                m_pUI->InsertError(m_eidCur, pszError);

            // Increment the failure count
            m_cFailed++;

        }

        m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

        m_state = WTS_NEXTFOLDER;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }

    // If the user canceled something just give up.
    if (IXP_E_USER_CANCEL == hrComplete)
    {
        Cancel();
    }

    // Reset some state information
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;

    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::OnPrompt()
//
//  PURPOSE:    Called by the server when it needs to do some funky SSL thing.
//
HRESULT CWatchTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}


//
//  FUNCTION:   CWatchTask::OnPrompt()
//
//  PURPOSE:    Called by the timeout dialog when the user responds.
//
HRESULT CWatchTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


//
//  FUNCTION:   CWatchTask::GetParentWindow()
//
//  PURPOSE:    Called by the server object when it needs to display some sort
//              of UI.  If we're running in the background, we fail the call.
//
HRESULT CWatchTask::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr;

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    if (m_pUI)
    {
        hr = m_pUI->GetWindow(phwndParent);
    }
    else
    {
        *phwndParent = NULL;
        hr = E_FAIL;
    }

    return(hr);
}


//
//  FUNCTION:   CWatchTask::_TaskWndProc()
//
//  PURPOSE:    Hidden window that processes messages for this task.
//
LRESULT CALLBACK CWatchTask::_TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                          LPARAM lParam)
{
    CWatchTask *pThis = (CWatchTask *) GetProp(hwnd, c_szThis);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
            pThis = (CWatchTask *) pcs->lpCreateParams;
            SetProp(hwnd, c_szThis, (LPVOID) pThis);
            return (0);
        }

        case NTM_NEXTSTATE:
            if (pThis)
            {
                pThis->AddRef();
                pThis->_NextState();
                pThis->Release();
            }
            return (0);

        case WM_DESTROY:
            RemoveProp(hwnd, c_szThis);
            break;
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CWatchTask::_NextState()
//
//  PURPOSE:    Executes the function for the current state
//
void CWatchTask::_NextState(void)
{
    if (NULL != g_rgpfnState[m_state])
        (this->*(g_rgpfnState[m_state]))();
}


//
//  FUNCTION:   CWatchTask::_Watch_Init()
//
//  PURPOSE:    When we need to start doing our thing.  This function creates
//              and initializes any objects we need to do our job and starts
//              looking at the first group.
//
HRESULT CWatchTask::_Watch_Init(void)
{
    FOLDERINFO fi;
    HRESULT    hr;

    // Get information about the server we're checking
    if (SUCCEEDED(hr = g_pStore->GetFolderInfo(m_idAccount, &fi)))
    {
        // With that information, create the server object
        hr = CreateMessageServerType(fi.tyFolder, &m_pServer);
        g_pStore->FreeRecord(&fi);            

        if (SUCCEEDED(hr))
        {
            // Initialize the server object
            if (SUCCEEDED(m_pServer->Initialize(g_pLocalStore, m_idAccount, 
                                                NULL, FOLDERID_INVALID)))
            {                
                // At this point we have all the information we need.  Initialize
                // the progress UI.
                TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

                AthLoadString(idsCheckingWatchedProgress, szRes, ARRAYSIZE(szRes));
                wsprintf(szBuf, szRes, m_szAccount);

                m_pUI->SetGeneralProgress(szBuf);
                m_pUI->SetProgressRange((WORD) m_cFolders);
                
                m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING_NEWS, 0);                
                
                // Go ahead and start with the first folder.
                m_cCurFolder = -1;
                m_cFailed = 0;
                m_state = WTS_NEXTFOLDER;

                PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0); 
                return (S_OK);
            }
        }
    }

    // If we got here, we didn't succeed in initializing the required stuff.
    // We need to log the error and bail.
    m_pUI->InsertError(m_eidCur, MAKEINTRESOURCE(idsErrFailedWatchInit));
    m_cFailed = m_cFolders;

    m_state = WTS_END;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    SafeRelease(m_pServer);
    return (E_OUTOFMEMORY);
}


//
//  FUNCTION:   CWatchTask::_Watch_NextFolder()
//
//  PURPOSE:    Requests the watched information from the server object for the
//              next folder in our list of folders to check.
//
HRESULT CWatchTask::_Watch_NextFolder(void)
{
    HRESULT     hr = E_FAIL;
    FOLDERINFO  fi;
    TCHAR       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    // Loop until we succeed
    while (TRUE)
    {
        m_cCurFolder++;

        // Check to see if we've reached the end
        if (m_cCurFolder >= m_cFolders)
        {
            m_state = WTS_END;
            PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
            return (S_OK);
        }

        // Update the progress UI.  If we fail to get the folder name, it's not
        // fatal, just keep truckin.
        if (SUCCEEDED(g_pStore->GetFolderInfo(m_rgidFolders[m_cCurFolder], &fi)))
        {
            AthLoadString(idsCheckingWatchedFolderProg, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, fi.pszName);
            m_pUI->SetSpecificProgress(szBuf);

            g_pStore->FreeRecord(&fi);
        }

        // Open the store folder for this next folder
        hr = E_FAIL;
        IMessageFolder *pFolder;
        hr = g_pStore->OpenFolder(m_rgidFolders[m_cCurFolder], NULL, OPEN_FOLDER_NOCREATE, &pFolder);
        if (SUCCEEDED(hr))
        {
            IServiceProvider *pSP;

            if (SUCCEEDED(pFolder->QueryInterface(IID_IServiceProvider, (LPVOID *) &pSP)))
            {
                IMessageFolder *pFolderReal;

                if (SUCCEEDED(hr = pSP->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (LPVOID *) &pFolderReal)))
                {
                    m_pServer->ResetFolder(pFolderReal, m_rgidFolders[m_cCurFolder]);

                    // Request the information
                    hr = m_pServer->GetWatchedInfo(m_rgidFolders[m_cCurFolder], (IStoreCallback *) this);
                    if (E_PENDING == hr)
                    {
                        m_state = WTS_RESP;
                    }

                    pFolderReal->Release();
                }
                pSP->Release();
            }
            pFolder->Release();
        }

        if (E_PENDING == hr)
            return (S_OK);
    }

    if (FAILED(hr))
    {
        // If we got here, something failed
        m_cFailed++;
    }

    m_pUI->IncrementProgress(1);
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return (E_FAIL);
}


//
//  FUNCTION:   CWatchTask::_Watch_Done()
//
//  PURPOSE:    Called when we're done getting all our watched stuff.  This 
//              function primarily is used to clean stuff up.
//
HRESULT CWatchTask::_Watch_Done(void)
{
    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

    // Tell the spooler if we failed or not
    if (m_fCancel)
    {
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
        m_fCancel = FALSE;
    }
    else if (m_cFailed == m_cFolders)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_cFailed == 0)
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);

    if (m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION | MSGSVRF_HANDS_OFF_SERVER);

    SafeRelease(m_pServer);
    SafeMemFree(m_rgidFolders);
    SafeRelease(m_pAccount);
    SafeRelease(m_pUI);

    m_cFolders = 0;
    m_cFailed = 0;
    m_eidCur = 0;
    m_state = WTS_IDLE;

    return (S_OK);
}


//
//  FUNCTION:   CWatchTask::_ChildFoldersHaveWatched()
//
//  PURPOSE:    Checks to see if any of the folders which are a child of the 
//              given folder have any messages that are being watched.
//
BOOL CWatchTask::_ChildFoldersHaveWatched(FOLDERID id)
{
    HRESULT   hr = S_OK;
    FOLDERID *rgidFolderList = 0;
    DWORD     dwAllocated;
    DWORD     dwUsed;
    DWORD     i;

    // If the user want's us to check all folders, get a list of 'em
    if (m_idFolderCheck == FOLDERID_INVALID)
    {
        // Get a list of all the folders which are a child of this folder
        hr = FlattenHierarchy(g_pStore, id, FALSE, TRUE, &rgidFolderList, &dwAllocated,
                              &dwUsed);
        if (FAILED(hr))
            goto exit;
    }
    else
    {
        if (!MemAlloc((LPVOID *) &rgidFolderList, sizeof(FOLDERID) * 1))
            return (FALSE);

        *rgidFolderList = m_idFolderCheck;
        dwUsed = 1;
    }

    // Check to see if we got any folders back
    m_cFolders = 0;
    if (dwUsed)
    {
        // Allocate a new array that will in the end only contain the folders we 
        // care about.    
        if (!MemAlloc((LPVOID *) &m_rgidFolders, sizeof(FOLDERID) * dwUsed))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Initialize the stored list
        ZeroMemory(m_rgidFolders, sizeof(FOLDERID) * dwUsed);
        m_cFolders = 0;

        // Now loop through the array 
        for (i = 0; i < dwUsed; i++)
        {
            if (_FolderContainsWatched(rgidFolderList[i]))
            {
                m_rgidFolders[m_cFolders] = rgidFolderList[i];
                m_cFolders++;
            }
        }
    }

exit:
    SafeMemFree(rgidFolderList);

    if (FAILED(hr))
    {
        SafeMemFree(m_rgidFolders);
        m_cFolders = 0;
    }

    return (m_cFolders != 0);
}


//
//  FUNCTION:   CWatchTask::_FolderContainsWatched()
//
//  PURPOSE:    Checks to see if the specified folder has any messages which are
//              being watched.
//
BOOL CWatchTask::_FolderContainsWatched(FOLDERID id)
{
    FOLDERINFO      rFolderInfo = {0};
    BOOL            fReturn = FALSE;

    // Get the folder info struct
    if (SUCCEEDED(g_pStore->GetFolderInfo(id, &rFolderInfo)))
    {
        fReturn = rFolderInfo.cWatched;
        g_pStore->FreeRecord(&rFolderInfo);
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\cleanup.h ===
//--------------------------------------------------------------------------
// Cleanup.h
//--------------------------------------------------------------------------
#ifndef __CLEANUP_H
#define __CLEANUP_H

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT StartBackgroundStoreCleanup(DWORD dwDelaySeconds);
HRESULT CloseBackgroundStoreCleanup(void);

#endif // __CLEANUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\taskutil.cpp ===
// --------------------------------------------------------------------------------
// TaskUtil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "spoolapi.h"
#include "imnxport.h"
#include "taskutil.h"
#include "strconst.h"
#include "resource.h"
#include "passdlg.h"
#include "xpcomm.h"
#include "timeout.h"
#include "thormsgs.h"
#include "mimeutil.h"
#include "flagconv.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Array of mappings between IXPTYPE and protocol name
// --------------------------------------------------------------------------------
static const LPSTR g_prgszServers[IXP_HTTPMail + 1] = { 
    "NNTP",
    "SMTP",
    "POP3",
    "IMAP",
    "RAS",
    "HTTPMail"
};

// --------------------------------------------------------------------------------
// LOGONINFO
// --------------------------------------------------------------------------------
typedef struct tagLOGFONINFO {
    LPSTR           pszAccount;                     // Account
    LPSTR           pszServer;                      // Server Name
    LPSTR           pszUserName;                    // User Name
    LPSTR           pszPassword;                    // Passowrd
    DWORD           fSavePassword;                  // Save Password
    DWORD           fAlwaysPromptPassword;          // "Always prompt for password"
} LOGONINFO, *LPLOGONINFO;

// --------------------------------------------------------------------------------
// TASKERROR
// --------------------------------------------------------------------------------
static const TASKERROR c_rgTaskErrors[] = {
    { SP_E_CANTLOCKUIDLCACHE,               idshrLockUidCacheFailed,                NULL, TRUE,   TASKRESULT_FAILURE  },
    { IXP_E_TIMEOUT,                        IDS_IXP_E_TIMEOUT,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSASYSNOTREADY,         IDS_IXP_E_CONN,                         NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAEINPROGRESS,         IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_FAILED_WSASTARTUP,      IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAEFAULT,              IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAEPROCLIM,            IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_WINSOCK_WSAVERNOTSUPPORTED,     IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP,    NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_LOAD_SICILY_FAILED,             IDS_IXP_E_LOAD_SICILY_FAILED,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_INVALID_CERT_CN,                IDS_IXP_E_INVALID_CERT_CN,              NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_INVALID_CERT_DATE,              IDS_IXP_E_INVALID_CERT_DATE,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONN,                           IDS_IXP_E_CONN,                         NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CANT_FIND_HOST,                 IDS_IXP_E_CANT_FIND_HOST,               NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_FAILED_TO_CONNECT,              IDS_IXP_E_FAILED_TO_CONNECT,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONNECTION_DROPPED,             IDS_IXP_E_CONNECTION_DROPPED,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONN_RECV,                      IDS_IXP_E_SOCKET_READ_ERROR,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_READ_ERROR,              IDS_IXP_E_SOCKET_READ_ERROR,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_CONN_SEND,                      IDS_IXP_E_SOCKET_WRITE_ERROR,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_WRITE_ERROR,             IDS_IXP_E_SOCKET_WRITE_ERROR,           NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_INIT_ERROR,              IDS_IXP_E_SOCKET_INIT_ERROR,            NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SOCKET_CONNECT_ERROR,           IDS_IXP_E_SOCKET_CONNECT_ERROR,         NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_INVALID_ACCOUNT,                IDS_IXP_E_INVALID_ACCOUNT,              NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_USER_CANCEL,                    IDS_IXP_E_USER_CANCEL,                  NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SICILY_LOGON_FAILED,            IDS_IXP_E_SICILY_LOGON_FAILED,          NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SMTP_RESPONSE_ERROR,            IDS_IXP_E_SMTP_RESPONSE_ERROR,          NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SMTP_UNKNOWN_RESPONSE_CODE,     IDS_IXP_E_SMTP_UNKNOWN_RESPONSE_CODE,   NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_SMTP_REJECTED_RECIPIENTS,       IDS_IXP_E_SMTP_REJECTED_RECIPIENTS,     NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX,   IDS_IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX, NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_NO_SENDER,                 IDS_IXP_E_SMTP_NO_SENDER,               NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_NO_RECIPIENTS,             IDS_IXP_E_SMTP_NO_RECIPIENTS,           NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { SP_E_SMTP_CANTOPENMESSAGE,            IDS_SP_E_SMTP_CANTOPENMESSAGE,          NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { SP_E_SENDINGSPLITGROUP,               IDS_SP_E_SENDINGSPLITGROUP,             NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_REJECTED_SENDER,           IDS_IXP_E_SMTP_REJECTED_SENDER,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_POP3_RESPONSE_ERROR,            IDS_IXP_E_POP3_RESPONSE_ERROR,          NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_POP3_INVALID_USER_NAME,         IDS_IXP_E_POP3_INVALID_USER_NAME,       NULL, FALSE,  TASKRESULT_FAILURE  },
    { IXP_E_POP3_INVALID_PASSWORD,          IDS_IXP_E_POP3_INVALID_PASSWORD,        NULL, FALSE,  TASKRESULT_FAILURE  },
    { SP_E_CANTLEAVEONSERVER,               idshrCantLeaveOnServer,                 NULL, FALSE,  TASKRESULT_FAILURE  },
    { E_OUTOFMEMORY,                        IDS_E_OUTOFMEMORY,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { ERROR_NOT_ENOUGH_MEMORY,              IDS_E_OUTOFMEMORY,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { ERROR_OUTOFMEMORY,                    IDS_E_OUTOFMEMORY,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { hrDiskFull,                           idsDiskFull,                            NULL, FALSE,  TASKRESULT_FAILURE  },
    { ERROR_DISK_FULL,                      idsDiskFull,                            NULL, FALSE,  TASKRESULT_FAILURE  },
    { DB_E_DISKFULL,                        idsDiskFull,                            NULL, FALSE,  TASKRESULT_FAILURE  },
    { DB_E_ACCESSDENIED,                    idsDBAccessDenied,                      NULL, FALSE,  TASKRESULT_FAILURE  },
    { SP_E_POP3_RETR,                       IDS_SP_E_RETRFAILED,                    NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_SMTP_552_STORAGE_OVERFLOW,      IDS_IXP_E_SMTP_552_STORAGE_OVERFLOW,    NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { SP_E_CANT_MOVETO_SENTITEMS,           IDS_SP_E_CANT_MOVETO_SENTITEMS,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_RESPONSE_ERROR,            idsNNTPErrUnknownResponse,              NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_NNTP_NEWGROUPS_FAILED,          idsNNTPErrNewgroupsFailed,              NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_LIST_FAILED,               idsNNTPErrListFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_LISTGROUP_FAILED,          idsNNTPErrListGroupFailed,              NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_GROUP_FAILED,              idsNNTPErrGroupFailed,                  NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_GROUP_NOTFOUND,            idsNNTPErrGroupNotFound,                NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_ARTICLE_FAILED,            idsNNTPErrArticleFailed,                NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_HEAD_FAILED,               idsNNTPErrHeadFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_BODY_FAILED,               idsNNTPErrBodyFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_POST_FAILED,               idsNNTPErrPostFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_NEXT_FAILED,               idsNNTPErrNextFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED }, 
    { IXP_E_NNTP_DATE_FAILED,               idsNNTPErrDateFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_HEADERS_FAILED,            idsNNTPErrHeadersFailed,                NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_XHDR_FAILED,               idsNNTPErrXhdrFailed,                   NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_NNTP_INVALID_USERPASS,          idsNNTPErrPasswordFailed,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SECURE_CONNECT_FAILED,          idsFailedToConnectSecurely,             NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_USE_PROXY,                 IDS_IXP_E_HTTP_USE_PROXY,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_BAD_REQUEST,               IDS_IXP_E_HTTP_BAD_REQUEST,             NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_UNAUTHORIZED,              IDS_IXP_E_HTTP_UNAUTHORIZED,            NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_FORBIDDEN,                 IDS_IXP_E_HTTP_FORBIDDEN,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_NOT_FOUND,                 IDS_IXP_E_HTTP_NOT_FOUND,               NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_METHOD_NOT_ALLOW,          IDS_IXP_E_HTTP_METHOD_NOT_ALLOW,        NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_NOT_ACCEPTABLE,            IDS_IXP_E_HTTP_NOT_ACCEPTABLE,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_PROXY_AUTH_REQ,            IDS_IXP_E_HTTP_PROXY_AUTH_REQ,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_REQUEST_TIMEOUT,           IDS_IXP_E_HTTP_REQUEST_TIMEOUT,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_CONFLICT,                  IDS_IXP_E_HTTP_CONFLICT,                NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_GONE,                      IDS_IXP_E_HTTP_GONE,                    NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_LENGTH_REQUIRED,           IDS_IXP_E_HTTP_LENGTH_REQUIRED,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_PRECOND_FAILED,            IDS_IXP_E_HTTP_PRECOND_FAILED,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_INTERNAL_ERROR,            IDS_IXP_E_HTTP_INTERNAL_ERROR,          NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_NOT_IMPLEMENTED,           IDS_IXP_E_HTTP_NOT_IMPLEMENTED,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_BAD_GATEWAY,               IDS_IXP_E_HTTP_BAD_GATEWAY,             NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_SERVICE_UNAVAIL,           IDS_IXP_E_HTTP_SERVICE_UNAVAIL,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_HTTP_GATEWAY_TIMEOUT,           IDS_IXP_E_HTTP_GATEWAY_TIMEOUT,         NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_VERS_NOT_SUP,              IDS_IXP_E_HTTP_VERS_NOT_SUP,            NULL, FALSE,  TASKRESULT_FAILURE },
    { SP_E_HTTP_NOSENDMSGURL,               idsHttpNoSendMsgUrl,                    NULL, FALSE,  TASKRESULT_FAILURE },
    { SP_E_HTTP_SERVICEDOESNTWORK,          idsHttpServiceDoesntWork,               NULL, FALSE,  TASKRESULT_FAILURE },    
    { SP_E_HTTP_NODELETESUPPORT,            idsHttpNoDeleteSupport,                 NULL, FALSE,  TASKRESULT_FAILURE },    
    { SP_E_HTTP_CANTMODIFYMSNFOLDER,        idsCantModifyMsnFolder,                 NULL, FALSE,  TASKRESULT_EVENTFAILED },
    { IXP_E_HTTP_INSUFFICIENT_STORAGE,      idsHttpNoSpaceOnServer,                 NULL, FALSE,  TASKRESULT_FAILURE },    
    { STORE_E_IMAP_HC_NOSLASH,              idsIMAPHC_NoSlash,                      NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_IMAP_HC_NOBACKSLASH,          idsIMAPHC_NoBackSlash,                  NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_IMAP_HC_NODOT,                idsIMAPHC_NoDot,                        NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_IMAP_HC_NOHC,                 idsIMAPHC_NoHC,                         NULL, FALSE,  TASKRESULT_FAILURE },
    { STORE_E_NOTRANSLATION,                idsIMAPNoTranslatableInferiors,         NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SMTP_530_STARTTLS_REQUIRED,     idsSMTPSTARTTLSRequired,                NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SMTP_NO_STARTTLS_SUPPORT,       idsSMTPNoSTARTTLSSupport,               NULL, FALSE,  TASKRESULT_FAILURE },
    { IXP_E_SMTP_454_STARTTLS_FAILED,       idsSMTPSTARTTLSFailed,                  NULL, FALSE,  TASKRESULT_FAILURE },
};

// --------------------------------------------------------------------------------
// TaskUtil_LogonPromptDlgProc
// --------------------------------------------------------------------------------
BOOL CALLBACK TaskUtil_LogonPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK TaskUtil_TimeoutPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// --------------------------------------------------------------------------------
// TaskUtil_HrWriteQuoted
// --------------------------------------------------------------------------------
HRESULT TaskUtil_HrWriteQuoted(IStream *pStream, LPCSTR pszName, LPCSTR pszData, BOOL fQuoted, 
    LPCSTR *ppszSep)
{
    // Locals
    HRESULT     hr=S_OK;

    // Write - Separator
    CHECKHR(hr = pStream->Write(*ppszSep, lstrlen(*ppszSep), NULL));

    // Change Separator
    *ppszSep = g_szCommaSpace;

    // Write - 'Account Name:'
    CHECKHR(hr = pStream->Write(pszName, lstrlen(pszName), NULL));

    // Write Space
    CHECKHR(hr = pStream->Write(g_szSpace, lstrlen(g_szSpace), NULL));

    // Write single quote
    if (fQuoted)
        CHECKHR(hr = pStream->Write(g_szQuote, lstrlen(g_szQuote), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pszData, lstrlen(pszData), NULL));

    // Write End Quote
    if (fQuoted)
        CHECKHR(hr = pStream->Write(g_szQuote, lstrlen(g_szQuote), NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// TaskUtil_HrBuildErrorInfoString
// --------------------------------------------------------------------------------
HRESULT TaskUtil_HrBuildErrorInfoString(LPCSTR pszProblem, IXPTYPE ixptype, LPIXPRESULT pResult,
    LPINETSERVER pServer, LPCSTR pszSubject, LPSTR *ppszInfo, ULONG *pcchInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[255];
    CHAR            szNumber[50];
    LPCSTR          pszSep=c_szEmpty;
    CByteStream     cStream;

    // Init
    *ppszInfo = NULL;
    *pcchInfo = 0;

    // Write out the problem
    AssertSz(NULL != pszProblem, "Hey, what's your problem, buddy?");
    if (pszProblem) {
        CHECKHR(hr = cStream.Write(pszProblem, lstrlen(pszProblem), NULL));
        CHECKHR(hr = cStream.Write(g_szSpace, lstrlen(g_szSpace), NULL));
    }

    // Subject: 'Subject'
    if (pszSubject)
    {
        LOADSTRING(idsSubject, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pszSubject, TRUE, &pszSep));
    }

     // Account: 'Account Name'
    if (!FIsEmptyA(pServer->szAccount))
    {
        LOADSTRING(idsDetail_Account, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pServer->szAccount, TRUE, &pszSep));
    }

    // Server: 'Server Name'
    if (!FIsEmptyA(pServer->szServerName))
    {
        LOADSTRING(idsDetail_Server, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pServer->szServerName, TRUE, &pszSep));
    }

    // Protocol: 'SMTP'
    LOADSTRING(idsDetail_Protocol, szRes);
    CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, g_prgszServers[ixptype], FALSE, &pszSep));

    // Server Response: 'Text'
    if (pResult->pszResponse)
    {
        LOADSTRING(idsDetail_ServerResponse, szRes);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, pResult->pszResponse, TRUE, &pszSep));
    }

    // Port: 'Port'
    LOADSTRING(idsDetail_Port, szRes);
    wsprintf(szNumber, "%d", pServer->dwPort);
    CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));

    // Secure: 'Yes or No'
    LOADSTRING(idsDetail_Secure, szRes);
    if (pServer->fSSL)
        LOADSTRING(idsOui, szNumber);
    else
        LOADSTRING(idsNon, szNumber);
    CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));

    // Server Error: 'number'
    if (pResult->uiServerError)
    {
        LOADSTRING(idsServerErrorNumber, szRes);
        wsprintf(szNumber, "%d", pResult->uiServerError);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Server Error: '0x00000000'
    else if (pResult->hrServerError)
    {
        LOADSTRING(idsServerErrorNumber, szRes);
        wsprintf(szNumber, "0x%0X", pResult->hrServerError);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Socket Error: 'number'
    if (pResult->dwSocketError)
    {
        LOADSTRING(idsSocketErrorNumber, szRes);
        wsprintf(szNumber, "%d", pResult->dwSocketError);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Error Number: 'Text'
    if (pResult->hrResult)
    {
        LOADSTRING(idsDetail_ErrorNumber, szRes);
        wsprintf(szNumber, "0x%0X", pResult->hrResult);
        CHECKHR(hr = TaskUtil_HrWriteQuoted(&cStream, szRes, szNumber, FALSE, &pszSep));
    }

    // Acquire the string from cStream
    CHECKHR(hr = cStream.HrAcquireStringA(pcchInfo, ppszInfo, ACQ_DISPLACE));

exit:
    if (FAILED(hr)) {
        // If we failed, just return the pszProblem string (duped), if possible
        *ppszInfo = StringDup(pszProblem);
        if (NULL != *ppszInfo) {
            *pcchInfo = lstrlen(*ppszInfo);
            hr = S_FALSE;
        }
        else {            
            *pcchInfo = 0;
            hr = E_OUTOFMEMORY;
        }
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// PTaskUtil_GetError
// --------------------------------------------------------------------------------
LPCTASKERROR PTaskUtil_GetError(HRESULT hrResult, ULONG *piError)
{
    // Look for the hresult
    for (ULONG i=0; i<ARRAYSIZE(c_rgTaskErrors); i++)
    {
        // Is this It
        if (hrResult == c_rgTaskErrors[i].hrResult)
        {
            // Done
            if (piError)
                *piError = i;
            return(&c_rgTaskErrors[i]);
        }
    }

    // Done
    return(NULL);
}


// --------------------------------------------------------------------------------
// TaskUtil_SplitStoreError
// --------------------------------------------------------------------------------
void TaskUtil_SplitStoreError(IXPRESULT *pixpResult, INETSERVER *pInetServer,
                              STOREERROR *pErrorInfo)
{
    if (NULL == pixpResult || NULL == pInetServer || NULL == pErrorInfo)
    {
        Assert(FALSE);
        return;
    }

    // Fill out IXPRESULT from STOREERROR
    ZeroMemory(pixpResult, sizeof(*pixpResult));
    pixpResult->hrResult = pErrorInfo->hrResult;
    pixpResult->pszResponse = pErrorInfo->pszDetails;
    pixpResult->uiServerError = pErrorInfo->uiServerError;
    pixpResult->hrServerError = pErrorInfo->hrServerError;
    pixpResult->dwSocketError = pErrorInfo->dwSocketError;
    pixpResult->pszProblem = pErrorInfo->pszProblem;

    // Fill out INETSERVER structure from STOREERROR
    ZeroMemory(pInetServer, sizeof(*pInetServer));
    if (NULL != pErrorInfo->pszAccount)
        lstrcpyn(pInetServer->szAccount, pErrorInfo->pszAccount, sizeof(pInetServer->szAccount));

    if (NULL != pErrorInfo->pszUserName)
        lstrcpyn(pInetServer->szUserName, pErrorInfo->pszUserName, sizeof(pInetServer->szUserName));

    pInetServer->szPassword[0] = '\0';

    if (NULL != pErrorInfo->pszServer)
        lstrcpyn(pInetServer->szServerName, pErrorInfo->pszServer, sizeof(pInetServer->szServerName));

    if (NULL != pErrorInfo->pszConnectoid)
        lstrcpyn(pInetServer->szConnectoid, pErrorInfo->pszConnectoid, sizeof(pInetServer->szConnectoid));

    pInetServer->rasconntype = pErrorInfo->rasconntype;
    pInetServer->dwPort = pErrorInfo->dwPort;
    pInetServer->fSSL = pErrorInfo->fSSL;
    pInetServer->fTrySicily = pErrorInfo->fTrySicily;
    pInetServer->dwTimeout = 30; // Whatever, I don't think it's used
    pInetServer->dwFlags = 0;
}



TASKRESULTTYPE TaskUtil_InsertTransportError(BOOL fCanShowUI, ISpoolerUI *pUI, EVENTID eidCurrent,
                                             STOREERROR *pErrorInfo, LPSTR pszOpDescription,
                                             LPSTR pszSubject)
{
    char            szBuf[CCHMAX_STRINGRES * 2];
    LPSTR           pszEnd; // Points to end of string being constructed in szBuf
    IXPRESULT       ixpResult;
    INETSERVER      rServer;
    HWND            hwndParent;

    if (NULL == pErrorInfo)
    {
        Assert(FALSE);
        return TASKRESULT_FAILURE;
    }

    // If operation description is provided, copy it first
    szBuf[0] = '\0';
    pszEnd = szBuf;
    if (NULL != pszOpDescription)
    {
        if (0 == HIWORD(pszOpDescription))
            pszEnd += LoadString(g_hLocRes, LOWORD(pszOpDescription), szBuf, sizeof(szBuf));
        else
        {
            lstrcpyn(szBuf, pszOpDescription, sizeof(szBuf));
            pszEnd += lstrlen(szBuf);
        }
    }

    // Append the transport error description to our error string buffer
    if ((pszEnd - szBuf) < (sizeof(szBuf) - 1))
    {
        *pszEnd = ' ';
        pszEnd += 1;
        *pszEnd = '\0';
    }

    if (NULL != pErrorInfo->pszProblem)
        lstrcpyn(pszEnd, pErrorInfo->pszProblem, sizeof(szBuf) - (int) (pszEnd - szBuf));


    // Now generate and insert the full error information
    TaskUtil_SplitStoreError(&ixpResult, &rServer, pErrorInfo);
    ixpResult.pszProblem = szBuf;

    // Get Window
    if (NULL == pUI || FAILED(pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    return TaskUtil_FBaseTransportError(pErrorInfo->ixpType, eidCurrent, &ixpResult,
        &rServer, pszSubject, pUI, fCanShowUI, hwndParent);
} // TaskUtil_InsertTransportError



// --------------------------------------------------------------------------------
// TaskUtil_FBaseTransportError
// --------------------------------------------------------------------------------
TASKRESULTTYPE TaskUtil_FBaseTransportError(IXPTYPE ixptype, EVENTID idEvent, LPIXPRESULT pResult, 
    LPINETSERVER pServer, LPCSTR pszSubject, ISpoolerUI *pUI, BOOL fCanShowUI, HWND hwndParent)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCTASKERROR pError=NULL;
    TASKRESULTTYPE  taskresult=TASKRESULT_FAILURE;
    CHAR            szRes[255];
    LPSTR           pszInfo=NULL;
    ULONG           cchInfo;
    LPSTR           pszError=NULL;
    LPSTR           pszFull=NULL;
    BOOL            fShowUI=FALSE;
    LPSTR           pszTempProb=pResult->pszProblem;
    ULONG           i;

    // Invalid Arg
    Assert(pResult && FAILED(pResult->hrResult) && pServer && ixptype <= IXP_HTTPMail);

    // Find the Error
    pError = PTaskUtil_GetError(pResult->hrResult, &i);

    // Found it
    if (pError)
    {
        // If I have hard-coded a string
        if (pError->pszError)
        {
            // Just copy the string
            lstrcpyn(szRes, pError->pszError, ARRAYSIZE(szRes));

            // Set pszError
            pszError = szRes;
        }

        // Rejected Recips or Rejected Sender
        else if (IXP_E_SMTP_REJECTED_RECIPIENTS == pError->hrResult || IXP_E_SMTP_REJECTED_SENDER == pError->hrResult)
        {
            // Locals
            CHAR szMessage[1024];

            // Better Succeed
            SideAssert(LoadString(g_hLocRes, pError->ulStringId, szRes, ARRAYSIZE(szRes)) > 0);

            // Format the message
            if (pResult->pszProblem && '\0' != *pResult->pszProblem)
            {
                // Use pszProblem, it probably contains the email address, I hope
                wsprintf(szMessage, szRes, pResult->pszProblem);

                // Temporarily NULL it out so that we don't use it later
                pResult->pszProblem = NULL;
            }
            else
            {
                // Locals
                CHAR szUnknown[255];

                // Load '<Unknown>'
                SideAssert(LoadString(g_hLocRes, idsUnknown, szUnknown, ARRAYSIZE(szUnknown)) > 0);

                // Format the error
                wsprintf(szMessage, szRes, szUnknown);
            }

            // Set pszError
            pszError = szMessage;
        }

        // Otherwise, load the string
        else
        {
            // Better Succeed
            SideAssert(LoadString(g_hLocRes, pError->ulStringId, szRes, ARRAYSIZE(szRes)) > 0);

            // Set pszError
            pszError = szRes;
        }

        // Set the task result type
        taskresult = c_rgTaskErrors[i].tyResult;

        // Show UI
        fShowUI = pError->fShowUI;
    }

    // Otherwise, default
    else
    {
        // Load the unknwon string
        SideAssert(LoadString(g_hLocRes, IDS_IXP_E_UNKNOWN, szRes, ARRAYSIZE(szRes)) > 0);

        // Set the Error source
        pszError = szRes;
    }

    // No Error
    if (NULL == pszError)
        goto exit;

    // If there is a pszProblem, use it
    if (pResult->pszProblem)
        pszError = pResult->pszProblem;

    // Get the error information part
    CHECKHR(hr = TaskUtil_HrBuildErrorInfoString(pszError, ixptype, pResult, pServer, pszSubject, &pszInfo, &cchInfo));

    // Log into spooler ui
    if (pUI)
    {
        // Insert the Error
        CHECKHR(hr = pUI->InsertError(idEvent, pszInfo));
    }

    // Show in a message box ?
    if (fShowUI && fCanShowUI)
    {
        // Locals
        INETMAILERROR rError;

        // Zero Init
        ZeroMemory(&rError, sizeof(INETMAILERROR));

        // Setup the Error Structure
        rError.dwErrorNumber = pResult->hrResult;
        rError.hrError = pResult->hrServerError;
        rError.pszServer = pServer->szServerName;
        rError.pszAccount = pServer->szAccount;
        rError.pszMessage = pszError;
        rError.pszUserName = pServer->szUserName;
        rError.pszProtocol = g_prgszServers[ixptype];
        rError.pszDetails = pResult->pszResponse;
        rError.dwPort = pServer->dwPort;
        rError.fSecure = pServer->fSSL;

        // Beep
        MessageBeep(MB_OK);

        // Show the error
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddInetMailError), hwndParent, (DLGPROC) InetMailErrorDlgProc, (LPARAM)&rError);
    }

exit:
    // Cleanup
    SafeMemFree(pszInfo);
    SafeMemFree(pszFull);

    // Reset pszProblem
    pResult->pszProblem = pszTempProb;

    // Done
    return taskresult;
}


// ------------------------------------------------------------------------------------
// TaskUtil_OnLogonPrompt - Returns S_FALSE if user cancels, otherwise S_OK
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OnLogonPrompt(IImnAccount *pAccount, ISpoolerUI *pUI, HWND hwndParent,
    LPINETSERVER pServer, DWORD apidUserName, DWORD apidPassword, DWORD apidPromptPwd, BOOL fSaveChanges)
{
    // Locals
    HRESULT         hr=S_FALSE;
    LOGONINFO       rLogon;
    DWORD           cb, type, dw;

    // Check Params
    Assert(pAccount && pServer);

	if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
	{
		if(HideHotmail())
			return(hr);
	}

    // Use current account, blah
    rLogon.pszAccount = pServer->szAccount;
    rLogon.pszPassword = pServer->szPassword;
    rLogon.pszUserName = pServer->szUserName;
    rLogon.pszServer = pServer->szServerName;
    rLogon.fSavePassword = !ISFLAGSET(pServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegValNoModifyAccts, &type, &dw, &cb) &&
        dw == 0)
        rLogon.fAlwaysPromptPassword = TRUE;
    else
        rLogon.fAlwaysPromptPassword = FALSE;

    // No Parent
    if (NULL == hwndParent && NULL != pUI)
    {
        // Get the window parent
        if (FAILED(pUI->GetWindow(&hwndParent)))
            hwndParent = NULL;

        // Set foreground
        if (hwndParent)
            SetForegroundWindow(hwndParent);
    }

    // Do the Dialog Box
    if (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddPassword), hwndParent, (DLGPROC)TaskUtil_LogonPromptDlgProc, (LPARAM)&rLogon) == IDCANCEL)
        goto exit;

    // Set User Name
    pAccount->SetPropSz(apidUserName, pServer->szUserName);

    // Save Password
    if (rLogon.fSavePassword)
        pAccount->SetPropSz(apidPassword, pServer->szPassword);
    else 
        pAccount->SetProp(apidPassword, NULL, 0);

    if (rLogon.fAlwaysPromptPassword && apidPromptPwd)
        pAccount->SetPropDw(apidPromptPwd, !rLogon.fSavePassword);

    // Save Changes
    if (fSaveChanges)
        pAccount->SaveChanges();

    // Everything is good
    hr = S_OK;

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// TaskUtil_LogonPromptDlgProc
// ------------------------------------------------------------------------------------
BOOL CALLBACK TaskUtil_LogonPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPLOGONINFO     pLogon=(LPLOGONINFO)GetWndThisPtr(hwnd);
    CHAR            szRes[CCHMAX_RES];
    CHAR            szTitle[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        pLogon = (LPLOGONINFO)lParam;
        Assert(pLogon);

        // AddRef the pointer
        Assert(pLogon->pszAccount);
        Assert(pLogon->pszServer);
        Assert(pLogon->pszUserName);
        Assert(pLogon->pszPassword);

        // Center remember location
        CenterDialog(hwnd);

	    // Limit Text
        Edit_LimitText(GetDlgItem(hwnd, IDE_ACCOUNT), CCHMAX_USERNAME-1);
        Edit_LimitText(GetDlgItem(hwnd, IDE_PASSWORD), CCHMAX_PASSWORD-1);

        // Set Window Title
        if (!FIsEmptyA(pLogon->pszAccount))
        {
            GetWindowText(hwnd, szRes, sizeof(szRes)/sizeof(TCHAR));
            wsprintf(szTitle, "%s - %s", szRes, pLogon->pszAccount);
            SetWindowText(hwnd, szTitle);
        }

        // Set Server
        if (!FIsEmptyA(pLogon->pszServer))
            Edit_SetText(GetDlgItem(hwnd, IDS_SERVER), pLogon->pszServer);

        // Set User Name
        if (!FIsEmptyA(pLogon->pszUserName))
        {
            Edit_SetText(GetDlgItem(hwnd, IDE_ACCOUNT), pLogon->pszUserName);
            SetFocus(GetDlgItem(hwnd, IDE_PASSWORD));
        }
        else 
            SetFocus(GetDlgItem(hwnd, IDE_ACCOUNT));

        // Set Password 
        if (!FIsEmptyA(pLogon->pszPassword))
            Edit_SetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pszPassword);

        // Remember Password
        CheckDlgButton(hwnd, IDCH_REMEMBER, pLogon->fSavePassword);

        if (!pLogon->fAlwaysPromptPassword)
            EnableWindow(GetDlgItem(hwnd, IDCH_REMEMBER), FALSE);

        // Save the pointer
        SetWndThisPtr(hwnd, pLogon);
        return FALSE;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return 1;

        case IDOK:
            Assert(pLogon);
            if (pLogon)
            {
                // Pray
                Assert(pLogon->pszUserName);
                Assert(pLogon->pszPassword);

                // User Name
                if (pLogon->pszUserName)
                    Edit_GetText(GetDlgItem(hwnd, IDE_ACCOUNT), pLogon->pszUserName, CCHMAX_USERNAME);

                // Password
                if (pLogon->pszPassword)
                    Edit_GetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pszPassword, CCHMAX_PASSWORD);

                // Save Password
                pLogon->fSavePassword = IsDlgButtonChecked(hwnd, IDCH_REMEMBER);
            }
            EndDialog(hwnd, IDOK);
            return 1;
        }
        break;

    case WM_DESTROY:
        SetWndThisPtr(hwnd, NULL);
        return 0;
    }

    // Done
    return 0;
}

// ------------------------------------------------------------------------------------
// TaskUtil_HwndOnTimeout
// ------------------------------------------------------------------------------------
HWND TaskUtil_HwndOnTimeout(LPCSTR pszServer, LPCSTR pszAccount, LPCSTR pszProtocol, DWORD dwTimeout,
    ITimeoutCallback *pCallback)
{
    // Locals
    TIMEOUTINFO rTimeout;

    // Init
    ZeroMemory(&rTimeout, sizeof(TIMEOUTINFO));
    rTimeout.pszProtocol = pszProtocol;
    rTimeout.pszServer = pszServer;
    rTimeout.pszAccount = pszAccount;
    rTimeout.dwTimeout = dwTimeout;
    rTimeout.pCallback = pCallback;

    // Modeless Dialog
    HWND hwnd = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddTimeout), NULL, (DLGPROC)TaskUtil_TimeoutPromptDlgProc, (LPARAM)&rTimeout);

    // Failure
    if (hwnd)
        SetForegroundWindow(hwnd);

    // Done
    return hwnd;
}

// ------------------------------------------------------------------------------------
// TaskUtil_TimeoutPromptDlgProc
// ------------------------------------------------------------------------------------
BOOL CALLBACK TaskUtil_TimeoutPromptDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    ITimeoutCallback *pCallback=(ITimeoutCallback *)GetWndThisPtr(hwnd);
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        {
            LPTIMEOUTINFO pTimeout = (LPTIMEOUTINFO)lParam;
            Assert(pTimeout);

            // Validate pIn
            Assert(pTimeout->pszServer && pTimeout->pszAccount && pTimeout->pszProtocol && pTimeout->pCallback);

            // Center remember location
            CenterDialog(hwnd);

            // Get the text from the static
            CHAR szText[CCHMAX_RES + CCHMAX_RES];
            Edit_GetText(GetDlgItem(hwnd, IDC_TIMEOUT), szText, ARRAYSIZE(szText));

            // Format the message
            CHAR szAccount[CCHMAX_ACCOUNT_NAME];
            CHAR szWarning[CCHMAX_RES + CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_SERVER_NAME];
            PszEscapeMenuStringA(pTimeout->pszAccount, szAccount, sizeof(szAccount) / sizeof(char));
            wsprintf(szWarning, szText, pTimeout->pszProtocol, pTimeout->dwTimeout, pTimeout->dwTimeout, szAccount, pTimeout->pszServer);

            // Set the Text
            Edit_SetText(GetDlgItem(hwnd, IDC_TIMEOUT), szWarning);

            // AddRef the Task
            pTimeout->pCallback->AddRef();

            // Save the pointer
            SetWndThisPtr(hwnd, pTimeout->pCallback);
        }
        return FALSE;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            Assert(pCallback);
            if (pCallback)
                {
                // IMAP's OnTimeoutResponse blocks on modal error dlg when disconnecting
                // during cmd in progress. Hide us to avoid confusion
                ShowWindow(hwnd, SW_HIDE);
                pCallback->OnTimeoutResponse(TIMEOUT_RESPONSE_STOP);
                }
            DestroyWindow(hwnd);
            return 1;

        case IDOK:
            Assert(pCallback);
            if (pCallback)
                pCallback->OnTimeoutResponse(TIMEOUT_RESPONSE_WAIT);
            DestroyWindow(hwnd);
            return 1;
        }
        break;

    case WM_DESTROY:
        Assert(pCallback);
        SafeRelease(pCallback);
        SetWndThisPtr(hwnd, NULL);
        return 0;
    }

    // Done
    return 0;
}


// ------------------------------------------------------------------------------------
// TaskUtil_CheckForPasswordPrompt
//
// Purpose: This function checks if the given account is set to always prompt for a
//   a password, and we do not have a password cached for this account. If both are
//   true, we make the spooler window visible so that we may prompt the user
//   for his password. This function should be called immediately after a spooler
//   event has been successfully registered. This function should not be called if
//   the caller already has AP_*_PROMPT_PASSWORD, AP_*_PORT and AP_*_SERVER properties:
//   in this case, the caller can call GetPassword to see if the password is cached.
//
// Arguments:
//   IImnAccount *pAccount [in] - the account associated with a successfully registered
//     spooler event.
//   DWORD dwSrvType [in] - the SRV_* type of this server, eg, SRV_IMAP or SRV_SMTP.
//   ISpoolerUI *pUI [in] - used to show the spooler window if this account matches
//     the criteria.
// ------------------------------------------------------------------------------------
#if 0 // Nobody seems to use this right now
void TaskUtil_CheckForPasswordPrompt(IImnAccount *pAccount, DWORD dwSrvType,
                                     ISpoolerUI *pUI)
{
    DWORD dwPromptPassPropID, dwPortPropID, dwServerPropID;
    DWORD fAlwaysPromptPassword, dwPort;
    char szServerName[CCHMAX_SERVER_NAME];
    HRESULT hrResult;

    Assert(SRV_IMAP == dwSrvType || SRV_NNTP == dwSrvType ||
        SRV_POP3 == dwSrvType || SRV_SMTP == dwSrvType);

    // Resolve property ID's
    switch (dwSrvType) {
        case SRV_IMAP:
            dwPromptPassPropID = AP_IMAP_PROMPT_PASSWORD;
            dwPortPropID = AP_IMAP_PORT;
            dwServerPropID = AP_IMAP_SERVER;
            break;

        case SRV_NNTP:
            dwPromptPassPropID = AP_NNTP_PROMPT_PASSWORD;
            dwPortPropID = AP_NNTP_PORT;
            dwServerPropID = AP_NNTP_SERVER;
            break;

        case SRV_POP3:
            dwPromptPassPropID = AP_POP3_PROMPT_PASSWORD;
            dwPortPropID = AP_POP3_PORT;
            dwServerPropID = AP_POP3_SERVER;
            break;

        case SRV_SMTP:
            dwPromptPassPropID = AP_SMTP_PROMPT_PASSWORD;
            dwPortPropID = AP_SMTP_PORT;
            dwServerPropID = AP_SMTP_SERVER;
            break;

        default:
            return; // We can't help you, buddy
    } // switch

    // If this account is set to always prompt for password and password isn't
    // already cached, show UI so we can prompt user for password
    hrResult = pAccount->GetPropDw(dwPromptPassPropID, &fAlwaysPromptPassword);
    if (FAILED(hrResult) || !fAlwaysPromptPassword)
        return;

    hrResult = pAccount->GetPropDw(dwPortPropID, &dwPort);
    if (FAILED(hrResult))
        return;

    hrResult = pAccount->GetPropSz(dwServerPropID, szServerName, sizeof(szServerName));
    if (FAILED(hrResult))
        return;

    hrResult = GetPassword(dwPort, szServerName, NULL, 0);
    if (FAILED(hrResult))
        // No cached password! Go ahead and make the spooler window visible
        pUI->ShowWindow(SW_SHOW);

} // TaskUtil_CheckForPasswordPrompt
#endif // 0

// ------------------------------------------------------------------------------------
// TaskUtil_OpenSentItemsFolder
//
// 1. If pAccount is a POP3 Account, then return the Local Store Sent Items.
// 2. If pAccount is a NEWS Account, then return the default mail account sent items.
// 3. Otherwise, return the sent items folder for the account (IMAP or HotMail).

// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OpenSentItemsFolder(IImnAccount *pAccount, IMessageFolder **ppFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idServer;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount    *pDefault=NULL;
    DWORD           dwServers;

    // Invalid Args
    Assert(pAccount && ppFolder);

    // Trace
    TraceCall("TaskUtil_OpenSentItemsFolder");

    // Get Sever Types
    IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));

    // If News Server, use default mail account instead...
    if (ISFLAGSET(dwServers, SRV_NNTP))
    {
        // Try to get the default mail account
        if (SUCCEEDED(g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pDefault)))
        {
            // Reset pAccount
            pAccount = pDefault;

            // Get Sever Types
            IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));
        }

        // Otherwise, use local store
        else
            dwServers = SRV_POP3;
    }

    // If pop3...
    if (ISFLAGSET(dwServers, SRV_POP3))
    {
        // Local Store
        idServer = FOLDERID_LOCAL_STORE;
    }

    // Otherwise...
    else
    {
        // Can't be new
        Assert(!ISFLAGSET(dwServers, SRV_NNTP));

        // Get the Account ID for pAccount
        IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));

        // Find the Server Id
        IF_FAILEXIT(hr = g_pStore->FindServerId(szAccountId, &idServer));
    }

    // Open Local Store
    IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_SENT, ppFolder));

exit:
    // If failed, try to open local store special
    if (FAILED(hr))
        hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_SENT, ppFolder);

    // Cleanup
    SafeRelease(pDefault);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\taskutil.h ===
// --------------------------------------------------------------------------------
// TaskUtil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __TASKUTIL_H
#define __TASKUTIL_H

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "spoolapi.h"

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
const EVENTID INVALID_EVENT = -1;

// --------------------------------------------------------------------------------
// LOADSTRING
// --------------------------------------------------------------------------------
#define LOADSTRING(_idsString, _szDest) \
    SideAssert(LoadString(g_hLocRes, _idsString, _szDest, sizeof(_szDest)) > 0)
#define T_LOADSTRING(_szString, _szDest) \
    lstrcpy(_szDest, _szString)
#define CCHMAX_RES 255

// --------------------------------------------------------------------------------
// TASKRESULTTYPE
// --------------------------------------------------------------------------------
typedef enum tagTASKRESULTTYPE {
    TASKRESULT_SUCCESS,                               // No problem
    TASKRESULT_FAILURE,                               // Fatal results in disconnect
    TASKRESULT_EVENTFAILED                            // An item or event failed
} TASKRESULTTYPE;

// ------------------------------------------------------------------------------------
// TIMEOUTINFO
// ------------------------------------------------------------------------------------
typedef struct tagTIMEOUTINFO {
    DWORD               dwTimeout;
    LPCSTR              pszServer;
    LPCSTR              pszAccount;
    LPCSTR              pszProtocol;
    ITimeoutCallback   *pCallback;
} TIMEOUTINFO, *LPTIMEOUTINFO;

// --------------------------------------------------------------------------------
// TASKERROR
// --------------------------------------------------------------------------------
typedef struct tagTASKERROR {
    HRESULT         hrResult;
    ULONG           ulStringId;
    LPCSTR          pszError;
    BOOL            fShowUI;
    TASKRESULTTYPE  tyResult;
} TASKERROR, *LPTASKERROR;
typedef TASKERROR const *LPCTASKERROR;

// --------------------------------------------------------------------------------
// PTaskUtil_GetError
// --------------------------------------------------------------------------------
LPCTASKERROR PTaskUtil_GetError(HRESULT hrResult, ULONG *piError);

// --------------------------------------------------------------------------------
// TaskUtil_SplitStoreError - converts STOREERROR into IXPRESULT and INETSERVER
// --------------------------------------------------------------------------------
void TaskUtil_SplitStoreError(IXPRESULT *pixpResult, INETSERVER *pInetServer,
                              STOREERROR *pErrorInfo);

// --------------------------------------------------------------------------------
// TaskUtil_InsertTransportError
// --------------------------------------------------------------------------------
TASKRESULTTYPE TaskUtil_InsertTransportError(BOOL fCanShowUI, ISpoolerUI *pUI, EVENTID eidCurrent,
                                             STOREERROR *pErrorInfo, LPSTR pszOpDescription,
                                             LPSTR pszSubject);

// --------------------------------------------------------------------------------
// TaskUtil_FBaseTransportError - Returns TRUE if the error was handled
// --------------------------------------------------------------------------------
TASKRESULTTYPE TaskUtil_FBaseTransportError(IXPTYPE ixptype, EVENTID idEvent, LPIXPRESULT pResult, 
    LPINETSERVER pServer, LPCSTR pszSubject, ISpoolerUI *pUI, BOOL fCanShowUI, HWND hwndParent);

// ------------------------------------------------------------------------------------
// TaskUtil_HrBuildErrorInfoString
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_HrBuildErrorInfoString(LPCSTR pszProblem, IXPTYPE ixptype, LPIXPRESULT pResult,
    LPINETSERVER pServer, LPCSTR pszSubject, LPSTR *ppszInfo, ULONG *pcchInfo);

// ------------------------------------------------------------------------------------
// TaskUtil_OnLogonPrompt
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OnLogonPrompt(IImnAccount *pAccount, ISpoolerUI *pUI, HWND hwndParent,
    LPINETSERVER pServer, DWORD apidUserName, DWORD apidPassword, DWORD apidPromptPwd, BOOL fSaveChanges);

// ------------------------------------------------------------------------------------
// TaskUtil_HwndOnTimeout
// ------------------------------------------------------------------------------------
HWND TaskUtil_HwndOnTimeout(LPCSTR pszServer, LPCSTR pszAccount, LPCSTR pszProtocol, DWORD dwTimeout,
    ITimeoutCallback *pTask);

// ------------------------------------------------------------------------------------
// TaskUtil_OpenSentItemsFolder
// ------------------------------------------------------------------------------------
HRESULT TaskUtil_OpenSentItemsFolder(IImnAccount *pAccount, IMessageFolder **ppFolder);



#endif // __TASKUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\watchtsk.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     watchtsk.h
//
//  PURPOSE:    Defines the spooler task that is responsible for checking
//              for watched messages.
//

#pragma once

#include "spoolapi.h"
#include "storutil.h"

/////////////////////////////////////////////////////////////////////////////
// States for the state machine
//

typedef enum tagWATCHTASKSTATE
{
    WTS_IDLE = 0,
    WTS_CONNECTING,
    WTS_INIT,
    WTS_NEXTFOLDER,
    WTS_RESP,
    WTS_END,
    WTS_MAX
} WATCHTASKSTATE;

class CWatchTask;
typedef HRESULT (CWatchTask::*PFNWSTATEFUNC)(THIS_ void);


/////////////////////////////////////////////////////////////////////////////
// class CWatchTask
//
// Overview:
// This object is responsible for checking folders on the server for new 
// messages that might be part of a conversation the user is watching.  If
// one of these messages is found, then that message is downloaded into the
// users's store and the user is notified.
//

class CWatchTask : public ISpoolerTask, 
                   public IStoreCallback, 
                   public ITimeoutCallback
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    //
    CWatchTask();
    ~CWatchTask();    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    //
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    /////////////////////////////////////////////////////////////////////////
    // ISpoolerTask Interface
    //
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails);
    STDMETHODIMP Cancel(void);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback Interface
    // 
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback Interface
    //
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

protected:
    /////////////////////////////////////////////////////////////////////////
    // Window callback and message handling
    //
    static LRESULT CALLBACK _TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                         LPARAM lParam);

    /////////////////////////////////////////////////////////////////////////
    // General stuff
    //
    void CWatchTask::_NextState(void);
    BOOL _ChildFoldersHaveWatched(FOLDERID id);
    BOOL _FolderContainsWatched(FOLDERID id);

    /////////////////////////////////////////////////////////////////////////
    // State Machine functions, public but don't call 'em directly.
    //
public:
    HRESULT _Watch_Init(void);
    HRESULT _Watch_NextFolder(void);
    HRESULT _Watch_Done(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private data
    //

    ULONG                   m_cRef;         // Reference Count

    // State
    BOOL                    m_fInited;      // TRUE if we've had our Init() member called
    DWORD                   m_dwFlags;      // Execution flags from the spooler engine
    TCHAR                   m_szAccount[256];
    TCHAR                   m_szAccountId[256];
    FOLDERID                m_idAccount;
    EVENTID                 m_eidCur;       // The current executing event

    // Interfaces
    ISpoolerBindContext    *m_pBindCtx;     // Interface to communicate with the spooler engine
    ISpoolerUI             *m_pUI;          // Interface to communicate with the UI
    IImnAccount            *m_pAccount;     // Interface of the account we're checking
    IMessageServer         *m_pServer;      // Interface of the server object we're using
    IOperationCancel       *m_pCancel;      // Interface we use to cancel the current server op

    // Stuff
    FOLDERID                m_idFolderCheck;// If the user just want's us to check one folder
    FOLDERID               *m_rgidFolders;  // Array of all of the folders we need to check
    DWORD                   m_cFolders;     // Number of folders in m_rgidFolders
    HWND                    m_hwnd;         // Handle of our window
    HTIMEOUT                m_hTimeout;     // Handle of the timeout dialog
    DWORD                   m_cMsgs;        // Number of watched messages downloaded


    // State Machine goo
    DWORD                   m_state;
    BOOL                    m_fCancel;      // TRUE if the user has pressed the Cancel button
    DWORD                   m_cCurFolder;   // Current folder being checked.  Index's into m_rgidFolders;
    DWORD                   m_cFailed;      // Number of folders that could not be checked
    STOREOPERATIONTYPE      m_tyOperation;  // Current operation type

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\cleanup.cpp ===
//--------------------------------------------------------------------------
// Cleanup.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "cleanup.h"
#include "goptions.h"
#include "shlwapi.h"
#include "storutil.h"
#include "xpcomm.h"
#include "shared.h"
#include "syncop.h"
#include "storsync.h"
#include "instance.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------------
static const LPSTR g_szCleanupWndProc = "OEStoreCleanupThread";
static const LPSTR c_szRegLastStoreCleaned = "Last Store Cleaned";
static const LPSTR c_szRegLastFolderCleaned = "Last Folder Cleaned";

// --------------------------------------------------------------------------------
// STOREFILETYPE
// --------------------------------------------------------------------------------
typedef enum tagSTOREFILETYPE {
    STORE_FILE_HEADERS,
    STORE_FILE_FOLDERS,
    STORE_FILE_POP3UIDL,
    STORE_FILE_OFFLINE,
    STORE_FILE_LAST
} STOREFILETYPE;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
static BOOL             g_fShutdown=FALSE;

// --------------------------------------------------------------------------------
// CCompactProgress
// --------------------------------------------------------------------------------
class CCompactProgress : public IDatabaseProgress
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return TraceResult(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void) { return(2); }
    STDMETHODIMP_(ULONG) Release(void) { return(1); }
    STDMETHODIMP Update(DWORD cCount) { return(g_fShutdown ? hrUserCancel : S_OK); }
};

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
static DWORD            g_dwCleanupThreadId=0;
static HANDLE           g_hCleanupThread=NULL;
static HWND             g_hwndStoreCleanup=NULL;
static UINT_PTR         g_uDelayTimerId=0;
static HROWSET          g_hCleanupRowset=NULL;
static BOOL             g_fWorking=FALSE;
static STOREFILETYPE    g_tyCurrentFile=STORE_FILE_LAST;
static ILogFile        *g_pCleanLog=NULL;
static CCompactProgress g_cProgress;

// --------------------------------------------------------------------------------
// Timer Constants
// --------------------------------------------------------------------------------
#define IDT_START_CYCLE          (WM_USER + 1)
#define IDT_CLEANUP_FOLDER       (WM_USER + 2)
#define CYCLE_INTERVAL           (1000 * 60 * 30)

// --------------------------------------------------------------------------------
// CLEANUPTRHEADCREATE
// --------------------------------------------------------------------------------
typedef struct tagCLEANUPTRHEADCREATE {
    HRESULT         hrResult;
    HANDLE          hEvent;
} CLEANUPTRHEADCREATE, *LPCLEANUPTRHEADCREATE;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
DWORD   StoreCleanupThreadEntry(LPDWORD pdwParam);
LRESULT CALLBACK StoreCleanupWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT CleanupStoreInitializeCycle(HWND hwnd);
HRESULT CleanupCurrentFolder(HWND hwnd);
HRESULT SetNextCleanupFolder(HWND hwnd);
HRESULT StartCleanupCycle(HWND hwnd);
HRESULT CleanupNewsgroup(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcRemovedRead, LPDWORD pcRemovedExpired);
HRESULT CleanupJunkMail(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcJunkDeleted);

//--------------------------------------------------------------------------
// RegisterWindowClass
//--------------------------------------------------------------------------
HRESULT RegisterWindowClass(LPCSTR pszClass, WNDPROC pfnWndProc)
{
    // Locals
    HRESULT         hr=S_OK;
    WNDCLASS        WindowClass;

    // Tracing
    TraceCall("RegisterWindowClass");

    // Register the Window Class
    if (0 != GetClassInfo(g_hInst, pszClass, &WindowClass))
        goto exit;

    // Zero the object
    ZeroMemory(&WindowClass, sizeof(WNDCLASS));

    // Initialize the Window Class
    WindowClass.lpfnWndProc = pfnWndProc;
    WindowClass.hInstance = g_hInst;
    WindowClass.lpszClassName = pszClass;

    // Register the Class
    if (0 == RegisterClass(&WindowClass))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CreateNotifyWindow
//--------------------------------------------------------------------------
HRESULT CreateNotifyWindow(LPCSTR pszClass, LPVOID pvParam, HWND *phwndNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwnd;

    // Tracing
    TraceCall("CreateNotifyWindow");

    // Invalid ARg
    Assert(pszClass && phwndNotify);

    // Initialize
    *phwndNotify = NULL;

    // Create the Window
    hwnd = CreateWindowEx(WS_EX_TOPMOST, pszClass, pszClass, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInst, (LPVOID)pvParam);

    // Failure
    if (NULL == hwnd)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Set Return
    *phwndNotify = hwnd;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DelayedStartStoreCleanup
// --------------------------------------------------------------------------------
void CALLBACK DelayedStartStoreCleanup(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    // Trace
    TraceCall("DelayedStartStoreCleanup");

    // Must have a timer
    Assert(g_uDelayTimerId);

    // Kill the Timer
    KillTimer(NULL, g_uDelayTimerId);

    // Set g_uDelayTimerId
    g_uDelayTimerId = 0;

    // Call this function with zero delay...
    StartBackgroundStoreCleanup(0);
}

// --------------------------------------------------------------------------------
// StartBackgroundStoreCleanup
// --------------------------------------------------------------------------------
HRESULT StartBackgroundStoreCleanup(DWORD dwDelaySeconds)
{
    // Locals
    HRESULT             hr=S_OK;
    CLEANUPTRHEADCREATE Create={0};

    // Trace
    TraceCall("StartBackgroundStoreCleanup");

    // Already Running ?
    if (NULL != g_hCleanupThread)
        return(S_OK);

    // If dwDelaySeconds is NOT zero, then lets start this function later
    if (0 != dwDelaySeconds)
    {
        // Trace
        TraceInfo(_MSG("Delayed start store cleanup in %d seconds.", dwDelaySeconds));

        // Set a timer to call this the delay function a little bit later
        g_uDelayTimerId = SetTimer(NULL, 0, (dwDelaySeconds * 1000), DelayedStartStoreCleanup);

        // Failure
        if (0 == g_uDelayTimerId)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Done
        return(S_OK);
    }

    // Trace
    TraceInfo("Starting store cleanup.");

    // Initialize
    Create.hrResult = S_OK;

    // Create an Event to synchonize creation
    Create.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == Create.hEvent)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Create the inetmail thread
    g_hCleanupThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StoreCleanupThreadEntry, &Create, 0, &g_dwCleanupThreadId);
    if (NULL == g_hCleanupThread)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Wait for StoreCleanupThreadEntry to signal the event
    WaitForSingleObject(Create.hEvent, INFINITE);

    // Failure
    if (FAILED(Create.hrResult))
    {
        // Close
        SafeCloseHandle(g_hCleanupThread);

        // Reset Globals
        g_hCleanupThread = NULL;
        g_dwCleanupThreadId = 0;

        // Return
        hr = TrapError(Create.hrResult);

        // Done
        goto exit;
    }

exit:
    // Cleanup
    SafeCloseHandle(Create.hEvent);

    // Done
    return(hr);
}

// ------------------------------------------------------------------------------------
// CloseBackgroundStoreCleanup
// ------------------------------------------------------------------------------------
HRESULT CloseBackgroundStoreCleanup(void)
{
    // Trace
    TraceCall("CloseBackgroundStoreCleanup");

    // Trace
    TraceInfo("Terminating Store Cleanup thread.");

    // Kill the Timer
    if (g_uDelayTimerId)
    {
        KillTimer(NULL, g_uDelayTimerId);
        g_uDelayTimerId = 0;
    }

    // Invalid Arg
    if (0 != g_dwCleanupThreadId)
    {
        // Assert
        Assert(g_hCleanupThread && FALSE == g_fShutdown);

        // Set Shutdown bit
        g_fShutdown = TRUE;

        // Post quit message
        PostThreadMessage(g_dwCleanupThreadId, WM_QUIT, 0, 0);

        // Wait for event to become signaled
        WaitForSingleObject(g_hCleanupThread, INFINITE);
    }

    // Validate
    Assert(NULL == g_hwndStoreCleanup && 0 == g_dwCleanupThreadId);

    // If we have a handle
    if (NULL != g_hCleanupThread)
    {
        // Close the thread handle
        CloseHandle(g_hCleanupThread);

        // Reset Globals
        g_hCleanupThread = NULL;
    }

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// InitializeCleanupLogFile
// --------------------------------------------------------------------------------
HRESULT InitializeCleanupLogFile(void)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szLogFile[MAX_PATH];
    CHAR            szStoreRoot[MAX_PATH];

    // Trace
    TraceCall("InitializeCleanupLogFile");

    // Better not have a log file yet
    Assert(NULL == g_pCleanLog);

    // Open Log File
    IF_FAILEXIT(hr = GetStoreRootDirectory(szStoreRoot, ARRAYSIZE(szStoreRoot)));

    // MakeFilePath to cleanup.log
    IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, "cleanup.log", c_szEmpty, szLogFile, ARRAYSIZE(szLogFile)));

    // Open the LogFile
    IF_FAILEXIT(hr = CreateLogFile(g_hLocRes, szLogFile, "CLEANUP", 65536, &g_pCleanLog,
        FILE_SHARE_READ | FILE_SHARE_WRITE));

    // Write the Store root
    g_pCleanLog->WriteLog(LOGFILE_DB, szStoreRoot);

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// StoreCleanupThreadEntry
// --------------------------------------------------------------------------------
DWORD StoreCleanupThreadEntry(LPDWORD pdwParam) 
{  
    // Locals
    HRESULT                 hr=S_OK;
    MSG                     msg;
    DWORD                   dw;
    DWORD                   cb;
    LPCLEANUPTRHEADCREATE   pCreate;

    // Trace
    TraceCall("StoreCleanupThreadEntry");

    // We better have a parameter
    Assert(pdwParam);

    // Cast to create info
    pCreate = (LPCLEANUPTRHEADCREATE)pdwParam;

    // Initialize OLE
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        pCreate->hrResult = hr;
        SetEvent(pCreate->hEvent);
        return(1);
    }

    // Reset Shutdown Bit
    g_fShutdown = FALSE;

    // OpenCleanupLogFile
    InitializeCleanupLogFile();

    // Registery the window class
    IF_FAILEXIT(hr = RegisterWindowClass(g_szCleanupWndProc, StoreCleanupWindowProc));

    // Create the notification window
    IF_FAILEXIT(hr = CreateNotifyWindow(g_szCleanupWndProc, NULL, &g_hwndStoreCleanup));

    // Success
    pCreate->hrResult = S_OK;

    // Run at a low-priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    // Set Event
    SetEvent(pCreate->hEvent);

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Kill the timer
    if (g_uDelayTimerId)
    {
        KillTimer(NULL, g_uDelayTimerId);
        g_uDelayTimerId = 0;
    }

    // Kill the Current Timer
    KillTimer(g_hwndStoreCleanup, IDT_CLEANUP_FOLDER);

    // Kill the timer
    KillTimer(g_hwndStoreCleanup, IDT_START_CYCLE);

    // Kill the Window
    DestroyWindow(g_hwndStoreCleanup);
    g_hwndStoreCleanup = NULL;
    g_dwCleanupThreadId = 0;

    // Release LogFile
    SafeRelease(g_pCleanLog);

exit:
    // Failure
    if (FAILED(hr))
    {
        pCreate->hrResult = hr;
        SetEvent(pCreate->hEvent);
    }

    // Uninit
    CoUninitialize();

    // Done
    return 1;
}

// --------------------------------------------------------------------------------
// StoreCleanupWindowProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK StoreCleanupWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Trace
    TraceCall("StoreCleanupWindowProc");

    // Switch
    switch(msg)
    {
    // OnCreate
    case WM_CREATE:

        // Set the time to start the first cycle in one second
        SetTimer(hwnd, IDT_START_CYCLE, 1000, NULL);

        // Done
        return(0);

    // OnTime
    case WM_TIMER:

        // Cleanup Folder Timer
        if (IDT_CLEANUP_FOLDER == wParam)
        {
            // Kill the Current Timer
            KillTimer(hwnd, IDT_CLEANUP_FOLDER);

            // Cleanup the Next Folder
            CleanupCurrentFolder(hwnd);
        }

        // Start new cleanup cycle
        else if (IDT_START_CYCLE == wParam)
        {
            // Kill the timer
            KillTimer(hwnd, IDT_START_CYCLE);

            // Start a new cycle
            StartCleanupCycle(hwnd);
        }

        // Done
        return(0);

    // OnDestroy
    case WM_DESTROY:

        // Close the Current Rowset
        g_pLocalStore->CloseRowset(&g_hCleanupRowset);

        // Done
        return(0);
    }

    // Deletegate
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

// --------------------------------------------------------------------------------
// StartCleanupCycle
// --------------------------------------------------------------------------------
HRESULT StartCleanupCycle(HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("StartCleanupCycle");

    // Validate State
    Assert(g_pLocalStore && NULL == g_hCleanupRowset);

    // Logfile
    if (g_pCleanLog)
    {
        // WriteLogFile
        g_pCleanLog->WriteLog(LOGFILE_DB, "Starting Background Cleanup Cycle...");
    }

    // Create a Store Rowset
    IF_FAILEXIT(hr = g_pLocalStore->CreateRowset(IINDEX_SUBSCRIBED, NOFLAGS, &g_hCleanupRowset));

    // Set state
    g_tyCurrentFile = STORE_FILE_HEADERS;

    // Cleanup this folder...
    SetTimer(hwnd, IDT_CLEANUP_FOLDER, 100, NULL);

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupCurrentFolder
// --------------------------------------------------------------------------------
HRESULT CleanupCurrentFolder(HWND hwnd)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCSTR              pszFile=NULL;
    FOLDERTYPE          tyFolder=FOLDER_INVALID;
    SPECIALFOLDER       tySpecial=FOLDER_NOTSPECIAL;
    FOLDERINFO          Folder={0};
    DWORD               cRecords;
    DWORD               cbAllocated;
    DWORD               cbFreed;
    DWORD               cbStreams;
    DWORD               cbFile;
    DWORD               dwWasted;
    DWORD               dwCompactAt;
    DWORD               cRemovedRead=0;
    DWORD               cRemovedExpired=0;
    DWORD               cJunkDeleted=0;
    IDatabase          *pDB=NULL;
    IMessageFolder     *pFolderObject=NULL;

    // Trace
    TraceCall("CleanupCurrentFolder");

    // Validate
    Assert(g_pLocalStore);

    // Get Next Folder
    if (STORE_FILE_HEADERS == g_tyCurrentFile)
    {
        // Better have a rowset
        Assert(g_hCleanupRowset);
        
        // Get a Folder
        hr = g_pLocalStore->QueryRowset(g_hCleanupRowset, 1, (LPVOID *)&Folder, NULL);
        if (FAILED(hr) || S_FALSE == hr)
        {
            // Don with Current Cycle
            g_pLocalStore->CloseRowset(&g_hCleanupRowset);

            // Set g_tyCurrentFile
            g_tyCurrentFile = STORE_FILE_FOLDERS;
        }

        // Otherwise...
        else if (FOLDERID_ROOT == Folder.idFolder || ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            // Goto Next
            goto exit;
        }

        // Otherwise
        else
        {
            // Set some stuff
            pszFile = Folder.pszFile;
            tyFolder = Folder.tyFolder;
            tySpecial = Folder.tySpecial;

            // If no folder file, then jump to exit
            if (NULL == pszFile)
                goto exit;

            // Open the folder object
            if (FAILED(g_pLocalStore->OpenFolder(Folder.idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
                goto exit;

            // Get the Database
            pFolderObject->GetDatabase(&pDB);
        }
    }

    // If something other than a folder
    if (STORE_FILE_HEADERS != g_tyCurrentFile)
    {
        // Locals
        LPCTABLESCHEMA pSchema=NULL;
        LPCSTR         pszName=NULL;
        CHAR           szRootDir[MAX_PATH + MAX_PATH];
        CHAR           szFilePath[MAX_PATH + MAX_PATH];

        // Folders
        if (STORE_FILE_FOLDERS == g_tyCurrentFile)
        {
            pszName = pszFile = c_szFoldersFile;
            pSchema = &g_FolderTableSchema;
            g_tyCurrentFile = STORE_FILE_POP3UIDL;
        }

        // Pop3uidl
        else if (STORE_FILE_POP3UIDL == g_tyCurrentFile)
        {
            pszName = pszFile = c_szPop3UidlFile;
            pSchema = &g_UidlTableSchema;
            g_tyCurrentFile = STORE_FILE_OFFLINE;
        }

        // Offline.dbx
        else if (STORE_FILE_OFFLINE == g_tyCurrentFile)
        {
            pszName = pszFile = c_szOfflineFile;
            pSchema = &g_SyncOpTableSchema;
            g_tyCurrentFile = STORE_FILE_LAST;
        }

        // Otherwise, we are done
        else if (STORE_FILE_LAST == g_tyCurrentFile)
        {
            // Set time to start next cycle
            SetTimer(hwnd, IDT_START_CYCLE, CYCLE_INTERVAL, NULL);

            // Done
            return(S_OK);
        }

        // Validate
        Assert(pSchema && pszName);

        // No File
        if (FIsEmptyA(pszFile))
            goto exit;

        // Get Root Directory
        IF_FAILEXIT(hr = GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir)));

        // Make File Path
        IF_FAILEXIT(hr = MakeFilePath(szRootDir, pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // If the File Exists?
        if (FALSE == PathFileExists(szFilePath))
            goto exit;

        // Open a Database Object on the file
        IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NORESET, pSchema, NULL, &pDB));
    }

    // Not Working 
    g_fWorking = TRUE;

    // Get Record Count
    IF_FAILEXIT(hr = pDB->GetRecordCount(IINDEX_PRIMARY, &cRecords));

    // If this is a news folder, and I'm the only person with it open...
    if (FOLDER_NEWS == tyFolder)
    {
        // Cleanup Newgroup
        CleanupNewsgroup(pszFile, pDB, &cRemovedRead, &cRemovedExpired);
    }

    // If this is the junk mail folder
    if ((FOLDER_LOCAL == tyFolder) && (FOLDER_JUNK == tySpecial))
    {
        // Cleanup Junk Mail folder
        CleanupJunkMail(pszFile, pDB, &cJunkDeleted);
    }

    // Get Size Information...
    IF_FAILEXIT(hr = pDB->GetSize(&cbFile, &cbAllocated, &cbFreed, &cbStreams));

    // Wasted
    dwWasted = cbAllocated > 0 ? ((cbFreed * 100) / cbAllocated) : 0;

    // Get Option about when to compact
    dwCompactAt = DwGetOption(OPT_CACHECOMPACTPER);

    // Trace
    if (g_pCleanLog)
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("%12s, CompactAt: %02d%%, Wasted: %02d%%, File: %09d, Records: %08d, Allocated: %09d, Freed: %08d, Streams: %08d, RemovedRead: %d, RemovedExpired: %d, JunkDeleted: %d", pszFile, dwCompactAt, dwWasted, cbFile, cRecords, cbAllocated, cbFreed, cbStreams, cRemovedRead, cRemovedExpired, cJunkDeleted));
    }

    // If less than 25% wasted space and there is more than a meg allocated
    if (dwWasted < dwCompactAt)
        goto exit;

    // Compact
    hr = pDB->Compact((IDatabaseProgress *)&g_cProgress, COMPACT_PREEMPTABLE | COMPACT_YIELD);

    // Log Result
    if (g_pCleanLog && S_OK != hr)
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("IDatabase::Compact(%s) Returned: 0x%08X", pszFile, hr));
    }

exit:
    // Cleanup
    SafeRelease(pDB);
    SafeRelease(pFolderObject);
    g_pLocalStore->FreeRecord(&Folder);

    // Not Working 
    g_fWorking = FALSE;

    // ShutDown
    if (FALSE == g_fShutdown)
    {
        // Compute Next CleanupFolder
        SetTimer(hwnd, IDT_CLEANUP_FOLDER, 100, NULL);
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupNewsgroup
// --------------------------------------------------------------------------------
HRESULT CleanupNewsgroup(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcRemovedRead, 
    LPDWORD pcRemovedExpired)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cExpireDays;
    BOOL        fRemoveExpired=FALSE;
    BOOL        fRemoveRead=FALSE;
    DWORD       cClients;
    FILETIME    ftCurrent;
    HROWSET     hRowset=NULL;
    MESSAGEINFO MsgInfo={0};

    // Trace
    TraceCall("CleanupNewsgroup");

    // Get Current Time
    GetSystemTimeAsFileTime(&ftCurrent);

    // Get the Number of Days in which to expire messages
    cExpireDays = DwGetOption(OPT_CACHEDELETEMSGS);

    // If the option is not off, set the flag
    fRemoveExpired = (OPTION_OFF == cExpireDays) ? FALSE : TRUE;

    // Remove Read ?
    fRemoveRead = (FALSE != DwGetOption(OPT_CACHEREAD) ? TRUE : FALSE);

    // Nothing to do
    if (FALSE == fRemoveExpired && FALSE == fRemoveRead)
        goto exit;

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
    {
        // If I'm not the only client, then abort the cleanup
        IF_FAILEXIT(hr = pDB->GetClientCount(&cClients));

        // Better be 1
        if (cClients != 1)
        {
            hr = DB_E_COMPACT_PREEMPTED;
            goto exit;
        }

        // Abort
        if (S_OK != g_cProgress.Update(1))
        {
            hr = STORE_E_OPERATION_CANCELED;
            goto exit;
        }

        // Only if this message has a body
        if (!ISFLAGSET(MsgInfo.dwFlags, ARF_KEEPBODY) && !ISFLAGSET(MsgInfo.dwFlags, ARF_WATCH) && ISFLAGSET(MsgInfo.dwFlags, ARF_HASBODY) && MsgInfo.faStream)
        {
            // Otherwise, if expiring...
            if (TRUE == fRemoveExpired && (UlDateDiff(&MsgInfo.ftDownloaded, &ftCurrent) / SECONDS_INA_DAY) >= cExpireDays)
            {
                // Delete this message
                IF_FAILEXIT(hr = pDB->DeleteRecord(&MsgInfo));

                // Count Removed Expired
                (*pcRemovedExpired)++;
            }

            // Removing Read and this message is read ?
            else if (TRUE == fRemoveRead && ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            {
                // Delete the Stream
                pDB->DeleteStream(MsgInfo.faStream);

                // No More Stream
                MsgInfo.faStream = 0;

                // Fixup the Record
                FLAGCLEAR(MsgInfo.dwFlags, ARF_HASBODY | ARF_ARTICLE_EXPIRED);

                // Clear downloaded time
                ZeroMemory(&MsgInfo.ftDownloaded, sizeof(FILETIME));

                // Update the Record
                IF_FAILEXIT(hr = pDB->UpdateRecord(&MsgInfo));

                // Count Removed Read
                (*pcRemovedRead)++;
            }
        }

        // Free Current
        pDB->FreeRecord(&MsgInfo);
    }

exit:
    // Cleanup
    pDB->CloseRowset(&hRowset);
    pDB->FreeRecord(&MsgInfo);

    // Log File
    if (g_pCleanLog && FAILED(hr))
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("CleanupNewsgroup(%s) Returned: 0x%08X", pszFile, hr));
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupJunkMail
// --------------------------------------------------------------------------------
HRESULT CleanupJunkMail(LPCSTR pszFile, IDatabase *pDB, LPDWORD pcJunkDeleted)
{
    // Locals
    HRESULT             hr = S_OK;
    FILETIME            ftCurrent = {0};
    DWORD               cDeleteDays = 0;
    IDatabase          *pUidlDB = NULL;
    HROWSET             hRowset = NULL;
    MESSAGEINFO         MsgInfo = {0};
    DWORD               cClients = 0;

    // Trace
    TraceCall("CleanupJunkMail");

    // Is there anything to do?
    if ((0 == DwGetOption(OPT_FILTERJUNK)) || (0 == DwGetOption(OPT_DELETEJUNK)) || (0 == (g_dwAthenaMode & MODE_JUNKMAIL)))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Get Current Time
    GetSystemTimeAsFileTime(&ftCurrent);

    // Get the Number of Days in which to expire messages
    cDeleteDays = DwGetOption(OPT_DELETEJUNKDAYS);

    // Open the UIDL Cache
    IF_FAILEXIT(hr = OpenUidlCache(&pUidlDB));
    
    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
    {
        // If I'm not the only client, then abort the cleanup
        IF_FAILEXIT(hr = pDB->GetClientCount(&cClients));

        // Better be 1
        if (cClients != 1)
        {
            hr = DB_E_COMPACT_PREEMPTED;
            goto exit;
        }

        // Abort
        if (S_OK != g_cProgress.Update(1))
        {
            hr = STORE_E_OPERATION_CANCELED;
            goto exit;
        }

        // Has the message been around long enough?
        if (cDeleteDays <= (UlDateDiff(&MsgInfo.ftDownloaded, &ftCurrent) / SECONDS_INA_DAY))
        {
            // Count Deleted
            (*pcJunkDeleted)++;

            // Delete the message
            IF_FAILEXIT(hr = DeleteMessageFromStore(&MsgInfo, pDB, pUidlDB));
        }

        // Free Current
        pDB->FreeRecord(&MsgInfo);
    }

    hr = S_OK;
    
exit:
    // Cleanup
    SafeRelease(pUidlDB);
    pDB->CloseRowset(&hRowset);
    pDB->FreeRecord(&MsgInfo);

    // Log File
    if (g_pCleanLog && FAILED(hr))
    {
        // Write
        g_pCleanLog->WriteLog(LOGFILE_DB, _MSG("CleanupJunkMail(%s) Returned: 0x%08X", pszFile, hr));
    }

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\dbimpl.h ===
//--------------------------------------------------------------------------
// dbimpl.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// IMPLEMENT_IDATABASE
//--------------------------------------------------------------------------
#define IMPLEMENT_IDATABASE(_fStreams, _pMember) \
    STDMETHODIMP Lock(LPHLOCK phLock) { return _pMember->Lock(phLock); } \
    STDMETHODIMP Unlock(LPHLOCK phLock) { return _pMember->Unlock(phLock); } \
    STDMETHODIMP MoveFile(LPCWSTR pszFileName) { return _pMember->MoveFile(pszFileName); } \
    STDMETHODIMP SetSize(DWORD cbSize) { return _pMember->SetSize(cbSize); } \
    STDMETHODIMP GetIndexInfo(INDEXORDINAL iIndex, LPSTR *ppszFilter, LPTABLEINDEX pIndex) { return _pMember->GetIndexInfo(iIndex, ppszFilter, pIndex); } \
    STDMETHODIMP ModifyIndex(INDEXORDINAL iIndex, LPCSTR pszFilter, LPCTABLEINDEX pIndexSrc) { return _pMember->ModifyIndex(iIndex, pszFilter, pIndexSrc); } \
    STDMETHODIMP DeleteIndex(INDEXORDINAL iIndex) { return _pMember->DeleteIndex(iIndex); } \
    STDMETHODIMP InsertRecord(LPVOID pRecord) { return _pMember->InsertRecord(pRecord); } \
    STDMETHODIMP UpdateRecord(LPVOID pRecord) { return _pMember->UpdateRecord(pRecord); } \
    STDMETHODIMP DeleteRecord(LPVOID pRecord) { return _pMember->DeleteRecord(pRecord); } \
    STDMETHODIMP FindRecord(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pRecord, LPROWORDINAL piRow) { return _pMember->FindRecord(iIndex, cColumns, pRecord, piRow); } \
    STDMETHODIMP GetRowOrdinal(INDEXORDINAL iIndex, LPVOID pRecord, LPROWORDINAL piRow) { return _pMember->GetRowOrdinal(iIndex, pRecord, piRow); } \
    STDMETHODIMP CreateRowset(INDEXORDINAL iIndex, CREATEROWSETFLAGS dwFlags, LPHROWSET phRowset) { return _pMember->CreateRowset(iIndex, dwFlags, phRowset); } \
    STDMETHODIMP SeekRowset(HROWSET hRowset, SEEKROWSETTYPE tySeek, LONG cRows, LPROWORDINAL piRowNew) { return _pMember->SeekRowset(hRowset, tySeek, cRows, piRowNew); } \
    STDMETHODIMP QueryRowset(HROWSET hRowset, LONG cWanted, LPVOID *prgpRecord, LPDWORD pcObtained) { return _pMember->QueryRowset(hRowset, cWanted, prgpRecord, pcObtained); } \
    STDMETHODIMP CloseRowset(LPHROWSET phRowset) { return _pMember->CloseRowset(phRowset); } \
    STDMETHODIMP FreeRecord(LPVOID pRecord) { return _pMember->FreeRecord(pRecord); } \
    STDMETHODIMP CreateStream(LPFILEADDRESS pfaStart) { Assert(_fStreams); return _pMember->CreateStream(pfaStart); } \
    STDMETHODIMP CopyStream(IDatabase *pDest, FILEADDRESS faStream, LPFILEADDRESS pfaNew) { Assert(_fStreams); return _pMember->CopyStream(pDest, faStream, pfaNew); } \
    STDMETHODIMP DeleteStream(FILEADDRESS faStart) { Assert(_fStreams); return _pMember->DeleteStream(faStart); } \
    STDMETHODIMP OpenStream(ACCESSTYPE tyAccess, FILEADDRESS faStart, IStream **ppStream) { Assert(_fStreams); return _pMember->OpenStream(tyAccess, faStart, ppStream); } \
    STDMETHODIMP ChangeStreamLock(IStream *pStream, ACCESSTYPE tyAccessNew) { Assert(_fStreams); return _pMember->ChangeStreamLock(pStream, tyAccessNew); } \
    STDMETHODIMP GetUserData(LPVOID pvUserData, ULONG cbUserData) { return _pMember->GetUserData(pvUserData, cbUserData); } \
    STDMETHODIMP SetUserData(LPVOID pvUserData, ULONG cbUserData) { return _pMember->SetUserData(pvUserData, cbUserData); } \
    STDMETHODIMP GetRecordCount(INDEXORDINAL iIndex, LPDWORD pcRecords) { return _pMember->GetRecordCount(iIndex, pcRecords); } \
    STDMETHODIMP GetFile(LPWSTR *ppszFile) { return _pMember->GetFile(ppszFile); } \
    STDMETHODIMP GetSize(LPDWORD pcbFile, LPDWORD pcbAllocated, LPDWORD pcbFreed, LPDWORD pcbStreams) { return _pMember->GetSize(pcbFile, pcbAllocated, pcbFreed, pcbStreams); } \
    STDMETHODIMP Compact(IDatabaseProgress *pProgress, COMPACTFLAGS dwFlags) { return _pMember->Compact(pProgress, dwFlags); } \
    STDMETHODIMP DispatchNotify(IDatabaseNotify *pNotify) { return _pMember->DispatchNotify(pNotify); } \
    STDMETHODIMP RegisterNotify(INDEXORDINAL iIndex, REGISTERNOTIFYFLAGS dwFlags, DWORD_PTR dwCookie, IDatabaseNotify *pNotify)  { return _pMember->RegisterNotify(iIndex, dwFlags, dwCookie, pNotify); } \
    STDMETHODIMP SuspendNotify(IDatabaseNotify *pNotify) { return _pMember->SuspendNotify(pNotify); } \
    STDMETHODIMP ResumeNotify(IDatabaseNotify *pNotify) { return _pMember->ResumeNotify(pNotify); } \
    STDMETHODIMP UnregisterNotify(IDatabaseNotify *pNotify) { return _pMember->UnregisterNotify(pNotify); } \
    STDMETHODIMP GenerateId(LPDWORD pdwId) { return _pMember->GenerateId(pdwId); } \
    STDMETHODIMP LockNotify(LOCKNOTIFYFLAGS dwFlags, LPHLOCK phLock) { return _pMember->LockNotify(dwFlags, phLock); } \
    STDMETHODIMP UnlockNotify(LPHLOCK phLock) { return _pMember->UnlockNotify(phLock); } \
    STDMETHODIMP GetClientCount(LPDWORD pcClients) { return _pMember->GetClientCount(pcClients); } \
    STDMETHODIMP Repair(void) { return _pMember->Repair(); } \
    STDMETHODIMP HeapFree(LPVOID pBuffer) { return _pMember->HeapFree(pBuffer); } \
    STDMETHODIMP HeapAllocate(DWORD dwFlags, DWORD cbSize, LPVOID *ppBuffer) { return _pMember->HeapAllocate(dwFlags, cbSize, ppBuffer); } \
    STDMETHODIMP GetTransaction(LPHTRANSACTION phTransaction, LPTRANSACTIONTYPE ptyTransaction, LPVOID pRecord1, LPVOID pRecord2, LPINDEXORDINAL piIndex, LPORDINALLIST pOrdinals) { return _pMember->GetTransaction(phTransaction, ptyTransaction, pRecord1, pRecord2, piIndex, pOrdinals); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\enumfold.h ===
//--------------------------------------------------------------------------
// EnumFold.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// CEnumerateFolders
//--------------------------------------------------------------------------
class CEnumerateFolders : public IEnumerateFolders
{
public:
    //----------------------------------------------------------------------
    // CEnumerateFolders
    //----------------------------------------------------------------------
    CEnumerateFolders(void);
    ~CEnumerateFolders(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CEnumerateFolders Members
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDB, BOOL fSubscribed, FOLDERID idParent);

    //----------------------------------------------------------------------
    // IEnumerateFolders Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cFetch, LPFOLDERINFO prgInfo, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cItems);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumerateFolders **ppEnum);
    STDMETHODIMP Count(ULONG *pcItems);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _FreeFolderArray(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    FOLDERID            m_idParent;
    BOOL                m_fSubscribed;
    DWORD               m_cFolders;
    DWORD               m_iFolder;
    IDatabase          *m_pDB;
    IStream            *m_pStream;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\enumfold.cpp ===
//--------------------------------------------------------------------------
// EnumFold.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "enumfold.h"

//--------------------------------------------------------------------------
// CFOLDER_FETCH
//--------------------------------------------------------------------------
#define CFOLDER_FETCH_MIN           5
#define CFOLDER_FETCH_MID           30
#define CFOLDER_FETCH_MAX           200

//--------------------------------------------------------------------------
// CEnumerateFolders::CEnumerateFolders
//--------------------------------------------------------------------------
CEnumerateFolders::CEnumerateFolders(void)
{
    TraceCall("CEnumerateFolders::CEnumerateFolders");
    m_cRef = 1;
    m_pDB = NULL;
    m_fSubscribed = FALSE;
    m_idParent = FOLDERID_INVALID;
    m_pStream = NULL;
    m_cFolders = 0;
    m_iFolder = 0;
}

//--------------------------------------------------------------------------
// CEnumerateFolders::~CEnumerateFolders
//--------------------------------------------------------------------------
CEnumerateFolders::~CEnumerateFolders(void)
{
    TraceCall("CEnumerateFolders::~CEnumerateFolders");
    _FreeFolderArray();
    SafeRelease(m_pDB);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CEnumerateFolders::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumerateFolders == riid)
        *ppv = (IEnumerateFolders *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateFolders::AddRef(void)
{
    TraceCall("CEnumerateFolders::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateFolders::Release(void)
{
    TraceCall("CEnumerateFolders::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CEnumerateFolders::_FreeFolderArray
//--------------------------------------------------------------------------
HRESULT CEnumerateFolders::_FreeFolderArray(void)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder;
    DWORD           cbRead;
    DWORD           cbSeek;

    // Trace
    TraceCall("CEnumerateFolders::_FreeFolderArray");

    // If we have a stream
    if (NULL == m_pStream)
        return(S_OK);

    // Seek to next folder that should be read
    cbSeek = (m_iFolder * sizeof(FOLDERINFO));

    // Seek
    IF_FAILEXIT(hr = HrStreamSeekSet(m_pStream, cbSeek));

    // Read Folder Infos
    while (S_OK == m_pStream->Read(&Folder, sizeof(FOLDERINFO), &cbRead) && cbRead)
    {
        // Free Folder Info
        m_pDB->FreeRecord(&Folder);
    }

exit:
    // Reset
    m_cFolders = m_iFolder = 0;

    // Free
    SafeRelease(m_pStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Initialize
//--------------------------------------------------------------------------
HRESULT CEnumerateFolders::Initialize(IDatabase *pDB, BOOL fSubscribed, 
    FOLDERID idParent)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWORDINAL      iFirstRow;
    HLOCK           hLock=NULL;
    HROWSET         hRowset=NULL;
    FOLDERINFO      Child={0};
    FOLDERINFO      rgFolder[CFOLDER_FETCH_MAX];
    DWORD           cWanted=CFOLDER_FETCH_MIN;
    DWORD           cFetched=0;
    DWORD           i;
    INDEXORDINAL    iIndex;

    // Trace
    TraceCall("CEnumerateFolders::Initialize");

    // Invalid Args
    Assert(pDB);

    // Release Current m_pDB
    SafeRelease(m_pDB);
    m_pDB = pDB;
    m_pDB->AddRef();

    // Unlock
    IF_FAILEXIT(hr = pDB->Lock(&hLock));

    // Free Folder Array
    _FreeFolderArray();

    // Save Subscribed
    m_fSubscribed = fSubscribed;

    // Subscribed Stuff
    iIndex = (fSubscribed ? IINDEX_SUBSCRIBED : IINDEX_ALL);

    // Save parent
    m_idParent = idParent;

    // Set idParent
    Child.idParent = idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(iIndex, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Stream
    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&m_pStream));

    // Write the Folder....
    IF_FAILEXIT(hr = m_pStream->Write(&Child, sizeof(FOLDERINFO), NULL));

    // One Folder
    m_cFolders++;

    // Don't Free Child
    Child.pAllocated = NULL;

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(iIndex, NOFLAGS, &hRowset));

    // Seek the rowset to the first row
    if (FAILED(m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iFirstRow, NULL)))
    {
        hr = S_OK;
        goto exit;
    }

    // Loop and fetch all folders...
    while (SUCCEEDED(m_pDB->QueryRowset(hRowset, cWanted, (LPVOID *)rgFolder, &cFetched)) && cFetched > 0)
    {
        // Write the Folder....
        IF_FAILEXIT(hr = m_pStream->Write(rgFolder, sizeof(FOLDERINFO) * cFetched, NULL));

        // Loop through cFetched
        for (i=0; i<cFetched; i++)
        {
            // Done ?
            if (rgFolder[i].idParent != m_idParent)
                goto exit;

            // Increment Folder Count
            m_cFolders++;
        }

        // Adjust cWanted for Perf.
        if (cWanted < CFOLDER_FETCH_MID && m_cFolders >= CFOLDER_FETCH_MID)
            cWanted = CFOLDER_FETCH_MID;
        if (cWanted < CFOLDER_FETCH_MAX && m_cFolders >= CFOLDER_FETCH_MAX)
            cWanted = CFOLDER_FETCH_MAX;
    }

exit:
    // Commit
    if (m_pStream)
    {
        // Commit
        m_pStream->Commit(STGC_DEFAULT);

        // Rewind
        HrRewindStream(m_pStream);
    }

    // Close the Rowset
    m_pDB->FreeRecord(&Child);

    // Close the Rowset
    m_pDB->CloseRowset(&hRowset);

    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Next
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Next(ULONG cWanted, LPFOLDERINFO prgInfo, ULONG *pcFetched)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cFetched=0;
    DWORD       cbRead;

    // Trace
    TraceCall("CEnumerateFolders::Next");

    // Initialize
    if (pcFetched)
        *pcFetched = 0;

    // Get some Records
    while (cFetched < cWanted && m_iFolder < m_cFolders)
    {
        // Read a Folder
        IF_FAILEXIT(hr = m_pStream->Read(&prgInfo[cFetched], sizeof(FOLDERINFO), &cbRead));

        // Validate
        Assert(sizeof(FOLDERINFO) == cbRead && prgInfo[cFetched].idParent == m_idParent);

        // Increment m_iFolder
        m_iFolder++;

        // Increment iFetch
        cFetched++;
    }

    // Initialize
    if (pcFetched)
        *pcFetched = cFetched;

exit:
    // Done
    return(cFetched == cWanted) ? S_OK : S_FALSE;
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Skip
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Skip(ULONG cItems)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERINFO      Folder;

    // Trace
    TraceCall("CEnumerateFolders::Skip");

    // Loop...
    for (i=0; i<cItems; i++)
    {
        // Next
        IF_FAILEXIT(hr = Next(1, &Folder, NULL));

        // Done
        if (S_OK != hr)
            break;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Reset
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Reset(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CEnumerateFolders::Reset");

    // Initialize MySelf
    IF_FAILEXIT(hr = Initialize(m_pDB, m_fSubscribed, m_idParent));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Clone
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Clone(IEnumerateFolders **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumerateFolders  *pEnum=NULL;

    // Trace
    TraceCall("CEnumerateFolders::Clone");

    // Allocate a New Enumerator
    IF_NULLEXIT(pEnum = new CEnumerateFolders);

    // Initialzie
    IF_FAILEXIT(hr = pEnum->Initialize(m_pDB, m_fSubscribed, m_idParent));

    // Return It
    *ppEnum = (IEnumerateFolders *)pEnum;

    // Don't Release It
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateFolders::Count(ULONG *pcItems)
{
    // Trace
    TraceCall("CEnumerateFolders::Next");

    // Return Folder count
    *pcItems = m_cFolders;

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\enummsgs.h ===
//--------------------------------------------------------------------------
// EnumMsgs.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// CEnumerateMessages
//--------------------------------------------------------------------------
class CEnumerateMessages : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // CEnumerateMessages
    //----------------------------------------------------------------------
    CEnumerateMessages(void);
    ~CEnumerateMessages(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CEnumerateMessages Members
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDB, MESSAGEID idParent);

    //----------------------------------------------------------------------
    // IEnumerateFolders Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cFetch, LPMESSAGEINFO prgInfo, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cItems);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(CEnumerateMessages **ppEnum);
    STDMETHODIMP Count(ULONG *pcItems);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    HROWSET             m_hRowset;
    MESSAGEID           m_idParent;
    IDatabase     *m_pDB;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\enumsync.cpp ===
#include "pch.hxx"
#include "syncop.h"
#include "sync.h"
#include "enumsync.h"

//--------------------------------------------------------------------------
// CEnumerateSyncOps::CEnumerateSyncOps
//--------------------------------------------------------------------------
CEnumerateSyncOps::CEnumerateSyncOps(void)
{
    m_cRef = 1;
    m_pid = NULL;
    m_iid = 0;
    m_cid = 0;
    m_cidBuf = 0;
    m_pDB = NULL;
    m_idServer = FOLDERID_INVALID;
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::~CEnumerateSyncOps
//--------------------------------------------------------------------------
CEnumerateSyncOps::~CEnumerateSyncOps(void)
{
    SafeMemFree(m_pid);
    SafeRelease(m_pDB);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateSyncOps::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateSyncOps::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateSyncOps::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Initialize
//--------------------------------------------------------------------------
HRESULT CEnumerateSyncOps::Initialize(IDatabase *pDB, FOLDERID idServer)
{
    SYNCOPINFO      info;
    HROWSET         hRowset;
    DWORD           cBuf;
    HRESULT         hr;
    ROWORDINAL      iRow;

    Assert(pDB);

    Assert(idServer != m_idServer);

    // Save parent
    m_idServer = idServer;

    // Save pStore
    if (m_pDB != NULL)
        m_pDB->Release();
    m_pDB = pDB;
    m_pDB->AddRef();

    m_iid = 0;
    m_cid = 0;

    ZeroMemory(&info, sizeof(SYNCOPINFO));
    info.idServer = idServer;
    hr = m_pDB->FindRecord(IINDEX_ALL, 1, &info, &iRow);
    if (hr != DB_S_FOUND)
        return(S_OK);
    m_pDB->FreeRecord(&info);

    hr = m_pDB->CreateRowset(IINDEX_ALL, NOFLAGS, &hRowset);
    if (FAILED(hr))
        return(hr);

    hr = m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iRow - 1, NULL);
    if (SUCCEEDED(hr))
    {
        while (S_OK == m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&info, NULL))
        {
            if (info.idServer != idServer)
            {
                m_pDB->FreeRecord(&info);
                break;
            }

            if (m_cid == m_cidBuf)
            {
                cBuf = m_cidBuf + 256;
                if (!MemRealloc((void **)&m_pid, cBuf * sizeof(SYNCOPID)))
                {
                    m_pDB->FreeRecord(&info);
                    hr = E_OUTOFMEMORY;
                    break;
                }
                m_cidBuf = cBuf;
            }

            m_pid[m_cid] = info.idOperation;
            m_cid++;

            m_pDB->FreeRecord(&info);
        }
    }

    m_pDB->CloseRowset(&hRowset);

    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Next
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateSyncOps::Next(LPSYNCOPINFO pInfo)
{
    HRESULT hr;

    // Validate
    Assert(m_pDB != NULL);
    Assert(pInfo != NULL);

    if (m_iid >= m_cid)
        return(S_FALSE);

    ZeroMemory(pInfo, sizeof(SYNCOPINFO));
    pInfo->idOperation = m_pid[m_iid++];

    // Locate where the first record with idParent
    hr = m_pDB->FindRecord(IINDEX_PRIMARY, 1, pInfo, NULL);

    // Not Found
    if (DB_S_NOTFOUND == hr)
        hr = E_FAIL;
    else if (SUCCEEDED(hr))
        hr = S_OK;

    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateSyncOps::Release
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateSyncOps::Count(ULONG *pcItems)
{
    Assert(pcItems != NULL);
    *pcItems = m_cid;

    return(S_OK);
}

STDMETHODIMP CEnumerateSyncOps::Reset()
{
    m_iid = 0;

    return(S_OK);
}

STDMETHODIMP CEnumerateSyncOps::Skip(ULONG cItems)
{
    m_iid += cItems;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\enummsgs.cpp ===
//--------------------------------------------------------------------------
// EnumMsgs.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "enummsgs.h"

//--------------------------------------------------------------------------
// CEnumerateMessages::CEnumerateMessages
//--------------------------------------------------------------------------
CEnumerateMessages::CEnumerateMessages(void)
{
    TraceCall("CEnumerateMessages::CEnumerateMessages");
    m_cRef = 1;
    m_hRowset = NULL;
    m_pDB = NULL;
    m_idParent = MESSAGEID_INVALID;
}

//--------------------------------------------------------------------------
// CEnumerateMessages::~CEnumerateMessages
//--------------------------------------------------------------------------
CEnumerateMessages::~CEnumerateMessages(void)
{
    TraceCall("CEnumerateMessages::~CEnumerateMessages");
    if (m_hRowset && m_pDB)
        m_pDB->CloseRowset(&m_hRowset);
    SafeRelease(m_pDB);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CEnumerateMessages::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateMessages::AddRef(void)
{
    TraceCall("CEnumerateMessages::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumerateMessages::Release(void)
{
    TraceCall("CEnumerateMessages::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Initialize
//--------------------------------------------------------------------------
HRESULT CEnumerateMessages::Initialize(IDatabase *pDB, MESSAGEID idParent)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Child={0};
    ROWORDINAL      iFirstRow;

    // Trace
    TraceCall("CEnumerateMessages::Initialize");

    // Invalid Args
    Assert(pDB);

    // Reset ?
    if (m_hRowset && m_pDB)
        m_pDB->CloseRowset(&m_hRowset);
    SafeRelease(m_pDB);

    // Save parent
    m_idParent = idParent;

    // Save pStore
    m_pDB = pDB;
    m_pDB->AddRef();

    // Set idParent
    Child.idParent = idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_THREADS, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_THREADS, NOFLAGS, &m_hRowset));

    // Seek the rowset to the first row
    IF_FAILEXIT(hr = m_pDB->SeekRowset(m_hRowset, SEEK_ROWSET_BEGIN, iFirstRow - 1, NULL));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Child);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Next
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Next(ULONG cWanted, LPMESSAGEINFO prgInfo, 
    ULONG *pcFetched)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cFetched=0;

    // Trace
    TraceCall("CEnumerateMessages::Next");

    // Initialize
    if (pcFetched)
        *pcFetched = 0;

    // Nothing
    if (NULL == m_hRowset)
        return(S_FALSE);

    // Validate
    Assert(m_pDB);

    // Query the Rowset for cFetch Rows...
    IF_FAILEXIT(hr = m_pDB->QueryRowset(m_hRowset, cWanted, (LPVOID *)prgInfo, &cFetched));

    // Adjust Actual Fetched based on m_idParent
    while(cFetched && prgInfo[cFetched - 1].idParent != m_idParent)
    {
        // Free prgInfo
        m_pDB->FreeRecord(&prgInfo[cFetched - 1]);

        // Decrement cFetched
        cFetched--;
    }

    // Return pcFetched
    if (pcFetched)
        *pcFetched = cFetched;

exit:
    // Done
    return(cFetched == cWanted) ? S_OK : S_FALSE;
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Skip
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Skip(ULONG cItems)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CEnumerateMessages::Skip");

    // Loop...
    for (i=0; i<cItems; i++)
    {
        // Query the Rowset for cFetch Rows...
        IF_FAILEXIT(hr = m_pDB->QueryRowset(m_hRowset, 1, (LPVOID *)&Message, NULL));

        // Different Parent
        if (Message.idParent != m_idParent)
            break;

        // Free
        m_pDB->FreeRecord(&Message);
    }

exit:
    // Free
    m_pDB->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Reset
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Reset(void)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Child={0};
    ROWORDINAL      iFirstRow;

    // Trace
    TraceCall("CEnumerateMessages::Reset");

    // Close Rowset
    m_pDB->CloseRowset(&m_hRowset);

    // Set idParent
    Child.idParent = m_idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_THREADS, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_THREADS, NOFLAGS, &m_hRowset));

    // Seek the rowset to the first row
    IF_FAILEXIT(hr = m_pDB->SeekRowset(m_hRowset, SEEK_ROWSET_BEGIN, iFirstRow - 1, NULL));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Child);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Clone
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Clone(CEnumerateMessages **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumerateMessages  *pEnum=NULL;

    // Trace
    TraceCall("CEnumerateMessages::Clone");

    // Allocate a New Enumerator
    IF_NULLEXIT(pEnum = new CEnumerateMessages);

    // Initialzie
    IF_FAILEXIT(hr = pEnum->Initialize(m_pDB, m_idParent));

    // Return It
    *ppEnum = (CEnumerateMessages *)pEnum;

    // Don't Release It
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CEnumerateMessages::Release
//--------------------------------------------------------------------------
STDMETHODIMP CEnumerateMessages::Count(ULONG *pcItems)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Child={0};
    MESSAGEINFO     Message={0};
    ROWORDINAL      iFirstRow;
    HROWSET         hRowset;

    // Trace
    TraceCall("CEnumerateMessages::Next");

    // Init
    *pcItems = 0;

    // Set idParent
    Child.idParent = m_idParent;

    // Locate where the first record with idParent
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_THREADS, 1, &Child, &iFirstRow));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = S_OK;
        goto exit;
    }

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_THREADS, NOFLAGS, &hRowset));

    // Seek the rowset to the first row
    IF_FAILEXIT(hr = m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iFirstRow - 1, NULL));

    // Walk the Rowset
    while (S_OK == m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL) && Message.idParent == m_idParent)
    {
        // Increment Count
        (*pcItems)++;

        // Free
        m_pDB->FreeRecord(&Message);
    }

exit:
    // Cleanup
    m_pDB->CloseRowset(&hRowset);
    m_pDB->FreeRecord(&Message);
    m_pDB->FreeRecord(&Child);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\enumsync.h ===
#pragma once

//--------------------------------------------------------------------------
// CEnumerateSyncOps
//--------------------------------------------------------------------------
class CEnumerateSyncOps : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // CEnumerateSyncOps
    //----------------------------------------------------------------------
    CEnumerateSyncOps(void);
    ~CEnumerateSyncOps(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CEnumerateSyncOps Members
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDB, FOLDERID idServer);

    //----------------------------------------------------------------------
    // IEnumerateFolders Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(LPSYNCOPINFO pInfo);
    STDMETHODIMP Count(ULONG *pcItems);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Skip(ULONG cItems);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    SYNCOPID           *m_pid;
    DWORD               m_iid;
    DWORD               m_cid;
    DWORD               m_cidBuf;
    FOLDERID            m_idServer;
    IDatabase          *m_pDB;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\istore.cpp ===
//--------------------------------------------------------------------------
// ISTORE.CPP
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "istore.h"
#include "instance.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "flagconv.h"
#include "storutil.h"
#include "notify.h"

//--------------------------------------------------------------------------
// Flag Conversion functions
//--------------------------------------------------------------------------
DWORD DwConvertSCFStoMSG(DWORD dwSCFS);
DWORD DwConvertMSGtoARF(DWORD dwMSG);
DWORD DwConvertARFtoMSG(DWORD dwARF);
DWORD DwConvertMSGtoIMAP(DWORD dwMSG);

//--------------------------------------------------------------------------
// DwConvertMSGtoARF
//--------------------------------------------------------------------------
DWORD DwConvertMSGtoARF(DWORD dwMSG)
{
    register DWORD dwRet = 0;

    if (dwMSG & MSG_UNSENT)
        dwRet |= ARF_UNSENT;
    if (0 == (dwMSG & MSG_UNREAD))
        dwRet |= ARF_READ;
    if (dwMSG & MSG_NOSECUI)
        dwRet |= ARF_NOSECUI;
    if (dwMSG & MSG_SUBMITTED)
        dwRet |= ARF_SUBMITTED;
    if (dwMSG & MSG_RECEIVED)
        dwRet |= ARF_RECEIVED;
    if (dwMSG & MSG_NEWSMSG)
        dwRet |= ARF_NEWSMSG;
    if (dwMSG & MSG_REPLIED)
        dwRet |= ARF_REPLIED;
    if (dwMSG & MSG_FORWARDED)
        dwRet |= ARF_FORWARDED;
    if (dwMSG & MSG_RCPTSENT)
        dwRet |= ARF_RCPTSENT;
    if (dwMSG & MSG_FLAGGED)
        dwRet |= ARF_FLAGGED;
    if (dwMSG & MSG_VOICEMAIL)
        dwRet |= ARF_VOICEMAIL;

    return dwRet;
}

//--------------------------------------------------------------------------
// DwConvertARFtoMSG
//--------------------------------------------------------------------------
DWORD DwConvertARFtoMSG(DWORD dwARF)
{
    register DWORD dwRet = 0;

    if (dwARF & ARF_UNSENT)
        dwRet |= MSG_UNSENT;
    if (0 == (dwARF & ARF_READ))
        dwRet |= MSG_UNREAD;
    if (dwARF & ARF_NOSECUI)
        dwRet |= MSG_NOSECUI;
    if (dwARF & ARF_SUBMITTED)
        dwRet |= MSG_SUBMITTED;
    if (dwARF & ARF_RECEIVED)
        dwRet |= MSG_RECEIVED;
    if (dwARF & ARF_NEWSMSG)
        dwRet |= MSG_NEWSMSG;
    if (dwARF & ARF_REPLIED)
        dwRet |= MSG_REPLIED;
    if (dwARF & ARF_FORWARDED)
        dwRet |= MSG_FORWARDED;
    if (dwARF & ARF_RCPTSENT)
        dwRet |= MSG_RCPTSENT;
    if (dwARF & ARF_FLAGGED)
        dwRet |= MSG_FLAGGED;
    if (dwARF & ARF_VOICEMAIL)
        dwRet |= MSG_VOICEMAIL;
    
    return dwRet;
}

//--------------------------------------------------------------------------
// CreateInstance_StoreNamespace
//--------------------------------------------------------------------------
HRESULT CreateInstance_StoreNamespace(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CStoreNamespace   *pNew=NULL;

    // Trace
    TraceCall("CreateInstance_StoreNamespace");

    // Invalid Arg
    Assert(NULL != ppUnknown && NULL == pUnkOuter);

    // Create
    IF_NULLEXIT(pNew = new CStoreNamespace);

    // Return the Innter
    *ppUnknown = SAFECAST(pNew, IStoreNamespace *);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// FldInfoToFolderProps
//--------------------------------------------------------------------------
HRESULT FldInfoToFolderProps(LPFOLDERINFO pInfo, LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               cbSize;
    IEnumerateFolders  *pEnum=NULL;

    // Stack...
    TraceCall("FldInfoToFolderProps");

    // Invalid ARg
    Assert(pInfo && pProps);

    // Bad version
    if (sizeof(FOLDERPROPS) != pProps->cbSize)
    {
        AssertSz(FALSE, "Invalid - un-supported version.");
        return TraceResult(MSOEAPI_E_INVALID_STRUCT_SIZE);
    }

    // Save Size
    cbSize = pProps->cbSize;

    // ZeroInit
    ZeroMemory(pProps, sizeof(FOLDERPROPS));

    // Copy the properties
    pProps->cbSize = cbSize;
    pProps->dwFolderId = pInfo->idFolder;
    pProps->cUnread = pInfo->cUnread;
    pProps->cMessage = pInfo->cMessages;
    lstrcpyn(pProps->szName, pInfo->pszName, ARRAYSIZE(pProps->szName));

    // Map the special folder type
    if (FOLDER_NOTSPECIAL == pInfo->tySpecial)
        pProps->sfType = -1;
    else
        pProps->sfType = (pInfo->tySpecial - 1);

    // Enumerate Subscribed Children
    IF_FAILEXIT(hr = g_pStore->EnumChildren(pInfo->idFolder, TRUE, &pEnum));

    // Count
    if (FAILED(pEnum->Count((LPDWORD)&pProps->cSubFolders)))
        pProps->cSubFolders = 0;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// MsgInfoToMessageProps
//--------------------------------------------------------------------------
HRESULT MsgInfoToMessageProps(BOOL fFast, LPMESSAGEINFO pMsgInfo, LPMESSAGEPROPS pProps)
{
    // Locals
    ULONG           cbSize;
    LPBYTE          pbOffsets;

    // Stack
    TraceCall("MsgInfoToMessageProps");

    // Invalid Arg
    Assert(pMsgInfo && pProps);

    // Bad version
    if (sizeof(MESSAGEPROPS) != pProps->cbSize)
    {
        AssertSz(FALSE, "Invalid - un-supported version.");
        return TraceResult(MSOEAPI_E_INVALID_STRUCT_SIZE);
    }

    // Save Size
    cbSize = pProps->cbSize;

    // ZeroInit
    ZeroMemory(pProps, sizeof(MESSAGEPROPS));

    // If Not Fast
    if (FALSE == fFast)
    {
        // Message Size
        pProps->cbMessage = pMsgInfo->cbMessage;

        // Priority
        pProps->priority = (IMSGPRIORITY)pMsgInfo->wPriority;

        // Subject
        pProps->pszSubject = pMsgInfo->pszSubject;

        // Display To
        pProps->pszDisplayTo = pMsgInfo->pszDisplayTo;

        // Dislay From
        pProps->pszDisplayFrom = pMsgInfo->pszDisplayFrom;

        // Normalized Subject
        pProps->pszNormalSubject = pMsgInfo->pszNormalSubj;

        // Received Time
        pProps->ftReceived = pMsgInfo->ftReceived;

        // Sent Time
        pProps->ftSent = pMsgInfo->ftSent;

        // Set dwFlags
        if (ISFLAGSET(pMsgInfo->dwFlags, ARF_VOICEMAIL))
            FLAGSET(pProps->dwFlags, IMF_VOICEMAIL);
        if (ISFLAGSET(pMsgInfo->dwFlags, ARF_NEWSMSG))
            FLAGSET(pProps->dwFlags, IMF_NEWS);

        // Dup the memory
        pbOffsets = (LPBYTE)g_pMalloc->Alloc(pMsgInfo->Offsets.cbSize);

        // If that worked
        if (pbOffsets)
        {
            // Copy the offsets
            CopyMemory(pbOffsets, pMsgInfo->Offsets.pBlobData, pMsgInfo->Offsets.cbSize);

            // Create the Offset Table
            pProps->pStmOffsetTable = new CByteStream(pbOffsets, pMsgInfo->Offsets.cbSize);
        }

        // Better have an offset table
        AssertSz(pProps->pStmOffsetTable, "There is no offset table for this message.");
    }

    // Reset the Size
    pProps->cbSize = cbSize;

    // Store the MessageId
    pProps->dwMessageId = pMsgInfo->idMessage;

    // Store the Language
    pProps->dwLanguage = pMsgInfo->wLanguage;

    // Convert ARF_ to MSG_
    pProps->dwState = DwConvertARFtoMSG(pMsgInfo->dwFlags);

    // Store the Memory
    pProps->dwReserved = (DWORD_PTR)pMsgInfo->pAllocated;

    // pProps owns *ppHeader
    ZeroMemory(pMsgInfo, sizeof(MESSAGEINFO));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CStoreNamespace
//--------------------------------------------------------------------------
CStoreNamespace::CStoreNamespace(void)
{
    TraceCall("CStoreNamespace::CStoreNamespace");
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_cNotify = 0;
    m_prghwndNotify = NULL;
    m_fRegistered = FALSE;
    m_hInitRef = NULL;
    InitializeCriticalSection(&m_cs);
}

//--------------------------------------------------------------------------
// CStoreNamespace::~CStoreNamespace
//--------------------------------------------------------------------------
CStoreNamespace::~CStoreNamespace(void)
{
    TraceCall("CStoreNamespace::~CStoreNamespace");
    SafeMemFree(m_prghwndNotify);
    if (m_fRegistered)
        g_pStore->UnregisterNotify((IDatabaseNotify *)this);
    DeleteCriticalSection(&m_cs);
    g_pInstance->DllRelease();
    CoDecrementInit("CStoreNamespace::Initialize", &m_hInitRef);
}

//--------------------------------------------------------------------------
// CStoreNamespace::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreNamespace::AddRef(void)
{
    TraceCall("CStoreNamespace::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CStoreNamespace::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreNamespace::Release(void)
{
    TraceCall("CStoreNamespace::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CStoreNamespace::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CStoreNamespace::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IStoreNamespace *)this;
    else if (IID_IStoreNamespace == riid)
        *ppv = (IStoreNamespace *)this;
    else if (IID_IStoreCallback == riid)
        *ppv = (IStoreCallback *)this;
    else if (IID_IDatabaseNotify == riid)
        *ppv = (IDatabaseNotify *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::Initialize
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::Initialize(HWND hwndOwner, DWORD dwFlags)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwStart=MSOEAPI_START_COMOBJECT;

    // Stack
    TraceCall("CStoreNamespace::Initialize");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Already Initialized
    if (NULL != m_hInitRef)
    {
        TraceInfo("IStoreNamespace::Initialize has been called more than once.");
        goto exit;
    }

    // Not Current Identity
    if (!ISFLAGSET(dwFlags, NAMESPACE_INITIALIZE_CURRENTIDENTITY))
    {
        // Use Default Identity, must be MS Phone
        FLAGSET(dwStart, MSOEAPI_START_DEFAULTIDENTITY);
    }

    // Initialize the store directory
    IF_FAILEXIT(hr = CoIncrementInit("CStoreNamespace::Initialize", dwStart | MSOEAPI_START_STOREVALIDNODELETE, NULL, &m_hInitRef));

    // Better Have g_pStore
    Assert(g_pStore);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetDirectory
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetDirectory(LPSTR pszPath, DWORD cchMaxPath)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::GetDirectory");

    // Invalid Arg
    if (NULL == pszPath)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Get the directory
    IF_FAILEXIT(hr = GetStoreRootDirectory(pszPath, cchMaxPath));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::OpenSpecialFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::OpenSpecialFolder(LONG sfType, DWORD dwReserved, 
    IStoreFolder **ppFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    IMessageFolder     *pFolder=NULL;
    CStoreFolder       *pComFolder=NULL;

    // Stack
    TraceCall("CStoreNamespace::OpenSpecialFolder");

    // Invalid Arg
    if (sfType <= -1 || sfType >= (FOLDER_MAX - 1) || 0 != dwReserved || NULL == ppFolder)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppFolder = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Ask the store to do the work
    IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, (BYTE)(sfType + 1), &pFolder));

    // Create an IStoreFolder
    IF_NULLEXIT(pComFolder = new CStoreFolder(pFolder, this));

    // Return it
    *ppFolder = (IStoreFolder *)pComFolder;
    (*ppFolder)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pFolder);
    SafeRelease(pComFolder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::OpenFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::OpenFolder(FOLDERID dwFolderId, DWORD dwReserved, 
    IStoreFolder **ppFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    IMessageFolder     *pFolder=NULL;
    CStoreFolder       *pComFolder=NULL;

    // Stack
    TraceCall("CStoreNamespace::OpenFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || 0 != dwReserved || NULL == ppFolder)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppFolder = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Open the folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(dwFolderId, NULL, NOFLAGS, &pFolder));

    // Create an IStoreFolder
    IF_NULLEXIT(pComFolder = new CStoreFolder(pFolder, this));

    // Return it
    *ppFolder = (IStoreFolder *)pComFolder;
    (*ppFolder)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pFolder);
    SafeRelease(pComFolder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CreateFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::CreateFolder(FOLDERID dwParentId, LPCSTR pszName, 
    DWORD dwReserved, LPFOLDERID pdwFolderId)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder;

    // Stack
    TraceCall("CStoreNamespace::CreateFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwParentId || NULL == pszName || 0 != dwReserved || NULL == pdwFolderId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Adjust the Parent
    if (dwParentId == FOLDERID_ROOT)
        dwParentId = FOLDERID_LOCAL_STORE;

    // Init
    *pdwFolderId = FOLDERID_INVALID;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Setup a Folder Info
    ZeroMemory(&Folder, sizeof(FOLDERINFO));
    Folder.idParent = dwParentId;
    Folder.pszName = (LPSTR)pszName;
    Folder.dwFlags = FOLDER_SUBSCRIBED;

    // Create a folder
    IF_FAILEXIT(hr = g_pStore->CreateFolder(NOFLAGS, &Folder, (IStoreCallback *)this));
    
    // Return the Id
    *pdwFolderId = Folder.idFolder;

    // Sucess
    hr = S_OK;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::RenameFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::RenameFolder(FOLDERID dwFolderId, DWORD dwReserved, LPCSTR pszNewName)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::RenameFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || 0 != dwReserved || NULL == pszNewName)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Create a folder
    IF_FAILEXIT(hr = g_pStore->RenameFolder(dwFolderId, pszNewName, NOFLAGS, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::MoveFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::MoveFolder(FOLDERID dwFolderId, FOLDERID dwParentId, DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::MoveFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || FOLDERID_INVALID == dwParentId || 0 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Adjust the Parent
    if (dwParentId == FOLDERID_ROOT)
        dwParentId = FOLDERID_LOCAL_STORE;

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Move the folder
    IF_FAILEXIT(hr = g_pStore->MoveFolder(dwFolderId, dwParentId, NOFLAGS, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::DeleteFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::DeleteFolder(FOLDERID dwFolderId, DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::DeleteFolder");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Delete the folder
    IF_FAILEXIT(hr = g_pStore->DeleteFolder(dwFolderId, DELETE_FOLDER_RECURSIVE, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetFolderProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetFolderProps(FOLDERID dwFolderId, DWORD dwReserved, 
    LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Stack
    TraceCall("CStoreNamespace::GetFolderProps");

    // Invalid Arg
    if (FOLDERID_INVALID == dwFolderId || 0 != dwReserved || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Adjust the Parent
    if (dwFolderId == FOLDERID_ROOT)
        dwFolderId = FOLDERID_LOCAL_STORE;

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Save the structure size
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(dwFolderId, &Folder));

    // FolderInfoToProps
    IF_FAILEXIT(hr = FldInfoToFolderProps(&Folder, pProps));
    
exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CopyMoveMessages
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::CopyMoveMessages(IStoreFolder *pSource, IStoreFolder *pDest, 
    LPMESSAGEIDLIST pMsgIdList, DWORD dwFlags, DWORD dwFlagsRemove,IProgressNotify *pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    ADJUSTFLAGS         AdjustFlags;
    DWORD               dwArfRemoveFlags;
    CStoreFolder       *pComSource=NULL;
    CStoreFolder       *pComDest=NULL;
    IMessageFolder     *pActSource=NULL;
    IMessageFolder     *pActDest=NULL;

    // Stack
    TraceCall("CStoreNamespace::CopyMoveMessages");

    // Invalid Arg
    if (NULL == pSource || NULL == pDest || NULL == pMsgIdList)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Get Actual Soruce Local Store Folder
    IF_FAILEXIT(hr = pSource->QueryInterface(IID_CStoreFolder, (LPVOID *)&pComSource));
    IF_FAILEXIT(hr = pComSource->GetMessageFolder(&pActSource));

    // Get Actual Destination Local Store Folder
    IF_FAILEXIT(hr = pDest->QueryInterface(IID_CStoreFolder, (LPVOID *)&pComDest));
    IF_FAILEXIT(hr = pComDest->GetMessageFolder(&pActDest));

    // Convert dwFlagsRemove to ARF Flags...
    dwArfRemoveFlags = DwConvertMSGtoARF(dwFlagsRemove);

    // Adjust Flags
    AdjustFlags.dwAdd = 0;
    AdjustFlags.dwRemove = dwArfRemoveFlags;

    // Do the Copy or Move
    IF_FAILEXIT(hr = pActSource->CopyMessages(pActDest, dwFlags, pMsgIdList, &AdjustFlags, NULL, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pComSource);
    SafeRelease(pComDest);
    SafeRelease(pActSource);
    SafeRelease(pActDest);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::RegisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::RegisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       i;
    BOOL        fFoundEmpty=FALSE;

    // Stack
    TraceCall("CStoreNamespace::RegisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Try to Find an Empty Spot in m_prghwndNotify
    for (i=0; i<m_cNotify; i++)
    {
        // Empty
        if (NULL == m_prghwndNotify[i])
        {
            // Use It
            m_prghwndNotify[i] = hwnd;

            // Found Empty
            fFoundEmpty = TRUE;

            // Done
            break;
        }
    }

    // Didn't Find an Empty slot ?
    if (FALSE == fFoundEmpty)
    {
        // Add hwnd into the Array
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prghwndNotify, (m_cNotify + 1) * sizeof(HWND)));

        // Store the hwnd
        m_prghwndNotify[m_cNotify] = hwnd;

        // Increment Count
        m_cNotify++;
    }

    // Am I registered yet?
    if (FALSE == m_fRegistered)
    {
        // Register
        IF_FAILEXIT(hr = g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this));

        // We are Registered
        m_fRegistered = TRUE;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::UnregisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::UnregisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       i;

    // Stack
    TraceCall("CStoreNamespace::UnregisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Try to Find an Empty Spot in m_prghwndNotify
    for (i=0; i<m_cNotify; i++)
    {
        // Empty
        if (hwnd == m_prghwndNotify[i])
        {
            // Use It
            m_prghwndNotify[i] = NULL;

            // Done
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::OnNotify
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::OnTransaction(HTRANSACTION hTransaction, 
    DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iNotify;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    ORDINALLIST         Ordinals;
    TRANSACTIONTYPE     tyTransaction;
    FOLDERNOTIFYEX      SendBase;
    INDEXORDINAL        iIndex;
    LPFOLDERNOTIFYEX    pSend=NULL;

    // Trace
    TraceCall("CStoreNamespace::OnNotify");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through info structures
    while (hTransaction)
    {
        // Get Transact
        IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals));

        // Only send notifications about local folders
        if (Folder1.tyFolder == FOLDER_LOCAL)
        {
            // Zero
            ZeroMemory(&SendBase, sizeof(FOLDERNOTIFYEX));

            // TRANSACTION_INSERT
            if (TRANSACTION_INSERT == tyTransaction)
            {
                SendBase.type = NEW_FOLDER;
                SendBase.idFolderNew = Folder1.idFolder;
            }

            // TRANSACTION_UPDATE
            else if (TRANSACTION_UPDATE == tyTransaction)
            {
                // Set Old and New
                SendBase.idFolderOld = Folder1.idFolder;
                SendBase.idFolderNew = Folder2.idFolder;

                // Was this a rename
                if (lstrcmp(Folder1.pszName, Folder2.pszName) != 0)
                    SendBase.type = RENAME_FOLDER;

                // Move
                else if (Folder1.idParent != Folder2.idParent)
                    SendBase.type = MOVE_FOLDER;

                // Unread Change
                else if (Folder1.cUnread != Folder2.cUnread)
                    SendBase.type = UNREAD_CHANGE;

                // Flag Change
                else if (Folder1.dwFlags != Folder2.dwFlags)
                    SendBase.type = UPDATEFLAG_CHANGE;

                // Otherwise, generic catch all
                else
                    SendBase.type = FOLDER_PROPS_CHANGED;
            }

            // TRANSACTION_DELETE
            else if (TRANSACTION_DELETE == tyTransaction)
            {
                SendBase.type = DELETE_FOLDER;
                SendBase.idFolderNew = Folder1.idFolder;
            }

            // Loop through the Notifications
            for (iNotify=0; iNotify<m_cNotify; iNotify++)
            {
                // Do we have a window /
                if (m_prghwndNotify[iNotify])
                {
                    // Is a valid window ?
                    if (IsWindow(m_prghwndNotify[iNotify]))
                    {
                        // Allocate a FolderNotifyEx
                        IF_NULLEXIT(pSend = (LPFOLDERNOTIFYEX)g_pMalloc->Alloc(sizeof(FOLDERNOTIFYEX)));

                        // Copy the Base
                        CopyMemory(pSend, &SendBase, sizeof(FOLDERNOTIFYEX));

                        // Send It
                        SendMessage(m_prghwndNotify[iNotify], WM_FOLDERNOTIFY, 0, (LPARAM)pSend);

                        // Don't Free It
                        pSend = NULL;
                    }

                    // Don't try this window again
                    else
                        m_prghwndNotify[iNotify] = NULL;
                }
            }
        }
    }

exit:
    // Cleanup
    SafeMemFree(pSend);

    // Free Records
    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreNamespace::CompactAll (1 = Fail with no UI)
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::CompactAll(DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwRecurse=RECURSE_ONLYSUBSCRIBED | RECURSE_SUBFOLDERS;

    // Stack
    TraceCall("CStoreNamespace::UnregisterNotification");

    // Invalid Arg
    if (0 != dwReserved && 1 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // No UI
    if (1 == dwReserved)
        FLAGSET(dwRecurse, RECURSE_NOUI);

    // Do the compaction
    IF_FAILEXIT(hr = CompactFolders(NULL, dwRecurse, FOLDERID_LOCAL_STORE));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetFirstSubFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetFirstSubFolder(FOLDERID dwFolderId, 
    LPFOLDERPROPS pProps, LPHENUMSTORE phEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pEnum=NULL;
    
    // Stack
    TraceCall("CStoreNamespace::GetFirstSubFolder");

    // Invalid Arg
    if (NULL == pProps || NULL == phEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // INit
    *phEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Adjust the Parent
    if (dwFolderId == FOLDERID_ROOT)
        dwFolderId = FOLDERID_LOCAL_STORE;

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Create Enumerator
    IF_FAILEXIT(hr = g_pStore->EnumChildren(dwFolderId, TRUE, &pEnum));

    // Pluck off the first item
    IF_FAILEXIT(hr = pEnum->Next(1, &Folder, NULL));

    // Done ?
    if (S_FALSE == hr)
        goto exit;

    // Copy Folder Properties
    IF_FAILEXIT(hr = FldInfoToFolderProps(&Folder, pProps));

    // Set return
    *phEnum = (HENUMSTORE)pEnum;

    // Don't Free
    pEnum = NULL;

exit:
    // Failed Cleanup
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetNextSubFolder
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetNextSubFolder(HENUMSTORE hEnum, LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pEnum=(IEnumerateFolders *)hEnum;

    // Stack
    TraceCall("CStoreNamespace::GetNextSubFolder");

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Pluck off the next item
    IF_FAILEXIT(hr = pEnum->Next(1, &Folder, NULL));

    // Done ?
    if (S_FALSE == hr)
        goto exit;

    // Copy Folder Properties
    IF_FAILEXIT(hr = FldInfoToFolderProps(&Folder, pProps));

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreNamespace::GetSubFolderClose
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreNamespace::GetSubFolderClose(HENUMSTORE hEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    IEnumerateFolders  *pEnum=(IEnumerateFolders *)hEnum;

    // Stack
    TraceCall("CStoreNamespace::GetSubFolderClose");

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not initialized
    if (NULL == m_hInitRef)
    {
        hr = TraceResult(MSOEAPI_E_STORE_INITIALIZE);
        goto exit;
    }

    // Renum pEnum
    SafeRelease(pEnum);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::CStoreFolder
//-------------------------------------------------------------------------- 
CStoreFolder::CStoreFolder(IMessageFolder *pFolder, CStoreNamespace *pNamespace) 
    : m_pFolder(pFolder), m_pNamespace(pNamespace)
{
    TraceCall("CStoreFolder::CStoreFolder");
    Assert(m_pNamespace && m_pFolder);
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_hwndNotify = NULL;
    m_pFolder->AddRef();
    m_pNamespace->AddRef();
    m_pFolder->GetFolderId(&m_idFolder);
    InitializeCriticalSection(&m_cs);
}

//--------------------------------------------------------------------------
// CStoreFolder::CStoreFolder
//-------------------------------------------------------------------------- 
CStoreFolder::~CStoreFolder(void)
{
    TraceCall("CStoreFolder::~CStoreFolder");
    SafeRelease(m_pFolder);
    SafeRelease(m_pNamespace);
    DeleteCriticalSection(&m_cs);
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CStoreFolder::QueryInterface
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreNamespace::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IStoreFolder *)this;
    else if (IID_IStoreFolder == riid)
        *ppv = (IStoreFolder *)this;
    else if (IID_CStoreFolder == riid)
        *ppv = (CStoreFolder *)this;
    else if (IID_IStoreCallback == riid)
        *ppv = (IStoreCallback *)this;
    else if (IID_IDatabaseNotify == riid)
        *ppv = (IDatabaseNotify *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::AddRef
//-------------------------------------------------------------------------- 
STDMETHODIMP_(ULONG) CStoreFolder::AddRef(void)
{
    TraceCall("CStoreFolder::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CStoreFolder::Release
//-------------------------------------------------------------------------- 
STDMETHODIMP_(ULONG) CStoreFolder::Release(void)
{
    TraceCall("CStoreFolder::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CStoreFolder::GetFolderProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetFolderProps(DWORD dwReserved, LPFOLDERPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::GetFolderProps");

    // Invalid Arg
    if (0 != dwReserved || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Call through namespace
    IF_FAILEXIT(hr = m_pNamespace->GetFolderProps(m_idFolder, 0, pProps));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::DeleteMessages
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::DeleteMessages(LPMESSAGEIDLIST pMsgIdList, DWORD dwReserved, 
    IProgressNotify *pProgress)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::DeleteMessages");

    // Invalid Arg
    if (NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg || 0 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Delete me some messages
    IF_FAILEXIT(hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOPROMPT, pMsgIdList, NULL, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::SetLanguage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::SetLanguage(DWORD dwLanguage, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList)
{
    // Locals
    HRESULT          hr=S_OK;
    MESSAGEINFO      MsgInfo={0};
    ULONG            i;

    // Stack
    TraceCall("CStoreFolder::SetLanguage");

    // Invalid Arg
    if (0 != dwReserved || NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Loop through the message ids
    for (i=0; i<pMsgIdList->cMsgs; i++)
    {
        // Initialize MsgInfo with the Id
        MsgInfo.idMessage = pMsgIdList->prgidMsg[i];

        // Find the Row
        IF_FAILEXIT(hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL));

        // If Not found
        if (DB_S_FOUND == hr)
        {
            // Return the Language
            MsgInfo.wLanguage = (WORD)dwLanguage;

            // Update the Record
            IF_FAILEXIT(hr = m_pFolder->UpdateRecord(&MsgInfo));

            // Free It
            m_pFolder->FreeRecord(&MsgInfo);
        }
    }

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::MarkMessagesAsRead
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::MarkMessagesAsRead(BOOL fRead, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList)
{
    // Locals
    HRESULT     hr=S_OK;
    ADJUSTFLAGS AdjustFlags={0};

    // Stack
    TraceCall("CStoreFolder::MarkMessagesAsRead");

    // Invalid Arg
    if (0 != dwReserved || NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Setup AdjustFlags
    if (fRead)
        AdjustFlags.dwAdd = ARF_READ;
    else
        AdjustFlags.dwRemove = ARF_READ;

    // Mark messages as read
    IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(pMsgIdList, &AdjustFlags, NULL, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::SetFlags
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::SetFlags(LPMESSAGEIDLIST pMsgIdList, DWORD dwState, 
    DWORD dwStatemask, LPDWORD prgdwNewFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    ADJUSTFLAGS     AdjustFlags={0};
    DWORD           dwArfState=DwConvertMSGtoARF(dwState);
    DWORD           dwArfStateMask=DwConvertMSGtoARF(dwStatemask);
    MESSAGEINFO     MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::SetFlags");

    // Invalid Arg
    if (NULL == pMsgIdList || NULL == pMsgIdList->prgidMsg)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Setup Adjust Flags
    AdjustFlags.dwAdd = (dwArfState & dwArfStateMask);

    // Mark messages as read
    IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(pMsgIdList, &AdjustFlags, NULL, (IStoreCallback *)this));

    // Convert prgdwNewFlags to MSG_xxx Flags
    if (prgdwNewFlags)
    {
        // Loop through the message ids
        for (ULONG i=0; i<pMsgIdList->cMsgs; i++)
        {
            // Initialize MsgInfo with the Id
            MsgInfo.idMessage = pMsgIdList->prgidMsg[i];

            // Find the Row
            IF_FAILEXIT(hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL));

            // If Not found
            if (DB_S_FOUND == hr)
            {
                // Return the Flags
                prgdwNewFlags[i] = DwConvertARFtoMSG(MsgInfo.dwFlags);

                // Free It
                m_pFolder->FreeRecord(&MsgInfo);
            }
        }
    }

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::OpenMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::OpenMessage(MESSAGEID dwMessageId, REFIID riid, LPVOID *ppvObject)
{
    // Locals
    HRESULT          hr=S_OK;
    MESSAGEINFO      MsgInfo={0};
    IStream         *pStream=NULL;
    IMimeMessage    *pMessage=NULL;

    // Stack
    TraceCall("CStoreFolder::OpenMessage");

    // Invalid Arg
    if (MESSAGEID_INVALID == dwMessageId || NULL == ppvObject || (IID_IStream != riid && IID_IMimeMessage != riid))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppvObject = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Streamout
    // [PaulHi] 6/11/99  Raid 69317
    // This is a security hole.  We can't export a public method that allows anyone
    // to open and read a secure message.
    IF_FAILEXIT(hr = m_pFolder->OpenMessage(dwMessageId, OPEN_MESSAGE_SECURE/*NOFLAGS*/, &pMessage, (IStoreCallback *)this));

    // User just wants a stream out...
    if (IID_IStream == riid)
    {
        // Streamout
        IF_FAILEXIT(hr = pMessage->GetMessageSource(&pStream, NOFLAGS));

        // Set Return
        *ppvObject = pStream;

        // AddRef It
        pStream->AddRef();
    }

    // Otherwise, user wants an IMimeMessage
    else
    {
        // Set Return
        *ppvObject = pMessage;

        // AddRef It
        pMessage->AddRef();
    }

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::SaveMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::SaveMessage(REFIID riid, LPVOID pvObject, DWORD dwMsgFlags, 
    LPMESSAGEID pdwMessageId)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimeMessage       *pMessage=NULL;
    IStream            *pStream=NULL;
    IStream            *pStmSource=NULL;
    MESSAGEID           dwMessageId=MESSAGEID_INVALID;

    // Stack
    TraceCall("CStoreFolder::SaveMessage");

    // Invalid Arg
    if ((IID_IStream != riid && IID_IMimeMessage != riid) || NULL == pvObject)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Creates me a stream to put the message in...
    IF_FAILEXIT(hr = CreateStream(NULL, 0, &pStream, &dwMessageId));

    // If they gave me a stream, I need to create an IMimeMessage
    if (IID_IStream == riid)
    {
        // Cast to a IStream
        pStmSource = (IStream *)pvObject;

        // AddRef
        pStmSource->AddRef();
    }

    // Otherwise, the user gave me a message
    else
    {
        // Cast to a message
        pMessage = (IMimeMessage *)pvObject;

        // AddRef since we release in cleanup
        IF_FAILEXIT(hr = pMessage->GetMessageSource(&pStmSource, 0));
    }

    // Copy pvObject to pStream
    IF_FAILEXIT(hr = HrCopyStream(pStmSource, pStream, NULL));

    // Commit the stream
    IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

    // Creates me a stream to put the message in...
    IF_FAILEXIT(hr = CommitStream(NULL, 0, dwMsgFlags, pStream, dwMessageId, pMessage));

    // Return the message id
    if (pdwMessageId)
        *pdwMessageId = dwMessageId;

    // We commited
    dwMessageId = MESSAGEID_INVALID;
    SafeRelease(pStream);

exit:
    // If we didn't commit
    if (FAILED(hr) && MESSAGEID_INVALID != dwMessageId && pStream)
        CommitStream(NULL, COMMITSTREAM_REVERT, 0, pStream, dwMessageId, NULL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pStmSource);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::CreateStream
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::CreateStream(HBATCHLOCK hBatchLock, DWORD dwReserved, 
    IStream **ppStream, LPMESSAGEID pdwMessageId)
{
    // Locals
    HRESULT          hr=S_OK;
    FILEADDRESS      faStream;

    // Stack
    TraceCall("CStoreFolder::CreateStream");

    // Invalid Arg
    if (0 != dwReserved || NULL == ppStream || NULL == pdwMessageId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Init
    *ppStream = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Generate a message Id
    IF_FAILEXIT(hr = m_pFolder->GenerateId((LPDWORD)pdwMessageId));

    // Create a Stream
    IF_FAILEXIT(hr = m_pFolder->CreateStream(&faStream));

    // Open the Stream
    IF_FAILEXIT(hr = m_pFolder->OpenStream(ACCESS_WRITE, faStream, ppStream));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::CommitStream
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::CommitStream(HBATCHLOCK hBatchLock, DWORD dwFlags, 
    DWORD dwMsgFlags, IStream *pStream, MESSAGEID dwMessageId, 
    IMimeMessage *pMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    DWORD                   dwImfFlags;
    DWORD                   dwArfFlags=DwConvertMSGtoARF(dwMsgFlags);
    IDatabaseStream        *pDBStream=NULL;

    // Stack
    TraceCall("CStoreFolder::CommitStream");

    // Validate
    Assert(hBatchLock == (HBATCHLOCK)this);

    // Invalid Arg
    if (NULL == pStream || MESSAGEID_INVALID == dwMessageId)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Determine if this is an ObjectDB Stream
    IF_FAILEXIT(hr = pStream->QueryInterface(IID_IDatabaseStream, (LPVOID *)&pDBStream));

    // If no stream, this must be a failure
    if (ISFLAGSET(dwFlags, COMMITSTREAM_REVERT))
    {
        // Locals
        FILEADDRESS faStream;

        // Get the Address
        IF_FAILEXIT(hr = pDBStream->GetFileAddress(&faStream));

        // Delete the Stream
        IF_FAILEXIT(hr = m_pFolder->DeleteStream(faStream));

        // Done
        goto exit;
    }

    // Convert the Stream to a REad lock
    IF_FAILEXIT(hr = m_pFolder->ChangeStreamLock(pDBStream, ACCESS_READ));

    // If the user did not passin an IMimeMessage
    if (NULL == pMessage)
    {
        // Create a message object
        IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMessage));

        // Lets rewind the stream
        IF_FAILEXIT(hr = HrRewindStream(pStream));

        // Load the message object with the stream
        IF_FAILEXIT(hr = pMessage->Load(pStream));
    }
    else
        pMessage->AddRef();

    // Get message flags
    pMessage->GetFlags(&dwImfFlags);
    if (ISFLAGSET(dwImfFlags, IMF_VOICEMAIL))
        FLAGSET(dwArfFlags, ARF_VOICEMAIL);

    // Insert the message
    IF_FAILEXIT(hr = m_pFolder->SaveMessage(&dwMessageId, NOFLAGS, dwArfFlags, pDBStream, pMessage, (IStoreCallback *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pMessage);
    SafeRelease(pDBStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::BatchLock
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::BatchLock(DWORD dwReserved, LPHBATCHLOCK phBatchLock)
{
    // Just a simple test
    *phBatchLock = (HBATCHLOCK)this;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::BatchFlush
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::BatchFlush(DWORD dwReserved, HBATCHLOCK hBatchLock)
{
    // Just a simple test
    Assert(hBatchLock == (HBATCHLOCK)this);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::BatchUnlock
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::BatchUnlock(DWORD dwReserved, HBATCHLOCK hBatchLock)
{
    // Just a simple test
    Assert(hBatchLock == (HBATCHLOCK)this);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::RegisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::RegisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::RegisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Somebody is already registered
    if (m_hwndNotify)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Register for notify on the folder
    IF_FAILEXIT(hr = m_pFolder->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, NOTIFY_FOLDER, (IDatabaseNotify *)this));

    // Register for notify on the store
    IF_FAILEXIT(hr = g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, NOTIFY_STORE, (IDatabaseNotify *)this));

    // Hold Onto hwnd
    m_hwndNotify = hwnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::UnregisterNotification
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::UnregisterNotification(DWORD dwReserved, HWND hwnd)
{
    // Locals
    HRESULT hr=S_OK;

    // Stack
    TraceCall("CStoreFolder::UnregisterNotification");

    // Invalid Arg
    if (0 != dwReserved || NULL == hwnd || FALSE == IsWindow(hwnd))
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Nobody is registered
    if (NULL == m_hwndNotify)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Kill It
    m_hwndNotify = NULL;

    // Register for notify
    IF_FAILEXIT(hr = g_pStore->UnregisterNotify((IDatabaseNotify *)this));

    // Register for notify
    IF_FAILEXIT(hr = m_pFolder->UnregisterNotify((IDatabaseNotify *)this));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::Compact
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::Compact(DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwRecurse=RECURSE_ONLYSUBSCRIBED | RECURSE_INCLUDECURRENT;

    // Stack
    TraceCall("CStoreFolder::Compact");

    // Invalid Arg
    if (0 != dwReserved && 1 != dwReserved)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // No UI
    if (1 == dwReserved)
        FLAGSET(dwRecurse, RECURSE_NOUI);

    // Compact
    IF_FAILEXIT(hr = CompactFolders(NULL, dwRecurse, m_idFolder));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetMessageProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetMessageProps(MESSAGEID dwMessageId, DWORD dwFlags, LPMESSAGEPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::GetMessageProps");

    // Invalid Arg
    if (MESSAGEID_INVALID == dwMessageId || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Set Id
    MsgInfo.idMessage = dwMessageId;

    // Find dwMessageId
    IF_FAILEXIT(hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Copy message header to message props
    IF_FAILEXIT(hr = MsgInfoToMessageProps(ISFLAGSET(dwFlags, MSGPROPS_FAST), &MsgInfo, pProps));

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::FreeMessageProps
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::FreeMessageProps(LPMESSAGEPROPS pProps)
{
    // Locals
    DWORD       cbSize;
    MESSAGEINFO MsgInfo;

    // Stack
    TraceCall("CStoreFolder::FreeMessageProps");

    // Invalid Arg
    if (NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Bad version
    if (sizeof(MESSAGEPROPS) != pProps->cbSize)
    {
        AssertSz(FALSE, "Invalid - un-supported version.");
        return TraceResult(MSOEAPI_E_INVALID_STRUCT_SIZE);
    }

    // Save Size
    cbSize = pProps->cbSize;

    // Free the elements
    if (pProps->dwReserved && m_pFolder)
    {
        // Store the Pointer
        MsgInfo.pAllocated = (LPBYTE)pProps->dwReserved;

        // Free It
        m_pFolder->FreeRecord(&MsgInfo);
    }

    // Free the STream
    SafeRelease(pProps->pStmOffsetTable);

    // ZeroInit
    ZeroMemory(pProps, sizeof(MESSAGEPROPS));
    pProps->cbSize = cbSize;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetMessageFolder
//-------------------------------------------------------------------------- 
HRESULT CStoreFolder::GetMessageFolder(IMessageFolder **ppFolder)
{
    // Stack
    TraceCall("CStoreFolder::GetMessageFolder");

    // Invalid Arg
    Assert(ppFolder)

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Retrun
    *ppFolder = m_pFolder;
    (*ppFolder)->AddRef();

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetFirstMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetFirstMessage(DWORD dwFlags, DWORD dwMsgFlags, MESSAGEID dwMsgIdFirst, 
    LPMESSAGEPROPS pProps, LPHENUMSTORE phEnum)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwArfFlags=DwConvertMSGtoARF(dwMsgFlags);
    HROWSET     hRowset=NULL;
    MESSAGEINFO MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::GetFirstMessage");

    // Invalid Arg
    if (NULL == pProps || NULL == phEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Create a Rowset
    IF_FAILEXIT(hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop..
    IF_FAILEXIT(hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL));

    // If Nothing found
    if (S_FALSE == hr)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // MsgInfoToMessageProps
    IF_FAILEXIT(hr = MsgInfoToMessageProps(ISFLAGSET(dwFlags, MSGPROPS_FAST), &MsgInfo, pProps));

    // Return the Handle
    *phEnum = (HENUMSTORE)hRowset;

exit:
    // Failure
    if (FAILED(hr))
        m_pFolder->CloseRowset(&hRowset);

    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetNextMessage
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetNextMessage(HENUMSTORE hEnum, DWORD dwFlags, LPMESSAGEPROPS pProps)
{
    // Locals
    HRESULT     hr=S_OK;
    HROWSET     hRowset=(HROWSET)hEnum;
    MESSAGEINFO MsgInfo={0};

    // Stack
    TraceCall("CStoreFolder::GetNextMessage");

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum || NULL == pProps)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(m_pNamespace && m_pFolder);

    // Loop..
    IF_FAILEXIT(hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL));

    // If Nothing found
    if (S_FALSE == hr)
        goto exit;

    // MsgInfoToMessageProps
    IF_FAILEXIT(hr = MsgInfoToMessageProps(ISFLAGSET(dwFlags, MSGPROPS_FAST), &MsgInfo, pProps));

exit:
    // Cleanup
    m_pFolder->FreeRecord(&MsgInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CStoreFolder::GetMessageClose
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::GetMessageClose(HENUMSTORE hEnum)
{
    // Locals
    HROWSET     hRowset=(HROWSET)hEnum;

    // Invalid Arg
    if (NULL == hEnum || INVALID_HANDLE_VALUE_16 == hEnum)
    {
        AssertSz(FALSE, "Invalid Arguments");
        return TraceResult(E_INVALIDARG);
    }

    // Close the Rowset
    m_pFolder->CloseRowset(&hRowset);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreFolder::OnNotify
//-------------------------------------------------------------------------- 
STDMETHODIMP CStoreFolder::OnTransaction(HTRANSACTION hTransaction, 
    DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    TRANSACTIONTYPE tyTransaction;
    ORDINALLIST     Ordinals;
    MESSAGEINFO     Message1={0};
    MESSAGEINFO     Message2={0};
    FOLDERINFO      Folder1={0};
    FOLDERINFO      Folder2={0};
    UINT            msg=0;
    WPARAM          wParam=0;
    LPARAM          lParam=0;
    INDEXORDINAL    iIndex;

    // Trace
    TraceCall("CStoreFolder::OnNotify");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Notify on the Folder
    if (NOTIFY_FOLDER == dwCookie)
    {
        // Loop through the Notification Info
        while (hTransaction)
        {
            // Get Transact Info
            IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Message1, &Message2, &iIndex, &Ordinals));

            // TRANSACTION_INSERT
            if (TRANSACTION_INSERT == tyTransaction)
            {
                msg = WM_NEWMSGS;
                wParam = (WPARAM)Message1.idMessage;
            }

            // TRANSACTION_UPDATE
            else if (TRANSACTION_UPDATE == tyTransaction)
            {
                // Unread State Change ?
                if (ISFLAGSET(Message1.dwFlags, ARF_READ) != ISFLAGSET(Message2.dwFlags, ARF_READ))
                {
                    // Set w and l param
                    wParam = (WPARAM)&Message2.idMessage;
                    lParam = 1;

                    // Marked as Read
                    if (ISFLAGSET(Message2.dwFlags, ARF_READ))
                        msg = WM_MARKEDASREAD;
                    else
                        msg = WM_MARKEDASUNREAD;
                }
            }

            // TRANSACTION_DELETE
            else if (TRANSACTION_DELETE == tyTransaction)
            {
                // Allocate a message id
                LPMESSAGEID pidMessage = (LPMESSAGEID)g_pMalloc->Alloc(sizeof(MESSAGEID));

                // If that worked
                if (pidMessage)
                {
                    msg = WM_DELETEMSGS;
                    *pidMessage = Message1.idMessage;
                    wParam = (WPARAM)pidMessage;
                    lParam = 1;
                }
            }

            // Do we have a message?
            if (IsWindow(m_hwndNotify))
            {
                // Send Delete Folder Notification
                SendMessage(m_hwndNotify, msg, wParam, lParam);
            }
        }
    }

    // Otherwise, store notification
    else
    {
        // Must be a store notification
        Assert(NOTIFY_STORE == dwCookie);

        // Loop through the Notification Info
        while (hTransaction)
        {
            // Get Transact Info
            IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals));

            // Only Reporting Delete folder Notifications
            if (TRANSACTION_DELETE == tyTransaction)
            {
                // Send Delete Folder Notification
                PostMessage(m_hwndNotify, WM_DELETEFOLDER, (WPARAM)Folder1.idFolder, 0);
            }
        }
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);
    m_pFolder->FreeRecord(&Message1);
    m_pFolder->FreeRecord(&Message2);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\locstore.cpp ===
//--------------------------------------------------------------------------
// LocStore.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "locstore.h"

//--------------------------------------------------------------------------
// CreateLocalStore
//--------------------------------------------------------------------------
HRESULT CreateLocalStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateLocalStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CLocalStore *pNew = new CLocalStore();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IUnknown *);

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// CLocalStore::CLocalStore
//--------------------------------------------------------------------------
CLocalStore::CLocalStore(void)
{
    TraceCall("CLocalStore::CLocalStore");
    g_pInstance->DllAddRef();
    m_cRef = 1;
}

//--------------------------------------------------------------------------
// CLocalStore::~CLocalStore
//--------------------------------------------------------------------------
CLocalStore::~CLocalStore(void)
{
    // Trace
    TraceCall("CLocalStore::~CLocalStore");
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CLocalStore::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CLocalStore::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CLocalStore::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMessageServer == riid)
        *ppv = (IMessageServer *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CLocalStore::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLocalStore::AddRef(void)
{
    TraceCall("CLocalStore::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CLocalStore::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLocalStore::Release(void)
{
    TraceCall("CLocalStore::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\findfold.cpp ===
//--------------------------------------------------------------------------
// FindFold.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "finder.h"
#include "findfold.h"
#include "storutil.h"
#include "msgfldr.h"
#include "shlwapip.h" 
#include "storecb.h"

//--------------------------------------------------------------------------
// ENUMFINDFOLDERS
//--------------------------------------------------------------------------
typedef struct tagENUMFINDFOLDERS {
    LPFOLDERENTRY   prgFolder;
    DWORD           cFolders;
    DWORD           cAllocated;
    DWORD           cMax;
} ENUMFINDFOLDERS, *LPENUMFINDFOLDERS;

//--------------------------------------------------------------------------
// CLEAR_MESSAGE_FIELDS(_pMessage)
//--------------------------------------------------------------------------
#define CLEAR_MESSAGE_FIELDS(_Message) \
    _Message.pszUidl = NULL; \
    _Message.pszServer = NULL; \
    _Message.faStream = 0; \
    _Message.Offsets.cbSize = 0; \
    _Message.Offsets.pBlobData = NULL

//--------------------------------------------------------------------------
// EnumerateFindFolders
//--------------------------------------------------------------------------
HRESULT EnumerateFindFolders(LPFOLDERINFO pFolder, BOOL fSubFolders,
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERID            idDeleted;
    FOLDERID            idServer;
    LPENUMFINDFOLDERS   pEnum=(LPENUMFINDFOLDERS)dwCookie;
    LPFOLDERENTRY       pEntry;
    IMessageFolder     *pFolderObject=NULL;

    // Trace
    TraceCall("EnumerateFindFolders");

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) || FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Room For One More
    if (pEnum->cFolders + 1 > pEnum->cAllocated)
    {
        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&pEnum->prgFolder, sizeof(FOLDERENTRY) * (pEnum->cAllocated + 5)));

        // Set cAllocated
        pEnum->cAllocated += 5;
    }

    // Readability
    pEntry = &pEnum->prgFolder[pEnum->cFolders];

    // Open the Folder
    if (SUCCEEDED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
    {
        // Get the Database
        if (SUCCEEDED(pFolderObject->GetDatabase(&pEntry->pDB)))
        {
            // No Folder
            pEntry->pFolder = NULL;

            // fInDeleted
            if (S_OK == IsParentDeletedItems(pFolder->idFolder, &idDeleted, &idServer))
            {
                // We are in the deleted items folder
                pEntry->fInDeleted = TRUE;
            }

            // Otherwise, not in deleted items
            else
            {
                // Nope
                pEntry->fInDeleted = FALSE;
            }

            // Count Record
            IF_FAILEXIT(hr = pEntry->pDB->GetRecordCount(IINDEX_PRIMARY, &pEntry->cRecords));

            // Save the Folder id
            pEntry->idFolder = pFolder->idFolder;

            // Save the Folder Type
            pEntry->tyFolder = pFolder->tyFolder;

            // Increment Max
            pEnum->cMax += pEntry->cRecords;

            // Copy folder Name
            IF_NULLEXIT(pEntry->pszName = PszDupA(pFolder->pszName));

            // Increment Folder Count
            pEnum->cFolders++;
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolderObject);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::CFindFolder
//--------------------------------------------------------------------------
CFindFolder::CFindFolder(void)
{
    m_cRef = 1;
    m_pCriteria = NULL;
    m_pSearch = NULL;
    m_pStore = NULL;
    m_cFolders = 0;
    m_cAllocated = 0;
    m_cMax = 0;
    m_cCur = 0;
    m_fCancel = FALSE;
    m_prgFolder = NULL;
    m_pCallback = NULL;
    m_idRoot = FOLDERID_INVALID;
    m_idFolder = FOLDERID_INVALID;
    m_pMessage = NULL;
}

//--------------------------------------------------------------------------
// CFindFolder::~CFindFolder
//--------------------------------------------------------------------------
CFindFolder::~CFindFolder(void)
{
    // Locals
    LPACTIVEFINDFOLDER pCurrent;
    LPACTIVEFINDFOLDER pPrevious=NULL;

    // Thread Safety
    EnterCriticalSection(&g_csFindFolder);

    // Walk Through the global list of Active Search Folders
    for (pCurrent=g_pHeadFindFolder; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Is this it
        if (m_idFolder == pCurrent->idFolder)
        {
            // If there was a Previous
            if (pPrevious)
                pPrevious->pNext = pCurrent->pNext;

            // Otherwise, reset the header
            else
                g_pHeadFindFolder = pCurrent->pNext;

            // Free pCurrent
            g_pMalloc->Free(pCurrent);

            // Done
            break;
        }

        // Save Previous
        pPrevious = pCurrent;
    }

    // Thread Safety
    LeaveCriticalSection(&g_csFindFolder);

    // Release Database
    SafeRelease(m_pSearch);

    // Delete this folder
    if (FOLDERID_INVALID != m_idFolder && m_pStore)
    {
        // Delete this folder
        m_pStore->DeleteFolder(m_idFolder, DELETE_FOLDER_NOTRASHCAN, (IStoreCallback *)this);
    }

    // Release the Store
    SafeRelease(m_pStore);

    // Release the Callback
    SafeRelease(m_pCallback);

    // Free the Folder Array
    for (ULONG i=0; i<m_cFolders; i++)
    {
        // Free the Folder Name
        SafeMemFree(m_prgFolder[i].pszName);

        // Remove Notify
        m_prgFolder[i].pDB->UnregisterNotify((IDatabaseNotify *)this);

        // Release the Folder Object
        SafeRelease(m_prgFolder[i].pDB);

        // Release the Folder Object
        SafeRelease(m_prgFolder[i].pFolder);
    }

    // Release my mime message
    SafeRelease(m_pMessage);

    // Free the Array
    SafeMemFree(m_prgFolder);

    // Free Find Info
    if (m_pCriteria)
    {
        FreeFindInfo(m_pCriteria);
        SafeMemFree(m_pCriteria);
    }
}

//--------------------------------------------------------------------------
// CFindFolder::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFindFolder::AddRef(void)
{
    TraceCall("CFindFolder::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CFindFolder::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFindFolder::Release(void)
{
    TraceCall("CFindFolder::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CFindFolder::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CFindFolder::QueryInterface");

    // Invalid Arg
    Assert(ppv);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageFolder *)this;
    else if (IID_IMessageFolder == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IDatabaseNotify == riid)
        *ppv = (IDatabaseNotify *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::QueryService
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::QueryService(REFGUID guidService, REFIID riid, 
    LPVOID *ppvObject)
{
    // Trace
    TraceCall("CFindFolder::QueryService");

    // Just a Query Interface
    return(QueryInterface(riid, ppvObject));
}

//--------------------------------------------------------------------------
// CFindFolder::Initialize
//--------------------------------------------------------------------------
HRESULT CFindFolder::Initialize(IMessageStore *pStore, IMessageServer *pServer, 
    OPENFOLDERFLAGS dwFlags, FOLDERID idFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    FOLDERUSERDATA      UserData={0};
    TABLEINDEX          Index;
    LPACTIVEFINDFOLDER  pActiveFind;

    // Trace
    TraceCall("CFindFolder::Initialize");

    // I don't need a server
    Assert(NULL == pServer);

    // Invalid Arg
    if (NULL == pStore)
        return TraceResult(E_INVALIDARG);

    // Should be NULL
    Assert(NULL == m_pCriteria);

    // Save the Folder Id
    m_idRoot = idFolder;

    // Save the Store
    m_pStore = pStore;
    m_pStore->AddRef();

    // Fill Up My folder Info
    Folder.pszName = "Search Folder";
    Folder.tyFolder = FOLDER_LOCAL;
    Folder.tySpecial = FOLDER_NOTSPECIAL;
    Folder.dwFlags = FOLDER_HIDDEN | FOLDER_FINDRESULTS;
    Folder.idParent = FOLDERID_LOCAL_STORE;

    // Create a Folder
    IF_FAILEXIT(hr = m_pStore->CreateFolder(CREATE_FOLDER_UNIQUIFYNAME, &Folder, (IStoreCallback *)this));

    // Save the Id
    m_idFolder = Folder.idFolder;

    // Create a CMessageFolder Object
    IF_NULLEXIT(m_pSearch = new CMessageFolder);

    // Initialize
    IF_FAILEXIT(hr = m_pSearch->Initialize((IMessageStore *)pStore, NULL, NOFLAGS, m_idFolder));

    // Fill the IINDEX_FINDER Information
    ZeroMemory(&Index, sizeof(TABLEINDEX));
    Index.cKeys = 2;
    Index.rgKey[0].iColumn = MSGCOL_FINDFOLDER;
    Index.rgKey[1].iColumn = MSGCOL_FINDSOURCE;

    // Set Index
    IF_FAILEXIT(hr = m_pSearch->ModifyIndex(IINDEX_FINDER, NULL, &Index));

    // Allocate ACTIVEFINDFOLDER
    IF_NULLEXIT(pActiveFind = (LPACTIVEFINDFOLDER)ZeroAllocate(sizeof(ACTIVEFINDFOLDER)));

    // Set idFolder
    pActiveFind->idFolder = m_idFolder;

    // Set this
    pActiveFind->pFolder = this;

    // Thread Safety
    EnterCriticalSection(&g_csFindFolder);

    // Set Next
    pActiveFind->pNext = g_pHeadFindFolder;

    // Set Head
    g_pHeadFindFolder = pActiveFind;

    // Thread Safety
    LeaveCriticalSection(&g_csFindFolder);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::GetMessageFolderId
//--------------------------------------------------------------------------
HRESULT CFindFolder::GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message={0};

    // Trace
    TraceCall("CFindFolder::GetMessageFolderId");

    // Invalid Args
    if (NULL == m_pSearch || NULL == pidFolder)
        return TraceResult(E_INVALIDARG);

    // Initialize Message
    IF_FAILEXIT(hr = GetMessageInfo(m_pSearch, idMessage, &Message));

    // Get the Folder Entry
    *pidFolder = m_prgFolder[Message.iFindFolder].idFolder;

exit:
    // Done
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::GetMessageFolderType
//--------------------------------------------------------------------------
HRESULT CFindFolder::GetMessageFolderType(MESSAGEID idMessage, 
    FOLDERTYPE *ptyFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message={0};

    // Trace
    TraceCall("CFindFolder::GetMessageFolderType");

    // Invalid Args
    if (NULL == m_pSearch || NULL == ptyFolder)
        return TraceResult(E_INVALIDARG);

    // Initialize Message
    IF_FAILEXIT(hr = GetMessageInfo(m_pSearch, idMessage, &Message));

    // Get the Folder Entry
    *ptyFolder = m_prgFolder[Message.iFindFolder].tyFolder;

exit:
    // Done
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::StartFind
//--------------------------------------------------------------------------
HRESULT CFindFolder::StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    RECURSEFLAGS    dwFlags=RECURSE_ONLYSUBSCRIBED;
    ENUMFINDFOLDERS EnumFolders={0};

    // Trace
    TraceCall("CFindFolder::StartFind");

    // Invalid Arg
    if (NULL == pCriteria || NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Should be NULL
    Assert(NULL == m_pCriteria && m_pStore);

    // Allocate m_pCriteria
    IF_NULLEXIT(m_pCriteria = (FINDINFO *)g_pMalloc->Alloc(sizeof(FINDINFO)));

    // Copy the Find Info
    IF_FAILEXIT(hr = CopyFindInfo(pCriteria, m_pCriteria));

    // Hold Onto the Callback
    m_pCallback = pCallback;
    m_pCallback->AddRef();

    // Setup Flags
    if (FOLDERID_ROOT != m_idRoot)
        FLAGSET(dwFlags, RECURSE_INCLUDECURRENT);

    // SubFolder
    if (m_pCriteria->fSubFolders) 
        FLAGSET(dwFlags, RECURSE_SUBFOLDERS);

    // Build my Folder Table
    IF_FAILEXIT(hr = RecurseFolderHierarchy(m_idRoot, dwFlags, 0, (DWORD_PTR)&EnumFolders, (PFNRECURSECALLBACK)EnumerateFindFolders));

    // Take Stuff Back
    m_prgFolder = EnumFolders.prgFolder;
    m_cFolders = EnumFolders.cFolders;
    m_cAllocated = EnumFolders.cAllocated;
    m_cMax = EnumFolders.cMax;

    // Start the find...
    IF_FAILEXIT(hr = _StartFind());

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_StartFind
//--------------------------------------------------------------------------
HRESULT CFindFolder::_StartFind(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;

    // Trace
    TraceCall("CFindFolder::_StartFind");

    // Callback
    if (m_pCallback)
        m_pCallback->OnBegin(SOT_SEARCHING, NULL, (IOperationCancel *)this);

    // Loop through the Folders
    for (i=0; i<m_cFolders; i++)
    {
        // Query the Folder
        IF_FAILEXIT(hr = _SearchFolder(i));
    }

exit:
    // Callback
    if (m_pCallback)
        m_pCallback->OnComplete(SOT_SEARCHING, hr, NULL, NULL);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_SearchFolder
//--------------------------------------------------------------------------
HRESULT CFindFolder::_SearchFolder(DWORD iFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iRow=0;
    DWORD           cRows=0;
    HROWSET         hRowset=NULL;
    LPSTR           pszName;
    HLOCK           hNotify=NULL;
    MESSAGEINFO     rgMessage[100];
    BOOL            fFree=FALSE;
    LPFOLDERENTRY   pEntry;
    BOOL            fMatch;
    IDatabase      *pDB;
    DWORD           cMatch=0;

    // Trace
    TraceCall("CFindFolder::_SearchFolder");

    // Get pEntry
    pEntry = &m_prgFolder[iFolder];

    // Get the Folder Name
    pszName = pEntry->pszName;

    // Get the Folder Object
    pDB = pEntry->pDB;

    // Create a Rowset for this Folder
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Progress
    if (m_fCancel || (m_pCallback && S_FALSE == m_pCallback->OnProgress(SOT_SEARCHING, m_cCur, m_cMax, pszName)))
        goto exit;

    // Queue Notifications
    IF_FAILEXIT(hr = m_pSearch->LockNotify(NOFLAGS, &hNotify));

    // Walk the Rowset
    while (S_OK == pDB->QueryRowset(hRowset, 100, (LPVOID *)rgMessage, &cRows))
    {
        // Need to Free
        fFree = TRUE;

        // Walk through the Rows
        for (iRow=0; iRow<cRows; iRow++)
        {
            // Does Row Match Criteria
            IF_FAILEXIT(hr = _OnInsert(iFolder, &rgMessage[iRow], &fMatch));

            // Count Matched
            if (fMatch)
                cMatch++;

            // Incrment m_cCur
            m_cCur++;

            // Adjust the max
            if (m_cCur > m_cMax)
                m_cMax = m_cCur;

            // Do Progress Stuff
            if ((m_cCur % 50) == 0 && m_cCur > 0)
            {
                // Progress
                if (m_fCancel || (m_pCallback && S_FALSE == m_pCallback->OnProgress(SOT_SEARCHING, m_cCur, m_cMax, NULL)))
                {
                    // Register for a notifications on the stuff that we've searched
                    pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, iFolder, (IDatabaseNotify *)this);

                    // Done..
                    goto exit;
                }
            }

            // Do Progress Stuff
            if ((cMatch % 50) == 0 && cMatch > 0)
            {
                // Unlock the Notificaton Queue
                m_pSearch->UnlockNotify(&hNotify);

                // Lock It Again
                m_pSearch->LockNotify(NOFLAGS, &hNotify);
            }

            // Free It
            pDB->FreeRecord(&rgMessage[iRow]);
        }

        // No Need to Free
        fFree = FALSE;
    }

    // Register for a notificatoin on this folder
    pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, iFolder, (IDatabaseNotify *)this);

exit:
    // Unlock the Notificaton Queue
    m_pSearch->UnlockNotify(&hNotify);

    // Free ?
    if (fFree)
    {
        // Loop through remaining unfreed rows
        for (; iRow<cRows; iRow++)
        {
            // Free the Row
            pDB->FreeRecord(&rgMessage[iRow]);
        }
    }

    // Cleanup
    pDB->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_OnInsert
//--------------------------------------------------------------------------
HRESULT CFindFolder::_OnInsert(DWORD iFolder, LPMESSAGEINFO pInfo,
    BOOL *pfMatch, LPMESSAGEID pidNew /* =NULL */)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message;

    // Trace
    TraceCall("CFindFolder::_OnInsert");

    // Invalid Argts
    Assert(iFolder < m_cFolders && pInfo);

    // Init
    if (pfMatch)
        *pfMatch = FALSE;

    // Doesn't match my criteria ?
    if (S_FALSE == _IsMatch(iFolder, pInfo))
        goto exit;

    // Init
    if (pfMatch)
        *pfMatch = TRUE;

    // Copy the Message Info
    CopyMemory(&Message, pInfo, sizeof(MESSAGEINFO));

    // Store the Folder Name
    Message.pszFolder = m_prgFolder[iFolder].pszName;

    // Set the Source Id
    Message.idFindSource = Message.idMessage;

    // Set the Tag
    Message.iFindFolder = iFolder;

    // Generate a New Message Id
    IF_FAILEXIT(hr = m_pSearch->GenerateId((LPDWORD)&Message.idMessage));

    // Remove some stuff to make it smaller
    CLEAR_MESSAGE_FIELDS(Message);

    // Insert the Record
    IF_FAILEXIT(hr = m_pSearch->InsertRecord(&Message));

    // Return the Id
    if (pidNew)
        *pidNew = Message.idMessage;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_OnDelete
//--------------------------------------------------------------------------
HRESULT CFindFolder::_OnDelete(DWORD iFolder, LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message={0};

    // Trace
    TraceCall("CFindFolder::_OnDelete");

    // Invalid Argts
    Assert(iFolder < m_cFolders && pInfo);

    // Setup the Search key
    Message.iFindFolder = iFolder;
    Message.idFindSource = pInfo->idMessage;

    // Find It
    IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_FINDER, COLUMNS_ALL, &Message, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Delete this Record
    IF_FAILEXIT(hr = m_pSearch->DeleteRecord(&Message));
        
exit:
    // Cleanup
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_OnUpdate
//--------------------------------------------------------------------------
HRESULT CFindFolder::_OnUpdate(DWORD iFolder, LPMESSAGEINFO pInfo1,
    LPMESSAGEINFO pInfo2)
{
    // Locals
    HRESULT     hr=S_OK;
    MESSAGEINFO Message;
    MESSAGEINFO Current={0};

    // Trace
    TraceCall("CFindFolder::_OnUpdate");

    // Invalid Argts
    Assert(iFolder < m_cFolders && pInfo1 && pInfo2);

    // Doesn't match my criteria ?
    if (S_FALSE == _IsMatch(iFolder, pInfo1))
    {
        // If the Original Record was not in the find folder, then see if record 2 should be added
        _OnInsert(iFolder, pInfo2, NULL);
    }

    // If pInfo2 should not be displayed, then delete pInfo1
    else if (S_FALSE == _IsMatch(iFolder, pInfo2))
    {
        // Delete pInfo1
        _OnDelete(iFolder, pInfo1);
    }

    // Otherwise, update pInfo1
    else
    {
        // Setup the Search key
        Current.iFindFolder = iFolder;
        Current.idFindSource = pInfo1->idMessage;

        // Find It
        IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_FINDER, COLUMNS_ALL, &Current, NULL));

        // Not Found
        if (DB_S_NOTFOUND == hr)
        {
            hr = TraceResult(DB_E_NOTFOUND);
            goto exit;
        }
        
        // Copy the Message Info
        CopyMemory(&Message, pInfo2, sizeof(MESSAGEINFO));

        // Fixup the Version
        Message.bVersion = Current.bVersion;

        // Store the Folder Name
        Message.pszFolder = m_prgFolder[iFolder].pszName;

        // Set the Source Id
        Message.idFindSource = Current.idFindSource;

        // Set the Tag
        Message.iFindFolder = iFolder;

        // Set the id
        Message.idMessage = Current.idMessage;

        // Remove some stuff to make it smaller
        Message.pszUidl = NULL;
        Message.pszServer = NULL;
        Message.faStream = 0;

        // Insert the Record
        IF_FAILEXIT(hr = m_pSearch->UpdateRecord(&Message));
    }

exit:
    // Cleanup
    m_pSearch->FreeRecord(&Current);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_IsMatch
//--------------------------------------------------------------------------
HRESULT CFindFolder::_IsMatch(DWORD iFolder, LPMESSAGEINFO pInfo)
{
    // Trace
    TraceCall("CFindFolder::_ProcessMessageInfo");

    // Has Attachment
    if (ISFLAGSET(m_pCriteria->mask, FIM_ATTACHMENT))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_HASATTACH))
            return(S_FALSE);
    }

    // Is Flagged
    if (ISFLAGSET(m_pCriteria->mask, FIM_FLAGGED))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_FLAGGED))
            return(S_FALSE);
    }

    // Was Forwarded
    if (ISFLAGSET(m_pCriteria->mask, FIM_FORWARDED))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_FORWARDED))
            return(S_FALSE);
    }

    // Was Replied to
    if (ISFLAGSET(m_pCriteria->mask, FIM_REPLIED))
    {
        // No Attachment
        if (FALSE == ISFLAGSET(pInfo->dwFlags, ARF_REPLIED))
            return(S_FALSE);
    }

    // From
    if (ISFLAGSET(m_pCriteria->mask, FIM_FROM))
    {
        // No pszFrom
        if (NULL == m_pCriteria->pszFrom)
            return(S_FALSE);

        // Check pszEmail From
        if (NULL == pInfo->pszDisplayFrom || NULL == StrStrIA(pInfo->pszDisplayFrom, m_pCriteria->pszFrom))
        {
            // Try Email
            if (NULL == pInfo->pszEmailFrom || NULL == StrStrIA(pInfo->pszEmailFrom, m_pCriteria->pszFrom))
                return(S_FALSE);
        }
    }

    // Subject
    if (ISFLAGSET(m_pCriteria->mask, FIM_SUBJECT))
    {
        // Check Subject
        if (NULL == m_pCriteria->pszSubject || NULL == pInfo->pszSubject || NULL == StrStrIA(pInfo->pszSubject, m_pCriteria->pszSubject))
            return(S_FALSE);
    }

    // Recipient
    if (ISFLAGSET(m_pCriteria->mask, FIM_TO))
    {
        // No pszFrom
        if (NULL == m_pCriteria->pszTo)
            return(S_FALSE);

        // Check pszEmail From
        if (NULL == pInfo->pszDisplayTo || NULL == StrStrIA(pInfo->pszDisplayTo, m_pCriteria->pszTo))
        {
            // Try Email
            if (NULL == pInfo->pszEmailTo || NULL == StrStrIA(pInfo->pszEmailTo, m_pCriteria->pszTo))
                return(S_FALSE);
        }
    }

    // DateFrom <= pInfo <= DateTo
    if (ISFLAGSET(m_pCriteria->mask, FIM_DATEFROM))
    {
        // Locals
        FILETIME ftLocal;

        // Convert to local file time
        FileTimeToLocalFileTime(&pInfo->ftReceived, &ftLocal);

        // Compare Received
        if (CompareFileTime(&ftLocal, &m_pCriteria->ftDateFrom) < 0)
            return(S_FALSE);
    }

    // DateFrom <= pInfo <= DateTo
    if (ISFLAGSET(m_pCriteria->mask, FIM_DATETO))
    {
        // Locals
        FILETIME ftLocal;

        // Convert to local file time
        FileTimeToLocalFileTime(&pInfo->ftReceived, &ftLocal);

        // Compare Received
        if (CompareFileTime(&ftLocal, &m_pCriteria->ftDateTo) > 0)
            return(S_FALSE);
    }

    // Body Text
    if (ISFLAGSET(m_pCriteria->mask, FIM_BODYTEXT))
    {
        // Locals
        BOOL fMatch=FALSE;
        IStream *pStream;

        // No Body TExt
        if (NULL == m_pCriteria->pszBody)
            return(S_FALSE);

        // Open the mime message
        if (SUCCEEDED(LighweightOpenMessage(m_prgFolder[iFolder].pDB, pInfo, &m_pMessage)))
        {
            // Try to Get the Plain Text Stream
            if (FAILED(m_pMessage->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
            {
                // Try to get the HTML stream
                if (FAILED(m_pMessage->GetTextBody(TXT_HTML, IET_DECODED, &pStream, NULL)))
                    pStream = NULL;
            }

            // Do we have a strema
            if (pStream)
            {
                // Search the Stream
                fMatch = StreamSubStringMatch(pStream, m_pCriteria->pszBody);

                // Release the Stream
                pStream->Release();
            }
        }

        // No Match
        if (FALSE == fMatch)
            return(S_FALSE);
    }

    // Its a match
    return(S_OK);
}

//--------------------------------------------------------------------------
// CFindFolder::SaveMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::SaveMessage(LPMESSAGEID pidMessage, 
    SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, 
    IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    MESSAGEID       idSaved;
    MESSAGEINFO     Saved={0};
    MESSAGEINFO     Message={0};
    LPFOLDERENTRY   pEntry=NULL;
    BOOL            fRegNotify=FALSE;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::SaveMessage");

    // Invalid Args
    if (NULL == pidMessage || NULL == pMessage || !ISFLAGSET(dwOptions, SAVE_MESSAGE_GENID))
    {
        Assert(FALSE);
        return TraceResult(E_INVALIDARG);
    }

    // Set the messageId
    Message.idMessage = *pidMessage;

    // Find It
    IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        AssertSz(FALSE, "This can't happen because you can't save new messages into a search folder.");
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Get the Folder Entry
    pEntry = &m_prgFolder[Message.iFindFolder];

    // Open the folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(pEntry->idFolder, NULL, NOFLAGS, &pFolder));

    // Lock
    IF_FAILEXIT(hr = pEntry->pDB->Lock(&hLock));

    // Remove my notification
    pEntry->pDB->UnregisterNotify((IDatabaseNotify *)this);

    // Re-Register for notifications
    fRegNotify = TRUE;

    // Set idFindSource
    idSaved = Message.idFindSource;

    // Open the Message
    IF_FAILEXIT(hr = pFolder->SaveMessage(&idSaved, dwOptions, dwFlags, pStream, pMessage, pCallback));

    // Get the new message info
    IF_FAILEXIT(hr = GetMessageInfo(pFolder, idSaved, &Saved));

    // Insert This Dude
    IF_FAILEXIT(hr = _OnInsert(Message.iFindFolder, &Saved, NULL, pidMessage));

exit:
    // Cleanup
    if (pEntry)
    {
        // fRegNotify
        if (fRegNotify)
        {
            // Re-register for notifications
            pEntry->pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, Message.iFindFolder, (IDatabaseNotify *)this);
        }

        // Unlock the Folder
        pEntry->pDB->Unlock(&hLock);
    }

    // Free Message
    m_pSearch->FreeRecord(&Message);

    // Free
    if (pFolder)
        pFolder->FreeRecord(&Saved);

    // Release the Folder
    SafeRelease(pFolder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::OpenMessage(MESSAGEID idMessage, 
    OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Message={0};
    LPFOLDERENTRY   pEntry;

    // Trace
    TraceCall("CFindFolder::OpenMessage");

    // Set the messageId
    Message.idMessage = idMessage;

    // Find It
    IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Get entry
    pEntry = &m_prgFolder[Message.iFindFolder];

    // Do we have a folder open yet ?
    if (NULL == pEntry->pFolder)
    {
        // Get the Real Folder
        IF_FAILEXIT(hr = g_pStore->OpenFolder(pEntry->idFolder, NULL, NOFLAGS, &pEntry->pFolder));
    }

    // Open the Message
    IF_FAILEXIT(hr = pEntry->pFolder->OpenMessage(Message.idFindSource, dwFlags, ppMessage, pCallback));

exit:
    // Cleanup
    m_pSearch->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::SetMessageFlags
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::SetMessageFlags(LPMESSAGEIDLIST pList, 
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwndParent;
    DWORD           i;
    LPMESSAGEIDLIST prgList=NULL;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::SetMessageFlags");

    // Invalid Args
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(pCallback);

    // Invalid Args
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Get the Parent Window
    IF_FAILEXIT(hr = pCallback->GetParentWindow(0, &hwndParent));

    // Collate into folders
    IF_FAILEXIT(hr = _CollateIdList(pList, &prgList, NULL));

    // Walk through the folders...
    for (i=0; i<m_cFolders; i++)
    {
        // Call Into the Folder unless cMsgs == 0
        if (prgList[i].cMsgs > 0)
        {
            // Get the Real Folder
            IF_FAILEXIT(hr = g_pStore->OpenFolder(m_prgFolder[i].idFolder, NULL, NOFLAGS, &pFolder));

            // Blocking...
            IF_FAILEXIT(hr = SetMessageFlagsProgress(hwndParent, pFolder, pFlags, &prgList[i]));

            // Cleanup
            SafeRelease(pFolder);
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolder);
    _FreeIdListArray(&prgList);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::CopyMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::CopyMessages(IMessageFolder *pDest, 
    COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, 
    LPRESULTLIST pResults, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwndParent;
    DWORD           i;
    LPMESSAGEIDLIST prgList=NULL;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::CopyMessages");

    // Better have a callback
    Assert(pCallback);

    // Invalid Args
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Get the Parent Window
    IF_FAILEXIT(hr = pCallback->GetParentWindow(0, &hwndParent));

    // Collate into folders
    IF_FAILEXIT(hr = _CollateIdList(pList, &prgList, NULL));

    // Walk through the folders...
    for (i=0; i<m_cFolders; i++)
    {
        // Anything to do?
        if (prgList[i].cMsgs > 0)
        {
            // Get the Real Folder
            IF_FAILEXIT(hr = g_pStore->OpenFolder(m_prgFolder[i].idFolder, NULL, NOFLAGS, &pFolder));

            // Call Justins
            IF_FAILEXIT(hr = CopyMessagesProgress(hwndParent, pFolder, pDest, dwFlags, &prgList[i], pFlags));

            // Cleanup
            SafeRelease(pFolder);
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolder);
    _FreeIdListArray(&prgList);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::DeleteMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::DeleteMessages(DELETEMESSAGEFLAGS dwFlags,
    LPMESSAGEIDLIST pList, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    BOOL            fSomeInDeleted;
    HWND            hwndParent;
    LPMESSAGEIDLIST prgList=NULL;
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CFindFolder::DeleteMessages");

    // Invalid Args
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(pCallback);

    // Invalid Args
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Collate into folders
    IF_FAILEXIT(hr = _CollateIdList(pList, &prgList, &fSomeInDeleted));

    // Prompt...
    if (fSomeInDeleted && FALSE == ISFLAGSET(dwFlags, DELETE_MESSAGE_NOPROMPT))
    {
        // Get a Parent Hwnd
        Assert(pCallback);

        // Get Parent Window
        if (FAILED(pCallback->GetParentWindow(0, &hwndParent)))
            hwndParent = NULL;

        // Prompt...
        if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnSomePermDelete), NULL, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ))
            goto exit;
    }

    // Get the Parent Window
    IF_FAILEXIT(hr = pCallback->GetParentWindow(0, &hwndParent));

    // Walk through the folders...
    for (i=0; i<m_cFolders; i++)
    {
        // Call Into the Folder unless cMsgs == 0
        if (prgList[i].cMsgs > 0)
        {
            // Get the Real Folder
            IF_FAILEXIT(hr = g_pStore->OpenFolder(m_prgFolder[i].idFolder, NULL, NOFLAGS, &pFolder));

            // Call Into the Folder
            IF_FAILEXIT(hr = DeleteMessagesProgress(hwndParent, pFolder, dwFlags | DELETE_MESSAGE_NOPROMPT, &prgList[i]));

            // Cleanup
            SafeRelease(pFolder);
        }
    }

exit:
    // Cleanup
    SafeRelease(pFolder);
    _FreeIdListArray(&prgList);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_CollateIdList
//--------------------------------------------------------------------------
HRESULT CFindFolder::_CollateIdList(LPMESSAGEIDLIST pList, 
    LPMESSAGEIDLIST *pprgCollated, BOOL *pfSomeInDeleted)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    LPMESSAGEIDLIST pListDst;
    DWORD           i;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CFindFolder::_CollateIdList");

    // Initialize
    if (pfSomeInDeleted)
        *pfSomeInDeleted = FALSE;

    // Allocate pprgCollated
    IF_NULLEXIT(*pprgCollated = (LPMESSAGEIDLIST)ZeroAllocate(sizeof(MESSAGEIDLIST) * m_cFolders));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pSearch->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            Message.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pSearch->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pSearch->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Validate
            Assert(Message.iFindFolder < m_cFolders);

            // Return pfSomeInDeleted
            if (pfSomeInDeleted && m_prgFolder[Message.iFindFolder].fInDeleted)
                *pfSomeInDeleted = TRUE;

            // Locate the Correct 
            pListDst = &((*pprgCollated)[Message.iFindFolder]);

            // Need to Grow this puppy
            if (pListDst->cMsgs + 1 >= pListDst->cAllocated)
            {
                // Realloc the Array
                IF_FAILEXIT(hr = HrRealloc((LPVOID *)&pListDst->prgidMsg, sizeof(MESSAGEID) * (pListDst->cAllocated + 256)));

                // Increment 
                pListDst->cAllocated += 256;
            }

            // Store the Id
            pListDst->prgidMsg[pListDst->cMsgs++] = Message.idFindSource;

            // Free
            m_pSearch->FreeRecord(&Message);
        }
    }

exit:
    // Cleanup
    m_pSearch->FreeRecord(&Message);
    m_pSearch->CloseRowset(&hRowset);

    // Failure
    if (FAILED(hr))
        _FreeIdListArray(pprgCollated);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CFindFolder::_FreeIdListArray
//--------------------------------------------------------------------------
HRESULT CFindFolder::_FreeIdListArray(LPMESSAGEIDLIST *pprgList)
{
    // Locals
    DWORD       i;

    // Trace
    TraceCall("CFindFolder::_FreeIdListArray");

    // Nothing to Free
    if (NULL == *pprgList)
        return(S_OK);

    // Loop
    for (i=0; i<m_cFolders; i++)
    {
        // Free prgidMsg
        SafeMemFree((*pprgList)[i].prgidMsg);
    }

    // Free the Array
    SafeMemFree((*pprgList));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CFindFolder::OnTransaction
//--------------------------------------------------------------------------
STDMETHODIMP CFindFolder::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, 
    IDatabase *pDB)
{
    // Locals
    HRESULT         hr;
    HLOCK           hNotify=NULL;
    MESSAGEINFO     Message1={0};
    MESSAGEINFO     Message2={0};
    ORDINALLIST     Ordinals;
    INDEXORDINAL    iIndex;
    TRANSACTIONTYPE tyTransaction;

    // Trace
    TraceCall("CFindFolder::OnRecordNotify");

    // Lock Notifications
    m_pSearch->LockNotify(NOFLAGS, &hNotify);

    // While we have a Transaction...
    while (hTransaction)
    {
        // Get Transaction
        IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Message1, &Message2, &iIndex, &Ordinals));

        // Insert
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Ccall OnInsert
            _OnInsert((DWORD) dwCookie, &Message1, NULL);
        }

        // Delete
        else if (TRANSACTION_DELETE == tyTransaction)
        {
            // Ccall OnDelete
            _OnDelete((DWORD) dwCookie, &Message1);
        }

        // Update
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Ccall OnInsert
            _OnUpdate((DWORD) dwCookie, &Message1, &Message2);
        }
    }

exit:
    // Cleanup
    pDB->FreeRecord(&Message1);
    pDB->FreeRecord(&Message2);

    // Lock Notifications
    m_pSearch->UnlockNotify(&hNotify);

    // Done
    return(S_OK);
}

HRESULT CFindFolder::ConnectionAddRef()
{
    if (m_pSearch)
        m_pSearch->ConnectionAddRef();
    return S_OK;
}

HRESULT CFindFolder::ConnectionRelease()
{
    if (m_pSearch)
        m_pSearch->ConnectionAddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\istore.h ===
//--------------------------------------------------------------------------
// ISTORE.H
//--------------------------------------------------------------------------
#ifndef __ISTORE_H
#define __ISTORE_H

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
interface INotify;

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define NOTIFY_FOLDER       0xf0001000
#define NOTIFY_STORE        0xf0002000

//--------------------------------------------------------------------------
// ENUMFOLDERINFO
//--------------------------------------------------------------------------
typedef struct tagENUMFOLDERINFO {
    HLOCK           hLock;
    FOLDERID        idNext;
} ENUMFOLDERINFO, *LPENUMFOLDERINFO;

//--------------------------------------------------------------------------
// CStoreNamespace
//--------------------------------------------------------------------------
class CStoreNamespace : public IStoreNamespace, public IDatabaseNotify, public IStoreCallback
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CStoreNamespace(void);
    ~CStoreNamespace(void);

    //----------------------------------------------------------------------
    // IUnknown Methods
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreCallback Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    //----------------------------------------------------------------------
    // IDatabaseNotify Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pLog);

    //----------------------------------------------------------------------
    // IStoreNamespace Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(HWND hwndOwner, DWORD dwReserved);
    STDMETHODIMP GetDirectory(LPSTR pszPath, DWORD cchMaxPath);
    STDMETHODIMP OpenSpecialFolder(LONG sfType, DWORD dwReserved, IStoreFolder **ppFolder);
    STDMETHODIMP OpenFolder(FOLDERID dwFolderId, DWORD dwReserved, IStoreFolder **ppFolder);
    STDMETHODIMP CreateFolder(FOLDERID dwParentId, LPCSTR pszName,DWORD dwReserved, LPFOLDERID pdwFolderId);
    STDMETHODIMP RenameFolder(FOLDERID dwFolderId, DWORD dwReserved, LPCSTR pszNewName);
    STDMETHODIMP MoveFolder(FOLDERID dwFolderId, FOLDERID dwParentId, DWORD dwReserved);
    STDMETHODIMP DeleteFolder(FOLDERID dwFolderId, DWORD dwReserved);
    STDMETHODIMP GetFolderProps(FOLDERID dwFolderId, DWORD dwReserved, LPFOLDERPROPS pProps);
    STDMETHODIMP CopyMoveMessages(IStoreFolder *pSource, IStoreFolder *pDest, LPMESSAGEIDLIST pMsgIdList, DWORD dwFlags, DWORD dwFlagsRemove,IProgressNotify *pProgress);
    STDMETHODIMP RegisterNotification(DWORD dwReserved, HWND hwnd);
    STDMETHODIMP UnregisterNotification(DWORD dwReserved, HWND hwnd);
    STDMETHODIMP CompactAll(DWORD dwReserved);
    STDMETHODIMP GetFirstSubFolder(FOLDERID dwFolderId, LPFOLDERPROPS pProps, LPHENUMSTORE phEnum);
    STDMETHODIMP GetNextSubFolder(HENUMSTORE hEnum, LPFOLDERPROPS pProps);
    STDMETHODIMP GetSubFolderClose(HENUMSTORE hEnum);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    HINITREF            m_hInitRef;     // Application reference count
    BOOL                m_fRegistered;  // Is this object register for notifications yets
    DWORD               m_cNotify;      // Number of notification recipients
    HWND               *m_prghwndNotify;// Array of hwnd's to notify
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

//--------------------------------------------------------------------------
// CStoreFolder
//--------------------------------------------------------------------------
class CStoreFolder : public IStoreFolder, public IDatabaseNotify, public IStoreCallback
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CStoreFolder(IMessageFolder *pFolder, CStoreNamespace *pNamespace);
    ~CStoreFolder(void);

    //----------------------------------------------------------------------
    // IUnknown Methods
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreCallback Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    //----------------------------------------------------------------------
    // IDatabaseNotify Methods
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pLog);

    //----------------------------------------------------------------------
    // IStoreFolder Methods
    //----------------------------------------------------------------------
    STDMETHODIMP GetFolderProps(DWORD dwReserved, LPFOLDERPROPS pProps);
    STDMETHODIMP GetMessageProps(MESSAGEID dwMessageId, DWORD dwFlags, LPMESSAGEPROPS pProps);
    STDMETHODIMP FreeMessageProps(LPMESSAGEPROPS pProps);
    STDMETHODIMP DeleteMessages(LPMESSAGEIDLIST pMsgIdList, DWORD dwReserved, IProgressNotify *pProgress);
    STDMETHODIMP SetLanguage(DWORD dwLanguage, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList);
    STDMETHODIMP MarkMessagesAsRead(BOOL fRead, DWORD dwReserved, LPMESSAGEIDLIST pMsgIdList);
    STDMETHODIMP SetFlags(LPMESSAGEIDLIST pMsgIdList, DWORD dwState, DWORD dwStatemask, LPDWORD prgdwNewFlags);
    STDMETHODIMP OpenMessage(MESSAGEID dwMessageId, REFIID riid, LPVOID *ppvObject);            
    STDMETHODIMP SaveMessage(REFIID riid, LPVOID pvObject, DWORD dwMsgFlags, LPMESSAGEID pdwMessageId);          
    STDMETHODIMP BatchLock(DWORD dwReserved, LPHBATCHLOCK phBatchLock);           
    STDMETHODIMP BatchFlush(DWORD dwReserved, HBATCHLOCK hBatchLock);            
    STDMETHODIMP BatchUnlock(DWORD dwReserved, HBATCHLOCK hBatchLock);
    STDMETHODIMP CreateStream(HBATCHLOCK hBatchLock, DWORD dwReserved, IStream **ppStream, LPMESSAGEID pdwMessageId);
    STDMETHODIMP CommitStream(HBATCHLOCK hBatchLock, DWORD dwFlags, DWORD dwMsgFlags, IStream *pStream, MESSAGEID dwMessageId, IMimeMessage *pMessage);
    STDMETHODIMP RegisterNotification(DWORD dwReserved, HWND hwnd);                  
    STDMETHODIMP UnregisterNotification(DWORD dwReserved, HWND hwnd);                  
    STDMETHODIMP Compact(DWORD dwReserved);            
    STDMETHODIMP GetFirstMessage(DWORD dwFlags, DWORD dwMsgFlags, MESSAGEID dwMsgIdFirst, LPMESSAGEPROPS pProps, LPHENUMSTORE phEnum);
    STDMETHODIMP GetNextMessage(HENUMSTORE hEnum, DWORD dwFlags, LPMESSAGEPROPS pProps);
    STDMETHODIMP GetMessageClose(HENUMSTORE hEnum);

    //----------------------------------------------------------------------
    // CStoreFolder Methods
    //----------------------------------------------------------------------
    HRESULT GetMessageFolder(IMessageFolder **ppFolder);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;                 // Reference Count
    HWND                m_hwndNotify;           // Current Registered Notify Window
    FOLDERID            m_idFolder;             // ID of this folder
    IMessageFolder     *m_pFolder;              // The real folder
    CStoreNamespace    *m_pNamespace;           // Store Namespace
    CRITICAL_SECTION    m_cs;                   // Thread Safety
};

//--------------------------------------------------------------------------
// C Prototypes
//--------------------------------------------------------------------------
HRESULT CreateInstance_StoreNamespace(IUnknown *pUnkOuter, IUnknown **ppUnknown);

#endif // __ISTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\findfold.h ===
//--------------------------------------------------------------------------
// FindFold.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "dbimpl.h"

//--------------------------------------------------------------------------
// ACTIVEFINDFOLDER
//--------------------------------------------------------------------------
class CFindFolder;
typedef struct tagACTIVEFINDFOLDER *LPACTIVEFINDFOLDER;
typedef struct tagACTIVEFINDFOLDER {
    FOLDERID            idFolder;
    CFindFolder        *pFolder;
    LPACTIVEFINDFOLDER  pNext;
} ACTIVEFINDFOLDER;

//--------------------------------------------------------------------------
// FOLDERENTRY
//--------------------------------------------------------------------------
typedef struct tagFOLDERENTRY {
    LPSTR               pszName;
    DWORD               cRecords;
    BOOL                fInDeleted;
    FOLDERID            idFolder;
    FOLDERTYPE          tyFolder;
    IDatabase          *pDB;
    IMessageFolder     *pFolder; // Used only for Opening messages...
} FOLDERENTRY, *LPFOLDERENTRY;

//--------------------------------------------------------------------------
// CFindFolder
//--------------------------------------------------------------------------
class CFindFolder : public IMessageFolder, 
                    public IDatabaseNotify, 
                    public IStoreCallback,
                    public IServiceProvider,
                    public IOperationCancel
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CFindFolder(void);
    ~CFindFolder(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageFolder Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERID idFolder);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback) { return E_NOTIMPL; }
    STDMETHODIMP Close() { return S_OK; }
    STDMETHODIMP GetFolderId(LPFOLDERID pidFolder) { *pidFolder = m_idFolder; return S_OK; }
    STDMETHODIMP GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder);
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP OpenMessage(MESSAGEID idMessage, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP SaveMessage(LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageStream(MESSAGEID idMessage, IStream *pStream) { return E_NOTIMPL; }
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP ConnectionAddRef();
    STDMETHODIMP ConnectionRelease();
    STDMETHODIMP GetDatabase(IDatabase **ppDB) { return m_pSearch->GetDatabase(ppDB); }
    STDMETHODIMP ResetFolderCounts(DWORD cMessages, DWORD cUnread, DWORD cWatchedUnread, DWORD cWatched) { return(S_OK); }
    STDMETHODIMP IsWatched(LPCSTR pszReferences, LPCSTR pszSubject) { return m_pSearch->IsWatched(pszReferences, pszSubject); }
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback) { return E_NOTIMPL; }

    //----------------------------------------------------------------------
    // IServiceProvider 
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IStoreCallback Members
    //----------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) { return(E_NOTIMPL); }

    //----------------------------------------------------------------------
    // IOperationCancel
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel) { m_fCancel = TRUE; return(S_OK); }

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(FALSE, m_pSearch)

    //----------------------------------------------------------------------
    // IDatabaseNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    //----------------------------------------------------------------------
    // CFindFolder
    //----------------------------------------------------------------------
    HRESULT StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback);
    HRESULT GetMessageFolderType(MESSAGEID idMessage, FOLDERTYPE *ptyFolder);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _StartFind(void);
    HRESULT _SearchFolder(DWORD iFolder);
    HRESULT _IsMatch(DWORD iFolder, LPMESSAGEINFO pMessage);
    HRESULT _OnInsert(DWORD iFolder, LPMESSAGEINFO pMessage, BOOL *pfMatch, LPMESSAGEID pidNew=NULL);
    HRESULT _OnDelete(DWORD iFolder, LPMESSAGEINFO pInfo);
    HRESULT _OnUpdate(DWORD iFolder, LPMESSAGEINFO pInfo1, LPMESSAGEINFO pInfo2);
    HRESULT _FreeIdListArray(LPMESSAGEIDLIST *pprgList);
    HRESULT _CollateIdList(LPMESSAGEIDLIST pList, LPMESSAGEIDLIST *pprgCollated, BOOL *pfSomeInDeleted);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG              m_cRef;         // Reference Counting
    FOLDERID          m_idRoot;       // Root Folder Id to Search
    FOLDERID          m_idFolder;     // Temporary Search Folder Id
    DWORD             m_cFolders;     // Number of Folders we are looking at...
    DWORD             m_cAllocated;   // Number of allocated elements in m_prgFolder
    DWORD             m_cMax;         // Max Number of Records to Query
    DWORD             m_cCur;         // Current number of records queried
    BYTE              m_fCancel;      // Was IOperationCancel Called ?
    LPFOLDERENTRY     m_prgFolder;    // Array of folders to search
    LPFINDINFO        m_pCriteria;    // Criteria To perform Find With    
    IMessageFolder   *m_pSearch;      // Search Folder
    IMessageStore    *m_pStore;       // My Store Object
    IStoreCallback   *m_pCallback;    // The Callback (Usually to the Finder Dialog)
    IMimeMessage     *m_pMessage;     // Reusable mime message for searching
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\fldrsync.cpp ===
#include "pch.hxx"
#include "store.h"
#include "instance.h"
#include "msgfldr.h"
#include "secutil.h"
#include "storutil.h"
#include "fldrsync.h"
#include <conman.h>
#include "shlwapip.h" 
#include "sync.h"

static char c_szFolderSyncWndClass[] = "Outlook Express FolderSync Window Class";

static const PFNCOPYFUNC c_rgpfnCopyMsgs[] = 
{
    &CFolderSync::CopyOpen,
    &CFolderSync::CopySave,
    &CFolderSync::CopySave2,
    &CFolderSync::CopyDelete,
    &CFolderSync::CopyDelete2,
};

//--------------------------------------------------------------------------
// CFolderSync::CFolderSync
//--------------------------------------------------------------------------
CFolderSync::CFolderSync(void)
{
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_pLocalStore = NULL;
    m_pFldr = NULL;
    m_tyFolder = FOLDER_INVALID;
    m_idFolder = FOLDERID_INVALID;
    m_idServer = FOLDERID_INVALID;
    m_szAcctId[0] = 0;
    m_pServer = NULL;
    m_fConManAdvise = FALSE;
    m_hwnd = NULL;
    m_pCopy = NULL;
    m_fImap = FALSE;
}

//--------------------------------------------------------------------------
// CFolderSync::~CFolderSync
//--------------------------------------------------------------------------
CFolderSync::~CFolderSync(void)
{
    Assert(m_pCopy == NULL);

    if (m_fConManAdvise && g_pConMan != NULL)
        g_pConMan->Unadvise((IConnectionNotify *)this);

    if (m_hwnd != NULL)
    {
        if (GetWindowThreadProcessId(m_hwnd, NULL) == GetCurrentThreadId())
        {
            DestroyWindow(m_hwnd);
        }
        else
        {
            SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
            PostMessage(m_hwnd, WM_CLOSE, 0, 0L);
        }
    }

    if (m_pServer)
    {
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
        m_pServer = NULL;
    }

    SafeRelease(m_pLocalStore);
    SafeRelease(m_pFldr);
    
    // Release the Dll
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CFolderSync::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IMessageFolder == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// CFolderSync::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFolderSync::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CFolderSync::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFolderSync::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CFolderSync::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::Initialize(IMessageStore *pStore, IMessageServer *pServer, 
    OPENFOLDERFLAGS dwFlags, FOLDERID idFolder)
{
    Assert(FALSE);
    return(E_NOTIMPL);
}

//--------------------------------------------------------------------------
// CFolderSync::SetOwner
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SetOwner(IStoreCallback *pDefaultCallback)
{
    HRESULT hrResult;

    TraceCall("CFolderSync::SetOwner");

    if (NULL == m_pServer)
    {
        hrResult = E_FAIL;
        goto exit;
    }

    hrResult = m_pServer->SetIdleCallback(pDefaultCallback);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
}

//--------------------------------------------------------------------------
// CFolderSync::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback)
{
    BOOL        fOffline;
    HRESULT     hr;

    // async
    // if online, then synchronize folder
    // if offline, no op (fail)

    if (m_pServer == NULL)
    {
        // local folders don't sync.
        // NOTE - This isn't failure - there's just nothing to do.
        return (S_FALSE);
    }

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);
	if(g_pConMan->IsAccountDisabled((LPSTR)m_szAcctId))
		hr = S_FALSE;
	else
		hr = m_pServer->SynchronizeFolder(dwFlags, cHeaders, pCallback);
    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::GetFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::GetFolderId(LPFOLDERID pidFolder)
{
    Assert(NULL != pidFolder);

    // local store operation only

    *pidFolder = m_idFolder;

    return(S_OK);
}

//--------------------------------------------------------------------------
// CFolderSync::GetMessageFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder)
{
    return(m_pFldr->GetMessageFolderId(idMessage, pidFolder));
}

//--------------------------------------------------------------------------
// CFolderSync::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::OpenMessage(MESSAGEID idMessage, 
    OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, 
    IStoreCallback *pCallback)
{
    HRESULT         hr;
    BOOL            fOffline;
    FILEADDRESS     faStart;

    Assert(NULL != ppMessage);

    // async
    // if message is already downloaded
    //      open message in local store
    // else
    //      if online, download message
    //      if offline, fail

    hr = m_pFldr->OpenMessage(idMessage, dwFlags, ppMessage, NULL);
    if (SUCCEEDED(hr))
        return(hr);

    if (hr == STORE_E_NOBODY && m_pServer != NULL && !ISFLAGSET(dwFlags, OPEN_MESSAGE_CACHEDONLY))
    {
        Assert(pCallback != NULL);
        if (pCallback == NULL)
            return(E_INVALIDARG);

        hr = m_pServer->GetMessage(idMessage, pCallback);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::SaveMessage
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SaveMessage(LPMESSAGEID pidMessage, 
    SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, 
    IStream *pStreamIn, IMimeMessage *pMessage, IStoreCallback *pCallback)
{
    HRESULT         hr;
    IStream        *pStream;
    DWORD           dwOffline;
    LPFILETIME      pftRecv;
    PROPVARIANT     rVariant;
    
	Assert(NULL != pMessage);

    // save message to local store
    // if online, upload message
    // if offline, log transaction

    if (m_pServer == NULL)
    {
        hr = m_pFldr->SaveMessage(pidMessage, dwOptions, dwFlags, pStreamIn, pMessage, NULL);
        return(hr);
    }

    hr = _Offline(&dwOffline);
    if (SUCCEEDED(hr))
    {
        if (dwOffline == CONN_STATE_NOT_CONNECTED)
        {
            hr = E_NOT_ONLINE;
        }
        else if (dwOffline == CONN_STATE_OFFLINE)
        {
            hr = g_pSync->CreateMessage(m_pFldr, pidMessage, dwOptions, dwFlags, pStreamIn, pMessage);
        }
        else
        {
            Assert(dwOffline == CONN_STATE_CONNECTED);
            
            Assert(pCallback != NULL);
            if (pCallback == NULL)
                return(E_INVALIDARG);
            
            // the idStream can legally by null in the case of saving a draft
            if (NULL == pStreamIn)
                hr = pMessage->GetMessageSource(&pStream, COMMIT_ONLYIFDIRTY);
            else
            {
                pStream = pStreamIn;
                pStream->AddRef();
            }

            if (SUCCEEDED(hr))
            {
                rVariant.vt = VT_FILETIME;
                if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
                    pftRecv = &rVariant.filetime;
                else
                    pftRecv = NULL;
                
                hr = m_pServer->PutMessage(m_idFolder, dwFlags, pftRecv, pStream, pCallback);
                pStream->Release();
            }
        }
    }
    
    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::SetMessageStream
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SetMessageStream(MESSAGEID idMessage, 
    IStream *pStream)
{
    // pass through to the local store
    Assert (NULL != m_pFldr);
    Assert(NULL != pStream);

    if (NULL == pStream)
        return E_INVALIDARG;

    return m_pFldr->SetMessageStream(idMessage, pStream);
}

//--------------------------------------------------------------------------
// CFolderSync::SetMessageFlags
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::SetMessageFlags(LPMESSAGEIDLIST pList,
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    INewsStore     *pNewsStore;
    ADJUSTFLAGS     localFlags, svrFlags;
    MESSAGEFLAGS    flags;
    DWORD           dwOffline;
    HRESULT         hr;

    Assert(NULL != pFlags);
    Assert(NULL == pList || 0 != pList->cMsgs);

    // async
    // save message flags to local store
    // if online, upload message flags if necessary (some flags are irrelevant to server)
    // if offline, log transaction if necessary

    if (m_pServer == NULL)
        return(m_pFldr->SetMessageFlags(pList, pFlags, pResults, NULL));

    hr = _Offline(&dwOffline);
    if (SUCCEEDED(hr))
    {
        hr = m_pServer->GetServerMessageFlags(&flags);
        if (SUCCEEDED(hr))
        {
            Assert(hr == S_OK || hr == S_FALSE);

            // hr == S_FALSE
            // this server doesn't have any flags that need to hit the server
            
            localFlags = *pFlags;

            if (hr == S_OK)
            {
                svrFlags = *pFlags;
                svrFlags.dwAdd &= flags;
                svrFlags.dwRemove &= flags;

                localFlags.dwAdd &= ~flags;
                localFlags.dwRemove &= ~flags;

                if (0 != svrFlags.dwAdd ||
                    0 != svrFlags.dwRemove)
                {
                    if (dwOffline == CONN_STATE_NOT_CONNECTED)
                    {
                        return(E_NOT_ONLINE);
                    }
                    else if (dwOffline == CONN_STATE_OFFLINE)
                    {
                        hr = g_pSync->SetMessageFlags(m_pFldr, pList, &svrFlags);
                    }
                    else
                    {
                        Assert(dwOffline == CONN_STATE_CONNECTED);

                        Assert(pCallback != NULL);
                        if (pCallback == NULL)
                            return(E_INVALIDARG);

                        hr = m_pServer->SetMessageFlags(pList, &svrFlags, 0, pCallback);
                    }
                }
            }

            if (0 != localFlags.dwAdd ||
                0 != localFlags.dwRemove)
            {
                hr = m_pFldr->SetMessageFlags(pList, &localFlags, pResults, NULL);

                // mark news crossposts as read
                if (m_tyFolder == FOLDER_NEWS &&
                    (!!(localFlags.dwAdd & ARF_READ) || !!(localFlags.dwRemove & ARF_READ)))
                {
                    IServiceProvider *pService;

                    if (SUCCEEDED(m_pServer->QueryInterface(IID_IServiceProvider, (void **)&pService)))
                    {
                        if (SUCCEEDED(pService->QueryService(SID_MessageServer, IID_INewsStore, (void **)&pNewsStore)))
                        {
                            pNewsStore->MarkCrossposts(pList, !!(localFlags.dwAdd & ARF_READ));

                            pNewsStore->Release();
                        }

                        pService->Release();
                    }
                }
            }
        }
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::DeleteMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, 
    LPMESSAGEIDLIST pList, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    ADJUSTFLAGS     afFlags;
    DWORD           dwOffline;
    HRESULT         hr;

    Assert(NULL == pList || pList->cMsgs > 0);

    // if online, delete messages from server and local store
    // if offline, log transaction

    if (m_pServer == NULL || m_tyFolder == FOLDER_NEWS)
        return(m_pFldr->DeleteMessages(dwOptions, pList, pResults, pCallback));

    hr = _Offline(&dwOffline);
    if (SUCCEEDED(hr))
    {
        if (dwOffline == CONN_STATE_NOT_CONNECTED)
        {
            hr = E_NOT_ONLINE;
        }
        else if (dwOffline == CONN_STATE_OFFLINE)
        {
            // [PaulHi] 4/8/99  Raid 63339
            // Deleting from an HTTP folder (other than the 'deleted' folder)
            // translates into a message move from the source folder to the 
            // 'deleted' folder.  If offline we want the message copy to take
            // place and then cache the message 'copy' just as would happen with
            // an offline drag/drop copy operation.
            FOLDERINFO  fldrinfo;
            BOOL        bHMOffLineCopy = FALSE;

            hr = m_pLocalStore->GetFolderInfo(m_idFolder, &fldrinfo);
            if (SUCCEEDED(hr))
            {
                if ( (fldrinfo.tyFolder == FOLDER_HTTPMAIL) && (fldrinfo.tySpecial != FOLDER_DELETED) &&
                     (fldrinfo.tySpecial != FOLDER_MSNPROMO) )
                {
                    // Code stolen from CFolderSync::CopyMessages
                    IMessageFolder * pDeletedItems = NULL;
                    IMessageFolder * pDestLocal = NULL;
                    IServiceProvider * pService = NULL;

                    hr = g_pStore->OpenSpecialFolder(m_idServer, NULL, FOLDER_DELETED, &pDeletedItems);

                    if (SUCCEEDED(hr))
                    {
                        hr = pDeletedItems->QueryInterface(IID_IServiceProvider, (void **)&pService);
                        if (SUCCEEDED(hr))
                        {
                            hr = pService->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (void **)&pDestLocal);
                            pService->Release();
                        }

                        pDeletedItems->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
                        Assert(pDestLocal != NULL);

                        afFlags.dwAdd = 0;
                        afFlags.dwRemove = 0;
                        hr = g_pSync->CopyMessages(m_pFldr, pDestLocal, COPY_MESSAGE_MOVE, pList, &afFlags);
                        bHMOffLineCopy = TRUE;

                        pDestLocal->Release();
                    }

                    m_pLocalStore->FreeRecord(&fldrinfo);
                }
            }

            // If the HM offline copy didn't occur, for whatever reason, revert to the original
            // off line delete.
            if (!bHMOffLineCopy)
                hr = g_pSync->DeleteMessages(m_pFldr, dwOptions, pList);
        }
        else
        {
            Assert(dwOffline == CONN_STATE_CONNECTED);

            Assert(pCallback != NULL);
            if (pCallback == NULL)
                return(E_INVALIDARG);

            hr = m_pServer->DeleteMessages(dwOptions, pList, pCallback);
        }
    }

    return(hr);
}

HRESULT CFolderSync::Initialize(IMessageStore *pStore, IMessageFolder *pLocalFolder, 
    IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERTYPE tyFolder, 
    FOLDERID idFolder, FOLDERID idServer)
{
    WNDCLASSEX      wc;
    HRESULT         hr;
    FOLDERINFO      info;

    Assert(NULL != pStore);

    // Save the Folder Type
    m_tyFolder = tyFolder;

    // Save the FolderId
    m_idFolder = idFolder;

    m_idServer = idServer;

    // Save pStore
    m_pLocalStore = pStore;
    m_pLocalStore->AddRef();

    if (pServer != NULL)
    {
        hr = m_pLocalStore->GetFolderInfo(m_idServer, &info);
        if (FAILED(hr))
            return(hr);

        lstrcpy(m_szAcctId, info.pszAccountId);
        m_fImap = (info.tyFolder == FOLDER_IMAP);

        m_pLocalStore->FreeRecord(&info);

        m_pServer = pServer;
        m_pServer->AddRef();

        hr = g_pConMan->Advise((IConnectionNotify *)this);
        m_fConManAdvise = SUCCEEDED(hr);
    }

    if (pLocalFolder)
    {
        m_pFldr = pLocalFolder;
        m_pFldr->AddRef();
    }
    else
    {
        hr = m_pLocalStore->OpenFolder(m_idFolder, NULL, dwFlags, &m_pFldr);
        if (FAILED(hr))
            return(hr);
    }
    
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szFolderSyncWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = FolderSyncWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szFolderSyncWndClass;
        wc.hIconSm          = NULL;
        if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }

    m_hwnd = CreateWindowEx(WS_EX_TOPMOST, c_szFolderSyncWndClass, 
                c_szFolderSyncWndClass, WS_POPUP, 1, 1, 1, 1, NULL, 
                NULL, g_hInst, (LPVOID)this);
    if (m_hwnd == NULL)
        return(E_FAIL);

    return(S_OK);
}

HRESULT CFolderSync::Close()
{
    HRESULT hr = S_OK;
    if (m_pServer)
        hr = m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);

    return hr;
}

HRESULT CFolderSync::_Offline(DWORD *pdwOffline)
{
    BOOL fOffline;
    HRESULT hr;

    Assert(pdwOffline != NULL);
    Assert(m_szAcctId[0] != 0);

    fOffline = g_pConMan->IsGlobalOffline();
    if (fOffline)
    {
        *pdwOffline = CONN_STATE_OFFLINE;
    }
    else
    {
		//Bug# 39337. We just give the operation to the sync object even if we are not connected.
		//The sync object in turn figures out whether it needs to dial or not

		/*
        hr = g_pConMan->CanConnect(m_szAcctId);
    
        *pdwOffline = (hr == S_OK) ? CONN_STATE_CONNECTED : CONN_STATE_NOT_CONNECTED;
		*/
		*pdwOffline = CONN_STATE_CONNECTED;
    }

    return(S_OK);
}

HRESULT CFolderSync::_OfflineServer(FOLDERID idServer, DWORD *pdwOffline)
{
    HRESULT hr;
    FOLDERINFO info;
    BOOL fOffline;

    Assert(pdwOffline != NULL);

    hr = m_pLocalStore->GetFolderInfo(idServer, &info);
    if (FAILED(hr))
        return(hr);

    if (info.tyFolder == FOLDER_LOCAL)
    {
        *pdwOffline = CONN_STATE_CONNECTED;
    }
    else
    {
        fOffline = g_pConMan->IsGlobalOffline();
        if (fOffline)
        {
            *pdwOffline = CONN_STATE_OFFLINE;
        }
        else
        {
			/*
            hr = g_pConMan->CanConnect(info.pszAccountId);
    
            *pdwOffline = (hr == S_OK) ? CONN_STATE_CONNECTED : CONN_STATE_NOT_CONNECTED;
			*/
			*pdwOffline = CONN_STATE_CONNECTED;
        }
    }

    m_pLocalStore->FreeRecord(&info);

    return(S_OK);
}

HRESULT CFolderSync::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    IServiceProvider    *pSP;
    HRESULT             hr = E_NOINTERFACE;

    if (guidService == SID_LocalMessageFolder)
    {
        if (m_pFldr != NULL)
            hr = m_pFldr->QueryInterface(riid, ppvObject);
    }
    else if (m_pServer && m_pServer->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
    {
        hr = pSP->QueryService(guidService, riid, ppvObject);
        pSP->Release();
    }

    return hr;
}

HRESULT CFolderSync::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(m_pCopy->type == SOT_INVALID);
    Assert(m_pCopy->fAsync);

    m_pCopy->type = tyOperation;

    if (!m_pCopy->fBegin)
    {
        Assert(m_pCopy->pCallback != NULL);
        m_pCopy->pCallback->OnBegin(SOT_COPYMOVE_MESSAGE, pOpInfo, (IOperationCancel *)this);

        m_pCopy->fBegin = TRUE;
    }

    return(S_OK);
}

HRESULT CFolderSync::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    return(S_OK);
}

HRESULT CFolderSync::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->OnTimeout(pServer, pdwTimeout, ixpServerType));
}

HRESULT CFolderSync::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->CanConnect(pszAccountId, dwFlags));
}

HRESULT CFolderSync::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->OnLogonPrompt(pServer, ixpServerType));
}

HRESULT CFolderSync::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_pCopy != NULL);
    if (m_pCopy->type != tyOperation ||
        m_pCopy->hr != S_FALSE)
        return(S_OK);

    Assert(hrComplete != S_FALSE);

    m_pCopy->hr = hrComplete;

    if (NULL != pErrorInfo)
    {
        BOOL    fResult;

        fResult = MemAlloc((void **)&m_pCopy->pErrorInfo, sizeof(STOREERROR));
        if (FALSE == fResult)
        {
            TraceResult(E_OUTOFMEMORY);
        }
        else
        {
            // Make a copy of the STOREERROR so we can display rich errors to user
            m_pCopy->pErrorInfo->hrResult = pErrorInfo->hrResult;
            m_pCopy->pErrorInfo->uiServerError = pErrorInfo->uiServerError;
            m_pCopy->pErrorInfo->hrServerError = pErrorInfo->hrServerError;
            m_pCopy->pErrorInfo->dwSocketError = pErrorInfo->dwSocketError;
            m_pCopy->pErrorInfo->pszProblem = PszDupA(pErrorInfo->pszProblem);
            m_pCopy->pErrorInfo->pszDetails = PszDupA(pErrorInfo->pszDetails);
            m_pCopy->pErrorInfo->pszAccount = PszDupA(pErrorInfo->pszAccount);
            m_pCopy->pErrorInfo->pszServer = PszDupA(pErrorInfo->pszServer);
            m_pCopy->pErrorInfo->pszFolder = PszDupA(pErrorInfo->pszFolder);
            m_pCopy->pErrorInfo->pszUserName = PszDupA(pErrorInfo->pszUserName);
            m_pCopy->pErrorInfo->pszProtocol = PszDupA(pErrorInfo->pszProtocol);
            m_pCopy->pErrorInfo->ixpType = pErrorInfo->ixpType;
            m_pCopy->pErrorInfo->dwPort = pErrorInfo->dwPort;
            m_pCopy->pErrorInfo->fSSL = pErrorInfo->fSSL;
            m_pCopy->pErrorInfo->dwFlags = pErrorInfo->dwFlags;
        }
    }

    PostMessage(m_hwnd, WM_USER, 0, 0);
    
    m_pCopy->type = SOT_INVALID;

    return S_OK;
}

HRESULT CFolderSync::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->OnPrompt(hrError, pszText, pszCaption, uType, piUserResponse));
}

HRESULT CFolderSync::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_pCopy != NULL);
    return(m_pCopy->pCallback->GetParentWindow(dwReserved, phwndParent));
}

HRESULT CFolderSync::Cancel(CANCELTYPE tyCancel)
{
    Assert(m_pCopy != NULL);
    Assert(tyCancel != CT_INVALID);

    m_pCopy->tyCancel = tyCancel;

    return(S_OK);
}

HRESULT CFolderSync::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    FOLDERINFO info;
    HRESULT hr;

    Assert(m_pServer != NULL);

    if (nCode == CONNNOTIFY_CONNECTED)
    {
        
    }
    else if (nCode == CONNNOTIFY_WORKOFFLINE && pvData)
    {
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);
    }
    else if (nCode == CONNNOTIFY_DISCONNECTED)
    {
        hr = g_pStore->GetFolderInfo(m_idServer, &info);
        if (SUCCEEDED(hr))
        {
            CHAR szAccountId[CCHMAX_ACCOUNT_NAME];

            if (SUCCEEDED(GetFolderAccountId(&info, szAccountId)))
            {
                if (!g_pConMan->CanConnect(szAccountId))
                    m_pServer->Close(MSGSVRF_DROP_CONNECTION);
            }

            g_pStore->FreeRecord(&info);
        }
    }

    return(S_OK);
}

void CFolderSync::_FreeCopyInfo()
{
    Assert(m_pCopy != NULL);

    if (m_pCopy->pDest != NULL)
        m_pCopy->pDest->Release();
    if (m_pCopy->pDestLocal != NULL)
        m_pCopy->pDestLocal->Release();
    if (m_pCopy->pList != NULL)
        MemFree(m_pCopy->pList);

    if (m_pCopy->pErrorInfo != NULL)
    {
        SafeMemFree(m_pCopy->pErrorInfo->pszProblem);
        SafeMemFree(m_pCopy->pErrorInfo->pszDetails);
        SafeMemFree(m_pCopy->pErrorInfo->pszAccount);
        SafeMemFree(m_pCopy->pErrorInfo->pszServer);
        SafeMemFree(m_pCopy->pErrorInfo->pszFolder);
        SafeMemFree(m_pCopy->pErrorInfo->pszUserName);
        SafeMemFree(m_pCopy->pErrorInfo->pszProtocol);
        MemFree(m_pCopy->pErrorInfo);
    }

    MemFree(m_pCopy);
    m_pCopy = NULL;
}

HRESULT AllBodiesDownloaded(IMessageFolder *pFldr, LPMESSAGEIDLIST pList)
{
    MESSAGEINFO Message;
    DWORD iMsg;
    HRESULT hr;

    Assert(pFldr != NULL);
    Assert(pList != NULL);

    hr = S_OK;

    for (iMsg = 0; iMsg < pList->cMsgs; iMsg++)
    {
        ZeroMemory(&Message, sizeof(MESSAGEINFO));
        Message.idMessage = pList->prgidMsg[iMsg];
        if (DB_S_FOUND == pFldr->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
        {
            if (0 == (Message.dwFlags & ARF_HASBODY))
                hr = S_FALSE;

            pFldr->FreeRecord(&Message);
        }

        if (hr != S_OK)
            break;
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CFolderSync::CopyMessages
//--------------------------------------------------------------------------
STDMETHODIMP CFolderSync::CopyMessages(IMessageFolder   *pDest, 
                                       COPYMESSAGEFLAGS dwOptions, 
                                       LPMESSAGEIDLIST  pList, 
                                       LPADJUSTFLAGS    pFlags, 
                                       LPRESULTLIST     pResults,
                                       IStoreCallback  *pCallback)
{
    HWND                hwnd;
    DWORD               dwOfflineSrc, dwOfflineDst;
    HRESULT             hr;
    IMessageFolder     *pDestLocal;
    ADJUSTFLAGS         aflags;
    FOLDERID            idDst, idServerDst;
    IServiceProvider   *pService;
    FOLDERINFO          fiSource = {0};

    Assert(pDest != NULL);
    Assert(pList != NULL);

    hr = pDest->GetFolderId(&idDst);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServerId(idDst, &idServerDst);
    if (FAILED(hr))
        return(hr);

    if (m_pServer == NULL)
    {
        dwOfflineSrc = CONN_STATE_CONNECTED;
    }
    else
    {
        hr = _Offline(&dwOfflineSrc);
        if (FAILED(hr))
            return(hr);
    }

    if (m_tyFolder == FOLDER_IMAP)
    {
        if (pFlags != NULL)
        {
            aflags = *pFlags;
        }
        else
        {
            aflags.dwAdd = 0;
            aflags.dwRemove = 0;
        }
        aflags.dwRemove |= ARF_ENDANGERED;
        pFlags = &aflags;
    }

    if (m_idServer == idServerDst)
    {
        if (m_pServer == NULL)
        {
            hr = m_pFldr->CopyMessages(pDest, dwOptions, pList, pFlags, pResults, pCallback);
        }
        else if (dwOfflineSrc == CONN_STATE_NOT_CONNECTED)
        {
            hr = E_NOT_ONLINE;
        }
        else if (dwOfflineSrc == CONN_STATE_CONNECTED)
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
                return(E_INVALIDARG);

            hr = m_pServer->CopyMessages(pDest, dwOptions, pList, pFlags, pCallback);
        }
        else
        {
            Assert(dwOfflineSrc == CONN_STATE_OFFLINE);

            pDestLocal = NULL;

            hr = pDest->QueryInterface(IID_IServiceProvider, (void **)&pService);
            if (SUCCEEDED(hr))
            {
                hr = pService->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (void **)&pDestLocal);

                pService->Release();
            }

            if (FAILED(hr))
                return(hr);

            Assert(pDestLocal != NULL);
            hr = g_pSync->CopyMessages(m_pFldr, pDestLocal, dwOptions, pList, pFlags);

            pDestLocal->Release();
        }

        return(hr);
    }

    hr = _OfflineServer(idServerDst, &dwOfflineDst);
    if (FAILED(hr))
        return(hr);

    if (dwOfflineDst == CONN_STATE_NOT_CONNECTED)
        return(E_NOT_ONLINE);

    Assert(m_pCopy == NULL);
    if (m_pCopy != NULL)
        return(E_FAIL);

    if (dwOfflineSrc != CONN_STATE_CONNECTED)
    {
        hr = AllBodiesDownloaded(m_pFldr, pList);
        if (FAILED(hr))
        {
            return(hr);
        }
        else if (hr == S_FALSE)
        {
            pCallback->GetParentWindow(0, &hwnd);
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                !!(COPY_MESSAGE_MOVE & dwOptions) ? MAKEINTRESOURCEW(idsCantMoveNotDownloaded) : MAKEINTRESOURCEW(idsCantCopyNotDownloaded),
                0, MB_OK | MB_ICONEXCLAMATION);

            return(E_NOT_ONLINE);
        }
    }

    // Bug# 94639
    // If the src and dest servers are not the same, and if the source is Hotmail Deleted Items folder
    // disallow move.
    // For Hotmail accounts Deleted Items folder is managed by the Hotmail servers.
    // So the users cannot manually delete or move messages.
    // Hence, disallow moving from Deleted Items. 
    // Instead ask if the user wants to copy the message
    if ((m_idServer != idServerDst) && (FOLDER_HTTPMAIL == m_tyFolder))
    {
        IF_FAILEXIT(hr = m_pLocalStore->GetFolderInfo(m_idFolder, &fiSource));
        if (FOLDER_DELETED == fiSource.tySpecial)
        {
            if (IDNO == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                                         MAKEINTRESOURCEW(idsHttpNoMoveCopy), 0, MB_YESNO))
            {
                // Just return S_OK;
                hr = S_OK;
                goto exit;
            }
            else
            {
                // Change the move flags to copy.
                dwOptions = (dwOptions & ~COPY_MESSAGE_MOVE);
            }
        }
    }

    if (!MemAlloc((void **)&m_pCopy, sizeof(COPYINFO)))
        return(E_OUTOFMEMORY);

    ZeroMemory(m_pCopy, sizeof(COPYINFO));
    m_pCopy->fSrcOffline = (dwOfflineSrc != CONN_STATE_CONNECTED);
    m_pCopy->fDestOffline = (dwOfflineDst != CONN_STATE_CONNECTED);
    m_pCopy->hr = S_OK;
    m_pCopy->pDest = pDest;
    pDest->AddRef();
    m_pCopy->fMove = !!(COPY_MESSAGE_MOVE & dwOptions);
    hr = CloneMessageIDList(pList, &m_pCopy->pList);
    if (FAILED(hr))
    {
        _FreeCopyInfo();
        return(hr);
    }

    if (m_pCopy->fDestOffline)
    {
        hr = m_pCopy->pDest->QueryInterface(IID_IServiceProvider, (void **)&pService);
        if (SUCCEEDED(hr))
        {
            hr = pService->QueryService(SID_LocalMessageFolder, IID_IMessageFolder, (void **)&m_pCopy->pDestLocal);

            pService->Release();
        }

        if (FAILED(hr))
        {
            _FreeCopyInfo();
            return(E_INVALIDARG);
        }
    }
    
    if (pFlags != NULL)
        m_pCopy->AdjustFlags = *pFlags;

    m_pCopy->pCallback = pCallback;

    hr = _CopyMessageState();

exit:
    m_pLocalStore->FreeRecord(&fiSource);
    return(hr);
}

HRESULT CFolderSync::CopyOpen()
{
    HRESULT			hr;
	MESSAGEINFO		mi = {0};
	LPMESSAGEINFO	pmi = NULL;

    if (m_pCopy->iMsg >= m_pCopy->pList->cMsgs)
    {
        m_pCopy->state = COPY_STATE_DONE;
        return(S_OK);
    }

    Assert(m_pCopy->pStream == NULL);

    // initialize message info with the message id
    mi.idMessage = m_pCopy->pList->prgidMsg[m_pCopy->iMsg];
    
    // find the row
    hr = GetMessageInfo(m_pFldr, m_pCopy->pList->prgidMsg[m_pCopy->iMsg], &mi);
    if (FAILED(hr))
        goto exit;
    
    pmi = &mi;
    
    if (0 == mi.faStream || !!(mi.dwFlags & ARF_ARTICLE_EXPIRED))
    {
        // if the server is NULL and we don't have a body stream,
        // then something is wrong with the message. we skip the
        // bad message and move onto the next one.
        if (NULL == m_pServer || m_pCopy->fSrcOffline)
        {
            m_pCopy->state = COPY_STATE_DELETE2;
            hr = S_OK;
        }
        else if (!m_pCopy->fSrcRequested)
        {
            Assert(m_pServer != NULL);
            
            hr = m_pServer->GetMessage(m_pCopy->pList->prgidMsg[m_pCopy->iMsg], (IStoreCallback *)this);
            if (hr == E_PENDING)
                m_pCopy->fSrcRequested = TRUE;
            Assert(FAILED(hr));
        }
    }
    else
    {
        hr = m_pFldr->OpenStream(ACCESS_READ, mi.faStream, &m_pCopy->pStream);
        if (FAILED(hr))
            goto exit;
        m_pCopy->state = COPY_STATE_SAVE;
    }
    
exit:
    if (NULL != pmi)
        m_pFldr->FreeRecord(pmi);
    return(hr);
}

HRESULT CFolderSync::CopySave()
{
    DWORD dwFlags;
    HRESULT hr;
    MESSAGEINFO Message;
    MESSAGEID id;
    IMimeMessage *pMessage = NULL;
    
    Assert(m_pCopy->pStream != NULL);
    
    dwFlags = 0;
    
    ZeroMemory(&Message, sizeof(MESSAGEINFO));
    Message.idMessage = m_pCopy->pList->prgidMsg[m_pCopy->iMsg];
    if (DB_S_FOUND == m_pFldr->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
    {
        dwFlags = Message.dwFlags;
        m_pFldr->FreeRecord(&Message);
    }
    
    if (m_pCopy->AdjustFlags.dwRemove != 0)
        dwFlags &= ~m_pCopy->AdjustFlags.dwRemove;
    if (m_pCopy->AdjustFlags.dwAdd != 0)
        dwFlags |= m_pCopy->AdjustFlags.dwAdd;
    
    // create a mime message	
    hr = m_pFldr->OpenMessage(m_pCopy->pList->prgidMsg[m_pCopy->iMsg], OPEN_MESSAGE_SECURE, &pMessage, NOSTORECALLBACK);
    if (FAILED(hr))
        goto exit;
    
    if (m_pCopy->fDestOffline)
    {
        Assert(m_pCopy->pDestLocal != NULL);
        hr = g_pSync->CreateMessage(m_pCopy->pDestLocal, &id, SAVE_MESSAGE_GENID, dwFlags, m_pCopy->pStream, pMessage);
    }
    else
    {
        hr = m_pCopy->pDest->SaveMessage(&id, SAVE_MESSAGE_GENID, dwFlags, m_pCopy->pStream, pMessage, (IStoreCallback *)this);
    }
    
    if (hr == E_PENDING || SUCCEEDED(hr))
        m_pCopy->state = COPY_STATE_SAVE2;
    
exit:
    if (NULL != pMessage)
        pMessage->Release();
    
    m_pCopy->pStream->Release();
    m_pCopy->pStream = NULL;
    
    return(hr);
}

HRESULT CFolderSync::CopySave2()
{
    if (m_pCopy->fMove)
    {
        m_pCopy->state = COPY_STATE_DELETE;
    }
    else
    {
        m_pCopy->state = COPY_STATE_OPEN;
        m_pCopy->iMsg++;
        m_pCopy->fSrcRequested = FALSE;

        m_pCopy->pCallback->OnProgress(SOT_COPYMOVE_MESSAGE, m_pCopy->iMsg, m_pCopy->pList->cMsgs, NULL);
    }

    return(S_OK);
}

HRESULT CFolderSync::CopyDelete()
{
    MESSAGEIDLIST list;
    HRESULT hr;
    MESSAGEID id;
    ADJUSTFLAGS afFlags;

    list.cMsgs = 1;
    id = m_pCopy->pList->prgidMsg[m_pCopy->iMsg];
    list.prgidMsg = &id;

    if (m_pServer != NULL)
    {
        if (m_pCopy->fSrcOffline)
        {
            if (m_fImap)
            {
                afFlags.dwAdd = ARF_ENDANGERED;
                afFlags.dwRemove = 0;
                hr = g_pSync->SetMessageFlags(m_pFldr, &list, &afFlags);
            }
            else
            {
#ifdef DEAD
                hr = g_pSync->DeleteMessages(m_pFldr, DELETE_MESSAGE_NOTRASHCAN, &list);
#endif // DEAD
                hr = S_OK;
            }
        }
        else
        {
            hr = m_pServer->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT | DELETE_MESSAGE_MAYIGNORENOTRASH, &list, (IStoreCallback *)this);
        }
    }
    else
    {
        hr = m_pFldr->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NOSTORECALLBACK);
    }

    if (hr == E_PENDING || SUCCEEDED(hr))
        m_pCopy->state = COPY_STATE_DELETE2;

    return(hr);
}

HRESULT CFolderSync::CopyDelete2()
{
    m_pCopy->state = COPY_STATE_OPEN;
    m_pCopy->iMsg++;
    m_pCopy->fSrcRequested = FALSE;

    m_pCopy->pCallback->OnProgress(SOT_COPYMOVE_MESSAGE, m_pCopy->iMsg, m_pCopy->pList->cMsgs, NULL);

    return(S_OK);
}

HRESULT CFolderSync::_CopyMessageState()
{
    BOOL fBegin;
    HRESULT hr;
    HWND hwnd;
    IStoreCallback *pCallback;

    Assert(m_pCopy != NULL);
    Assert(m_pCopy->hr != S_FALSE);
    Assert(m_pCopy->hr != E_PENDING);

    if (FAILED(m_pCopy->hr) && m_pCopy->state == COPY_STATE_OPEN && m_pCopy->fSrcRequested)
    {
        m_pCopy->fDownloadFail = TRUE;
        m_pCopy->hr = S_OK;
        m_pCopy->iMsg++;
        m_pCopy->fSrcRequested = FALSE;
    }

    if (FAILED(m_pCopy->hr))
    {
        hr = m_pCopy->hr;
    }
    else
    {
        while (TRUE)
        {
            if (m_pCopy->tyCancel != CT_INVALID)
            {
                m_pCopy->state = COPY_STATE_DONE;
                hr = S_FALSE;
                break;
            }

            hr = (this->*(c_rgpfnCopyMsgs[m_pCopy->state]))();

            if (FAILED(hr) || m_pCopy->state == COPY_STATE_DONE)
                break;
        }
    }

    if (hr == E_PENDING)
    {
        Assert(m_pCopy->type == SOT_INVALID);
        m_pCopy->fAsync = TRUE;
        m_pCopy->hr = S_FALSE;
    }
    else if (FAILED(hr) || m_pCopy->state == COPY_STATE_DONE)
    {
        fBegin = m_pCopy->fBegin;
#ifdef DEBUG
        if (fBegin)
            Assert(m_pCopy->fAsync);
#endif // DEBUG
        pCallback = m_pCopy->pCallback;

        if (fBegin)
        {
            if (m_pCopy->fDownloadFail && SUCCEEDED(hr))
            {
                if (SUCCEEDED(pCallback->GetParentWindow(0, &hwnd)))
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                        m_pCopy->fMove ? MAKEINTRESOURCEW(idsMoveDownloadFail) : MAKEINTRESOURCEW(idsCopyDownloadFail),
                        NULL, MB_ICONEXCLAMATION | MB_OK);
                }
            }

            pCallback->OnComplete(SOT_COPYMOVE_MESSAGE, hr, NULL, m_pCopy->pErrorInfo);
        }

        _FreeCopyInfo();
    }

    return(hr);
}

LRESULT CALLBACK CFolderSync::FolderSyncWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    CFolderSync *pThis;

    pThis = (CFolderSync *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (NULL == pThis && msg != WM_CREATE)
        return DefWindowProc(hwnd, msg, wParam, lParam);

    switch(msg)
    {
        case WM_CREATE:
            Assert(pThis == NULL);
            pThis = (CFolderSync *)((CREATESTRUCT *)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
            break;

        case WM_USER:
            pThis->_CopyMessageState();
            break;
    }

    return(DefWindowProc(hwnd, msg, wParam, lParam));
}

//--------------------------------------------------------------------------
// CFolderSync::ConnectionAddRef
//
// Purpose: users of IMessageFolder need to keep alive the underlying server 
//          object if they plan of re-using the same server connection as
//          another user of the same IMessageTable. eg. a note and a view window
//          This allows us to not have to re-auth for operations that could
//          be potentially expensive
//--------------------------------------------------------------------------
HRESULT CFolderSync::ConnectionAddRef()
{
    if (m_pServer)
        m_pServer->ConnectionAddRef();
    return S_OK;
}

//--------------------------------------------------------------------------
// CFolderSync::ConnectionRelease
//
// Purpose: figure it out
//--------------------------------------------------------------------------
HRESULT CFolderSync::ConnectionRelease()
{
    if (m_pServer)
        m_pServer->ConnectionRelease();
    return S_OK;
}

HRESULT CFolderSync::GetAdBarUrl(IStoreCallback *pCallback)
{
    HRESULT     hr = E_FAIL;

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);

    if (m_pServer)
        hr = m_pServer->GetAdBarUrl(pCallback);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\fldrsync.h ===
#ifndef __FLDRSYNC_H
#define __FLDRSYNC_H

#include <conman.h>

class CFolderSync;

enum
{
    COPY_STATE_OPEN = 0,
    COPY_STATE_SAVE,
    COPY_STATE_SAVE2,
    COPY_STATE_DELETE,
    COPY_STATE_DELETE2,
    COPY_STATE_DONE
};

enum
{
    CONN_STATE_CONNECTED = 0,
    CONN_STATE_NOT_CONNECTED,
    CONN_STATE_OFFLINE
};

typedef HRESULT (CFolderSync::*PFNCOPYFUNC)(THIS_ void);

typedef struct tagCOPYINFO
{
    DWORD           state;
    HRESULT         hr;
    CANCELTYPE      tyCancel;
    STOREOPERATIONTYPE type;
    BOOL            fDownloadFail;

    IMessageFolder *pDest;
    IMessageFolder *pDestLocal;
    LPMESSAGEIDLIST pList;
    ADJUSTFLAGS     AdjustFlags;
    IStoreCallback *pCallback;
    STOREERROR     *pErrorInfo;

    BOOL            fAsync;
    BOOL            fBegin;
    BOOL            fMove;
    DWORD           iMsg;
    BOOL            fSrcOffline;
    BOOL            fDestOffline;

    IStream        *pStream;

    BOOL            fSrcRequested;
} COPYINFO;

//--------------------------------------------------------------------------
// CFolderSync
//--------------------------------------------------------------------------
class CFolderSync : 
    public IMessageFolder,
    public IServiceProvider,
    public IStoreCallback,
    public IOperationCancel,
    public IConnectionNotify
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CFolderSync(void);
    ~CFolderSync(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageFolder Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERID idFolder);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback);
    STDMETHODIMP Close();
    STDMETHODIMP GetFolderId(LPFOLDERID pidFolder);
    STDMETHODIMP GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder);
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP OpenMessage(MESSAGEID idMessage, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP SaveMessage(LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageStream(MESSAGEID idMessage, IStream *pStream);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPRESULTLIST pResults, IStoreCallback *pCallback); 
    STDMETHODIMP DoFolderCounts(BOOL fDoCounts);
    STDMETHODIMP ConnectionAddRef();
    STDMETHODIMP ConnectionRelease();
    STDMETHODIMP GetDatabase(IDatabase **ppDB) { return m_pFldr->GetDatabase(ppDB); }
    STDMETHODIMP ResetFolderCounts(DWORD cMessages, DWORD cUnread, DWORD cWatchedUnread, DWORD cWatched) { return m_pFldr->ResetFolderCounts(cMessages, cUnread, cWatchedUnread, cWatched); }
    STDMETHODIMP IsWatched(LPCSTR pszReferences, LPCSTR pszSubject) { return m_pFldr->IsWatched(pszReferences, pszSubject); }
    STDMETHODIMP GetAdBarUrl(IStoreCallback    *pCallback);   

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(TRUE, m_pFldr);

    //----------------------------------------------------------------------
    // IServiceProvider
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IStoreCallback
    //----------------------------------------------------------------------
    HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    //----------------------------------------------------------------------
    // IOperationCancel
    //----------------------------------------------------------------------
    HRESULT STDMETHODCALLTYPE Cancel(CANCELTYPE tyCancel);

    //----------------------------------------------------------------------
    // IConnectionNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);

    // CFolderSync
    HRESULT Initialize(IMessageStore *pStore, IMessageFolder *pLocalFolder, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERTYPE tyFolder, FOLDERID idFolder, FOLDERID idServer);

    HRESULT CopyOpen(void);
    HRESULT CopySave(void);
    HRESULT CopySave2(void);
    HRESULT CopyDelete(void);
    HRESULT CopyDelete2(void);

    static LRESULT CALLBACK FolderSyncWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _Offline(DWORD *pdwState);
    HRESULT _OfflineServer(FOLDERID idServer, DWORD *pdwState);
    HRESULT _CopyMessageState(void);
    void    _FreeCopyInfo(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;             // Ref Count
    FOLDERTYPE          m_tyFolder;         // Type of folder I'm In
    FOLDERID            m_idFolder;         // Folder Id
    FOLDERID            m_idServer;
    char                m_szAcctId[CCHMAX_ACCOUNT_NAME];
    IMessageFolder     *m_pFldr;            // local message folder
    IMessageStore      *m_pLocalStore;      // Store Object
    IMessageServer     *m_pServer;
    BOOL                m_fConManAdvise;
    HWND                m_hwnd;
    COPYINFO           *m_pCopy;
    BOOL                m_fImap;            // IMAP special-casing lives!
};

#endif // __FLDRSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\msgtable.cpp ===
//--------------------------------------------------------------------------
// MsgTable.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "msgtable.h"
#include "findfold.h"
#include "storutil.h"
#include "ruleutil.h"
#include "newsutil.h"
#include "xpcomm.h"

//--------------------------------------------------------------------------
// CGROWTABLE
//--------------------------------------------------------------------------
#define CGROWTABLE              256
#define INVALID_ROWINDEX        0xffffffff
#define ROWSET_FETCH            100

//--------------------------------------------------------------------------
// GETTHREADSTATE
//--------------------------------------------------------------------------
typedef struct tagGETTHREADSTATE {
    MESSAGEFLAGS            dwFlags;
    DWORD                   cHasFlags;
    DWORD                   cChildren;
} GETTHREADSTATE, *LPGETTHREADSTATE;

//--------------------------------------------------------------------------
// THREADISFROMME
//--------------------------------------------------------------------------
typedef struct tagTHREADISFROMME {
    BOOL                    fResult;
    LPROWINFO               pRow;
} THREADISFROMME, *LPTHREADISFROMME;

//--------------------------------------------------------------------------
// THREADHIDE
//--------------------------------------------------------------------------
typedef struct tagTHREADHIDE {
    BOOL                    fNotify;
} THREADHIDE, *LPTHREADHIDE;

//--------------------------------------------------------------------------
// GETSELECTIONSTATE
//--------------------------------------------------------------------------
typedef struct tagGETSELECTIONSTATE {
    SELECTIONSTATE          dwMask;
    SELECTIONSTATE          dwState;
} GETSELECTIONSTATE, *LPGETSELECTIONSTATE;

//--------------------------------------------------------------------------
// GETTHREADPARENT
//--------------------------------------------------------------------------
typedef struct tagGETTHREADPARENT {
    IDatabase       *pDatabase;
    IHashTable      *pHash;
    LPVOID           pvResult;
} GETTHREADPARENT, *LPGETTHREADPARENT;

//--------------------------------------------------------------------------
// IsInitialized
//--------------------------------------------------------------------------
#define IsInitialized(_pThis) \
    (_pThis->m_pFolder && _pThis->m_pDB)

//--------------------------------------------------------------------------
// EnumRefsGetThreadParent
//--------------------------------------------------------------------------
HRESULT EnumRefsGetThreadParent(LPCSTR pszMessageId, DWORD_PTR dwCookie,
    BOOL *pfDone)
{
    // Locals
    LPGETTHREADPARENT pGetParent = (LPGETTHREADPARENT)dwCookie;

    // Trace
    TraceCall("EnumRefsGetThreadParent");

    // Find Message Id
    if (SUCCEEDED(pGetParent->pHash->Find((LPSTR)pszMessageId, FALSE, &pGetParent->pvResult)))
    {
        // Ok
        *pfDone = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::CMessageTable
//--------------------------------------------------------------------------
CMessageTable::CMessageTable(void)
{
    TraceCall("CMessageTable::CMessageTable");
    m_cRef = 1;
    m_fSynching = FALSE;
    m_pFolder = NULL;
    m_pDB = NULL;
    m_cRows = 0;
    m_cView = 0;
    m_cFiltered = 0;
    m_cUnread = 0;
    m_cAllocated = 0;
    m_prgpRow = NULL;
    m_prgpView = NULL;
    m_pFindFolder = NULL;
    m_pNotify = NULL;
    m_fRelNotify = FALSE;
    m_pThreadMsgId = NULL;
    m_pThreadSubject = NULL;
    m_pQuery = NULL;
    m_cDelayed = 0;
    m_fRegistered = FALSE;
    m_clrWatched = 0;
    m_pszEmail = NULL;
    m_fLoaded = FALSE;
    ZeroMemory(&m_SortInfo, sizeof(FOLDERSORTINFO));
    ZeroMemory(&m_Notify, sizeof(NOTIFYQUEUE));
    ZeroMemory(&m_Folder, sizeof(FOLDERINFO));
    m_Notify.iRowMin = 0xffffffff;
    m_Notify.fClean = TRUE;
}

//--------------------------------------------------------------------------
// CMessageTable::~CMessageTable - Don't put any Asserts in this function
//--------------------------------------------------------------------------
CMessageTable::~CMessageTable()
{
    // Trace
    TraceCall("CMessageTable::~CMessageTable");

    // Free Folder Info
    g_pStore->FreeRecord(&m_Folder);

    // Free Cached Rows
    _FreeTable();

    // Release the Folder
    SafeRelease(m_pFolder);

    // Release Query Object...
    SafeRelease(m_pQuery);

    // Release DB after folder, because releasing folder can cause call chain: ~CFolderSync->~CServerQ->
    // CMessageList::OnComplete->CMessageTable::GetCount, for which we need a m_pDB.
    if (m_pDB)
    {
        // Unregister
        m_pDB->UnregisterNotify((IDatabaseNotify *)this);

        // Release the Folder
        m_pDB->Release();

        // Null
        m_pDB = NULL;
    }

    // Release the Find Folder
    SafeRelease(m_pFindFolder);

    // Set pCurrent
    if (m_pNotify)
    {
        if (m_fRelNotify)
            m_pNotify->Release();
        m_pNotify = NULL;
    }

    // Free m_pszEmail
    SafeMemFree(m_pszEmail);

    // Free the Notification Queue
    SafeMemFree(m_Notify.prgiRow);
}

//--------------------------------------------------------------------------
// CMessageTable::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageTable::AddRef(void)
{
    TraceCall("CMessageTable::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CMessageTable::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageTable::Release(void)
{
    TraceCall("CMessageTable::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CMessageTable::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CMessageTable::QueryInterface");

    // Invalid Arg
    Assert(ppv);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageTable *)this;
    else if (IID_IMessageTable == riid)
        *ppv = (IMessageTable *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_FIsHidden
//--------------------------------------------------------------------------
BOOL CMessageTable::_FIsHidden(LPROWINFO pRow)
{
    // Trace
    TraceCall("CMessageTable::_FIsHidden");

    // Hide Deleted ?
    if (FALSE == m_SortInfo.fShowDeleted && ISFLAGSET(pRow->Message.dwFlags, ARF_ENDANGERED))
        return(TRUE);

    // Hide Offline Deleted ?
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_DELETED_OFFLINE))
        return(TRUE);

    // Not Hidden
    return(FALSE);
}

//--------------------------------------------------------------------------
// CMessageTable::_FIsFiltered
//--------------------------------------------------------------------------
BOOL CMessageTable::_FIsFiltered(LPROWINFO pRow)
{
    // Trace
    TraceCall("CMessageTable::_FIsFiltered");

    // No Query Object
    if (NULL == m_pQuery)
        return(FALSE);

    // No m_pQuery
    return(S_OK == m_pQuery->Evaluate(&pRow->Message) ? FALSE : TRUE);
}

//--------------------------------------------------------------------------
// CMessageTable::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Initialize(FOLDERID idFolder, IMessageServer *pServer,
    BOOL fFindTable, IStoreCallback *pCallback)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CMessageTable::Initialize");

    // Already Open ?
    if (m_pFolder)
    {
        hr = TraceResult(E_UNEXPECTED);
        goto exit;
    }

    // Search Folder ?
    if (fFindTable)
    {
        // Create a Find Folder
        IF_NULLEXIT(m_pFindFolder = new CFindFolder);

        // Initialize
        IF_FAILEXIT(hr = m_pFindFolder->Initialize(g_pStore, NULL, NOFLAGS, idFolder));

        // Get an IMessageFolder
        IF_FAILEXIT(hr = m_pFindFolder->QueryInterface(IID_IMessageFolder, (LPVOID *)&m_pFolder));
    }

    // Otherwise
    else
    {
        // Are there children
        IF_FAILEXIT(hr = g_pStore->OpenFolder(idFolder, pServer, NOFLAGS, &m_pFolder));
    }

    // Get the folder id, it might have changed if this is a find folder
    IF_FAILEXIT(hr = m_pFolder->GetFolderId(&idFolder));

    // Get Folder Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &m_Folder));

    // Get the Database
    IF_FAILEXIT(hr = m_pFolder->GetDatabase(&m_pDB));

    // Set m_clrWatched
    m_clrWatched = (WORD)DwGetOption(OPT_WATCHED_COLOR);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::StartFind
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CMessageTable::StartFind");

    // Validate State
    if (!IsInitialized(this) || NULL == m_pFindFolder)
        return(TraceResult(E_UNEXPECTED));

    // Initialize the Find Folder
    IF_FAILEXIT(hr = m_pFindFolder->StartFind(pCriteria, pCallback));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetSortChangeInfo
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetSortChangeInfo(LPFOLDERSORTINFO pSortInfo,
    LPFOLDERUSERDATA pUserData, LPSORTCHANGEINFO pChange)
{
    // Locals
    HRESULT     hr;
    DWORD       dwVersion;

    // Trace
    TraceCall("CMessageTable::_GetSortChangeInfo");

    // INitialize
    ZeroMemory(pChange, sizeof(SORTCHANGEINFO));

    // Invalid ?
    if (pSortInfo->ridFilter == RULEID_INVALID)
    {
        // Reset
        pSortInfo->ridFilter = RULEID_VIEW_ALL;
    }

    // Get the filter version
    hr = RuleUtil_HrGetFilterVersion(pSortInfo->ridFilter, &dwVersion);

    // Bummer, that failed, so lets revert back to the default filter
    if (FAILED(hr))
    {
        // View All filter
        pSortInfo->ridFilter = RULEID_VIEW_ALL;

        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Ohterwise, If this is a different filter
    else if (pUserData->ridFilter != pSortInfo->ridFilter)
    {
        // Reset Version
        pUserData->dwFilterVersion = dwVersion;

        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Otherwise, did the version of this filter change
    else if (pUserData->dwFilterVersion != dwVersion)
    {
        // Reset Version
        pUserData->dwFilterVersion = dwVersion;

        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Other filtering changes
    if (pSortInfo->fShowDeleted != (BOOL)pUserData->fShowDeleted || pSortInfo->fShowReplies != (BOOL)pUserData->fShowReplies)
    {
        // Filter Changed...
        pChange->fFilter = TRUE;
    }

    // Sort Order Change
    if (pSortInfo->idColumn != (COLUMN_ID)pUserData->idSort || pSortInfo->fAscending != (BOOL)pUserData->fAscending)
    {
        // Sort Changed
        pChange->fSort = TRUE;
    }

    // Thread Change...
    if (pSortInfo->fThreaded != (BOOL)pUserData->fThreaded)
    {
        // Thread Change
        pChange->fThread = TRUE;
    }

    // Expand Change
    if (pSortInfo->fExpandAll != (BOOL)pUserData->fExpandAll)
    {
        // Expand Change
        pChange->fExpand = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::OnSynchronizeComplete
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::OnSynchronizeComplete(void)
{
    // Locals
    DWORD           i;
    SORTCHANGEINFO  Change={0};

    // Trace
    TraceCall("CMessageTable::OnSynchronizeComplete");

    // If Not New...
    if (FOLDER_NEWS != m_Folder.tyFolder)
        goto exit;

    // Finish any insert notifications
    m_pDB->DispatchNotify(this);

    // Nothing to do...
    if (0 == m_cDelayed)
        goto exit;

    // Reset m_cDelayed
    m_cDelayed = 0;

    // ChangeSortOrThreading
    _SortThreadFilterTable(&Change, m_SortInfo.fShowReplies);

    // Remove fDelayed Bit...
    for (i = 0; i < m_cRows; i++)
    {
        // Remove Delayed Bit
        m_prgpRow[i]->fDelayed = FALSE;
    }

exit:
    // Reset m_fSynching
    m_fSynching = FALSE;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::SetSortInfo
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::SetSortInfo(LPFOLDERSORTINFO pSortInfo,
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HCURSOR         hCursor=NULL;
    HLOCK           hLock=NULL;
    FOLDERUSERDATA  UserData;
    SORTCHANGEINFO  Change;
    IF_DEBUG(DWORD  dwTickStart=GetTickCount());

    // Trace
    TraceCall("CMessageTable::SetSortInfo");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // If this isn't a news folder then don't allow fShowReplies
    if (FOLDER_NEWS != m_Folder.tyFolder)
    {
        // Clear fShowReplies
        pSortInfo->fShowReplies = FALSE;
    }

    // Lock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Get UserData
    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Get Sort Change Information...
    IF_FAILEXIT(hr = _GetSortChangeInfo(pSortInfo, &UserData, &Change));

    // Save the SortInfo
    CopyMemory(&m_SortInfo, pSortInfo, sizeof(FOLDERSORTINFO));

    // Total Rebuild ?
    if (NULL == m_prgpRow)
    {
        // Build RowTable
        IF_FAILEXIT(hr = _BuildTable(pCallback));
    }

    // Sort or Threading Change Only
    else if (Change.fSort || Change.fThread || Change.fFilter)
    {
        // ChangeSortOrThreading
        _SortThreadFilterTable(&Change, Change.fFilter);
    }

    // Expand State Change
    else if (Change.fExpand && m_SortInfo.fThreaded)
    {
        // Expand All ?
        if (m_SortInfo.fExpandAll)
        {
            // Expand Everything
            _ExpandThread(INVALID_ROWINDEX, FALSE, FALSE);
        }

        // Otherwise, collapse all
        else
        {
            // Collapse Everything
            _CollapseThread(INVALID_ROWINDEX, FALSE);
        }
    }

    // Otherwise, just refresh the filter
    else
    {
        // RefreshFilter
        _RefreshFilter();
    }

    // Save Sort Order
    UserData.fAscending = pSortInfo->fAscending;
    UserData.idSort = pSortInfo->idColumn;
    UserData.fThreaded = pSortInfo->fThreaded;
    UserData.ridFilter = pSortInfo->ridFilter;
    UserData.fExpandAll = pSortInfo->fExpandAll;
    UserData.fShowDeleted = (BYTE) !!(pSortInfo->fShowDeleted);
    UserData.fShowReplies = (BYTE) !!(pSortInfo->fShowReplies);

    // Get UserData
    IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Have I Registered For Notifications Yet ?
    if (FALSE == m_fRegistered)
    {
        // Register for Notifications
        IF_FAILEXIT(hr = m_pDB->RegisterNotify(IINDEX_PRIMARY, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this));

        // Registered
        m_fRegistered = TRUE;
    }

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Reset Cursor
    SetCursor(hCursor);

    // Time to Sort
    TraceInfo(_MSG("Table Sort Time: %d Milli-Seconds", GetTickCount() - dwTickStart));

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetSortInfo
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetSortInfo(LPFOLDERSORTINFO pSortInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERUSERDATA  UserData;

    // Trace
    TraceCall("CMessageTable::GetSortInfo");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    ZeroMemory(pSortInfo, sizeof(FOLDERSORTINFO));

    // Get Sort Information
    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Save Sort Order if not threaded
    pSortInfo->fAscending = UserData.fAscending;

    // Threaded
    pSortInfo->fThreaded = UserData.fThreaded;

    // Save Sort Column
    pSortInfo->idColumn = (COLUMN_ID)UserData.idSort;

    // Expand All
    pSortInfo->fExpandAll = UserData.fExpandAll;

    // Set rid Filter
    pSortInfo->ridFilter = UserData.ridFilter;

    // Set deleted state
    pSortInfo->fShowDeleted = UserData.fShowDeleted;

    // Set replies
    pSortInfo->fShowReplies = UserData.fShowReplies;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetRowFromIndex
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetRowFromIndex(ROWINDEX iRow, LPROWINFO *ppRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::_GetRowFromIndex");

    // Out of View Range ?
    if (iRow >= m_cView)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Bad Row Index
    if (NULL == m_prgpView[iRow])
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Set pRow
    pRow = m_prgpView[iRow];

    // Validate Reserved...
    IxpAssert(pRow->Message.dwReserved == (DWORD_PTR)pRow);

    // Must have pAllocated
    IxpAssert(pRow->Message.pAllocated);

    // Must have References
    IxpAssert(pRow->cRefs > 0);

    // Set pprow
    *ppRow = pRow;

exit:
    // Return the Row
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_CreateRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::_CreateRow(LPMESSAGEINFO pMessage, LPROWINFO *ppRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::_CreateRow");

    // Allocate the Row
    IF_FAILEXIT(hr = m_pDB->HeapAllocate(HEAP_ZERO_MEMORY, sizeof(ROWINFO), (LPVOID *)&pRow));

    // Save the Highlight
    pRow->wHighlight = pMessage->wHighlight;

    // Copy the message
    CopyMemory(&pRow->Message, pMessage, sizeof(MESSAGEINFO));

    // Set pRow into 
    pRow->Message.dwReserved = (DWORD_PTR)pRow;

    // OneRef
    pRow->cRefs = 1;

    // Return the Row
    *ppRow = pRow;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_DeleteRowFromThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_DeleteRowFromThread(LPROWINFO pRow, BOOL fNotify)
{
    // Locals
    LPROWINFO   pCurrent;
    LPROWINFO   pNewRow;
    ROWINDEX    iMin;
    ROWINDEX    iMax;

    // Trace
    TraceCall("CMessageTable::_DeleteRowFromThread");

    // Abort
    if (FALSE == m_SortInfo.fThreaded || pRow->fFiltered || pRow->fHidden)
        return(S_OK);

    // Notify
    if (fNotify)
    {
        // _RefreshThread
        _GetThreadIndexRange(pRow, TRUE, &iMin, &iMax);
    }

    // If there is a messageid
    if (pRow->Message.pszMessageId)
    {
        // Remove pRow from both threading indexes!!!
        if (SUCCEEDED(m_pThreadMsgId->Find(pRow->Message.pszMessageId, TRUE, (LPVOID *)&pCurrent)))
        {
            // If this isn't this row, then put it back...
            if (pRow != pCurrent)
            {
                // Put It Back
                m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pCurrent, HF_NO_DUPLICATES);
            }
        }
    }

    // If there is a normalized subject and a subject hash table
    if (NULL == pRow->pParent && pRow->Message.pszNormalSubj && m_pThreadSubject)
    {
        // Remove pRow from both threading indexes!!!
        if (SUCCEEDED(m_pThreadSubject->Find(pRow->Message.pszNormalSubj, TRUE, (LPVOID *)&pCurrent)))
        {
            // If this isn't this row, then put it back...
            if (pRow != pCurrent)
            {
                // Put It Back
                m_pThreadSubject->Insert(pRow->Message.pszNormalSubj, (LPVOID)pCurrent, HF_NO_DUPLICATES);
            }
        }
    }

    // If we have a Child
    if (pRow->pChild)
    {
        // Set pNewRow
        pNewRow = pRow->pChild;

        // Promote Children of pNewRow to be at the same level as the children of pRow
        if (pNewRow->pChild)
        {
            // Walk until I find the last sibling
            pCurrent = pNewRow->pChild;
            
            // Continue
            while (pCurrent->pSibling)
            {
                // Validate Parent
                Assert(pCurrent->pParent == pNewRow);

                // Goto Next
                pCurrent = pCurrent->pSibling;
            }

            // Make pLastSibling->pSibling
            pCurrent->pSibling = pNewRow->pSibling;
        }

        // Otherwise, Child is the first sibling of pNewRow
        else
        {
            // Set First Child
            pNewRow->pChild = pNewRow->pSibling;
        }

        // Fixup other children of pRow to have a new parent of pNewRow...
        pCurrent = pNewRow->pSibling;

        // While we have siblings...
        while (pCurrent)
        {
            // Current Parent is pRow
            Assert(pRow == pCurrent->pParent);

            // Reset the parent...
            pCurrent->pParent = pNewRow;

            // Goto Next Sibling
            pCurrent = pCurrent->pSibling;
        }

        // Set the Sibling of pNewRow to be the same sibling as pRow
        pNewRow->pSibling = pRow->pSibling;

        // Reset Parent of pNewRow
        pNewRow->pParent = pRow->pParent;

        // Assume Expanded Flags...
        pNewRow->fExpanded = pRow->fExpanded;

        // Clear dwState
        pNewRow->dwState = 0;

        // If pNewRow is now a Root.. Need to adjust the subject hash table..
        if (NULL == pNewRow->pParent && pNewRow->Message.pszNormalSubj && m_pThreadSubject)
        {
            // Remove pRow from both threading indexes!!!
            m_pThreadSubject->Insert(pNewRow->Message.pszNormalSubj, (LPVOID)pNewRow, HF_NO_DUPLICATES);
        }
    }

    // Otherwise...
    else
    {
        // Set pNewRow for doing sibling/parent fixup
        pNewRow = pRow->pSibling;
    }

    // Otherwise, if there is a parent...
    if (pRow->pParent)
    {
        // Parent must have children
        Assert(pRow->pParent->pChild);

        // First Child of pRow->pParent
        if (pRow == pRow->pParent->pChild)
        {
            // Set new first child to pRow's Sibling
            pRow->pParent->pChild = pNewRow;
        }

        // Otherwise, Walk pParent's Child and remove pRow from Sibling List
        else
        {
            // Set pPrevious
            LPROWINFO pPrevious=NULL;

            // Set pCurrent
            pCurrent = pRow->pParent->pChild;

            // Loop
            while (pCurrent)
            {
                // Is this the row to remove!
                if (pRow == pCurrent)
                {
                    // Better be a previous
                    Assert(pPrevious);

                    // pPrevious's Sibling better be pRow
                    Assert(pPrevious->pSibling == pRow);

                    // Set New Sibling
                    pPrevious->pSibling = pNewRow;

                    // Done
                    break;
                }
                
                // Set pPrevious
                pPrevious = pCurrent;

                // Set pCurrent
                pCurrent = pCurrent->pSibling;
            }

            // Validate
            Assert(pRow == pCurrent);
        }

        // Set row state
        pRow->pParent->dwState = 0;
    }

    // UpdateRows
    if (fNotify && INVALID_ROWINDEX != iMin && INVALID_ROWINDEX != iMax)
    {
        // Queue the Notification
        _QueueNotification(TRANSACTION_UPDATE, iMin, iMax);
    }

    // Clear the row
    pRow->pParent = pRow->pChild = pRow->pSibling = NULL;

    // done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_PGetThreadRoot
//--------------------------------------------------------------------------
LPROWINFO CMessageTable::_PGetThreadRoot(LPROWINFO pRow)
{
    // Trace
    TraceCall("CMessageTable::_PGetThreadRoot");

    // Validate
    Assert(pRow);

    // Set Root
    LPROWINFO pRoot = pRow;

    // While there is a parent
    while (pRoot->pParent)
    {
        // Go Up One
        pRoot = pRoot->pParent;
    }

    // Done
    return(pRoot);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetThreadIndexRange
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetThreadIndexRange(LPROWINFO pRow, BOOL fClearState,
    LPROWINDEX piMin, LPROWINDEX piMax)
{
    // Locals
    LPROWINFO   pRoot;
    ROWINDEX    iRow;

    // Trace
    TraceCall("CMessageTable::_GetThreadIndexRange");

    // Validate Args
    Assert(pRow && piMin && piMax);

    // Initialize
    *piMin = *piMax = INVALID_ROWINDEX;

    // Get the Root
    pRoot = _PGetThreadRoot(pRow);

    // If the root isn't visible, then don't bother...
    if (FALSE == pRoot->fVisible)
        return(S_OK);

    // The Root Must be Visible, not filtered and not hidden
    Assert(FALSE == pRoot->fFiltered && FALSE == pRoot->fHidden);
    
    // Get the Row Index
    SideAssert(SUCCEEDED(GetRowIndex(pRoot->Message.idMessage, piMin)));

    // Init piMax
    (*piMax) = (*piMin);

    // Loop until I hit the next row in the view who is the root
    while (1)
    {
        // Set irow
        iRow = (*piMax) + 1;

        // Dont
        if (iRow >= m_cView)
            break;

        // Look at the Next Row
        if (NULL == m_prgpView[iRow]->pParent)
            break;

        // Increment piMax
        (*piMax) = iRow;
    }

    // ClearState
    if (fClearState)
    {
        // If Clear State
        _WalkMessageThread(pRoot, WALK_THREAD_CURRENT, NULL, _WalkThreadClearState);
    }

    // Done
    return(S_OK);
}
        
//--------------------------------------------------------------------------
// CMessageTable::_LinkRowIntoThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_LinkRowIntoThread(LPROWINFO pParent, LPROWINFO pRow,
    BOOL fNotify)
{
    // Locals
    BOOL            fHadChildren=(pParent->pChild ? TRUE : FALSE);
    LPROWINFO       pCurrent;
    LPROWINFO       pPrevious=NULL;

    // Trace
    TraceCall("CMessageTable::_LinkRowIntoThread");

    // Set Parent
    pRow->pParent = pParent;

    // Loop through the children and find the right place to insert this child
    pCurrent = pParent->pChild;

    // Loop
    while (pCurrent)
    {
        // Compare Received Time...
        if (CompareFileTime(&pRow->Message.ftReceived, &pCurrent->Message.ftReceived) <= 0)
            break;

        // Set Previous
        pPrevious = pCurrent;

        // Goto Next
        pCurrent = pCurrent->pSibling;
    }

    // If there is a pPrevious
    if (pPrevious)
    {
        // Set Sibling of pRow
        pRow->pSibling = pPrevious->pSibling;

        // Point pPrevious to pRow
        pPrevious->pSibling = pRow;
    }

    // Otherwise, set parent child
    else
    {
        // Set Sibling of pRow
        pRow->pSibling = pParent->pChild;

        // First Row ?
        if (NULL == pParent->pChild && FALSE == m_fLoaded)
        {
            // Set Expanded
            pParent->fExpanded = m_SortInfo.fExpandAll;
        }

        // Set Parent Child
        pParent->pChild = pRow;
    }

    // Not Loaded
    if (FALSE == m_fLoaded || TRUE == pRow->fDelayed)
    {
        // Set Expanded Bit on this row...
        pRow->fExpanded = pParent->fExpanded;
    }

    // If this is the first child and we have expand all on
    if (fNotify)
    {
        // First Child...
        if (pParent->fVisible && (m_SortInfo.fExpandAll || pParent->fExpanded))
        {
            // Locals
            ROWINDEX iParent;

            // Expand this thread...
            SideAssert(SUCCEEDED(GetRowIndex(pParent->Message.idMessage, &iParent)));

            // Expand...
            _ExpandThread(iParent, TRUE, FALSE);
        }

        // Otherwise, update this thread range...
        else if (m_pNotify)
        {
            // Locals
            ROWINDEX iMin;
            ROWINDEX iMax;

            // _RefreshThread
            _GetThreadIndexRange(pParent, TRUE, &iMin, &iMax);

            // UpdateRows
            if (INVALID_ROWINDEX != iMin && INVALID_ROWINDEX != iMax)
            {
                // Queue It
                _QueueNotification(TRANSACTION_UPDATE, iMin, iMax);
            }
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_FindThreadParentByRef
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FindThreadParentByRef(LPCSTR pszReferences, 
    LPROWINFO *ppParent)
{
    // Locals
    HRESULT         hr=S_OK;
    GETTHREADPARENT GetParent;

    // Trace
    TraceCall("CMessageTable::_FindThreadParentByRef");

    // Init
    *ppParent = NULL;

    // Setup GetParent
    GetParent.pDatabase = m_pDB;
    GetParent.pHash = m_pThreadMsgId;
    GetParent.pvResult = NULL;

    // EnumerateReferences
    IF_FAILEXIT(hr = EnumerateRefs(pszReferences, (DWORD_PTR)&GetParent, EnumRefsGetThreadParent));

    // Not Found
    if (NULL == GetParent.pvResult)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Return the Row
    *ppParent = (LPROWINFO)GetParent.pvResult;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_InsertRowIntoThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_InsertRowIntoThread(LPROWINFO pRow, BOOL fNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pParent;
    LPMESSAGEINFO   pMessage=&pRow->Message;

    // Trace
    TraceCall("CMessageTable::_InsertRowIntoThread");

    // Better not be hidden or filtered
    Assert(FALSE == pRow->fFiltered && FALSE == pRow->fHidden);

    // Find Parent by References Line
    if (S_OK == _FindThreadParentByRef(pMessage->pszReferences, &pParent))
    {
        // Link row into thread
        _LinkRowIntoThread(pParent, pRow, fNotify);

        // Ok
        hr = S_OK;

        // Done
        goto exit;
    }

    // Subject Threading
    if (m_pThreadSubject)
    {
        // If there is a subject
        if (NULL == pRow->Message.pszNormalSubj)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Try to find a message who has the same normalized subject....
        if (SUCCEEDED(m_pThreadSubject->Find(pRow->Message.pszNormalSubj, FALSE, (LPVOID *)&pParent)))
        {
            // Should we Swap the parent and pRow ?
            if (CompareFileTime(&pRow->Message.ftReceived, &pParent->Message.ftReceived) <= 0)
            {
                // Locals
                ROWINDEX iRow;

                // Make pRow be the Root
                IxpAssert(NULL == pParent->pParent && NULL == pParent->pSibling && pParent->fVisible);

                // No Parent for pRow
                pRow->pParent = NULL;

                // Set Expanded
                pRow->fExpanded = pParent->fExpanded;

                // Get the Row Index
                SideAssert(SUCCEEDED(GetRowIndex(pParent->Message.idMessage, &iRow)));

                // Validate
                Assert(m_prgpView[iRow] == pParent);

                // Replace with pRow
                m_prgpView[iRow] = pRow;

                // Visible
                pRow->fVisible = TRUE;

                // Clear Visible...
                pParent->fVisible = FALSE;

                // Replace the Subject Token
                SideAssert(SUCCEEDED(m_pThreadSubject->Replace(pRow->Message.pszNormalSubj, (LPVOID *)pRow)));

                // Link row into thread
                _LinkRowIntoThread(pRow, pParent, fNotify);
            }

            // Otherwise..
            else
            {
                // Link row into thread
                _LinkRowIntoThread(pParent, pRow, fNotify);
            }

            // Success
            hr = S_OK;

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = S_FALSE;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_RefreshFilter
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RefreshFilter(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;
    SORTCHANGEINFO  Change={0};

    // Trace
    TraceCall("CMessageTable::_RefreshFilter");

    // No filter currently enabled
    if (NULL == m_pQuery)
        goto exit;

    // Loop through current rows...
    for (i = 0; i < m_cRows; i++)
    {
        // Set pRow
        pRow = m_prgpRow[i];

        // If Not Hidden and Not Filtered
        if (pRow->fFiltered)
            continue;

        // Set Filtered Bit
        if (FALSE == _FIsFiltered(pRow))
            continue;

        // Adjust m_cUnread
        _AdjustUnreadCount(pRow, -1);

        // Hide the Row
        _HideRow(pRow, FALSE);

        // Filtered
        pRow->fFiltered = TRUE;

        // Increment m_cFiltered
        m_cFiltered++;
    }
    
exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_SortThreadFilterTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_SortThreadFilterTable(LPSORTCHANGEINFO pChange,
    BOOL fApplyFilter)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;
    QUERYINFO       Query={0};

    // Trace
    TraceCall("CMessageTable::_SortThreadFilterTable");

    // Nothing to resort ?
    if (0 == m_cRows)
        goto exit;

    // Nuke the View Index
    m_cView = 0;

    // Do the Filter
    if (pChange->fFilter)
    {
        // Get m_pQuery
        SafeRelease(m_pQuery);

        // Build a Query Object
        if (SUCCEEDED(RuleUtil_HrBuildQuerysFromFilter(m_SortInfo.ridFilter, &Query)) && Query.pszQuery)
        {
            // Get the Query Object
            IF_FAILEXIT(hr = g_pDBSession->OpenQuery(m_pDB, Query.pszQuery, &m_pQuery));
        }
    }

    // Drop the Threading Indexes
    SafeRelease(m_pThreadMsgId);
    SafeRelease(m_pThreadSubject);

    // If Threaded
    if (m_SortInfo.fThreaded)
    {
        // Create a New Hash TAble
        IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, m_cRows), FALSE, &m_pThreadMsgId));

        // Don't do Subject threading?
        if (DwGetOption(OPT_SUBJECT_THREADING) || (FOLDER_NEWS != m_Folder.tyFolder))
        {
            // Create a Subject Hash Table
            IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, m_cRows), FALSE, &m_pThreadSubject));
        }
    }

    // Reset Unread and Filtered
    m_cUnread = m_cFiltered = 0;

    // Loop through current rows...
    for (i = 0; i < m_cRows; i++)
    {
        // Set pRow
        pRow = m_prgpRow[i];

        // Reset Visible
        pRow->fVisible = FALSE;

        // Clear Threading
        pRow->pParent = pRow->pChild = pRow->pSibling = NULL;

        // Clear dwState
        pRow->dwState = 0;

        // If Threaded..
        if (FALSE == m_SortInfo.fThreaded)
        {
            // Clear Expanded
            pRow->fExpanded = FALSE;
        }

        // Otherwise, if the row is hidden
        else if (pRow->fFiltered || pRow->fHidden)
        {
            // Reset Expanded State
            pRow->fExpanded = m_SortInfo.fExpandAll;
        }

        // Do filter
        if (fApplyFilter)
        {
            // Reset the Highlight
            pRow->Message.wHighlight = pRow->wHighlight;

            // If not doing show repiles
            if (FALSE == m_SortInfo.fShowReplies)
            {
                // Set Filtered Bit
                pRow->fFiltered = _FIsFiltered(pRow);

                // Set Hidden Bit
                pRow->fHidden = _FIsHidden(pRow);
            }

            // Otherwise, clear the filtered bits
            else
            {
                // Clear the Bits
                pRow->fFiltered = pRow->fHidden = FALSE;
            }
        }

        // If Not Filtered
        if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
        {
            // Hash the MessageId
            if (m_SortInfo.fThreaded)
            {
                // Insert Message Id into the hash table
                if (pRow->Message.pszMessageId)
                {
                    // Insert It
                    m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pRow, HF_NO_DUPLICATES);
                }
            }

            // Otherwise, add entry to view index
            else
            {
                // Visible
                pRow->fVisible = TRUE;

                // Put into m_prgpView
                m_prgpView[m_cView] = pRow;

                // Increment View Count
                m_cView++;
            }

            // Adjust m_cUnread
            _AdjustUnreadCount(pRow, 1);
        }

        // Otherwise, free the record
        else
        {
            // Count Filtered
            m_cFiltered++;
        }
    }

    // Sort the Table
    _SortAndThreadTable(fApplyFilter);

    // If Threaded
    if (m_SortInfo.fThreaded)
    {
        // If the Filter Changed, then re-apply collapse and expand...
        if (pChange->fThread)
        {
            // Expand All ?
            if (m_SortInfo.fExpandAll)
            {
                // Expand Everything
                _ExpandThread(INVALID_ROWINDEX, FALSE, FALSE);
            }

            // Otherwise, collapse all
            else
            {
                // Collapse Everything
                _CollapseThread(INVALID_ROWINDEX, FALSE);
            }
        }

        // Otherwise, re-expand threads that were expanded and expand newly deferred inserted rows
        else 
        {
            // Re-Expand Threads that were expanded...
            _ExpandThread(INVALID_ROWINDEX, FALSE, TRUE);
        }
    }

exit:
    // Cleanup
    SafeMemFree(Query.pszQuery);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_BuildTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_BuildTable(IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;
    QUERYINFO       Query={0};
    DWORD           cRecords;
    DWORD           cFetched;
    DWORD           i;
    DWORD           cMessages=0;
    DWORD           cUnread=0;
    DWORD           cWatched=0;
    DWORD           cWatchedUnread=0;
    HROWSET         hRowset=NULL;
    LPMESSAGEINFO   pMessage;
    MESSAGEINFO     rgMessage[ROWSET_FETCH];

    // Trace
    TraceCall("CMessageTable::_BuildTable");

    // Free my current row table
    _FreeTable();

    // Get m_pQuery
    SafeRelease(m_pQuery);

    // Build a Query Object
    if (SUCCEEDED(RuleUtil_HrBuildQuerysFromFilter(m_SortInfo.ridFilter, &Query)) && Query.pszQuery)
    {
        // Get the Query Object
        IF_FAILEXIT(hr = g_pDBSession->OpenQuery(m_pDB, Query.pszQuery, &m_pQuery));
    }

    // Get the Row Count
    IF_FAILEXIT(hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cRecords));

    // Do OnBegin
    if (pCallback)
        pCallback->OnBegin(SOT_SORTING, NULL, (IOperationCancel *)this);

    // If Threaded
    if (m_SortInfo.fThreaded)
    {
        // Create a New Hash TAble
        IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, cRecords), FALSE, &m_pThreadMsgId));

        // Don't do Subject threading?
        if (DwGetOption(OPT_SUBJECT_THREADING) || (FOLDER_NEWS != m_Folder.tyFolder))
        {
            // Create a Subject Hash Table
            IF_FAILEXIT(hr = MimeOleCreateHashTable(max(1024, cRecords), FALSE, &m_pThreadSubject));
        }
    }

    // Allocate the Row Table
    IF_FAILEXIT(hr = HrAlloc((LPVOID *)&m_prgpRow, sizeof(LPROWINFO) * (cRecords + CGROWTABLE)));

    // Allocate the View Table
    IF_FAILEXIT(hr = HrAlloc((LPVOID *)&m_prgpView, sizeof(LPROWINFO) * (cRecords + CGROWTABLE)));

    // Set m_cAllocated
    m_cAllocated = cRecords + CGROWTABLE;

    // Create a Rowset
    IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk the Rowset
    while (S_OK == m_pDB->QueryRowset(hRowset, ROWSET_FETCH, (LPVOID *)rgMessage, &cFetched))
    {
        // Loop through the Rows
        for (i=0; i<cFetched; i++)
        {
            // Set pMessage
            pMessage = &rgMessage[i];

            // Count Messages
            cMessages++;

            // Create a Row
            IF_FAILEXIT(hr = _CreateRow(pMessage, &pRow));

            // Unread ?
            if (!ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
            {
                // Increment cUnread
                cUnread++;

                // Watched
                if (ISFLAGSET(pRow->Message.dwFlags, ARF_WATCH))
                    cWatchedUnread++;
            }

            // Watched
            if (ISFLAGSET(pRow->Message.dwFlags, ARF_WATCH))
                cWatched++;

            // If not showing repiles
            if (FALSE == m_SortInfo.fShowReplies)
            {
                // Set Filtered Bit
                pRow->fFiltered = _FIsFiltered(pRow);

                // Set Hidden Bit
                pRow->fHidden = _FIsHidden(pRow);
            }

            // If Not Filtered
            if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
            {
                // Hash the MessageId
                if (m_SortInfo.fThreaded)
                {
                    // Insert Message Id into the hash table
                    if (pRow->Message.pszMessageId)
                    {
                        // Insert It
                        m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pRow, HF_NO_DUPLICATES);
                    }
                }

                // Otherwise, add entry to view index
                else
                {
                    // Visible
                    pRow->fVisible = TRUE;

                    // Put into m_prgpView
                    m_prgpView[m_cView] = pRow;

                    // Increment View Count
                    m_cView++;
                }

                // Adjust m_cUnread
                _AdjustUnreadCount(pRow, 1);
            }

            // Otherwise, free the record
            else
            {
                // Count Filtered
                m_cFiltered++;
            }

            // Store the Row
            m_prgpRow[m_cRows] = pRow;

            // Increment Row Count
            m_cRows++;
        }

        // Do OnBegin
        if (pCallback)
            pCallback->OnProgress(SOT_SORTING, m_cRows, cRecords, NULL);
    }

    // Reset the folder count
    m_pFolder->ResetFolderCounts(cMessages, cUnread, cWatchedUnread, cWatched);

    // Sort the Table
    _SortAndThreadTable(TRUE);

    // Threaded
    if (m_SortInfo.fThreaded)
    {
        // Expand All ?
        if (m_SortInfo.fExpandAll)
        {
            // Expand Everything
            _ExpandThread(INVALID_ROWINDEX, FALSE, FALSE);
        }

        // Otherwise, collapse all
        else
        {
            // Collapse Everything
            _CollapseThread(INVALID_ROWINDEX, FALSE);
        }
    }

    // Set Bit to denote that m_fBuiltTable
    m_fLoaded = TRUE;

exit:
    // Free rgMessage?
    for (; i<cFetched; i++)
    {
        // Free this record
        m_pDB->FreeRecord(&rgMessage[i]);
    }

    // Close the Rowset
    m_pDB->CloseRowset(&hRowset);

    // Cleanup
    SafeMemFree(Query.pszQuery);

    // Do OnBegin
    if (pCallback)
        pCallback->OnComplete(SOT_SORTING, S_OK, NULL, NULL);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_SortAndThreadTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_SortAndThreadTable(BOOL fApplyFilter)
{
    // Locals
    DWORD       i;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::_SortAndThreadTable");

    // If there are rows...
    if (0 == m_cRows)
        goto exit;

    // Threaded
    if (m_SortInfo.fThreaded)
    {
        // Build Thread Roots
        for (i = 0; i < m_cRows; i++)
        {
            // Set pRow
            pRow = m_prgpRow[i];

            // If Not Filtered...
            if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
            {
                // Insert this row into a thread...
                if (S_FALSE == _InsertRowIntoThread(pRow, FALSE))
                {
                    // Subject Threading ?
                    if (m_pThreadSubject && pRow->Message.pszNormalSubj)
                    {
                        // Insert Subject into Hash Table...
                        m_pThreadSubject->Insert(pRow->Message.pszNormalSubj, (LPVOID)pRow, HF_NO_DUPLICATES);
                    }

                    // Visible
                    pRow->fVisible = TRUE;

                    // Its a Root
                    m_prgpView[m_cView++] = pRow;
                }
            }
        }

        // Show Replies Only ?
        if (fApplyFilter && m_SortInfo.fShowReplies)
        {
            // PruneToReplies
            _PruneToReplies();
        }
    }

    // If there are rows...
    if (0 == m_cView)
        goto exit;

    // Sort the View
    _SortView(0, m_cView - 1);

    // Refresh Filter
    if (fApplyFilter && m_SortInfo.fShowReplies)
    {
        // Refresh Any filter (I have to do this after I've pruned replies
        _RefreshFilter();
    }

exit:
    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_PruneToReplies
//--------------------------------------------------------------------------
HRESULT CMessageTable::_PruneToReplies(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iRow;
    LPROWINFO       pRow;
    FOLDERINFO      Server={0};
    IImnAccount    *pAccount=NULL;
    CHAR            szEmail[CCHMAX_EMAIL_ADDRESS];
    THREADISFROMME  IsFromMe;
    THREADHIDE      HideThread={0};

    // Trace
    TraceCall("CMessageTable::_PruneToReplies");

    // Validate
    Assert(FOLDER_NEWS == m_Folder.tyFolder && TRUE == m_SortInfo.fThreaded);

    // Free m_pszEmail
    SafeMemFree(m_pszEmail);

    // Get Folder Store Info
    IF_FAILEXIT(hr = GetFolderStoreInfo(m_Folder.idFolder, &Server));

    // Better have an account id
    Assert(Server.pszAccountId);

    // Find the Account for the id for this Server
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Server.pszAccountId, &pAccount));

    // Try the NNTP Email Address
    IF_FAILEXIT(hr = pAccount->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szEmail, CCHMAX_EMAIL_ADDRESS));

    // Duplicate szEmail
    IF_NULLEXIT(m_pszEmail = PszDupA(szEmail));

    // Don't notify on hide thread
    HideThread.fNotify = FALSE;

    // Init iRow...
    iRow = 0;

    // Walk through the Roots
    while (iRow < m_cView)
    {
        // Set pRow
        pRow = m_prgpView[iRow];

        // Not a Root ?
        if (NULL == pRow->pParent)
        {
            // Reset
            IsFromMe.fResult = FALSE;
            IsFromMe.pRow = NULL;

            // Find the first message that is from me in this thread...
            _WalkMessageThread(pRow, WALK_THREAD_CURRENT, (DWORD_PTR)&IsFromMe, _WalkThreadIsFromMe);

            // If Not From Me, then hide this thread...
            if (FALSE == IsFromMe.fResult)
            {
                // Find the first message that is from me in this thread...
                _WalkMessageThread(pRow, WALK_THREAD_CURRENT | WALK_THREAD_BOTTOMUP, (DWORD_PTR)&HideThread, _WalkThreadHide);
            }

            // Otherwise, increment iRow
            else
                iRow++;
        }

        // Otherwise, increment iRow
        else
            iRow++;
    }

exit:
    // Clearnup
    SafeRelease(pAccount);
    g_pStore->FreeRecord(&Server);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_AdjustUnreadCount
//--------------------------------------------------------------------------
HRESULT CMessageTable::_AdjustUnreadCount(LPROWINFO pRow, LONG lCount)
{
    // Not Filtered
    if (FALSE == pRow->fFiltered && FALSE == pRow->fHidden)
    {
        // Not Read
        if (FALSE == ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
        {
            // Adjust Unread Count
            m_cUnread += lCount;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SafeStrCmpI
//--------------------------------------------------------------------------
inline SafeStrCmpI(LPCSTR psz1, LPCSTR psz2) 
{
    // Null
    if (NULL == psz1) 
    {
        // Equal
        if (NULL == psz2)
            return(0);

        // Less Than
        return(-1);
    }

    // Greater than
    if (NULL == psz2) 
        return(1);

    // Return Comparison
    return(lstrcmpi(psz1, psz2));
}

//--------------------------------------------------------------------------
// CMessageTable::_CompareMessages
//--------------------------------------------------------------------------
LONG CMessageTable::_CompareMessages(LPMESSAGEINFO pMsg1, LPMESSAGEINFO pMsg2)
{
    // Locals
    LONG lRet = 0;

    // Trace
    TraceCall("CMessageTable::_CompareMessages");

    switch (m_SortInfo.idColumn)
    {
    case COLUMN_TO:
        lRet = SafeStrCmpI(pMsg1->pszDisplayTo, pMsg2->pszDisplayTo);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            }
        break;

    case COLUMN_FROM:
        lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            }
        break;

    case COLUMN_SUBJECT:
        lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_RECEIVED:
        lRet = CompareFileTime(&pMsg1->ftReceived, &pMsg2->ftReceived);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_SENT:
        lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_SIZE:
        lRet = (pMsg1->cbMessage - pMsg2->cbMessage);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            }
        break;

    case COLUMN_FOLDER:
        lRet = SafeStrCmpI(pMsg1->pszFolder, pMsg2->pszFolder);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
            }
        break;

    case COLUMN_LINES:
        lRet = (pMsg1->cLines - pMsg2->cLines);
        if (0 == lRet)
            {
            lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            if (0 == lRet)
                lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            }
        break;

    case COLUMN_ACCOUNT:
        lRet = SafeStrCmpI(pMsg1->pszAcctName, pMsg2->pszAcctName);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftReceived, &pMsg2->ftReceived);
            if (0 == lRet)
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
            }
        break;

    case COLUMN_ATTACHMENT:
        lRet = (pMsg1->dwFlags & ARF_HASATTACH) - (pMsg2->dwFlags & ARF_HASATTACH);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_PRIORITY:
        lRet = (pMsg1->wPriority - pMsg2->wPriority);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_FLAG:
        lRet = (pMsg1->dwFlags & ARF_FLAGGED) - (pMsg2->dwFlags & ARF_FLAGGED);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_DOWNLOADMSG:
        lRet = (pMsg1->dwFlags & ARF_DOWNLOAD) - (pMsg2->dwFlags & ARF_DOWNLOAD);
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    case COLUMN_THREADSTATE:
        lRet = (pMsg1->dwFlags & (ARF_WATCH | ARF_IGNORE)) - (pMsg2->dwFlags & (ARF_WATCH | ARF_IGNORE));
        if (0 == lRet)
            {
            lRet = CompareFileTime(&pMsg1->ftSent, &pMsg2->ftSent);
            if (0 == lRet)
                {
                lRet = SafeStrCmpI(pMsg1->pszNormalSubj, pMsg2->pszNormalSubj);
                if (0 == lRet)
                    lRet = SafeStrCmpI(pMsg1->pszDisplayFrom, pMsg2->pszDisplayFrom);
                }
            }
        break;

    default:
        Assert(FALSE);
        break;
    }

    // Done
    return (m_SortInfo.fAscending ? lRet : -lRet);
}

//--------------------------------------------------------------------------
// CMessageTable::_SortView
//--------------------------------------------------------------------------
VOID CMessageTable::_SortView(LONG left, LONG right)
{
    // Locals
    register LONG   i;
    register LONG   j;
    LPROWINFO       pRow;
    LPROWINFO       y;

    i = left;
    j = right;
    pRow = m_prgpView[(left + right) / 2];

    do  
    {
        while (_CompareMessages(&m_prgpView[i]->Message, &pRow->Message) < 0 && i < right)
            i++;
        while (_CompareMessages(&m_prgpView[j]->Message, &pRow->Message) > 0 && j > left)
            j--;

        if (i <= j)
        {
            y = m_prgpView[i];
            m_prgpView[i] = m_prgpView[j];
            m_prgpView[j] = y;
            i++; j--;
        }
     } while (i <= j);

    if (left < j)
        _SortView(left, j);
    if (i < right)
        _SortView(i, right);
}

//--------------------------------------------------------------------------
// CMessageTable::GetCount
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetCount(GETCOUNTTYPE tyCount, DWORD *pcRows)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idFolder;
    FOLDERINFO      Folder;

    // Trace
    TraceCall("CMessageTable::GetCount");

    // Invalid Args
    Assert(pcRows);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *pcRows = 0;

    // Get the Folder Id
    IF_FAILEXIT(hr = m_pFolder->GetFolderId(&idFolder));

    // Handle Type
    switch(tyCount)
    {
    case MESSAGE_COUNT_VISIBLE:
        *pcRows = m_cView;
        break;

    case MESSAGE_COUNT_ALL:
        *pcRows = (m_cRows - m_cFiltered);
        break;

    case MESSAGE_COUNT_FILTERED:
        *pcRows = m_cFiltered;
        break;

    case MESSAGE_COUNT_UNREAD:
        *pcRows = m_cUnread;
        break;

    case MESSAGE_COUNT_NOTDOWNLOADED:
        if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        {
            if (Folder.tyFolder == FOLDER_NEWS)
                *pcRows = NewsUtil_GetNotDownloadCount(&Folder);
            g_pStore->FreeRecord(&Folder);
        }
        break;

    default:
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_FreeTable
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FreeTable(void)
{
    // Trace
    TraceCall("CMessageTable::_FreeTable");

    // Free Hash Tables
    SafeRelease(m_pThreadMsgId);
    SafeRelease(m_pThreadSubject);

    // Free Elements
    _FreeTableElements();

    // Fre the Array
    SafeMemFree(m_prgpRow);

    // Free the View Index
    SafeMemFree(m_prgpView);

    // Set m_cAllocated
    m_cFiltered = m_cUnread = m_cRows = m_cView = m_cAllocated = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_FreeTableElements
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FreeTableElements(void)
{
    // Trace
    TraceCall("CMessageTable::_FreeTableElements");

    // If we have an m_prgpRow
    if (m_prgpRow)
    {
        // Free Cache
        for (DWORD i=0; i<m_cRows; i++)
        {
            // Not Null ?
            if (m_prgpRow[i])
            {
                // Release the Row
                ReleaseRow(&m_prgpRow[i]->Message);

                // Null It
                m_prgpRow[i] = NULL;
            }
        }
    }

    // Done
    return(S_OK);
}


//--------------------------------------------------------------------------
// CMessageTable::GetRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRow(ROWINDEX iRow, LPMESSAGEINFO *ppInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pRow;

    // Trace
    TraceCall("CMessageTable::GetRow");

    // Invalid Args
    Assert(ppInfo);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *ppInfo = NULL;

    // Failure
    hr = _GetRowFromIndex(iRow, &pRow);
    if (FAILED(hr))
        goto exit;

    // Copy the Record to pInfo...
    *ppInfo = &pRow->Message;

    // Increment Refs
    pRow->cRefs++;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::ReleaseRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::ReleaseRow(LPMESSAGEINFO pMessage)
{
    // Locals
    LPROWINFO pRow;

    // Trace
    TraceCall("CMessageTable::ReleaseRow");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Release ?
    if (pMessage)
    {
        // Get pRow
        pRow = (LPROWINFO)pMessage->dwReserved;

        // Must have at least one ref
        IxpAssert(pRow->cRefs);

        // Decrement Refs
        pRow->cRefs--;

        // No more refs
        if (0 == pRow->cRefs)
        {
            // Free
            m_pDB->FreeRecord(&pRow->Message);

            // Free pMessage
            m_pDB->HeapFree(pRow);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRelativeRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRelativeRow(ROWINDEX iRow, RELATIVEROWTYPE tyRelative, 
    LPROWINDEX piRelative)
{
    // Locals
    HRESULT             hr=S_OK;
    LPROWINFO           pRow;

    // Trace
    TraceCall("CMessageTable::GetRelativeRow");

    // Invalid Args
    Assert(piRelative);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *piRelative = INVALID_ROWINDEX;

    // Failure
    IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

    // Parent
    if (RELATIVE_ROW_PARENT == tyRelative)
    {
        // If this row is expanded...
        if (TRUE == pRow->fExpanded)
        {
            // Expand...
            _CollapseThread(iRow, TRUE);

            // Return iRow
            *piRelative = iRow;
        }

        // If there is a Parent
        else if (pRow->pParent)
        {
            // Get Row Index
            IF_FAILEXIT(hr = GetRowIndex(pRow->pParent->Message.idMessage, piRelative));
        }
    }

    // Child
    else if (RELATIVE_ROW_CHILD == tyRelative)
    {
        // If there is a Parent
        if (pRow->pChild)
        {
            // If not Expanded, expand...
            if (FALSE == pRow->fExpanded)
            {
                // Expand...
                _ExpandThread(iRow, TRUE, FALSE);

                // Return iRow
                *piRelative = iRow;
            }

            // Otherwise...
            else
            {
                // Get Row Index
                IF_FAILEXIT(hr = GetRowIndex(pRow->pChild->Message.idMessage, piRelative));
            }
        }
    }

    // Root
    else if (RELATIVE_ROW_ROOT == tyRelative)
    {
        // While
        while (pRow->pParent)
        {
            // Walk to the root
            pRow = pRow->pParent;
        }

        // Get Row Index
        IF_FAILEXIT(hr = GetRowIndex(pRow->Message.idMessage, piRelative));
    }

    // Failure
    else
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetLanguage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetLanguage(ROWINDEX iRow, LPDWORD pdwCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetLanguage");

    // Invalid Args
    Assert(pdwCodePage);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Get the Row
    IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

    // Get the Charset
    *pdwCodePage = pMessage->wLanguage;

exit:
    // Cleanup
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::SetLanguage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::SetLanguage(DWORD cRows, LPROWINDEX prgiRow, 
    DWORD dwCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    HLOCK           hLock=NULL;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::SetLanguage");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Lock Notify
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Loop
    for (i=0; i<cRows; i++)
    {
        // Get Row
        if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
        {
            // Set the Language
            pRow->Message.wLanguage = (WORD)dwCodePage;

            // Update the Record
            IF_FAILEXIT(hr = m_pDB->UpdateRecord(&pRow->Message));
        }
    }

exit:
    // Lock Notify
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::OpenMessage(ROWINDEX iRow, OPENMESSAGEFLAGS dwFlags, 
    IMimeMessage **ppMessage, IStoreCallback *pCallback)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMESSAGEINFO       pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetMessage");

    // Invalid Args
    Assert(ppMessage);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *ppMessage = NULL;

    // Get the message info
    IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

    // Open the message
    IF_FAILEXIT(hr = m_pFolder->OpenMessage(pMessage->idMessage, dwFlags, ppMessage, pCallback));

exit:
    // Clenaup
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowMessageId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowMessageId(ROWINDEX iRow, LPMESSAGEID pidMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetRowMessageId");

    // Invalid Args
    Assert(pidMessage);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *pidMessage = 0;

    // Get the Row Info
    IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

    // Store the id
    *pidMessage = pMessage->idMessage;

exit:
    // Free
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowIndex
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowIndex(MESSAGEID idMessage, LPROWINDEX piRow)
{
    // Locals
    HRESULT     hr=S_OK;
    ROWINDEX    iRow;
    LPROWINFO   pRow;
    
    // Trace
    TraceCall("CMessageTable::GetRowIndex");

    // Invalid Args
    Assert(idMessage && piRow);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // INit
    *piRow = INVALID_ROWINDEX;

    // Loop through the view index
    for (iRow=0; iRow<m_cView; iRow++)
    {
        // Is This It ?
        if (m_prgpView[iRow]->Message.idMessage == idMessage)
        {
            // Done
            *piRow = iRow;

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetIndentLevel
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetIndentLevel(ROWINDEX iRow, LPDWORD pcIndent)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetIndentLevel");

    // Invalid Args
    Assert(pcIndent);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Don't Call Unless Threaded
    Assert(m_SortInfo.fThreaded);

    // Init
    *pcIndent = 0;

    // Valid irow
    IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

    // Walk the Parent Chain...
    while (pRow->pParent)
    {
        // Increment Index
        (*pcIndent)++;

        // Set pRow
        pRow = pRow->pParent;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkMessageThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkMessageThread(LPROWINFO pRow, WALKTHREADFLAGS dwFlags, 
    DWORD_PTR dwCookie, PFWALKTHREADCALLBACK pfnCallback)
{
    // Locals
    HRESULT     hr=S_OK;
    LPROWINFO   pCurrent;
    LPROWINFO   pTemp;
    BOOL        fCurrent=FALSE;

    // Trace
    TraceCall("CMessageTable::_WalkMessageThread");

    // Invalid Args
    Assert(pfnCallback);

    // Include idMessage ?
    if (ISFLAGSET(dwFlags, WALK_THREAD_CURRENT))
    {
        // This is the first iteration
        fCurrent = TRUE;
    }

    // Don't include current anymore
    FLAGCLEAR(dwFlags, WALK_THREAD_CURRENT);

    // Bottom Up Recursion...
    if (ISFLAGSET(dwFlags, WALK_THREAD_BOTTOMUP))
    {
        // Set iCurrent
        pCurrent = pRow->pChild;

        // Loop
        while (pCurrent)
        {
            // Enumerate Children
            IF_FAILEXIT(hr = _WalkMessageThread(pCurrent, dwFlags, dwCookie, pfnCallback));

            // Set iCurrent
            pTemp = pCurrent->pSibling;

            // Call the Callback
            (*(pfnCallback))(this, pCurrent, dwCookie);

            // Set pCurrent
            pCurrent = pTemp;
        }

        // Can't Support these flags with bottom up...
        if (TRUE == fCurrent)
        {
            // Call the Callback
            (*(pfnCallback))(this, pRow, dwCookie);
        }
    }

    // Otherwise.
    else
    {
        // Include idMessage ?
        if (TRUE == fCurrent)
        {
            // Call the Callback
            (*(pfnCallback))(this, pRow, dwCookie);
        }

        // Set iCurrent
        pCurrent = pRow->pChild;

        // Loop
        while (pCurrent)
        {
            // Call the Callback
            (*(pfnCallback))(this, pCurrent, dwCookie);

            // Enumerate Children
            IF_FAILEXIT(hr = _WalkMessageThread(pCurrent, dwFlags, dwCookie, pfnCallback));

            // Set iCurrent
            pCurrent = pCurrent->pSibling;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetSelectionState
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetSelectionState(DWORD cRows, LPROWINDEX prgiRow, 
    SELECTIONSTATE dwMask, BOOL fIncludeChildren, SELECTIONSTATE *pdwState)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERID            idFolder;
    FOLDERINFO          Folder={0};
    LPROWINFO           pRow;
    FOLDERTYPE          tyFolder;
    DWORD               i;
    GETSELECTIONSTATE   Selection={0};

    // Trace
    TraceCall("CMessageTable::GetSelectionState");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *pdwState = 0;

    // SELECTION_STATE_DELETABLE
    if (ISFLAGSET(dwMask, SELECTION_STATE_DELETABLE))
    {
        // Not a Find Folder ?
        if (NULL == m_pFindFolder)
        {
            // Get the Folder Id from pidFolder
            IF_FAILEXIT(hr = m_pFolder->GetFolderId(&idFolder));

            // Get Folder Info
            IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

            // BUGBUG @bug [PaulHi] 4/23/99  This is backwards.  The FOLDER_NEWS is the only folder
            // that CAN'T delete messages.  The CMessageList::_IsSelectionDeletable() function
            // reverses this so that deletion is available correctly.  I don't want to mess with
            // this now, in case other code compensates for this.
            // $HACK$ We know that the only folder types that can delete messages are FOLDER_NEWS
            if (FOLDER_NEWS == Folder.tyFolder)
            {
                // Set the Flag
                FLAGSET(*pdwState, SELECTION_STATE_DELETABLE);
            }

#if 0
            // [PaulHi] 4/25/99  Only HotMail HTTP servers don't allow deletion of items in the 
            // 'deleted' folders.  Excehange servers do, so back this fix out.
            // [PaulHi] 4/23/99  Raid 62883.
            if ( (FOLDER_HTTPMAIL == Folder.tyFolder) && (FOLDER_DELETED == Folder.tySpecial) )
            {
                FLAGSET(*pdwState, SELECTION_STATE_DELETABLE);  // Not deletable see above @bug comment
            }
#endif
        }

        // Otherwise, ask the find folder...
        else
        {
            // Setup Selection
            Selection.dwMask = dwMask;
            Selection.dwState = 0;

            // Mark things that are in this folder...
            for (i=0; i<cRows; i++)
            {
                // Good Row Index
                if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
                {
                    // Get the Folder Type
                    IF_FAILEXIT(hr = m_pFindFolder->GetMessageFolderType(pRow->Message.idMessage, &tyFolder));

                    // Get the State
                    if (FOLDER_NEWS == tyFolder)
                    {
                        // Set the State
                        FLAGSET(*pdwState, SELECTION_STATE_DELETABLE);

                        // Done
                        break;
                    }

                    // Threaded
                    if (m_SortInfo.fThreaded)
                    {
                        // Do Children ?
                        if (fIncludeChildren && !pRow->fExpanded && pRow->pChild)
                        {
                            // Walk the Thread
                            IF_FAILEXIT(hr = _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&Selection, _WalkThreadGetSelectionState));

                            // Optimize so that we can finish early
                            if (ISFLAGSET(Selection.dwState, SELECTION_STATE_DELETABLE))
                                break;
                        }
                    }
                }
            }
        }
    }

exit:
    // Free
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_IsThreadImportance
//--------------------------------------------------------------------------
HRESULT CMessageTable::_IsThreadImportance(LPROWINFO pRow, MESSAGEFLAGS dwFlag,
    ROWSTATE dwState, ROWSTATE *pdwState)
{
    // Locals
    LPROWINFO       pRoot;
    GETTHREADSTATE  GetState={0};

    // Trace
    TraceCall("CMessageTable::_IsThreadImportance");

    // Validate
    Assert(ARF_WATCH == dwFlag || ARF_IGNORE == dwFlag);

    // Does this row have the flag set ?
    if (ISFLAGSET(pRow->Message.dwFlags, dwFlag))
    {
        // Set the State
        FLAGSET(*pdwState, dwState);

        // Done
        return(S_OK);
    }

    // Get the Root of this thread
    pRoot = _PGetThreadRoot(pRow);

    // Does this row have the flag set ?
    if (ISFLAGSET(pRoot->Message.dwFlags, dwFlag))
    {
        // Set the State
        FLAGSET(*pdwState, dwState);

        // Done
        return(S_OK);
    }

    // Set Flags to Count
    GetState.dwFlags = dwFlag;

    // Enumerate Immediate Children
    _WalkMessageThread(pRoot, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

    // If This is row is marked as read
    if (GetState.cHasFlags > 0)
    {
        // Set the Bit
        FLAGSET(*pdwState, dwState);

        // Done
        return(S_OK);
    }

    // Not Found
    return(S_FALSE);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowState
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowState(ROWINDEX iRow, ROWSTATE dwStateMask, 
    ROWSTATE *pdwState)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetRowState");

    // Invalid Args
    Assert(pdwState);

    // Validate State
    if (!IsInitialized(this) || iRow >= m_cRows)
        return(E_UNEXPECTED);

    // Initialzie
    *pdwState = 0;

    // Get the row
    IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

    // Is the state Cached Yet?
    if (ISFLAGSET(pRow->dwState, ROW_STATE_VALID))
    {
        // Return the State
        *pdwState = pRow->dwState;

        // Done
        return(S_OK);
    }

    // Reset
    pRow->dwState = 0;

    // Get Thread State
    if (m_SortInfo.fThreaded && pRow->pChild && !pRow->fExpanded && ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
    {
        // Locals
        GETTHREADSTATE GetState={0};

        // Set Flags to Count
        GetState.dwFlags = ARF_READ;

        // Enumerate Immediate Children
        _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

        // If This is row is marked as read
        if (GetState.cHasFlags == GetState.cChildren)
            FLAGSET(pRow->dwState, ROW_STATE_READ);
    }

    // Otherwise, just check the message
    else if (ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
        FLAGSET(pRow->dwState, ROW_STATE_READ);
    
    // If single watched row
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_WATCH))
        FLAGSET(pRow->dwState, ROW_STATE_WATCHED);

    // If single ignored row
    else if (ISFLAGSET(pRow->Message.dwFlags, ARF_IGNORE))
        FLAGSET(pRow->dwState, ROW_STATE_IGNORED);

    // ROW_STATE_DELETED
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_ENDANGERED) || ISFLAGSET(pRow->Message.dwFlags, ARF_ARTICLE_EXPIRED))
        FLAGSET(pRow->dwState, ROW_STATE_DELETED);

    // ROW_STATE_HAS_BODY
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_HASBODY))
        FLAGSET(pRow->dwState, ROW_STATE_HAS_BODY);

    // ROW_STATE_FLAGGED
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_FLAGGED))
        FLAGSET(pRow->dwState, ROW_STATE_FLAGGED);

    // ROW_STATE_EXPANDED
    if (m_SortInfo.fThreaded && pRow->fExpanded)
        FLAGSET(pRow->dwState, ROW_STATE_EXPANDED);

    // ROW_STATE_HAS_CHILDREN
    if (m_SortInfo.fThreaded && pRow->pChild)
        FLAGSET(pRow->dwState, ROW_STATE_HAS_CHILDREN);

    // ROW_STATE_MARKED_DOWNLOAD
    if (ISFLAGSET(pRow->Message.dwFlags, ARF_DOWNLOAD))
        FLAGSET(pRow->dwState, ROW_STATE_MARKED_DOWNLOAD);

    // Cache the State
    FLAGSET(pRow->dwState, ROW_STATE_VALID);

    // Return the State
    *pdwState = pRow->dwState;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Mark
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Mark(LPROWINDEX prgiRow, DWORD cRows, 
    APPLYCHILDRENTYPE tyApply, MARK_TYPE tyMark, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPMESSAGEINFO   pMessage=NULL;
    ADJUSTFLAGS     Flags={0};
    MESSAGEIDLIST   List={0};
    LPROWINFO       pRow;
    HCURSOR         hCursor=NULL;

    // Trace
    TraceCall("CMessageTable::Mark");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Handle Mark Type
    switch(tyMark)
    {
    case MARK_MESSAGE_READ: 
        Flags.dwAdd = ARF_READ; 
        break;

    case MARK_MESSAGE_UNREAD: 
        Flags.dwRemove = ARF_READ; 
        break;

    case MARK_MESSAGE_DELETED: 
        Flags.dwAdd = ARF_ENDANGERED; 
        break;

    case MARK_MESSAGE_UNDELETED: 
        Flags.dwRemove = ARF_ENDANGERED; 
        break;

    case MARK_MESSAGE_DOWNLOAD:  
        Flags.dwAdd = ARF_DOWNLOAD;
        break;

    case MARK_MESSAGE_UNDOWNLOAD: 
        Flags.dwRemove = ARF_DOWNLOAD;
        break;

    case MARK_MESSAGE_FLAGGED: 
        Flags.dwAdd = ARF_FLAGGED; 
        break;

    case MARK_MESSAGE_UNFLAGGED: 
        Flags.dwRemove = ARF_FLAGGED; 
        break;

    case MARK_MESSAGE_FORWARDED:
        Flags.dwAdd = ARF_FORWARDED;
        break;

    case MARK_MESSAGE_UNFORWARDED:
        Flags.dwRemove = ARF_FORWARDED;
        break;

    case MARK_MESSAGE_REPLIED:
        Flags.dwAdd = ARF_REPLIED;
        break;

    case MARK_MESSAGE_UNREPLIED:
        Flags.dwRemove = ARF_REPLIED;
        break;

    case MARK_MESSAGE_NOSECUI:
        Flags.dwAdd = ARF_NOSECUI;
        break;

    case MARK_MESSAGE_SECUI:
        Flags.dwRemove = ARF_NOSECUI;
        break;

    case MARK_MESSAGE_WATCH:
        Flags.dwAdd = ARF_WATCH;
        Flags.dwRemove = ARF_IGNORE;
        break;

    case MARK_MESSAGE_IGNORE:
        Flags.dwAdd = ARF_IGNORE;
        Flags.dwRemove = ARF_WATCH;
        break;

    case MARK_MESSAGE_NORMALTHREAD:
        Flags.dwRemove = ARF_WATCH | ARF_IGNORE;
        break;

    case MARK_MESSAGE_RCPT_PROCESSED:
        Flags.dwAdd = ARF_RCPT_PROCESSED;
        break;

    default:
        Assert(FALSE);
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Not Mark All...
    if (prgiRow && cRows)
    {
        // Allocate an Array
        IF_FAILEXIT(hr = _GrowIdList(&List, cRows + 32));

        // Mark things that are in this folder...
        for (i=0; i<cRows; i++)
        {
            // Valid Row Index
            if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
            {
                // Allocate an Array
                IF_FAILEXIT(hr = _GrowIdList(&List, 1));

                // Set id
                List.prgidMsg[List.cMsgs++] = pRow->Message.idMessage;

                // Do the children 
                if (APPLY_CHILDREN == tyApply || (APPLY_COLLAPSED == tyApply && !pRow->fExpanded))
                {
                    // Only if there are children
                    if (pRow->pChild)
                    {
                        // Walk the Thread
                        IF_FAILEXIT(hr = _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&List, _WalkThreadGetIdList));
                    }
                }
            }
        }

        // Are there messages
        if (List.cMsgs > 0)
        {
            // Adjust the Flags
            IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(&List, &Flags, NULL, pCallback));
        }
    }

    // Mark All
    else
    {
        // Adjust the Flags
        IF_FAILEXIT(hr = m_pFolder->SetMessageFlags(NULL, &Flags, NULL, pCallback));
    }

    // Re-Register for notifications
    m_pDB->DispatchNotify((IDatabaseNotify *)this);

exit:
    // Reset Cursor
    SetCursor(hCursor);

    // Cleanup
    SafeMemFree(List.prgidMsg);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::ConnectionRelease
//--------------------------------------------------------------------------
HRESULT CMessageTable::ConnectionAddRef(void)
{
    if (m_pFolder)
        m_pFolder->ConnectionAddRef();
    return S_OK;
}

//--------------------------------------------------------------------------
// CMessageTable::ConnectionRelease
//--------------------------------------------------------------------------
HRESULT CMessageTable::ConnectionRelease(void)
{
    if (m_pFolder)
        m_pFolder->ConnectionRelease();
    return S_OK;
}

//--------------------------------------------------------------------------
// CMessageTable::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Synchronize(SYNCFOLDERFLAGS dwFlags, 
    DWORD           cHeaders,
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CMessageTable::Synchronize");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Tell the Folder to Synch
    hr = m_pFolder->Synchronize(dwFlags, cHeaders, pCallback);

    // Success
    if (E_PENDING == hr)
    {
        // We are synching
        m_fSynching = TRUE;
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::SetOwner
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::SetOwner(IStoreCallback *pDefaultCallback)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CMessageTable::SetOwner");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Set the Owner
    hr = m_pFolder->SetOwner(pDefaultCallback);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Close
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Close(void)
{
    // Locals
    HRESULT hr = S_OK;

    //Trace
    TraceCall("CMessageTable::Close");

    // Pass it on
    if (m_pFolder)
        hr = m_pFolder->Close();

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CMessageTable::GetRowFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetRowFolderId(ROWINDEX iRow, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;

    // Trace
    TraceCall("CMessageTable::GetRowFolderId");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Not a Find Folder ?
    if (NULL == m_pFindFolder)
    {
        // Get the Folder Id from pidFolder
        IF_FAILEXIT(hr = m_pFolder->GetFolderId(pidFolder));
    }

    // Otherwise, ask the find folder...
    else
    {
        // Get the Row
        IF_FAILEXIT(hr = GetRow(iRow, &pMessage));

        // Call into the find folder
        IF_FAILEXIT(hr = m_pFindFolder->GetMessageFolderId(pMessage->idMessage, pidFolder));
    }

exit:
    // Free the Row
    SafeReleaseRow(this, pMessage);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::RegisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::RegisterNotify(REGISTERNOTIFYFLAGS dwFlags, 
    IMessageTableNotify *pNotify)
{
    // Trace
    TraceCall("CMessageTable::RegisterNotify");

    // Invalid Args
    if (NULL == pNotify)
        return TraceResult(E_INVALIDARG);

    // Only One is allowed
    AssertSz(NULL == m_pNotify, "Only one person can register for notifications on my object");

    // Save It
    m_pNotify = pNotify;

    // No Release
    m_fRelNotify = FALSE;

    // AddRef ?
    if (FALSE == ISFLAGSET(dwFlags, REGISTER_NOTIFY_NOADDREF))
    {
        m_pNotify->AddRef();
        m_fRelNotify = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::UnregisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::UnregisterNotify(IMessageTableNotify *pNotify)
{
    // Trace
    TraceCall("CMessageTable::UnregisterNotify");

    // Invalid Args
    if (NULL == pNotify)
        return TraceResult(E_INVALIDARG);

    // Otherwise, remove
    if (m_pNotify)
    {
        // Validate
        Assert(m_pNotify == pNotify);

        // Release It
        if (m_fRelNotify)
            m_pNotify->Release();
        m_pNotify = NULL;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::GetNextRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetNextRow(ROWINDEX iCurrentRow, 
    GETNEXTTYPE tyDirection, ROWMESSAGETYPE tyMessage, GETNEXTFLAGS dwFlags, 
    LPROWINDEX piNewRow)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWINDEX        iRow=iCurrentRow;
    ROWINDEX        iStartRow=iCurrentRow;
    BOOL            fWrapAround=FALSE;
    BYTE            fThreadHasUnread;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetNextRow");

    // Invalid Args
    Assert(piNewRow);

    // Validate State
    if (!IsInitialized(this) || iCurrentRow >= m_cView)
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *piNewRow = INVALID_ROWINDEX;

    // Loop
    while (1)
    {
        // Threaded
        if (m_SortInfo.fThreaded)
        {
            // Get pRow
            IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

            // If not expanded
            if (FALSE == pRow->fExpanded && pRow->pChild)
            {
                // Imay need to expand this row...
                if (ROWMSG_ALL == tyMessage || (ROWMSG_NEWS == tyMessage && ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)) || (ROWMSG_MAIL == tyMessage && !ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)))
                {
                    // If looking for unread, see if the thread has unread messages in it
                    if (ISFLAGSET(dwFlags, GETNEXT_UNREAD) && !ISFLAGSET(dwFlags, GETNEXT_THREAD))
                    {
                        // Locals
                        GETTHREADSTATE GetState={0};

                        // Set Flags to Count
                        GetState.dwFlags = ARF_READ;

                        // Root that isn't totally read...
                        _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

                        // If there are unread children of this 
                        if (GetState.cHasFlags != GetState.cChildren)
                        {
                            // Expand This thread
                            _ExpandThread(iRow, TRUE, FALSE);
                        }
                    }
                }
            }
        }

        // Next ?
        if (GETNEXT_NEXT == tyDirection)
        {
            // Increment 
            iRow++;

            // Start back at zero
            if (iRow >= m_cView)
            {
                // Done
                if (!ISFLAGSET(dwFlags, GETNEXT_UNREAD))
                {
                    hr = E_FAIL;
                    goto exit;
                }

                // We Wrapped Around
                fWrapAround = TRUE;

                // Start back at zero
                iRow = 0;
            }
        }

        // Otherwise, backwards
        else
        {
            // Start back at zero
            if (0 == iRow)
            {
                // Done
                if (!ISFLAGSET(dwFlags, GETNEXT_UNREAD))
                {
                    hr = E_FAIL;
                    goto exit;
                }

                // We Wrapped Around
                fWrapAround = TRUE;

                // Start back at zero
                iRow = m_cView - 1;
            }

            // Otherwise, decrement iRow
            else
                iRow--;
        }

        // Wrapped and back to original row
        if (fWrapAround && iRow == iStartRow)
            break;

        // Validate iRow
        Assert(iRow < m_cView);

        // Get pRow
        IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

        // Good time to Stop ?
        if (ROWMSG_ALL == tyMessage || (ROWMSG_NEWS == tyMessage && ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)) || (ROWMSG_MAIL == tyMessage && !ISFLAGSET(pRow->Message.dwFlags, ARF_NEWSMSG)))
        {
            // Set fThreadHasUnread
            fThreadHasUnread = FALSE;

            // If looking for unread, see if the thread has unread messages in it
            if (ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // Locals
                GETTHREADSTATE GetState={0};

                // Set Flags to Count
                GetState.dwFlags = ARF_READ;

                // Root that isn't totally read...
                _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)&GetState, _WalkThreadGetState);

                // If there are unread children of this 
                if (GetState.cHasFlags != GetState.cChildren)
                {
                    // This thread has unread stuff
                    fThreadHasUnread = TRUE;
                }
            }

            // Looking for the next thread with unread messages in it
            if (ISFLAGSET(dwFlags, GETNEXT_THREAD) && ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // If this is a root thread...
                if (NULL == pRow->pParent)
                {
                    // If this row is unread
                    if (!ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
                    {
                        // This is It
                        *piNewRow = iRow;

                        // Done
                        goto exit;
                    }

                    // Otherwise...
                    else if (fThreadHasUnread)
                    {
                        // This is It
                        *piNewRow = iRow;

                        // Done
                        goto exit;
                    }
                }
            }

            // Looking for a thread root
            else if (ISFLAGSET(dwFlags, GETNEXT_THREAD) && !ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // If this is a root thread...
                if (NULL == pRow->pParent)
                {
                    // This is It
                    *piNewRow = iRow;

                    // Done
                    goto exit;
                }
            }

            // Looking for the next unread message
            else if (!ISFLAGSET(dwFlags, GETNEXT_THREAD) && ISFLAGSET(dwFlags, GETNEXT_UNREAD))
            {
                // If this is a thread that has unread children, then expand It.
                if (m_SortInfo.fThreaded && FALSE == pRow->fExpanded && pRow->pChild && fThreadHasUnread)
                {
                    // Expand This thread
                    _ExpandThread(iRow, TRUE, FALSE);
                }

                // If this is a root thread...
                if (FALSE == ISFLAGSET(pRow->Message.dwFlags, ARF_READ))
                {
                    // This is It
                    *piNewRow = iRow;

                    // Done
                    goto exit;
                }
            }

            // Otherwise, this is it
            else
            {
                // This is It
                *piNewRow = iRow;

                // Done
                goto exit;
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetMessageIdList
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::GetMessageIdList(BOOL fRootsOnly, DWORD cRows, 
    LPROWINDEX prgiRow, LPMESSAGEIDLIST pIdList)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::GetMessageIdList");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    ZeroMemory(pIdList, sizeof(MESSAGEIDLIST));

    // Allocate an Array
    IF_FAILEXIT(hr = _GrowIdList(pIdList, cRows + 32));

    // Mark things that are in this folder...
    for (i=0; i<cRows; i++)
    {
        // Good View Index
        if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
        {
            // _GrowIdList
            IF_FAILEXIT(hr = _GrowIdList(pIdList, 1));

            // Set id
            pIdList->prgidMsg[pIdList->cMsgs++] = pRow->Message.idMessage;

            // If Not Expanded and Has children, insert the children...
            if (!fRootsOnly && m_SortInfo.fThreaded && !pRow->fExpanded && pRow->pChild)
            {
                // Walk the Thread
                IF_FAILEXIT(hr = _WalkMessageThread(pRow, NOFLAGS, (DWORD_PTR)pIdList, _WalkThreadGetIdList));
            }
        }
    }

exit:
    // Done
    return(hr);
}

#if 0
//--------------------------------------------------------------------------
// CMessageTable::_GetRowOrdinal
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetRowOrdinal(MESSAGEID idMessage, LPROWORDINAL piOrdinal)
{
    // Locals
    LONG        lLower=0;
    LONG        lUpper=m_cRows - 1;
    LONG        lCompare;
    DWORD       dwMiddle;
    LPROWINFO   pRow;

    // Do binary search / insert
    while (lLower <= lUpper)
    {
        // Set lMiddle
        dwMiddle = (DWORD)((lLower + lUpper) / 2);

        // Compute middle record to compare against
        pRow = m_prgpRow[dwMiddle];

        // Get string to compare against
        lCompare = ((DWORD)idMessage - (DWORD)pRow->Message.idMessage);

        // If Equal, then were done
        if (lCompare == 0)
        {
            *piOrdinal = dwMiddle;
            return(S_OK);
        }

        // Compute upper and lower 
        if (lCompare > 0)
            lLower = (LONG)(dwMiddle + 1);
        else 
            lUpper = (LONG)(dwMiddle - 1);
    }       

    // Not Found
    return(TraceResult(DB_E_NOTFOUND));
}

//--------------------------------------------------------------------------
// CMessageTable::_ProcessResults
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ProcessResults(TRANSACTIONTYPE tyTransaction,
    DWORD cRows, LPROWINDEX prgiRow, LPRESULTLIST pResults)
{
    // Locals
    DWORD           i;
    ROWORDINAL      iOrdinal;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_ProcessResults");

    // Validate
    Assert(TRANSACTION_UPDATE == tyTransaction || TRANSACTION_DELETE == tyTransaction);

    // Another Validation
    Assert(cRows == pResults->cMsgs);

    // No Results
    if (NULL == pResults || NULL == pResults->prgResult)
        return(S_OK);

    // Do Row Updates Myself...
    for (i=0; i<pResults->cValid; i++)
    {
        // If this row was deleted
        if (S_OK == pResults->prgResult[i].hrResult)
        {
            // Get Row From Index
            if (SUCCEEDED(_GetRowFromIndex(prgiRow[i], &pRow)))
            {
                // Validate
                Assert(pResults->prgResult[i].idMessage == pRow->Message.idMessage);

                // Find the Row Ordinal
                SideAssert(SUCCEEDED(_GetRowOrdinal(pRow->Message.idMessage, &iOrdinal)));

                // We better have found it
                Assert(iOrdinal < m_cRows);

                // Update
                else if (TRANSACTION_UPDATE == tyTransaction)
                {
                    // Get pRow
                    _RowTableUpdate(iOrdinal, &pRow->Message, &pResults->prgResult[i]);
                }
            }
        }
    }

    // Flush Notification Queue
    _FlushNotificationQueue(TRUE);

    // Done
    return(S_OK);
}
#endif

//--------------------------------------------------------------------------
// CMessageTable::DeleteRows
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::DeleteRows(DELETEMESSAGEFLAGS dwFlags, DWORD cRows, 
    LPROWINDEX prgiRow, BOOL fIncludeChildren, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEIDLIST   List={0};
    HCURSOR         hCursor=NULL;

    // Trace
    TraceCall("CMessageTable::DeleteRows");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Get MessageID List
    IF_FAILEXIT(hr = GetMessageIdList((FALSE == fIncludeChildren), cRows, prgiRow, &List));

    // Adjust the Flags
    IF_FAILEXIT(hr = m_pFolder->DeleteMessages(dwFlags, &List, NULL, pCallback));

    // Re-Register for notifications
    m_pDB->DispatchNotify((IDatabaseNotify *)this);

exit:
    // Reset Cursor
    SetCursor(hCursor);

    // Cleanup
    SafeMemFree(List.prgidMsg);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::CopyRows
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::CopyRows(FOLDERID idFolder, 
    COPYMESSAGEFLAGS dwOptions, DWORD cRows, LPROWINDEX prgiRow, 
    LPADJUSTFLAGS pFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEIDLIST   List={0};
    HCURSOR         hCursor=NULL;
    IMessageFolder *pDstFolder=NULL;

    // Trace
    TraceCall("CMessageTable::CopyRows");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Open the Destination Folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pDstFolder));

    // Get MessageID List
    IF_FAILEXIT(hr = GetMessageIdList(FALSE, cRows, prgiRow, &List));

    // Adjust the Flags
    IF_FAILEXIT(hr = m_pFolder->CopyMessages(pDstFolder, dwOptions, &List, pFlags, NULL, pCallback));

    // Re-Register for notifications
    m_pDB->DispatchNotify((IDatabaseNotify *)this);

exit:
    // Reset Cursor
    SetCursor(hCursor);

    // Cleanup
    SafeRelease(pDstFolder);
    SafeMemFree(List.prgidMsg);
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::QueryService
//--------------------------------------------------------------------------
HRESULT CMessageTable::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    // Locals
    HRESULT             hr=E_NOINTERFACE;
    IServiceProvider   *pSP;

    // Trace
    TraceCall("CMessageTable::QueryService");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Currently the msgtable doesn't expose any objects, but will delegate to the folder to see if it can handle it
    if (guidService == IID_IMessageFolder)
    {
        if (m_pFolder)
            hr = m_pFolder->QueryInterface(riid, ppvObject);
    }
    else if (m_pFolder && m_pFolder->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP) == S_OK)
    {
        // Query Service This
        hr = pSP->QueryService(guidService, riid, ppvObject);

        // Release It
        pSP->Release();
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::FindNextRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::FindNextRow(ROWINDEX iStartRow, LPCTSTR pszFindString, 
    FINDNEXTFLAGS dwFlags, BOOL fIncludeBody, ROWINDEX *piNextRow, BOOL *pfWrapped)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEINFO   pMessage=NULL;
    ROWINDEX        iCurrent;
    DWORD           cchFindString;
    BOOL            fWrapAround=FALSE;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageTable::QueryService");

    // Invalid Args
    Assert(pszFindString && piNextRow);

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Initialize
    *piNextRow = -1;
    if (pfWrapped)
        *pfWrapped = FALSE;

    // Get Prefix Length
    cchFindString = lstrlen(pszFindString);

    // Lock the Folder
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Set iCurrent
    iCurrent = iStartRow >= m_cRows ? 0 : iStartRow;

    // COLUMN_TO
    if (FINDNEXT_TYPEAHEAD != dwFlags )
        iCurrent++;

    // Start my Loop
    while (1)
    {
        // Start back at zero
        if (iCurrent >= m_cRows)
        {
            // We Wrapped Around
            fWrapAround = TRUE;

            if (pfWrapped)
                *pfWrapped = TRUE;

            // Start back at zero
            iCurrent = 0;
        }

        // Get the Row Info
        IF_FAILEXIT(hr = GetRow(iCurrent, &pMessage));

        // How to search...
        if (FINDNEXT_ALLCOLUMNS == dwFlags)
        {
            // Display to
            if (pMessage->pszDisplayTo && StrStrIA(pMessage->pszDisplayTo, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }
            
            // Email To
            if (pMessage->pszEmailTo && StrStrIA(pMessage->pszEmailTo, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Display From
            if (pMessage->pszDisplayFrom && StrStrIA(pMessage->pszDisplayFrom, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Email From
            if (pMessage->pszEmailFrom && StrStrIA(pMessage->pszEmailFrom, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Subject
            if (pMessage->pszNormalSubj && StrStrIA(pMessage->pszNormalSubj, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Folder
            if (pMessage->pszFolder && StrStrIA(pMessage->pszFolder, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Account name
            if (pMessage->pszAcctName && StrStrIA(pMessage->pszAcctName, pszFindString))
            {
                *piNextRow = iCurrent;
                goto exit;
            }

            // Search the Body ?
            if (fIncludeBody && pMessage->faStream)
            {
                // Locals
                BOOL fMatch=FALSE;
                IMimeMessage *pMessageObject;
                IStream *pStream;

                // Open the Stream
                if (SUCCEEDED(m_pFolder->OpenMessage(pMessage->idMessage, OPEN_MESSAGE_CACHEDONLY, &pMessageObject, NOSTORECALLBACK)))
                {
                    // Try to Get the Plain Text Stream
                    if (FAILED(pMessageObject->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
                    {
                        // Try to get the HTML stream
                        if (FAILED(pMessageObject->GetTextBody(TXT_HTML, IET_DECODED, &pStream, NULL)))
                            pStream = NULL;
                    }

                    // Do we have a strema
                    if (pStream)
                    {
                        // Search the Stream
                        fMatch = StreamSubStringMatch(pStream, (LPSTR)pszFindString);

                        // Release the Stream
                        pStream->Release();
                    }

                    // Cleanup
                    pMessageObject->Release();
                }

                // Found a Match ?
                if (fMatch)
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
            }
        }

        // Otherwise
        else
        {
            // Handle the column to search on...
            switch(m_SortInfo.idColumn)
            {
            case COLUMN_TO:
                if (pMessage->pszDisplayTo && 0 == StrCmpNI(pszFindString, pMessage->pszDisplayTo, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_FROM:       
                if (pMessage->pszDisplayFrom && 0 == StrCmpNI(pszFindString, pMessage->pszDisplayFrom, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_SUBJECT:    
                if (pMessage->pszNormalSubj && 0 == StrCmpNI(pszFindString, pMessage->pszNormalSubj, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_FOLDER:     
                if (pMessage->pszFolder && 0 == StrCmpNI(pszFindString, pMessage->pszFolder, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            case COLUMN_ACCOUNT:    
                if (pMessage->pszAcctName && 0 == StrCmpNI(pszFindString, pMessage->pszAcctName, cchFindString))
                {
                    *piNextRow = iCurrent;
                    goto exit;
                }
                break;

            default:
                goto exit;
            }
        }

        // Cleanup
        SafeReleaseRow(this, pMessage);

        // Increment iCurrent
        iCurrent++;

        // Wrapped and back to original row
        if (fWrapAround && iCurrent >= iStartRow)
            break;
    }

exit:
    // Cleanup
    SafeReleaseRow(this, pMessage);

    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Collapse
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Collapse(ROWINDEX iRow)
{
    // Trace
    TraceCall("CMessageTable::Collapse");

    // Call Internal Function
    return(_CollapseThread(iRow, TRUE));
}

//--------------------------------------------------------------------------
// CMessageTable::_CollapseThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_CollapseThread(ROWINDEX iRow, BOOL fNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWINDEX        iParent;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_CollapseThread");

    // Expand All ?
    if (INVALID_ROWINDEX == iRow)
    {
        // Walk through the Roots in the View...
        for (iRow = 0; iRow < m_cView; iRow++)
        {
            // Set pRow
            if (NULL == m_prgpView[iRow]->pParent)
            {
                // Set iParent
                iParent = iRow;

                // _CollapseSingleThread
                IF_FAILEXIT(hr = _CollapseSingleThread(&iRow, m_prgpView[iRow], fNotify));

                // Notify ?
                if (fNotify)
                {
                    // Queue It
                    _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
                }
            }
        }
    }

    // Otherwise, expand one row
    else
    {
        // Get the Row
        IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

        // Set iParent
        iParent = iRow;

        // _ExpandSingleThread
        IF_FAILEXIT(hr = _CollapseSingleThread(&iRow, pRow, fNotify));

        // Notify ?
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
        }
    }

exit:
    // Flush
    if (fNotify)
        _FlushNotificationQueue(TRUE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_CollapseSingleThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_CollapseSingleThread(LPROWINDEX piCurrent, 
    LPROWINFO pParent, BOOL fNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pCurrent;

    // Trace
    TraceCall("CMessageTable::_CollapseSingleThread");

    // Mark Parent as Expanded...
    pParent->fExpanded = FALSE;

    // Set row state
    pParent->dwState = 0;

    // If no children
    if (NULL == pParent->pChild)
        return(S_OK);

    // Loop through the children...
    for (pCurrent = pParent->pChild; pCurrent != NULL; pCurrent = pCurrent->pSibling)
    {
        // If not visible
        if (pCurrent->fVisible)
        {
            // Increment
            (*piCurrent)++;

            // Validate
            Assert(m_prgpView[(*piCurrent)] == pCurrent);

            // Insert pCurrent's Children
            IF_FAILEXIT(hr = _CollapseSingleThread(piCurrent, pCurrent, fNotify));

            // Insert into View
            _DeleteFromView((*piCurrent), pCurrent);

            // Insert the Row
            if (fNotify)
            {
                // Queue It
                _QueueNotification(TRANSACTION_DELETE, *piCurrent, INVALID_ROWINDEX, TRUE);
            }

            // Decrement
            (*piCurrent)--;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::Expand
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::Expand(ROWINDEX iRow)
{
    // Trace
    TraceCall("CMessageTable::Collapse");

    // Call Internal Function
    return(_ExpandThread(iRow, TRUE, FALSE));
}

//--------------------------------------------------------------------------
// CMessageTable::_ExpandThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ExpandThread(ROWINDEX iRow, BOOL fNotify, BOOL fReExpand)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWINDEX        iParent;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_ExpandThread");

    // Expand All ?
    if (INVALID_ROWINDEX == iRow)
    {
        // Walk through the Roots in the View...
        for (iRow = 0; iRow < m_cView; iRow++)
        {
            // Set pRow
            if (NULL == m_prgpView[iRow]->pParent)
            {
                // Set iParent
                iParent = iRow;

                // _ExpandSingleThread
                IF_FAILEXIT(hr = _ExpandSingleThread(&iRow, m_prgpView[iRow], fNotify, fReExpand));

                // Notify ?
                if (fNotify)
                {
                    // Queue It
                    _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
                }
            }
        }
    }

    // Otherwise, expand one row
    else
    {
        // Get the Row
        IF_FAILEXIT(hr = _GetRowFromIndex(iRow, &pRow));

        // Set iParent
        iParent = iRow;

        // _ExpandSingleThread
        IF_FAILEXIT(hr = _ExpandSingleThread(&iRow, pRow, fNotify, fReExpand));

        // Notify ?
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iParent, iParent);
        }
    }

exit:
    // Flush
    if (fNotify)
        _FlushNotificationQueue(TRUE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_ExpandSingleThread
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ExpandSingleThread(LPROWINDEX piCurrent, 
    LPROWINFO pParent, BOOL fNotify, BOOL fReExpand)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pCurrent;

    // Trace
    TraceCall("CMessageTable::_ExpandSingleThread");

    // If not delayed inserted...
    if (fReExpand && FALSE == pParent->fExpanded)
        return(S_OK);

    // Mark Parent as Expanded...
    pParent->fExpanded = TRUE;

    // Set row state
    pParent->dwState = 0;

    // If no children
    if (NULL == pParent->pChild)
        return(S_OK);

    // Loop through the children...
    for (pCurrent = pParent->pChild; pCurrent != NULL; pCurrent = pCurrent->pSibling)
    {
        // Increment piCurrent
        (*piCurrent)++;

        // If not visible
        if (FALSE == pCurrent->fVisible)
        {
            // Insert into View
            _InsertIntoView((*piCurrent), pCurrent);

            // Insert the Row
            if (fNotify)
            {
                // Queue It
                _QueueNotification(TRANSACTION_INSERT, *piCurrent, INVALID_ROWINDEX, TRUE);
            }
        }

        // Otherwise, valident entry in view index
        else
            Assert(m_prgpView[(*piCurrent)] == pCurrent);

        // Insert pCurrent's Children
        IF_FAILEXIT(hr = _ExpandSingleThread(piCurrent, pCurrent, fNotify, fReExpand));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_DeleteFromView
//--------------------------------------------------------------------------
HRESULT CMessageTable::_DeleteFromView(ROWINDEX iRow, LPROWINFO pRow)
{
    // Better not be visible yet
    Assert(TRUE == pRow->fVisible);

    // Correct Row
    Assert(m_prgpView[iRow] == pRow);

    // Visible...
    pRow->fVisible = FALSE;

    // Collapse the Array
    MoveMemory(&m_prgpView[iRow], &m_prgpView[iRow + 1], sizeof(LPROWINFO) * (m_cView - (iRow + 1)));

    // Decrement m_cView
    m_cView--;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_InsertIntoView
//--------------------------------------------------------------------------
HRESULT CMessageTable::_InsertIntoView(ROWINDEX iRow, LPROWINFO pRow)
{
    // Better not be visible yet
    Assert(FALSE == pRow->fVisible);

    // Visible...
    pRow->fVisible = TRUE;

    // Increment view Count
    m_cView++;

    // Shift The Array
    MoveMemory(&m_prgpView[iRow + 1], &m_prgpView[iRow], sizeof(LPROWINFO) * (m_cView - iRow));

    // Set the Index
    m_prgpView[iRow] = pRow;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_RowTableInsert
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RowTableInsert(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPROWINFO       pRow;
    ROWINDEX        iRow;

    // Trace
    TraceCall("CMessageTable::_RowTableInsert");

    // Failure
    if (iOrdinal >= m_cRows + 1)
    {
        Assert(FALSE);
        return(TraceResult(E_FAIL));
    }

    // Do I need to grow the table
    if (m_cRows + 1 >= m_cAllocated)
    {
        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prgpRow, sizeof(LPROWINFO) * (m_cRows + CGROWTABLE)));

        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prgpView, sizeof(LPROWINFO) * (m_cRows + CGROWTABLE)));

        // Set m_cAllocated
        m_cAllocated = m_cRows + CGROWTABLE;
    }

    // Create a Row
    IF_FAILEXIT(hr = _CreateRow(pMessage, &pRow));
  
    // Don't Free
    pMessage->pAllocated = NULL;

    // Increment Row Count
    m_cRows++;

    // Shift The Array
    MoveMemory(&m_prgpRow[iOrdinal + 1], &m_prgpRow[iOrdinal], sizeof(LPROWINFO) * (m_cRows - iOrdinal));

    // Set pRow
    m_prgpRow[iOrdinal] = pRow;

    // If the row is Filtered, then just return
    pRow->fFiltered = _FIsFiltered(pRow);

    // Get Hidden Bit
    pRow->fHidden = _FIsHidden(pRow);

    // If not filtered and not hidden
    if (pRow->fFiltered || pRow->fHidden)
    {
        // Update Filtered Count
        m_cFiltered++;

        // Done
        goto exit;
    }

    // If this  is a news folder, then lets just wait for a while...we will get hit with a force sort later...
    if (TRUE == m_fSynching && FOLDER_NEWS == m_Folder.tyFolder)
    {
        // Set Expanded
        pRow->fExpanded = m_SortInfo.fExpandAll;

        // Set fDelayed
        pRow->fDelayed = TRUE;

        // Count Skiped
        m_cDelayed++;

        // Done
        goto exit;
    }

    // If not filtered
    _AdjustUnreadCount(pRow, 1);

    // Show the Row
    _ShowRow(pRow);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_ShowRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::_ShowRow(LPROWINFO pRow)
{
    // Locals
    ROWINDEX iRow = INVALID_ROWINDEX;

    // Compare
    if (m_SortInfo.fShowReplies)
    {
        // Have Addresses
        if (pRow->Message.pszEmailFrom && m_pszEmail)
        {
            // From Me
            if (0 == lstrcmpi(m_pszEmail, pRow->Message.pszEmailFrom))
            {
                // Set the Highlight
                pRow->Message.wHighlight = m_clrWatched;
            }
        }
    }

    // Threaded ?
    if (m_SortInfo.fThreaded)
    {
        // Insert Message Id into the hash table
        if (pRow->Message.pszMessageId)
        {
            // Insert It
            m_pThreadMsgId->Insert(pRow->Message.pszMessageId, (LPVOID)pRow, HF_NO_DUPLICATES);
        }

        // Insert this row into a thread...
        if (S_OK == _InsertRowIntoThread(pRow, TRUE))
            return(S_OK);

        // Subject Threading ?
        // [PaulHi] 6/22/99  Raid 81081
        // Make sure we have a non-NULL subject string pointer before trying to hash it.
        if (m_pThreadSubject && pRow->Message.pszNormalSubj)
        {
            // Insert Subject into Hash Table...
            m_pThreadSubject->Insert(pRow->Message.pszNormalSubj, (LPVOID)pRow, HF_NO_DUPLICATES);
        }
    }

    // If no parent, then just insert sorted into the view
    Assert(NULL == pRow->pParent);

    // Insert into View
    for (iRow=0; iRow<m_cView; iRow++)
    {
        // Only Compare Against Roots
        if (NULL == m_prgpView[iRow]->pParent)
        {
            // Insert Here...
            if (_CompareMessages(&pRow->Message, &m_prgpView[iRow]->Message) <= 0)
                break;
        }
    }

    // Insert into the view
    _InsertIntoView(iRow, pRow);

    // Queue It
    _QueueNotification(TRANSACTION_INSERT, iRow, INVALID_ROWINDEX);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_GetRowFromOrdinal
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GetRowFromOrdinal(ROWORDINAL iOrdinal, 
    LPMESSAGEINFO pExpected, LPROWINFO *ppRow)
{
    // Trace
    TraceCall("CMessageTable::_GetRowFromOrdinal");

    // Failure
    if (iOrdinal >= m_cRows)
    {
        Assert(FALSE);
        return(TraceResult(E_FAIL));
    }

    // Set pRow
    (*ppRow) = m_prgpRow[iOrdinal];

    // Valid Row
    if ((*ppRow)->Message.idMessage != pExpected->idMessage)
    {
        Assert(FALSE);
        return(TraceResult(E_FAIL));
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_RowTableDelete
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RowTableDelete(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage)
{
    // Set pRow
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;

    // Trace
    TraceCall("CMessageTable::_RowTableDelete");

    // Get Row From Ordinal
    IF_FAILEXIT(hr = _GetRowFromOrdinal(iOrdinal, pMessage, &pRow));

    // Shift The Array
    MoveMemory(&m_prgpRow[iOrdinal], &m_prgpRow[iOrdinal + 1], sizeof(LPROWINFO) * (m_cRows - (iOrdinal + 1)));

    // Decrement row Count
    m_cRows--;

    // If the message was filtered
    if (pRow->fFiltered || pRow->fHidden)
    {
        // One less filtered item
        m_cFiltered--;
    }

    // If not filtered
    _AdjustUnreadCount(pRow, -1);

    // Call Utility
    _HideRow(pRow, TRUE);

    // Release the Row
    ReleaseRow(&pRow->Message);

exit:
    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_HideRow
//--------------------------------------------------------------------------
HRESULT CMessageTable::_HideRow(LPROWINFO pRow, BOOL fNotify)
{
    // Locals
    LPROWINFO   pReplace=NULL;
    ROWINDEX    iRow;

    // Trace
    TraceCall("CMessageTable::_HideRow");

    // Threaded
    if (m_SortInfo.fThreaded)
    {
        // Save First Child
        pReplace = pRow->pChild;
    }

    // Delete the row from the thread
    _DeleteRowFromThread(pRow, fNotify);

    // Locate pRow in m_prgpView
    if (FALSE == pRow->fVisible)
        return(S_OK);

    // Better not be hidden or filtered
    Assert(FALSE == pRow->fHidden && FALSE == pRow->fFiltered);

    // Must Succeed
    SideAssert(SUCCEEDED(GetRowIndex(pRow->Message.idMessage, &iRow)));

    // Replace ?
    if (pReplace && TRUE == pRow->fVisible && FALSE == pReplace->fVisible)
    {
        // Validate
        Assert(m_prgpView[iRow] == pRow);

        // Insert into View
        m_prgpView[iRow] = pReplace;

        // Visible...
        pReplace->fVisible = TRUE;

        // Insert the Row
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iRow, iRow, TRUE);
        }
    }

    // Otherwise, just delete it...
    else
    {
        // Delete from view
        _DeleteFromView(iRow, pRow);

        // Notify ?
        if (fNotify)
        {
            // Queue It
            _QueueNotification(TRANSACTION_DELETE, iRow, INVALID_ROWINDEX);
        }
    }

    // Not Visible
    pRow->fVisible = FALSE;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_RowTableUpdate
//--------------------------------------------------------------------------
HRESULT CMessageTable::_RowTableUpdate(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPROWINFO       pRow;
    ROWINDEX        iMin;
    ROWINDEX        iMax;
    BOOL            fDone=FALSE;
    BOOL            fHidden;

    // Trace
    TraceCall("CMessageTable::_RowTableUpdate");

    // Get Row From Ordinal
    IF_FAILEXIT(hr = _GetRowFromOrdinal(iOrdinal, pMessage, &pRow));

    // If not filtered
    _AdjustUnreadCount(pRow, -1);

    // Free pRow->Message
    m_pDB->FreeRecord(&pRow->Message);

    // Copy the Message Info
    CopyMemory(&pRow->Message, pMessage, sizeof(MESSAGEINFO));

    // Set dwReserved
    pRow->Message.dwReserved = (DWORD_PTR)pRow;

    // Don't Free
    pMessage->pAllocated = NULL;

    // Save the Highlight
    pRow->wHighlight = pRow->Message.wHighlight;

    // Clear this rows state...
    pRow->dwState = 0;

    // Compare
    if (m_SortInfo.fShowReplies)
    {
        // Have Addresses
        if (pRow->Message.pszEmailFrom && m_pszEmail)
        {
            // From Me
            if (0 == lstrcmpi(m_pszEmail, pRow->Message.pszEmailFrom))
            {
                // Set the Highlight
                pRow->Message.wHighlight = m_clrWatched;
            }
        }
    }

    // Hidden
    fHidden = _FIsHidden(pRow);

    // If the message was filtered, but isn't filtered now...
    if (TRUE == pRow->fFiltered)
    {
        // Reset the Filtered Bit
        if (FALSE == _FIsFiltered(pRow))
        {
            // Set fFiltered
            pRow->fFiltered = FALSE;

            // If Not Hidden
            if (FALSE == pRow->fHidden)
            {
                // Need to do something so that it gets shown
                pRow->fHidden = !fHidden;

                // Decrement m_cFiltered
                m_cFiltered--;
            }
        }
    }

    // If not filtered
    if (FALSE == pRow->fFiltered)
    {
        // Is it hidden now
        if (FALSE == pRow->fHidden && TRUE == fHidden)
        {
            // If not filtered
            _AdjustUnreadCount(pRow, -1);

            // Hide the Row
            _HideRow(pRow, TRUE);

            // Its Hidden
            pRow->fHidden = TRUE;

            // Increment Filtered
            m_cFiltered++;

            // Done
            fDone = TRUE;
        }

        // Otherwise, if it was hidden, and now its not...
        else if (TRUE == pRow->fHidden && FALSE == fHidden)
        {
            // Its Hidden
            pRow->fHidden = FALSE;

            // If not filtered
            _AdjustUnreadCount(pRow, 1);

            // Increment Filtered
            m_cFiltered--;

            // Show the row
            _ShowRow(pRow);

            // Done
            fDone = TRUE;
        }
    }

    // If not hidden and not filtered
    if (FALSE == fDone && FALSE == pRow->fHidden && FALSE == pRow->fFiltered)
    {
        // If not filtered
        _AdjustUnreadCount(pRow, 1);

        // If this row is visible, then I just need to update this row...
        if (pRow->fVisible)
        {
            // Get the Row Index
            SideAssert(SUCCEEDED(GetRowIndex(pRow->Message.idMessage, &iMin)));

            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iMin, iMin);
        }

        // Otherwise, update the thread range
        else
        {
            // Get the index range of this thread
            _GetThreadIndexRange(pRow, TRUE, &iMin, &iMax);

            // Queue It
            _QueueNotification(TRANSACTION_UPDATE, iMin, iMax);
        }
    }

exit:
    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_FlushNotificationQueue
//--------------------------------------------------------------------------
HRESULT CMessageTable::_FlushNotificationQueue(BOOL fFinal)
{
    // Nothing to Notify
    if (NULL == m_pNotify)
        return(S_OK);

    // Have Delete or Inserted rows ?
    if (m_Notify.cRows > 0)
    {
        // TRANSACTION_INSERT
        if (TRANSACTION_INSERT == m_Notify.tyCurrent)
        {
            // Is this It ?
            m_pNotify->OnInsertRows(m_Notify.cRows, m_Notify.prgiRow, m_Notify.fIsExpandCollapse);
        }

        // TRANSACTION_DELETE
        else if (TRANSACTION_DELETE == m_Notify.tyCurrent)
        {
            // Is this It ?
            m_pNotify->OnDeleteRows(m_Notify.cRows, m_Notify.prgiRow, m_Notify.fIsExpandCollapse);
        }
    }

    // Have Updated Rows ?
    if (m_Notify.cUpdate > 0)
    {
        // Is this It ?
        m_pNotify->OnUpdateRows(m_Notify.iRowMin, m_Notify.iRowMax);

        // Reset Update Range
        m_Notify.cUpdate = 0;
        m_Notify.iRowMin = 0xffffffff;
        m_Notify.iRowMax = 0;
    }

    // Nothing to Notify About
    m_Notify.cRows = 0;

    // Final ?
    m_Notify.fClean = fFinal;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_QueueNotification
//--------------------------------------------------------------------------
HRESULT CMessageTable::_QueueNotification(TRANSACTIONTYPE tyTransaction, 
    ROWINDEX iRowMin, ROWINDEX iRowMax, BOOL fIsExpandCollapse /*=FALSE*/)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("CMessageTable::_QueueNotification");

    // Nothing to Notify
    if (NULL == m_pNotify)
        return(S_OK);

    // Not Clearn
    m_Notify.fClean = FALSE;

    // If Update
    if (TRANSACTION_UPDATE == tyTransaction)
    {
        // Min
        if (iRowMin < m_Notify.iRowMin)
            m_Notify.iRowMin = iRowMin;

        // Max
        if (iRowMax > m_Notify.iRowMax)
            m_Notify.iRowMax = iRowMax;

        // Count Notify
        m_Notify.cUpdate++;
    }

    // Otherwise...
    else
    {
        // Queue It
        if (tyTransaction != m_Notify.tyCurrent || m_Notify.fIsExpandCollapse != fIsExpandCollapse)
        {
            // Flush
            _FlushNotificationQueue(FALSE);

            // Save the New Type
            m_Notify.tyCurrent = tyTransaction;

            // Count fIsExpandCollapse
            m_Notify.fIsExpandCollapse = (BYTE) !!fIsExpandCollapse;
        }

        // Grow the Queue Size
        if (m_Notify.cRows + 1 > m_Notify.cAllocated)
        {
            // Realloc
            IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_Notify.prgiRow, (m_Notify.cAllocated + 256) * sizeof(ROWINDEX)));

            // Set cAlloc
            m_Notify.cAllocated = (m_Notify.cAllocated + 256);
        }

        // Append the iRow
        m_Notify.prgiRow[m_Notify.cRows] = iRowMin;

        // Increment Row count
        m_Notify.cRows++;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::OnTransaction
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::OnTransaction(HTRANSACTION hTransaction, 
    DWORD_PTR dwCookie, IDatabase *pDB)
{
    // Locals
    HRESULT             hr=S_OK;
    ORDINALLIST         Ordinals;
    INDEXORDINAL        iIndex;
    MESSAGEINFO         Message1={0};
    MESSAGEINFO         Message2={0};
    TRANSACTIONTYPE     tyTransaction;

    // Trace
    TraceCall("CMessageTable::OnTransaction");

    // Should have final bit set
    IxpAssert(m_Notify.fClean == TRUE);

    // Loop Through Notifications
    while (hTransaction)
    {
        // Get the Transaction Info
        IF_FAILEXIT(hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Message1, &Message2, &iIndex, &Ordinals));

        // Insert
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Good Ordinal
            Assert(INVALID_ROWORDINAL != Ordinals.rgiRecord1[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] > 0);

            // Insert Row Into Table
            _RowTableInsert(Ordinals.rgiRecord1[IINDEX_PRIMARY] - 1, &Message1);
        }

        // Delete
        else if (TRANSACTION_DELETE == tyTransaction)
        {
            // Good Ordinal
            Assert(INVALID_ROWORDINAL != Ordinals.rgiRecord1[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] > 0);

            // Delete Row From Table
            _RowTableDelete(Ordinals.rgiRecord1[IINDEX_PRIMARY] - 1, &Message1);
        }

        // Update
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Deleted
            Assert(INVALID_ROWORDINAL != Ordinals.rgiRecord1[IINDEX_PRIMARY] && INVALID_ROWORDINAL != Ordinals.rgiRecord2[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] == Ordinals.rgiRecord2[IINDEX_PRIMARY] && Ordinals.rgiRecord1[IINDEX_PRIMARY] > 0 && Ordinals.rgiRecord2[IINDEX_PRIMARY] > 0);

            // Delete Row From Table
            _RowTableUpdate(Ordinals.rgiRecord1[IINDEX_PRIMARY] - 1, &Message2);
        }
    }

exit:
    // Cleanup
    pDB->FreeRecord(&Message1);
    pDB->FreeRecord(&Message2);

    // Flush the Queue
    _FlushNotificationQueue(TRUE);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadGetSelectionState
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadGetSelectionState(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERTYPE          tyFolder;
    LPGETSELECTIONSTATE pState = (LPGETSELECTIONSTATE)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadGetSelectionState");

    // Is Deletetable
    if (ISFLAGSET(pState->dwMask, SELECTION_STATE_DELETABLE))
    {
        // Validate
        Assert(pThis->m_pFindFolder);

        // Get the Folder Type
        IF_FAILEXIT(hr = pThis->m_pFindFolder->GetMessageFolderType(pRow->Message.idMessage, &tyFolder));

        // Get the State
        if (FOLDER_NEWS == tyFolder)
        {
            // Set the State
            FLAGSET(pState->dwState, SELECTION_STATE_DELETABLE);
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadGetIdList
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadGetIdList(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEIDLIST pList=(LPMESSAGEIDLIST)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadGetIdList");

    // Grow the Id List
    IF_FAILEXIT(hr = pThis->_GrowIdList(pList, 1));

    // Insert Id
    pList->prgidMsg[pList->cMsgs++] = pRow->Message.idMessage;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadGetState
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadGetState(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    LPGETTHREADSTATE pGetState = (LPGETTHREADSTATE)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadGetState");

    // Children
    pGetState->cChildren++;

    // Is Unread
    if (0 != (pRow->Message.dwFlags & pGetState->dwFlags))
        pGetState->cHasFlags++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadClearState
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadClearState(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Trace
    TraceCall("CMessageTable::_WalkThreadClearState");

    // Clear State
    pRow->dwState = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadIsFromMe
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadIsFromMe(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    LPTHREADISFROMME pIsFromMe = (LPTHREADISFROMME)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadIsFromMe");

    // m_pszEmail or pszEmailFrom is null
    if (NULL == pRow->Message.pszEmailFrom)
        return(S_OK);

    // Compare
    if (pThis->m_pszEmail && 0 == lstrcmpi(pThis->m_pszEmail, pRow->Message.pszEmailFrom))
    {
        // This thread is from me
        pIsFromMe->fResult = TRUE;

        // Set the Row
        pIsFromMe->pRow = pRow;

        // Override the highlight
        pRow->Message.wHighlight = pThis->m_clrWatched;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_WalkThreadHide
//--------------------------------------------------------------------------
HRESULT CMessageTable::_WalkThreadHide(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie)
{
    // Locals
    LPTHREADHIDE pHide = (LPTHREADHIDE)dwCookie;

    // Trace
    TraceCall("CMessageTable::_WalkThreadHide");

    // Hide this row
    pThis->_HideRow(pRow, pHide->fNotify);

    // If not filtered
    pThis->_AdjustUnreadCount(pRow, -1);

    // Mark Row as Filtered
    pRow->fFiltered = TRUE;

    // Increment m_cFiltered
    pThis->m_cFiltered++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageTable::_GrowIdList
//--------------------------------------------------------------------------
HRESULT CMessageTable::_GrowIdList(LPMESSAGEIDLIST pList, DWORD cNeeded)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CMessageTable::_GrowIdList");

    // Allocate
    if (pList->cMsgs + cNeeded > pList->cAllocated)
    {
        // Compute cGrow
        DWORD cGrow = max(32, cNeeded);

        // Realloc
        IF_FAILEXIT(hr = HrRealloc((LPVOID *)&pList->prgidMsg, sizeof(MESSAGEID) * (pList->cAllocated + cGrow)));

        // Increment dwREserved
        pList->cAllocated += cGrow;
    }
exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// EnumerateRefs
// --------------------------------------------------------------------------------
HRESULT EnumerateRefs(LPCSTR pszReferences, DWORD_PTR dwCookie, PFNENUMREFS pfnEnumRefs)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cchRefs;
    LPSTR           pszRefs;
    LPSTR           pszFree=NULL;
    LPSTR           pszT;
    BOOL            fDone=FALSE;
    CHAR            szBuffer[1024];

    // Trace
    TraceCall("EnumerateRefs");

    // If the message has a references line
    if (NULL == pszReferences || '\0' == *pszReferences)
        return(S_OK);

    // Get Length
    cchRefs = lstrlen(pszReferences);

    // Use Buffer ?
    if (cchRefs + 1 <= ARRAYSIZE(szBuffer))
        pszRefs = szBuffer;

    // Otherwise, duplicate it
    else
    {
        // Allocate Memory
        IF_NULLEXIT(pszFree = (LPSTR)g_pMalloc->Alloc(cchRefs + 1));

        // Set pszRefs
        pszRefs = pszFree;
    }

    // Copy It
    CopyMemory(pszRefs, pszReferences, cchRefs + 1);

    // Set pszT
    pszT = (LPSTR)(pszRefs + cchRefs - 1);

    // Strip
    while (pszT > pszRefs && *pszT != '>')
        *pszT-- = '\0';

    // We have have ids
    while (pszT >= pszRefs)
    {
        // Start of message Id ?
        if (*pszT == '<')
        {
            // Callback function
            (*pfnEnumRefs)(pszT, dwCookie, &fDone);

            // Done
            if (fDone)
                goto exit;

            // Strip
            while (pszT > pszRefs && *pszT != '>')
                *pszT-- = '\0';
        }

        // Decrement
        pszT--;
    }

exit:
    // Cleanup
    SafeMemFree(pszFree);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageTable::GetRelativeRow
//--------------------------------------------------------------------------
STDMETHODIMP CMessageTable::IsChild(ROWINDEX iRowParent, ROWINDEX iRowChild)
{
    // Locals
    HRESULT             hr=S_FALSE;
    LPROWINFO           pRow;
    LPROWINFO           pRowParent;

    // Trace
    TraceCall("CMessageTable::IsChild");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Failure
    IF_FAILEXIT(hr = _GetRowFromIndex(iRowChild, &pRow));
    IF_FAILEXIT(hr = _GetRowFromIndex(iRowParent, &pRowParent));

    // Loop through all the parents of the child row to see if we find the
    // specified parent row.
    while (pRow->pParent)
    {
        if (pRow->pParent == pRowParent)
        {
            hr = S_OK;
            goto exit;
        }

        pRow = pRow->pParent;
    }
    hr = S_FALSE;

exit:
    return (hr);
}

STDMETHODIMP CMessageTable::GetAdBarUrl(IStoreCallback *pCallback)
{
    HRESULT     hr = S_OK;

    // Trace
    TraceCall("CMessageTable::GetAdBarUrl");

    // Validate State
    if (!IsInitialized(this))
        return(TraceResult(E_UNEXPECTED));

    // Tell the Folder to Synch
    IF_FAILEXIT(hr = m_pFolder->GetAdBarUrl(pCallback));

exit:
    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\locstore.h ===
// --------------------------------------------------------------------------------
// Locstore.h
// --------------------------------------------------------------------------------
#ifndef __LOCSTORE_H
#define __LOCSTORE_H

//--------------------------------------------------------------------------
// CLocalStore
//--------------------------------------------------------------------------
class CLocalStore : public IMessageServer
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CLocalStore(void);
    ~CLocalStore(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IStoreSink Members
    //----------------------------------------------------------------------
    STDMETHODIMP SetCurrentFolder(IMessageStore *pStore, IMessageFolder *pFolder, FOLDERID idFolder) { return S_OK; }
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback, HWND hwndUIParent) { return E_NOTIMPL; }
    STDMETHODIMP SetConnectionState(CONNECT_STATE tyConnect) { return E_NOTIMPL; }
    STDMETHODIMP SynchronizeFolder(SYNCFOLDERFLAGS dwFlags) { return E_NOTIMPL; }
    STDMETHODIMP GetMessage(MESSAGEID idMessage, IStream *pStream, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream *pStream, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP SynchronizeStore(FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetFolderCounts( FOLDERID idFolder,IStoreCallback *pCallback) { return E_NOTIMPL; }

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;         // Reference Counting
    IDatabaseTable *m_pTable;       // Database table
    FOLDERID        m_idFolder;     // Folder Id We are looking at
    IMessageStore  *m_pStore;       // My Store Object
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateLocalStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);

#endif // __LOCSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\msgfldr.h ===
//--------------------------------------------------------------------------
// MsgFldr.h
//--------------------------------------------------------------------------
#ifndef __MSGFLDR_H
#define __MSGFLDR_H

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "dbimpl.h"

//--------------------------------------------------------------------------
// ONLOCKINFO
//--------------------------------------------------------------------------
typedef struct tagONLOCKINFO {
    DWORD           cLocked;
    LONG            lMsgs;
    LONG            lUnread;
    LONG            lWatchedUnread;
    LONG            lWatched;
} ONLOCKINFO, *LPONLOCKINFO;

//--------------------------------------------------------------------------
// FOLDERSTATE
//--------------------------------------------------------------------------
typedef DWORD FOLDERSTATE;
#define FOLDER_STATE_RELEASEDB          0x00000001
#define FOLDER_STATE_CANCEL             0x00000002

//--------------------------------------------------------------------------
// CMessageFolder
//--------------------------------------------------------------------------
class CMessageFolder : public IMessageFolder, 
                       public IDatabaseExtension,
                       public IOperationCancel,
                       public IServiceProvider
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CMessageFolder(void);
    ~CMessageFolder(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageFolder Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, FOLDERID idFolder);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetFolderId(LPFOLDERID pidFolder);
    STDMETHODIMP GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder);
    STDMETHODIMP Close(void) { return(S_OK); }
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback) { return(S_OK); }
    STDMETHODIMP OpenMessage(MESSAGEID idMessage, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP SaveMessage(LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageStream(MESSAGEID idMessage, IStream *pStream);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPRESULTLIST pResults, IStoreCallback *pCallback); 
    STDMETHODIMP ConnectionAddRef(void) { return(S_OK); }
    STDMETHODIMP ConnectionRelease(void) { return(S_OK); }
    STDMETHODIMP ResetFolderCounts(DWORD cMessages, DWORD cUnread, DWORD cWatchedUnread, DWORD cWatched);
    STDMETHODIMP IsWatched(LPCSTR pszReferences, LPCSTR pszSubject);
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback) { return E_NOTIMPL; };

    //----------------------------------------------------------------------
    // IMessageFolder::GetDatabase Members
    //----------------------------------------------------------------------
    STDMETHODIMP GetDatabase(IDatabase **ppDB) { 
        *ppDB = m_pDB; 
        (*ppDB)->AddRef(); 
        return(S_OK); 
    }

    //----------------------------------------------------------------------
    // IDatabaseExtension Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IDatabase *pDB);
    STDMETHODIMP OnLock(void);
    STDMETHODIMP OnUnlock(void);
    STDMETHODIMP OnRecordInsert(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnRecordUpdate(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew);
    STDMETHODIMP OnRecordDelete(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnExecuteMethod(METHODID idMethod, LPVOID pBinding, LPDWORD pdwResult);

    //----------------------------------------------------------------------
    // IServiceProvider 
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IOperationCancel Members
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel) { FLAGSET(m_dwState, FOLDER_STATE_CANCEL); return(S_OK); }

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(TRUE, m_pDB);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _FixupMessageCharset(IMimeMessage *pMessage, CODEPAGEID cpCurrent);
    HRESULT _GetMsgInfoFromMessage(IMimeMessage *pMessage, LPMESSAGEINFO pInfo);
    HRESULT _GetMsgInfoFromPropertySet(IMimePropertySet *pPropertySet, LPMESSAGEINFO pInfo);
    HRESULT _FreeMsgInfoData(LPMESSAGEINFO pInfo);
    HRESULT _SetMessageStream(LPMESSAGEINFO pInfo, BOOL fUpdateRecord, IStream *pStream);
    HRESULT _InitializeWatchIgnoreIndex(void);
    HRESULT _GetWatchIgnoreParentFlags(LPCSTR pszReferences, LPCSTR pszSubject, MESSAGEFLAGS *pdwFlags);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;                 // Ref Count
    ONLOCKINFO          m_OnLock;               // OnLock information
    FOLDERTYPE          m_tyFolder;             // Folder Type
    SPECIALFOLDER       m_tySpecial;            // Am I a Special Folder ?
    FOLDERID            m_idFolder;             // Folder Id
    FOLDERSTATE         m_dwState;              // Folder State
    IDatabase          *m_pDB;                  // Database Table
    IMessageStore      *m_pStore;               // Store Object
};

//--------------------------------------------------------------------------
// CreateMsgDbExtension
//--------------------------------------------------------------------------
HRESULT CreateMsgDbExtension(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT WalkThreadAdjustFlags(IDatabase *pDB, LPMESSAGEINFO pMessage, 
    BOOL fSubThreads, DWORD cIndent, DWORD_PTR dwCookie, BOOL *pfDoSubThreads);

#endif // __MSGFLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\msgtable.h ===
//--------------------------------------------------------------------------
// MsgTable.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decl.
//--------------------------------------------------------------------------
class CFindFolder;
class CMessageTable;

//--------------------------------------------------------------------------
// SafeReleaseRow
//--------------------------------------------------------------------------
#define SafeReleaseRow(_pTable, _pMessage) \
    if (_pMessage) { \
        _pTable->ReleaseRow(_pMessage); \
        _pMessage = NULL; \
    }

//--------------------------------------------------------------------------
// WALKTHREADFLAGS
//--------------------------------------------------------------------------
typedef DWORD WALKTHREADFLAGS;
#define WALK_THREAD_CURRENT      0x00000001
#define WALK_THREAD_BOTTOMUP     0x00000020

//--------------------------------------------------------------------------
// SORTCHANGEINFO
//--------------------------------------------------------------------------
typedef struct tagSORTCHANGEINFO {
    BYTE                fSort;
    BYTE                fThread;
    BYTE                fFilter;
    BYTE                fExpand;
} SORTCHANGEINFO, *LPSORTCHANGEINFO;

//--------------------------------------------------------------------------
// ROWINFO
//--------------------------------------------------------------------------
typedef struct tagROWINFO *LPROWINFO;
typedef struct tagROWINFO {
    BYTE                cRefs;
    ROWSTATE            dwState;
    LPROWINFO           pParent;
    LPROWINFO           pChild;
    LPROWINFO           pSibling;
    WORD                wHighlight;
    unsigned            fExpanded : 1;  // A thread parent that is expanded
    unsigned            fVisible  : 1;  // Is displayed in the m_prgpView index
    unsigned            fFiltered : 1;  // Filtered and won't be displayed until filter changes
    unsigned            fHidden   : 1;  // Hidden, but if row is changed it may become visible.
    unsigned            fDelayed  : 1;  // Delayed Insert
    MESSAGEINFO         Message;
} ROWINFO;

//--------------------------------------------------------------------------
// NOTIFYQUEUE
//--------------------------------------------------------------------------
typedef struct tagNOTIFYQUEUE {
    BOOL                fClean;
    TRANSACTIONTYPE     tyCurrent;
    ROWINDEX            iRowMin;
    ROWINDEX            iRowMax;
    DWORD               cUpdate;
    DWORD               cAllocated;
    DWORD               cRows;
    BYTE                fIsExpandCollapse;
    LPROWINDEX          prgiRow;
} NOTIFYQUEUE, *LPNOTIFYQUEUE;

//--------------------------------------------------------------------------
// PFWALKTHREADCALLBACK
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFWALKTHREADCALLBACK)(CMessageTable *pThis, 
    LPROWINFO pRow, DWORD_PTR dwCookie);

//--------------------------------------------------------------------------
// PFNENUMREFS
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNENUMREFS)(LPCSTR pszMessageId, DWORD_PTR dwCookie,
    BOOL *pfDone);

//--------------------------------------------------------------------------
// CMessageTable
//--------------------------------------------------------------------------
class CMessageTable : public IMessageTable,
                      public IDatabaseNotify,
                      public IServiceProvider,
                      public IOperationCancel

{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CMessageTable(void);
    ~CMessageTable(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageTable Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(FOLDERID idFolder, IMessageServer *pServer, BOOL fFindTable, IStoreCallback *pCallback);
    STDMETHODIMP StartFind(LPFINDINFO pCriteria, IStoreCallback *pCallback);
    STDMETHODIMP SetOwner(IStoreCallback *pDefaultCallback);
    STDMETHODIMP Close(void);
    STDMETHODIMP Synchronize(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP OnSynchronizeComplete(void);
    STDMETHODIMP GetCount(GETCOUNTTYPE tyCount, DWORD *pdwCount);
    STDMETHODIMP GetRow(ROWINDEX iRow, LPMESSAGEINFO *ppData);
    STDMETHODIMP ReleaseRow(LPMESSAGEINFO pInfo);
    STDMETHODIMP GetRelativeRow(ROWINDEX iRow, RELATIVEROWTYPE tyRelative, LPROWINDEX piRelative);
    STDMETHODIMP GetIndentLevel(ROWINDEX iRow, LPDWORD pcIndent);            
    STDMETHODIMP Mark(LPROWINDEX prgiView, DWORD cRows, APPLYCHILDRENTYPE tyApply, MARK_TYPE mark, IStoreCallback *pCallback);
    STDMETHODIMP GetSortInfo(LPFOLDERSORTINFO pSortInfo);
    STDMETHODIMP SetSortInfo(LPFOLDERSORTINFO pSortInfo, IStoreCallback *pCallback);
    STDMETHODIMP GetLanguage(ROWINDEX iRow, LPDWORD pdwCodePage);
    STDMETHODIMP SetLanguage(DWORD cRows, LPROWINDEX prgiRow, DWORD dwCodePage);
    STDMETHODIMP GetNextRow(ROWINDEX iCurrentRow, GETNEXTTYPE tyDirection, ROWMESSAGETYPE tyMessage, GETNEXTFLAGS dwFlags, LPROWINDEX piNewRow);
    STDMETHODIMP GetRowState(ROWINDEX iRow, ROWSTATE dwStateMask, ROWSTATE *pdwState);
    STDMETHODIMP GetSelectionState(DWORD cRows, LPROWINDEX prgiView, SELECTIONSTATE dwMask, BOOL fIncludeChildren, SELECTIONSTATE *pdwState);
    STDMETHODIMP Expand(ROWINDEX iRow);
    STDMETHODIMP Collapse(ROWINDEX iRow);
    STDMETHODIMP OpenMessage(ROWINDEX iRow, OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, IStoreCallback *pCallback);
    STDMETHODIMP GetRowMessageId(ROWINDEX iRow, LPMESSAGEID pidMessage);
    STDMETHODIMP GetRowIndex(MESSAGEID idMessage, LPROWINDEX piView);
    STDMETHODIMP DeleteRows(DELETEMESSAGEFLAGS dwFlags, DWORD cRows, LPROWINDEX prgiView, BOOL fIncludeChildren, IStoreCallback *pCallback);
    STDMETHODIMP CopyRows(FOLDERID idFolder, COPYMESSAGEFLAGS dwOptions, DWORD cRows, LPROWINDEX prgiView, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);
    STDMETHODIMP RegisterNotify(REGISTERNOTIFYFLAGS dwFlags, IMessageTableNotify *pNotify);
    STDMETHODIMP UnregisterNotify(IMessageTableNotify *pNotify);
    STDMETHODIMP FindNextRow(ROWINDEX iStartRow, LPCTSTR pszFindString, FINDNEXTFLAGS dwFlags, BOOL fIncludeBody, ROWINDEX *piNextRow, BOOL *pfWrapped);
    STDMETHODIMP GetRowFolderId(ROWINDEX iRow, LPFOLDERID pidFolder);
    STDMETHODIMP GetMessageIdList(BOOL fRootsOnly, DWORD cRows, LPROWINDEX prgiView, LPMESSAGEIDLIST pIdList);
    STDMETHODIMP ConnectionAddRef(void);
    STDMETHODIMP ConnectionRelease(void);
    STDMETHODIMP IsChild(ROWINDEX iRowParent, ROWINDEX iRowChild);
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IDatabaseNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    //----------------------------------------------------------------------
    // IServiceProvider 
    //----------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    //----------------------------------------------------------------------
    // IOperationCancel
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel) { return(S_OK); }

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _CreateRow(LPMESSAGEINFO pMessage, LPROWINFO *ppRow);
    HRESULT _InsertRowIntoThread(LPROWINFO pRow, BOOL fNotify);
    HRESULT _DeleteRowFromThread(LPROWINFO pRow, BOOL fNotify);
    HRESULT _FreeTable(void);
    HRESULT _FreeTableElements(void);
    HRESULT _BuildTable(IStoreCallback *pCallback);
    HRESULT _WalkMessageThread(LPROWINFO pRow, WALKTHREADFLAGS dwFlags, DWORD_PTR dwCookie, PFWALKTHREADCALLBACK pfnCallback);
    HRESULT _RowTableInsert(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage);
    HRESULT _RowTableDelete(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage);
    HRESULT _RowTableUpdate(ROWORDINAL iOrdinal, LPMESSAGEINFO pMessage);
    HRESULT _GetRowFromIndex(ROWINDEX iRow, LPROWINFO *ppRow);
    HRESULT _LinkRowIntoThread(LPROWINFO pParent, LPROWINFO pRow, BOOL fNotify);
    HRESULT _GrowIdList(LPMESSAGEIDLIST pList, DWORD cNeeded);
    HRESULT _ExpandThread(ROWINDEX iRow, BOOL fNotify, BOOL fReExpand);
    HRESULT _ExpandSingleThread(LPROWINDEX piCurrent, LPROWINFO pParent, BOOL fNotify, BOOL fForceExpand);
    HRESULT _CollapseThread(ROWINDEX iRow, BOOL fNotify);
    HRESULT _CollapseSingleThread(LPROWINDEX piCurrent, LPROWINFO pParent, BOOL fNotify);
    HRESULT _InsertIntoView(ROWINDEX iRow, LPROWINFO pRow);
    HRESULT _DeleteFromView(ROWINDEX iRow, LPROWINFO pRow);
    HRESULT _GetRowFromOrdinal(ROWORDINAL iOrdinal, LPMESSAGEINFO pExpected, LPROWINFO *ppRow);
    HRESULT _AdjustUnreadCount(LPROWINFO pRow, LONG lCount);
    HRESULT _GetThreadIndexRange(LPROWINFO pRow, BOOL fClearState, LPROWINDEX piMin, LPROWINDEX piMax);
    HRESULT _IsThreadImportance(LPROWINFO pRow, MESSAGEFLAGS dwFlag, ROWSTATE dwState, ROWSTATE *pdwState);
    HRESULT _QueueNotification(TRANSACTIONTYPE tyTransaction, ROWINDEX iRowMin, ROWINDEX iRowMax, BOOL fIsExpandCollapse=FALSE);
    HRESULT _FlushNotificationQueue(BOOL fFinal);
    HRESULT _GetSortChangeInfo(LPFOLDERSORTINFO pSortInfo, LPFOLDERUSERDATA pUserData, LPSORTCHANGEINFO pChange);
    HRESULT _SortThreadFilterTable(LPSORTCHANGEINFO pChange, BOOL fApplyFilter);
    HRESULT _SortAndThreadTable(BOOL fApplyFilter);
    HRESULT _HideRow(LPROWINFO pRow, BOOL fNotify);
    HRESULT _ShowRow(LPROWINFO pRow);
    HRESULT _PruneToReplies(void);
    HRESULT _FindThreadParentByRef(LPCSTR pszReferences, LPROWINFO *ppParent);
    HRESULT _RefreshFilter(void);

    //----------------------------------------------------------------------
    // Utilities
    //----------------------------------------------------------------------
    VOID        _SortView(LONG left, LONG right);
    LONG        _CompareMessages(LPMESSAGEINFO pMsg1, LPMESSAGEINFO pMsg2);
    BOOL        _FIsFiltered(LPROWINFO pRow);
    BOOL        _FIsHidden(LPROWINFO pRow);
    LPROWINFO   _PGetThreadRoot(LPROWINFO pRow);

    //----------------------------------------------------------------------
    // Friends
    //----------------------------------------------------------------------
    static HRESULT _WalkThreadGetSelectionState(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadGetIdList(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadGetState(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadClearState(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadIsFromMe(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);
    static HRESULT _WalkThreadHide(CMessageTable *pThis, LPROWINFO pRow, DWORD_PTR dwCookie);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                 m_cRef;                // Reference Counting
    BOOL                 m_fSynching;           // Are we synching a folder ?
    DWORD                m_cAllocated;          // Allocated elements in m_prgRow and m_prgiView
    DWORD                m_cRows;               // Rows...
    DWORD                m_cView;               // Number of items in the listview
    DWORD                m_cFiltered;           // Number of rows that were filtered
    DWORD                m_cUnread;             // Number of unread rows in m_prgpRow
    LPROWINFO           *m_prgpRow;             // Array of Pointers to Rows
    LPROWINFO           *m_prgpView;            // Current View
    FOLDERSORTINFO       m_SortInfo;            // Folder Sort Info
    IMessageFolder      *m_pFolder;             // Base Folder
    IDatabase           *m_pDB;                 // The Database
    CFindFolder         *m_pFindFolder;         // Find Folder
    IMessageTableNotify *m_pNotify;             // usually the message list
    BYTE                 m_fRelNotify;          // Release m_pNotify?
    IDatabaseQuery      *m_pQuery;              // Query Object
    NOTIFYQUEUE          m_Notify;              // Notify Queue
    FOLDERINFO           m_Folder;              // Folder Information
    DWORD                m_cDelayed;            // Number of news messages not insert into view
    BYTE                 m_fRegistered;         // Registered for Notifications
    BYTE                 m_fLoaded;             // The first load has completed.
    WORD                 m_clrWatched;          // Watched Color
    LPSTR                m_pszEmail;            // Email Address to use for show replies filter
    IHashTable          *m_pThreadMsgId;        // Message-ID Hash Table for Threading
    IHashTable          *m_pThreadSubject;      // Message-ID Hash Table for Threading
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT EnumerateRefs(LPCSTR pszReferences, DWORD_PTR dwCookie, PFNENUMREFS pfnEnumRefs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\msgfldr.cpp ===
//--------------------------------------------------------------------------
// MsgFldr.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "store.h"
#include "instance.h"
#include "msgfldr.h"
#include "secutil.h"
#include "storutil.h"
#include "shared.h"
#include "flagconv.h"
#include "qstrcmpi.h"
#include "xpcomm.h"
#include "msgtable.h"
#include "shlwapip.h" 
#include <oerules.h>
#include <ruleutil.h>

//--------------------------------------------------------------------------
// Watch/Ignore Index Filter
//--------------------------------------------------------------------------
static const char c_szWatchIgnoreFilter[] = "((MSGCOL_FLAGS & ARF_WATCH) != 0 || (MSGCOL_FLAGS & ARF_IGNORE) != 0)";

//--------------------------------------------------------------------------
// GETWATCHIGNOREPARENT
//--------------------------------------------------------------------------
typedef struct tagGETWATCHIGNOREPARENT {
    IDatabase      *pDatabase;
    HRESULT         hrResult;
    MESSAGEINFO     Parent;
} GETWATCHIGNOREPARENT, *LPGETWATCHIGNOREPARENT;

//--------------------------------------------------------------------------
// EnumRefsGetWatchIgnoreParent
//--------------------------------------------------------------------------
HRESULT EnumRefsGetWatchIgnoreParent(LPCSTR pszMessageId, DWORD_PTR dwCookie,
    BOOL *pfDone)
{
    // Locals
    LPGETWATCHIGNOREPARENT pGetParent = (LPGETWATCHIGNOREPARENT)dwCookie;

    // Trace
    TraceCall("EnumRefsGetWatchIgnoreParent");

    // Set MessageId
    pGetParent->Parent.pszMessageId = (LPSTR)pszMessageId;

    // Find pszMessageId in the IINDEX_WATCHIGNORE Index
    pGetParent->hrResult = pGetParent->pDatabase->FindRecord(IINDEX_WATCHIGNORE, 1, &pGetParent->Parent, NULL);

    // Done
    if (DB_S_FOUND == pGetParent->hrResult)
    {
        // We are done
        *pfDone = TRUE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CreateMsgDbExtension
//--------------------------------------------------------------------------
HRESULT CreateMsgDbExtension(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateMsgDbExtension");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageFolder *pNew = new CMessageFolder();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IDatabaseExtension *);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::CMessageFolder
//--------------------------------------------------------------------------
CMessageFolder::CMessageFolder(void)
{
    TraceCall("CMessageFolder::CMessageFolder");
#ifndef _WIN64
    Assert(1560 == sizeof(FOLDERUSERDATA));
#endif // WIN64
    m_cRef = 1;
    m_pStore = NULL;
    m_pDB = NULL;
    m_tyFolder = FOLDER_INVALID;
    m_tySpecial = FOLDER_NOTSPECIAL;
    m_idFolder = FOLDERID_INVALID;
    m_dwState = 0;
    ZeroMemory(&m_OnLock, sizeof(ONLOCKINFO));
}

//--------------------------------------------------------------------------
// CMessageFolder::~CMessageFolder
//--------------------------------------------------------------------------
CMessageFolder::~CMessageFolder(void)
{
    // Trace
    TraceCall("CMessageFolder::~CMessageFolder");

    // Release the Store
    SafeRelease(m_pStore);

    // Release the Database Table
    if (ISFLAGSET(m_dwState, FOLDER_STATE_RELEASEDB) && m_pDB)
    {
        m_pDB->Release();
        m_pDB = NULL;
    }
}

//--------------------------------------------------------------------------
// CMessageFolder::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CMessageFolder::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageFolder *)this;
    else if (IID_IMessageFolder == riid)
        *ppv = (IMessageFolder *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IDatabaseExtension == riid)
        *ppv = (IDatabaseExtension *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageFolder::AddRef(void)
{
    TraceCall("CMessageFolder::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CMessageFolder::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageFolder::Release(void)
{
    TraceCall("CMessageFolder::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CMessageFolder::QueryService
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::QueryService(REFGUID guidService, REFIID riid, 
    LPVOID *ppvObject)
{
    // Trace
    TraceCall("CMessageFolder::QueryService");

    // Just a Query Interface
    return(QueryInterface(riid, ppvObject));
}

//--------------------------------------------------------------------------
// CMessageFolder::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::Initialize(IMessageStore *pStore, IMessageServer *pServer,
    OPENFOLDERFLAGS dwFlags, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szDirectory[MAX_PATH];
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    FOLDERINFO      Folder={0};
    FOLDERUSERDATA  UserData={0};

    // Trace
    TraceCall("CMessageFolder::Initialize");

    // Invalid Args
    if (NULL == pStore)
        return TraceResult(E_INVALIDARG);

    // Save the FolderId
    m_idFolder = idFolder;

    // Save pStore (This must happen before m_pDB->Open happens)
    m_pStore = pStore;
    m_pStore->AddRef();

    // Find the Folder Information
    IF_FAILEXIT(hr = pStore->GetFolderInfo(idFolder, &Folder));

    // Make Folder File Path
    IF_FAILEXIT(hr = pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory)));

    // No Folder File Yet ?
    if (FIsEmptyA(Folder.pszFile))
    {
        // Don't Create
        if (ISFLAGSET(dwFlags, OPEN_FOLDER_NOCREATE))
        {
            hr = STORE_E_FILENOEXIST;
            goto exit;
        }

        // Build Friendly Name
        IF_FAILEXIT(hr = BuildFriendlyFolderFileName(szDirectory, &Folder, szFilePath, ARRAYSIZE(szFilePath), NULL, NULL));

        // Get the new pszFile...
        Folder.pszFile = PathFindFileName(szFilePath);

        // Update the Record
        IF_FAILEXIT(hr = pStore->UpdateRecord(&Folder));
    }

    // Otherwise, build the filepath
    else
    {
        // Make File Path
        IF_FAILEXIT(hr = MakeFilePath(szDirectory, Folder.pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));
    }

    // If the file doesn't exist...
    if (FALSE == PathFileExists(szFilePath))
    {
        // Reset the Folder Counts...
        Folder.cMessages = 0;
        Folder.dwClientHigh = 0;
        Folder.dwClientLow = 0;
        Folder.cUnread = 0;
        Folder.cWatched = 0;
        Folder.cWatchedUnread = 0;
        Folder.dwServerHigh = 0;
        Folder.dwServerLow = 0;
        Folder.dwServerCount = 0;
        Folder.dwStatusMsgDelta = 0;
        Folder.dwStatusUnreadDelta = 0;
        Folder.dwNotDownloaded = 0;
        Folder.dwClientWatchedHigh = 0;
        Folder.Requested.cbSize = 0;
        Folder.Requested.pBlobData = NULL;
        Folder.Read.cbSize = 0;
        Folder.Read.pBlobData = NULL;

        // Update the Record
        IF_FAILEXIT(hr = pStore->UpdateRecord(&Folder));

        // No Create ?
        if (ISFLAGSET(dwFlags, OPEN_FOLDER_NOCREATE))
        {
            hr = STORE_E_FILENOEXIST;
            goto exit;
        }
    }

    // Save Special Folder Type
    m_tySpecial = Folder.tySpecial;

    // Save the Folder Type
    m_tyFolder = Folder.tyFolder;

    // Create a Database Table
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NOADDREFEXT, &g_MessageTableSchema, (IDatabaseExtension *)this, &m_pDB));

    // Release m_pDB
    FLAGSET(m_dwState, FOLDER_STATE_RELEASEDB);

    // Get the User Data
    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // May not have been initialized yet ?
    if (FALSE == UserData.fInitialized)
    {
        // Locals
        FOLDERINFO  Server;

        // Get the Server Info
        IF_FAILEXIT(hr = GetFolderServer(Folder.idParent, &Server));

        // Its Initialized
        UserData.fInitialized = TRUE;

        // Configure the Folder UserData
        UserData.tyFolder = Folder.tyFolder;

        // Is Special Folder ?
        UserData.tySpecial = Folder.tySpecial;

        // Copy the Account Id
        lstrcpyn(UserData.szAcctId, Server.pszAccountId, ARRAYSIZE(UserData.szAcctId));

        // Free
        pStore->FreeRecord(&Server);

        // Store the Folder Name
        lstrcpyn(UserData.szFolder, Folder.pszName, ARRAYSIZE(UserData.szFolder));

        // Set Folder Id
        UserData.idFolder = Folder.idFolder;

        // Sort Ascending
        UserData.fAscending = FALSE;

        // No Threading
        UserData.fThreaded = FALSE;

        // Base Filter
        UserData.ridFilter = (RULEID) IntToPtr(DwGetOption(OPT_VIEW_GLOBAL));
        if ((RULEID_INVALID == UserData.ridFilter) || ((RULEID_VIEW_DOWNLOADED == UserData.ridFilter) && (FOLDER_LOCAL == m_tyFolder)))
            UserData.ridFilter = RULEID_VIEW_ALL;

        // Hide Deleted Messages
        UserData.fShowDeleted = FALSE;

        // Hide Deleted Messages
        UserData.fShowReplies = FALSE;

        // Set Sort Order
        UserData.idSort = COLUMN_RECEIVED;

        // New thread model
        UserData.fNoIndexes = TRUE;

        // Set the User Data
        IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));
    }

    // Otherwise, fixup cWatchedUnread ?
    else
    {
        // No Indexes
        if (FALSE == UserData.fNoIndexes)
        {
            // Index Ordinals
            const INDEXORDINAL IINDEX_VIEW       = 1;
            const INDEXORDINAL IINDEX_MESSAGEID  = 3;
            const INDEXORDINAL IINDEX_SUBJECT    = 4;
            const INDEXORDINAL IINDEX_THREADS    = 5;

            // Delete the indexes that I don't user anymore
            m_pDB->DeleteIndex(IINDEX_VIEW);
            m_pDB->DeleteIndex(IINDEX_MESSAGEID);
            m_pDB->DeleteIndex(IINDEX_SUBJECT);
            m_pDB->DeleteIndex(IINDEX_THREADS);

            // Reset fNoIndexes
            UserData.fNoIndexes = TRUE;

            // Set the User Data
            IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));
        }
    }

    // Initialize Watch/Ignore Index
    _InitializeWatchIgnoreIndex();

exit:
    // Cleanup
    pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::IsWatched
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::IsWatched(LPCSTR pszReferences, 
    LPCSTR pszSubject)
{
    // Locals
    MESSAGEFLAGS dwFlags;

    // Trace
    TraceCall("CMessageFolder::IsWatched");

    // Get Flags
    if (DB_S_FOUND == _GetWatchIgnoreParentFlags(pszReferences, pszSubject, &dwFlags))
    {
        // Watched
        if (ISFLAGSET(dwFlags, ARF_WATCH))
            return(S_OK);
    }

    // Not Watched
    return(S_FALSE);
}

//--------------------------------------------------------------------------
// CMessageFolder::_GetWatchIgnoreParentFlags
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_GetWatchIgnoreParentFlags(LPCSTR pszReferences, 
    LPCSTR pszSubject, MESSAGEFLAGS *pdwFlags)
{
    // Locals
    GETWATCHIGNOREPARENT GetParent;

    // Trace
    TraceCall("CMessageFolder::_GetWatchIgnoreParentFlags");

    // Init hrResult...
    GetParent.pDatabase = m_pDB;
    GetParent.hrResult = DB_S_NOTFOUND;

    // EnumerateReferences
    if (SUCCEEDED(EnumerateRefs(pszReferences, (DWORD_PTR)&GetParent, EnumRefsGetWatchIgnoreParent)))
    {
        // If Found
        if (DB_S_FOUND == GetParent.hrResult)
        {
            // Return the Flags
            *pdwFlags = GetParent.Parent.dwFlags;

            // Free It
            m_pDB->FreeRecord(&GetParent.Parent);
        }
    }

    // Not Watched
    return(GetParent.hrResult);
}

//--------------------------------------------------------------------------
// CMessageFolder::_InitializeWatchIgnoreIndex
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_InitializeWatchIgnoreIndex(void)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fRebuild=FALSE;
    LPSTR       pszFilter=NULL;
    TABLEINDEX  Index;

    // Trace
    TraceCall("CMessageFolder::_InitializeWatchIgnoreIndex");

    // Reset fRebuild
    fRebuild = FALSE;

    // Create the Watch Ignore Index
    if (FAILED(m_pDB->GetIndexInfo(IINDEX_WATCHIGNORE, &pszFilter, &Index)))
        fRebuild = TRUE;

    // Filter Change ?
    else if (NULL == pszFilter || lstrcmpi(pszFilter, c_szWatchIgnoreFilter) != 0)
        fRebuild = TRUE;

    // Otherwise, the index is different
    else if (S_FALSE == CompareTableIndexes(&Index, &g_WatchIgnoreIndex))
        fRebuild = TRUE;

    // Rebuild It ?
    if (fRebuild)
    {
        // Create the Index
        IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_WATCHIGNORE, c_szWatchIgnoreFilter, &g_WatchIgnoreIndex));
    }

exit:
    // Cleanup
    SafeMemFree(pszFilter);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::GetFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::GetFolderId(LPFOLDERID pidFolder)
{
    // Trace
    TraceCall("CMessageFolder::GetFolderId");

    // Invalid Args
    if (NULL == pidFolder)
        return TraceResult(E_INVALIDARG);

    // Return the FolderId
    *pidFolder = m_idFolder;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::GetMessageFolderId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::GetMessageFolderId(MESSAGEID idMessage, LPFOLDERID pidFolder)
{
    // Trace
    TraceCall("CMessageFolder::GetFolderId");

    // Invalid Args
    if (NULL == pidFolder)
        return TraceResult(E_INVALIDARG);

    // Return the FolderId
    *pidFolder = m_idFolder;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OpenMessage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OpenMessage(MESSAGEID idMessage, 
    OPENMESSAGEFLAGS dwFlags, IMimeMessage **ppMessage, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT          hr=S_OK;
    IMimeMessage    *pMessage=NULL;
    MESSAGEINFO      Message={0};
    PROPVARIANT      Variant;
    IStream         *pStream=NULL;

    // Trace
    TraceCall("CMessageFolder::OpenMessage");

    // Invalid Args
    if (NULL == ppMessage)
        return TraceResult(E_INVALIDARG);

    // Initiailize
    *ppMessage = NULL;

    // Initialize Message with the Id
    Message.idMessage = idMessage;

    // Find the Row
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Does we have it ?
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Has Expired?
    if (Message.dwFlags & ARF_ARTICLE_EXPIRED)
    {
        hr = STORE_E_EXPIRED;
        goto exit;
    }

    // No Body ?
    if (0 == Message.faStream)
    {
        hr = STORE_E_NOBODY;
        goto exit;
    }

    // Create a Message
    IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMessage));

    // Open the Stream from the Store
    IF_FAILEXIT(hr = m_pDB->OpenStream(ACCESS_READ, Message.faStream, &pStream));

    // If there is an offset table
    if (Message.Offsets.cbSize > 0)
    {
        // Create a ByteStream Object
        CByteStream cByteStm(Message.Offsets.pBlobData, Message.Offsets.cbSize);

        // Load the Offset Table Into the message
        pMessage->LoadOffsetTable(&cByteStm);

        // Take the bytes back out of the bytestream object (so that it doesn't try to free it)
        cByteStm.AcquireBytes(&Message.Offsets.cbSize, &Message.Offsets.pBlobData, ACQ_DISPLACE);
    }

    // Load the pMessage
    IF_FAILEXIT(hr = pMessage->Load(pStream));

    // Undo security enhancements if the caller wants us to
    if (!ISFLAGSET(dwFlags, OPEN_MESSAGE_SECURE))
    {
        // Handle Message Security
        IF_FAILEXIT(hr = HandleSecurity(NULL, pMessage));
    }

    // All Props are VT_LPSTR
    Variant.vt = VT_LPSTR;

    // MUD_SERVER
    if (Message.pszServer)
    {
        Variant.pszVal = Message.pszServer;
        pMessage->SetProp(PIDTOSTR(PID_ATT_SERVER), 0, &Variant);
    }

    // PID_ATT_ACCOUNTID
    if (Message.pszAcctId)
    {
        Variant.pszVal = Message.pszAcctId;
        pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &Variant);
    }
    
    // PID_ATT_ACCOUNTID
    if (Message.pszAcctName)
    {
        Variant.pszVal = Message.pszAcctName;
        pMessage->SetProp(STR_ATT_ACCOUNTNAME, 0, &Variant);
    }

    // Otherwise, if there is an account id... lets get the account name
    else if (Message.pszAcctId)
    {
        // Locals
        IImnAccount *pAccount=NULL;
        CHAR szName[CCHMAX_ACCOUNT_NAME];

        // Find an Account
        if (g_pAcctMan && SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Message.pszAcctId, &pAccount)))
        {
            // Get the Account name
            if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szName, ARRAYSIZE(szName))))
            {
                Variant.pszVal = szName;
                pMessage->SetProp(STR_ATT_ACCOUNTNAME, 0, &Variant);
            }

            // Release
            pAccount->Release();
        }
    }

    // PID_ATT_UIDL
    if (Message.pszUidl)
    {
        Variant.pszVal = Message.pszUidl;
        pMessage->SetProp(PIDTOSTR(PID_ATT_UIDL), 0, &Variant);
    }

    // PID_ATT_FORWARDTO
    if (Message.pszForwardTo)
    {
        Variant.pszVal = Message.pszForwardTo;
        pMessage->SetProp(PIDTOSTR(PID_ATT_FORWARDTO), 0, &Variant);
    }

    // PID_HDR_XUNSENT
    if (ISFLAGSET(Message.dwFlags, ARF_UNSENT))
    {
        Variant.pszVal = "1";
        pMessage->SetProp(PIDTOSTR(PID_HDR_XUNSENT), 0, &Variant);
    }

    // Fixup Character Set
    IF_FAILEXIT(hr = _FixupMessageCharset(pMessage, (CODEPAGEID)Message.wLanguage));

    // Clear Dirty
    MimeOleClearDirtyTree(pMessage);

    // Return pMessage
    *ppMessage = pMessage;
    pMessage = NULL;

exit:
    // Free Records
    m_pDB->FreeRecord(&Message);

    // Release
    SafeRelease(pMessage);
    SafeRelease(pStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::SaveMessage
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::SaveMessage(LPMESSAGEID pidMessage, 
    SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, 
    IStream *pStream, IMimeMessage *pMessage, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pSource=NULL;
    CByteStream     cStream;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CMessageFolder::SaveMessage");

    // Invalid Args
    if (NULL == pMessage)
        return TraceResult(E_INVALIDARG);

    if (NULL == pidMessage && !ISFLAGSET(dwOptions, SAVE_MESSAGE_GENID))
        return TraceResult(E_INVALIDARG);

    // Get Message from the Message
    IF_FAILEXIT(hr = _GetMsgInfoFromMessage(pMessage, &Message));

    // Validate or Generate a message id
    if (ISFLAGSET(dwOptions, SAVE_MESSAGE_GENID))
    {
        // Generate Unique Message Id
        IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&Message.idMessage));

        // Return It ?
        if (pidMessage)
            *pidMessage = Message.idMessage;
    }

    // Otherwise, just use idMessage
    else
        Message.idMessage = *pidMessage;

    // Set the Message Flags
    Message.dwFlags |= dwFlags;

    // Do I need to store the message stream...
    if (NULL == pStream)
    {
        // Get the Message Stream From the Message
        IF_FAILEXIT(hr = pMessage->GetMessageSource(&pSource, COMMIT_ONLYIFDIRTY));
    }

    // Otherwise, set pSource
    else
    {
        pSource = pStream;
        pSource->AddRef();
    }

    // Store the Message onto this record
    IF_FAILEXIT(hr = _SetMessageStream(&Message, FALSE, pSource));

    // Create the offset table
    if (SUCCEEDED(pMessage->SaveOffsetTable(&cStream, 0)))
    {
        // pulls the Bytes out of cByteStm
        cStream.AcquireBytes(&Message.Offsets.cbSize, &Message.Offsets.pBlobData, ACQ_DISPLACE);
    }
    
    // Store the Record
    if (FAILED(hr = m_pDB->InsertRecord(&Message)))
    {
        // Trace That
        TraceResult(hr);

        // A failure here means that the stream's refCount has been incremented, but the message does not reference the stream
        SideAssert(SUCCEEDED(m_pDB->DeleteStream(Message.faStream)));

        // Done
        goto exit;
    }
    
exit:
    // Free Allocate Message Properties
    _FreeMsgInfoData(&Message);
    
    // Release Message Source IStream 
    SafeRelease(pSource);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::SetMessageStream
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::SetMessageStream(MESSAGEID idMessage, 
    IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CMessageFolder::SetMessageStream");

    // Invalid Args
    if (NULL == pStream)
        return TraceResult(E_INVALIDARG);

    // Set the MsgId
    Message.idMessage = idMessage;

    // Find the Record
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));

    // Store the Stream
    IF_FAILEXIT(hr = _SetMessageStream(&Message, TRUE, pStream));

exit:
    // Free the Record
    m_pDB->FreeRecord(&Message);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::SetMessageFlags
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::SetMessageFlags(LPMESSAGEIDLIST pList,
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults,
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i=0;
    DWORD           cWatchedUnread=0;
    DWORD           cWatched=0;
    MESSAGEINFO     Message={0};
    HROWSET         hRowset=NULL;
    HLOCK           hLock=NULL;
    MESSAGEFLAGS    dwFlags;
    DWORD           cTotal;

    // Trace
    TraceCall("CMessageFolder::SetMessageFlags");

    // Invalid Args
    if (NULL == pFlags)
        return TraceResult(E_INVALIDARG);

    // Lock Notifications
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

        // Get Count
        IF_FAILEXIT(hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cTotal));
    }

    // Otherwise, set cTotal
    else
        cTotal = pList->cMsgs;

    // User Wants Results ?
    if (pResults)
    {
        // Zero Init
        ZeroMemory(pResults, sizeof(RESULTLIST));

        // Return Results
        IF_NULLEXIT(pResults->prgResult = (LPRESULTINFO)ZeroAllocate(cTotal * sizeof(RESULTINFO)));

        // Set cAllocated
        pResults->cAllocated = pResults->cMsgs = cTotal;
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            Message.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Save Flags
            dwFlags = Message.dwFlags;

            // Remove Flags
            FLAGCLEAR(dwFlags, pFlags->dwRemove);

            // Add Flags
            FLAGSET(dwFlags, pFlags->dwAdd);

            // if there is a body for this msg, then the download flag can't be on
            if (ISFLAGSET(dwFlags, ARF_DOWNLOAD) && ISFLAGSET(dwFlags, ARF_HASBODY))
                FLAGCLEAR(dwFlags, ARF_DOWNLOAD);

            // Update All...or no change
            if (Message.dwFlags != dwFlags)
            {
                // Reset the Flags
                Message.dwFlags = dwFlags;

                // Update the Record
                IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Message));
            }

            // Count Watched Unread
            if (ISFLAGSET(Message.dwFlags, ARF_WATCH))
            {
                // Count Watched
                cWatched++;

                // Is unread
                if (!ISFLAGSET(Message.dwFlags, ARF_READ))
                    cWatchedUnread++;
            }

            // Return Result
            if (pResults)
            {
                // hrResult
                pResults->prgResult[i].hrResult = S_OK;

                // Message Id
                pResults->prgResult[i].idMessage = Message.idMessage;

                // Store Falgs
                pResults->prgResult[i].dwFlags = Message.dwFlags;
            
                // Increment Success
                pResults->cValid++;
            }

            // Free
            m_pDB->FreeRecord(&Message);
        }

        // Otherwise, if pResults
        else if (pResults)
        {
            // Set hr
            pResults->prgResult[i].hrResult = hr;

            // Increment Success
            pResults->cValid++;
        }
    }

exit:
    // Reset Folder Counts ?
    if (NULL == pList && ISFLAGSET(pFlags->dwAdd, ARF_READ))
    {
        // Reset Folder Counts
        ResetFolderCounts(i, 0, cWatchedUnread, cWatched);
    }

    // Unlock the Database
    m_pDB->Unlock(&hLock);

    // Cleanup
    m_pDB->FreeRecord(&Message);
    m_pDB->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMesageFolder::ResetFolderCounts
//--------------------------------------------------------------------------
HRESULT CMessageFolder::ResetFolderCounts(DWORD cMessages, DWORD cUnread,
    DWORD cWatchedUnread, DWORD cWatched)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("CMesageFolder::ResetFolderCounts");

    // Get Folder Info
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_idFolder, &Folder));

    Folder.cMessages = cMessages;
    Folder.cUnread = cUnread;    
    Folder.cWatchedUnread = cWatchedUnread;
    Folder.cWatched = cWatched;
    Folder.dwStatusMsgDelta = 0;
    Folder.dwStatusUnreadDelta = 0;

    // Update the Record
    IF_FAILEXIT(hr = m_pStore->UpdateRecord(&Folder));

exit:
    // Cleanup
    m_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::CopyMessages
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::CopyMessages(IMessageFolder *pDest, 
    COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, 
    LPADJUSTFLAGS pFlags, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     InfoSrc={0};
    MESSAGEINFO     InfoDst;
    DWORD           i;
    FOLDERID        idDstFolder=FOLDERID_INVALID;
    HLOCK           hSrcLock=NULL;
    HLOCK           hDstLock=NULL;

    // Trace
    TraceCall("CMessageFolder::CopyMessages");

    // Invalid Args
    if (NULL == pDest)
        return TraceResult(E_INVALIDARG);

    // Get Destination Folder Id
    IF_FAILEXIT(hr = pDest->GetFolderId(&idDstFolder));

    // Same ?
    if (ISFLAGSET(dwOptions, COPY_MESSAGE_MOVE) && m_idFolder == idDstFolder)
        return(S_OK);

    // Lock current folder
    IF_FAILEXIT(hr = Lock(&hSrcLock));

    // Lock the Dest
    IF_FAILEXIT(hr = pDest->Lock(&hDstLock));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            InfoSrc.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &InfoSrc, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&InfoSrc, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Initialize the InfoDst
            CopyMemory(&InfoDst, &InfoSrc, sizeof(MESSAGEINFO));

            // Kill some fields
            InfoDst.idMessage = 0;

            // Don't Copy the UIDL...
            if (FALSE == ISFLAGSET(dwOptions, COPY_MESSAGE_MOVE))
            {
                // Clear It Out
                InfoDst.pszUidl = NULL;
            }

            // Clear a flag
            FLAGCLEAR(InfoDst.dwFlags, ARF_ENDANGERED);

            // Copy Source Stream
            if (InfoSrc.faStream)
            {
                // Copy the Stream
                IF_FAILEXIT(hr = m_pDB->CopyStream(pDest, InfoSrc.faStream, &InfoDst.faStream));
            }

            // Adjust Flags
            if (pFlags)
            {
                // Remove the Flags
                FLAGCLEAR(InfoDst.dwFlags, pFlags->dwRemove);

                // Flags to Add
                FLAGSET(InfoDst.dwFlags, pFlags->dwAdd);
            }

            // Generate a Message Id
            IF_FAILEXIT(hr = pDest->GenerateId((LPDWORD)&InfoDst.idMessage));

            // Insert the Record
            IF_FAILEXIT(hr = pDest->InsertRecord(&InfoDst));

            // Cleanup
            m_pDB->FreeRecord(&InfoSrc);
        }
    }

    // Delete the Original Array of messages ?
    if (ISFLAGSET(dwOptions, COPY_MESSAGE_MOVE))
    {
        // DeleteMessages
        IF_FAILEXIT(hr = DeleteMessages(DELETE_MESSAGE_NOUIDLUPDATE | DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, pList, pResults, pCallback));
    }

exit:
    // Unlock
    Unlock(&hSrcLock);
    pDest->Unlock(&hDstLock);

    // Cleanup
    m_pDB->CloseRowset(&hRowset);
    m_pDB->FreeRecord(&InfoSrc);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::DeleteMessages
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, 
    LPMESSAGEIDLIST pList, LPRESULTLIST pResults, 
    IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrCancel;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};
    DWORD           cTotal;
    DWORD           cCurrent=0;
    DWORD           i;
    FOLDERID        idServer;
    FOLDERID        idDeletedItems;
    HLOCK           hLock=NULL;
    HWND            hwndParent;
    BOOL            fOnBegin=FALSE;
    IDatabase      *pUidlDB=NULL;
    IMessageFolder *pDeleted=NULL;

    // Trace
    TraceCall("CMessageFolder::DeleteMessages");

    // I can't Undelete
    AssertSz(0 == (dwOptions & DELETE_MESSAGE_UNDELETE), "This flag only makes sense for IMAP!");

    // Am I in the Trash Can ?
    if (!ISFLAGSET(dwOptions, DELETE_MESSAGE_NOTRASHCAN))
    {
        // Not in the deleted items folder
        if (S_FALSE == IsParentDeletedItems(m_idFolder, &idDeletedItems, &idServer))
        {
            // Get the Deleted Items Folder
            IF_FAILEXIT(hr = m_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_DELETED, &pDeleted));

            // Simply move messages to the deleted items
            IF_FAILEXIT(hr = CopyMessages(pDeleted, COPY_MESSAGE_MOVE, pList, NULL, pResults, pCallback));

            // Done
            goto exit;
        }

        // Otherwise, do deleted items
        else
        {
            // Prompt...
            if (FALSE == ISFLAGSET(dwOptions, DELETE_MESSAGE_NOPROMPT))
            {
                // Get a Parent Hwnd
                Assert(pCallback);

                // Get Parent Window
                if (FAILED(pCallback->GetParentWindow(0, &hwndParent)))
                    hwndParent = NULL;

                // Prompt...
                if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnPermDelete), NULL, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ))
                    goto exit;
            }
        }
    }
    else if (!ISFLAGSET(dwOptions, DELETE_MESSAGE_NOPROMPT))
    {
        // Get a Parent Hwnd
        Assert(pCallback);

        // Get Parent Window
        if (FAILED(pCallback->GetParentWindow(0, &hwndParent)))
            hwndParent = NULL;

        // Prompt...
        if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsWarnPermDelete), NULL, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ))
            goto exit;
    }

    // If deleting messages from local folder, update the uidl cache.
    if (FOLDER_LOCAL == m_tyFolder && !ISFLAGSET(dwOptions, DELETE_MESSAGE_NOUIDLUPDATE))
    {
        // Open the UIDL Cache
        IF_FAILEXIT(hr = OpenUidlCache(&pUidlDB));
    }

    // No Cancel
    FLAGCLEAR(m_dwState, FOLDER_STATE_CANCEL);

    // Lock Notifications
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Need a Rowset
    if (NULL == pList)
    {
        // Create a Rowset
        IF_FAILEXIT(hr = m_pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

        // Get Count
        IF_FAILEXIT(hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cTotal));
    }

    // Otherwise, set cTotal
    else
        cTotal = pList->cMsgs;

    // User Wants Results ?
    if (pResults)
    {
        // Zero Init
        ZeroMemory(pResults, sizeof(RESULTLIST));

        // Return Results
        IF_NULLEXIT(pResults->prgResult = (LPRESULTINFO)ZeroAllocate(cTotal * sizeof(RESULTINFO)));

        // Set cAllocated
        pResults->cAllocated = pResults->cMsgs = cTotal;
    }

    // Loop through the messageIds
    for (i=0;;i++)
    {
        // Done
        if (pList)
        {
            // Done
            if (i >= pList->cMsgs)
                break;

            // Set the MessageId
            Message.idMessage = pList->prgidMsg[i];

            // Look for this record
            IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL));
        }

        // Otherwise, enumerate next
        else
        {
            // Get the next
            IF_FAILEXIT(hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL));

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            // Found
            hr = DB_S_FOUND;
        }

        // Was It Found
        if (DB_S_FOUND == hr)
        {
            // Delete the message
            IF_FAILEXIT(hr = DeleteMessageFromStore(&Message, m_pDB, pUidlDB));

            // Free
            m_pDB->FreeRecord(&Message);

            // Return Result
            if (pResults)
            {
                // hrResult
                pResults->prgResult[i].hrResult = S_OK;

                // Message Id
                pResults->prgResult[i].idMessage = Message.idMessage;

                // Store Falgs
                pResults->prgResult[i].dwFlags = Message.dwFlags;
            
                // Increment Success
                pResults->cValid++;
            }
        }

        // Otherwise, if pResults
        else if (pResults)
        {
            // Set hr
            pResults->prgResult[i].hrResult = hr;

            // Increment Success
            pResults->cValid++;
        }

        // Increment Progress
        cCurrent++;

        // Update Progress
        if (pCallback)
        {
            // Do some progress
            hrCancel = pCallback->OnProgress(SOT_DELETING_MESSAGES, cCurrent, cTotal, NULL);
            if (FAILED(hrCancel) && E_NOTIMPL != hrCancel)
                break;

            // Cancelled ?
            if (ISFLAGSET(m_dwState, FOLDER_STATE_CANCEL))
                break;
        }
    }

exit:
    // Deleted All ?
    if (NULL == pList)
    {
        // Get Count
        if (SUCCEEDED(m_pDB->GetRecordCount(IINDEX_PRIMARY, &cTotal)) && 0 == cTotal)
        {
            // Reset The Counts
            ResetFolderCounts(0, 0, 0, 0);
        }
    }

    // Lock Notifications
    m_pDB->Unlock(&hLock);

    // Cleanup
    SafeRelease(pDeleted);
    SafeRelease(pUidlDB);
    m_pDB->CloseRowset(&hRowset);
    m_pDB->FreeRecord(&Message);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageFolder::_FixupMessageCharset
// --------------------------------------------------------------------------------
HRESULT CMessageFolder::_FixupMessageCharset(IMimeMessage *pMessage, 
    CODEPAGEID cpCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    HCHARSET        hCharset;
    INETCSETINFO    CsetInfo;
    DWORD           dwCodePage=0;
    DWORD           dwFlags;

    // Trace
    TraceCall("CMessageFolder::_FixupMessageCharset");

    // Invalid Args
    Assert(pMessage);

    // See if we need to apply charset re-mapping
    if (cpCurrent == 0)
    {
        HCHARSET hChar = NULL;
        
        // Get Flags
        IF_FAILEXIT(hr = pMessage->GetFlags(&dwFlags));

        if(DwGetOption(OPT_INCOMDEFENCODE))
        {
            if (SUCCEEDED(HGetDefaultCharset(&hChar)))
                pMessage->SetCharset(hChar, CSET_APPLY_ALL);
            else
                cpCurrent = GetACP();
        }
        // for tagged message or news only
        else if (ISFLAGSET(dwFlags, IMF_CSETTAGGED))
        {
            // Get the Character SEt
            IF_FAILEXIT(hr= pMessage->GetCharset(&hCharset));

            // Remap the Character Set
            if (hCharset && CheckIntlCharsetMap(hCharset, &dwCodePage))
                cpCurrent = dwCodePage;
        }
        // Check AutoSelect
        else if(CheckAutoSelect((UINT *) &dwCodePage))
            cpCurrent = dwCodePage;

        // The message is not tagged, use the default character set
        else if (SUCCEEDED(HGetDefaultCharset(&hChar)))
        {
            // Change the Character set of the message to default
            pMessage->SetCharset(hChar, CSET_APPLY_ALL);
        }
    }

    // If cpCurrent is set, call SetCharset to change charset
    if (cpCurrent)
    {
        // Get the character set fromt he codepage
        hCharset = GetMimeCharsetFromCodePage(cpCurrent);

        // Modify the Character set of the message
        if (hCharset)
        {
            // SetCharset
            IF_FAILEXIT(hr = pMessage->SetCharset(hCharset, CSET_APPLY_ALL));
        }
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageFolder::_GetMsgInfoFromMessage
// --------------------------------------------------------------------------------
HRESULT CMessageFolder::_GetMsgInfoFromMessage(IMimeMessage *pMessage,
    LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwImf;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    SYSTEMTIME          st;
    FILETIME            ftCurrent;
    IMimePropertySet   *pPropertySet=NULL;

    // Trace
    TraceCall("CMessageFolder::_GetMsgInfoFromMessage");

    // Invalid Args
    Assert(pMessage && pInfo);

    // Get the Root Property Set from the Message
    IF_FAILEXIT(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropertySet));

    // File pInfo from pPropertySet
    IF_FAILEXIT(hr = _GetMsgInfoFromPropertySet(pPropertySet, pInfo));

    // Get Message Flags
    if (SUCCEEDED(pMessage->GetFlags(&dwImf)))
        pInfo->dwFlags = ConvertIMFFlagsToARF(dwImf);

    // Get the Message Size
    pMessage->GetMessageSize(&pInfo->cbMessage, 0);

exit:
    // Cleanup
    SafeRelease(pPropertySet);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder:_GetMsgInfoFromPropertySet
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_GetMsgInfoFromPropertySet(IMimePropertySet *pPropertySet,
    LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    FILETIME            ftCurrent;
    IMimeAddressTable  *pAdrTable=NULL;
    ADDRESSPROPS        rAddress;

    // Trace
    TraceCall("CMessageFolder::_GetMsgInfoFromPropertySet");

    // Invalid Args
    Assert(pPropertySet && pInfo);

    // Default Sent and Received Times...
    GetSystemTimeAsFileTime(&ftCurrent);

    // Set Variant tyStore
    Variant.vt = VT_UI4;

    // Priority
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &Variant)))
    {
        // Set Priority
        pInfo->wPriority = (WORD)Variant.ulVal;
    }

    // Partial Numbers...
    if (pPropertySet->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK)
    {
        // Locals
        WORD cParts=0, iPart=0;

        // Get Total
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_TOTAL, NOFLAGS, &Variant)))
            cParts = (WORD)Variant.ulVal;

        // Get Number
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_NUMBER, NOFLAGS, &Variant)))
            iPart = (WORD)Variant.ulVal;

        // Set Parts
        pInfo->dwPartial = MAKELONG(cParts, iPart);
    }

    // Otherwise, check for user property
    else if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_COMBINED), NOFLAGS, &Variant)))
    {
        // Set the Partial Id
        pInfo->dwPartial = Variant.ulVal;
    }

    // Getting some file times
    Variant.vt = VT_FILETIME;

    // Get Received Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &Variant)))
        pInfo->ftReceived = Variant.filetime;
    else
        pInfo->ftReceived = ftCurrent;

    // Get Sent Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &Variant)))
        pInfo->ftSent = Variant.filetime;
    else
        pInfo->ftSent = ftCurrent;

    // Get Address Table
    IF_FAILEXIT(hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAdrTable));

    // Display From
    pAdrTable->GetFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &pInfo->pszDisplayFrom);

    // Email From
    rAddress.dwProps = IAP_EMAIL;
    if (SUCCEEDED(pAdrTable->GetSender(&rAddress)))
    {
        pInfo->pszEmailFrom = rAddress.pszEmail;
    }

    // Display to
    pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &pInfo->pszDisplayTo);

    // Email To
    pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_EMAIL, &pInfo->pszEmailTo);

    // String Properties
    Variant.vt = VT_LPSTR;

    // pszDisplayFrom as newsgroups
    if (NULL == pInfo->pszDisplayTo && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &Variant)))
        pInfo->pszDisplayTo = Variant.pszVal;

    // pszMessageId
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &Variant)))
        pInfo->pszMessageId = Variant.pszVal;

    // pszMSOESRec
    if (SUCCEEDED(pPropertySet->GetProp(STR_HDR_XMSOESREC, NOFLAGS, &Variant)))
        pInfo->pszMSOESRec = Variant.pszVal;

    // pszXref
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_XREF), NOFLAGS, &Variant)))
        pInfo->pszXref = Variant.pszVal;

    // pszReferences
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(STR_HDR_REFS), NOFLAGS, &Variant)))
        pInfo->pszReferences = Variant.pszVal;

    // pszSubject
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &Variant)))
        pInfo->pszSubject = Variant.pszVal;

    // pszNormalSubj
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &Variant)))
        pInfo->pszNormalSubj = Variant.pszVal;

    // pszAcctId
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &Variant)))
        pInfo->pszAcctId = Variant.pszVal;

    // pszAcctName
    if (SUCCEEDED(pPropertySet->GetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &Variant)))
        pInfo->pszAcctName = Variant.pszVal;

    // pszServer
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &Variant)))
        pInfo->pszServer = Variant.pszVal;

    // pszUidl
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_UIDL), NOFLAGS, &Variant)))
        pInfo->pszUidl = Variant.pszVal;

    // pszPartialId
    if (pInfo->dwPartial != 0 && SUCCEEDED(pPropertySet->GetProp(STR_PAR_ID, NOFLAGS, &Variant)))
        pInfo->pszPartialId = Variant.pszVal;

    // ForwardTo
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_FORWARDTO), NOFLAGS, &Variant)))
        pInfo->pszForwardTo = Variant.pszVal;

exit:
    // Cleanup
    SafeRelease(pAdrTable);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::_FreeMsgInfoData
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_FreeMsgInfoData(LPMESSAGEINFO pInfo)
{
    // Trace
    TraceCall("CMessageFolder::_FreeMsgInfoData");

    // Invalid Args
    Assert(pInfo && NULL == pInfo->pAllocated);

    // Free all the items
    g_pMalloc->Free(pInfo->pszMessageId);
    g_pMalloc->Free(pInfo->pszSubject);
    g_pMalloc->Free(pInfo->pszNormalSubj);
    g_pMalloc->Free(pInfo->pszFromHeader);
    g_pMalloc->Free(pInfo->pszReferences);
    g_pMalloc->Free(pInfo->pszXref);
    g_pMalloc->Free(pInfo->pszServer);
    g_pMalloc->Free(pInfo->pszDisplayFrom);
    g_pMalloc->Free(pInfo->pszEmailFrom);
    g_pMalloc->Free(pInfo->pszDisplayTo);
    g_pMalloc->Free(pInfo->pszEmailTo);
    g_pMalloc->Free(pInfo->pszUidl);
    g_pMalloc->Free(pInfo->pszPartialId);
    g_pMalloc->Free(pInfo->pszForwardTo);
    g_pMalloc->Free(pInfo->pszAcctId);
    g_pMalloc->Free(pInfo->pszAcctName);
    g_pMalloc->Free(pInfo->Offsets.pBlobData);
    g_pMalloc->Free(pInfo->pszMSOESRec);

    // Zero It
    ZeroMemory(pInfo, sizeof(MESSAGEINFO));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::_SetMessageStream
//--------------------------------------------------------------------------
HRESULT CMessageFolder::_SetMessageStream(LPMESSAGEINFO pInfo, 
    BOOL fUpdateRecord, IStream *pStmSrc)
{
    // Locals
    HRESULT               hr=S_OK;
    FILEADDRESS           faStream=0;
    FILEADDRESS           faOldStream=0;
    IStream              *pStmDst=NULL;
    IDatabaseStream      *pDBStream=NULL;

    // Trace
    TraceCall("CMessageFolder::_SetMessageStream");

    // Invalid Args
    Assert(pInfo && pStmSrc);

    // Raid 38276: message moves after being downloaded (don't reset the size if its already set)
    if (0 == pInfo->cbMessage)
    {
        // Get the size of the stream
        IF_FAILEXIT(hr = HrGetStreamSize(pStmSrc, &pInfo->cbMessage));
    }

    // Rewind the source stream
    IF_FAILEXIT(hr = HrRewindStream(pStmSrc));

    // Determine if this is an ObjectDB Stream
    if (SUCCEEDED(pStmSrc->QueryInterface(IID_IDatabaseStream, (LPVOID *)&pDBStream)) && S_OK == pDBStream->CompareDatabase(m_pDB))
    {
        // Get the Stream Id
        pDBStream->GetFileAddress(&faStream);
    }

    // Otherwise, create a stream
    else
    {
        // Create a stream
        IF_FAILEXIT(hr = m_pDB->CreateStream(&faStream));

        // Open the Stream
        IF_FAILEXIT(hr = m_pDB->OpenStream(ACCESS_WRITE, faStream, &pStmDst));

        // Copy the Stream
        IF_FAILEXIT(hr = HrCopyStream(pStmSrc, pStmDst, NULL));

        // Commit
        IF_FAILEXIT(hr = pStmDst->Commit(STGC_DEFAULT));
    }

    // Save the Address of the Old Message Stream Attached to this message
    faOldStream = pInfo->faStream;

    // Update the Message Information
    pInfo->faStream = faStream;

    // Get the time in which the article was downloaded
    GetSystemTimeAsFileTime(&pInfo->ftDownloaded);

    // Has a Body
    FLAGSET(pInfo->dwFlags, ARF_HASBODY);

    // Update the Record ?
    if (fUpdateRecord)
    {
        // Save the new Record
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(pInfo));
    }

    // Don't Free faStream
    faStream = 0;

exit:
    // If pInfo already has a message sstream,
    if (faOldStream)
    {
        // Free this stream
        SideAssert(SUCCEEDED(m_pDB->DeleteStream(faOldStream)));
    }

    // Failure
    if (faStream)
    {
        // Free this stream
        SideAssert(SUCCEEDED(m_pDB->DeleteStream(faStream)));
    }

    // Cleanup
    SafeRelease(pDBStream);
    SafeRelease(pStmDst);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CMessageFolder::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::Initialize(IDatabase *pDB)
{
    // Trace
    TraceCall("CMessageFolder::Initialize");

    // Assume the Database from here ?
    if (NULL == m_pDB)
    {
        // Save Database
        m_pDB = pDB;
    }

    // Only if there is a global store...
    if (NULL == m_pStore && g_pStore)
    {
        // Locals
        FOLDERINFO      Folder;
        FOLDERUSERDATA  UserData;

        // Get the user data
        m_pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA));

        // Get Folder Info
        if (UserData.fInitialized && SUCCEEDED(g_pStore->GetFolderInfo(UserData.idFolder, &Folder)))
        {
            // AddRef g_pStore
            m_pStore = g_pStore;

            // AddRef it
            m_pStore->AddRef();

            // Save My Folder Id
            m_idFolder = Folder.idFolder;

            // Save m_tyFolder
            m_tyFolder = Folder.tyFolder;

            // Save m_tySpecial
            m_tySpecial = Folder.tySpecial;

            // Free Folder
            g_pStore->FreeRecord(&Folder);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnLock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnLock(void)
{
    // Trace
    TraceCall("CMessageFolder::OnLock");

    // Validate
    Assert(0 == m_OnLock.cLocked ? (0 == m_OnLock.lMsgs && 0 == m_OnLock.lUnread && 0 == m_OnLock.lWatchedUnread) : TRUE);

    // Increment cLock
    m_OnLock.cLocked++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnUnlock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnUnlock(void)
{
    // Trace
    TraceCall("CMessageFolder::OnUnlock");

    // Increment cLock
    m_OnLock.cLocked--;

    // If zero, then lets flush counts...
    if (0 == m_OnLock.cLocked)
    {
        // Do we have a folder ?
        if (FOLDERID_INVALID != m_idFolder && m_pStore)
        {
            // Update Folder Counts
            m_pStore->UpdateFolderCounts(m_idFolder, m_OnLock.lMsgs, m_OnLock.lUnread, m_OnLock.lWatchedUnread, m_OnLock.lWatched);
        }

        // Zero OnLock
        ZeroMemory(&m_OnLock, sizeof(ONLOCKINFO));
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnInsertRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnRecordInsert(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Locals
    HRESULT         hr;
    MESSAGEFLAGS    dwFlags;
    LPMESSAGEINFO   pMessage=(LPMESSAGEINFO)pRecord;

    // Trace
    TraceCall("CMessageFolder::OnInsertRecord");

    // Validate
    Assert(pRecord && m_OnLock.cLocked > 0);

    // Before
    if (OPERATION_BEFORE == tyState)
    {
        // If not Watched and Not ignored...
        if (!ISFLAGSET(pMessage->dwFlags, ARF_WATCH) && !ISFLAGSET(pMessage->dwFlags, ARF_IGNORE))
        {
            // Get Flags
            if (DB_S_FOUND == _GetWatchIgnoreParentFlags(pMessage->pszReferences, pMessage->pszNormalSubj, &dwFlags))
            {
                // Set Watched
                if (ISFLAGSET(dwFlags, ARF_WATCH))
                    FLAGSET(pMessage->dwFlags, ARF_WATCH);
                else if (ISFLAGSET(dwFlags, ARF_IGNORE))
                    FLAGSET(pMessage->dwFlags, ARF_IGNORE);
            }
        }
    }

    // After
    else if (OPERATION_AFTER == tyState)
    {
        // One more message...
        m_OnLock.lMsgs++;

        // Watched
        if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
            m_OnLock.lWatched++;

        // On more unread...
        if (FALSE == ISFLAGSET(pMessage->dwFlags, ARF_READ))
        {
            // Total Unread
            m_OnLock.lUnread++;

            // Watched ?
            if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
                m_OnLock.lWatchedUnread++;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnUpdateRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnRecordUpdate(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lUnread=0;
    ROWORDINAL      iOrdinal1;
    ROWORDINAL      iOrdinal2;
    LPMESSAGEINFO   pMsgOld = (LPMESSAGEINFO)pRecordOld;
    LPMESSAGEINFO   pMsgNew = (LPMESSAGEINFO)pRecordNew;

    // Trace
    TraceCall("CMessageFolder::OnRecordUpdate");

    // Validate
    Assert(pRecordOld && pRecordNew && m_OnLock.cLocked > 0);

    // After
    if (OPERATION_AFTER == tyState)
    {
        // One less Unread Message
        if (!ISFLAGSET(pMsgOld->dwFlags, ARF_READ) && ISFLAGSET(pMsgNew->dwFlags, ARF_READ))
            lUnread = -1;

        // Otherwise...new unread
        else if (ISFLAGSET(pMsgOld->dwFlags, ARF_READ) && !ISFLAGSET(pMsgNew->dwFlags, ARF_READ))
            lUnread = 1;

        // Update m_OnLock
        m_OnLock.lUnread += lUnread;

        // Old was Watched new is not watched
        if (ISFLAGSET(pMsgOld->dwFlags, ARF_WATCH) && !ISFLAGSET(pMsgNew->dwFlags, ARF_WATCH))
        {
            // Total Watched
            m_OnLock.lWatched--;

            // Unread
            if (!ISFLAGSET(pMsgOld->dwFlags, ARF_READ))
                m_OnLock.lWatchedUnread--;
        }

        // Otherwise, Old was not watched and new message is watched
        else if (!ISFLAGSET(pMsgOld->dwFlags, ARF_WATCH) && ISFLAGSET(pMsgNew->dwFlags, ARF_WATCH))
        {
            // Total Watched
            m_OnLock.lWatched++;

            // Unread
            if (!ISFLAGSET(pMsgNew->dwFlags, ARF_READ))
                m_OnLock.lWatchedUnread++;
        }

        // Otherwise, old was watched, new is watched, then just adjust the unread count
        else if (ISFLAGSET(pMsgOld->dwFlags, ARF_WATCH) && ISFLAGSET(pMsgNew->dwFlags, ARF_WATCH))
            m_OnLock.lWatchedUnread += lUnread;
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnDeleteRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnRecordDelete(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Locals
    LPMESSAGEINFO   pMessage=(LPMESSAGEINFO)pRecord;

    // Trace
    TraceCall("CMessageFolder::OnDeleteRecord");

    // Validate
    Assert(pRecord && m_OnLock.cLocked > 0);

    // After
    if (OPERATION_AFTER == tyState)
    {
        // One less message
        m_OnLock.lMsgs--;

        // Watched
        if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
            m_OnLock.lWatched--;

        // Read State Change
        if (FALSE == ISFLAGSET(pMessage->dwFlags, ARF_READ))
        {
            // Total Unread
            m_OnLock.lUnread--;

            // Watched
            if (ISFLAGSET(pMessage->dwFlags, ARF_WATCH))
                m_OnLock.lWatchedUnread--;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageFolder::OnExecuteMethod
//--------------------------------------------------------------------------
STDMETHODIMP CMessageFolder::OnExecuteMethod(METHODID idMethod, LPVOID pBinding, 
    LPDWORD pdwResult)
{
    // Locals
    FILETIME        ftCurrent;
    LPMESSAGEINFO   pMessage=(LPMESSAGEINFO)pBinding;

    // Validate
    Assert(METHODID_MESSAGEAGEINDAYS == idMethod);

    // Get system time as filetime
    GetSystemTimeAsFileTime(&ftCurrent);

    // Convert st to seconds since Jan 1, 1996
    *pdwResult = (UlDateDiff(&pMessage->ftSent, &ftCurrent) / SECONDS_INA_DAY);

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\playback.cpp ===
#include "pch.hxx"
#include <progress.h>
#include "store.h"
#include "storutil.h"
#include "storsync.h"
#include "syncop.h"
#include "sync.h"
#include "shlwapip.h" 
#include "enumsync.h"
#include "playback.h"

#define WM_NEXT_OPERATION   (WM_USER + 69)

HRESULT OpenErrorsFolder(IMessageFolder **ppFolder);

COfflinePlayback::COfflinePlayback()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndDlg = NULL;
    m_fComplete = TRUE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;

    m_cMovedToErrors = 0;
    m_cFailures = 0;

    m_pDB = NULL;

    m_pid = NULL;
    m_iid = 0;
    m_cid = 0;

    m_idServer = FOLDERID_INVALID;
    m_idFolder = FOLDERID_INVALID;
    m_idFolderSel = FOLDERID_INVALID;
    m_fSyncSel = FALSE;
    m_pServer = NULL;
    m_pLocalFolder = NULL;
    m_iOps = 0;
    m_cOps = 0;
    m_pEnum = NULL;

    m_pFolderDest = NULL;
}

COfflinePlayback::~COfflinePlayback()
{
    Assert(m_pFolderDest == NULL);

    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();
    if (m_pDB != NULL)
        m_pDB->Release();
    if (m_pid != NULL)
        MemFree(m_pid);
    if (m_pLocalFolder != NULL)
        m_pLocalFolder->Release();
    if (m_pServer != NULL)
    {
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
    }
    if (m_pEnum != NULL)
        m_pEnum->Release();
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (void*) (ITimeoutCallback *)this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE COfflinePlayback::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE COfflinePlayback::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT COfflinePlayback::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    Assert(m_hwndDlg != NULL);
    Assert(!m_fComplete);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    return CallbackCanConnect(pszAccountId, m_hwndDlg, FALSE);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT hr;
    SYNCOPINFO info;

    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    if (m_idOperation == SYNCOPID_INVALID)
    {
        m_idFolderSel = FOLDERID_INVALID;
    }
    else
    {
        ZeroMemory(&info, sizeof(SYNCOPINFO));

        info.idOperation = m_idOperation;
        hr = m_pDB->FindRecord(IINDEX_PRIMARY, 1, &info, NULL);
        if (hr == DB_S_FOUND)
        {
            switch (info.tyOperation)
            {
                case SYNC_DELETE_MSG:
                    hr = _HandleDeleteComplete(hrComplete, &info);
                    break;

                case SYNC_SETPROP_MSG:
                    hr = _HandleSetPropComplete(hrComplete, &info);
                    break;

                case SYNC_CREATE_MSG:
                    hr = _HandleCreateComplete(hrComplete, &info);
                    break;

                case SYNC_COPY_MSG:
                case SYNC_MOVE_MSG:
                    hr = _HandleCopyComplete(hrComplete, &info);
                    break;

                default:
                    Assert(FALSE);
                    break;
            }

            m_pDB->DeleteRecord(&info);
            m_pDB->FreeRecord(&info);
        }
    }

    PostMessage(m_hwndDlg, WM_NEXT_OPERATION, 0, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE COfflinePlayback::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}

HRESULT COfflinePlayback::DoPlayback(HWND hwnd, IDatabase *pDB, FOLDERID *pid, DWORD cid, FOLDERID idFolderSel)
{
    FOLDERTYPE type;
    int iRet;
    char szStoreDir[MAX_PATH + MAX_PATH];

    Assert(pDB != NULL);
    Assert(pid != NULL);
    Assert(cid > 0);

    m_pDB = pDB;
    m_pDB->AddRef();

    m_pEnum = new CEnumerateSyncOps;
    if (m_pEnum == NULL)
        return(E_OUTOFMEMORY);

    if (!MemAlloc((void **)&m_pid, cid * sizeof(FOLDERID)))
        return(E_OUTOFMEMORY);

    CopyMemory(m_pid, pid, cid * sizeof(FOLDERID));
    m_cid = cid;
    type = GetFolderType(idFolderSel);
    if (type == FOLDER_IMAP || type == FOLDER_HTTPMAIL)
        m_idFolderSel = idFolderSel;

    iRet = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(IDD_PLAYBACK), hwnd, PlaybackDlgProc, (LPARAM)this);

    if (m_cFailures > 0)
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsOfflineTransactionsFailed),
            (m_cMovedToErrors > 0) ? MAKEINTRESOURCEW(idsMovedToOfflineErrors) : NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    return(S_OK);
}

INT_PTR CALLBACK COfflinePlayback::PlaybackDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet;
    HRESULT hr;
    COfflinePlayback *pThis;

    fRet = TRUE;

    switch (msg)
    {
        case WM_INITDIALOG:
            pThis = (COfflinePlayback *)lParam;
            Assert(pThis != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);

            pThis->m_hwndDlg = hwnd;

            CenterDialog(hwnd);

            Animate_OpenEx(GetDlgItem(hwnd, idcANI), g_hLocRes, MAKEINTRESOURCE(idanOutbox));
            PostMessage(hwnd, WM_NEXT_OPERATION, 0, 0);
            break;

        case WM_NEXT_OPERATION:
            pThis = (COfflinePlayback *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            Assert(pThis != NULL);
            hr = pThis->_DoNextOperation();
            if (hr != S_OK)
                EndDialog(hwnd, 0);
            break;

        default:
            fRet = FALSE;
            break;
    }

    return(fRet);
}

HRESULT COfflinePlayback::_DoNextOperation()
{
    HRESULT hr;
    char sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];
    SYNCOPINFO info;
    FOLDERINFO Folder;

    Assert(m_pEnum != NULL);
    Assert(g_pLocalStore != NULL);

    if (m_iOps == m_cOps)
    {
        m_iOps = 0;
        m_idServer = FOLDERID_INVALID;
        m_idFolder = FOLDERID_INVALID;
        if (m_pServer != NULL)
        {
            m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
            m_pServer->Release();
            m_pServer = NULL;
        }

        if (m_pLocalFolder != NULL)
        {
            m_pLocalFolder->Release();
            m_pLocalFolder = NULL;
        }

        while (TRUE)
        {
            if (m_iid == m_cid)
            {
                hr = S_FALSE;

                if (m_idFolderSel != FOLDERID_INVALID &&
                    m_fSyncSel)
                {
                    if (SUCCEEDED(g_pLocalStore->GetFolderInfo(m_idFolderSel, &Folder)))
                    {
                        if (SUCCEEDED(CreateMessageServerType(Folder.tyFolder, &m_pServer)) &&
                            SUCCEEDED(g_pLocalStore->OpenFolder(m_idFolderSel, NULL, NOFLAGS, &m_pLocalFolder)) &&
                            SUCCEEDED(GetFolderServerId(m_idFolderSel, &m_idServer)) &&
                            SUCCEEDED(m_pServer->Initialize(g_pLocalStore, m_idServer, m_pLocalFolder, m_idFolderSel)))
                        {
                            if (E_PENDING == m_pServer->SynchronizeFolder(SYNC_FOLDER_CACHED_HEADERS | SYNC_FOLDER_NEW_HEADERS, 0, this))
                            {
                                m_idOperation = SYNCOPID_INVALID;

                                hr = S_OK;
                            }
                        }

                        g_pLocalStore->FreeRecord(&Folder);
                    }
                }

                return(hr);
            }

            m_idServer = m_pid[m_iid++];
            hr = m_pEnum->Initialize(m_pDB, m_idServer);
            if (FAILED(hr))
                return(hr);

            hr = m_pEnum->Count(&m_cOps);
            if (FAILED(hr))
                return(hr);

            if (m_cOps > 0)
            {
                if (SUCCEEDED(g_pLocalStore->GetFolderInfo(m_idServer, &Folder)))
                {
                    AthLoadString(idsAccountLabelFmt, szT, ARRAYSIZE(szT));
                    wsprintf(sz, szT, Folder.pszName);
                    SetDlgItemText(m_hwndDlg, IDC_ACCOUNT_STATIC, sz);
                    g_pLocalStore->FreeRecord(&Folder);
                }

                SendDlgItemMessage(m_hwndDlg, idcProgBar, PBM_SETRANGE, 0, MAKELPARAM(0, m_cOps));
                break;
            }
        }
    }

    Assert(m_pEnum != NULL);

    hr = m_pEnum->Next(&info);
    if (hr != S_OK)
        return(hr);
    m_iOps++;

    if (info.idFolder != m_idFolder)
    {
        if (m_pServer != NULL)
        {
            m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
            m_pServer->Release();
            m_pServer = NULL;
        }

        if (m_pLocalFolder != NULL)
        {
            m_pLocalFolder->Release();
            m_pLocalFolder = NULL;
        }

        m_idFolder = info.idFolder;

        hr = g_pLocalStore->GetFolderInfo(m_idFolder, &Folder);
        if (SUCCEEDED(hr))
        {
            hr = CreateMessageServerType(Folder.tyFolder, &m_pServer);
            if (SUCCEEDED(hr))
            {
                hr = g_pLocalStore->OpenFolder(m_idFolder, NULL, NOFLAGS, &m_pLocalFolder);
                if (SUCCEEDED(hr))
                {
                    hr = m_pServer->Initialize(g_pLocalStore, m_idServer, m_pLocalFolder, m_idFolder);
                }
            }
            AthLoadString(idsFolderLabelFmt, szT, ARRAYSIZE(szT));
            wsprintf(sz, szT, Folder.pszName);
            SetDlgItemText(m_hwndDlg, IDC_FOO_STATIC, sz);

            g_pLocalStore->FreeRecord(&Folder);
        }

        if (FAILED(hr))
        {
            m_pDB->FreeRecord(&info);
            return(hr);
        }
    }

    SendDlgItemMessage(m_hwndDlg, idcProgBar, PBM_SETPOS, m_iOps, 0);

    switch (info.tyOperation)
    {
        case SYNC_DELETE_MSG:
            hr = _DoDeleteOp(&info);
            break;

        case SYNC_SETPROP_MSG:
            hr = _DoSetPropOp(&info);
            break;

        case SYNC_CREATE_MSG:
            hr = _DoCreateOp(&info);
            break;

        case SYNC_COPY_MSG:
        case SYNC_MOVE_MSG:
            hr = _DoCopyOp(&info);
            break;

        default:
            Assert(FALSE);
            break;
    }

    if (FAILED(hr))
    {
        Assert(hr != E_PENDING);
        m_pDB->DeleteRecord(&info);

        PostMessage(m_hwndDlg, WM_NEXT_OPERATION, 0, 0);
    }
    else
    {
        m_idOperation = info.idOperation;
    }
    m_pDB->FreeRecord(&info);

    return(S_OK);
}

HRESULT COfflinePlayback::_DoDeleteOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;

    Assert(pInfo != NULL);

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessage;

    hr = m_pServer->DeleteMessages(pInfo->dwFlags, &list, this);
    if (hr == E_PENDING)
        hr = S_OK;
    else
        Assert(FAILED(hr));

    return(hr);
}

HRESULT COfflinePlayback::_DoSetPropOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessage;

    flags.dwRemove = pInfo->dwRemove;
    flags.dwAdd = pInfo->dwAdd;

    hr = m_pServer->SetMessageFlags(&list, &flags, SET_MESSAGE_FLAGS_FORCE, this);
    if (hr == E_PENDING)
        hr = S_OK;
    else
        Assert(FAILED(hr));

    return(hr);
}

HRESULT COfflinePlayback::_DoCreateOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    IMimeMessage *pMessage;
    IStream *pStream;
    MESSAGEINFO Message;
    PROPVARIANT rVariant;
    LPFILETIME pftRecv;
    DWORD dwFlags;

    Assert(pInfo != NULL);

    hr = m_pLocalFolder->OpenMessage(pInfo->idMessage, 0, &pMessage, NULL);
    if (SUCCEEDED(hr))
    {
        dwFlags = 0;
        ZeroMemory(&Message, sizeof(MESSAGEINFO));
        Message.idMessage = pInfo->idMessage;
        if (DB_S_FOUND == m_pLocalFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
        {
            dwFlags = Message.dwFlags;

            m_pLocalFolder->FreeRecord(&Message);
        }

        hr = pMessage->GetMessageSource(&pStream, 0);
        if (SUCCEEDED(hr))
        {
            rVariant.vt = VT_FILETIME;
            if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
                pftRecv = &rVariant.filetime;
            else
                pftRecv = NULL;

            hr = m_pServer->PutMessage(m_idFolder, dwFlags, pftRecv, pStream, this);
            if (hr == E_PENDING)
                hr = S_OK;
            else
                Assert(FAILED(hr));

            pStream->Release();
        }

        pMessage->Release();
    }

    return(hr);
}

HRESULT COfflinePlayback::_DoCopyOp(SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    MESSAGEINFO infoSrc, infoDest;
    ADJUSTFLAGS flags, *pFlags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_COPY_MSG || pInfo->tyOperation == SYNC_MOVE_MSG);
    Assert(m_pFolderDest == NULL);

    hr = g_pLocalStore->OpenFolder(pInfo->idFolderDest, NULL, NOFLAGS, &m_pFolderDest);
    if (SUCCEEDED(hr))
    {
        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        if (pInfo->dwRemove != 0 || pInfo->dwAdd != 0)
        {
            flags.dwRemove = pInfo->dwRemove;
            flags.dwAdd = pInfo->dwAdd;
            pFlags = &flags;
        }
        else
        {
            pFlags = NULL;
        }

        hr = m_pServer->CopyMessages(m_pFolderDest, pInfo->tyOperation == SYNC_MOVE_MSG ? COPY_MESSAGE_MOVE : NOFLAGS,
                                        &list, pFlags, this);
        if (hr == E_PENDING)
        {
            hr = S_OK;
        }
        else
        {
            Assert(FAILED(hr));

            m_pFolderDest->Release();
            m_pFolderDest = NULL;
        }
    }

    return(hr);
}

HRESULT COfflinePlayback::_HandleSetPropComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_SETPROP_MSG);
    Assert(m_pLocalFolder != NULL);

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        flags.dwAdd = pInfo->dwRemove;
        flags.dwRemove = pInfo->dwAdd;

        hr = m_pLocalFolder->SetMessageFlags(&list, &flags, NULL, NULL);
    }
    
    return(S_OK);
}

HRESULT COfflinePlayback::_HandleCreateComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    FOLDERINFO Folder;
    MESSAGEIDLIST list;
    IMessageFolder *pErrorFolder;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_CREATE_MSG);
    Assert(m_pLocalFolder != NULL);

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessage;

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        hr = OpenErrorsFolder(&pErrorFolder);
        if (SUCCEEDED(hr))
        {
            hr = m_pLocalFolder->CopyMessages(pErrorFolder, NOFLAGS, &list, NULL, NULL, NULL);
            if (SUCCEEDED(hr))
                m_cMovedToErrors++;

            pErrorFolder->Release();
        }
    }

    // get rid of the temp offline msg
    hr = m_pLocalFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NULL);
    Assert(SUCCEEDED(hr));

    if (pInfo->idFolder == m_idFolderSel)
        m_fSyncSel = TRUE;

    return(S_OK);
}

HRESULT COfflinePlayback::_HandleDeleteComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_DELETE_MSG);
    Assert(m_pLocalFolder != NULL);

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        flags.dwAdd = 0;
        flags.dwRemove = ARF_DELETED_OFFLINE;

        hr = m_pLocalFolder->SetMessageFlags(&list, &flags, NULL, NULL);
    }
    
    return(S_OK);
}

HRESULT COfflinePlayback::_HandleCopyComplete(HRESULT hrOperation, SYNCOPINFO *pInfo)
{
    HRESULT hr;
    MESSAGEIDLIST list;
    ADJUSTFLAGS flags;

    Assert(pInfo != NULL);
    Assert(pInfo->tyOperation == SYNC_COPY_MSG || pInfo->tyOperation == SYNC_MOVE_MSG);
    Assert(m_pLocalFolder != NULL);

    if (pInfo->tyOperation == SYNC_MOVE_MSG && FAILED(hrOperation))
    {
        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &pInfo->idMessage;

        flags.dwAdd = 0;
        flags.dwRemove = ARF_DELETED_OFFLINE;

        hr = m_pLocalFolder->SetMessageFlags(&list, &flags, NULL, NULL);
    }

    if (FAILED(hrOperation))
    {
        m_cFailures++;

        // TODO: we need more robust error handling in here
    }

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &pInfo->idMessageDest;

    // get rid of the temp offline msg
    hr = m_pFolderDest->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NULL);
    Assert(SUCCEEDED(hr));

    if (pInfo->idFolderDest == m_idFolderSel)
        m_fSyncSel = TRUE;

    m_pFolderDest->Release();
    m_pFolderDest = NULL;

    return(S_OK);
}

HRESULT OpenErrorsFolder(IMessageFolder **ppFolder)
{
    FOLDERINFO Folder;
    HRESULT hr;
    char szFolder[CCHMAX_FOLDER_NAME];

    Assert(g_pLocalStore != NULL);
    Assert(ppFolder != NULL);

    hr = g_pLocalStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_ERRORS, &Folder);
    if (SUCCEEDED(hr))
    {
        hr = g_pLocalStore->OpenFolder(Folder.idFolder, NULL, NOFLAGS, ppFolder);

        g_pLocalStore->FreeRecord(&Folder);
    }
    else if (hr == DB_E_NOTFOUND)
    {
        LoadString(g_hLocRes, idsOfflineErrors, szFolder, ARRAYSIZE(szFolder));

        // Fill the Folder Info
        ZeroMemory(&Folder, sizeof(FOLDERINFO));
        Folder.idParent = FOLDERID_LOCAL_STORE;
        Folder.tySpecial = FOLDER_ERRORS;
        Folder.pszName = szFolder;
        Folder.dwFlags = FOLDER_SUBSCRIBED;

        // Create the Folder
        hr = g_pLocalStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK);
        if (SUCCEEDED(hr))
            hr = g_pLocalStore->OpenFolder(Folder.idFolder, NULL, NOFLAGS, ppFolder);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\newfldr.h ===
//--------------------------------------------------------------------------
// Newfldr.h
//--------------------------------------------------------------------------
#ifndef __NEWFLDR_H
#define __NEWFLDR_H

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "treeview.h"

//--------------------------------------------------------------------------
// Control Ids
//--------------------------------------------------------------------------
#define idcFolderEdit           1000
#define idcTreeView             1001
#define idcTreeViewText         1002
#define idcNewFolderBtn         1003

//--------------------------------------------------------------------------
// Folder Dialog flags (Can be combined with TREEVIEW_xxx Flags
//--------------------------------------------------------------------------
typedef DWORD FOLDERDIALOGFLAGS;
#define FD_NONEWFOLDERS         0x0100
#define FD_DISABLEROOT          0x0200
#define FD_DISABLEINBOX         0x0400
#define FD_DISABLEOUTBOX        0x0800
#define FD_DISABLESENTITEMS     0x1000
#define FD_DISABLESERVERS       0x2000
#define FD_FORCEINITSELFOLDER   0x4000

//--------------------------------------------------------------------------
// Common Folder Dialog flags Combos
//--------------------------------------------------------------------------
#define FD_COPYFLAGS            (FD_DISABLEROOT | FD_DISABLEOUTBOX)
#define FD_MOVEFLAGS            (FD_DISABLEROOT | FD_DISABLEOUTBOX)
#define FD_DISABLEFLAGS         (FD_DISABLEROOT | FD_DISABLEINBOX | FD_DISABLEOUTBOX | FD_DISABLESENTITEMS | FD_DISABLESERVERS)
#define FD_DISABLEFOLDERS       (FD_DISABLEINBOX | FD_DISABLEOUTBOX | FD_DISABLESENTITEMS)

//--------------------------------------------------------------------------
// Select Folder Dialog operations
//--------------------------------------------------------------------------
enum
{
    SFD_SELECTFOLDER = 0,
    SFD_NEWFOLDER,
    SFD_MOVEFOLDER,
    // SFD_MOVEMESSAGES,
    // SFD_COPYMESSAGES,
    SFD_LAST
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT SelectFolderDialog(
    IN      HWND                hwnd,
    IN      DWORD               op,
    IN      FOLDERID            idCurrent,
    IN      FOLDERDIALOGFLAGS   dwFlags,
    IN_OPT  LPCSTR              pszTitle,
    IN_OPT  LPCSTR              pszText,
    OUT_OPT LPFOLDERID          pidSelected);

#endif // _INC_NEWFLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\newfldr.cpp ===
//--------------------------------------------------------------------------
// Newfldr.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "imagelst.h"
#include "newfldr.h"
#include <ourguid.h>
#include "conman.h"
#include "storutil.h"
#include "storecb.h"
#include "shlwapip.h" 
#include "instance.h"
#include "demand.h"

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define WM_SETFOLDERSELECT  (WM_USER + 1666)

//--------------------------------------------------------------------------
// SELECTFOLDER
//--------------------------------------------------------------------------
typedef struct tagSELECTFOLDER {
    DWORD               op;
    FOLDERID            idCurrent;      // Current Selected Folder
    FOLDERDIALOGFLAGS   dwFlags;        // Folder dialog flags
    LPSTR               pszTitle;       // Title of the dialog box
    LPSTR               pszText;        // Why are you asking for a folder
    FOLDERID            idSelected;     // The selected folder
    CTreeViewFrame     *pFrame;         // Treeview frame object

    BOOL                fPending;
    CStoreDlgCB        *pCallback;
    FOLDERID            idParent;
    char                szName[CCHMAX_FOLDER_NAME];
} SELECTFOLDER, *LPSELECTFOLDER;

//--------------------------------------------------------------------------
// NEWFOLDERDIALOGINIT
//--------------------------------------------------------------------------
typedef struct tagNEWFOLDERDIALOGINIT {
    IN  FOLDERID        idParent;
    OUT FOLDERID        idNew;
    
        BOOL            fPending;
    IN  CStoreDlgCB    *pCallback;
        char            szName[CCHMAX_FOLDER_NAME];
} NEWFOLDERDIALOGINIT, *LPNEWFOLDERDIALOGINIT;

//--------------------------------------------------------------------------
// SelectFolderDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK SelectFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT CreateNewFolder(HWND hwnd, LPCSTR pszName, FOLDERID idParent, LPFOLDERID pidNew, IStoreCallback *pCallback);
BOOL EnabledFolder(HWND hwnd, LPSELECTFOLDER pSelect, FOLDERID idFolder);
HRESULT GetCreatedFolderId(FOLDERID idParent, LPCSTR pszName, FOLDERID *pid);
BOOL SelectFolder_HandleCommand(HWND hwnd, WORD wID, LPSELECTFOLDER pSelect);
void SelectFolder_HandleStoreComplete(HWND hwnd, LPSELECTFOLDER pSelect);

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
static FOLDERID g_idPrevSel = FOLDERID_LOCAL_STORE;

//--------------------------------------------------------------------------
// SelectFolderDialog
//--------------------------------------------------------------------------
HRESULT SelectFolderDialog(
    IN      HWND                hwnd,
    IN      DWORD               op,
    IN      FOLDERID            idCurrent,
    IN      FOLDERDIALOGFLAGS   dwFlags,
    IN_OPT  LPCSTR              pszTitle,
    IN_OPT  LPCSTR              pszText,
    OUT_OPT LPFOLDERID          pidSelected)
{
    // Locals
    HRESULT         hr=S_OK;
    UINT            uAnswer;
    SELECTFOLDER    Select={0};

    // Trace
    TraceCall("SelectFolderDialog");

    // Invalid Args
    Assert(IsWindow(hwnd));
    Assert(((int) op) >= SFD_SELECTFOLDER && op < SFD_LAST);

    // Initialize Select Folder
    Select.op = op;
    if (SFD_MOVEFOLDER == op || (!!(dwFlags & FD_FORCEINITSELFOLDER) && FOLDERID_ROOT != idCurrent))
    {
        Assert(idCurrent != FOLDERID_INVALID);
        Select.idCurrent = idCurrent;
    }
    else
    {
        Select.idCurrent = g_idPrevSel;
    }
    Select.dwFlags = dwFlags | TREEVIEW_DIALOG;

    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
        Select.dwFlags |= TREEVIEW_NOIMAP | TREEVIEW_NOHTTP;

    Select.pszTitle = (LPSTR)pszTitle;
    Select.pszText = (LPSTR)pszText;
    Select.pCallback = new CStoreDlgCB;
    if (Select.pCallback == NULL)
        return(E_OUTOFMEMORY);

    // Create the Dialog Box
    if (IDOK != DialogBoxParam(g_hLocRes, ((op == SFD_NEWFOLDER) ? MAKEINTRESOURCE(iddCreateFolder) : MAKEINTRESOURCE(iddSelectFolder)), hwnd, SelectFolderDlgProc, (LPARAM)&Select))
    {
        hr = TraceResult(hrUserCancel);
        goto exit;
    }

    // Return selected folderid
    g_idPrevSel = Select.idSelected;
    if (pidSelected)
        *pidSelected = Select.idSelected;

exit:
    Select.pCallback->Release();

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// SelectFolderDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK SelectFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    FOLDERINFO              info;
    HRESULT                 hr;
    BOOL                    fEnable;
    LPSELECTFOLDER          pSelect;
    HWND                    hwndT;
    HWND                    hwndTree;
    CHAR                    sz[256];
    WORD                    wID;
    RECT                    rc;
    FOLDERID                id;
    NEWFOLDERDIALOGINIT     NewFolder;
    FOLDERINFO              Folder;
    CTreeView              *pTreeView;

    // Trace
    TraceCall("SelectFolderDlgProc");

    // Get pSelect
    pSelect = (LPSELECTFOLDER)GetWndThisPtr(hwnd);

    switch (msg)
    {
    case WM_INITDIALOG:
        // Better not have it yet
        Assert(NULL == pSelect);

        // Set pSelect
        pSelect = (LPSELECTFOLDER)lParam;

        // Set This pointer
        SetWndThisPtr(hwnd, (LPSELECTFOLDER)lParam);

        if (pSelect->op != SFD_SELECTFOLDER)
        {
            Assert(pSelect->pCallback != NULL);
            pSelect->pCallback->Initialize(hwnd);
        }

        if (pSelect->op == SFD_NEWFOLDER)
        {
            hwndT = GetDlgItem(hwnd, idcFolderEdit);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_FOLDER_NAME - 1, 0);
        }
        else if (ISFLAGSET(pSelect->dwFlags, FD_NONEWFOLDERS))
        {
            ShowWindow(GetDlgItem(hwnd, idcNewFolderBtn), SW_HIDE);
        }

        // Set the title
        if (pSelect->pszTitle != NULL)
        {
            // Must be a string resourceid
            if (IS_INTRESOURCE(pSelect->pszTitle))
            {
                // Load the String
                AthLoadString(PtrToUlong(pSelect->pszTitle), sz, ARRAYSIZE(sz));

                // Set Temp
                SetWindowText(hwnd, sz);
            }

            // Otherwise, just use the string
            else
                SetWindowText(hwnd, pSelect->pszTitle);
        }

        // Do we have some status text
        if (pSelect->pszText != NULL)
        {
            // Must be a resource string id
            if (IS_INTRESOURCE(pSelect->pszText))
            {
                // Load the String
                AthLoadString(PtrToUlong(pSelect->pszText), sz, ARRAYSIZE(sz));

                // Set Temp
                SetWindowText(GetDlgItem(hwnd, idcTreeViewText), sz);
            }

            // Otherwise, just use the string
            else
                SetWindowText(GetDlgItem(hwnd, idcTreeViewText), pSelect->pszText);
        }

        // Set the treeview font
        hwndT = GetDlgItem(hwnd, idcTreeView);
        Assert(hwndT != NULL);
        SetIntlFont(hwndT);
        GetWindowRect(hwndT, &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
        DestroyWindow(hwndT);

        // Create a Frame
        pSelect->pFrame = new CTreeViewFrame;
        if (NULL == pSelect->pFrame)
        {
            EndDialog(hwnd, IDCANCEL);
            return FALSE;
        }

        // Initialzie the tree view frame
        if (FAILED(pSelect->pFrame->Initialize(hwnd, &rc, (TREEVIEW_FLAGS & pSelect->dwFlags))))
        {
            EndDialog(hwnd, IDCANCEL);
            return FALSE;
        }

        // Get the Tree View Object from the Frame
        pTreeView = pSelect->pFrame->GetTreeView();

        // Get the Window Handle
        if (SUCCEEDED(pTreeView->GetWindow(&hwndTree)))
        {
            hwndT = GetDlgItem(hwnd, idcTreeViewText);
            SetWindowPos(hwndTree, hwndT, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_NOSIZE);
        }

        // Refresh the Treeview
        pTreeView->Refresh();

        // Set current selection
        if (FAILED(pTreeView->SetSelection(pSelect->idCurrent, 0)))
        {
            pSelect->idCurrent = g_idPrevSel;
            
            pTreeView->SetSelection(pSelect->idCurrent, 0);
        }

        // Center Myself
        CenterDialog(hwnd);

        // Done
        return(TRUE);           

    case WM_SETFOLDERSELECT:

        // Validate Params
        Assert(wParam != NULL && pSelect != NULL);

        // Get the Tree View Object
        pTreeView = pSelect->pFrame->GetTreeView();

        // Validate
        Assert(pTreeView != NULL);

        // Set current selection
        pTreeView->SetSelection((FOLDERID)wParam, 0);

        // Done
        return(TRUE);           

    case WM_STORE_COMPLETE:
        SelectFolder_HandleStoreComplete(hwnd, pSelect);
        return(TRUE);

    case WM_COMMAND:

        // Get the Command Id
        wID = LOWORD(wParam);

        return(SelectFolder_HandleCommand(hwnd, wID, pSelect));

    case TVM_SELCHANGED:

        // Possibly disable choosing the newly selected folder based on flags we were given
        fEnable = EnabledFolder(hwnd, pSelect, (FOLDERID)lParam);

        // Enable the OK Button
        EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);

        // Get the new folder button hwnd
        hwndT = GetDlgItem(hwnd, SFD_SELECTFOLDER == pSelect->op ? idcNewFolderBtn : IDOK);
        if (hwndT != NULL)
        {
            // Get Folder Info
            if (SUCCEEDED(g_pStore->GetFolderInfo((FOLDERID)lParam, &Folder)))
            {
                // fEnable
                fEnable = Folder.idFolder != FOLDERID_ROOT &&
                          Folder.tyFolder != FOLDER_NEWS &&
                          !ISFLAGSET(Folder.dwFlags, FOLDER_NOCHILDCREATE);

                // Enable/disable the window
                EnableWindow(hwndT, fEnable);

                // Free
                g_pStore->FreeRecord(&Folder);
            }
        }

        // Done
        return(TRUE);

    case TVM_DBLCLICK:
        // If Not Creating a Folder:
        if (pSelect->op != SFD_NEWFOLDER)    
        {
            // If the OK button isn't enabled, I can't select this folder
            if (FALSE == IsWindowEnabled(GetDlgItem(hwnd, IDOK)))
                return(TRUE);

            pTreeView = pSelect->pFrame->GetTreeView();

            id = pTreeView->GetSelection();

            hr = g_pStore->GetFolderInfo(id, &info);
            if (SUCCEEDED(hr))
            {
                if (!FHasChildren(&info, TRUE))
                    SelectFolder_HandleCommand(hwnd, IDOK, pSelect);

                g_pStore->FreeRecord(&info);
            }
        }
        // Done
        return(TRUE);

    case WM_DESTROY:

        // Close the Tree View
        if (pSelect != NULL && pSelect->pFrame != NULL)
        {
            // Close the TreeView
            pSelect->pFrame->CloseTreeView();

            // Release the Frame
            SideAssert(pSelect->pFrame->Release() == 0);
        }

        // Done
        return(TRUE);
    }

    // Done
    return(FALSE);
}

//--------------------------------------------------------------------------
// SelectFolderDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK NewFolderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    HRESULT                  hr;
    LPNEWFOLDERDIALOGINIT    pNew;
    WORD                     wID;
    FOLDERID                 id;
    HWND                     hwndEdit;

    // Trace
    TraceCall("NewFolderDlgProc");

    // Get This
    pNew = (LPNEWFOLDERDIALOGINIT)GetWndThisPtr(hwnd);

    // Handle the Message
    switch (msg)
    {
    case WM_INITDIALOG:

        // Shouldn't Have This
        Assert(pNew == NULL);

        // Set pNew
        pNew = (LPNEWFOLDERDIALOGINIT)lParam;

        // Set this Pointer
        SetWndThisPtr(hwnd, (LPNEWFOLDERDIALOGINIT)lParam);

        Assert(pNew->pCallback != NULL);
        pNew->pCallback->Initialize(hwnd);

        // Get the Folder Name Edit
        hwndEdit = GetDlgItem(hwnd, idtxtFolderName);

        // Correct for intl.
        SetIntlFont(hwndEdit);

        // Limit the text
        SendMessage(hwndEdit, EM_LIMITTEXT, CCHMAX_FOLDER_NAME - 1, 0);

        // Center
        CenterDialog(hwnd);

        // Done
        return(TRUE);

    case WM_STORE_COMPLETE:
        Assert(pNew->fPending);
        pNew->fPending = FALSE;

        hr = pNew->pCallback->GetResult();
        if (hr == S_FALSE)
        {
            EndDialog(hwnd, IDCANCEL);
        }
        else if (SUCCEEDED(hr))
        {
            hr = GetCreatedFolderId(pNew->idParent, pNew->szName, &id);
            if (SUCCEEDED(hr))
                pNew->idNew = id;
            else
                pNew->idNew = pNew->idParent;
            EndDialog(hwnd, IDOK);
        }
        else
        {
            // No need to put up error dialog, CStoreDlgCB already did this on failed OnComplete
            hwndEdit = GetDlgItem(hwnd, idtxtFolderName);
            SendMessage(hwndEdit, EM_SETSEL, 0, -1);
            SetFocus(hwndEdit);
        }
        return(TRUE);

    case WM_COMMAND:

        // Get the Command Id
        wID = LOWORD(wParam);

        // Handle the Command
        switch (wID)
        {
        case IDOK:
            if (pNew->fPending)
                return(TRUE);

            Assert(pNew->pCallback != NULL);
            pNew->pCallback->Reset();

            hwndEdit = GetDlgItem(hwnd, idtxtFolderName);
            GetWindowText(hwndEdit, pNew->szName, ARRAYSIZE(pNew->szName));

            // Try to Create the Folder
            hr = CreateNewFolder(hwnd, pNew->szName, pNew->idParent, &pNew->idNew, (IStoreCallback *)pNew->pCallback);
            if (hr == E_PENDING)
            {
                pNew->fPending = TRUE;
                break;
            }
            else if (FAILED(hr))
            {
                AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCreateNewFld), hr);
                SendMessage(hwndEdit, EM_SETSEL, 0, -1);
                SetFocus(hwndEdit);
                break;
            }

            // End the dialog
            EndDialog(hwnd, IDOK);

            // done
            return(TRUE);

        case IDCANCEL:

            if (pNew->fPending)
                pNew->pCallback->Cancel();
            else    
                // End the dialog
                EndDialog(hwnd, IDCANCEL);

            // Done
            return(TRUE);
        }

        // Done
        break;
    }

    // Done
    return(FALSE);
}

//--------------------------------------------------------------------------
// CreateNewFolder
//--------------------------------------------------------------------------
HRESULT CreateNewFolder(HWND hwnd, LPCSTR pszName, FOLDERID idParent, LPFOLDERID pidNew, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr;
    ULONG           cchFolder;
    FOLDERINFO      Folder;

    // Trace
    TraceCall("CreateNewFolder");

    Assert(pCallback != NULL);

    // Get Text Length
    cchFolder = lstrlen(pszName);

    // Invalid
    if (0 == cchFolder)
        return(STORE_E_BADFOLDERNAME);

    // Filup the Folder Info
    ZeroMemory(&Folder, sizeof(FOLDERINFO));
    Folder.idParent = idParent;
    Folder.tySpecial = FOLDER_NOTSPECIAL;
    Folder.pszName = (LPSTR)pszName;
    Folder.dwFlags = FOLDER_SUBSCRIBED;

    // Create the Folder
    hr = g_pStore->CreateFolder(NOFLAGS, &Folder, pCallback);
    if (hr == E_PENDING)
        return(hr);

    // Return the Folder Id
    if (pidNew)
        *pidNew = Folder.idFolder;

    // Done
    return (hr);
}

//--------------------------------------------------------------------------
// EnabledFolder
//--------------------------------------------------------------------------
BOOL EnabledFolder(HWND hwnd, LPSELECTFOLDER pSelect, FOLDERID idFolder)
{
    // Locals
    BOOL fRet = FALSE;
    FOLDERINFO Folder;

    // Trace
    TraceCall("EnabledFolder");

    // Get Folder Info
    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        goto exit;

    // FD_DISABLEROOT
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLEROOT) && FOLDERID_ROOT == idFolder)
        goto exit;

    // FD_DISABLEINBOX
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLEINBOX) && FOLDER_INBOX == Folder.tySpecial)
        goto exit;

    // FD_DISABLEOUTBOX
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLEOUTBOX) && FOLDER_OUTBOX == Folder.tySpecial)
        goto exit;

    // FD_DISABLESENTITEMS
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLESENTITEMS) && FOLDER_SENT == Folder.tySpecial)
        goto exit;

    // FD_DISABLESERVERS
    if (ISFLAGSET(pSelect->dwFlags, FD_DISABLESERVERS) && ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        goto exit;

    fRet = TRUE;

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Default
    return fRet;
}

HRESULT GetCreatedFolderId(FOLDERID idParent, LPCSTR pszName, FOLDERID *pid)
{
    HRESULT hr;
    HLOCK hLock;
    FOLDERINFO Folder = {0};

    Assert(pszName != NULL);
    Assert(pid != NULL);

    hr = g_pStore->Lock(&hLock);
    if (FAILED(hr))
        return(hr);

    Folder.idParent = idParent;
    Folder.pszName = (LPSTR)pszName;

    if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        *pid = Folder.idFolder;

        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        hr = E_FAIL;
    }

    g_pStore->Unlock(&hLock);

    return(hr);
}

BOOL SelectFolder_HandleCommand(HWND hwnd, WORD wID, LPSELECTFOLDER pSelect)
{
    HRESULT                 hr;
    HWND                    hwndT;
    FOLDERID                id=FOLDERID_INVALID;
    NEWFOLDERDIALOGINIT     NewFolder;
    CTreeView              *pTreeView;

    switch (wID)
    {
        case idcNewFolderBtn:
            pTreeView = pSelect->pFrame->GetTreeView();

            ZeroMemory(&NewFolder, sizeof(NEWFOLDERDIALOGINIT));
            NewFolder.idParent = pTreeView->GetSelection();
            NewFolder.pCallback = new CStoreDlgCB;
            if (NewFolder.pCallback == NULL)
                // TODO: an error message might be helpful
                return(TRUE);

            // Launch the dialog to create a new folder
            if (IDOK == DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddNewFolder), hwnd, NewFolderDlgProc, (LPARAM)&NewFolder))
            {
                // Select the new folder
                PostMessage(hwnd, WM_SETFOLDERSELECT, (WPARAM)NewFolder.idNew, 0);
            }

            NewFolder.pCallback->Release();
            return(TRUE);

        case IDOK:
            if (pSelect->fPending)
                return(TRUE);

            pTreeView = pSelect->pFrame->GetTreeView();

            pSelect->idSelected = pTreeView->GetSelection();

            switch (pSelect->op)
            {
                case SFD_SELECTFOLDER:
                    break;

                case SFD_NEWFOLDER:
                    Assert(pSelect->pCallback != NULL);
                    pSelect->pCallback->Reset();

                    hwndT = GetDlgItem(hwnd, idcFolderEdit);
                    GetWindowText(hwndT, pSelect->szName, ARRAYSIZE(pSelect->szName));

                    hr = CreateNewFolder(hwnd, pSelect->szName, pSelect->idSelected, &id, (IStoreCallback *)pSelect->pCallback);
                    if (hr == E_PENDING)
                    {
                        pSelect->fPending = TRUE;
                        pSelect->idParent = pSelect->idSelected;
                        return(TRUE);
                    }
                    else if (STORE_S_ALREADYEXISTS == hr)
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCreateExists), 0, MB_OK | MB_ICONEXCLAMATION);
                        SendMessage(hwndT, EM_SETSEL, 0, -1);
                        SetFocus(hwndT);
                        return(TRUE);
                    }
                    else if (FAILED(hr))
                    {
                        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCreateNewFld), hr);
                        SendMessage(hwndT, EM_SETSEL, 0, -1);
                        SetFocus(hwndT);
                        return(TRUE);
                    }
        
                    pSelect->idSelected = id;
                    break;

                case SFD_MOVEFOLDER:
                    Assert(pSelect->pCallback != NULL);
                    pSelect->pCallback->Reset();

                    hr = g_pStore->MoveFolder(pSelect->idCurrent, pSelect->idSelected, 0, (IStoreCallback *)pSelect->pCallback);
                    if (hr == E_PENDING)
                    {
                        pSelect->fPending = TRUE;
                        return(TRUE);
                    }
                    else if (FAILED(hr))
                    {
                        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrFolderMove), hr);
                        return(TRUE);
                    }
        
                    pSelect->idSelected = id;
                    break;

                default:
                    Assert(FALSE);
                    break;
            }

            EndDialog(hwnd, IDOK);
            return(TRUE);

        case IDCANCEL:
            if (pSelect->fPending)
                pSelect->pCallback->Cancel();
            else
                EndDialog(hwnd, IDCANCEL);
            return(TRUE);
            
        default:
            break;
    }

    return(FALSE);
}

void SelectFolder_HandleStoreComplete(HWND hwnd, LPSELECTFOLDER pSelect)
{
    HRESULT hr;
    FOLDERID id;
    HWND hwndT;

    Assert(pSelect->op != SFD_SELECTFOLDER);
    Assert(pSelect->fPending);
    pSelect->fPending = FALSE;

    hr = pSelect->pCallback->GetResult();
    if (hr == S_FALSE)
    {
        EndDialog(hwnd, IDCANCEL);
        return;
    }

    switch (pSelect->op)
    {
        case SFD_NEWFOLDER:
            if (SUCCEEDED(hr))
            {
                hr = GetCreatedFolderId(pSelect->idParent, pSelect->szName, &id);
                if (SUCCEEDED(hr))
                    pSelect->idSelected = id;
                else
                    pSelect->idSelected = pSelect->idParent;
                EndDialog(hwnd, IDOK);
            }
            else
            {
                // No need to put up error dialog, CStoreDlgCB already did this on failed OnComplete
                hwndT = GetDlgItem(hwnd, idcFolderEdit);
                SendMessage(hwndT, EM_SETSEL, 0, -1);
                SetFocus(hwndT);
            }
            break;

        case SFD_MOVEFOLDER:
            if (SUCCEEDED(hr))
            {
                pSelect->idSelected = pSelect->idCurrent;
                EndDialog(hwnd, IDOK);
            }
            else if (FAILED(hr))
            {
                AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrFolderMove), hr);
            }
            break;

        default:
            Assert(FALSE);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\playback.h ===
#ifndef _INC_PLAYBACK_H
#define _INC_PLAYBACK_H

class COfflinePlayback : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE );
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        COfflinePlayback(void);
        ~COfflinePlayback(void);

        HRESULT DoPlayback(HWND hwnd, IDatabase *pDB, FOLDERID *pid, DWORD cid, FOLDERID idFolderSel);

        static INT_PTR CALLBACK PlaybackDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    private:
        HRESULT _DoNextOperation(void);
        HRESULT _DoSetPropOp(SYNCOPINFO *pInfo);
        HRESULT _DoCreateOp(SYNCOPINFO *pInfo);
        HRESULT _DoDeleteOp(SYNCOPINFO *pInfo);
        HRESULT _DoCopyOp(SYNCOPINFO *pInfo);

        HRESULT _HandleSetPropComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);
        HRESULT _HandleCreateComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);
        HRESULT _HandleDeleteComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);
        HRESULT _HandleCopyComplete(HRESULT hrOperation, SYNCOPINFO *pInfo);

        ULONG               m_cRef;
        HRESULT             m_hr;
        HWND                m_hwndDlg;
        BOOL                m_fComplete;
        STOREOPERATIONTYPE  m_type;
        IOperationCancel   *m_pCancel;
        HTIMEOUT            m_hTimeout;

        DWORD               m_cMovedToErrors;
        DWORD               m_cFailures;

        IDatabase          *m_pDB;

        FOLDERID           *m_pid;
        DWORD               m_iid;
        DWORD               m_cid;
        FOLDERID            m_idFolderSel;
        BOOL                m_fSyncSel;

        FOLDERID            m_idServer;
        FOLDERID            m_idFolder;
        IMessageServer     *m_pServer;
        IMessageFolder     *m_pLocalFolder;
        DWORD               m_iOps;
        DWORD               m_cOps;
        CEnumerateSyncOps  *m_pEnum;
        SYNCOPID            m_idOperation;

        IMessageFolder     *m_pFolderDest; // for copy and move
};

#endif // _INC_PLAYBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\store.h ===
//--------------------------------------------------------------------------
// Store.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "dbimpl.h"

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CProgress;
interface IImnAccountManager;

//--------------------------------------------------------------------------
// SERVERFOLDER
//--------------------------------------------------------------------------
typedef struct tagSERVERFOLDER *LPSERVERFOLDER;
typedef struct tagSERVERFOLDER {
    FOLDERID        idServer;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    FOLDERID        rgidSpecial[FOLDER_MAX];
    LPSERVERFOLDER  pNext;
} SERVERFOLDER;

//--------------------------------------------------------------------------
// CMessageStore
//--------------------------------------------------------------------------
class CMessageStore : public IMessageStore, public IDatabaseExtension
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CMessageStore(BOOL fMigrate);
    ~CMessageStore(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageStore Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(LPCSTR pszDirectory);
    STDMETHODIMP Validate(DWORD dwReserved);
    STDMETHODIMP GetDirectory(LPSTR pszDirectory, DWORD cchMaxDir);
    STDMETHODIMP Synchronize(FOLDERID idFolder, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP FindServerId(LPCSTR pszAcctId, LPFOLDERID pidStore);
    STDMETHODIMP CreateServer(IImnAccount *pAcct, FLDRFLAGS dwFlags, LPFOLDERID pidFolder);
    STDMETHODIMP CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, LPFOLDERINFO pInfo, IStoreCallback *pCallback);
    STDMETHODIMP OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer, SPECIALFOLDER tySpecial, IMessageFolder **ppFolder);
    STDMETHODIMP OpenFolder(FOLDERID idFolder, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo);
    STDMETHODIMP GetSpecialFolderInfo(FOLDERID idStore, SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP UpdateFolderCounts(FOLDERID idFolder, LONG lMsgs, LONG lUnread, LONG lWatchedUnread, LONG lWatched);
    STDMETHODIMP EnumChildren(FOLDERID idParent, BOOL fSubscribed, IEnumerateFolders **ppEnum);
    STDMETHODIMP GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IDatabaseExtension Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IDatabase *pDB);
    STDMETHODIMP OnLock(void);
    STDMETHODIMP OnUnlock(void);
    STDMETHODIMP OnRecordInsert(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnRecordUpdate(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew);
    STDMETHODIMP OnRecordDelete(OPERATIONSTATE tyState, LPORDINALLIST pOrdinals, LPVOID pRecord);
    STDMETHODIMP OnExecuteMethod(METHODID idMethod, LPVOID pBinding, LPDWORD pdwResult);

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(FALSE, m_pDB);

    //----------------------------------------------------------------------
    // MigrateToDBX
    //----------------------------------------------------------------------
    HRESULT MigrateToDBX(void);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _ComputeMessageCounts(IDatabase *pDB, LPDWORD pcMsgs, LPDWORD pcUnread);
    HRESULT _DeleteSiblingsAndChildren(LPFOLDERINFO pParent);
    HRESULT _InternalDeleteFolder(LPFOLDERINFO pDelete);
    HRESULT _InsertFolderFromFile(LPCSTR pszAcctId, LPCSTR pszFile);
    HRESULT _ValidateServer(LPFOLDERINFO pServer);
    HRESULT _DeleteFolderFile(LPFOLDERINFO pFolder);
    HRESULT _MakeUniqueFolderName(FOLDERID idParent, LPCSTR pszOriginalName, LPSTR *ppszNewName);
    HRESULT _CountDeleteChildren(FOLDERID idParent, LPDWORD pcChildren);
    HRESULT _ValidateSpecialFolders(LPFOLDERINFO pServer);
    HRESULT _LoadServerTable(HLOCK hLock);
    HRESULT _FreeServerTable(HLOCK hLock);
    HRESULT _GetSpecialFolderId(FOLDERID idStore, SPECIALFOLDER tySpecial, LPFOLDERID pidFolder);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    LPSTR               m_pszDirectory; // Current Store Directory
    IDatabase          *m_pDB;          // Database Table
    IDatabaseSession   *m_pSession;     // Local Session if store is running as inproc server
    IImnAccountManager2 *m_pActManRel;  // Used for migration
    BOOL                m_fMigrate;     // Created Precisely for Migration
    LPSERVERFOLDER      m_pServerHead;  // List of Cached Server Nodes and their special folders...
};

//--------------------------------------------------------------------------
// ProtoTypes
//--------------------------------------------------------------------------
HRESULT CreateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT CreateMigrateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT CreateFolderDatabaseExt(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\storecb.h ===
#ifndef _INC_STORECB
#define _INC_STORECB

#include "storutil.h"

HRESULT CopyMessagesProgress(HWND hwnd, IMessageFolder *pFolder, IMessageFolder *pDest,
    COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags);
HRESULT MoveFolderProgress(HWND hwnd, FOLDERID idFolder, FOLDERID idParentNew);
HRESULT DeleteFolderProgress(HWND hwnd, FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags);
HRESULT DeleteMessagesProgress(HWND hwnd, IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList);
HRESULT RenameFolderProgress(HWND hwnd, FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags);
HRESULT SetMessageFlagsProgress(HWND hwnd, IMessageFolder *pFolder, LPADJUSTFLAGS pFlags, LPMESSAGEIDLIST pList);

#define WM_STORE_COMPLETE   (WM_USER + 666)
#define WM_STORE_PROGRESS   (WM_USER + 667)

class CStoreCB : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServer);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        virtual HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CStoreCB();
        ~CStoreCB();

        HRESULT Initialize(HWND hwnd, LPCSTR pszText, BOOL fProgress);
        HRESULT Block(void);
        HRESULT Close(void);
        HRESULT Reset(void);

        static INT_PTR CALLBACK StoreCallbackDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    private:

        void    _ShowDlg(void);

        ULONG       m_cRef;
        HRESULT     m_hr;
        HWND        m_hwndParent;
        HWND        m_hwndDlg;
        HWND        m_hwndProg;
        BOOL        m_fComplete;
        HCURSOR     m_hcur;
        UINT_PTR    m_uTimer;
        LPSTR       m_pszText;
        BOOL        m_fProgress;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        HTIMEOUT    m_hTimeout;
};

class CStoreDlgCB : public IStoreCallback, public ITimeoutCallback
{
    public:
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        virtual HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CStoreDlgCB(void);
        ~CStoreDlgCB(void);

        void Initialize(HWND hwndDlg);
        void Reset(void);
        void Cancel(void);
        HRESULT GetResult(void);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        HWND        m_hwndDlg;
        BOOL        m_fComplete;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        HTIMEOUT    m_hTimeout;
};

#endif // _INC_STORECB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\storecb.cpp ===
#include "pch.hxx"
#include "storecb.h"
#include "storutil.h"
#include <progress.h>

HRESULT CopyMessagesProgress(HWND hwnd, IMessageFolder *pFolder, IMessageFolder *pDest,
    COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags)
{
    CStoreCB *pCB;
    HRESULT hr;

    Assert(pFolder != NULL);

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, !!(dwFlags & COPY_MESSAGE_MOVE) ? MAKEINTRESOURCE(idsMovingMessages) : MAKEINTRESOURCE(idsCopyingMessages), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pFolder->CopyMessages(pDest, dwFlags, pList, pFlags, NULL, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT MoveFolderProgress(HWND hwnd, FOLDERID idFolder, FOLDERID idParentNew)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsMovingFolder), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->MoveFolder(idFolder, idParentNew, 0, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT DeleteFolderProgress(HWND hwnd, FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsDeletingFolder), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->DeleteFolder(idFolder, dwFlags, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT DeleteMessagesProgress(HWND hwnd, IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList)
{
    CStoreCB *pCB;
    HRESULT hr;

    Assert(pFolder != NULL);

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, !!(dwOptions & DELETE_MESSAGE_UNDELETE) ? MAKEINTRESOURCE(idsUndeletingMessages) : MAKEINTRESOURCE(idsDeletingMessages), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pFolder->DeleteMessages(dwOptions, pList, NULL, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT RenameFolderProgress(HWND hwnd, FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsRenamingFolder), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->RenameFolder(idFolder, pszName, dwFlags, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT SetMessageFlagsProgress(HWND hwnd, IMessageFolder *pFolder, LPADJUSTFLAGS pFlags, LPMESSAGEIDLIST pList)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsSettingMessageFlags), FALSE);
    if (SUCCEEDED(hr))
    {
        hr = pFolder->SetMessageFlags(pList, pFlags, NULL, (IStoreCallback *)pCB);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

CStoreCB::CStoreCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndParent = NULL;
    m_hwndDlg = NULL;
    m_hwndProg = NULL;
    m_fComplete = FALSE;
    m_fProgress = TRUE;
    m_pszText = NULL;
    m_hcur = NULL;
    m_uTimer = 0;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;
}

CStoreCB::~CStoreCB()
{
    Assert(m_hwndDlg == NULL);
    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();
    if (m_pszText != NULL)
        MemFree(m_pszText);
}

HRESULT STDMETHODCALLTYPE CStoreCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CStoreCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CStoreCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CStoreCB::Initialize(HWND hwnd, LPCSTR pszText, BOOL fProgress)
{
    HWND hwndT;

    // Replace hwnd with top-most parent: this ensures modal behaviour (all windows disabled)
    hwnd = GetTopMostParent(hwnd);
    m_hwndParent = hwnd;

    if (IS_INTRESOURCE(pszText))
        m_pszText = AthLoadString(PtrToUlong(pszText), 0, 0);
    else
        m_pszText = PszDup(pszText);
    if (m_pszText == NULL)
        return(E_OUTOFMEMORY);

    m_fProgress = fProgress;

    hwndT = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddCopyMoveMessages), hwnd, StoreCallbackDlgProc, (LPARAM)this);
    if (hwndT == NULL)
        return(E_FAIL);

    EnableWindow(hwnd, FALSE);
    m_hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    return(S_OK);
}

HRESULT CStoreCB::Reset()
{
    m_fComplete = FALSE;

    return(S_OK);
}

HRESULT CStoreCB::Block()
{
    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
        {
        if (m_hcur)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        if (m_fComplete)
            break;
        }    

    return(m_hr);
}

HRESULT CStoreCB::Close()
{
    if (m_hcur != NULL)
        SetCursor(m_hcur);
    EnableWindow(m_hwndParent, TRUE);
    Assert(m_hwndDlg != NULL);
    DestroyWindow(m_hwndDlg);

    return(S_OK);
}

void CStoreCB::_ShowDlg()
{
    if (m_uTimer != 0)
    {
        KillTimer(m_hwndDlg, m_uTimer);
        m_uTimer = 0;

        ShowWindow(m_hwndDlg, SW_SHOW);

        if (m_hcur != NULL)
        {
            SetCursor(m_hcur);
            m_hcur = NULL;
        }
    }
}

HRESULT CStoreCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (0 == dwMax)
    {
        // dwMax can be 0 if we have to re-connect to the server (SOT_CONNECTION_STATUS progress)
        TraceInfo(_MSG("CStoreCB::OnProgress bailing on %s progress with dwMax = 0",
            sotToSz(tyOperation)));
        return S_OK;
    }

    if (m_hwndProg != NULL)
        SendMessage(m_hwndProg, PBM_SETPOS, (dwCurrent * 100) / dwMax, 0);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwnd;

    GetParentWindow(0, &hwnd);

    return CallbackCanConnect(pszAccountId, hwnd,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    GetParentWindow(0, &hwnd);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_hr = hrComplete;
    m_fComplete = TRUE;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        _ShowDlg();
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    GetParentWindow(0, &hwnd);

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CStoreCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    _ShowDlg();
    *phwndParent = m_hwndDlg;

    return(S_OK);
}

INT_PTR CALLBACK CStoreCB::StoreCallbackDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CStoreCB       *pThis = (CStoreCB *)GetWindowLongPtr(hwnd, DWLP_USER);
        
    switch (uMsg)
    {
        case WM_INITDIALOG:
            Assert(lParam);
            pThis = (CStoreCB *)lParam;

            pThis->m_hwndDlg = hwnd;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            pThis->m_hwndProg = GetDlgItem(pThis->m_hwndDlg, idcProgBar);
            Assert(pThis->m_hwndProg != NULL);
            if (!pThis->m_fProgress)
            {
                ShowWindow(pThis->m_hwndProg, SW_HIDE);
                pThis->m_hwndProg = NULL;
            }

            CenterDialog(hwnd);

            SetDlgItemText(hwnd, idcStatic1, pThis->m_pszText);

            ShowWindow(hwnd, SW_HIDE);
            pThis->m_uTimer = SetTimer(hwnd, 666, 2000, NULL);
            break;

        case WM_TIMER:
            pThis->_ShowDlg();
            break;

        case WM_COMMAND:
            Assert(pThis != NULL);

            if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
            {   
                if (pThis->m_pCancel != NULL)
                    pThis->m_pCancel->Cancel(CT_CANCEL);

                return(TRUE);
            }
            break;

        case WM_DESTROY:
            if (pThis->m_uTimer != 0)
            {
                KillTimer(hwnd, pThis->m_uTimer);
                pThis->m_uTimer = 0;
            }
            pThis->m_hwndDlg = NULL;
            break;
    }
    
    return(0);    
}

CStoreDlgCB::CStoreDlgCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwndDlg = NULL;
    m_fComplete = TRUE;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_hTimeout = NULL;
}

CStoreDlgCB::~CStoreDlgCB()
{
    CallbackCloseTimeout(&m_hTimeout);
    if (m_pCancel != NULL)
        m_pCancel->Release();
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CStoreDlgCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CStoreDlgCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

void CStoreDlgCB::Initialize(HWND hwnd)
{
    Assert(hwnd != NULL);
    // Should be OK to Re-initilize
    //Assert(m_hwndDlg == NULL);

    m_hwndDlg = hwnd;
}

void CStoreDlgCB::Reset()
{
    Assert(m_hwndDlg != NULL);

    m_hr = E_FAIL;
    m_fComplete = FALSE;
}

void CStoreDlgCB::Cancel()
{
    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_CANCEL);
}

HRESULT CStoreDlgCB::GetResult()
{
    Assert(m_fComplete);
    return(m_hr);
}

HRESULT CStoreDlgCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(tyOperation != SOT_INVALID);
    Assert(m_pCancel == NULL);

    m_type = tyOperation;
    m_fComplete = FALSE;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    Assert(m_hwndDlg != NULL);
    Assert(!m_fComplete);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // If numbers > 16 bits, scale the progress to fit within 16-bit.
    // I'd like to avoid using floating-point, so let's use an integer algorithm
    // I'll just multiply numerator and denominator by 0.5 until we fit in 16 bits
    while (dwMax > 65535)
    {
        dwCurrent >>= 1;
        dwMax >>= 1;
    }

    PostMessage(m_hwndDlg, WM_STORE_PROGRESS, (DWORD)tyOperation, MAKELONG(dwMax, dwCurrent));
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwndParent;
    DWORD   dwReserved = 0;

    GetParentWindow(dwReserved, &hwndParent);

    return CallbackCanConnect(pszAccountId, hwndParent,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndDlg, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    Assert(m_hwndDlg != NULL);
    AssertSz(m_type != SOT_INVALID, "somebody isn't calling OnBegin");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_type != tyOperation)
        return(S_OK);

    m_fComplete = TRUE;
    m_hr = hrComplete;

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // If error occurred, display the error
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndDlg, hrComplete, pErrorInfo);
    }

    PostMessage(m_hwndDlg, WM_STORE_COMPLETE, hrComplete, (DWORD)tyOperation);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndDlg, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CStoreDlgCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwndDlg != NULL);

    *phwndParent = m_hwndDlg;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\store.cpp ===
//--------------------------------------------------------------------------
// Store.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "Store.h"
#include "msgfldr.h"
#include "storfldr.h"
#include "storutil.h"
#include "enumfold.h"
#include "findfold.h"
#include "shared.h"
#include <msident.h>
#include "acctutil.h"
#include "xpcomm.h"
#include "multiusr.h"

//--------------------------------------------------------------------------
// CreateMessageStore
//--------------------------------------------------------------------------
static const char c_szSubscribedFilter[] = "(FLDCOL_FLAGS & FOLDER_SUBSCRIBED)";
                                      
//--------------------------------------------------------------------------
// CreateMessageStore
//--------------------------------------------------------------------------
HRESULT CreateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CMessageStore      *pNew;

    // Trace
    TraceCall("CreateMessageStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    IF_NULLEXIT(pNew = new CMessageStore(FALSE));

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMessageStore *);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CreateFolderDatabaseExt
//--------------------------------------------------------------------------
HRESULT CreateFolderDatabaseExt(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateFolderDatabaseExt");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageStore *pNew = new CMessageStore(FALSE);
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IDatabaseExtension *);

    // Done
    return(S_OK);
}


//--------------------------------------------------------------------------
// CreateMigrateMessageStore
//--------------------------------------------------------------------------
HRESULT CreateMigrateMessageStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CMessageStore      *pNew;

    // Trace
    TraceCall("CreateMigrateMessageStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    IF_NULLEXIT(pNew = new CMessageStore(TRUE));

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMessageStore *);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::CMessageStore
//--------------------------------------------------------------------------
CMessageStore::CMessageStore(BOOL fMigrate/*=FALSE*/) : m_fMigrate(fMigrate)
{
    TraceCall("CMessageStore::CMessageStore");
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_pszDirectory = NULL;
    m_pDB = NULL;
    m_pSession = NULL;
    m_pActManRel = NULL;
    m_pServerHead = NULL;
}

//--------------------------------------------------------------------------
// CMessageStore::~CMessageStore
//--------------------------------------------------------------------------
CMessageStore::~CMessageStore(void)
{
    // Trace
    TraceCall("CMessageStore::~CMessageStore");

    // Was this a Migrate Session ?
    if (m_fMigrate)
    {
        // Must have m_pUnkRelease
        Assert(g_pAcctMan == m_pActManRel && g_pStore == this);

        // Cleanup
        SafeRelease(m_pActManRel);

        // Clear
        g_pAcctMan = NULL;

        // Clear g_pStore
        g_pStore = NULL;
    }

    // Validate
    Assert(NULL == m_pActManRel);

    // Free Directory
    SafeMemFree(m_pszDirectory);

    // Free Database Table
    SafeRelease(m_pDB);

    // If I have a private session
    if (m_pSession)
    {
        // Must be the same as the global
        Assert(m_pSession == g_pDBSession);

        // Release Session
        m_pSession->Release();

        // Set to Null
        g_pDBSession = m_pSession = NULL;
    }

    // Free m_pServerHead
    LPSERVERFOLDER pCurrent = m_pServerHead;
    LPSERVERFOLDER pNext;

    // While Current
    while(pCurrent)
    {
        // Set Next
        pNext = pCurrent->pNext;

        // Free
        g_pMalloc->Free(pCurrent);

        // Goto next
        pCurrent = pNext;
    }
   
    // Release the Dll
    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CMessageStore::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CMessageStore::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMessageStore *)this;
    else if (IID_IMessageStore == riid)
        *ppv = (IMessageStore *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IDatabaseExtension == riid)
        *ppv = (IDatabaseExtension *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageStore::AddRef(void)
{
    TraceCall("CMessageStore::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CMessageStore::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageStore::Release(void)
{
    TraceCall("CMessageStore::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CMessageStore::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::Initialize(LPCSTR pszDirectory)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    TABLEINDEX      Index;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    STOREUSERDATA   UserData={0};
    LPSTR           pszFilter=NULL;

    // Trace
    TraceCall("CMessageStore::Initialize");

    // Invalid Args
    if (NULL == pszDirectory)
        return TraceResult(E_INVALIDARG);

    // Make sure the directory exists
    if (FALSE == PathIsDirectory(pszDirectory))
    {
        // It doesn't, so create it
        IF_FAILEXIT(hr = OpenDirectory((LPTSTR)pszDirectory));
    }

    // Save the directory
    IF_NULLEXIT(m_pszDirectory = PszDupA(pszDirectory));

    // Build Path to Folders
    IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, c_szFoldersFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

    // If we have g_pDBSession, then use it, otherwise, get one...(happens on store migration)
    if (NULL == g_pDBSession)
    {
        // Create the Session
        IF_FAILEXIT(hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&g_pDBSession));

        // I should release this..;
        m_pSession = g_pDBSession;
    }
        
    // Create an Object Database
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NOADDREFEXT, &g_FolderTableSchema, (IDatabaseExtension *)this, &m_pDB));

    // set Folder
    Folder.idFolder = FOLDERID_ROOT;

    // Is there a root folder ?
    if (DB_S_NOTFOUND == m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Folder, NULL))
    {
        // Locals
        DWORD           idReserved;
        CHAR            szRes[100];

        // Reset the Cache
        IF_FAILEXIT(hr = DeleteAllRecords(&g_FolderTableSchema, m_pDB, NULL));

        // Create the idParent / FolderName Index
        IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_ALL, NULL, &g_FolderNameIndex));

        // Create the idParent / FolderName Index
        IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_SUBSCRIBED, c_szSubscribedFilter, &g_FolderNameIndex));

        // Insert the Root Folder
        Folder.idParent = FOLDERID_INVALID;

        // Set clsidType
        Folder.tyFolder = FOLDER_ROOTNODE;

        // Insert the Root
        Folder.tySpecial = FOLDER_NOTSPECIAL;

        // Load String
        LoadString(g_hLocRes, idsAthena, szRes, ARRAYSIZE(szRes));

        // Get the Name of the Root
        Folder.pszName = szRes;

        // Insert the Record
        IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

        // Generate a couple of ids to prevent collision
        m_pDB->GenerateId(&idReserved);
        m_pDB->GenerateId(&idReserved);

        // Create Time
        GetSystemTimeAsFileTime(&UserData.ftCreated);

        // Don't need to convert to DBX
        UserData.fConvertedToDBX = TRUE;

        // Set the UserData
        IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(STOREUSERDATA)));
    }

    // Otherwise, verify the IINDEX_NAME index
    else
    {
        // Locals
        BOOL fReset=FALSE;

        // Create the idParent / FolderName Index
        if (FAILED(m_pDB->GetIndexInfo(IINDEX_ALL, NULL, &Index)))
            fReset = TRUE;

        // If still noreset, see of indexes are the same
        else if (S_FALSE == CompareTableIndexes(&Index, &g_FolderNameIndex))
            fReset = TRUE;

        // Change the Index
        if (fReset)
        {
            // Create the idParent / FolderName Index
            IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_ALL, NULL, &g_FolderNameIndex));
        }

        // Not Reset
        fReset = FALSE;

        // Create the idParent / FolderName Index
        if (FAILED(m_pDB->GetIndexInfo(IINDEX_SUBSCRIBED, &pszFilter, &Index)))
            fReset = TRUE;

        // If still noreset, see of indexes are the same
        else if (S_FALSE == CompareTableIndexes(&Index, &g_FolderNameIndex))
            fReset = TRUE;

        // If still noreset, see if the filter is different
        else if (NULL == pszFilter || lstrcmpi(pszFilter, c_szSubscribedFilter) != 0)
            fReset = TRUE;

        // Change the Index
        if (fReset)
        {
            // Create the idParent / FolderName Index
            IF_FAILEXIT(hr = m_pDB->ModifyIndex(IINDEX_SUBSCRIBED, c_szSubscribedFilter, &g_FolderNameIndex));
        }
    }

    // If this object is being used for migration
    if (m_fMigrate)
    {
        // Validate
        Assert(NULL == g_pStore && NULL == g_pAcctMan);

        // Create manager for ID
        hr = AcctUtil_CreateAccountManagerForIdentity(PGUIDCurrentOrDefault(), &m_pActManRel);

        // Try Something Else
        if (FAILED(hr))
            hr = AcctUtil_CreateAccountManagerForIdentity((GUID *)&UID_GIBC_DEFAULT_USER, &m_pActManRel);

        // Failure
        if (FAILED(hr))
            goto exit;

        // Set Global
        g_pAcctMan = m_pActManRel;

        // Set g_pStore
        g_pStore = this;
    }

exit:
    // Cleanup
    if (m_pDB)
        m_pDB->FreeRecord(&Folder);
    SafeMemFree(pszFilter);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::MigrateToDBX
//--------------------------------------------------------------------------
HRESULT CMessageStore::MigrateToDBX(void)
{
    // Locals
    HRESULT         hr=S_OK;
    STOREUSERDATA   UserData;

    // Get the User Data
    if(m_pDB == NULL)
        return(E_OUTOFMEMORY);

    IF_FAILEXIT(hr = m_pDB->GetUserData(&UserData, sizeof(STOREUSERDATA)));

    // ConvertedToDBX ?
    if (UserData.fConvertedToDBX)
        goto exit;

    // Convert to DBX
    IF_FAILEXIT(hr = GetRidOfMessagesODSFile());

    // Converted
    UserData.fConvertedToDBX = TRUE;

    // Store the UserDat
    IF_FAILEXIT(hr = m_pDB->SetUserData(&UserData, sizeof(STOREUSERDATA)));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::Validate
//--------------------------------------------------------------------------
HRESULT CMessageStore::Validate(STOREVALIDATEFLAGS dwFlags)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    FOLDERID            idServer;
    CHAR                szAccountId[CCHMAX_ACCOUNT_NAME], szFolder[CCHMAX_FOLDER_NAME];
    IEnumerateFolders  *pChildren=NULL;
    IImnEnumAccounts   *pEnum=NULL;
    IImnAccount        *pAccount=NULL;

    // Trace
    TraceCall("CMessageStore::Validate");

    // Validate
    Assert(g_pAcctMan);

    // Don't Sync With Accounts ?
    if (!ISFLAGSET(dwFlags, STORE_VALIDATE_DONTSYNCWITHACCOUNTS))
    {
        // Enumerate Folders
        IF_FAILEXIT(hr = EnumChildren(FOLDERID_ROOT, TRUE, &pChildren));

        // Enumerate the top-level servers in the store
        while (S_OK == pChildren->Next(1, &Folder, NULL))
        {
            // Does Folder.szAccountId exist in the Account Manager ?
            if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Folder.pszAccountId, &pAccount)) && lstrcmp(STR_LOCALSTORE, Folder.pszAccountId) != 0)
            {
                // Delete this server node
                DeleteFolder(Folder.idFolder, DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_NOTRASHCAN, NOSTORECALLBACK);
            }

            // Otherwise, release
            else
                SafeRelease(pAccount);

            // Cleanup
            m_pDB->FreeRecord(&Folder);
        }
    }

    // local store
    if (FAILED(GetFolderInfo(FOLDERID_LOCAL_STORE, &Folder)))
    {
        // Create the Store
        IF_FAILEXIT(hr = CreateServer(NULL, NOFLAGS, &idServer));

        // Valid ?
        Assert(idServer == FOLDERID_LOCAL_STORE);
    }

    // Otherwise, Validate FolderId
    else
    {
        // _ValidateSpecialFolders
        IF_FAILEXIT(hr = _ValidateSpecialFolders(&Folder));

        // Free Folder
        m_pDB->FreeRecord(&Folder);

        hr = GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_ERRORS, &Folder);
        if (SUCCEEDED(hr))
        {
            if (Folder.cMessages == 0 && 0 == (Folder.dwFlags & FOLDER_HASCHILDREN))
                DeleteFolder(Folder.idFolder, DELETE_FOLDER_NOTRASHCAN | DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_DELETESPECIAL, NULL);

            m_pDB->FreeRecord(&Folder);
        }
        else if (hr != DB_E_NOTFOUND)
        {
            goto exit;
        }

        // Lose the junk mail folder if we can't use it...
        if (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
        {
            hr = GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_JUNK, &Folder);
            if (SUCCEEDED(hr))
            {
                if (Folder.cMessages == 0 && 0 == (Folder.dwFlags & FOLDER_HASCHILDREN))
                    DeleteFolder(Folder.idFolder, DELETE_FOLDER_NOTRASHCAN | DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_DELETESPECIAL, NULL);

                m_pDB->FreeRecord(&Folder);
            }
            else if (hr != DB_E_NOTFOUND)
            {
                goto exit;
            }
        }
    }

    // Get an Account Enumerator...
    hr = g_pAcctMan->Enumerate(SRV_SMTP | SRV_POP3 | SRV_NNTP | SRV_IMAP | SRV_HTTPMAIL, &pEnum);

    // No Accounts
    if (hr == E_NoAccounts)
        hr = S_OK;

    // Otherwise, if failed
    else if (FAILED(hr))
        goto exit;

    // Otherwise...
    else
    {
        // Loop accounts
        while (SUCCEEDED(pEnum->GetNext(&pAccount)))
        {
            // Create the Store
            CreateServer(pAccount, NOFLAGS, &idServer);

            // Cleanup
            SafeRelease(pAccount);
        }
    }

    // Should we put a welcome message into the store
    if (g_pAcctMan && FALSE == m_fMigrate)
    {
        // Locals
        IMessageFolder *pInbox;

        // Open Inbox
        if (SUCCEEDED(OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, &pInbox)))
        {
            // Locals
            FOLDERUSERDATA UserData;

            // Get the User Data
            if (SUCCEEDED(pInbox->GetUserData(&UserData, sizeof(FOLDERUSERDATA))))
            {
                // No Welcome message yet ?
                if (FALSE == UserData.fWelcomeAdded || DwGetOption(OPT_NEEDWELCOMEMSG) != 0)
                {
                    // Add the Welcome Message
                    AddWelcomeMessage(pInbox);

                    // We Added the Welcome Message
                    UserData.fWelcomeAdded = TRUE;

                    // Update the User Data
                    pInbox->SetUserData(&UserData, sizeof(FOLDERUSERDATA));
                }
            }

            // Done
            pInbox->Release();
        }
    }

exit:
    // Cleanup
    SafeRelease(pChildren);
    SafeRelease(pAccount);
    SafeRelease(pEnum);
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_ValidateSpecialFolders
//--------------------------------------------------------------------------
HRESULT CMessageStore::_ValidateSpecialFolders(LPFOLDERINFO pServer)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERINFO      Folder;
    FOLDERINFO      NewFolder;
    CHAR            szFolder[CCHMAX_FOLDER_NAME];

    // Trace
    TraceCall("CMessageStore::_ValidateSpecialFolders");

    // Loop through the special folders
    for (i = FOLDER_INBOX; i < FOLDER_MAX; i++)
    {
        // Ignore FOLDER_ERRORS and FOLDER_MSNPROMO
        if (FOLDER_ERRORS != i && FOLDER_MSNPROMO != i && FOLDER_BULKMAIL != i && (FOLDER_JUNK != i 
            || (g_dwAthenaMode & MODE_JUNKMAIL)
            ))
        {
            // Does this special folder exist under this node yet ?
            if (FAILED(GetSpecialFolderInfo(pServer->idFolder, (SPECIALFOLDER)i, &Folder)))
            {
                // Load the Folder String
                LoadString(g_hLocRes, (idsInbox + i) - 1, szFolder, ARRAYSIZE(szFolder));

                // Fill the Folder Info
                ZeroMemory(&NewFolder, sizeof(FOLDERINFO));
                NewFolder.idParent = pServer->idFolder;
                NewFolder.tySpecial = (SPECIALFOLDER)i;
                NewFolder.pszName = szFolder;
                NewFolder.dwFlags = FOLDER_SUBSCRIBED;

                // Create the Folder
                IF_FAILEXIT(hr = CreateFolder(NOFLAGS, &NewFolder, NOSTORECALLBACK));
            }

            // Otherwise...
            else
                m_pDB->FreeRecord(&Folder);
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_ValidateServer
//--------------------------------------------------------------------------
HRESULT CMessageStore::_ValidateServer(LPFOLDERINFO pServer)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szSearch[MAX_PATH + MAX_PATH];
    HANDLE              hFind=INVALID_HANDLE_VALUE;
    FOLDERID            idFolder;
    WIN32_FIND_DATA     fd;

    // Trace
    TraceCall("CMessageStore::Validate");

    // Not a Server
    Assert(pServer && ISFLAGSET(pServer->dwFlags, FOLDER_SERVER));

    // Don't overwrite buffer
    IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, "*.dbx", c_szEmpty, szSearch, ARRAYSIZE(szSearch)));
    
    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    do
    {
        // If this is not a directory
        if (ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
            continue;

        // Skip folders
        if (lstrcmpi(fd.cFileName, c_szFoldersFile) == 0)
            continue;

        // Skip pop3uidl
        if (lstrcmpi(fd.cFileName, c_szPop3UidlFile) == 0)
            continue;

        // Skip offline
        if (lstrcmpi(fd.cFileName, c_szOfflineFile) == 0)
            continue;

        // Create Folder
        if (FAILED(_InsertFolderFromFile(pServer->pszAccountId, fd.cFileName)))
            continue;

    } while (0 != FindNextFile(hFind, &fd));

    // Can Have Specail Folders ?
    if (ISFLAGSET(pServer->dwFlags, FOLDER_CANHAVESPECIAL))
    {
        // _ValidateSpecialFolders
        IF_FAILEXIT(hr = _ValidateSpecialFolders(pServer));
    }

exit:
    // Cleanup
    if (INVALID_HANDLE_VALUE != hFind)
        FindClose(hFind);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::GetDirectory(LPSTR pszDir, DWORD cchMaxDir)
{
    // Trace
    TraceCall("CMessageStore::GetDirectory");

    // Invalid Args
    if (NULL == pszDir || NULL == m_pszDirectory)
        return TraceResult(E_INVALIDARG);

    // Copy It
    lstrcpyn(pszDir, m_pszDirectory, cchMaxDir);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::Synchronize(FOLDERID idFolder, 
    SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idDeletedItems;
    FOLDERID        idServer=FOLDERID_INVALID;
    FOLDERID        idCurrent=idFolder;
    IMessageServer *pServer=NULL;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CMessageStore::Synchronize");

    // Invalid Args
    if (NULL == pCallback || FOLDERID_ROOT == idFolder)
        return TraceResult(E_INVALIDARG);

    // Walk up the parent chain
    IF_FAILEXIT(hr = IsParentDeletedItems(idFolder, &idDeletedItems, &idServer));

    // Didn't Find Server ?
    if (FOLDERID_INVALID == idServer)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Tell the Server to snchronize...
    IF_FAILEXIT(hr = pServer->SynchronizeStore(idFolder, dwFlags, pCallback));

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::CreateServer
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::CreateServer(IImnAccount *pAccount, FLDRFLAGS dwFlags,
    LPFOLDERID pidFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwServers;
    FOLDERINFO      Root={0};
    FOLDERINFO      Folder={0};
    CHAR            szRes[CCHMAX_ACCOUNT_NAME], szAccountId[CCHMAX_ACCOUNT_NAME];
    BOOL            fLocalStore=FALSE;
    DWORD           dwDomainMsn = 0;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageStore::CreateServer");

    if (pAccount == NULL)
        lstrcpy(szAccountId, STR_LOCALSTORE);
    else if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId))))
        return(hr);

    // Lock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Make sure that an account with this id doesn't already exist
    if (SUCCEEDED(FindServerId(szAccountId, pidFolder)))
        goto exit;

    // If Local Store, lets fix the id to FOLDERID_LOCAL
    if (0 != lstrcmpi(STR_LOCALSTORE, szAccountId))
    {
        // Get the server types supported by this account.
        IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));

        // If SRV_POP3
        if (ISFLAGSET(dwServers, SRV_POP3))
        {
            // See if the local store node already exists
            if (SUCCEEDED(FindServerId(STR_LOCALSTORE, pidFolder)))
                goto exit;

            // Local Store
            fLocalStore = TRUE;
        }
    }

    // If Local Store, lets fix the id to FOLDERID_LOCAL
    if (fLocalStore || 0 == lstrcmpi(STR_LOCALSTORE, szAccountId))
    {
        // Load the String Name
        LoadString(g_hLocRes, idsPersonalFolders, szRes, ARRAYSIZE(szRes));

        // Flags
        Folder.dwFlags = FOLDER_CANHAVESPECIAL | FOLDER_SERVER | FOLDER_SUBSCRIBED;

        // Set pszName
        Folder.pszName = szRes;

        // Set the Type
        Folder.tyFolder = FOLDER_LOCAL;

        // Set the Id
        Folder.idFolder = FOLDERID_LOCAL_STORE;
    }

    // Otherwise, generate a value
    else
    {
        // Get the Friendly Name
        IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szRes, ARRAYSIZE(szRes)));

        // Set pszName
        Folder.pszName = szRes;

        // NNTP
        if (ISFLAGSET(dwServers, SRV_NNTP))
        {
            // Set the Folder Flags
            Folder.dwFlags = FOLDER_CANRENAME | FOLDER_CANDELETE | FOLDER_SERVER | FOLDER_SUBSCRIBED;

            // Set Type
            Folder.tyFolder = FOLDER_NEWS;
        }

        // IMAP
        else if (ISFLAGSET(dwServers, SRV_IMAP))
        {
            // Set Flags
            Folder.dwFlags = FOLDER_CANRENAME | FOLDER_CANDELETE | FOLDER_SERVER | FOLDER_SUBSCRIBED;

            // Set Type
            Folder.tyFolder = FOLDER_IMAP;
        }
        
        // HTTP
        else if (ISFLAGSET(dwServers, SRV_HTTPMAIL))
        {
            // Set Flags
            Folder.dwFlags = /* FOLDER_CANHAVESPECIAL | */ FOLDER_CANRENAME | FOLDER_CANDELETE | FOLDER_SERVER | FOLDER_SUBSCRIBED;

            // Is the account associated with MSN.com?
            if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwDomainMsn)) && dwDomainMsn)
                Folder.dwFlags |= FOLDER_MSNSERVER;

            // Set Type
            Folder.tyFolder = FOLDER_HTTPMAIL;
        }

        // Generate a folderid
        IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&Folder.idFolder));

        // Validate
        Assert(FOLDERID_ROOT != Folder.idFolder && FOLDERID_LOCAL_STORE != Folder.idFolder);
    }

    // Fill the Folder Info
    Folder.pszAccountId = szAccountId;
    Folder.tySpecial = FOLDER_NOTSPECIAL;

    // Insert this Record
    IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

    // Validate
    IF_FAILEXIT(hr = _ValidateServer(&Folder));

    // Get the Root
    IF_FAILEXIT(hr = GetFolderInfo(FOLDERID_ROOT, &Root));

    // Parent Doesn't Think it Has Kids Yet ?
    if (FALSE == ISFLAGSET(Root.dwFlags, FOLDER_HASCHILDREN))
    {
        // Set the Flags
        FLAGSET(Root.dwFlags, FOLDER_HASCHILDREN);

        // Update the Record
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Root));
    }

    // Return the Folderid
    if (pidFolder)
        *pidFolder = Folder.idFolder;

exit:
    // Cleanup
    m_pDB->FreeRecord(&Root);

    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_MakeUniqueFolderName
//--------------------------------------------------------------------------
HRESULT CMessageStore::_MakeUniqueFolderName(FOLDERID idParent, 
    LPCSTR pszOriginalName, LPSTR *ppszNewName)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    ULONG           i;

    // Allocate
    IF_NULLEXIT(*ppszNewName = (LPSTR)g_pMalloc->Alloc(lstrlen(pszOriginalName) + 20));

    // Generate a Unique Name
    for (i=1; i<500; i++)
    {
        // Format the New Name
        wsprintf(*ppszNewName, "%s (%d)", pszOriginalName, i);

        // Setup Folder
        Folder.idParent = idParent;
        Folder.pszName = (*ppszNewName);

        // Not Found
        if (DB_S_NOTFOUND == m_pDB->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            goto exit;

        // Free Folder
        m_pDB->FreeRecord(&Folder);
    }

    // Free *ppszNewName
    SafeMemFree((*ppszNewName));

    // Failure
    hr = TraceResult(DB_E_DUPLICATE);

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::CreateFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, 
    LPFOLDERINFO pInfo, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszNewName=NULL;
    LPSTR           pszName;
    FOLDERINFO      Parent={0};
    FOLDERINFO      Folder={0};
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageStore::CreateFolder");

    // Invalid Args
    if (NULL == pInfo || NULL == pInfo->pszName)
        return TraceResult(E_INVALIDARG);

    // Bad Folder Name
    if (NULL == pInfo->pszName || FIsEmpty(pInfo->pszName))
        return TraceResult(STORE_E_BADFOLDERNAME);

    // Lock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // See if the Folder Already Exists
    Folder.idParent = pInfo->idParent;
    Folder.pszName = pszName = (LPSTR)pInfo->pszName;

    // Try to find in the index
    if (DB_S_FOUND == m_pDB->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        // Try to Uniquify the name ?
        if (ISFLAGSET(dwCreateFlags, CREATE_FOLDER_UNIQUIFYNAME))
        {
            // Free
            m_pDB->FreeRecord(&Folder);

            // Generate Unique Folder Name
            IF_FAILEXIT(hr = _MakeUniqueFolderName(pInfo->idParent, pInfo->pszName, &pszNewName));

            // Set pszName
            pszName = pszNewName;
        }

        // Otherwise, return success
        else
        {
            // Set the pidFolder
            pInfo->idFolder = Folder.idFolder;

            // Free
            m_pDB->FreeRecord(&Folder);

            // Success, but already exists...
            hr = STORE_S_ALREADYEXISTS;

            // Done
            goto exit;
        }
    }

    // Get Parent Folder Info
    IF_FAILEXIT(hr = GetFolderInfo(pInfo->idParent, &Parent));

    // Parent Can not be the root
    if (FOLDERID_ROOT == Parent.idFolder)
    {
        hr = TraceResult(STORE_E_INVALIDPARENT);
        goto exit;
    }

    // Generate a folderid
    IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&Folder.idFolder));

    // Fill In the Folder Info
    Folder.tyFolder = Parent.tyFolder;
    Folder.idParent = Parent.idFolder;
    Folder.pszName = pszName;
    Folder.pszUrlComponent = pInfo->pszUrlComponent;
    Folder.tySpecial = pInfo->tySpecial;
    Folder.dwFlags = pInfo->dwFlags;
    Folder.bHierarchy = pInfo->bHierarchy;
    Folder.pszDescription = pInfo->pszDescription;
    Folder.dwServerHigh = pInfo->dwServerHigh;
    Folder.dwServerLow = pInfo->dwServerLow;
    Folder.dwServerCount = pInfo->dwServerCount;
    Folder.dwClientHigh = pInfo->dwClientHigh;
    Folder.dwClientLow = pInfo->dwClientLow;
    Folder.cMessages = pInfo->cMessages;
    Folder.cUnread = pInfo->cUnread;
    Folder.pszFile = pInfo->pszFile;
    Folder.Requested = pInfo->Requested;

    // Insert this Record
    IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

    // Parent Doesn't Think it Has Kids Yet ?
    if (FALSE == ISFLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN))
    {
        // Set the Flags
        FLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN);

        // Update the Record
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));
    }

    // Return the Folderid
    pInfo->idFolder = Folder.idFolder;

exit:
    // Cleanup
    m_pDB->FreeRecord(&Parent);
    m_pDB->Unlock(&hLock);
    SafeMemFree(pszNewName);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::OpenSpecialFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer,
    SPECIALFOLDER tySpecial, IMessageFolder **ppFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERID        idFolder;

    // Trace
    TraceCall("CMessageStore::OpenSpecialFolder");

    // Get Special Folder INformation
    IF_FAILEXIT(hr = _GetSpecialFolderId(idStore, tySpecial, &idFolder));

    // Open the Folder
    IF_FAILEXIT(hr = OpenFolder(idFolder, pServer, NOFLAGS, ppFolder));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::OpenFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OpenFolder(FOLDERID idFolder, IMessageServer *pServer, 
    OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    CFindFolder    *pFindFolder=NULL;
    CMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("CMessageStore::OpenFolder");

    // Invalid Args
    if (NULL == ppFolder || NULL == m_pDB)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *ppFolder = NULL;

    // Get Folder Info...
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // Search Folder ?
    if (ISFLAGSET(Folder.dwFlags, FOLDER_FINDRESULTS))
    {
        // Thread Safety
        EnterCriticalSection(&g_csFindFolder);

        // Walk Through the global list of Active Search Folders
        for (LPACTIVEFINDFOLDER pCurrent=g_pHeadFindFolder; pCurrent!=NULL; pCurrent=pCurrent->pNext)
        {
            // Is this it
            if (Folder.idFolder == pCurrent->idFolder)
            {
                // AddRef the Folder
                pFindFolder = pCurrent->pFolder;

                // AddRef It
                pFindFolder->AddRef();

                // Done
                break;
            }
        }

        // Thread Safety
        LeaveCriticalSection(&g_csFindFolder);

        // If Not Found
        if (NULL == pFindFolder)
        {
            hr = TraceResult(DB_E_NOTFOUND);
            goto exit;
        }

        // Return
        *ppFolder = (IMessageFolder *)pFindFolder;

        // Don't Free It
        pFindFolder = NULL;
    }

    // Otherwise
    else
    {
        // Create a CMessageFolder Object
        IF_NULLEXIT(pFolder = new CMessageFolder);

        // Initialize
        hr = pFolder->Initialize((IMessageStore *)this, pServer, dwFlags, idFolder);
        if (FAILED(hr))
            goto exit;

        // Return
        *ppFolder = (IMessageFolder *)pFolder;

        // Don't Free It
        pFolder = NULL;
    }

exit:
    // Cleanup
    SafeRelease(pFindFolder);
    SafeRelease(pFolder);
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::MoveFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, 
    MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERID        idParentOld;
    FOLDERINFO      Folder={0};
    FOLDERINFO      Parent={0};
    LPSTR           pszNewName=NULL;

    // Trace
    TraceCall("CMessageStore::MoveFolder");

    // Get all the Parents
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // Save Old Parent
    idParentOld = Folder.idParent;

    // Same Parent
    if (idParentOld == idParentNew)
        goto exit;

    // If Folder is a server..
    if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
    {
        hr = TraceResult(STORE_E_CANTMOVESERVERS);
        goto exit;
    }

    // If Folder is a special folder
    if (FOLDER_NOTSPECIAL != Folder.tySpecial)
    {
        hr = TraceResult(STORE_E_CANTMOVESPECIAL);
        goto exit;
    }

    // Set new Parent
    Folder.idParent = idParentNew;

    // Update the Parent
    hr = m_pDB->UpdateRecord(&Folder);

    // Failed and not a duplicate
    if (FAILED(hr) && DB_E_DUPLICATE != hr)
    {
        TraceResult(hr);
        goto exit;
    }

    // Duplicate
    if (DB_E_DUPLICATE == hr)
    {
        // Make Unique
        IF_FAILEXIT(hr = _MakeUniqueFolderName(Folder.idParent, Folder.pszName, &pszNewName));

        // Set the Name
        Folder.pszName = pszNewName;

        // Update the Parent
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));
    }

    // Update Parents
    IF_FAILEXIT(hr = GetFolderInfo(idParentOld, &Parent));

    // idParentOld no longer has children ?
    if (FALSE == FHasChildren(&Parent, FALSE))
    {
        // Remove FOLDER_HASCHILDREN flag
        FLAGCLEAR(Parent.dwFlags, FOLDER_HASCHILDREN);

        // Write It
        IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));
    }

    // Free It
    m_pDB->FreeRecord(&Parent);

    // Update Parents
    IF_FAILEXIT(hr = GetFolderInfo(idParentNew, &Parent));

    // Set the FOLDER_HASCHILDREN flag
    FLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN);

    // Write It
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Parent);
    m_pDB->FreeRecord(&Folder);
    SafeMemFree(pszNewName);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::RenameFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::RenameFolder(FOLDERID idFolder, LPCSTR pszName, 
    RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    FOLDERINFO      Folder={0};
    BOOL            fChanged;
    IDatabase      *pDB=NULL;
    LPWSTR          pwszFilePath=NULL;

    // Trace
    TraceCall("CMessageStore::RenameFolder");

    // Invalid Args
    if (NULL == pszName)
        return TraceResult(E_INVALIDARG);

    // Bad Folder Name
    if (FIsEmpty(pszName))
        return TraceResult(STORE_E_BADFOLDERNAME);

    // Get the FolderInfo
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // Can't Rename Special Folders
    if (FOLDER_NOTSPECIAL != Folder.tySpecial && 0 != lstrcmpi(pszName, Folder.pszName))
    {
        hr = TraceResult(STORE_E_CANTRENAMESPECIAL);
        goto exit;
    }

    // Set the Name
    Folder.pszName = (LPSTR)pszName;

    // If the file current has a folder file..
    if (Folder.pszFile)
    {
        // Build folder name
        IF_FAILEXIT(hr = BuildFriendlyFolderFileName(m_pszDirectory, &Folder, szFilePath, ARRAYSIZE(szFilePath), Folder.pszFile, &fChanged));

        // Changed ?
        if (fChanged)
        {
            // Locals
            CHAR szSrcFile[MAX_PATH + MAX_PATH];

            // Delete the Dest
            DeleteFile(szFilePath);

            // Open the old file
            IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, Folder.pszFile, c_szEmpty, szSrcFile, ARRAYSIZE(szSrcFile)));

            // Open the Folder
            IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szSrcFile, OPEN_DATABASE_NORESET | OPEN_DATABASE_NOEXTENSION, &g_MessageTableSchema, NULL, &pDB));

            // Convert to Unicode
            IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, szFilePath));

            // Move the file
            IF_FAILEXIT(hr = pDB->MoveFile(pwszFilePath));

            // Set the File Name
            Folder.pszFile = PathFindFileName(szFilePath);
        }
    }

    // Update the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

exit:
    // Cleanup
    SafeRelease(pDB);
    SafeMemFree(pwszFilePath);
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::DeleteFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::DeleteFolder(FOLDERID idFolder, 
    DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Delete={0};
    FOLDERID        idStore=FOLDERID_INVALID;
    FOLDERID        idDeletedItems=FOLDERID_INVALID;
    FOLDERINFO      DeletedItems={0};
    FOLDERINFO      Parent={0};
    BOOL            fTryTrashCan=FALSE;
    BOOL            fInDeletedItems=FALSE;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CMessageStore::DeleteFolder");

    // Can't Delete the root
    if (FOLDERID_ROOT == idFolder || FOLDERID_INVALID == idFolder)
        return TraceResult(E_INVALIDARG);

    // Lock Notifications
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // Get the Folder Information
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Delete));

    // Can't Delete special Folder
    if (!ISFLAGSET(dwFlags, DELETE_FOLDER_CHILDRENONLY) && FOLDER_NOTSPECIAL != Delete.tySpecial &&
        !ISFLAGSET(dwFlags, DELETE_FOLDER_DELETESPECIAL))
    {
        hr = TraceResult(STORE_E_CANTDELETESPECIAL);
        goto exit;
    }

    // Try to do the trash can ?
    if (FALSE == ISFLAGSET(Delete.dwFlags, FOLDER_SERVER) && FALSE == ISFLAGSET(dwFlags, DELETE_FOLDER_NOTRASHCAN))
        fTryTrashCan = TRUE;

    // If not in deleted items, then simply move this idFolder to deleted items
    if (TRUE == fTryTrashCan && S_FALSE == IsParentDeletedItems(idFolder, &idDeletedItems, &idStore) && FOLDER_NOTSPECIAL == Delete.tySpecial)
    {
        // Validate
        Assert(FOLDERID_INVALID == idDeletedItems && FOLDERID_INVALID != idStore);

        // Get the Deleted Items Folder for this store
        IF_FAILEXIT(hr = GetSpecialFolderInfo(idStore, FOLDER_DELETED, &DeletedItems));

        // Move this folder
        IF_FAILEXIT(hr = MoveFolder(idFolder, DeletedItems.idFolder, NOFLAGS, NULL));
    }

    // Otherwise, permanently delete these folders
    else
    {
        // Delete Children ?
        if (ISFLAGSET(dwFlags, DELETE_FOLDER_RECURSIVE))
        {
            // Delete Child Folders
            IF_FAILEXIT(hr = _DeleteSiblingsAndChildren(&Delete));

            // Delete has no children
            FLAGCLEAR(Delete.dwFlags, FOLDER_HASCHILDREN);

            // Update Delete
            IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Delete));
        }

        // _InternalDeleteFolder if not children only
        if (FALSE == ISFLAGSET(dwFlags, DELETE_FOLDER_CHILDRENONLY))
        {
            // Try to Delete this folder
            IF_FAILEXIT(hr = _InternalDeleteFolder(&Delete));

            // Delete's Parent has no childre
            if (FOLDERID_INVALID != Delete.idParent && FALSE == ISFLAGSET(Delete.dwFlags, FOLDER_HASCHILDREN))
            {
                // Get the Parent
                IF_FAILEXIT(hr = GetFolderInfo(Delete.idParent, &Parent));

                // Must have had children
                Assert(ISFLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN));

                // No more children
                if (FALSE == FHasChildren(&Parent, FALSE))
                {
                    // Delete has no children
                    FLAGCLEAR(Parent.dwFlags, FOLDER_HASCHILDREN);

                    // Update Delete
                    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));
                }
            }
        }
    }

exit:
    // Cleanup
    m_pDB->FreeRecord(&Delete);
    m_pDB->FreeRecord(&Parent);
    m_pDB->FreeRecord(&DeletedItems);
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_DeleteSiblingsAndChildren
//--------------------------------------------------------------------------
HRESULT CMessageStore::_DeleteSiblingsAndChildren(LPFOLDERINFO pParent)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("CMessageStore::_DeleteSiblingsAndChildren");

    // Enumerate Children
    IF_FAILEXIT(hr = EnumChildren(pParent->idFolder, FALSE, &pChildren));

    // Loop
    while (S_OK == pChildren->Next(1, &Folder, NULL))
    {
        // Has Children
        if (ISFLAGSET(Folder.dwFlags, FOLDER_HASCHILDREN))
        {
            // Delete Siblings and Children
            IF_FAILEXIT(hr = _DeleteSiblingsAndChildren(&Folder));
        }

        // _InternalDeleteFolder
        IF_FAILEXIT(hr = _InternalDeleteFolder(&Folder));

        // Cleanup
        m_pDB->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);
    SafeRelease(pChildren);

    // Done
    return (hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_InternalDeleteFolder
//--------------------------------------------------------------------------
HRESULT CMessageStore::_InternalDeleteFolder(LPFOLDERINFO pDelete)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("CMessageStore::_InternalDeleteFolder");

    // Has Children
    if (ISFLAGSET(pDelete->dwFlags, FOLDER_HASCHILDREN))
    {
        // Enumerate the Children
        IF_FAILEXIT(hr = EnumChildren(pDelete->idFolder, FALSE, &pChildren));

        // Loop
        while (S_OK == pChildren->Next(1, &Folder, NULL))
        {
            // Validate
            Assert(Folder.idParent == pDelete->idFolder);

            // Set New Parent
            Folder.idParent = pDelete->idParent;

            // Update the REcord
            IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

            // Cleanup
            m_pDB->FreeRecord(&Folder);
        }
    }

    // Final thing to do is to delete pFolder
    IF_FAILEXIT(hr = m_pDB->DeleteRecord(pDelete));

    // Delete folder file
    _DeleteFolderFile(pDelete);

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);
    SafeRelease(pChildren);

    // Done
    return (hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_DeleteFolderFile
//--------------------------------------------------------------------------
HRESULT CMessageStore::_DeleteFolderFile(LPFOLDERINFO pFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szFilePath[MAX_PATH + MAX_PATH];

    // Trac
    TraceCall("CMessageStore::_DeleteFolderFile");

    // If there is a file
    if (!FIsEmptyA(pFolder->pszFile))
    {
        // Make the file path
        IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, pFolder->pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // Delete the File
        if (0 == DeleteFile(szFilePath))
        {
            // Locals
            DeleteTempFileOnShutdownEx(PszDupA(szFilePath), NULL);
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_FreeServerTable
//--------------------------------------------------------------------------
HRESULT CMessageStore::_FreeServerTable(HLOCK hLock)
{
    // Locals
    LPSERVERFOLDER pCurrent = m_pServerHead;
    LPSERVERFOLDER pNext;

    // Trace
    TraceCall("CMessageStore::_FreeServerTable");

    // Validate
    Assert(hLock);

    // While Current
    while(pCurrent)
    {
        // Set Next
        pNext = pCurrent->pNext;

        // Free
        g_pMalloc->Free(pCurrent);

        // Goto next
        pCurrent = pNext;
    }

    // Reset
    m_pServerHead = NULL;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::_LoadServerTable
//--------------------------------------------------------------------------
HRESULT CMessageStore::_LoadServerTable(HLOCK hLock)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Server={0};
    FOLDERINFO          Folder={0};
    LPSERVERFOLDER      pServer=NULL;
    IEnumerateFolders  *pEnumServers=NULL;
    IEnumerateFolders  *pEnumFolders=NULL;

    // Trace
    TraceCall("CMessageStore::_LoadServerTable");

    // Validate
    Assert(hLock);

    // If Already Loaded
    if (m_pServerHead)
        return(S_OK);

    // Enumerate Children of Root
    IF_FAILEXIT(hr = EnumChildren(FOLDERID_ROOT, TRUE, &pEnumServers));

    // Loop..
    while (S_OK == pEnumServers->Next(1, &Server, NULL))
    {
        // Better be a store
        Assert(ISFLAGSET(Server.dwFlags, FOLDER_SERVER));

        // Allocate a Server Node
        IF_NULLEXIT(pServer = (LPSERVERFOLDER)g_pMalloc->Alloc(sizeof(SERVERFOLDER)));

        // Store the ServerId
        pServer->idServer = Server.idFolder;

        // Save AccountId
        lstrcpy(pServer->szAccountId, Server.pszAccountId);

        // Initialize
        FillMemory(pServer->rgidSpecial, sizeof(pServer->rgidSpecial), 0xFF);

        // Enumerate the Children
        IF_FAILEXIT(hr = EnumChildren(pServer->idServer, TRUE, &pEnumFolders));

        // Loop..
        while (S_OK == pEnumFolders->Next(1, &Folder, NULL))
        {
            // If Special
            if (FOLDER_NOTSPECIAL != Folder.tySpecial)
            {
                // Save the folder id
                pServer->rgidSpecial[Folder.tySpecial] = Folder.idFolder;
            }

            // Cleanup
            m_pDB->FreeRecord(&Folder);
        }

        // Release the Folder Enumerator
        SafeRelease(pEnumFolders);

        // Link it In
        pServer->pNext = m_pServerHead;

        // Set Server Head
        m_pServerHead = pServer;

        // Don't Free
        pServer = NULL;

        // Cleanup
        m_pDB->FreeRecord(&Server);
    } 

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);
    m_pDB->FreeRecord(&Server);
    SafeMemFree(pServer);

    // Release Enums
    SafeRelease(pEnumServers);
    SafeRelease(pEnumFolders);

    // Failure
    if (FAILED(hr))
    {
        // Free the Table
        _FreeServerTable(hLock);
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::FindServerId
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::FindServerId(LPCSTR pszAcctId, LPFOLDERID pidServer)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPSERVERFOLDER      pServer;

    // Trace
    TraceCall("CMessageStore::FindServerId");

    // Unlock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // LoadServer Table
    IF_FAILEXIT(hr = _LoadServerTable(hLock));

    // Loop through the cached server nodes...
    for (pServer = m_pServerHead; pServer != NULL; pServer = pServer->pNext)
    {
        // If this is It...
        if (lstrcmpi(pszAcctId, pServer->szAccountId) == 0)
        {
            *pidServer = pServer->idServer;
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// GetFolderInfo
//--------------------------------------------------------------------------
HRESULT CMessageStore::GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("CMessageStore::GetFolderInfo");
    
    // Invalid Arg
    Assert(pInfo);

    // Set pInfo
    pInfo->idFolder = idFolder;

    // Return
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pInfo, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

    // Found
    hr = S_OK;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetSpecialFolderInfo
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::GetSpecialFolderInfo(FOLDERID idStore,
    SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPSERVERFOLDER      pServer;

    // Trace
    TraceCall("CMessageStore::GetSpecialFolderInfo");

    // Invalid Args
    if (NULL == pInfo || FOLDER_NOTSPECIAL == tySpecial)
        return TraceResult(E_INVALIDARG);

    // Unlock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // LoadServer Table
    IF_FAILEXIT(hr = _LoadServerTable(hLock));

    // Loop through the cached server nodes...
    for (pServer = m_pServerHead; pServer != NULL; pServer = pServer->pNext)
    {
        // If this is It...
        if (idStore == pServer->idServer)
        {
            // Validate Special Folder Id ?
            if (FOLDERID_INVALID == pServer->rgidSpecial[tySpecial])
            {
                hr = DB_E_NOTFOUND;
                goto exit;
            }

            // Otherwise, get the folder info...
            IF_FAILEXIT(hr = GetFolderInfo(pServer->rgidSpecial[tySpecial], pInfo));

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_GetSpecialFolderId
//--------------------------------------------------------------------------
HRESULT CMessageStore::_GetSpecialFolderId(FOLDERID idStore,
    SPECIALFOLDER tySpecial, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPSERVERFOLDER      pServer;

    // Trace
    TraceCall("CMessageStore::_GetSpecialFolderId");

    // Unlock
    IF_FAILEXIT(hr = m_pDB->Lock(&hLock));

    // LoadServer Table
    IF_FAILEXIT(hr = _LoadServerTable(hLock));

    // Loop through the cached server nodes...
    for (pServer = m_pServerHead; pServer != NULL; pServer = pServer->pNext)
    {
        // If this is It...
        if (idStore == pServer->idServer)
        {
            // Validate Special Folder Id ?
            if (FOLDERID_INVALID == pServer->rgidSpecial[tySpecial])
            {
                hr = DB_E_NOTFOUND;
                goto exit;
            }

            // Return the id
            *pidFolder = pServer->rgidSpecial[tySpecial];

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Unlock
    m_pDB->Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::SubscribeToFolder
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::SubscribeToFolder(FOLDERID idFolder, 
    BOOL fSubscribed, IStoreCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CMessageStore::SubscribeToFolder");

    // Invalid Args
    if (NULL == m_pDB)
        return TraceResult(E_INVALIDARG);

    // Set idFolder
    IF_FAILEXIT(hr = GetFolderInfo(idFolder, &Folder));

    // If not Subscribed yet ?
    if (fSubscribed ^ ISFLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED))
    {
        // Remove the Not-Subscribed Falgs
        FLAGTOGGLE(Folder.dwFlags, FOLDER_SUBSCRIBED);
    }

    // Update the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

    // Delete the file if not subscribed
    if (FALSE == ISFLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED))
    {
        // Delete this file
        _DeleteFolderFile(&Folder);
    }

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::GetFolderCounts(FOLDERID idFolder,
                                               IStoreCallback *pCallback)
{
    // Has no equivalent in a local store
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
// CMessageStore::UpdateFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::UpdateFolderCounts(FOLDERID idFolder, 
    LONG lMsgs, LONG lUnread, LONG lWatchedUnread, LONG lWatched)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CMessageStore::UpdateMessageCount");

    // Invalid Args
    if (NULL == m_pDB)
        return TraceResult(E_INVALIDARG);

    // No Change
    if (0 == lMsgs && 0 == lUnread && 0 == lWatchedUnread && 0 == lWatched)
        return(S_OK);

    // Set idFolder
    Folder.idFolder = idFolder;

    // Find idFolder
    IF_FAILEXIT(hr = m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Folder, NULL));

    // Not found
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    if (lMsgs < 0 && (DWORD)(abs(lMsgs)) >= Folder.cMessages)
        lMsgs = -((LONG)Folder.cMessages);

    // Message Unread Count
    if (lUnread < 0 && (DWORD)(abs(lUnread)) >= Folder.cUnread)
        lUnread = -((LONG)Folder.cUnread);

    // Set Counts
    Folder.cMessages += lMsgs;
    Folder.cUnread += lUnread;

    // Total Watched Count
    if (lWatched < 0 && (DWORD)(abs(lWatched)) > Folder.cWatched)
        Folder.cWatched = 0;
    else
        Folder.cWatched += lWatched;

    // Watched Unread Counts
    if (lWatchedUnread < 0 && (DWORD)(abs(lWatchedUnread)) > Folder.cWatchedUnread)
        Folder.cWatchedUnread = 0;
    else
        Folder.cWatchedUnread += lWatchedUnread;

    // Reset IMAP status counts
    Folder.dwStatusMsgDelta = 0;
    Folder.dwStatusUnreadDelta = 0;

    // Update the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Folder));

exit:
    // Cleanup
    m_pDB->FreeRecord(&Folder);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_ComputeMessageCounts
//--------------------------------------------------------------------------
HRESULT CMessageStore::_ComputeMessageCounts(IDatabase *pDB,
    LPDWORD pcMsgs, LPDWORD pcUnread)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};

    // Trace
    TraceCall("CMessageStore::_ComputeMessageCounts");

    // Invalid Args
    Assert(pDB && pcMsgs && pcUnread);

    // Initialize
    *pcMsgs = 0;
    *pcUnread = 0;

    // Create Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Iterate throug the messages
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Count
        (*pcMsgs)++;

        // Not Read
        if (FALSE == ISFLAGSET(Message.dwFlags, ARF_READ))
            (*pcUnread)++;

        // Free
        pDB->FreeRecord(&Message);
    }

exit:
    // Clenaup
    pDB->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::_InsertFolderFromFile
//--------------------------------------------------------------------------
HRESULT CMessageStore::_InsertFolderFromFile(LPCSTR pszAcctId, 
    LPCSTR pszFile)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i=1;
    CHAR            szFolder[255];
    FOLDERINFO      Parent={0};
    FOLDERINFO      Folder={0};
    FOLDERUSERDATA  UserData={0};
    FOLDERUSERDATA  FolderData;
    FOLDERID        idParent;
    FOLDERID        idFolder;
    LPSTR           pszName;
    LPSTR           pszNewName=NULL;
    IDatabase *pDB=NULL;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("CMessageStore::_InsertFolderFromFile");

    // Invalid Args
    Assert(!FIsEmptyA(pszAcctId) && !FIsEmptyA(pszFile));

    // Init
    *szFilePath = '\0';

    // Make Path to the mst
    IF_FAILEXIT(hr = MakeFilePath(m_pszDirectory, pszFile, c_szEmpty, szFilePath, sizeof(szFilePath)));

    // Lets verify that this is really a message database
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, OPEN_DATABASE_NORESET, &g_MessageTableSchema, NULL, &pDB));

    // Get folder user data
    IF_FAILEXIT(hr = pDB->GetUserData(&FolderData, sizeof(FOLDERUSERDATA)));

    // If Not Initialized yet
    if (FALSE == FolderData.fInitialized)
        goto exit;

    // Locate the Parent Store
    IF_FAILEXIT(hr = FindServerId(FolderData.szAcctId, &idParent));

    // Get Parent Folder Info
    IF_FAILEXIT(hr = GetFolderInfo(idParent, &Parent));

    // pszAcctId
    if (lstrcmp(FolderData.szAcctId, pszAcctId) != 0)
        goto exit;

    // Parent Can not be the root
    if (FOLDERID_ROOT == idParent)
    {
        hr = TraceResult(STORE_E_INVALIDPARENT);
        goto exit;
    }

    // Setup Folder
    Folder.idFolder = idFolder = FolderData.idFolder;

    // Does FolderData.idFolder aready exist ?
    if (DB_S_FOUND == m_pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Folder, NULL))
    {
        // Free Folder
        m_pDB->FreeRecord(&Folder);

        // Make Unique
        IF_FAILEXIT(hr = m_pDB->GenerateId((LPDWORD)&idFolder));

        // Setup Folder
        FolderData.idFolder = idFolder;

        // Reset the User Data
        IF_FAILEXIT(hr = pDB->SetUserData(&FolderData, sizeof(FOLDERUSERDATA)));
    }

    // Set Name
    Folder.pszName = pszName = FolderData.szFolder;
    Folder.idParent = idParent;

    // See if folder with same name and paent already exists...
    if (DB_S_FOUND == m_pDB->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        // Free Folder
        m_pDB->FreeRecord(&Folder);

        // Don't duplicate special folders!!!
        if (FOLDER_NOTSPECIAL != FolderData.tySpecial)
        {
            hr = TraceResult(DB_E_DUPLICATE);
            goto exit;
        }

        // Make Unique
        IF_FAILEXIT(hr = _MakeUniqueFolderName(idParent, FolderData.szFolder, &pszNewName));

        // Reset FolderData
        lstrcpyn(FolderData.szFolder, pszNewName, ARRAYSIZE(FolderData.szFolder));

        // Reset the User Data
        IF_FAILEXIT(hr = pDB->SetUserData(&FolderData, sizeof(FOLDERUSERDATA)));

        // Set the Name
        pszName = pszNewName;
    }

    // Fill the Folder Info
    ZeroMemory(&Folder, sizeof(FOLDERINFO));
    Folder.idFolder = idFolder;
    Folder.pszName = pszName;
    Folder.tySpecial = FolderData.tySpecial;
    Folder.tyFolder = Parent.tyFolder;
    Folder.idParent = Parent.idFolder;
    Folder.dwFlags = FOLDER_SUBSCRIBED;
    Folder.pszFile = (LPSTR)pszFile;

    // Compute Message Counts
    IF_FAILEXIT(hr = _ComputeMessageCounts(pDB, &Folder.cMessages, &Folder.cUnread));

    // Insert this Record
    IF_FAILEXIT(hr = m_pDB->InsertRecord(&Folder));

    // Update the Parent
    FLAGSET(Parent.dwFlags, FOLDER_HASCHILDREN);

    // Write the Record
    IF_FAILEXIT(hr = m_pDB->UpdateRecord(&Parent));

exit:
    // Cleanup
    SafeRelease(pDB);
    m_pDB->FreeRecord(&Parent);
    SafeMemFree(pszNewName);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::EnumChildren
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::EnumChildren(FOLDERID idParent, 
    BOOL fSubscribed, IEnumerateFolders **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumerateFolders  *pEnum=NULL;

    // Trace
    TraceCall("CMessageStore::EnumChildren");

    // Allocate a New Enumerator
    IF_NULLEXIT(pEnum = new CEnumerateFolders);

    // Initialzie
    IF_FAILEXIT(hr = pEnum->Initialize(m_pDB, fSubscribed, idParent));

    // Return It
    *ppEnum = (IEnumerateFolders *)pEnum;

    // Don't Release It
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CMessageStore::GetNewGroups
//--------------------------------------------------------------------------
HRESULT CMessageStore::GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    return(E_NOTIMPL);
}

//--------------------------------------------------------------------------
// CMessageStore::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::Initialize(IDatabase *pDB)
{
    // Trace
    TraceCall("CMessageStore::Initialize");

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnLock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnLock(void)
{
    // Trace
    TraceCall("CMessageStore::OnLock");

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnUnlock
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnUnlock(void)
{
    // Trace
    TraceCall("CMessageStore::OnUnlock");

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnInsertRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnRecordInsert(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Cast to MessageInfos
    LPFOLDERINFO pFolder = (LPFOLDERINFO)pRecord;

    // Trace
    TraceCall("CMessageStore::OnRecordInsert");

    // If this was a server
    if (m_pDB && ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) || FOLDER_NOTSPECIAL != pFolder->tySpecial)
    {
        // Free the Server Table
        _FreeServerTable((HLOCK)-1);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnUpdateRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnRecordUpdate(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecordOld, LPVOID pRecordNew)
{
    // Cast to MessageInfos
    LPFOLDERINFO pFolderOld = (LPFOLDERINFO)pRecordOld;
    LPFOLDERINFO pFolderNew = (LPFOLDERINFO)pRecordNew;

    // Trace
    TraceCall("CMessageStore::OnRecordInsert");

    // Special Folder Type Changed ?
    if (m_pDB && ISFLAGSET(pFolderOld->dwFlags, FOLDER_SERVER) != ISFLAGSET(pFolderNew->dwFlags, FOLDER_SERVER) || pFolderOld->tySpecial != pFolderNew->tySpecial)
    {
        // Free the Server Table
        _FreeServerTable((HLOCK)-1);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnDeleteRecord
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnRecordDelete(OPERATIONSTATE tyState, 
    LPORDINALLIST pOrdinals, LPVOID pRecord)
{
    // Cast to MessageInfos
    LPFOLDERINFO pFolder = (LPFOLDERINFO)pRecord;

    // Trace
    TraceCall("CMessageStore::OnRecordInsert");

    // If this was a server
    if (m_pDB && ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) || FOLDER_NOTSPECIAL != pFolder->tySpecial)
    {
        // Free the Server Table
        _FreeServerTable((HLOCK)-1);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CMessageStore::OnExecuteMethod
//--------------------------------------------------------------------------
STDMETHODIMP CMessageStore::OnExecuteMethod(METHODID idMethod, LPVOID pBinding, 
    LPDWORD pdwResult)
{
    // Trace
    TraceCall("CMessageStore::OnExecuteMethod");

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\storsync.h ===
#ifndef __STORSYNC_H
#define __STORSYNC_H

#include <conman.h>
#include "dbimpl.h"

#define CMAXTHREADS     4

typedef struct tagSERVERENTRY
{
    FOLDERID            idServer;
    FOLDERID            idFolder;
    IMessageServer     *pServer;
} SERVERENTRY, *LPSERVERENTRY;

typedef struct tagTHREADSERVERS
{
    DWORD               dwThreadId;
    SERVERENTRY        *pEntry;
    DWORD               cEntry;
    DWORD               cEntryBuf;
} THREADSERVERS;

extern IMessageStore *g_pLocalStore;

class CStoreSync :
                public IMessageStore,
                public IConnectionNotify
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CStoreSync(void);
    ~CStoreSync(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageStore Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(LPCSTR pszDirectory);
    STDMETHODIMP Validate(DWORD dwReserved);
    STDMETHODIMP GetDirectory(LPSTR pszDirectory, DWORD cchMaxDir);
    STDMETHODIMP Synchronize(FOLDERID idFolder, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP FindServerId(LPCSTR pszAcctId, LPFOLDERID pidStore);
    STDMETHODIMP CreateServer(IImnAccount *pAcct, FLDRFLAGS dwFlags, LPFOLDERID pidFolder);
    STDMETHODIMP CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, LPFOLDERINFO pInfo, IStoreCallback *pCallback);
    STDMETHODIMP OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer, SPECIALFOLDER tySpecial, IMessageFolder **ppFolder);
    STDMETHODIMP OpenFolder(FOLDERID idFolder, IMessageServer *pServer, OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo);
    STDMETHODIMP GetSpecialFolderInfo(FOLDERID idStore, SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP UpdateFolderCounts(FOLDERID idFolder, LONG lMessages, LONG lUnread, LONG lWatchedUnread, LONG lWatched);
    STDMETHODIMP EnumChildren(FOLDERID idParent, BOOL fSubscribed, IEnumerateFolders **ppEnum);
    STDMETHODIMP GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IConnectionNotify
    //----------------------------------------------------------------------
    STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    IMPLEMENT_IDATABASE(FALSE, m_pLocalStore);

    HRESULT Initialize(IMessageStore *pLocalStore);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT     _GetFolderInfo(FOLDERID id, FOLDERINFO *pInfo, BOOL *pfOffline);
    HRESULT     _GetServer(FOLDERID idServer, FOLDERID idFolder, FOLDERTYPE tyFolder, IMessageServer **ppServer);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    IMessageStore      *m_pLocalStore;  // local message store
    BOOL                m_fConManAdvise;

    THREADSERVERS       m_rgts[CMAXTHREADS];
};

//--------------------------------------------------------------------------
// ProtoTypes
//--------------------------------------------------------------------------
HRESULT InitializeStore(DWORD dwFlags /* MSOEAPI_xxx Flags from msoeapi.idl */);

#endif // __STORSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\storsync.cpp ===
#include "pch.hxx"
#include "instance.h"
#include "storsync.h"
#include "msgfldr.h"
#include "storutil.h"
#include "store.h"
#include "fldrsync.h"
#include <conman.h>

IMessageStore *g_pLocalStore = NULL;

HRESULT InitializeStore(DWORD dwFlags /* MSOEAPI_xxx Flags from msoeapi.idl */)
{
    HRESULT hr;
    CStoreSync *pStore;
    char szStoreDir[MAX_PATH + MAX_PATH];

    hr = S_OK;

    if (g_pStore == NULL)
    {
        Assert(g_pLocalStore == NULL);

        hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
        if (FAILED(hr))
            return(hr);

        g_pLocalStore = new CMessageStore(FALSE);
        if (g_pLocalStore == NULL)
            return(E_OUTOFMEMORY);

        hr = g_pLocalStore->Initialize(szStoreDir);
        if (SUCCEEDED(hr))
        {
            pStore = new CStoreSync;
            if (pStore == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = pStore->Initialize(g_pLocalStore);
                if (SUCCEEDED(hr))
                {
                    g_pStore = pStore;
                    hr = g_pLocalStore->Validate(ISFLAGSET(dwFlags, MSOEAPI_START_STOREVALIDNODELETE) ? STORE_VALIDATE_DONTSYNCWITHACCOUNTS : 0);
                }
                else
                {
                    pStore->Release();
                }
            }
        }
    
        hr = ((CMessageStore *)g_pLocalStore)->MigrateToDBX();
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::CStoreSync
//--------------------------------------------------------------------------
CStoreSync::CStoreSync(void)
{
    g_pInstance->DllAddRef();
    m_cRef = 1;
    m_pLocalStore = NULL;
    m_fConManAdvise = FALSE;
    ZeroMemory(m_rgts, sizeof(m_rgts));
}

//--------------------------------------------------------------------------
// CStoreSync::~CStoreSync
//--------------------------------------------------------------------------
CStoreSync::~CStoreSync(void)
{
    DWORD i, j;

    SafeRelease(m_pLocalStore);

    if (m_fConManAdvise && g_pConMan != NULL)
        g_pConMan->Unadvise((IConnectionNotify *)this);

    for (j = 0; j < CMAXTHREADS; j++)
    {
        if (m_rgts[j].pEntry != NULL)
        {
            for (i = 0; i < m_rgts[j].cEntry; i++)
            {
                if (m_rgts[j].pEntry[i].pServer != NULL)
                    {
                    m_rgts[j].pEntry[i].pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
                    m_rgts[j].pEntry[i].pServer->Release();
                    }
            }

            MemFree(m_rgts[j].pEntry);
        }
    }

    g_pInstance->DllRelease();
}

//--------------------------------------------------------------------------
// CStoreSync::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IMessageStore *)this;
    else if (IID_IMessageStore == riid)
        *ppv = (IMessageStore *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_IConnectionNotify == riid)
        *ppv = (IConnectionNotify *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// CStoreSync::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreSync::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CStoreSync::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStoreSync::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CStoreSync::Initialize
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::Initialize(LPCSTR pszDirectory)
{
    Assert(FALSE);
    return(E_NOTIMPL);
}

HRESULT CStoreSync::Initialize(IMessageStore *pLocalStore)
{
    HRESULT         hr;

    Assert(pLocalStore != NULL);
    Assert(g_pConMan != NULL);
    Assert(g_pAcctMan != NULL);

    // local store operation only

    m_pLocalStore = pLocalStore;
    m_pLocalStore->AddRef();

    hr = g_pConMan->Advise((IConnectionNotify *)this);
    m_fConManAdvise = SUCCEEDED(hr);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::Validate
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::Validate(DWORD dwReserved)
{
    HRESULT         hr;

    // local store operation only

    hr = m_pLocalStore->Validate(dwReserved);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::GetDirectory(LPSTR pszDir, DWORD cchMaxDir)
{
    HRESULT         hr;

    Assert(NULL != pszDir);

    // local store operation only

    hr = m_pLocalStore->GetDirectory(pszDir, cchMaxDir);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::Synchronize
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::Synchronize(FOLDERID idFolder, 
    SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback)
{
    BOOL            fOffline;
    FOLDERINFO      info;
    HRESULT         hr;
    IMessageServer *pServer;

    Assert(FOLDERID_ROOT != idFolder);

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);

    // if online, sync folder list
    // if offline, no op (fail)

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(!!(info.dwFlags & FOLDER_SERVER));

        if (info.tyFolder != FOLDER_LOCAL)
        {
            if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->SynchronizeStore(idFolder, dwFlags, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::CreateServer
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::CreateServer(IImnAccount *pAcct, FLDRFLAGS dwFlags, 
    LPFOLDERID pidFolder)
{
    HRESULT         hr;

    // local store operation only
    // create node in local store for server

    hr = m_pLocalStore->CreateServer(pAcct, dwFlags, pidFolder);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::CreateFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::CreateFolder(CREATEFOLDERFLAGS dwCreateFlags, 
    LPFOLDERINFO pInfo, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idFolder;
    DWORD           dwFlags;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != pInfo);
    Assert(NULL != pInfo->pszName);
    Assert(0 == (pInfo->dwFlags & FOLDER_SERVER));

    if (NULL == pInfo->pszName || FIsEmpty(pInfo->pszName))
        return(STORE_E_BADFOLDERNAME);

    // if online, create folder on server and then create one in local store
    // if offline, not supported (fail)

    GetFolderServerId(pInfo->idParent, &idFolder);

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder == FOLDER_LOCAL ||
            dwCreateFlags == CREATE_FOLDER_LOCALONLY)
        {
            dwFlags = pInfo->dwFlags;

            if (pInfo->tySpecial == FOLDER_NOTSPECIAL && info.tyFolder == FOLDER_LOCAL)
                pInfo->dwFlags |= FOLDER_CANRENAME | FOLDER_CANDELETE;
            
            hr = m_pLocalStore->CreateFolder(dwCreateFlags, pInfo, NOSTORECALLBACK);
            
            pInfo->dwFlags = dwFlags;
        }
        else
        {
            Assert(info.tyFolder != FOLDER_NEWS);

            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                {
                    hr = pServer->CreateFolder(pInfo->idParent, pInfo->tySpecial, pInfo->pszName, pInfo->dwFlags, pCallback);
                }
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::OpenSpecialFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::OpenSpecialFolder(FOLDERID idStore, IMessageServer *pServer, 
    SPECIALFOLDER tySpecial, IMessageFolder **ppFolder)
{
    HRESULT         hr;
    FOLDERINFO      Folder;

    // local store operation only

    hr = GetSpecialFolderInfo(idStore, tySpecial, &Folder);
    if (SUCCEEDED(hr))
    {
        hr = OpenFolder(Folder.idFolder, pServer, NOFLAGS, ppFolder);

        m_pLocalStore->FreeRecord(&Folder);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::OpenFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::OpenFolder(FOLDERID idFolder, IMessageServer *pServerUseMeIfYouCan, 
    OPENFOLDERFLAGS dwFlags, IMessageFolder **ppFolder)
{
    char            sz[CCHMAX_ACCOUNT_NAME];
    FOLDERINFO      info;
    HRESULT         hr;
    CFolderSync    *pFolder;
    CMessageFolder *pMsgFolder;
    IMessageServer *pServer;
    IMessageFolder *pLocalFolder=NULL;
    FOLDERTYPE      tyFolder;
    FOLDERID        idParent;
    BOOL            fFind;

    Assert(NULL != ppFolder);

    // local store operation only

    pServer = NULL;
    *ppFolder = NULL;

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    hr = m_pLocalStore->GetFolderInfo(idFolder, &info);
    if (hr != S_OK)
        return(E_FAIL);

    tyFolder = info.tyFolder;
    fFind = !!(info.dwFlags & FOLDER_FINDRESULTS);

    m_pLocalStore->FreeRecord(&info);

    if (fFind)
    {
        hr = m_pLocalStore->OpenFolder(idFolder, NULL, dwFlags, &pLocalFolder);
        if (SUCCEEDED(hr))
            *ppFolder = pLocalFolder;
        return(hr);
    }

    pFolder = new CFolderSync;
    if (pFolder == NULL)
        return(E_OUTOFMEMORY);

    Assert(hr == S_OK);
    if (tyFolder != FOLDER_LOCAL)
    {
        hr = m_pLocalStore->OpenFolder(idFolder, NULL, dwFlags, &pLocalFolder);
        if (SUCCEEDED(hr))
        {
            if (pServerUseMeIfYouCan != NULL)
            {
                hr = pServerUseMeIfYouCan->ResetFolder(pLocalFolder, idFolder);
                if (SUCCEEDED(hr))
                {
                    pServer = pServerUseMeIfYouCan;
                    pServer->AddRef();
                }
            }

            if (pServer == NULL)
            {
                hr = CreateMessageServerType(tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->Initialize(m_pLocalStore, idParent, pLocalFolder, idFolder);
            }
        }
    }

    if (SUCCEEDED(hr))
        hr = pFolder->Initialize((IMessageStore *)m_pLocalStore, pLocalFolder, pServer, dwFlags, tyFolder, idFolder, idParent);

    if (SUCCEEDED(hr))
    {
        *ppFolder = (IMessageFolder *)pFolder;
        pFolder->AddRef();
    }

    if (pServer != NULL)
        pServer->Release();
    pFolder->Release();
    if (pLocalFolder)
        pLocalFolder->Release();

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::MoveFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, 
    MOVEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idAcct, idAcctNew;
    HRESULT         hr;
    IMessageServer *pServer;
    BOOL            fOffline;

    // if online, move folder on server and then move folder in local store
    // if offline, not supported (fail)

    if (idFolder == idParentNew)
        return(S_OK);

    hr = GetFolderServerId(idParentNew, &idAcctNew);
    if (hr != S_OK)
        return(E_FAIL);

    hr = GetFolderServerId(idFolder, &idAcct);
    if (hr != S_OK)
        return(E_FAIL);

    // can't move between servers...
    if (idAcct != idAcctNew)
        return(hrCantMoveFolderBetweenServers);

    hr = IsSubFolder(idParentNew, idFolder);
    if (hr == S_OK)
        return(hrCantMoveIntoSubfolder);
    else if (FAILED(hr))
        return(hr);

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_NEWS);

        if (info.tyFolder == FOLDER_LOCAL)
        {
            hr = m_pLocalStore->MoveFolder(idFolder, idParentNew, dwFlags, NULL);
        }
        else
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->MoveFolder(idFolder, idParentNew, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::RenameFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::RenameFolder(FOLDERID idFolder, LPCSTR pszName, 
    RENAMEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idParent;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != pszName);

    // if online, rename folder on server and then rename folder in local store
    // if offline, not supported (fail)

    if (FIsEmpty(pszName))
        return(STORE_E_BADFOLDERNAME);

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    if (idParent == idFolder)
    {
        // this is a server node, so we just handle it in the local store
        hr = m_pLocalStore->RenameFolder(idFolder, pszName, dwFlags, NULL);
        return(hr);
    }

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_NEWS);

        if (info.tyFolder == FOLDER_LOCAL)
        {
            hr = m_pLocalStore->RenameFolder(idFolder, pszName, dwFlags, NULL);
        }
        else
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->RenameFolder(idFolder, pszName, pCallback);
            }

        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::DeleteFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::DeleteFolder(FOLDERID idFolder, 
    DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idParent;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(FOLDERID_ROOT != idFolder);
    Assert(FOLDERID_INVALID != idFolder);

    // if online, delete folder on server and then delete folder in local store
    // if offline, not supported (fail)

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    if (idParent == idFolder)
    {
        // this is a server node, so we just handle it in the local store
        hr = m_pLocalStore->DeleteFolder(idFolder, dwFlags, pCallback);
        return(hr);
    }

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_NEWS);

        if (info.tyFolder == FOLDER_LOCAL)
        {
            hr = m_pLocalStore->DeleteFolder(idFolder, dwFlags, NULL);
        }
        else
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->DeleteFolder(idFolder, dwFlags, pCallback);
            }

        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::FindServerId
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::FindServerId(LPCSTR pszAcctId, LPFOLDERID pidServer)
{
    HRESULT         hr;

    Assert(pszAcctId != NULL);
    Assert(pidServer != NULL);

    // local store operation only

    hr = m_pLocalStore->FindServerId(pszAcctId, pidServer);

    return(hr);
}

//--------------------------------------------------------------------------
// GetFolderInfo
//--------------------------------------------------------------------------
HRESULT CStoreSync::GetFolderInfo(FOLDERID idFolder, LPFOLDERINFO pInfo)
{
    HRESULT         hr;

    Assert(pInfo != NULL);

    // local store operation only

    hr = m_pLocalStore->GetFolderInfo(idFolder, pInfo);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::EnumChildren
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::EnumChildren(FOLDERID idParent, BOOL fSubscribed, 
    IEnumerateFolders **ppEnum)
{
    HRESULT         hr;

    Assert(ppEnum != NULL);

    // local store operation only

    hr = m_pLocalStore->EnumChildren(idParent, fSubscribed, ppEnum);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::GetSpecialFolderInfo
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::GetSpecialFolderInfo(FOLDERID idStore,
    SPECIALFOLDER tySpecial, LPFOLDERINFO pInfo)
{
    HRESULT         hr;

    Assert(NULL != pInfo);
    Assert(FOLDER_NOTSPECIAL != tySpecial);

    // local store operation only

    hr = m_pLocalStore->GetSpecialFolderInfo(idStore, tySpecial, pInfo);

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::SubscribeToFolder
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::SubscribeToFolder(FOLDERID idFolder, 
    BOOL fSubscribed, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    FOLDERID        idParent;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != m_pLocalStore);

    // if imap and online, subscribe to folder on server and then in local store
    // otherwise, subscribe to folder in local store

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        Assert(info.tyFolder != FOLDER_LOCAL);

        if (info.tyFolder == FOLDER_NEWS)
        {
            hr = m_pLocalStore->SubscribeToFolder(idFolder, fSubscribed, NULL);
        }
        else
        {
            Assert(info.tyFolder == FOLDER_IMAP);

            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->SubscribeToFolder(idFolder, fSubscribed, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

STDMETHODIMP CStoreSync::GetNewGroups(FOLDERID idFolder, LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    FOLDERINFO      info;
    HRESULT         hr;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(m_pLocalStore != NULL);

    Assert(pCallback != NULL);
    if (pCallback == NULL)
        return(E_INVALIDARG);

    // if news server and online, get new groups on server

    hr = _GetFolderInfo(idFolder, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder != FOLDER_NEWS ||
            0 == (info.dwFlags & FOLDER_SERVER))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idFolder, idFolder, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->GetNewGroups(pSysTime, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::GetFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT         hr;
    FOLDERINFO      info;
    FOLDERID        idParent;
    BOOL            fOffline;
    IMessageServer *pServer;

    Assert(NULL != m_pLocalStore);

    // if imap or news, pass GetFolderCounts call through to server obj
    // otherwise, this function should not have been called so returns error

    hr = GetFolderServerId(idFolder, &idParent);
    if (hr != S_OK)
        return(E_FAIL);

    hr = _GetFolderInfo(idParent, &info, &fOffline);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder != FOLDER_LOCAL)
        {
            Assert(pCallback != NULL);
            if (pCallback == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (fOffline)
            {
                hr = E_NOT_ONLINE;
            }
            else
            {
                hr = _GetServer(idParent, idParent, info.tyFolder, &pServer);
                if (SUCCEEDED(hr))
                    hr = pServer->GetFolderCounts(idFolder, pCallback);
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}

//--------------------------------------------------------------------------
// CStoreSync::UpdateFolderCounts
//--------------------------------------------------------------------------
STDMETHODIMP CStoreSync::UpdateFolderCounts(FOLDERID idFolder, LONG lMessages,
    LONG lUnread, LONG lWatchedUnread, LONG lWatched)
{
    HRESULT         hr;

    Assert(NULL != m_pLocalStore);

    // local store operation only

    hr = m_pLocalStore->UpdateFolderCounts(idFolder, lMessages, lUnread, lWatchedUnread, lWatched);

    return(hr);
}

STDMETHODIMP CStoreSync::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    if (nCode == CONNNOTIFY_CONNECTED)
    {
        
    }
    else if (((nCode == CONNNOTIFY_WORKOFFLINE) && (pvData)) ||
              (nCode == CONNNOTIFY_DISCONNECTED))
    {
        DWORD   i, j;

        for (j = 0; j < CMAXTHREADS; j++)
        {
            if (m_rgts[j].pEntry != NULL)
            {
                for (i = 0; i < m_rgts[j].cEntry; i++)
                {
                    if (m_rgts[j].pEntry[i].pServer != NULL)
                    {
                        m_rgts[j].pEntry[i].pServer->Close(MSGSVRF_DROP_CONNECTION);
                    }
                }
            }
        }
    }

    return(S_OK);
}

HRESULT CStoreSync::_GetFolderInfo(FOLDERID id, FOLDERINFO *pInfo, BOOL *pfOffline)
{
    HRESULT hr;

    Assert(pInfo != NULL);
    Assert(pfOffline != NULL);

    hr = m_pLocalStore->GetFolderInfo(id, pInfo);
    if (SUCCEEDED(hr))
    {
        //*pfOffline = g_pConMan->IsGlobalOffline();
        *pfOffline = FALSE;
    }

    return(hr);
}

HRESULT CStoreSync::_GetServer(FOLDERID idServer, FOLDERID idFolder, FOLDERTYPE tyFolder, IMessageServer **ppServer)
{
    HRESULT hr;
    IMessageServer *pServer;
    DWORD i;
    FOLDERINFO info;
    SERVERENTRY *pEntry;
    DWORD dwThreadId;
    THREADSERVERS *pts;

    Assert(FOLDER_LOCAL != tyFolder);
    Assert(FOLDER_ROOTNODE != tyFolder);
    Assert(ppServer != NULL);
    Assert(idServer == idFolder);

    // TODO: figure out a way not to hold onto these IMessageServer objects...

    *ppServer = NULL;

    dwThreadId = GetCurrentThreadId();
    Assert(dwThreadId != 0);

    for (i = 0, pts = m_rgts; i < CMAXTHREADS; i++, pts++)
    {
        if (dwThreadId == pts->dwThreadId)
        {
            break;
        }
        else if (pts->dwThreadId == 0)
        {
            pts->dwThreadId = dwThreadId;
            break;
        }
    }
    Assert(i != CMAXTHREADS);

    for (i = 0, pEntry = pts->pEntry; i < pts->cEntry; i++, pEntry++)
    {
        if (pEntry->idFolder == idFolder)
        {
            Assert(pEntry->idServer == idServer);
            *ppServer = pEntry->pServer;
            return(S_OK);
        }
    }

    if (pts->cEntry == pts->cEntryBuf)
    {
        i = pts->cEntryBuf + 16;
        if (!MemRealloc((void **)&pts->pEntry, i * sizeof(SERVERENTRY)))
            return(E_OUTOFMEMORY);
        pts->cEntryBuf = i;
    }

    hr = m_pLocalStore->GetFolderInfo(idServer, &info);
    if (SUCCEEDED(hr))
    {
        hr = CreateMessageServerType(tyFolder, &pServer);
        if (SUCCEEDED(hr))
        {
            hr = pServer->Initialize(m_pLocalStore, idServer, NULL, FOLDERID_INVALID);
            if (SUCCEEDED(hr))
            {
                pEntry = &pts->pEntry[pts->cEntry];
                pEntry->pServer = pServer;
                pEntry->idServer = idServer;
                pEntry->idFolder = idFolder;
                pts->cEntry++;

                *ppServer = pServer;
            }
            else
            {
                pServer->Release();
            }
        }

        m_pLocalStore->FreeRecord(&info);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\sync.h ===
#ifndef _INC_SYNC_H
#define _INC_SYNC_H

#include <syncop.h>

class COfflineSync : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COfflineSync(void);
    ~COfflineSync(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT Initialize(void);
    HRESULT SetMessageFlags(IMessageFolder *pFolder, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags);
    HRESULT CreateMessage(IMessageFolder *pFolder, LPMESSAGEID pidMessage, SAVEMESSAGEFLAGS dwOptions, MESSAGEFLAGS dwFlags, IStream *pStream, IMimeMessage *pMessage);
    HRESULT DeleteMessages(IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList);
    HRESULT CopyMessages(IMessageFolder *pFolder, IMessageFolder *pFolderDest, COPYMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags);

    HRESULT DoPlayback(HWND hwnd, FOLDERID *pId, DWORD cId, FOLDERID idFolderSel);

    HRESULT GetRecordCount(LPDWORD pcRecords) {
        *pcRecords = 0;
        if (m_pDB)
            return(m_pDB->GetRecordCount(IINDEX_PRIMARY, pcRecords));
        return(TraceResult(E_FAIL));
    }

private:
    HRESULT _FindExistingOperation(FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage, DWORD typeSrc, DWORD typeDest, LPSYNCOPINFO pInfo);
    HRESULT _PlaybackServer(HWND hwnd, FOLDERID idServer);
    HRESULT _SetMessageFlags(IMessageFolder *pFolder, FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage, MESSAGEFLAGS dwFlags, LPADJUSTFLAGS pFlags);

    LONG            m_cRef;
    IDatabase      *m_pDB;
};

extern COfflineSync *g_pSync;

#endif // _INC_SYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\exchrep\defguid.h ===
DEFINE_GUID (IID_ExchRep, 0x4abdeb80, 0x98ef, 0x11cf, 0xab, 0x21, 0x00, 0xaa, 0x00, 0xb5, 0x10, 0x52);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\exchrep\exchole.cpp ===
#define INITGUID
#define USES_IID_IMessage
#define USES_IID_IExchExt
#define USES_IID_IExchExtSessionEvents

#include <ole2.h>
#include <initguid.h>
#include <MAPIX.H>
#include <MAPIUTIL.H>
#include <MAPIFORM.H>
#include <MAPIGUID.H>
#include <EXCHEXT.H>
#include "DEFGUID.H"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\storutil.h ===
//--------------------------------------------------------------------------
// Storutil.h
//--------------------------------------------------------------------------
#ifndef __STORUTIL_H
#define __STORUTIL_H

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "newfldr.h"

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CProgress;
typedef struct tagTHREADINGINFO *LPTHREADINGINFO;

//--------------------------------------------------------------------------
// HTIMEOUT
//--------------------------------------------------------------------------
DECLARE_HANDLE(HTIMEOUT);
typedef HTIMEOUT *LPHTIMEOUT;

//--------------------------------------------------------------------------
// HFOLDERENUM
//--------------------------------------------------------------------------
DECLARE_HANDLE(HFOLDERENUM);
typedef HFOLDERENUM *LPHFOLDERENUM;
const HFOLDERENUM HFOLDERENUM_INVALID = NULL;

//--------------------------------------------------------------------------
// SUBSCRIBED BOOLS
//--------------------------------------------------------------------------
#define SUBSCRIBED      TRUE
#define ALL             FALSE

//--------------------------------------------------------------------------
// CLEANUPFOLDERFLAGS
//--------------------------------------------------------------------------
typedef DWORD CLEANUPFOLDERFLAGS;
#define CLEANUP_REMOVE_READ     0x00000001
#define CLEANUP_REMOVE_EXPIRED  0x00000002
#define CLEANUP_REMOVE_ALL      0x00000004
#define CLEANUP_PROGRESS        0x00000008

//--------------------------------------------------------------------------
// CLEANUPFOLDERTYPE
//--------------------------------------------------------------------------
typedef enum tagCLEANUPFOLDERTYPE {
    CLEANUP_COMPACT,
    CLEANUP_DELETE,
    CLEANUP_RESET,
    CLEANUP_REMOVEBODIES
} CLEANUPFOLDERTYPE;

//--------------------------------------------------------------------------
// PFNRECURSECALLBACK
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNRECURSECALLBACK)(LPFOLDERINFO pFolder, 
    BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie);

//--------------------------------------------------------------------------
// RECURSEFLAGS
//--------------------------------------------------------------------------
typedef DWORD RECURSEFLAGS;
#define RECURSE_INCLUDECURRENT      0x00000001
#define RECURSE_ONLYSUBSCRIBED      0x00000002
#define RECURSE_SUBFOLDERS          0x00000004
#define RECURSE_NOLOCALSTORE        0x00000008
#define RECURSE_NOUI                0x00000010
#define RECURSE_ONLYLOCAL           0x00000020
#define RECURSE_ONLYNEWS            0x00000040

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT FlattenHierarchy(IMessageStore *pStore, FOLDERID idParent, BOOL fIncludeParent,
                         BOOL fSubscribedOnly, FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                         LPDWORD pdwUsed);
HRESULT RecurseFolderHierarchy(FOLDERID idFolder, RECURSEFLAGS dwFlags, DWORD dwReserved, DWORD_PTR dwCookie,  PFNRECURSECALLBACK pfnCallback);
HRESULT RecurseFolderCounts(LPFOLDERINFO pFolder, BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie);
int     GetFolderIcon(LPFOLDERINFO pFolder, BOOL fNoStateIcons = FALSE);
int     GetFolderIcon(FOLDERID idFolder, BOOL fNoStateIcons = FALSE);
HRESULT GetFolderStoreInfo(FOLDERID idFolder, LPFOLDERINFO pStore);
HRESULT GetFolderIdFromName(IMessageStore *pStore, LPCSTR pszName, FOLDERID idParent, LPFOLDERID pidFolder);
HRESULT GetStoreRootDirectory(LPSTR pszDir, DWORD cchMaxDir);
HRESULT CreateFolderViewObject(FOLDERID idFolder, HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
HRESULT InitializeLocalStoreDirectory(HWND hwndOwner, BOOL fNoCreate);
HRESULT RelocateStoreDirectory(HWND hwnd,  LPCSTR pszDestBase, BOOL fMove);
HRESULT MigrateLocalStore(HWND hwndParent, LPTSTR pszSrc, LPTSTR pszDest);
HRESULT CreateTempNewsAccount(LPCSTR pszServer, DWORD dwPort, BOOL fSecure, IImnAccount **ppAcct);
HRESULT GetFolderIdFromNewsUrl(LPCTSTR pszServer, UINT uPort, LPCTSTR pszGroup, BOOL fSecure, LPFOLDERID pidFolder);
HRESULT OpenUidlCache(IDatabase **ppDB);
HRESULT GetMessageInfo(IDatabase *pDB, MESSAGEID idMessage, LPMESSAGEINFO pInfo);
HRESULT IsSubFolder(FOLDERID idFolder, FOLDERID idParent);
HRESULT GetDefaultServerId(ACCTTYPE tyAccount, LPFOLDERID pidServer);
HRESULT CloneMessageIDList(LPMESSAGEIDLIST pSourceList, LPMESSAGEIDLIST *ppNewList);
HRESULT CloneAdjustFlags(LPADJUSTFLAGS pFlags, LPADJUSTFLAGS *ppNewFlags);
BOOL    ConnStateIsEqual(IXPSTATUS ixpStatus, CONNECT_STATE csState);
HRESULT CompactFolders(HWND hwndParent, RECURSEFLAGS dwFlags, FOLDERID idFolder);
HRESULT CleanupFolder(HWND hwndParent, RECURSEFLAGS dwRecurse, FOLDERID idFolder, CLEANUPFOLDERTYPE tyCleanup);
HRESULT InitFolderPickerEdit(HWND hwndEdit, FOLDERID idSelected);
FOLDERID GetFolderIdFromEdit(HWND hwndEdit);
HRESULT PickFolderInEdit(HWND hwndParent, HWND hwndEdit, FOLDERDIALOGFLAGS dwFlags, LPCSTR pszTitle, LPCSTR pszText, LPFOLDERID pidSelected);
HRESULT DisplayFolderSizeInfo(HWND hwnd, RECURSEFLAGS dwRecurse, FOLDERID idFolder);
HRESULT GetFolderServerId(FOLDERID idFolder, LPFOLDERID pidServer);
HRESULT CopyMoveMessages(HWND hwnd, FOLDERID src, FOLDERID dst, LPMESSAGEIDLIST pList, COPYMESSAGEFLAGS dwFlags);
HRESULT CompareTableIndexes(LPCTABLEINDEX pIndex1, LPCTABLEINDEX pIndex2);
HRESULT EmptyFolder(HWND hwndParent, FOLDERID idFolder);
HRESULT EmptySpecialFolder(HWND hwndParent, SPECIALFOLDER tySpecial);
HRESULT IsParentDeletedItems(FOLDERID idFolder, LPFOLDERID pidDeletedItems, LPFOLDERID pidServer);
void CleanupTempNewsAccounts(void);
HRESULT CreateMessageServerType(FOLDERTYPE tyFolder, IMessageServer **ppServer);
HRESULT GetFolderAccountId(LPFOLDERINFO pFolder, LPSTR pszAccountId);
HRESULT GetFolderAccountName(LPFOLDERINFO pFolder, LPSTR pszAccountName);
BOOL FHasChildren(LPFOLDERINFO pFolder, BOOL fSubscribed);
FOLDERTYPE GetFolderType(FOLDERID idFolder);
HRESULT GetFolderServer(FOLDERID idFolder, LPFOLDERINFO pServer);
HRESULT SetSynchronizeFlags(FOLDERID idFolder, DWORD flags);
HRESULT EmptyMessageFolder(LPFOLDERINFO pFolder, BOOL fReset, CProgress *pProgress);
HRESULT DeleteAllRecords(LPCTABLESCHEMA pSchema, IDatabase *pDB, CProgress *pProgress);
HRESULT GetFolderIdFromMsgTable(IMessageTable *pTable, LPFOLDERID pidFolder);
HRESULT GetHighestCachedMsgID(IMessageFolder *pFolder, DWORD_PTR *pdwHighestCachedMsgID);
HRESULT DeleteMessageFromStore(MESSAGEINFO * pMsgInfo, IDatabase *pDB, IDatabase *pUidlDB);
BOOL FFolderIsServer(FOLDERID id);
HRESULT LighweightOpenMessage(IDatabase *pDB, LPMESSAGEINFO pHeader, IMimeMessage **ppMessage);
HRESULT GetInboxId(IMessageStore    *pStore, FOLDERID    idParent, FOLDERID    **pprgFIDArray, LPDWORD     pdwUsed);
void GetProtocolString(LPCSTR *ppszResult, IXPTYPE ixpServerType);
HRESULT DoNewsgroupSubscribe(void);
HRESULT GetRidOfMessagesODSFile(void);
HRESULT BuildFriendlyFolderFileName(LPCSTR pszDir, LPFOLDERINFO pFolder, LPSTR pszFilePath, DWORD cchFilePathMax, LPCSTR pszCurrentFile, BOOL *pfChanged);
INT_PTR CALLBACK UpdateNewsgroup(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT HasMarkedMsgs(FOLDERID idFolder, BOOL *pfMarked);
HRESULT CreateMessageTable(FOLDERID idFolder, BOOL fThreaded, IMessageTable **ppTable);
HRESULT SimpleStoreInit(GUID *guid, LPCSTR pszStoreDir);
HRESULT SimpleStoreRelease(void);

//--------------------------------------------------------------------------
// IStoreCallback Utilities
//--------------------------------------------------------------------------
HRESULT CallbackOnLogonPrompt(HWND hwndParent, LPINETSERVER pServer, IXPTYPE ixpServerType);
HRESULT CallbackOnPrompt(HWND hwndParent, HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
HRESULT CallbackCanConnect(LPCSTR pszAccountId, HWND hwndParent, BOOL fPrompt);
HRESULT CallbackCloseTimeout(LPHTIMEOUT phTimeout);
HRESULT CallbackOnTimeout(LPINETSERVER pServer, IXPTYPE ixpServerType, DWORD dwTimeout,
                          ITimeoutCallback *pCallback, LPHTIMEOUT phTimeout);
HRESULT CallbackOnTimeoutResponse(TIMEOUTRESPONSE eResponse, IOperationCancel *pCancel, LPHTIMEOUT phTimeout);
HRESULT CallbackDisplayError(HWND hwndParent, HRESULT hrResult, LPSTOREERROR pError);

//---------------------------------------------------------------------------
// Folder hierarchy hash table helpers
//---------------------------------------------------------------------------
HRESULT CreateFolderHash(IMessageStore *pStore, FOLDERID idRoot, IHashTable **ppHash);
HRESULT UnsubscribeHashedFolders(IMessageStore *pStore, IHashTable *pHash);

//---------------------------------------------------------------------------
// Creating a MimeMessage from the cache
//---------------------------------------------------------------------------
HRESULT CreateMessageFromInfo(MESSAGEINFO *pInfo, IMimeMessage **ppMessage, FOLDERID folderID);

//---------------------------------------------------------------------------
// Adding a MimeMessage from the cache
//---------------------------------------------------------------------------
HRESULT CommitMessageToStore(IMessageFolder *pFolder, ADJUSTFLAGS *pflags, MESSAGEID idMessage, LPSTREAM pstm);

//---------------------------------------------------------------------------
// Creating a new persistent stream
//---------------------------------------------------------------------------
HRESULT CreatePersistentWriteStream(IMessageFolder *pFolder, IStream **ppStream, LPFILEADDRESS pfaStream);

//---------------------------------------------------------------------------
// Debugging helpers
//---------------------------------------------------------------------------
#ifdef DEBUG
LPCSTR sotToSz(STOREOPERATIONTYPE sot);
#endif

#endif // __STORUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\storutil.cpp ===
//----------------------------------------------------------------------------------
// Storutil.cpp
//----------------------------------------------------------------------------------
#include "pch.hxx"
#include "optres.h"
#include "frntpage.h"
#include "acctview.h"
#include "storfldr.h"
#include "shared.h"
#include "util.h"
#include "msgview.h"
#include "storutil.h"
#include "xpcomm.h"
#include "migerror.h"
#include "storecb.h"
#include "taskutil.h"
#include "flagconv.h"
#include "msgfldr.h"
#include "syncop.h"
#include "store.h"
#include "storsync.h"
#include "shlwapip.h" 
#include <multiusr.h>
#include "instance.h"
#include <newsdlgs.h>
#include "msgtable.h"
#include "newsstor.h"
#include "..\imap\imapsync.h"
#include "..\http\httpserv.h"
#include "demand.h"
#include "acctutil.h"

//----------------------------------------------------------------------------------
// Consts
//----------------------------------------------------------------------------------
#define FIDARRAY_START 50
#define FIDARRAY_GROW  50

//----------------------------------------------------------------------------------
// DELETEMSGS
//----------------------------------------------------------------------------------
typedef struct tagDELETEMSGS {
    LPCSTR               pszRootDir;
    CProgress           *pProgress;
    BOOL                 fReset;
} DELETEMSGS, *LPDELETEMSGS;

//----------------------------------------------------------------------------------
// REMOVEBODIES
//----------------------------------------------------------------------------------
typedef struct tagREMOVEBODIES {
    CProgress           *pProgress;
    CLEANUPFOLDERFLAGS   dwFlags;
    DWORD                cExpireDays;
} REMOVEBODIES, *LPREMOVEBODIES;

//----------------------------------------------------------------------------------
// ENUMFOLDERSIZE
//----------------------------------------------------------------------------------
typedef struct tagENUMFOLDERSIZE {
    DWORD           cbFile;
    DWORD           cbFreed;
    DWORD           cbStreams;
} ENUMFOLDERSIZE, *LPENUMFOLDERSIZE; 

//----------------------------------------------------------------------------------
// FOLDERENUMINFO
//----------------------------------------------------------------------------------
typedef struct tagFOLDERENUMINFO {
    FOLDERID   *prgFIDArray;
    DWORD       dwNumFolderIDs;
    DWORD       dwCurrentIdx;
} FOLDERENUMINFO;

//----------------------------------------------------------------------------------
// COMPACTCOOKIE
//----------------------------------------------------------------------------------
typedef struct tagCOMPACTCOOKIE {
    HWND        hwndParent;
    BOOL        fUI;
    CProgress  *pProgress;
} COMPACTCOOKIE, *LPCOMPACTCOOKIE;
  
//----------------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------------
HRESULT FixPOP3UIDLFile(IDatabase *pDB);
HRESULT HashChildren(IMessageStore *pStore, FOLDERID idParent, IHashTable *pHash,
                     LPSTR *ppszPath, DWORD dwChildOffset, DWORD *pdwAlloc);
HRESULT FlattenHierarchyHelper(IMessageStore *pStore, FOLDERID idParent,
                               BOOL fIncludeParent, BOOL fSubscribedOnly,
                               FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                               LPDWORD pdwUsed);

const static char c_szFolderFileSep[] = " - ";

// --------------------------------------------------------------------------------
// CreateMessageTable
// --------------------------------------------------------------------------------
HRESULT CreateMessageTable(FOLDERID idFolder, BOOL fThreaded, IMessageTable **ppTable)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERSORTINFO  SortInfo;
    IMessageTable  *pTable=NULL;

    // Trace
    TraceCall("CreateMessageTable");

    // Init
    *ppTable = NULL;

    // Allocate the Table
    IF_NULLEXIT(pTable = new CMessageTable);

    // Initialize the Message Table
    IF_FAILEXIT(hr = pTable->Initialize(idFolder, NULL, FALSE, NULL));

    // Get the Current Sort Info
    IF_FAILEXIT(hr = pTable->GetSortInfo(&SortInfo));

    // Set fThread
    SortInfo.fThreaded = fThreaded;

    // Sort It...
    IF_FAILEXIT(hr = pTable->SetSortInfo(&SortInfo, NULL));

    // Return It
    *ppTable = pTable;

    // Don't Release It
    pTable = NULL;

exit:
    // Cleanup
    SafeRelease(pTable);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetAvailableDiskSpace
// --------------------------------------------------------------------------------
HRESULT GetAvailableDiskSpace(
	/* in */        LPCSTR                      pszFilePath,
	/* out */       DWORDLONG                   *pdwlFree)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szDrive[5];
    DWORD       dwSectorsPerCluster;
    DWORD       dwBytesPerSector;
    DWORD       dwNumberOfFreeClusters;
    DWORD       dwTotalNumberOfClusters;

    // Trace
    TraceCall("GetAvailableDiskSpace");

    // Invalid Args
    Assert(pszFilePath && pszFilePath[1] == ':' && pdwlFree);

    // Split the path
    szDrive[0] = *pszFilePath;
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = '\0';
    
    // Get free disk space - if it fails, lets pray we have enought disk space
    if (!GetDiskFreeSpace(szDrive, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
	    hr = TraceResult(E_FAIL);
	    goto exit;
    }

    // Return Amount of Free Disk Space
    *pdwlFree = (dwNumberOfFreeClusters * (dwSectorsPerCluster * dwBytesPerSector));

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// GetFolderAccountName
//--------------------------------------------------------------------------
HRESULT GetFolderAccountName(LPFOLDERINFO pFolder, LPSTR pszAccountName)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];

    // Trace
    TraceCall("GetFolderAccountName");

    // Get Folder AccountId
    IF_FAILEXIT(hr = GetFolderAccountId(pFolder, szAccountId));

    // Find the Account
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

    // Get the Account Name
    IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, pszAccountName, CCHMAX_ACCOUNT_NAME));

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// BuildFriendlyFolderFileName
//--------------------------------------------------------------------------
HRESULT BuildFriendlyFolderFileName(LPCSTR pszDir, LPFOLDERINFO pFolder, 
    LPSTR pszFilePath, DWORD cchFilePathMax, LPCSTR pszCurrentFile,
    BOOL *pfChanged)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFileName=NULL;
    LPSTR           pszTemp=NULL;
    DWORD_PTR       i;
    CHAR            szFile[MAX_PATH];
    CHAR            szAccountName[CCHMAX_ACCOUNT_NAME];
    DWORD           cchFileName;

    // Validate
    Assert(pszDir && pFolder && pFolder->pszName && pszFilePath && cchFilePathMax >= MAX_PATH);

    // Init
    if (pfChanged)
        *pfChanged = TRUE;

    // Keep the names basic (i.e. no account prefix) for news and local folders.
    if (FOLDER_NEWS == pFolder->tyFolder || FOLDER_LOCAL == pFolder->tyFolder)
    {
        // No Account name Prefix
        *szAccountName = '\0';
    }

    // Otherwise
    else
    {
        // Get Folder Account Name
        IF_FAILEXIT(hr = GetFolderAccountName(pFolder, szAccountName));
    }

    // Build the name
    IF_NULLEXIT(pszFileName = PszAllocA(lstrlen(szAccountName) + lstrlen(pFolder->pszName) + lstrlen(c_szFolderFileSep) + 1));

    // Format the Name
    cchFileName = wsprintf(pszFileName, "%s%s%s", szAccountName, *szAccountName ? c_szFolderFileSep : c_szEmpty, pFolder->pszName);

    // Cleanup the filename
    CleanupFileNameInPlaceA(CP_ACP, pszFileName);

    // Same As Current ?
    if (pszCurrentFile)
    {
        // Add a .dbx extension to pszFilename
        IF_NULLEXIT(pszTemp = PszAllocA(cchFileName + lstrlen(c_szDbxExt) + 1));

        // Format psztemp
        wsprintf(pszTemp, "%s%s", pszFileName, c_szDbxExt);

        // Not Changed ?
        if (0 == lstrcmpi(pszTemp, pszCurrentFile))
        {
            // Not Changed
            if (pfChanged)
                *pfChanged = FALSE;

            // Done
            goto exit;
        }
    }

    // Build szDstFile
    hr = GenerateUniqueFileName(pszDir, pszFileName, c_szDbxExt, pszFilePath, cchFilePathMax);

    // If that failed, then try to generate a unqiue name
    if (FAILED(hr))
    {
        // Reset hr
        hr = S_OK;

        // Loop
        for (i=(DWORD_PTR)pFolder->idFolder;;i++)
        {
            // Format the File Name
            wsprintf(szFile, "%08d%s", i, c_szDbxExt);

            // Make the file path
            IF_FAILEXIT(hr = MakeFilePath(pszDir, szFile, c_szEmpty, pszFilePath, cchFilePathMax));

            // If the file still exists, renumber szFile until it doesn't exist
            if (FALSE == PathFileExists(pszFilePath))
                break;
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);
    SafeMemFree(pszTemp);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// PutMessagesIntoFolder
//--------------------------------------------------------------------------
HRESULT PutMessagesIntoFolder(CProgress *pProgress, IDatabase *pStreams, 
    IMessageFolder *pFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};
    STREAMINFO      Stream={0};

    // Walk through the Folder
    IF_FAILEXIT(hr = pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk It
    while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Has a idStream ?
        if (Message.idStreamOld)
        {
            // Initialize Message
            Message.faStream = 0;
            Message.Offsets.cbSize = 0;
            Message.Offsets.pBlobData = NULL;
            Message.idParentOld = 0;
            Message.ThreadIdOld.pBlobData = 0;
            Message.ThreadIdOld.cbSize = 0;
            Message.pszUserNameOld = NULL;

            // Set the Streamid
            Stream.idStream = Message.idStreamOld;

            // Find the Stream
            if (DB_S_FOUND == pStreams->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Stream, NULL))
            {
                // faStream ?
                if (Stream.faStream)
                {
                    // Copy the Stream
                    IF_FAILEXIT(hr = pStreams->CopyStream(pFolder, Stream.faStream, &Message.faStream));

                    // Save the Offsets
                    Message.Offsets = Stream.Offsets;
                }

                // Free
                pStreams->FreeRecord(&Stream);
            }

            // Clear idStreamOld
            Message.idStreamOld = 0;
        }

        // Update the Record
        IF_FAILEXIT(hr = pFolder->UpdateRecord(&Message));

        // Cleanup
        pFolder->FreeRecord(&Message);

        // Update Progress
        pProgress->HrUpdate(1);
    }

exit:
    // Cleanup
    pStreams->FreeRecord(&Stream);
    pFolder->FreeRecord(&Message);
    pFolder->CloseRowset(&hRowset);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// GetRidOfMessagesODSFile
//--------------------------------------------------------------------------
HRESULT GetRidOfMessagesODSFile(void)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    CHAR            szStoreRoot[MAX_PATH];
    CHAR            szMessagesFile[MAX_PATH];
    CHAR            szFile[MAX_PATH];
    CHAR            szSrcFile[MAX_PATH + MAX_PATH];
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    CHAR            szRes[255];
    IDatabase      *pStreams=NULL;
    IMessageFolder *pFolder=NULL;
    HROWSET         hRowset=NULL;
    DWORD           cRecords;
    DWORD           cTotal=0;
    DWORD           cbFile;
    DWORDLONG       dwlDiskFree;
    BOOL            fErrorDisplayed=FALSE;
    LPSTR           pszExt=NULL;
    CProgress       cProgress;

    // Trace
    TraceCall("GetRidOfMessagesODSFile");

    // Validate
    Assert(g_pDBSession);

    // Error Box
    AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMigrateMessagesODS), 0, MB_OK | MB_ICONEXCLAMATION);

    // Get Uidcache file path
    IF_FAILEXIT(hr = GetStoreRootDirectory(szStoreRoot, sizeof(szStoreRoot)));

    // Make File Path
    IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, "messages.ods", c_szEmpty, szMessagesFile, sizeof(szMessagesFile)));

    // Allocate Table Object
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szMessagesFile, NOFLAGS, &g_StreamTableSchema, NULL, &pStreams));

    // Do a file size Check...
    IF_FAILEXIT(hr = pStreams->GetSize(&cbFile, NULL, NULL, NULL));

    // Get Available DiskSpace
    IF_FAILEXIT(hr = GetAvailableDiskSpace(szStoreRoot, &dwlDiskFree));

    // Not Enought Disk Space
    if (((DWORDLONG) cbFile) > dwlDiskFree)
    {
        // Locals
        CHAR szRes[255];
        CHAR szMsg[255];
        CHAR szSize[50];

        // cbFile is DWORD and in this case we can downgrade dwlDiskFree to DWORD
        // Format the Size Needed
        StrFormatByteSizeA(cbFile - ((DWORD) dwlDiskFree), szSize, ARRAYSIZE(szSize));

        // Load the REs
        AthLoadString(idsMigMsgsODSNoDiskSpace, szRes, ARRAYSIZE(szRes));

        // Format the Message
        wsprintf(szMsg, szRes, szSize, szStoreRoot);

        // Display the Message
        AthMessageBox(NULL, MAKEINTRESOURCE(idsAthena), szMsg, 0, MB_OK | MB_ICONEXCLAMATION);

        // Error Displayed
        fErrorDisplayed = TRUE;

        // Build
        hr = TraceResult(DB_E_DISKFULL);

        // Done
        goto exit;
    }

    // Enumerate through subscribed folders....
    IF_FAILEXIT(hr = g_pStore->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Loop
    while (S_OK == g_pStore->QueryRowset(hRowset, 1, (LPVOID *)&Folder, NULL))
    {
        // Open the folder
        if (Folder.pszFile && SUCCEEDED(g_pStore->OpenFolder(Folder.idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder)))
        {
            // Cleanup
            g_pStore->FreeRecord(&Folder);

            // Refetch the folderinfo because opening a folder can update the folder info...
            IF_FAILEXIT(hr = g_pStore->GetFolderInfo(Folder.idFolder, &Folder));

            // Get Extension
            pszExt = PathFindExtensionA(Folder.pszFile);

            // Get Record Count
            IF_FAILEXIT(hr = pFolder->GetRecordCount(IINDEX_PRIMARY, &cRecords));

            // Put the messages into the folder
            cTotal += cRecords;

            // If not a .dbx file yet
            if (NULL == pszExt || lstrcmpi(pszExt, c_szDbxExt) != 0)
            {
                // Build szSrcFile
                IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, Folder.pszFile, c_szEmpty, szSrcFile, sizeof(szSrcFile)));

                // Release
                SafeRelease(pFolder);

                // Build Friendly Name
                IF_FAILEXIT(hr = BuildFriendlyFolderFileName(szStoreRoot, &Folder, szDstFile, ARRAYSIZE(szDstFile), NULL, NULL));

                // Delete the Dest
                DeleteFile(szDstFile);

                // Store 
                if (0 == MoveFile(szSrcFile, szDstFile))
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }

                // Get the new pszFile...
                Folder.pszFile = PathFindFileName(szDstFile);

                // Update the Record
                IF_FAILEXIT(hr = g_pStore->UpdateRecord(&Folder));
            }

            // Release
            SafeRelease(pFolder);
        }

        // Otherwise, if there is a file name, lets reset it
        else if (Folder.pszFile)
        {
            // Cleanup
            g_pStore->FreeRecord(&Folder);

            // Refetch the folderinfo because opening a folder can update the folder info...
            IF_FAILEXIT(hr = g_pStore->GetFolderInfo(Folder.idFolder, &Folder));

            // Get the new pszFile...
            Folder.pszFile = NULL;

            // Update the Record
            IF_FAILEXIT(hr = g_pStore->UpdateRecord(&Folder));
        }

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Get the Title
    AthLoadString(idsMigDBXTitle, szRes, ARRAYSIZE(szRes));

    // Create a Progress Meter...
    cProgress.Init(NULL, szRes, NULL, cTotal, idanCompact, FALSE);

    // Show the Progress
    cProgress.Show();

    // Seek the rowset
    IF_FAILEXIT(hr = g_pStore->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, 0, NULL));

    // Loop
    while (S_OK == g_pStore->QueryRowset(hRowset, 1, (LPVOID *)&Folder, NULL))
    {
        // Open the folder
        if (Folder.pszFile && SUCCEEDED(g_pStore->OpenFolder(Folder.idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder)))
        {
            // Set the Message
            cProgress.SetMsg(Folder.pszName);

            // Put the messages into the folder
            IF_FAILEXIT(hr = PutMessagesIntoFolder(&cProgress, pStreams, pFolder));

            // Release
            SafeRelease(pFolder);
        }

        // Better not have a file
        else
            Assert(NULL == Folder.pszFile);

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Release the Streams File so that I can delete it
    SafeRelease(pStreams);

    // Delete messages.ods
    DeleteFile(szMessagesFile);

exit:
    // Cleanup
    SafeRelease(pStreams);
    SafeRelease(pFolder);
    g_pStore->CloseRowset(&hRowset);
    g_pStore->FreeRecord(&Folder);

    // Show an Error
    if (FAILED(hr) && FALSE == fErrorDisplayed)
    {
        // Show an Error
        AthErrorMessageW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsMigMsgsODSError), hr);
    }

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderIdFromMsgTable
//----------------------------------------------------------------------------------
HRESULT GetFolderIdFromMsgTable(IMessageTable *pTable, LPFOLDERID pidFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    IMessageFolder     *pFolder=NULL;
    IServiceProvider   *pService=NULL;

    // Trace
    TraceCall("GetFolderIdFromMsgTable");

    // Invalid Args
    Assert(pTable && pidFolder);

    // Get IServiceProvider
    IF_FAILEXIT(hr = pTable->QueryInterface(IID_IServiceProvider, (LPVOID *)&pService));

    // Get IID_IMessageFolder
    IF_FAILEXIT(hr = pService->QueryService(IID_IMessageFolder, IID_IMessageFolder, (LPVOID *)&pFolder));

    // Get the Folder id
    IF_FAILEXIT(hr = pFolder->GetFolderId(pidFolder));

exit:
    // Cleanup
    SafeRelease(pFolder);
    SafeRelease(pService);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// EmptyMessageFolder
//----------------------------------------------------------------------------------
HRESULT EmptyMessageFolder(LPFOLDERINFO pFolder, BOOL fReset, CProgress *pProgress)
{
    // Locals
    HRESULT         hr=S_OK;
    CMessageFolder *pObject=NULL;

    // Trace
    TraceCall("EmptyMessageFolder");

    // Invalid Args
    Assert(pFolder);

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        goto exit;

    // Root
    if (FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // No File
    if (NULL == pFolder->pszFile)
        goto exit;

    // New CMessageFolder
    IF_NULLEXIT(pObject = new CMessageFolder);

    // Open the folder
    if (FAILED(pObject->Initialize(g_pStore, NULL, OPEN_FOLDER_NOCREATE, pFolder->idFolder)))
        goto exit;
    
    // If this is a news folder ?
    if (fReset)
    {
        // Update pFolder
        pFolder->dwClientHigh = pFolder->dwClientLow = 0;
        pFolder->dwNotDownloaded = 0;
        pFolder->Requested.cbSize = 0;
        pFolder->Requested.pBlobData = NULL;

        // Update the Folder
        IF_FAILEXIT(hr = g_pStore->UpdateRecord(pFolder));
    }

    // Delete All Record
    IF_FAILEXIT(hr = pObject->DeleteMessages(DELETE_MESSAGE_NOPROMPT | DELETE_MESSAGE_NOTRASHCAN, NULL, NULL, (IStoreCallback *)pProgress));

exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// DeleteAllRecords
//----------------------------------------------------------------------------------
HRESULT DeleteAllRecords(LPCTABLESCHEMA pSchema, IDatabase *pDB,
    CProgress *pProgress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPVOID          pBinding=NULL;
    HROWSET         hRowset=NULL;
    HLOCK           hNotifyLock=NULL;

    // Trace
    TraceCall("DeleteAllRecords");

    // Lock Down Notifications
    pDB->LockNotify(NOFLAGS, &hNotifyLock);
    
    // Allocate a record
    IF_NULLEXIT(pBinding = ZeroAllocate(pSchema->cbBinding));

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // While we have a node address
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)pBinding, NULL))
    {
        // Delete this record
        IF_FAILEXIT(hr = pDB->DeleteRecord(pBinding));

        // Free Record Data
        pDB->FreeRecord(pBinding);

        // Do Progress
        if (pProgress)
        {
            // Do Some Progress
            IF_FAILEXIT(hr = pProgress->HrUpdate(1));
        }
    }

exit:
    // Cleanup
    if (pBinding)
    {
        pDB->FreeRecord(pBinding);
        g_pMalloc->Free(pBinding);
    }

    // Close Rowset
    pDB->CloseRowset(&hRowset);

    // Lock Down Notifications
    pDB->UnlockNotify(&hNotifyLock);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetFolderServerId
// --------------------------------------------------------------------------------
HRESULT GetFolderServerId(FOLDERID idFolder, LPFOLDERID pidServer)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Server={0};

    // Trace
    TraceCall("GetFolderServerId");

    // Get the Server Info
    IF_FAILEXIT(hr = GetFolderServer(idFolder, &Server));

    // Return Server
    *pidServer = Server.idFolder;

exit:
    // Cleanup
    g_pStore->FreeRecord(&Server);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderServer
//----------------------------------------------------------------------------------
HRESULT GetFolderServer(FOLDERID idFolder, LPFOLDERINFO pServer)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetFolderServer");

    // Walk the Parent Chain
    while (1)
    {
        // Get Folder Info
        hr = g_pStore->GetFolderInfo(idFolder, pServer);
        if (FAILED(hr))
            goto exit;

        // Is this a server ?
        if (ISFLAGSET(pServer->dwFlags, FOLDER_SERVER))
            goto exit;

        // Set Next
        idFolder = pServer->idParent;

        // Free
        g_pStore->FreeRecord(pServer);
    }

exit:
    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderType
//----------------------------------------------------------------------------------
FOLDERTYPE GetFolderType(FOLDERID idFolder)
{
    // Locals
    FOLDERINFO Folder;

    // Trace
    TraceCall("GetFolderType");

    // Get Folder Info
    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
    {
        // Get the Type
        FOLDERTYPE tyFolder = Folder.tyFolder;

        // Cleanup
        g_pStore->FreeRecord(&Folder);

        // Done
        return(tyFolder);
    }

    // Done
    return(FOLDER_ROOTNODE);
}

//----------------------------------------------------------------------------------
// FHasChildren
//----------------------------------------------------------------------------------
BOOL FHasChildren(LPFOLDERINFO pFolder, BOOL fSubscribed)
{
    // Locals
    HRESULT             hr=S_OK;
    BOOL                fHasChildren=FALSE;
    FOLDERINFO          Folder;
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("FHasChildren");

    // Create Enumerator
    IF_FAILEXIT(hr = g_pStore->EnumChildren(pFolder->idFolder, fSubscribed, &pChildren));

    // Get first row
    if (S_OK == pChildren->Next(1, &Folder, NULL))
    {
        // Has Children
        fHasChildren = TRUE;

        // Free Record
        g_pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    SafeRelease(pChildren);

    // Done
    return(fHasChildren);
}

//----------------------------------------------------------------------------------
// GetFolderAccountId
//----------------------------------------------------------------------------------
HRESULT GetFolderAccountId(LPFOLDERINFO pFolder, LPSTR pszAccountId)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Server={0};

    // Trace
    TraceCall("GetFolderAccountId");

    // Args
    Assert(pFolder && pszAccountId);

    // If this is a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
    {
        // Validate
        Assert(!FIsEmptyA(pFolder->pszAccountId));

        // Copy It
        lstrcpyn(pszAccountId, pFolder->pszAccountId, CCHMAX_ACCOUNT_NAME);

        // Done
        goto exit;
    }

    // Validate
    Assert(FIsEmptyA(pFolder->pszAccountId));

    // Get Server Info
    IF_FAILEXIT(hr = GetFolderServer(pFolder->idFolder, &Server));

    // Copy Account Id
    if (FIsEmptyA(Server.pszAccountId))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Copy It
    lstrcpyn(pszAccountId, Server.pszAccountId, CCHMAX_ACCOUNT_NAME);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Server);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// CreateMessageServerType
//----------------------------------------------------------------------------------
HRESULT CreateMessageServerType(FOLDERTYPE tyFolder, IMessageServer **ppServer)
{
    // Locals
    HRESULT     hr=S_OK;
    IUnknown   *pUnknown=NULL;

    // Trace
    TraceCall("CreateMessageServerType");

    // Handle Folder
    switch(tyFolder)
    {
    case FOLDER_NEWS:
        IF_FAILEXIT(hr = CreateNewsStore(NULL, &pUnknown));
        break;

    case FOLDER_IMAP:
        IF_FAILEXIT(hr = CreateImapStore(NULL, &pUnknown));
        break;

    case FOLDER_HTTPMAIL:
        IF_FAILEXIT(hr = CreateHTTPMailStore(NULL, &pUnknown));
        break;

    default:
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // QI Unknown
    IF_FAILEXIT(hr = pUnknown->QueryInterface(IID_IMessageServer, (LPVOID *)ppServer));

exit:
    // Cleanup
    SafeRelease(pUnknown);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetDefaultServerId
//----------------------------------------------------------------------------------
HRESULT GetDefaultServerId(ACCTTYPE tyAccount, LPFOLDERID pidServer)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    FOLDERID        idServer;
    DWORD           dwServers;
    CHAR            szAcctId[CCHMAX_ACCOUNT_NAME];

    // Trace
    TraceCall("GetDefaultServerId");

    // Invalid Args
    Assert(pidServer);

    // Get the Default Account
    IF_FAILEXIT(hr = g_pAcctMan->GetDefaultAccount(tyAccount, &pAccount));

    // Get Server Types
    IF_FAILEXIT(hr = pAccount->GetServerTypes(&dwServers));

    // If POP3, special case to the local store
    if (ISFLAGSET(dwServers, SRV_POP3))
    {
        // Set Id
        *pidServer = FOLDERID_LOCAL_STORE;

        // Done
        goto exit;
    }

    // Get the Account Id
    IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAcctId, ARRAYSIZE(szAcctId)));

    // Get the Server Id
    IF_FAILEXIT(hr = g_pStore->FindServerId(szAcctId, pidServer));

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// IsSubFolder
//----------------------------------------------------------------------------------
HRESULT IsSubFolder(FOLDERID idFolder, FOLDERID idParent)
{
    // Locals
    HRESULT     hr = S_OK;
    FOLDERINFO  Folder={0};
    FOLDERID    idCurrent = idFolder;

    // Trace
    TraceCall("IsSubFolder");

    // Invalid Args
    Assert(idFolder != FOLDERID_INVALID);
    Assert(idParent != FOLDERID_INVALID);

    // Walk up the parent chain
    while (SUCCEEDED(hr = g_pStore->GetFolderInfo(idCurrent, &Folder)))
    {
        // Done ?
        if (Folder.idParent == idParent)
        {
            // Cleanup
            g_pStore->FreeRecord(&Folder);

            // Done
            break;
        }

        // Goto Parent
        idCurrent = Folder.idParent;

        // Cleanup
        g_pStore->FreeRecord(&Folder);

#ifdef _WIN64
		INT_PTR p = (INT_PTR) idCurrent;
		INT_PTR n = (INT_PTR) FOLDERID_INVALID;
		if ((((int) p) & 0xffffffff) == (((int) n) & 0xffffffff))
#else
        if (idCurrent == FOLDERID_INVALID)
#endif // _WIN64
        {
            hr = S_FALSE;
            break;
        }
    }

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetMessageInfo
//----------------------------------------------------------------------------------
HRESULT GetMessageInfo(IDatabase *pDB, MESSAGEID idMessage,
    LPMESSAGEINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("GetMessageInfo");

    // Set pInfo
    pInfo->idMessage = idMessage;

    // Return
    IF_FAILEXIT(hr = pDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pInfo, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

    // Found
    hr = S_OK;

exit:
    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// GetFolderIdFromName
//----------------------------------------------------------------------------------
HRESULT GetFolderIdFromName(IMessageStore *pStore, LPCSTR pszName, FOLDERID idParent, 
    LPFOLDERID pidFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("GetFolderIdFromName");

    // Invalid Args
    if (NULL == pszName)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *pidFolder = FOLDERID_INVALID;

    // Fill Folder
    Folder.idParent = idParent;
    Folder.pszName = (LPSTR)pszName;

    // Do a Find Record
    IF_FAILEXIT(hr = pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL));

    // Not Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

    // Return
    *pidFolder = Folder.idFolder;

exit:
    // Cleanup
    pStore->FreeRecord(&Folder);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// GetFolderStoreInfo
//----------------------------------------------------------------------------------
HRESULT GetFolderStoreInfo(FOLDERID idFolder, LPFOLDERINFO pStore)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERID    idCurrent=idFolder;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("GetFolderStoreInfo");

    // Walk the Parent Chain
    while (1)
    {
        // Get Current Folder Info
        IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idCurrent, &Folder));

        // No Parent
        if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            // Copy to pStore
            CopyMemory(pStore, &Folder, sizeof(FOLDERINFO));

            // Don't Free It
            ZeroMemory(&Folder, sizeof(FOLDERINFO));

            // Done
            goto exit;
        }

        // Goto Parent
        idCurrent = Folder.idParent;
    
        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// GetFolderIcon
//----------------------------------------------------------------------------------
int GetFolderIcon(FOLDERID idFolder, BOOL fNoStateIcons)
{
    // Locals
    HRESULT     hr=S_OK;
    int         iIcon=iFolderClosed;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("GetFolderIcon");

    // Get Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

    // Get the Icon
    iIcon = GetFolderIcon(&Folder);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return iIcon;
}

//----------------------------------------------------------------------------------
// GetFolderIcon
//----------------------------------------------------------------------------------
int GetFolderIcon(LPFOLDERINFO pFolder, BOOL fNoStateIcons)
{
    // Locals
    int iIcon=iFolderClosed;

    // Trace
    TraceCall("GetFolderIcon");

    // Invalid Args
    if (NULL == pFolder)
        return TraceResult(E_INVALIDARG);

    if (FOLDER_ROOTNODE == pFolder->tyFolder)
    {
        if (g_dwAthenaMode & MODE_NEWSONLY)
        {
            iIcon = iNewsRoot;
        }
        else
        {
            iIcon = iMailNews;

        }
    }

    // News
    else if (FOLDER_NEWS == pFolder->tyFolder)
    {
        // New Server ?
        if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        {
            // Subscribed Server
            if (ISFLAGSET(pFolder->dwFlags, FOLDER_SUBSCRIBED))
                iIcon = iNewsServer;

            // Otherwise, non-subscribed new server
            else
                iIcon = iUnsubServer;
        }

        // Synchronize...
        else if (!fNoStateIcons && !!(pFolder->dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
            iIcon = iNewsGroupSync;

        // Subscribed ?
        else if (ISFLAGSET(pFolder->dwFlags, FOLDER_SUBSCRIBED))
            iIcon = iNewsGroup;

        // Otherwise, not subscribed
        else
            iIcon = iUnsubGroup;
    }

    // Local Store, IMAP and HTTP servers
    else
    {
        // Local Folders
        if (FOLDERID_LOCAL_STORE == pFolder->idFolder)
            iIcon = iLocalFolders;

        // Mail Server
        else if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        {
            // msn branded server
            if (ISFLAGSET(pFolder->dwFlags, FOLDER_MSNSERVER))
                iIcon = iMsnServer;

            // otherwise, generic mail server
            else
                iIcon = iMailServer;
        }

        // Not Special
        else if (FOLDER_NOTSPECIAL == pFolder->tySpecial)
        {
            if (!fNoStateIcons && !!(pFolder->dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
                iIcon = iFolderDownload;
            else
                iIcon = iFolderClosed;
        }

        // Otherwise, base off of special folder type
        // but we don't have a special icon for Bulk mail folder
        else if (!fNoStateIcons && !!(pFolder->dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)))
            iIcon = (iInboxDownload + (((pFolder->tySpecial == FOLDER_BULKMAIL) ? FOLDER_JUNK : pFolder->tySpecial) - 1));
        else
            iIcon = (iInbox + (((pFolder->tySpecial == FOLDER_BULKMAIL) ? FOLDER_JUNK : pFolder->tySpecial) - 1));
    }

    // Done
    return iIcon;
}


//----------------------------------------------------------------------------------
// GetStoreRootDirectory
//----------------------------------------------------------------------------------
HRESULT GetStoreRootDirectory(LPSTR pszDir, DWORD cchMaxDir)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cb;
    DWORD       dwType;

    // Trace
    TraceCall("GetStoreRootDirectory");

    // Get the Root Directory
    cb = cchMaxDir;
    if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRegStoreRootDir, &dwType, (LPBYTE)pszDir, &cb))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Expand the string's enviroment vars
    if (dwType == REG_EXPAND_SZ)
    {
        // Locals
        CHAR szExpanded[MAX_PATH];

        // Expand enviroment strings
        cb = ExpandEnvironmentStrings(pszDir, szExpanded, ARRAYSIZE(szExpanded));

        // Failure
        if (cb == 0 || cb > ARRAYSIZE(szExpanded))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Copy into szRoot
        lstrcpyn(pszDir, szExpanded, ARRAYSIZE(pszDir));
    }

    // Get the length
    cb = lstrlen(pszDir);

    // No root
    if (0 == cb)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Fixup the end
    PathRemoveBackslash(pszDir);

    // If the directory doesn't exist yet ?
    if (FALSE == PathIsDirectory(pszDir))
    {
        // Our default directory doesn't exist, so create it
        IF_FAILEXIT(hr = OpenDirectory(pszDir));
    }

exit:
    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// CreateFolderViewObject
//----------------------------------------------------------------------------------
HRESULT CreateFolderViewObject(FOLDERID idFolder, HWND hwndOwner, 
    REFIID riid, LPVOID * ppvOut)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("CreateFolderViewObject");

    // Get Folder Info
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

    // Root Object
    if (FOLDERID_ROOT == idFolder)
    {
        CFrontPage *pFP = new CFrontPage();
        if (pFP)
        {
            if (SUCCEEDED(pFP->HrInit(idFolder)))
            {
                hr = pFP->QueryInterface(riid, ppvOut);
            }
            pFP->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
    {
        CAccountView *pAV = new CAccountView();

        if (pAV)
        {
            if (SUCCEEDED(pAV->HrInit(idFolder)))
            {
                hr = pAV->QueryInterface(riid, ppvOut);
            }
            pAV->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        CMessageView *pMV = new CMessageView();
        if (pMV)
        {
            if (SUCCEEDED(pMV->Initialize(idFolder)))
            {
                hr = pMV->QueryInterface(riid, ppvOut);
            }
            pMV->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// OpenUidlCache
//----------------------------------------------------------------------------------
HRESULT OpenUidlCache(IDatabase **ppDB)
{
    // Locals
    HRESULT       hr=S_OK;
    CHAR          szStoreRoot[MAX_PATH];
    CHAR          szFilePath[MAX_PATH];
    IDatabase    *pDB=NULL;

    // Trace
    TraceCall("OpenUidlCache");

    // Get Uidcache file path
    IF_FAILEXIT(hr = GetStoreRootDirectory(szStoreRoot, sizeof(szStoreRoot)));

    // Make File Path
    IF_FAILEXIT(hr = MakeFilePath(szStoreRoot, c_szPop3UidlFile, c_szEmpty, szFilePath, sizeof(szFilePath)));

    // Allocate Table Object
    IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_UidlTableSchema, NULL, &pDB));

    // Fix the file 
    SideAssert(SUCCEEDED(FixPOP3UIDLFile(pDB)));

    // Return It
    *ppDB = pDB;
    pDB = NULL;

exit:
    // Cleanup
    SafeRelease(pDB);

    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// FixPOP3UIDLFile
//----------------------------------------------------------------------------------
const char c_szFixedPOP3UidlFile[] = "FixedPOP3UidlFile";

typedef struct tagSERVERNAME {
    CHAR        szServer[CCHMAX_SERVER_NAME];
    CHAR        szAccountId[CCHMAX_ACCOUNT_NAME];
} SERVERNAME, *LPSERVERNAME;

HRESULT FixPOP3UIDLFile(IDatabase *pDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               fFixed=FALSE;
    DWORD               cb;
    DWORD               dwType;
    IImnAccount        *pAccount=NULL;
    IImnEnumAccounts   *pEnum=NULL;
    DWORD               dwTemp;
    DWORD               cServers;
    LPSERVERNAME        prgServerName=NULL;
    HROWSET             hRowset=NULL;
    UIDLRECORD          UidlInfo={0};
    DWORD               i;

    // Trace
    TraceCall("FixPOP3UIDLFile");

    // Need to fixup the UIDL cache ?
    cb = sizeof(fFixed);
    if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szFixedPOP3UidlFile, &dwType, (LPBYTE)&fFixed, &cb))
        fFixed = FALSE;
    else if (fFixed)
        return(S_OK);

    // First try to see if we can find such a server.
    IF_FAILEXIT(hr = g_pAcctMan->Enumerate(SRV_POP3, &pEnum));

    // Count
    IF_FAILEXIT(hr = pEnum->GetCount(&cServers));

    // If no POP3 servers
    if (0 == cServers)
    {
        // Delete all the records...
        IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

        // Loop
        while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
        {
            // Delete the Record
            pDB->DeleteRecord(&UidlInfo);

            // Free It
            pDB->FreeRecord(&UidlInfo);
        }

        // Fixed
        fFixed = TRUE;

        // Done
        goto exit;
    }

    // Allocate
    IF_NULLEXIT(prgServerName = (LPSERVERNAME)g_pMalloc->Alloc(cServers * sizeof(SERVERNAME)));

    // Reset cServers
    cServers = 0;

    // Enumerate the POP3 servers
    while (SUCCEEDED(pEnum->GetNext(&pAccount)))
    {
        // Get the server name
        if (SUCCEEDED(pAccount->GetPropSz(AP_POP3_SERVER, prgServerName[cServers].szServer, ARRAYSIZE(prgServerName[cServers].szServer))))
        {
            // Get the pop3 username
            if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, prgServerName[cServers].szAccountId, ARRAYSIZE(prgServerName[cServers].szAccountId))))
            {
                // Increment
                cServers++;
            }
        }

        // Release the Account
        SafeRelease(pAccount);
    }

    // Delete all the records...
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
    {
        // Does UidlInfo.pszServer exist in prgServerName
        if (UidlInfo.pszServer)
        {
            // Delete the Record
            pDB->DeleteRecord(&UidlInfo);

            // Reset fExist
            for (i=0; i<cServers; i++)
            {
                // Is this it
                if (lstrcmpi(UidlInfo.pszServer, prgServerName[i].szServer) == 0)
                {
                    // Update the Record
                    UidlInfo.pszAccountId = prgServerName[i].szAccountId;

                    // Update the Record
                    pDB->InsertRecord(&UidlInfo);
                }
            }
        }

        // Free It
        pDB->FreeRecord(&UidlInfo);
    }

    // Compact
    pDB->Compact(NULL, 0);

    // Fixed
    fFixed = TRUE;

exit:
    // Cleanup
    if (pDB && hRowset)
        pDB->CloseRowset(&hRowset);
    SafeRelease(pAccount);
    SafeRelease(pEnum);
    SafeMemFree(prgServerName);

    // Set the Value
    SideAssert(ERROR_SUCCESS == AthUserSetValue(NULL, c_szFixedPOP3UidlFile, REG_DWORD, (LPBYTE)&fFixed, sizeof(fFixed)));

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// SetStoreDirectory
//----------------------------------------------------------------------------------
HRESULT SetStoreDirectory(
        /* in */        LPCSTR                      pszRoot)
{                                                   
    // Locals
    HRESULT         hr=S_OK;
    LPCSTR          psz;
    CHAR            szProfile[MAX_PATH];
    DWORD           cb;
    DWORD           type;

    // Trace
    TraceCall("SetStoreDirectory");

    // Invalid Args
    Assert(pszRoot);

    // Bad Root
    if (lstrlen(pszRoot) >= MAX_PATH || FIsEmptyA(pszRoot))
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    type = AddEnvInPath(pszRoot, szProfile) ? REG_EXPAND_SZ : REG_SZ;

    // Store the Value in the Registry
    if (ERROR_SUCCESS != AthUserSetValue(NULL, c_szRegStoreRootDir, type, (LPBYTE)szProfile, lstrlen(szProfile) + 1))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// InitializeLocalStoreDirectory
//----------------------------------------------------------------------------------
HRESULT InitializeLocalStoreDirectory(
        /* in */        HWND                    hwndOwner, 
        /* in */        BOOL                    fNoCreate)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szPath[MAX_PATH];

    // Trace
    TraceCall("InitializeLocalStoreDirectory");

    // Get root directory
    if (SUCCEEDED(GetStoreRootDirectory(szPath, ARRAYSIZE(szPath))))
        goto exit;

    // Don't create
    if (fNoCreate)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Get Default Root
    IF_FAILEXIT(hr = GetDefaultStoreRoot(hwndOwner, szPath, ARRAYSIZE(szPath)));

    // If the directory doesn't exist yet ?
    if (FALSE == PathIsDirectory(szPath))
    {
        // Our default directory doesn't exist, so create it
        IF_FAILEXIT(hr = OpenDirectory(szPath));
    }

    // Set the Store Directory
    IF_FAILEXIT(hr = SetStoreDirectory(szPath));

exit:
    // Done
    return hr;
}

//----------------------------------------------------------------------------------
// CloneMessageIDList
//----------------------------------------------------------------------------------
HRESULT CloneMessageIDList(LPMESSAGEIDLIST pSourceList, LPMESSAGEIDLIST *ppNewList)
{
    LPMESSAGEIDLIST pNewList = NULL;
    LPMESSAGEID     pNewMsgIDArray = NULL;
    BOOL            fResult;

    TraceCall("CloneMessageIDList");
    Assert(NULL != ppNewList);

    if (NULL == pSourceList)
    {
        *ppNewList = NULL;
        return S_OK;
    }

    // Init return values
    *ppNewList = NULL;

    if (!MemAlloc((LPVOID *)&pNewList, sizeof(MESSAGEIDLIST) + pSourceList->cMsgs * sizeof(MESSAGEID)))
        return TraceResult(E_OUTOFMEMORY);

    // Fill in fields, allocate and copy prgidMsg array
    pNewList->cAllocated = 0;
    pNewList->cMsgs = pSourceList->cMsgs;
    pNewMsgIDArray = (LPMESSAGEID)((LPBYTE)pNewList + sizeof(MESSAGEIDLIST));
    CopyMemory(pNewMsgIDArray, pSourceList->prgidMsg, pSourceList->cMsgs * sizeof(MESSAGEID));
    pNewList->prgidMsg = pNewMsgIDArray;
    *ppNewList = pNewList;
    return S_OK;
}



HRESULT CloneAdjustFlags(LPADJUSTFLAGS pFlags, LPADJUSTFLAGS *ppNewFlags)
{
    LPADJUSTFLAGS pNewFlags;

    if (!MemAlloc((LPVOID *)&pNewFlags, sizeof(ADJUSTFLAGS)))
        return TraceResult(E_OUTOFMEMORY);

    CopyMemory(pNewFlags, pFlags, sizeof(ADJUSTFLAGS));
    *ppNewFlags = pNewFlags;
    return S_OK;
}


//----------------------------------------------------------------------------------
// ConnStateIsEqual
//----------------------------------------------------------------------------------
BOOL ConnStateIsEqual(IXPSTATUS ixpStatus, CONNECT_STATE csState)
{
    BOOL    fResult = FALSE;

    TraceCall("ConnStateIsEqual");

    switch (csState)
    {
        case CONNECT_STATE_CONNECT:
            // Remember IXP_CONNECTED doesn't necessarily mean we're authenticated
            if (IXP_AUTHORIZED == ixpStatus)
                fResult = TRUE;

            break;

        case CONNECT_STATE_DISCONNECT:
            if (IXP_DISCONNECTED == ixpStatus)
                fResult = TRUE;

            break;

        default:
            AssertSz(FALSE, "I've never heard of this CONNECT_STATE!");
            break;
    } // switch

    return fResult;
}

//----------------------------------------------------------------------------------
// RelocateStoreDirectory
//----------------------------------------------------------------------------------
// Extensions associated with OE v5 Store
const static TCHAR *rgszWildCards[] = 
{
    "*.dbx",
    "*.dbl",
    "*.log",
};

// Lengths of the above strings
const static int rgcchWilds[] = 
{
    5,
    5,
    5,
};

// Build a string of the form:
// C:\\foo\\*.bar\0C:\\foo\\*.car\0\0

// Return E_FAIL if we run out of memory
// Return S_FALSE if there are no *.bar or *.car files in C:\foo
// Return S_OK otherwise
HRESULT GenerateWildCards(LPTSTR pszBuf, DWORD cchBuf, LPTSTR pszSource, DWORD cchSource)
{
    UINT    i;
    DWORD   cchWildCard = 0;
    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;
    HANDLE  hFound;
    TCHAR   szTempBuf[MAX_PATH];
    BOOL    fFound;
    DWORD   cchOrig;

    // Form common root
    if(lstrlen(pszSource) >= sizeof(szTempBuf) / sizeof(szTempBuf[0])) return E_FAIL;
    lstrcpy(szTempBuf, pszSource);
    if (_T('\\') == *CharPrev(szTempBuf, szTempBuf + cchSource))
        // Avoid \\foo and \_foo
        cchSource--;
    else
        szTempBuf[cchSource] = _T('\\');
        
    // Go through list of extensions we are interested in
    for (i = 0; i < ARRAYSIZE(rgszWildCards); i++)
    {
        // Add the extension to the common root
        lstrcpy(&szTempBuf[cchSource+1], rgszWildCards[i]);
        
        // Should we bother with this wildcard?
        fFound = FALSE;
        hFound = FindFirstFile(szTempBuf, &fd);
        if (INVALID_HANDLE_VALUE != hFound)
        {
            do
            {
                if (!ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
                    fFound = TRUE;

            }
            while (!fFound && FindNextFile(hFound, &fd));

            FindClose(hFound);

            if (fFound)
            {
                // Do we have enough space for this wildcard?

                // 3 = 1 for slash + 2 for double null termination 
                if (cchWildCard + cchSource + rgcchWilds[i] + 3 > cchBuf)
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }

                hr = S_OK;

                // Add extension to the list
                lstrcpy(&pszBuf[cchWildCard], szTempBuf);
                
                // 2 = 1 for slash + 1 to skip over NULL
                cchWildCard += cchSource + rgcchWilds[i] + 2;
            }
        }
    }
        
    // Double Null-term
    pszBuf[cchWildCard] = '\0';

exit:
    return hr;
}

HRESULT RelocateStoreDirectory(HWND hwnd, LPCSTR pszDstDir, BOOL fMove)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrT;
    DWORD           cchDstDir;
    DWORD           cchSrcDir;
    CHAR            szWildCard[MAX_PATH * ARRAYSIZE(rgszWildCards)];
    CHAR            szSrcDir[MAX_PATH];
    CHAR            szDstDir[MAX_PATH];
    CHAR            szDrive[4] = "x:\\";
    CHAR            szRes[255];
    SHFILEOPSTRUCT  op;
    BOOL            fSome;

    Assert(pszDstDir && *pszDstDir);
    
    // Trace
    TraceCall("RelocateStoreDirectory");

    // Get the Current Root Store Location (won't have trailing slash)
    IF_FAILEXIT(hr = GetStoreRootDirectory(szWildCard, ARRAYSIZE(szWildCard)));

    // Make a copy of pszDstDir, stripping out any relative path padding
    PathCanonicalize(szDstDir, pszDstDir);    

    // Make sure the destination directory exists (it came from the reg...)
    IF_FAILEXIT(hr=OpenDirectory(szDstDir));

    // Strip out any relative path padding
    PathCanonicalize(szSrcDir, szWildCard);

    // Get Dest Dir Length
    cchDstDir = lstrlen(szDstDir);
    
    // Remove any slash termination
    if (_T('\\') == *CharPrev(szDstDir, szDstDir+cchDstDir))
        szDstDir[--cchDstDir] = 0;

    // BUGBUG: This isn't a very thorough test...
    // Source and Destination are the Same ?
    if (lstrcmpi(szSrcDir, szDstDir) == 0)
    {
        hr = TraceResult(S_FALSE);
        goto exit;
    }

    // Get Source Dir Length
    cchSrcDir = lstrlen(szSrcDir);

    // Normally, GetStoreRootDir should have have removed the backslash
    // But maybe we move to C:\
    //Assert(*CharPrev(szSrcDir, szSrcDir+cchSrcDir) != _T('\\'));

    // Set Drive Number
    szDrive[0] = szDstDir[0];

    // If destination is not a fixed drive, failure
    if (DRIVE_FIXED != GetDriveType(szDrive))
    {
        hr = TraceResult(S_FALSE);
        goto exit;
    }

    if (fMove)
    {
        // Enough space for one more character
        if (cchSrcDir + 2 >= ARRAYSIZE(szSrcDir))
        {
            hr = TraceResult(S_FALSE);
            goto exit;
        }

        // Double Null-term
        szSrcDir[cchSrcDir + 1] = _T('\0');

        // Validate
        Assert(szSrcDir[cchSrcDir] == _T('\0') && szSrcDir[cchSrcDir + 1] == _T('\0'));

        // Enough space for one more character
        if (cchDstDir + 1 >= ARRAYSIZE(szDstDir))
        {
            // This is never going to work so tell caller not to bother us again
            hr = TraceResult(S_FALSE);
            goto exit;
        }

        // Double Null-term
        szDstDir[cchDstDir + 1] = '\0';

        // Validate
        Assert(szDstDir[cchDstDir] == '\0' && szDstDir[cchDstDir + 1] == '\0');
        hrT = GenerateWildCards(szWildCard, ARRAYSIZE(szWildCard), szDstDir, cchDstDir);

        if (FAILED(hrT))
        {
            hr = TraceResult(S_FALSE);
            goto exit;
        }
        else if (S_OK == hrT)
        {
            // Delete the Files from the target location
            ZeroMemory(&op, sizeof(SHFILEOPSTRUCT));
            op.hwnd = hwnd;
            op.wFunc = FO_DELETE;
            op.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_FILESONLY | FOF_NORECURSION;
            op.pFrom = szWildCard;
            op.fAnyOperationsAborted = FALSE;

            // Delete the files 
            if (SHFileOperation(&op) != 0)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
        }

        // Make the file source paths
        hrT = GenerateWildCards(szWildCard, ARRAYSIZE(szWildCard), szSrcDir, cchSrcDir);

        if (FAILED(hrT))
        {
            hr = TraceResult(S_FALSE);
            goto exit;
        }
        else if (S_OK == hrT)
        {
            // Load the Progress String
            LoadString(g_hLocRes, idsMoveStoreProgress, szRes, ARRAYSIZE(szRes));

            // Setup for the file move operation
            ZeroMemory(&op, sizeof(SHFILEOPSTRUCT));
            op.hwnd = hwnd;
            op.wFunc = FO_COPY;
            op.fFlags = FOF_NOCONFIRMMKDIR | FOF_SIMPLEPROGRESS | FOF_FILESONLY | FOF_NORECURSION;
            op.lpszProgressTitle = szRes;
            op.fAnyOperationsAborted = FALSE;
            op.pFrom = szWildCard;
            op.pTo = szDstDir;

            // Did that succeed and was not aborted
            if (SHFileOperation(&op) == 0 && FALSE == op.fAnyOperationsAborted)
            {
                // Update the Store Root Directory
                // Use original string        
                SideAssert(SUCCEEDED(SetStoreDirectory(pszDstDir)));
            }

            // Canceled
            else
            {
                // Failure ?
                hr = (op.fAnyOperationsAborted ? S_FALSE : E_FAIL);

                // Delete what we moved
                hrT = GenerateWildCards(szWildCard, ARRAYSIZE(szWildCard), szDstDir, cchDstDir);
            }

            if (S_OK == hrT)
            {
                // Delete the Files from the original location
                op.wFunc = FO_DELETE;
                op.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_FILESONLY | FOF_NORECURSION;

                // Delete the files
                SHFileOperation(&op);
            }
        }
        else
            AssertSz(FALSE, "We're moving the store, but found no store to move!");
    }
    else
        SideAssert(SUCCEEDED(SetStoreDirectory(pszDstDir)));

    
exit:
    // Done
    return(hr);
}


//----------------------------------------------------------------------------------
// FlattenHierarchy
//----------------------------------------------------------------------------------
// Not the most efficient way to flatten a hierarchy, but it's quick impl
// Later enhancements can include implementing a stack to flatten hierarchy
// in real-time using enumerator functions
HRESULT FlattenHierarchy(IMessageStore *pStore, FOLDERID idParent,
                        BOOL fIncludeParent, BOOL fSubscribedOnly,
                        FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                        LPDWORD pdwUsed)
{
    TraceCall("FlattenHierarchy");
    Assert(NULL != pStore);
    Assert(NULL != pprgFIDArray);
    Assert(NULL != pdwAllocated);
    Assert(NULL != pdwUsed);

    // Initialize values
    *pprgFIDArray = NULL;
    *pdwAllocated = 0;
    *pdwUsed = 0;

    return FlattenHierarchyHelper(pStore, idParent, fIncludeParent, fSubscribedOnly,
        pprgFIDArray, pdwAllocated, pdwUsed);
} // FlattenHierarchy


HRESULT FlattenHierarchyHelper(IMessageStore *pStore, FOLDERID idParent,
                               BOOL fIncludeParent, BOOL fSubscribedOnly,
                               FOLDERID **pprgFIDArray, LPDWORD pdwAllocated,
                               LPDWORD pdwUsed)
{
    HRESULT             hrResult = S_OK;
    IEnumerateFolders  *pEnumFldr = NULL;

    TraceCall("FlattenHierarchy");
    Assert(NULL != pStore);
    Assert(NULL != pprgFIDArray);
    Assert(NULL != pdwAllocated);
    Assert(NULL != pdwUsed);
    Assert(*pdwAllocated >= *pdwUsed);
    Assert(*pdwUsed + FIDARRAY_GROW >= *pdwAllocated);

    // Check for invalid folder ID's
    if (FOLDERID_INVALID == idParent)
    {
        hrResult = S_OK;
        goto exit; // Nothing to do here!
    }

    // Check if we need to grow the FolderID Array
    if (*pdwUsed + 1 > *pdwAllocated)
    {
        BOOL    fResult;

        fResult = MemRealloc((void **)pprgFIDArray,
            (*pdwAllocated + FIDARRAY_GROW) * sizeof(FOLDERID));
        if (FALSE == fResult)
        {
            hrResult = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        *pdwAllocated += FIDARRAY_GROW;
    }

    // First thing we do is add current node to the ID array
    if (fIncludeParent)
    {
        (*pprgFIDArray)[*pdwUsed] = idParent;
        *pdwUsed += 1;
    }

    // OK, now add child folders
    hrResult = pStore->EnumChildren(idParent, fSubscribedOnly, &pEnumFldr);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    do
    {
        const BOOL  fINCLUDE_PARENT = TRUE;
        FOLDERINFO  fiFolderInfo;

        // Get info on next child folder
        hrResult = pEnumFldr->Next(1, &fiFolderInfo, NULL);
        if (S_OK != hrResult)
        {
            TraceError(hrResult);
            break;
        }

        // Recurse on child
        hrResult = FlattenHierarchyHelper(pStore, fiFolderInfo.idFolder, fINCLUDE_PARENT,
            fSubscribedOnly, pprgFIDArray, pdwAllocated, pdwUsed);
        pStore->FreeRecord(&fiFolderInfo);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            break;
        }
    } while (1);


exit:
    if (NULL != pEnumFldr)
        pEnumFldr->Release();

    return hrResult;
} // FlattenHierarchyHelper

HRESULT GetInboxId(IMessageStore    *pStore, 
                        FOLDERID    idParent,
                        FOLDERID    **pprgFIDArray,
                        LPDWORD     pdwUsed)
{
    BOOL                fResult;
    HRESULT             hrResult;
    IEnumerateFolders  *pEnumFldr = NULL;

    Assert(NULL != pStore);
    Assert(NULL != pprgFIDArray);
    Assert(NULL != pdwUsed);

    fResult = MemAlloc((void **)pprgFIDArray, sizeof(FOLDERID));
    if (FALSE == fResult)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hrResult = pStore->EnumChildren(idParent, FALSE, &pEnumFldr);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    do
    {
        FOLDERINFO  fiFolderInfo;

        // Get info on next child folder
        hrResult = pEnumFldr->Next(1, &fiFolderInfo, NULL);
        if (S_OK != hrResult)
        {
            TraceError(hrResult);
            break;
        }

        if (fiFolderInfo.tySpecial == FOLDER_INBOX)
        {
            (*pprgFIDArray)[*pdwUsed] = fiFolderInfo.idFolder;
            *pdwUsed += 1;
            break;
        }
        pStore->FreeRecord(&fiFolderInfo);
    } while (1);

exit:
    if (NULL != pEnumFldr)
        pEnumFldr->Release();

    return hrResult;

}

//----------------------------------------------------------------------------------
// RecurseFolderHierarchy
//----------------------------------------------------------------------------------
HRESULT RecurseFolderHierarchy(FOLDERID idFolder, RECURSEFLAGS dwFlags,
    DWORD dwReserved, DWORD_PTR dwCookie, PFNRECURSECALLBACK pfnCallback)
{
    // Locals
    HRESULT             hr=S_OK;
    FOLDERINFO          Folder={0};
    DWORD               cIndent=dwReserved;
    IEnumerateFolders  *pChildren=NULL;

    // Trace
    TraceCall("RecurseFolderHierarchy");

    // Include idFolder ?
    if (ISFLAGSET(dwFlags, RECURSE_INCLUDECURRENT))
    {
        // Process idFolder
        IF_FAILEXIT(hr = g_pStore->GetFolderInfo(idFolder, &Folder));

        // No Local Store
        if (!ISFLAGSET(dwFlags, RECURSE_NOLOCALSTORE) || FOLDERID_LOCAL_STORE != Folder.idFolder)
        {
            // Call the Callback
            IF_FAILEXIT(hr = (*(pfnCallback))(&Folder, ISFLAGSET(dwFlags, RECURSE_SUBFOLDERS), cIndent, dwCookie));
        }

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Don't include current anymore
    FLAGCLEAR(dwFlags, RECURSE_INCLUDECURRENT);

    // Do Sub Folders ?
    if (ISFLAGSET(dwFlags, RECURSE_SUBFOLDERS))
    {
        // No Local Store
        if (!ISFLAGSET(dwFlags, RECURSE_NOLOCALSTORE) || FOLDERID_LOCAL_STORE != idFolder)
        {
            // Create Enumerator for the Children
            IF_FAILEXIT(hr = g_pStore->EnumChildren(idFolder, ISFLAGSET(dwFlags, RECURSE_ONLYSUBSCRIBED), &pChildren));

            // Loop
            while (S_OK == pChildren->Next(1, &Folder, NULL))
            {
                // No Local Store
                if (((!ISFLAGSET(dwFlags, RECURSE_NOLOCALSTORE) || FOLDERID_LOCAL_STORE != Folder.idFolder)) &&
                            ((!ISFLAGSET(dwFlags, RECURSE_ONLYLOCAL) || FOLDER_LOCAL == Folder.tyFolder)) &&
                            ((!ISFLAGSET(dwFlags, RECURSE_ONLYNEWS) || FOLDER_NEWS == Folder.tyFolder)))
                {
                    // Call the Callback
                    IF_FAILEXIT(hr = (*(pfnCallback))(&Folder, ISFLAGSET(dwFlags, RECURSE_SUBFOLDERS), cIndent, dwCookie));

                    // Enumerate Children
                    IF_FAILEXIT(hr = RecurseFolderHierarchy(Folder.idFolder, dwFlags, cIndent + 1, dwCookie, pfnCallback));
                }

                // Free Folder
                g_pStore->FreeRecord(&Folder);
            }
        }
    }

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pChildren);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// RecurseFolderCounts
//----------------------------------------------------------------------------------
HRESULT RecurseFolderCounts(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    LPDWORD pcMsgs=(LPDWORD)dwCookie;

    // Trace
    TraceCall("RecurseFolderCounts");

    // If not a server
    if (FALSE == ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER) && FOLDERID_ROOT != pFolder->idFolder)
    {
        // Increment Max
        (*pcMsgs) += pFolder->cMessages;
    }

    // Done
    return(S_OK);
}

//----------------------------------------------------------------------------------
// DoCompactionError
//----------------------------------------------------------------------------------
HRESULT DoCompactionError(HWND hwndParent, LPCSTR pszFolder, LPCSTR pszFile,
    BOOL fSubFolders, HRESULT hrError)
{
    // Determine Message Box Flags
    UINT    uAnswer;
    UINT    uFlags = (fSubFolders ? MB_OKCANCEL | MB_ICONSTOP : MB_OK | MB_ICONSTOP);
    CHAR    szRes[255];
    CHAR    szReason[255];
    CHAR    szMsg[1024];

    // Trace
    TraceCall("DoCompactionError");

    // Should be a failure
    Assert(FAILED(hrError));

    // Cancel
    if (hrUserCancel == hrError)
        return(hrUserCancel);

    // General message
    AthLoadString(idsFailACacheCompact, szRes, ARRAYSIZE(szRes));

    // Disk Full
    if (hrError == hrDiskFull || hrError == DB_E_DISKFULL)
    {
        // Load the Disk Full Error
        AthLoadString(idsDiskFull, szReason, ARRAYSIZE(szRes));

        // Append It to the String
        wsprintf(szMsg, szRes, pszFolder, szReason, pszFile, hrError);

        // Show It
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Access Denied
    else if (hrError == DB_E_ACCESSDENIED)
    {
        // Load the Disk Full Error
        AthLoadString(idsDBAccessDenied, szReason, ARRAYSIZE(szRes));

        // Append It to the String
        wsprintf(szMsg, szRes, pszFolder, szReason, pszFile, hrError);

        // Show It
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Memory
    else if (hrError == hrMemory || hrError == E_OUTOFMEMORY)
    {
        // Load the Error
        AthLoadString(idsMemory, szReason, ARRAYSIZE(szReason));

        // Append It to the String
        wsprintf(szMsg, szRes, pszFolder, szReason, pszFile, hrError);

        // Show the Error
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Show general error
    else
    {
        // Load the String
        AthLoadString(idsFailACacheCompactReason, szRes, ARRAYSIZE(szRes));

        // Append It to the String
        wsprintf(szMsg, szRes, pszFolder, szReason, pszFile, hrError);

        // Show the Error
        uAnswer = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), szMsg, 0, uFlags);
    }

    // Return hrError
    return(uAnswer == IDCANCEL ? hrUserCancel : S_OK);
}

//----------------------------------------------------------------------------------
// RecurseCompactFolders
//----------------------------------------------------------------------------------
HRESULT RecurseCompactFolders(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    IMessageFolder *pFolderObject=NULL;
    LPCOMPACTCOOKIE pCompact=(LPCOMPACTCOOKIE)dwCookie;

    // Trace
    TraceCall("RecurseCompactFolders");

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        goto exit;
    
    // Root
    if (FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Open the Folder...
    if (FAILED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
        goto exit;
    
    // Set Msg
    pCompact->pProgress->SetMsg(pFolder->pszName);

    // Cleanup this folder
    hr = pFolderObject->Compact((IDatabaseProgress *)pCompact->pProgress, 0);

    // Failure
    if (FAILED(hr))
    {
        // Do UI
        if (pCompact->fUI && hrUserCancel == DoCompactionError(pCompact->hwndParent, pFolder->pszName, pFolder->pszFile, fSubFolders, hr))
            goto exit;
    }

    // Reset hr
    hr = S_OK;

exit:
    // Cleanup
    SafeRelease(pFolderObject);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CompactSpecialDatabase
// --------------------------------------------------------------------------------
HRESULT CompactSpecialDatabase(LPCOMPACTCOOKIE pCompact, LPCSTR pszFile, 
    IDatabase *pDB, UINT idName)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[255];

    // Trace
    TraceCall("CompactSpecialDatabase");

    // No Database
    if (NULL == pDB)
        goto exit;

    // Load the String
    LoadString(g_hLocRes, idName, szRes, ARRAYSIZE(szRes));

    // Set Msg
    pCompact->pProgress->SetMsg(szRes);

    // Cleanup this folder
    hr = pDB->Compact((IDatabaseProgress *)pCompact->pProgress, 0);

    // Failure
    if (FAILED(hr))
    {
        // Do UI
        if (pCompact->fUI && hrUserCancel == DoCompactionError(pCompact->hwndParent, szRes, pszFile, TRUE, hr))
            goto exit;
    }

    // Reset hr
    hr = S_OK;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CompactFolders
// --------------------------------------------------------------------------------
HRESULT CompactFolders(HWND hwndParent, RECURSEFLAGS dwRecurse, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cTotal=0;
    DWORD           cRecords;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    CHAR            szRootDir[MAX_PATH + MAX_PATH];
    CHAR            szTitle[255];
    COMPACTCOOKIE   Compact;
    IDatabase      *pUidlCache=NULL;
    IDatabase      *pOffline=NULL;
    CProgress      *pProgress=NULL;

    // Trace
    TraceCall("CompactFolders");

    // Get the Root Store Directory
    IF_FAILEXIT(hr = GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir)));

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&cTotal, (PFNRECURSECALLBACK)RecurseFolderCounts));

    // Compacting All
    if (FOLDERID_ROOT == idFolder && ISFLAGSET(dwRecurse, RECURSE_SUBFOLDERS))
    {
        // Get Folders Record Count
        IF_FAILEXIT(hr = g_pStore->GetRecordCount(IINDEX_PRIMARY, &cRecords));

        // Increment cTotal
        cTotal += cRecords;

        // Make File Path
        IF_FAILEXIT(hr = MakeFilePath(szRootDir, c_szPop3UidlFile, c_szEmpty, szFilePath, sizeof(szFilePath)));

        // If file exists
        if (PathFileExists(szFilePath))
        {
            // Allocate Table Object
            IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_UidlTableSchema, NULL, &pUidlCache));

            // Get Record Count
            IF_FAILEXIT(hr = pUidlCache->GetRecordCount(IINDEX_PRIMARY, &cRecords));

            // Increment cTotal
            cTotal += cRecords;
        }

        // Open Offline Transaction Log
        IF_FAILEXIT(hr = MakeFilePath(szRootDir, c_szOfflineFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // If the file exists
        if (PathFileExists(szFilePath))
        {
            // Create pOffline
            IF_FAILEXIT(hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_SyncOpTableSchema, NULL, &pOffline));

            // Get Record Count
            IF_FAILEXIT(hr = pOffline->GetRecordCount(IINDEX_PRIMARY, &cRecords));

            // Increment cTotal
            cTotal += cRecords;
        }
    }

    // Create progress meter
    IF_NULLEXIT(pProgress = new CProgress);

    // Dialog title
    AthLoadString(idsCompacting, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // Init progress meter
    pProgress->Init(hwndParent, szTitle, (LPSTR)NULL, cTotal, idanCompact, TRUE, FALSE);

    // Show progress
    pProgress->Show(0);

    // Setup Compact Cookie
    Compact.hwndParent = hwndParent;
    Compact.pProgress = pProgress;
    Compact.fUI = (ISFLAGSET(dwRecurse, RECURSE_NOUI) == TRUE) ? FALSE : TRUE;

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&Compact, (PFNRECURSECALLBACK)RecurseCompactFolders));

    // Compacting All
    if (FOLDERID_ROOT == idFolder && ISFLAGSET(dwRecurse, RECURSE_SUBFOLDERS))
    {
        // Compact Special Databae
        IF_FAILEXIT(hr = CompactSpecialDatabase(&Compact, c_szPop3UidlFile, pUidlCache, idsPop3UidlFile));

        // Compact Special Databae
        IF_FAILEXIT(hr = CompactSpecialDatabase(&Compact, c_szOfflineFile, pOffline, idsOfflineFile));

        // Compact Special Databae
        IF_FAILEXIT(hr = CompactSpecialDatabase(&Compact, c_szFoldersFile, g_pStore, idsFoldersFile));
    }

exit:
    // Cleanup
    SafeRelease(pProgress);
    SafeRelease(pUidlCache);
    SafeRelease(pOffline);

    // Done
    return (hrUserCancel == hr) ? S_OK : hr;
}

// --------------------------------------------------------------------------------
// RecurseRemoveMessageBodies
// --------------------------------------------------------------------------------
HRESULT RecurseRemoveMessageBodies(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    MESSAGEINFO     Message={0};
    BOOL            fRemoveBody;
    HROWSET         hRowset=NULL;
    IMessageFolder *pFolderObject=NULL;
    IDatabase      *pDB=NULL;
    FILETIME        ftCurrent;
    LPREMOVEBODIES  pRemove=(LPREMOVEBODIES)dwCookie;

    // Trace
    TraceCall("RecurseRemoveMessageBodies");

    // If not a server
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_SERVER))
        goto exit;

    // Root
    if (FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Open the folder...
    if (FAILED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolderObject)))
        goto exit;

    // Get the database
    IF_FAILEXIT(hr = pFolderObject->GetDatabase(&pDB));

    // Set Msg
    pRemove->pProgress->SetMsg(pFolder->pszName);

    // Adjust cExpireDays
    if (pRemove->cExpireDays <= 0)
        pRemove->cExpireDays = 5;

    // Get Current Time
    GetSystemTimeAsFileTime(&ftCurrent);

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Only if this message has a body
        if (!ISFLAGSET(Message.dwFlags, ARF_KEEPBODY) && !ISFLAGSET(Message.dwFlags, ARF_WATCH) && 0 != Message.faStream)
        {
            // Reset Bits
            fRemoveBody = FALSE;

            // Otherwise, remove body ?
            if (ISFLAGSET(pRemove->dwFlags, CLEANUP_REMOVE_ALL))
            {
                // Remove the Body
                fRemoveBody = TRUE;
            }

            // Otherwise
            else
            {
                // Removing Read and this message is read ?
                if (ISFLAGSET(pRemove->dwFlags, CLEANUP_REMOVE_READ) && ISFLAGSET(Message.dwFlags, ARF_READ))
                {
                    // Remove the Body
                    fRemoveBody = TRUE;
                }

                // Otherwise, if expiring...
                if (FALSE == fRemoveBody && ISFLAGSET(pRemove->dwFlags, CLEANUP_REMOVE_EXPIRED))
                {
                    // If difference
                    if ((UlDateDiff(&Message.ftDownloaded, &ftCurrent) / SECONDS_INA_DAY) >= pRemove->cExpireDays)
                    {
                        // Remove the Body
                        fRemoveBody = TRUE;
                    }
                }
            }

            // Otherwise, fRemoveBody ?
            if (fRemoveBody)
            {
                // Save the Address
                FILEADDRESS faDelete = Message.faStream;

                // Zero out the record's strema
                Message.faStream = 0;

                // Fixup the Record
                FLAGCLEAR(Message.dwFlags, ARF_HASBODY);
                FLAGCLEAR(Message.dwFlags, ARF_ARTICLE_EXPIRED);

                // Clear downloaded time
                ZeroMemory(&Message.ftDownloaded, sizeof(FILETIME));

                // Update the Record
                IF_FAILEXIT(hr = pDB->UpdateRecord(&Message));

                // Delete the Stream
                SideAssert(SUCCEEDED(pDB->DeleteStream(faDelete)));
            }
        }

        // Free Current
        pDB->FreeRecord(&Message);

        // Update the Progress
        if (pRemove->pProgress && hrUserCancel == pRemove->pProgress->HrUpdate(1))
            break;
    }

exit:
    // Cleanup
    if (pDB)
    {
        pDB->FreeRecord(&Message);
        pDB->CloseRowset(&hRowset);
        pDB->Release();
    }
    SafeRelease(pFolderObject);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// RemoveMessageBodies
// --------------------------------------------------------------------------------
HRESULT RemoveMessageBodies(HWND hwndParent, RECURSEFLAGS dwRecurse, 
    FOLDERID idFolder, CLEANUPFOLDERFLAGS dwFlags, DWORD cExpireDays)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cTotal=0;
    CHAR            szTitle[255];
    REMOVEBODIES    RemoveBodies;
    CProgress      *pProgress=NULL;

    // Trace
    TraceCall("CompactFolders");

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&cTotal, (PFNRECURSECALLBACK)RecurseFolderCounts));

    // Create progress meter
    IF_NULLEXIT(pProgress = new CProgress);

    // Dialog title
    AthLoadString(idsCleaningUp, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // Init progress meter
    pProgress->Init(hwndParent, szTitle, (LPSTR)NULL, cTotal, idanCompact, TRUE, FALSE);

    // Show progress
    pProgress->Show(0);

    // Setup Compact Cookie
    RemoveBodies.pProgress = pProgress;
    RemoveBodies.dwFlags = dwFlags;
    RemoveBodies.cExpireDays = cExpireDays;

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&RemoveBodies, (PFNRECURSECALLBACK)RecurseRemoveMessageBodies));

exit:
    // Cleanup
    SafeRelease(pProgress);

    // Done
    return (hrUserCancel == hr) ? S_OK : hr;
}

// --------------------------------------------------------------------------------
// RecurseDeleteMessages
// --------------------------------------------------------------------------------
HRESULT RecurseDeleteMessages(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT         hr=S_OK;
    LPDELETEMSGS    pDelete=(LPDELETEMSGS)dwCookie;

    // Trace
    TraceCall("RecurseDeleteMessages");

    // Set Msg
    pDelete->pProgress->SetMsg(pFolder->pszName);

    // If not a server
    IF_FAILEXIT(hr = EmptyMessageFolder(pFolder, pDelete->fReset, pDelete->pProgress));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupDeleteMessages
// --------------------------------------------------------------------------------
HRESULT CleanupDeleteMessages(HWND hwndParent, RECURSEFLAGS dwRecurse, 
    FOLDERID idFolder, BOOL fReset)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cTotal=0;
    CHAR            szTitle[255];
    DELETEMSGS      DeleteMsgs;
    CProgress      *pProgress=NULL;

    // Trace
    TraceCall("CompactFolders");

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&cTotal, (PFNRECURSECALLBACK)RecurseFolderCounts));

    // Create progress meter
    IF_NULLEXIT(pProgress = new CProgress);

    // Dialog title
    AthLoadString(idsCleaningUp, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // Init progress meter
    pProgress->Init(hwndParent, szTitle, (LPSTR)NULL, cTotal, idanCompact, TRUE, FALSE);

    // Show progress
    pProgress->Show(0);

    // Setup Compact Cookie
    DeleteMsgs.pProgress = pProgress;
    DeleteMsgs.fReset = fReset;

    // Get Folder Counts
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&DeleteMsgs, (PFNRECURSECALLBACK)RecurseDeleteMessages));

exit:
    // Cleanup
    SafeRelease(pProgress);

    // Done
    return (hrUserCancel == hr) ? S_OK : hr;
}

// --------------------------------------------------------------------------------
// CleanupFolder
// --------------------------------------------------------------------------------
HRESULT CleanupFolder(HWND hwndParent, RECURSEFLAGS dwRecurse, FOLDERID idFolder, 
    CLEANUPFOLDERTYPE tyCleanup)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CleanupFolder");

    // Handle Cleanup Type
    if (CLEANUP_COMPACT == tyCleanup)
    {
        // Compact
        IF_FAILEXIT(hr = CompactFolders(hwndParent, dwRecurse, idFolder));
    }

    // Delete ?
    else if (CLEANUP_DELETE == tyCleanup)
    {
        // Delete all the headers
        IF_FAILEXIT(hr = CleanupDeleteMessages(hwndParent, dwRecurse, idFolder, FALSE));
    }

    // Reset
    else if (CLEANUP_RESET == tyCleanup)
    {
        // Delete all the headers
        IF_FAILEXIT(hr = CleanupDeleteMessages(hwndParent, dwRecurse, idFolder, TRUE));
    }

    // Remove Message Bodies
    else if (CLEANUP_REMOVEBODIES == tyCleanup)
    {
        // RemoveMessageBodies
        IF_FAILEXIT(hr = RemoveMessageBodies(hwndParent, dwRecurse, idFolder, CLEANUP_REMOVE_ALL | CLEANUP_PROGRESS, 0));
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// InitFolderPickerEdit
// --------------------------------------------------------------------------------
HRESULT InitFolderPickerEdit(HWND hwndEdit, FOLDERID idSelected)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};
    TCHAR       sz[CCHMAX_STRINGRES];
    LPTSTR      psz;

    // Trace
    TraceCall("InitFolderPickerEdit");

    // Fix Selected ?
    if (FAILED(g_pStore->GetFolderInfo(idSelected, &Folder)))
    {
        // Try to get the Root
        IF_FAILEXIT(hr = g_pStore->GetFolderInfo(FOLDERID_ROOT, &Folder));
    }

    // SetWndThisPtr
    SetWndThisPtr(hwndEdit, Folder.idFolder);

    if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) && (idSelected == 0))
    {
        LoadString(g_hLocRes, idsOutlookNewsReader, sz, ARRAYSIZE(sz));
        psz = sz;
    }
    else
    {
        psz = Folder.pszName;
    }

    // Set the Text
    SetWindowText(hwndEdit, psz);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetFolderIdFromEdit
// --------------------------------------------------------------------------------
FOLDERID GetFolderIdFromEdit(HWND hwndEdit)
{
    // Trace
    TraceCall("GetFolderIdFromEdit");

    // GetWndThisPtr
    return(FOLDERID)(GetWndThisPtr(hwndEdit));
}

// --------------------------------------------------------------------------------
// PickFolderInEdit
// --------------------------------------------------------------------------------
HRESULT PickFolderInEdit(HWND hwndParent, HWND hwndEdit, FOLDERDIALOGFLAGS dwFlags, 
    LPCSTR pszTitle, LPCSTR pszText, LPFOLDERID pidSelected)
{
    // Locals
    HRESULT     hr=S_OK;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("PickFolderInEdit");

    // Invalid Args
    Assert(hwndParent && hwndEdit && pidSelected);

    // Select Folder
    IF_FAILEXIT(hr = SelectFolderDialog(hwndParent, SFD_SELECTFOLDER, GetFolderIdFromEdit(hwndEdit), dwFlags | FD_FORCEINITSELFOLDER, pszTitle, pszText, pidSelected));

    // Fix Selected ?
    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(*pidSelected, &Folder));

    // SetWndThisPtr
    SetWndThisPtr(hwndEdit, Folder.idFolder);

    // Set the Text
    SetWindowText(hwndEdit, Folder.pszName);

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// LighweightOpenMessage
// --------------------------------------------------------------------------------
HRESULT LighweightOpenMessage(IDatabase *pDB, LPMESSAGEINFO pHeader,
    IMimeMessage **ppMessage)
{
    // Locals
    HRESULT             hr=S_OK;
    IStream            *pStream=NULL;
    IMimeMessage       *pMessage;

    // Invalid Args
    Assert(pDB && pHeader && ppMessage);

    // No Stream
    if (0 == pHeader->faStream)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Need to create a message ?
    if (NULL == *ppMessage)
    {
        // Create a Message
        IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMessage));

        // Set pMessage
        (*ppMessage) = pMessage;
    }

    // Otherwise, InitNew
    else
    {
        // Set pMesage
        pMessage = (*ppMessage);

        // InitNew
        pMessage->InitNew();
    }

    // Open the Stream from the Store
    IF_FAILEXIT(hr = pDB->OpenStream(ACCESS_READ, pHeader->faStream, &pStream));

    // If there is an offset table
    if (pHeader->Offsets.cbSize > 0)
    {
        // Create a ByteStream Object
        CByteStream cByteStm(pHeader->Offsets.pBlobData, pHeader->Offsets.cbSize);

        // Load the Offset Table Into the message
        pMessage->LoadOffsetTable(&cByteStm);

        // Take the bytes back out of the bytestream object (so that it doesn't try to free it)
        cByteStm.AcquireBytes(&pHeader->Offsets.cbSize, &pHeader->Offsets.pBlobData, ACQ_DISPLACE);
    }

    // Load the pMessage
    IF_FAILEXIT(hr = pMessage->Load(pStream));

exit:
    // Cleanup
    SafeRelease(pStream);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// RecurseFolderSizeInfo
// --------------------------------------------------------------------------------
HRESULT RecurseFolderSizeInfo(LPFOLDERINFO pFolder, BOOL fSubFolders, 
    DWORD cIndent, DWORD_PTR dwCookie)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbFile;
    DWORD               cbFreed;
    DWORD               cbStreams;
    IMessageFolder     *pObject=NULL;
    LPENUMFOLDERSIZE    pEnumSize=(LPENUMFOLDERSIZE)dwCookie;

    // Trace
    TraceCall("RecurseFolderSizeInfo");

    // If not hidden
    if (ISFLAGSET(pFolder->dwFlags, FOLDER_HIDDEN) || FOLDERID_ROOT == pFolder->idFolder)
        goto exit;

    // Open the Folder Database
    if (SUCCEEDED(g_pStore->OpenFolder(pFolder->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pObject)))
    {
        // Get Size Information
        IF_FAILEXIT(hr = pObject->GetSize(&cbFile, NULL, &cbFreed, &cbStreams));

        // Increment
        pEnumSize->cbFile += cbFile;
        pEnumSize->cbFreed += cbFreed;
        pEnumSize->cbStreams += cbStreams;
    }

exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// DisplayFolderSizeInfo
// --------------------------------------------------------------------------------
HRESULT DisplayFolderSizeInfo(HWND hwnd, RECURSEFLAGS dwRecurse, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szSize[255];
    CHAR            szRes[255];
    CHAR            szMsg[255];
    ENUMFOLDERSIZE  EnumSize={0};

    // Trace
    TraceCall("DisplayFolderSizeInfo");

    // Recurse and Get File Size Information...
    IF_FAILEXIT(hr = RecurseFolderHierarchy(idFolder, dwRecurse, 0, (DWORD_PTR)&EnumSize, (PFNRECURSECALLBACK)RecurseFolderSizeInfo));

    // Total Size
    StrFormatByteSizeA(EnumSize.cbFile, szSize, ARRAYSIZE(szSize));

    // Display the Text
    SetWindowText(GetDlgItem(hwnd, idcTotalSize), szSize);

    // Size of the Streams
    StrFormatByteSizeA(EnumSize.cbStreams, szSize, ARRAYSIZE(szSize));

    // Wasted Space
    StrFormatByteSizeA(EnumSize.cbFreed, szSize, ARRAYSIZE(szSize));

    // Wasted Space
    AthLoadString(idsWastedKB, szRes, ARRAYSIZE(szRes));

    // Format the String
    wsprintf(szMsg, szRes, szSize, (EnumSize.cbFile != 0) ? ((EnumSize.cbFreed * 100) / EnumSize.cbFile) : 0);

    // Show the Text
    SetWindowText(GetDlgItem(hwnd, idcWastedSpace), szMsg);

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MigrateLocalStore
// --------------------------------------------------------------------------------
HRESULT MigrateLocalStore(HWND hwndParent, LPTSTR pszSrc, LPTSTR pszDest)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dw, cb;
    CHAR                szFilePath[MAX_PATH];
    CHAR                szExpanded[MAX_PATH];
    CHAR                szCommand[MAX_PATH+20];
    LPSTR               psz=(LPSTR)c_szMigrationExe;
    PROCESS_INFORMATION pi;
    STARTUPINFO         sti;
    HKEY                hkey;

    // Try to find the path to oemig50.exe
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szFilePath);    
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szInstallRoot, 0, &dw, (LPBYTE)szFilePath, &cb))
        {
            if (REG_EXPAND_SZ == dw)
            {
                ExpandEnvironmentStrings(szFilePath, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szFilePath;

            // Append backslash
            PathAddBackslash(psz);

            // Add in oemig50.exe
            cb = lstrlen(psz);
            lstrcpyn(&psz[cb], c_szMigrationExe, MAX_PATH - cb);
        }
        RegCloseKey(hkey);
    }

    // Form the command
    wsprintf(szCommand, "%s /type:V1+V4-V5 /src:%s /dst:%s", psz, pszSrc, pszDest);

    // Zero startup info
    ZeroMemory(&sti, sizeof(STARTUPINFO));
    sti.cb = sizeof(STARTUPINFO);

    // run oemig50.exe
    if (CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
    {
        // Wait for the process to finish
        WaitForSingleObject(pi.hProcess, INFINITE);

        // Get the Exit Process Code
        if (0 == GetExitCodeProcess(pi.hProcess, &dw))
        {
            // General Failure
            dw = TraceResult(E_FAIL);
        }

        // Close the Thread
        CloseHandle(pi.hThread);

        // Close the Process
        CloseHandle(pi.hProcess);

        // Failure ?
        if (MIGRATE_E_NOCONTINUE == (HRESULT)dw)
        {
            // Abort this process
            ExitProcess(dw);

            // Set hr
            hr = TraceResult(E_FAIL);
        }

        // Success
        else
            hr = S_OK;
    }

    // Failure
    else
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

HRESULT CopyMoveMessages(HWND hwnd, FOLDERID src, FOLDERID dst, LPMESSAGEIDLIST pList, COPYMESSAGEFLAGS dwFlags)
{
    HRESULT hr;
    IMessageFolder *pFolderSrc, *pFolderDst;

    Assert(pList != NULL);
    Assert(hwnd != NULL);

    hr = g_pStore->OpenFolder(src, NULL, 0, &pFolderSrc);
    if (SUCCEEDED(hr))
    {
        hr = g_pStore->OpenFolder(dst, NULL, 0, &pFolderDst);
        if (SUCCEEDED(hr))
        {
            hr = CopyMessagesProgress(hwnd, pFolderSrc, pFolderDst, dwFlags, pList, NULL);

            pFolderDst->Release();
        }

        pFolderSrc->Release();
    }

    return(hr);
}

// --------------------------------------------------------------------------------
// CallbackOnLogonPrompt
// --------------------------------------------------------------------------------
HRESULT CallbackOnLogonPrompt(HWND hwndParent, LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    DWORD           apidUserName;
    DWORD           apidPassword;
    DWORD           apidPromptPwd;

    // Trace
    TraceCall("CallbackOnLogonPrompt");

    // Invalid Args
    Assert(g_pAcctMan && hwndParent && IsWindow(hwndParent) && pServer);

    switch (ixpServerType)
    {
        case IXP_POP3:
            apidUserName = AP_POP3_USERNAME;
            apidPassword = AP_POP3_PASSWORD;
            apidPromptPwd = AP_POP3_PROMPT_PASSWORD;
            break;

        case IXP_SMTP:
            apidUserName = AP_SMTP_USERNAME;
            apidPassword = AP_SMTP_PASSWORD;
            apidPromptPwd = AP_SMTP_PROMPT_PASSWORD;
            break;

        case IXP_NNTP:
            apidUserName = AP_NNTP_USERNAME;
            apidPassword = AP_NNTP_PASSWORD;
            apidPromptPwd = AP_NNTP_PROMPT_PASSWORD;
            break;

        case IXP_IMAP:
            apidUserName = AP_IMAP_USERNAME;
            apidPassword = AP_IMAP_PASSWORD;
            apidPromptPwd = AP_IMAP_PROMPT_PASSWORD;
            break;

        case IXP_HTTPMail:
            apidUserName = AP_HTTPMAIL_USERNAME;
            apidPassword = AP_HTTPMAIL_PASSWORD;
            apidPromptPwd = AP_HTTPMAIL_PROMPT_PASSWORD;
            break;

        default:
            AssertSz(FALSE, "Not a valid server type");
            hr = TraceResult(E_FAIL);
            goto exit;
    }

    // Find the Account for pServer
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pServer->szAccount, &pAccount));

    // Call Task Util
    IF_FAILEXIT(hr = TaskUtil_OnLogonPrompt(pAccount, NULL, hwndParent, pServer, apidUserName, apidPassword, apidPromptPwd, TRUE));

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CallbackOnPrompt
// --------------------------------------------------------------------------------
HRESULT CallbackOnPrompt(HWND hwndParent, HRESULT hrError, LPCTSTR pszText, 
    LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    // Trace
    TraceCall("CallbackOnPrompt");

    // Invalid Arg
    Assert(pszText && pszCaption && piUserResponse);

    // Do the message box
    *piUserResponse = AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), (LPSTR)pszText, NULL, uType | MB_TASKMODAL);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CallbackOnTimeout
// --------------------------------------------------------------------------------
HRESULT CallbackOnTimeout(LPINETSERVER pServer, IXPTYPE ixpServerType, DWORD dwTimeout,
                          ITimeoutCallback *pCallback, LPHTIMEOUT phTimeout)
{
    // Locals
    HWND         hwndTimeout;

    // Trace
    TraceCall("CallbackOnTimeout");

    // Invalid Args
    Assert(pServer && phTimeout);

    // Set hwndTimeout
    hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

    // We are already showing a timeout dialog
    if (NULL == hwndTimeout)
    {
        LPCSTR  pszProtocol;

        // Do the Dialog
        GetProtocolString(&pszProtocol, ixpServerType);
        hwndTimeout = TaskUtil_HwndOnTimeout(pServer->szServerName, pServer->szAccount, pszProtocol, dwTimeout, pCallback);

        // Cast to phTimeout
        *phTimeout = (HTIMEOUT)hwndTimeout;

        // Store It
        TlsSetValue(g_dwTlsTimeout, (LPVOID)hwndTimeout);
    }

    // Done
    return(S_OK);
}



// --------------------------------------------------------------------------------
// CallbackCloseTimeout
// --------------------------------------------------------------------------------
HRESULT CallbackCloseTimeout(LPHTIMEOUT phTimeout)
{
    // Locals
    HWND    hwndTimeout=NULL;

    // Trace
    TraceCall("CallbackCloseTimeout");

    // Invalid Args
    Assert(phTimeout);

    // Nothing to Close
    if (NULL == *phTimeout)
        return(S_OK);

    // Get Timeout
    hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

    // Must Equal hwndTimeout
    Assert(hwndTimeout == (HWND)*phTimeout);

    // Kill the Window
    if (hwndTimeout && IsWindow(hwndTimeout) && hwndTimeout == (HWND)*phTimeout)
    {
        // Kil It
        DestroyWindow(hwndTimeout);
    }

    // Not Timeout
    TlsSetValue(g_dwTlsTimeout, NULL);

    // Null phTmieout
    *phTimeout = NULL;

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CallbackOnTimeoutResponse
// --------------------------------------------------------------------------------
HRESULT CallbackOnTimeoutResponse(TIMEOUTRESPONSE eResponse, IOperationCancel *pCancel, 
    LPHTIMEOUT phTimeout)
{
    // Trace
    TraceCall("CallbackOnTimeoutResponse");

    // better have a Cancel
    Assert(pCancel);

    // Handle the timeout
    switch(eResponse)
    {
    case TIMEOUT_RESPONSE_STOP:
        if (pCancel)
            pCancel->Cancel(CT_ABORT);
        break;

    case TIMEOUT_RESPONSE_WAIT:
        CallbackCloseTimeout(phTimeout);
        break;

    default:
        Assert(FALSE);
        break;
    }

    // Kill the timeout dialog
    CallbackCloseTimeout(phTimeout);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CallbackCanConnect
// --------------------------------------------------------------------------------
HRESULT CallbackCanConnect(LPCSTR pszAccountId, HWND hwndParent, BOOL fPrompt)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CallbackCanConnect");

    // Validate the Args
    Assert(pszAccountId);

    Assert(hwndParent);

    // We Should hav g_pConMan
    Assert(g_pConMan);

    // Call Into It
    if (g_pConMan)
    {
        // Can We Connect
        hr = g_pConMan->CanConnect((LPSTR)pszAccountId);

        if ((hr != S_OK) && (hr != HR_E_DIALING_INPROGRESS) && (fPrompt))
        {
            //We go ahead and connect
            hr = g_pConMan->Connect((LPSTR)pszAccountId, hwndParent, fPrompt);
        }
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CallbackDisplayError
// --------------------------------------------------------------------------------
HRESULT CallbackDisplayError(HWND hwndParent, HRESULT hrResult, LPSTOREERROR pError)
{
    // Locals
    CHAR            sz[CCHMAX_STRINGRES + 512];
    LPSTR           pszError = NULL;

    // Trace
    TraceCall("CallbackDisplayError");

    // Do not show errors that are caused by explicit user action
    switch (hrResult)
    {
        case HR_E_OFFLINE_FOLDER_CREATE:
            LoadString(g_hLocRes, idsErrOfflineFldrCreate, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case HR_E_OFFLINE_FOLDER_MOVE:
            LoadString(g_hLocRes, idsErrOfflineFldrMove, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case HR_E_OFFLINE_FOLDER_DELETE:
            LoadString(g_hLocRes, idsErrOfflineFldrDelete, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case HR_E_OFFLINE_FOLDER_RENAME:
            LoadString(g_hLocRes, idsErrOfflineFldrRename, sz, ARRAYSIZE(sz));
            pError->pszProblem = sz;
            break;

        case STORE_E_OPERATION_CANCELED:
        case HR_E_USER_CANCEL_CONNECT:
        case HR_E_OFFLINE:
        case HR_E_DIALING_INPROGRESS:
        case STORE_E_EXPIRED:
        case STORE_E_NOREMOTESPECIALFLDR: // Note should handle this case itself
        case IXP_E_USER_CANCEL:
        case IXP_E_HTTP_NOT_MODIFIED:
        case hrUserCancel:
            return(S_OK);

    }

    // Figure out error description string, if none provided
    if (NULL == pError || pError->pszProblem == NULL || '\0' == pError->pszProblem[0])
    {
        UINT            idsError = IDS_IXP_E_UNKNOWN;
        LPCTASKERROR    pTaskError=NULL;
        char            szRes[CCHMAX_STRINGRES];

        if (pError)
        {
            // Try to locate an Error Info
            pTaskError = PTaskUtil_GetError(pError->hrResult, NULL);
        }

        // Try to locate an Error Info
        if (NULL == pTaskError)
        {
            // Try to find a task error
            pTaskError = PTaskUtil_GetError(hrResult, NULL);
        }

        // If we have a task error
        if (pTaskError)
        {
            // Set the String
            idsError = pTaskError->ulStringId;
        }

        // Better Succeed
        SideAssert(LoadString(g_hLocRes, idsError, szRes, ARRAYSIZE(szRes)) > 0);

        // Add any extra information to the error string that might be necessary
        switch (idsError)
        {
            // Requires account name
            case idsNNTPErrUnknownResponse:
            case idsNNTPErrNewgroupsFailed:
            case idsNNTPErrListFailed:
            case idsNNTPErrPostFailed:
            case idsNNTPErrDateFailed:
            case idsNNTPErrPasswordFailed:
            case idsNNTPErrServerTimeout:
                wsprintf(sz, szRes, pError->pszAccount);
                break;
        
            // Group name, then account name
            case idsNNTPErrListGroupFailed:
            case idsNNTPErrGroupFailed:
            case idsNNTPErrGroupNotFound:
                wsprintf(sz, szRes, pError->pszFolder, pError->pszAccount);
                break;

            // Group name only
            case idsNNTPErrHeadersFailed:
            case idsNNTPErrXhdrFailed:
                wsprintf(sz, szRes, pError->pszFolder);
                break;

            default:
                lstrcpy(sz, szRes);            
        }

        pszError = sz;
    }
    else
        // Provided error string should always override generic HRESULT error str
        pszError = pError->pszProblem;

    // No pError ?
    if (pError)
    {
        INETMAILERROR   ErrorInfo={0};

        // Setup the Error Structure
        ErrorInfo.dwErrorNumber = pError->uiServerError;
        ErrorInfo.hrError = pError->hrResult;
        ErrorInfo.pszServer = pError->pszServer;
        ErrorInfo.pszAccount = pError->pszAccount;
        ErrorInfo.pszMessage = pszError;
        ErrorInfo.pszUserName = pError->pszUserName;
        ErrorInfo.pszProtocol = pError->pszProtocol;
        ErrorInfo.pszDetails = pError->pszDetails;
        ErrorInfo.dwPort = pError->dwPort;
        ErrorInfo.fSecure = pError->fSSL;

        // Beep
        MessageBeep(MB_OK);

        // Show the error
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddInetMailError), hwndParent, (DLGPROC) InetMailErrorDlgProc, (LPARAM)&ErrorInfo);
    }

    // Otherwise, show an error
    else
    {
        // Beep
        MessageBeep(MB_OK);

        // Show an error
        AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthena), pszError, NULL, MB_OK | MB_TASKMODAL);
    }

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CompareTableIndexes
// --------------------------------------------------------------------------------
HRESULT CompareTableIndexes(LPCTABLEINDEX pIndex1, LPCTABLEINDEX pIndex2)
{
    // Locals
    DWORD i;

    // Trace
    TraceCall("CompareTableIndexes");

    // Different Number of Keys
    if (pIndex1->cKeys != pIndex2->cKeys)
        return(S_FALSE);

    // Loop through the keys
    for (i=0; i<pIndex1->cKeys; i++)
    {
        // Different Column
        if (pIndex1->rgKey[i].iColumn != pIndex2->rgKey[i].iColumn)
            return(S_FALSE);

        // Different Compare Flags
        if (pIndex1->rgKey[i].bCompare != pIndex2->rgKey[i].bCompare)
            return(S_FALSE);

        // Different Compare Bits
        if (pIndex1->rgKey[i].dwBits != pIndex2->rgKey[i].dwBits)
            return(S_FALSE);
    }

    // Equal
    return(S_OK);
}

// --------------------------------------------------------------------------------
// EmptyFolder
// --------------------------------------------------------------------------------
HRESULT EmptyFolder(HWND hwndParent, FOLDERID idFolder)
{
    // Locals
    char            sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    IMessageFolder *pFolder=NULL;

    // Trace
    TraceCall("EmptyFolder");

    // Open the Folder
    IF_FAILEXIT(hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder));

    // Delete all the messages from the folder
    IF_FAILEXIT(hr = DeleteMessagesProgress(hwndParent, pFolder, DELETE_MESSAGE_NOPROMPT | DELETE_MESSAGE_NOTRASHCAN, NULL));

    // Delete Sub Folders..
    IF_FAILEXIT(hr = DeleteFolderProgress(hwndParent, idFolder, DELETE_FOLDER_CHILDRENONLY | DELETE_FOLDER_RECURSIVE));

exit:
    // Cleanup
    SafeRelease(pFolder);

    // Error Message
    if (FAILED(hr))
    {
        g_pStore->GetFolderInfo(idFolder, &Folder);
        AthLoadString(idsErrDeleteOnExit, sz, ARRAYSIZE(sz));
        wsprintf(szT, sz, Folder.pszName);
        AthErrorMessage(g_hwndInit, MAKEINTRESOURCE(idsAthenaMail), szT, hr);
        g_pStore->FreeRecord(&Folder);
    }

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// EmptySpecialFolder
// --------------------------------------------------------------------------------
HRESULT EmptySpecialFolder(HWND hwndParent, SPECIALFOLDER tySpecial)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("EmptySpecialFolder");

    // Get special folder information
    IF_FAILEXIT(hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, tySpecial, &Folder));

    // Delete all the messages from the folder
    IF_FAILEXIT(hr = EmptyFolder(hwndParent, Folder.idFolder));

exit:
    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(hr);
}

//----------------------------------------------------------------------------------
// IsParentDeletedItems
//----------------------------------------------------------------------------------
HRESULT IsParentDeletedItems(FOLDERID idFolder, LPFOLDERID pidDeletedItems,
    LPFOLDERID pidServer)
{
    // Locals
    BOOL        fInTrashCan=FALSE;
    FOLDERID    idCurrent=idFolder;
    FOLDERINFO  Folder={0};

    // Trace
    TraceCall("IsParentDeletedItems");
    
    // Invalid Arg
    Assert(pidDeletedItems && pidServer);

    // Initialize
    *pidDeletedItems = FOLDERID_INVALID;
    *pidServer = FOLDERID_INVALID;

    // Walk up the parent chain
    while (SUCCEEDED(g_pStore->GetFolderInfo(idCurrent, &Folder)))
    {
        // If this is the deleted items folder
        if (FOLDER_DELETED == Folder.tySpecial)
        {
            // idFolder is a child of the deleted items folder...
            fInTrashCan = TRUE;

            // Save the Id
            *pidDeletedItems = Folder.idFolder;
        }

        // If This is a Server, done
        if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            // Return Server
            *pidServer = Folder.idFolder;

            // Done
            break;
        }

        // Set idCurrent
        idCurrent = Folder.idParent;

        // Cleanup
        g_pStore->FreeRecord(&Folder);
    }

    // Validate
    Assert(FOLDERID_INVALID != *pidServer);

    // Cleanup
    g_pStore->FreeRecord(&Folder);

    // Done
    return(TRUE == fInTrashCan ? S_OK : S_FALSE);
}

HRESULT CreateTempNewsAccount(LPCSTR pszServer, DWORD dwPort, BOOL fSecure, IImnAccount **ppAcct)
{
    IImnAccount        *pAcct, *pDefAcct;
    IImnEnumAccounts   *pEnum;
    DWORD               dwTemp;
    char                szServer[1024];
    HRESULT             hr;
    
    *ppAcct = NULL;
    
    if (lstrlen(pszServer) >= CCHMAX_SERVER_NAME)
        return(E_FAIL);

    // First try to see if we can find such a server.
    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_NNTP, &pEnum)))
    {
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_SERVER, szServer, ARRAYSIZE(szServer))))
            {
                if (0 == lstrcmpi(pszServer, szServer))
                {
                    // The server names are the same, but we also need to make
                    // sure the port numbers are the same as well
                    if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_PORT, &dwTemp)) && dwTemp == dwPort)
                    {
                        // This is really bizzare.  Since this value doesn't seem to have a default 
                        // setting, if it hasn't been set yet, it returns E_NoPropData.
                        hr = pAcct->GetPropDw(AP_NNTP_SSL, &dwTemp);
                        if (hr == E_NoPropData || (SUCCEEDED(hr) && dwTemp == (DWORD) fSecure))
                        {
                            *ppAcct = pAcct;
                            break;
                        }
                    }
                }
            }
            pAcct->Release();
        }
        pEnum->Release();
    }
    
    if (*ppAcct)
        return (S_OK);
    
    // Try to create a new account object
    if (FAILED(hr = g_pAcctMan->CreateAccountObject(ACCT_NEWS, &pAcct)))
        return (hr);
    
    // We have the object, so set the account name and server name to pszServer.
    lstrcpy(szServer, pszServer);
    g_pAcctMan->GetUniqueAccountName(szServer, ARRAYSIZE(szServer));
    pAcct->SetPropSz(AP_ACCOUNT_NAME, szServer);
    pAcct->SetPropSz(AP_NNTP_SERVER, (LPSTR)pszServer);
    pAcct->SetPropDw(AP_NNTP_PORT, dwPort);
    pAcct->SetPropDw(AP_NNTP_SSL, fSecure);
    
    // Load the default news account
    if (SUCCEEDED(hr = g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pDefAcct)))
    {
        // Copy the User Name
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_DISPLAY_NAME, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, szServer);
        
        // Copy the Org
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_ORG_NAME, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_ORG_NAME, szServer);
        
        // Copy the email
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, szServer);
        
        // Copy the reply to
        if (SUCCEEDED(hr = pDefAcct->GetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szServer, ARRAYSIZE(szServer))))
            pAcct->SetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szServer);
        
        pDefAcct->Release();
    }
    
    // Tag this account as a temporary account
    pAcct->SetPropDw(AP_TEMP_ACCOUNT, (DWORD)TRUE);
    
    // save the changes
    pAcct->SaveChanges();
    
    *ppAcct = pAcct;
    
    return (S_OK);
}

void CleanupTempNewsAccounts()
{
    IImnAccount        *pAcct;
    IImnEnumAccounts   *pEnum;
    DWORD               dwTemp;
    BOOL                fSub;
    FOLDERID            idAcct;
    HRESULT             hr;
    FOLDERINFO          info;
    char                szAcct[CCHMAX_ACCOUNT_NAME];
    
    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_NNTP, &pEnum)))
    {
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropDw(AP_TEMP_ACCOUNT, &dwTemp)) && dwTemp)
            {
                if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szAcct, ARRAYSIZE(szAcct))))
                {
                    // if it doesn't have any subscribed children,
                    // we can delete it

                    fSub = FALSE;

                    hr = g_pStore->FindServerId(szAcct, &idAcct);
                    if (SUCCEEDED(hr))
                    {
                        IEnumerateFolders  *pFldrEnum;

                        // News accounts only have ONE level, so enumerate immediate
                        // subscribed children to see if there is at least one of them
                        hr = g_pStore->EnumChildren(idAcct, TRUE, &pFldrEnum);
                        if (SUCCEEDED(hr))
                        {
                            hr = pFldrEnum->Next(1, &info, NULL);
                            if (S_OK == hr)
                            {
                                if (info.dwFlags & FOLDER_SUBSCRIBED)
                                    fSub = TRUE;
                                
                                g_pStore->FreeRecord(&info);
                            }
                            pFldrEnum->Release();
                        }
                    }

                    if (fSub)
                        pAcct->SetPropDw(AP_TEMP_ACCOUNT, (DWORD)FALSE);
                    else
                        pAcct->Delete();
                }
            }
            pAcct->Release();
        }
        pEnum->Release();
    }
}

HRESULT FindGroupAccount(LPCSTR pszGroup, LPSTR pszAccount, UINT cchAccount)
{
    IImnEnumAccounts *pEnum;
    IImnAccount *pAcct;
    FOLDERID idAcct;
    HRESULT hr;
    HLOCK hLock;
    FOLDERINFO Folder;
    char szAccount[CCHMAX_ACCOUNT_NAME], szDefAcct[CCHMAX_ACCOUNT_NAME];
    UINT cScore, cScoreMax = 0;
    
    *szDefAcct = 0;
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pAcct)))
    {
        pAcct->GetPropSz(AP_ACCOUNT_ID, szDefAcct, ARRAYSIZE(szDefAcct));
        pAcct->Release();
    }

    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_NNTP, &pEnum)))
    {
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szAccount, ARRAYSIZE(szAccount))) &&
                SUCCEEDED(g_pStore->FindServerId(szAccount, &idAcct)) &&
                SUCCEEDED(g_pStore->Lock(&hLock)))
            {
                cScore = 0;
    
                ZeroMemory(&Folder, sizeof(FOLDERINFO));
                Folder.idParent = idAcct;
                Folder.pszName = (LPSTR)pszGroup;
                
                if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
                {
                    // look for it in the group list
                    cScore += 1;
                    
                    // check to see if it is subscribed
                    if (!!(Folder.dwFlags & FOLDER_SUBSCRIBED))
                        cScore += 4;
                    
                    g_pStore->FreeRecord(&Folder);
                }
                
                if (cScore)
                {
                    // is this the default account?
                    if (0 == lstrcmpi(szAccount, szDefAcct))
                        cScore += 2;
                    
                    if (cScore > cScoreMax)
                    {
                        cScoreMax = cScore;
                        lstrcpyn(pszAccount, szAccount, cchAccount);
                    }
                }
                
                g_pStore->Unlock(&hLock);
            }

            pAcct->Release();
        } 

        pEnum->Release();
    }

    return(cScoreMax > 0 ? S_OK : E_FAIL);
}

HRESULT GetNewsGroupFolderId(LPCSTR pszAccount, LPCSTR pszGroup, FOLDERID *pid)
{
    FOLDERID idAcct;
    HRESULT hr;
    HLOCK hLock;
    FOLDERINFO Folder = {0};
    
    Assert(pszAccount != NULL);
    Assert(pszGroup != NULL);
    Assert(pid != NULL);
    
    hr = g_pStore->FindServerId(pszAccount, &idAcct);
    if (FAILED(hr))
        return(hr);
    
    hr = g_pStore->Lock(&hLock);
    if (FAILED(hr))
        return(hr);
    
    Folder.idParent = idAcct;
    Folder.pszName = (LPSTR)pszGroup;
    
    if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
    {
        *pid = Folder.idFolder;
        
        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        ZeroMemory(&Folder, sizeof(FOLDERINFO));
        Folder.idParent = idAcct;
        Folder.tySpecial = FOLDER_NOTSPECIAL;
        Folder.pszName = (LPSTR)pszGroup;

        hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &Folder, NULL);           
        if (SUCCEEDED(hr))
            *pid = Folder.idFolder;
    }
    
    g_pStore->Unlock(&hLock);
    
    return(hr);
}

HRESULT GetFolderIdFromNewsUrl(LPCSTR pszServer, UINT uPort, LPCSTR pszGroup, BOOL fSecure, FOLDERID *pid)
{
    char            szAccount[CCHMAX_ACCOUNT_NAME];
    IImnAccount    *pAcct;
    HRESULT         hr;

    Assert(pid != NULL);

    *pid = FOLDERID_INVALID;

    // Bug #20448 - Handle IE 2.0's "news:netnews" and "news:*".  These
    //              should just cause us to launch normally.
    if (0 == lstrcmpi(pszGroup, c_szURLNetNews) || 
        0 == lstrcmpi(pszGroup, g_szAsterisk))
    {
        pszGroup = NULL;
    }

    *szAccount = 0;

    if (uPort == -1)
        uPort = fSecure ? DEF_SNEWSPORT : DEF_NNTPPORT;

    if (pszServer != NULL &&
        SUCCEEDED(CreateTempNewsAccount(pszServer, uPort, fSecure, &pAcct)))
    {
        pAcct->GetPropSz(AP_ACCOUNT_ID, szAccount, ARRAYSIZE(szAccount));
        pAcct->Release();
    }
    else
    {
        if (pszGroup == NULL || FAILED(FindGroupAccount(pszGroup, szAccount, ARRAYSIZE(szAccount))))
        {
            if (FAILED(g_pAcctMan->GetDefaultAccount(ACCT_NEWS, &pAcct)))
                return(E_FAIL);

            pAcct->GetPropSz(AP_ACCOUNT_ID, szAccount, ARRAYSIZE(szAccount));
            pAcct->Release();
        }
    }

    if (pszGroup != NULL)
    {
        hr = GetNewsGroupFolderId(szAccount, pszGroup, pid);
    }
    else
    {
        hr = g_pStore->FindServerId(szAccount, pid);
    }

    return(hr);
}



#define CHASH_BUCKETS   50

HRESULT CreateFolderHash(IMessageStore *pStore, FOLDERID idRoot, IHashTable **ppHash)
{
    IHashTable  *pHash=0;
    HRESULT     hr;
    LPSTR       pszTemp;
    DWORD       dwTemp;

    hr = MimeOleCreateHashTable(CHASH_BUCKETS, TRUE, &pHash);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }        

    pszTemp = NULL;
    dwTemp = 0;
    hr = HashChildren(pStore, idRoot, pHash, &pszTemp, 0, &dwTemp);
    SafeMemFree(pszTemp);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    *ppHash = pHash;
    pHash = NULL;
        
exit:
    ReleaseObj(pHash);
    return hr;
}

HRESULT HashChildren(IMessageStore *pStore, FOLDERID idParent, IHashTable *pHash,
                     LPSTR *ppszPath, DWORD dwChildOffset, DWORD *pdwAlloc)
{
    FOLDERINFO			fi;
    HRESULT				hr=S_OK;
	IEnumerateFolders	*pFldrEnum=0;
    LPSTR               pszInsertPt;

    pszInsertPt = *ppszPath + dwChildOffset;
    hr = pStore->EnumChildren(idParent, FALSE, &pFldrEnum);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    while (pFldrEnum->Next(1, &fi, NULL)==S_OK)
    {
        DWORD dwFldrNameLen;

        // Check if path buffer is large enough to accommodate current
        // foldername + hierarchy char + null term
        dwFldrNameLen = lstrlen(fi.pszName);
        if (dwFldrNameLen + dwChildOffset + 1 >= *pdwAlloc)
        {
            BOOL    fResult;
            DWORD   dwNewSize;

            dwNewSize = dwChildOffset + dwFldrNameLen + 51; // 1 byte for HC, 50 bytes worth of insurance
            Assert(dwNewSize > *pdwAlloc);
            fResult = MemRealloc((void **) ppszPath, dwNewSize * sizeof(**ppszPath));
            if (FALSE == fResult)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                pStore->FreeRecord(&fi);
                goto exit;
            }

            *pdwAlloc = dwNewSize;
            pszInsertPt = *ppszPath + dwChildOffset;
        }

        // Construct current folder path, insert into table
        lstrcpyn(pszInsertPt, fi.pszName, *pdwAlloc - (int) (pszInsertPt - *ppszPath));
        hr = pHash->Insert(*ppszPath, (LPVOID)fi.idFolder, NOFLAGS);
        if (FAILED(hr))
        {
            TraceResult(hr);
            pStore->FreeRecord(&fi);
            goto exit;
        }
    
        // if this folder has kids, recurse into it's child folders
        if (fi.dwFlags & FOLDER_HASCHILDREN)
        {
            // Append hierarchy character to current foldername
            IxpAssert(0 != fi.bHierarchy && 0xFF != fi.bHierarchy);
            Assert(dwFldrNameLen + 1 + dwChildOffset < *pdwAlloc); // Hierarchy char is guaranteed to fit (see above)
            pszInsertPt[dwFldrNameLen] = fi.bHierarchy;
            pszInsertPt[dwFldrNameLen + 1] = '\0'; // Don't need to null-term

            hr = HashChildren(pStore, fi.idFolder, pHash, ppszPath,
                dwChildOffset + dwFldrNameLen + 1, pdwAlloc);
            if (FAILED(hr))
            {
                TraceResult(hr);
                pStore->FreeRecord(&fi);
                goto exit;
            }

            // Recalculate pszInsertPt, in case HashChildren re-alloc'ed
            pszInsertPt = *ppszPath + dwChildOffset;
        }
        pStore->FreeRecord(&fi);
    }

exit:
    ReleaseObj(pFldrEnum);
    return hr;
}

#define CMAX_DELETE_SEARCH_BLOCK 50
HRESULT UnsubscribeHashedFolders(IMessageStore *pStore, IHashTable *pHash)
{
    ULONG   cFound=0;
    LPVOID  *rgpv;

    pHash->Reset();

    while (SUCCEEDED(pHash->Next(CMAX_DELETE_SEARCH_BLOCK, &rgpv, &cFound)))
    {
        while(cFound--)
        {
            pStore->SubscribeToFolder((FOLDERID)rgpv[cFound], FALSE, NULL);
        }

        SafeMemFree(rgpv);
    }
    return S_OK;
}


#ifdef DEBUG
LPCSTR sotToSz(STOREOPERATIONTYPE sot)
{

    switch (sot)
    {
    case SOT_INVALID:
        return "Invalid";
    
    case SOT_CONNECTION_STATUS:
        return "ConnectionStatus";

    case SOT_SYNC_FOLDER:
        return "SyncFolder";

    case SOT_GET_MESSAGE:
        return "GetMessage";

    case SOT_PUT_MESSAGE:
        return "PutMessage";

    case SOT_COPYMOVE_MESSAGE:
        return "CopyMoveMessage";

    case SOT_SYNCING_STORE:
        return "SyncStore";

    case SOT_CREATE_FOLDER:
        return "CreateFolder";

    case SOT_SEARCHING:
        return "Search";

    case SOT_DELETING_MESSAGES:
        return "DeleteMessage";

    case SOT_SET_MESSAGEFLAGS:
        return "SetMessageFlags";

	case SOT_MOVE_FOLDER:
        return "MoveFolder";

	case SOT_DELETE_FOLDER:
        return "DeleteFolder";

	case SOT_RENAME_FOLDER:
        return "RenameFolder";

	case SOT_SUBSCRIBE_FOLDER:
        return "SubscribeFolder";

	case SOT_UPDATE_FOLDER:
        return "UpdateFolderCounts";

    case SOT_GET_NEW_GROUPS:
        return "GetNewGroups";

    case SOT_PURGING_MESSAGES:
        return "PurgeMessages";

    case SOT_NEW_MAIL_NOTIFICATION:
        return "NewMailNotify";

    default:
        return "<SOT_UNKNOWN>";
    }
}
#endif

HRESULT SetSynchronizeFlags(FOLDERID idFolder, DWORD flags)
{
    FOLDERINFO info;
    HRESULT hr;

    Assert(0 == (flags & ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)));

    hr = g_pStore->GetFolderInfo(idFolder, &info);
    if (SUCCEEDED(hr))
    {
        info.dwFlags &= ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL);
        if (flags != 0)
            info.dwFlags |= flags;

        hr = g_pStore->UpdateRecord(&info);

        g_pStore->FreeRecord(&info);
    }

    return(hr);
}


HRESULT CreateMessageFromInfo(MESSAGEINFO *pInfo, IMimeMessage **ppMessage, FOLDERID folderID)
{
    IMimeMessage   *pMsg=0;
    HRESULT         hr;
    PROPVARIANT     pv;

    if (!ppMessage || !pInfo)
        return TraceResult(E_INVALIDARG);

    *ppMessage = NULL;

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    
    // sent-time
    pv.vt = VT_FILETIME;
    CopyMemory(&pv.filetime, &pInfo->ftSent, sizeof(FILETIME));
    pMsg->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);

    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, pInfo->pszMessageId);
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pInfo->pszSubject);
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, pInfo->pszFromHeader);
    MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, pInfo->pszDisplayTo);

    if (FOLDERID_INVALID != folderID)
    {
        FOLDERINFO  fi;
        hr = g_pStore->GetFolderInfo(folderID, &fi);
        if (SUCCEEDED(hr))
        {
            if (FOLDER_NEWS == fi.tyFolder)
            {
                if (0 == (FOLDER_SERVER & fi.dwFlags))
                    hr = MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, fi.pszName);
            }
            g_pStore->FreeRecord(&fi);
        }
    }

    HrSetAccount(pMsg, pInfo->pszAcctName);

    *ppMessage = pMsg;
    pMsg = NULL;
    hr = S_OK;

exit:
    ReleaseObj(pMsg);
    return hr;
}


HRESULT CommitMessageToStore(IMessageFolder *pFolder, ADJUSTFLAGS *pflags, MESSAGEID idMessage, LPSTREAM pstm)
{
    HRESULT         hr;
    IMimeMessage    *pMsg=0;
    DWORD           dwFlags=0,
                    dwAddFlags=0,
                    dwRemoveFlags=0;
    MESSAGEIDLIST   rMsgList;
    ADJUSTFLAGS     rAdjFlags;

    TraceCall("CIMAPSync::_OnMessageDownload");

    Assert (pFolder);

    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pMsg->Load(pstm);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (SUCCEEDED(pMsg->GetFlags(&dwFlags)))
        dwAddFlags = ConvertIMFFlagsToARF(dwFlags);

    // We always want to remove ARF_DOWNLOAD when downloading a message body
    dwRemoveFlags |= ARF_DOWNLOAD;

    rMsgList.cAllocated = 0;
    rMsgList.cMsgs = 1;
    rMsgList.prgidMsg = &idMessage;

    if (pflags==NULL)
    {
        pflags = &rAdjFlags;
        
        rAdjFlags.dwRemove = 0;
        rAdjFlags.dwAdd = 0;
    }
        
    pflags->dwAdd |= dwAddFlags;
    pflags->dwRemove |= dwRemoveFlags;
    hr = pFolder->SetMessageFlags(&rMsgList, pflags, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->SetMessageStream(idMessage, pstm);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }


exit:
    ReleaseObj(pMsg);
    return hr;
}

HRESULT CreatePersistentWriteStream(IMessageFolder *pFolder, IStream **ppStream, LPFILEADDRESS pfaStream)
{
    HRESULT hr=S_OK;

    TraceCall("CreateOpenStream");

    Assert(NULL != pFolder && NULL != ppStream && NULL != pfaStream);
    if (NULL == pFolder || NULL == ppStream || NULL == pfaStream)
        return E_INVALIDARG;

    *ppStream = NULL;
    *pfaStream = 0;

    hr = pFolder->CreateStream(pfaStream);
    if (!FAILED(hr))
    {
        hr = pFolder->OpenStream(ACCESS_WRITE, *pfaStream, ppStream);
        if (FAILED(hr))
        {
            pFolder->DeleteStream(*pfaStream);
            *pfaStream = 0;
        }
    }

    return hr;
}

HRESULT GetHighestCachedMsgID(IMessageFolder *pFolder, DWORD_PTR *pdwHighestCachedMsgID)
{
    HRESULT     hr;
    HROWSET     hRowSet = HROWSET_INVALID;
    MESSAGEINFO miMsgInfo = {0};

    TraceCall("GetHighestCachedMsgID");
    Assert(NULL != pdwHighestCachedMsgID);

    hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowSet);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->SeekRowset(hRowSet, SEEK_ROWSET_END, 0, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pFolder->QueryRowset(hRowSet, 1, (void **)&miMsgInfo, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (HROWSET_INVALID != hRowSet)
    {
        HRESULT hrTemp;

        // Record but otherwise ignore error
        hrTemp = pFolder->CloseRowset(&hRowSet);
        TraceError(hrTemp);
    }

    // Return highest cached UID
    if (DB_E_NORECORDS == hr)
    {
        // No problem, no records means highest cached UID = 0
        *pdwHighestCachedMsgID = 0;
        hr = S_OK;
    }
    else if (SUCCEEDED(hr))
    {
        *pdwHighestCachedMsgID = (DWORD_PTR) miMsgInfo.idMessage;
        pFolder->FreeRecord(&miMsgInfo);
    }

    return hr;
}

HRESULT DeleteMessageFromStore(MESSAGEINFO * pMsgInfo, IDatabase *pDB, IDatabase * pUidlDB)
{
    // Locals
    HRESULT         hr = S_OK;
    UIDLRECORD      UidlInfo = {0};

    // Trace
    TraceCall("DeleteMessageFromStore");

    Assert(NULL != g_pStore);
    
    // Check incoming params
    if ((NULL == pMsgInfo) || (NULL == pDB))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Delete the Bastard
    IF_FAILEXIT(hr = pDB->DeleteRecord(pMsgInfo));

    // Update UIDL Cache ?
    if (pUidlDB && !FIsEmptyA(pMsgInfo->pszUidl) && !FIsEmptyA(pMsgInfo->pszServer))
    {
        // Set Search Key
        UidlInfo.pszUidl = pMsgInfo->pszUidl;
        UidlInfo.pszServer = pMsgInfo->pszServer;
        UidlInfo.pszAccountId = pMsgInfo->pszAcctId;

        // Loop it up
        if (DB_S_FOUND == pUidlDB->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &UidlInfo, NULL))
        {
            // Deleted on client
            UidlInfo.fDeleted = TRUE;

            // Set the prop
            pUidlDB->UpdateRecord(&UidlInfo);

            // Free the Record
            pUidlDB->FreeRecord(&UidlInfo);
        }
    }

    hr = S_OK;
    
exit:
    // Done
    return(hr);
}

BOOL FFolderIsServer(FOLDERID id)
{
    FOLDERINFO fi = {0};
    HRESULT    hr;
    BOOL       fServer = FALSE;

    // Get Folder Info
    hr = g_pStore->GetFolderInfo(id, &fi);
    if (FAILED(hr))
        return (FALSE);

    // Is this a server ?
    fServer = ISFLAGSET(fi.dwFlags, FOLDER_SERVER);

    g_pStore->FreeRecord(&fi);
    return (fServer);
}

HRESULT GetIdentityStoreRootDirectory(IUserIdentity *pId, LPSTR pszDir, DWORD cchMaxDir)
{
    // Locals
    HKEY        hkey;
    char        szProfile[MAX_PATH];
    HRESULT     hr=S_OK;
    DWORD       cb;
    DWORD       dwType;

    Assert(pId != NULL);
    Assert(pszDir != NULL);
    Assert(cchMaxDir >= MAX_PATH);

    hr = pId->OpenIdentityRegKey(KEY_ALL_ACCESS, &hkey);
    if (FAILED(hr))
        return(hr);

    // Get the Root Directory
    cb = cchMaxDir;
    if (ERROR_SUCCESS != SHGetValue(hkey, c_szRegRoot, c_szRegStoreRootDir, &dwType, (LPBYTE)pszDir, &cb))
    {
        // Get Default Root
        IF_FAILEXIT(hr = MU_GetIdentityDirectoryRoot(pId, pszDir, cchMaxDir));

        // If the directory doesn't exist yet ?
        if (FALSE == PathIsDirectory(pszDir))
        {
            // Our default directory doesn't exist, so create it
            IF_FAILEXIT(hr = OpenDirectory(pszDir));
        }

        // Set the Store Directory
        dwType = AddEnvInPath(pszDir, szProfile) ? REG_EXPAND_SZ : REG_SZ;
        SHSetValue(hkey, c_szRegRoot, c_szRegStoreRootDir, dwType, pszDir, lstrlen(pszDir) + 1);
    }

    // Get the length
    cb = lstrlen(pszDir);

    // No root
    if (0 == cb)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Fixup the end
    PathRemoveBackslash(pszDir);
    
    // If the directory doesn't exist yet ?
    if (FALSE == PathIsDirectory(pszDir))
    {
        // Our default directory doesn't exist, so create it
        IF_FAILEXIT(hr = OpenDirectory(pszDir));
    }

exit:
    RegCloseKey(hkey);

    return hr;
}

HRESULT ImportSubNewsGroups(IUserIdentity *pId, IImnAccount *pAcct, LPCSTR pszGroups)
{
    HRESULT hr;
    FOLDERINFO Folder;
    IMessageStore *pStore;
    FOLDERID idServer;
    char szStoreDir[MAX_PATH + MAX_PATH];

    Assert(pszGroups != NULL);

    if (pId == NULL)
    {
        Assert(g_pLocalStore != NULL);
        pStore = g_pLocalStore;
        pStore->AddRef();
    }
    else
    {
        hr = GetIdentityStoreRootDirectory(pId, szStoreDir, ARRAYSIZE(szStoreDir));
        if (FAILED(hr))
            return(hr);

        hr = CoCreateInstance(CLSID_MessageStore, NULL, CLSCTX_INPROC_SERVER, IID_IMessageStore, (LPVOID *)&pStore);
        if (FAILED(hr))
            return(hr);

        hr = pStore->Initialize(szStoreDir);
        if (FAILED(hr))
        {
            pStore->Release();
            return(hr);
        }
    }

    hr = pStore->CreateServer(pAcct, NOFLAGS, &idServer);
    if (SUCCEEDED(hr))
    {
        while (*pszGroups != 0)
        {
            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.pszName = (LPSTR)pszGroups;
            Folder.idParent = idServer;

            if (DB_S_FOUND == pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                if ((Folder.dwFlags & FOLDER_SUBSCRIBED) == 0)
                {
                    Folder.dwFlags |= FOLDER_SUBSCRIBED;
                    
                    pStore->UpdateRecord(&Folder);
                }

                pStore->FreeRecord(&Folder);
            }
            else
            {
                Folder.tySpecial = FOLDER_NOTSPECIAL;
                Folder.dwFlags = FOLDER_SUBSCRIBED;

                hr = pStore->CreateFolder(NOFLAGS, &Folder, NULL);           
                Assert(hr != STORE_S_ALREADYEXISTS);

                if (FAILED(hr))
                    break;
            }

            pszGroups += (lstrlen(pszGroups) + 1);
        }
    }

    pStore->Release();

    return(hr);
}

HRESULT DoNewsgroupSubscribe()
{
    HKEY hkey, hkeyT, hkeyUser;
    char szKey[MAX_PATH];
    DWORD cAccts, iAcct, cb;
    LONG lResult, cch, i;
    LPSTR psz;
    BOOL fDelete;
    HRESULT hr;
    IImnAccount *pAcct;

    fDelete = TRUE;
    hkeyUser = MU_GetCurrentUserHKey();

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyUser, c_szRegRootSubscribe, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cAccts, NULL, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cAccts > 0)
        {
            for (iAcct = 0; iAcct < cAccts; iAcct++)
            {
                cb = sizeof(szKey);
                lResult = RegEnumKeyEx(hkey, iAcct, szKey, &cb, 0, NULL, NULL, NULL);
    
                // No more items
                if (lResult == ERROR_NO_MORE_ITEMS)
                    break;
    
                // Error, lets move onto the next account
                if (lResult != ERROR_SUCCESS)
                {
                    Assert(FALSE);
                    continue;
                }

                hr = S_OK;

                if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szKey, &pAcct)))
                {
                    if (ERROR_SUCCESS == RegQueryValue(hkey, szKey, NULL, &cch) && cch > 0)
                    {
                        hr = E_FAIL;

                        cch++;
                        if (MemAlloc((void **)&psz, cch))
                        {
                            if (ERROR_SUCCESS == RegQueryValue(hkey, szKey, psz, &cch))
                            {
                                for (i = 0; i < cch; i++)
                                {
                                    if (psz[i] == ',')
                                        psz[i] = 0;
                                }
                                psz[cch] = 0;

                                hr = ImportSubNewsGroups(NULL, pAcct, psz);
                            }

                            MemFree(psz);
                        }
                    }

                    pAcct->Release();
                }

                if (SUCCEEDED(hr))
                    RegDeleteKey(hkey, szKey);
                else
                    fDelete = FALSE;
            }
        }

        RegCloseKey(hkey);

        if (fDelete)
            RegDeleteKey(hkeyUser, c_szRegRootSubscribe);
    }

    return(S_OK);
}

void GetProtocolString(LPCSTR *ppszResult, IXPTYPE ixpServerType)
{
    switch (ixpServerType)
    {
        case IXP_POP3:
            *ppszResult = "POP3";
            break;

        case IXP_SMTP:
            *ppszResult = "SMTP";
            break;

        case IXP_NNTP:
            *ppszResult = "NNTP";
            break;

        case IXP_IMAP:
            *ppszResult = "IMAP";
            break;

        case IXP_HTTPMail:
            *ppszResult = "HTTPMail";
            break;

        default:
            *ppszResult = "Unknown";
            break;
    }
}

INT_PTR CALLBACK UpdateNewsgroup(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char sz[CCHMAX_STRINGRES];
    BOOL fEnabled;
    HICON hicon;
    static PUPDATENEWSGROUPINFO puni = 0;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Get the init info
            puni = (PUPDATENEWSGROUPINFO) lParam;
            Assert(puni);             
        
            if (!puni->fNews)
            {
                AthLoadString(idsSyncFolderTitle, sz, ARRAYSIZE(sz));
                SetWindowText(hwnd, sz);

                hicon = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiDLMail));
                SendDlgItemMessage(hwnd, idcStatic1, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hicon);
            }

            // Initialize the dialog settings
            fEnabled = (puni->dwGroupFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL));
            Button_SetCheck(GetDlgItem(hwnd, IDC_GET_CHECK), fEnabled);
        
            Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
            Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
            Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);
        
            // Check the right radio button
            if (fEnabled)
            {
                if (puni->dwGroupFlags & FOLDER_DOWNLOADHEADERS)
                    Button_SetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), TRUE);
                if (puni->dwGroupFlags & FOLDER_DOWNLOADNEW)
                    Button_SetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), TRUE);
                if (puni->dwGroupFlags & FOLDER_DOWNLOADALL)
                    Button_SetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), TRUE);
            }
            else if (puni->fNews)
            {
                Button_SetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), TRUE);
            }
            else
            {
                Button_SetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), TRUE);
            }

            Button_SetCheck(GetDlgItem(hwnd, IDC_GETMARKED_CHECK), puni->cMarked != 0);
            EnableWindow(GetDlgItem(hwnd, IDC_GETMARKED_CHECK), puni->cMarked != 0);

            EnableWindow(GetDlgItem(hwnd, IDOK), fEnabled || puni->cMarked != 0);
            return (TRUE);
        
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_GET_CHECK:
                    // Check to see whether this is actually checked or not
                    fEnabled = Button_GetCheck(GET_WM_COMMAND_HWND(wParam, lParam));
            
                    // Enable or disable the radio buttons
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);
            
                    EnableWindow(GetDlgItem(hwnd, IDOK), fEnabled || Button_GetCheck(GetDlgItem(hwnd, IDC_GETMARKED_CHECK)));
                    return (TRUE);
            
                case IDC_GETMARKED_CHECK:
                    EnableWindow(GetDlgItem(hwnd, IDOK), Button_GetCheck(GET_WM_COMMAND_HWND(wParam, lParam)) || Button_GetCheck(GetDlgItem(hwnd, IDC_GET_CHECK)));
                    return(TRUE);

                case IDOK:
                    // Set up the return value
                    if (Button_GetCheck(GetDlgItem(hwnd, IDC_GET_CHECK)))
                    {
                        if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO)))
                            puni->idCmd |= DELIVER_OFFLINE_HEADERS;
                        else if (Button_GetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO)))
                            puni->idCmd |= DELIVER_OFFLINE_ALL;
                        else if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO)))
                            puni->idCmd |= DELIVER_OFFLINE_NEW;
                    }
            
                    if (Button_GetCheck(GetDlgItem(hwnd, IDC_GETMARKED_CHECK)))
                    {
                        puni->idCmd |= DELIVER_OFFLINE_MARKED;
                    }
            
                    EndDialog(hwnd, 0);
                    return (TRUE);
            
                case IDCANCEL:
                    puni->idCmd = -1;
                    EndDialog(hwnd, 0);
                    return (TRUE);
            }
            return (FALSE);
    }
    
    return (FALSE);
}

HRESULT HasMarkedMsgs(FOLDERID idFolder, BOOL *pfMarked)
{
    HRESULT hr;
    HROWSET hRowset;
    MESSAGEINFO MsgInfo;
    IMessageFolder *pFolder;

    Assert(pfMarked != NULL);

    *pfMarked = FALSE;

    hr = g_pStore->OpenFolder(idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder);
    if (FAILED(hr))
        return(hr);

    hr = pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (SUCCEEDED(hr))
    {
	    while (S_OK == pFolder->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
        {
            if (!!(MsgInfo.dwFlags & (ARF_DOWNLOAD | ARF_WATCH)) && 0 == (MsgInfo.dwFlags & ARF_HASBODY))
            {
                pFolder->FreeRecord(&MsgInfo);
    
                *pfMarked = TRUE;
                break;
            }

            // Free the header info
            pFolder->FreeRecord(&MsgInfo);
        }

        // Release Lock
        pFolder->CloseRowset(&hRowset);
    }
    
    pFolder->Release();

    return (hr);
}

HRESULT SimpleInitStoreForDir(LPCSTR szStoreDir)
{
    CStoreSync *pStore;
    HRESULT hr = S_OK;

    if (g_pStore == NULL)
    {
        Assert(g_pLocalStore == NULL);

        g_pLocalStore = new CMessageStore(FALSE);
        if (g_pLocalStore == NULL)
            return(E_OUTOFMEMORY);

        hr = g_pLocalStore->Initialize(szStoreDir);
        if (SUCCEEDED(hr))
        {
            pStore = new CStoreSync;
            if (pStore == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = pStore->Initialize(g_pLocalStore);
                if (SUCCEEDED(hr))
                {
                    g_pStore = pStore;
                    hr = g_pLocalStore->Validate(STORE_VALIDATE_DONTSYNCWITHACCOUNTS);
                }
                else
                {
                    pStore->Release();
                }
            }
        }
    }

    return(hr);
}

HRESULT SimpleStoreInit(GUID *guid, LPCSTR szStoreDir)
{
    HRESULT hr = S_OK;

    // Init options
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        goto exit;
    }

    // Create account manger
    if (NULL == g_pAcctMan)
    {
        hr = AcctUtil_CreateAccountManagerForIdentity(guid ? guid : PGUIDCurrentOrDefault(), &g_pAcctMan);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    // Create the global connection manager
    if (NULL == g_pConMan)
    {
        g_pConMan = new CConnectionManager();
        if (NULL == g_pConMan)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        // CoIncrementInit the Connection Manager
        hr = g_pConMan->HrInit(g_pAcctMan);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    hr = SimpleInitStoreForDir(szStoreDir);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    return hr;
}

HRESULT SimpleStoreRelease()
{
    HRESULT hr = S_OK;

    SafeRelease(g_pLocalStore);
    SafeRelease(g_pStore);

    SafeRelease(g_pConMan);
    SafeRelease(g_pAcctMan);
    DeInitGlobalOptions();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\store\sync.cpp ===
#include "pch.hxx"
#include "store.h"
#include "instance.h"
#include "storutil.h"
#include <conman.h>
#include <syncop.h>
#include <shared.h>
#include "enumsync.h"
#include "playback.h"
#include "sync.h"

COfflineSync *g_pSync = NULL;

//--------------------------------------------------------------------------
// COfflineSync::COfflineSync
//--------------------------------------------------------------------------
COfflineSync::COfflineSync(void)
{
    m_cRef = 1;
    m_pDB = NULL;
}

//--------------------------------------------------------------------------
// CFolderSync::~CFolderSync
//--------------------------------------------------------------------------
COfflineSync::~COfflineSync(void)
{
    if (m_pDB != NULL)
        m_pDB->Release();
}

//--------------------------------------------------------------------------
// CFolderSync::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP COfflineSync::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

//--------------------------------------------------------------------------
// COfflineSync::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COfflineSync::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COfflineSync::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COfflineSync::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

HRESULT COfflineSync::_SetMessageFlags(IMessageFolder *pFolder, FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage, MESSAGEFLAGS dwFlags, LPADJUSTFLAGS pFlags)
{
    MESSAGEFLAGS dwAdd, dwRemove;
    SYNCOPINFO info;
    MESSAGEIDLIST list;
    HRESULT hr;

    Assert(pFolder != NULL);
    Assert(pFlags != NULL);
    Assert(0 != pFlags->dwAdd || 0 != pFlags->dwRemove);

    // if no new flags are being added or only unset flags are being removed,
    // we don't need to do anything
    if ((dwFlags | pFlags->dwAdd) == dwFlags &&
        (dwFlags & pFlags->dwRemove) == 0)
        return(S_OK);

    hr = _FindExistingOperation(idServer, idFolder, idMessage,
            SYNC_CREATE_MSG | SYNC_SETPROP_MSG, SYNC_COPY_MSG | SYNC_MOVE_MSG, &info);
    if (FAILED(hr))
        return(hr);

    if (hr == S_OK)
    {
        if (info.tyOperation == SYNC_CREATE_MSG)
        {
            // this message has been created offline and will be uploaded to the
            // server, so we can just set the flags in the message and they will
            // get uploaded with the message
        }
        else
        {
            dwAdd = pFlags->dwAdd;
            dwRemove = pFlags->dwRemove;

            dwFlags = info.dwAdd & dwRemove;
            if (dwFlags != 0)
            {
                FLAGCLEAR(info.dwAdd, dwFlags);
                FLAGCLEAR(dwRemove, dwFlags);
            }

            dwFlags = info.dwRemove & dwAdd;
            if (dwFlags != 0)
            {
                FLAGCLEAR(info.dwRemove, dwFlags);
                FLAGCLEAR(dwAdd, dwFlags);
            }

            FLAGSET(info.dwAdd, dwAdd);
            FLAGSET(info.dwRemove, dwRemove);

            if (info.dwAdd == 0 && info.dwRemove == 0 && info.tyOperation == SYNC_SETPROP_MSG)
            {
                // no flags are being changed so we can get rid of this operation
                hr = m_pDB->DeleteRecord(&info);
            }
            else
            {
                hr = m_pDB->UpdateRecord(&info);
            }
        }

        m_pDB->FreeRecord(&info);

        if (FAILED(hr))
            return(hr);
    }
    else
    {
        // no create or set prop operations exist for this message yet,
        // so create a new one

        ZeroMemory(&info, sizeof(SYNCOPINFO));
        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
        if (FAILED(hr))
            return(hr);
        info.idServer = idServer;
        info.idFolder = idFolder;
        info.idMessage = idMessage;
        info.tyOperation = SYNC_SETPROP_MSG;
        // info.dwFlags
        info.dwAdd = (~dwFlags & pFlags->dwAdd);
        info.dwRemove = (dwFlags & pFlags->dwRemove);

        hr = m_pDB->InsertRecord(&info);
        if (FAILED(hr))
            return(hr);
    }

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &idMessage;
    hr = pFolder->SetMessageFlags(&list, pFlags, NULL, NULL);

    return(hr);
}

HRESULT COfflineSync::SetMessageFlags(IMessageFolder *pFolder, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags)
{
    DWORD i;
    FOLDERID idFolder, idServer;
    MESSAGEINFO Message;
    HRESULT hr;
    HROWSET hRowset = NULL;

    Assert(pFolder != NULL);
    Assert(pFlags != NULL);
    Assert(0 != pFlags->dwAdd || 0 != pFlags->dwRemove);

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServerId(idFolder, &idServer);
    if (FAILED(hr))
        return(hr);

    if (NULL == pList)
    {
        hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            Message.idMessage = pList->prgidMsg[i];

            hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
            if (FAILED(hr))
                break;
            else if (hr != DB_S_FOUND)
                continue;
        }
        else
        {
            hr = pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        hr = _SetMessageFlags(pFolder, idServer, idFolder, Message.idMessage, Message.dwFlags, pFlags);

        pFolder->FreeRecord(&Message);

        if (FAILED(hr))
            break;
    }

    if (hRowset != NULL)
        pFolder->CloseRowset(&hRowset);

    return(hr);
}

HRESULT COfflineSync::DeleteMessages(IMessageFolder *pFolder, DELETEMESSAGEFLAGS dwFlags, LPMESSAGEIDLIST pList)
{
    DWORD i;
    ADJUSTFLAGS afFlags;
    BOOL fNoOp, fImap;
    FOLDERINFO Server;
    FOLDERID idFolder, idServer;
    MESSAGEID idMessage;
    SYNCOPINFO info;
    MESSAGEIDLIST list;
    MESSAGEINFO Message;
    HRESULT hr;
    HROWSET hRowset = NULL;

    // TODO: what about trashcan deletes????

    Assert(pFolder != NULL);

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServer(idFolder, &Server);
    if (FAILED(hr))
        return(hr);

    idServer = Server.idFolder;
    fImap = (Server.tyFolder == FOLDER_IMAP);

    g_pStore->FreeRecord(&Server);

    if (fImap)
    {
        if (!!(dwFlags & DELETE_MESSAGE_UNDELETE))
        {
            afFlags.dwAdd = 0;
            afFlags.dwRemove = ARF_ENDANGERED;
        }
        else
        {
            afFlags.dwAdd = ARF_ENDANGERED;
            afFlags.dwRemove = 0;
        }

        return(SetMessageFlags(pFolder, pList, &afFlags));
    }

    Assert(0 == (dwFlags & DELETE_MESSAGE_UNDELETE));

    if (NULL == pList)
    {
        hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    list.cAllocated = 0;
    list.cMsgs = 1;
    list.prgidMsg = &idMessage;

    afFlags.dwAdd = ARF_DELETED_OFFLINE;
    afFlags.dwRemove = 0;

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            idMessage = pList->prgidMsg[i];
        }
        else
        {
            hr = pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }

            idMessage = Message.idMessage;

            pFolder->FreeRecord(&Message);
        }

        hr = _FindExistingOperation(idServer, idFolder, idMessage,
                SYNC_CREATE_MSG | SYNC_SETPROP_MSG, SYNC_COPY_MSG | SYNC_MOVE_MSG, &info);
        if (FAILED(hr))
            break;

        if (hr == S_OK)
        {
            fNoOp = TRUE;

            if (info.tyOperation == SYNC_CREATE_MSG || info.tyOperation == SYNC_COPY_MSG)
            {
                // we don't need to do this create or copy anymore because the message is being
                // deleted. we don't need to do the delete either because the message
                // has never existed on the server

                hr = m_pDB->DeleteRecord(&info);
            }
            else if (info.tyOperation == SYNC_SETPROP_MSG)
            {
                // if it is a set prop operation, we don't need to do it anymore because the message
                // is just getting deleted anyway

                fNoOp = FALSE;

                hr = m_pDB->DeleteRecord(&info);
            }
            else
            {
                Assert(info.tyOperation == SYNC_MOVE_MSG);

                // convert it to a delete operation which is the same as moving it then deleting it

                info.idFolderDest = 0;
                info.idMessageDest = 0;
                info.tyOperation = SYNC_DELETE_MSG;
                info.dwAdd = 0;
                info.dwRemove = 0;
                info.dwFlags = dwFlags;

                hr = m_pDB->UpdateRecord(&info);
            }

            m_pDB->FreeRecord(&info);

            if (FAILED(hr))
            {
                break;
            }
            else if (fNoOp)
            {
                hr = pFolder->DeleteMessages(dwFlags, &list, NULL, NULL);
                if (FAILED(hr))
                    break;

                continue;
            }
        }

        // create the delete operation

        ZeroMemory(&info, sizeof(SYNCOPINFO));
        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
        if (FAILED(hr))
            break;
        info.idServer = idServer;
        info.idFolder = idFolder;
        info.idMessage = idMessage;
        info.tyOperation = SYNC_DELETE_MSG;
        info.dwFlags = dwFlags;
        // info.dwAdd
        // info.dwRemove

        hr = m_pDB->InsertRecord(&info);
        if (FAILED(hr))
            break;

        hr = pFolder->SetMessageFlags(&list, &afFlags, NULL, NULL);
        if (FAILED(hr))
            break;
    }

    if (hRowset != NULL)
        m_pDB->CloseRowset(&hRowset);

    return(hr);
}

HRESULT COfflineSync::CreateMessage(IMessageFolder *pFolder, 
									LPMESSAGEID pidMessage, 
									SAVEMESSAGEFLAGS dwOptions, 
									MESSAGEFLAGS dwFlags,
									IStream *pStream,
									IMimeMessage *pMessage)
{
    MESSAGEID idMessage;
    HRESULT hr;
    SYNCOPINFO info;
    FOLDERID idFolder, idServer;

    Assert(pFolder != NULL);
    Assert(pMessage != NULL);
    Assert(!!(dwOptions & SAVE_MESSAGE_GENID));

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServerId(idFolder, &idServer);
    if (FAILED(hr))
        return(hr);

    ZeroMemory(&info, sizeof(SYNCOPINFO));
    hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
    if (FAILED(hr))
        return(hr);

    hr = pFolder->SaveMessage(&idMessage, SAVE_MESSAGE_GENID, dwFlags, pStream, pMessage, NULL);
    if (FAILED(hr))
        return(hr);

    info.idServer = idServer;
    info.idFolder = idFolder;
    info.idMessage = idMessage;
    info.tyOperation = SYNC_CREATE_MSG;
    info.dwFlags = dwOptions;
    // info.dwAdd
    // info.dwRemove

    hr = m_pDB->InsertRecord(&info);

    return(hr);
}

HRESULT COfflineSync::CopyMessages(IMessageFolder *pFolder, IMessageFolder *pFolderDest, COPYMESSAGEFLAGS dwCopyFlags, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags)
{
    DWORD i;
    BOOL fMove, fImap, fCopyToMove;
    FOLDERINFO Server;
    MESSAGEFLAGS dwFlags;
    ADJUSTFLAGS afFlags;
    FOLDERID idFolder, idServer, idFolderDest;
    MESSAGEID idMessage;
    SYNCOPINFO info, infoT;
    MESSAGEIDLIST list;
    HRESULT hr;
    IMimeMessage *pMsg;
    HROWSET hRowset = NULL;
    MESSAGEINFO Message = { 0 };

    Assert(pFolder != NULL);
    Assert(pFolderDest != NULL);

    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
        return(hr);

    hr = pFolderDest->GetFolderId(&idFolderDest);
    if (FAILED(hr))
        return(hr);

    hr = GetFolderServer(idFolder, &Server);
    if (FAILED(hr))
        return(hr);

    idServer = Server.idFolder;
    fImap = (Server.tyFolder == FOLDER_IMAP);

    g_pStore->FreeRecord(&Server);

#ifdef DEBUG
    FOLDERID idServerDest;

    Assert(SUCCEEDED(GetFolderServerId(idFolderDest, &idServerDest)));
    Assert(SUCCEEDED(hr));
    Assert(idServer == idServerDest);
#endif // DEBUG

    if (NULL == pList)
    {
        hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    fMove = !!(dwCopyFlags & COPY_MESSAGE_MOVE);

    if (fMove)
    {
        list.cAllocated = 0;
        list.cMsgs = 1;
        list.prgidMsg = &idMessage;

        if (fImap)
        {
            afFlags.dwAdd = ARF_ENDANGERED;
            afFlags.dwRemove = 0;
        }
        else
        {
            afFlags.dwAdd = ARF_DELETED_OFFLINE;
            afFlags.dwRemove = 0;
        }
    }

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            Message.idMessage = pList->prgidMsg[i];

            hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
            if (FAILED(hr))
                break;
            else if (hr != DB_S_FOUND)
                continue;
        }
        else
        {
            hr = pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        idMessage = Message.idMessage;
        dwFlags = Message.dwFlags;

        if (pFlags != NULL)
        {
            if (pFlags->dwRemove != 0)
                Message.dwFlags &= ~pFlags->dwRemove;
            if (pFlags->dwAdd != 0)
                Message.dwFlags |= pFlags->dwAdd;
        }

        pMsg = NULL;
        hr = pFolder->OpenMessage(idMessage, NOFLAGS, &pMsg, NULL);
        if (hr == STORE_E_NOBODY)
        {
            // just create the header in the destination folder
            Assert(pMsg == NULL);

            hr = pFolderDest->GenerateId((LPDWORD)&Message.idMessage);
            if (SUCCEEDED(hr))
                hr = pFolderDest->InsertRecord(&Message);
        }
        else if (SUCCEEDED(hr))
        {
            // create the whole message in the destination folder
            Assert(pMsg != NULL);

            hr = pFolderDest->SaveMessage(&Message.idMessage, SAVE_MESSAGE_GENID, Message.dwFlags, 0, pMsg, NULL);

            pMsg->Release();
        }
        else
        {
            Assert(pMsg == NULL);
        }
        if (FAILED(hr))
            break;

        hr = _FindExistingOperation(idServer, idFolder, idMessage,
                SYNC_CREATE_MSG, SYNC_COPY_MSG | SYNC_MOVE_MSG, &info);
        if (FAILED(hr))
            break;

        if (hr == S_OK)
        {
            if (fMove)
            {
                // delete source msg because we're moving a msg which doesn't exist on the server
                // and then move the previous operation to the destination folder

                hr = pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &list, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    if (info.tyOperation == SYNC_CREATE_MSG)
                    {
                        info.idFolder = idFolderDest;
                        info.idMessage = Message.idMessage;
                    }
                    else
                    {
                        info.idFolderDest = idFolderDest;
                        info.idMessageDest = Message.idMessage;
                    }

                    hr = m_pDB->UpdateRecord(&info);

                    // foo
                }
            }
            else
            {
                if (info.tyOperation == SYNC_CREATE_MSG)
                {
                    // we can't copy this message because it doesn't exist on the server,
                    // so we'll add another create operation for the destination message

                    ZeroMemory(&infoT, sizeof(SYNCOPINFO));
                    hr = m_pDB->GenerateId((LPDWORD)&infoT.idOperation);
                    if (SUCCEEDED(hr))
                    {
                        infoT.idServer = idServer;
                        infoT.idFolder = idFolderDest;
                        infoT.idMessage = Message.idMessage;
                        infoT.tyOperation = SYNC_CREATE_MSG;
                        // infoT.dwFlags
                        // info.dwAdd
                        // info.dwRemove

                        hr = m_pDB->InsertRecord(&infoT);
                    }
                }
                else if (info.tyOperation == SYNC_COPY_MSG)
                {
                    fCopyToMove = FALSE;

                    // if there is an earlier operation that will result in the source msg
                    // being deleted, then we'll find that and remove it (delete) or change
                    // it (move), and then we'll do a move instead of a copy

                    hr = _FindExistingOperation(info.idServer, info.idFolder, info.idMessage,
                            SYNC_DELETE_MSG | SYNC_MOVE_MSG, 0, &infoT);
                    if (hr == S_OK)
                    {
                        if (infoT.tyOperation == SYNC_DELETE_MSG)
                        {
                            hr = m_pDB->DeleteRecord(&infoT);
                        }
                        else
                        {
                            Assert(infoT.tyOperation == SYNC_MOVE_MSG);

                            infoT.tyOperation = SYNC_COPY_MSG;

                            hr = m_pDB->UpdateRecord(&infoT);
                        }

                        fCopyToMove = TRUE;

                        m_pDB->FreeRecord(&infoT);
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
                        if (SUCCEEDED(hr))
                        {
                            info.idFolderDest = idFolderDest;
                            info.idMessageDest = Message.idMessage;
                            if (fCopyToMove)
                                info.tyOperation = SYNC_MOVE_MSG;

                            hr = m_pDB->InsertRecord(&info);
                        }
                    }
                }
                else
                {
                    Assert(info.tyOperation == SYNC_MOVE_MSG);

                    // instead of doing a move then a copy which wouldn't work so good,
                    // we'll have the current copy become a move and the earlier move will become a copy

                    infoT = info;
                    hr = m_pDB->GenerateId((LPDWORD)&infoT.idOperation);
                    if (SUCCEEDED(hr))
                    {
                        infoT.idFolderDest = idFolderDest;
                        infoT.idMessageDest = Message.idMessage;

                        hr = m_pDB->InsertRecord(&infoT);
                        if (SUCCEEDED(hr))
                        {
                            info.tyOperation = SYNC_COPY_MSG;

                            hr = m_pDB->UpdateRecord(&info);
                        }
                    }
                }
            }

            m_pDB->FreeRecord(&info);

            if (FAILED(hr))
            {
                break;
            }
            else
            {
                pFolder->FreeRecord(&Message);
                continue;
            }
        }

        ZeroMemory(&info, sizeof(SYNCOPINFO));
        hr = m_pDB->GenerateId((LPDWORD)&info.idOperation);
        if (FAILED(hr))
            break;
        info.idServer = idServer;
        info.idFolder = idFolder;
        info.idMessage = idMessage;
        info.tyOperation = (fMove && !fImap) ? SYNC_MOVE_MSG : SYNC_COPY_MSG;
        // info.dwFlags
        if (pFlags != NULL)
        {
            info.dwAdd = (~dwFlags & pFlags->dwAdd);
            info.dwRemove = (dwFlags & pFlags->dwRemove);
        }
        info.idFolderDest = idFolderDest;
        info.idMessageDest = Message.idMessage;

        hr = m_pDB->InsertRecord(&info);
        // TODO: if this fails, we should probably blow away the new msg we just created...
        if (FAILED(hr))
            break;

        if (fMove)
        {
            if (fImap)
            {
                // put this msg in the endangered species list
                hr = _SetMessageFlags(pFolder, idServer, idFolder, idMessage, dwFlags, &afFlags);
                if (FAILED(hr))
                    break;
            }
            else
            {
                // hide this msg because it is now deleted
                pFolder->SetMessageFlags(&list, &afFlags, NULL, NULL);
            }
        }

        pFolder->FreeRecord(&Message);
    }

    pFolder->FreeRecord(&Message);

    if (hRowset != NULL)
        pFolder->CloseRowset(&hRowset);

    return(hr);
}

HRESULT COfflineSync::Initialize()
{
    HRESULT         hr;
    BOOL            fReset;
    TABLEINDEX      Index;
    CHAR            szDirectory[MAX_PATH];
    CHAR            szFilePath[MAX_PATH];
    SYNCOPUSERDATA  UserData={0};

    Assert(g_pStore != NULL);

    hr = g_pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory));
    if (FAILED(hr))
        return(hr);

    hr = MakeFilePath(szDirectory, c_szOfflineFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath));
    if (FAILED(hr))
        return(hr);

    hr = g_pDBSession->OpenDatabase(szFilePath, NOFLAGS, &g_SyncOpTableSchema, NULL, &m_pDB);
    if (FAILED(hr))
        return(hr);

    fReset = FALSE;

    // Create the idServer / idFolder Index
    if (FAILED(m_pDB->GetIndexInfo(IINDEX_ALL, NULL, &Index)))
        fReset = TRUE;

    // If still noreset, see of indexes are the same
    else if (S_FALSE == CompareTableIndexes(&Index, &g_OpFolderIdIndex))
        fReset = TRUE;

    // Change the Index
    if (fReset)
    {
        // Create the idParent / FolderName Index
        hr = m_pDB->ModifyIndex(IINDEX_ALL, NULL, &g_OpFolderIdIndex);
        if (FAILED(hr))
            return(hr);
    }

    hr = m_pDB->GetUserData(&UserData, sizeof(SYNCOPUSERDATA));
    if (SUCCEEDED(hr))
    {
        if (!UserData.fInitialized)
        {
            UserData.fInitialized = TRUE;

            hr = m_pDB->SetUserData(&UserData, sizeof(SYNCOPUSERDATA));
        }
    }

    return(hr);
}

HRESULT COfflineSync::DoPlayback(HWND hwnd, FOLDERID *pId, DWORD cId, FOLDERID idFolderSel)
{
    HRESULT hr;
    DWORD cOps;
    COfflinePlayback *pPlayback;

    Assert(pId != NULL);
    Assert(cId > 0);

    hr = m_pDB->GetRecordCount(IINDEX_PRIMARY, &cOps);
    if (SUCCEEDED(hr) && cOps > 0)
    {
        pPlayback = new COfflinePlayback;
        if (pPlayback == NULL)
            return(E_OUTOFMEMORY);

        hr = pPlayback->DoPlayback(hwnd, m_pDB, pId, cId, idFolderSel);

        pPlayback->Release();
    }

    return(hr);
}

HRESULT COfflineSync::_FindExistingOperation(FOLDERID idServer, FOLDERID idFolder, MESSAGEID idMessage,
                                             DWORD dwFlagsSrc, DWORD dwFlagsDest, LPSYNCOPINFO pInfo)
{
    ROWORDINAL iRow;
    HRESULT hr;
    HROWSET hRowset = NULL;

    Assert(pInfo != NULL);
    Assert(dwFlagsSrc != 0 || dwFlagsDest != 0);

    ZeroMemory(pInfo, sizeof(SYNCOPINFO));
    pInfo->idServer = idServer;
    hr = m_pDB->FindRecord(IINDEX_ALL, 1, pInfo, &iRow);
    if (hr != DB_S_FOUND)
        return(S_FALSE);
    m_pDB->FreeRecord(pInfo);

    hr = m_pDB->CreateRowset(IINDEX_ALL, NOFLAGS, &hRowset);
    if (FAILED(hr))
        return(hr);

    hr = m_pDB->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iRow - 1, NULL);
    if (SUCCEEDED(hr))
    {
        while (TRUE)
        {
            hr = m_pDB->QueryRowset(hRowset, 1, (LPVOID *)pInfo, NULL);
            if (S_FALSE == hr)
            {
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }

            if (pInfo->idServer != idServer)
            {
                hr = S_FALSE;
                m_pDB->FreeRecord(pInfo);
                break;
            }

            if (dwFlagsSrc != 0)
            {
                if (pInfo->idFolder == idFolder && pInfo->idMessage == idMessage)
                {
                    if (!!(dwFlagsSrc & pInfo->tyOperation))
                        break;
                }
            }

            if (dwFlagsDest != 0)
            {
                if (pInfo->idFolderDest == idFolder && pInfo->idMessageDest == idMessage)
                {
                    if (!!(dwFlagsDest & pInfo->tyOperation))
                        break;
                }
            }

            m_pDB->FreeRecord(pInfo);
        }
    }

    m_pDB->CloseRowset(&hRowset);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\exchrep\exchrep.h ===
// =====================================================================================
// Exchange Rep Header
// =====================================================================================
#ifndef __EXCHREP_H
#define __EXCHREP_H

// =====================================================================================
// Required Headers
// =====================================================================================
#include "MAPI.H"
#include "MAPIX.H"
#include "MAPIUTIL.H"
#include "MAPIFORM.H"
#include "EXCHEXT.H"
#include "ASSERT.H"

// =====================================================================================
// Globals
// =====================================================================================
extern HINSTANCE g_hInst;

// =====================================================================================
// IMNAPI typedefs
// =====================================================================================
typedef HRESULT (STDAPICALLTYPE *PFNHRIMNROUTEMESSAGE)(LPIADDRINFO lpIaddrRoute, ULONG cAddrRoute, LPIMSG lpImsg);
typedef HRESULT (STDAPICALLTYPE *PFNMAILNEWSDLLINIT)(BOOL fInit);

// =====================================================================================
// C Interface Call Back from Exchange
// =====================================================================================
extern "C"
{
    LPEXCHEXT CALLBACK ExchEntryPoint(void);
}

// =====================================================================================
// Main Extension Interface Class
// =====================================================================================
class CExchRep : public IExchExt, IExchExtSessionEvents
{
private:
	ULONG				 m_uRef;
    LPMAPISESSION        m_lpSession;
    HWND                 m_hwnd;
    TCHAR                m_szDisplayTo[255];
    TCHAR                m_szAddressTo[255];
    TCHAR                m_szMailNewsPath[MAX_PATH];
    HINSTANCE            m_hMailNews;
    PFNHRIMNROUTEMESSAGE m_lpfnHrImnRouteMessage;
    PFNMAILNEWSDLLINIT   m_lpfnMailNewsDllInit;
    
public:
	// =====================================================================================
	// Construct
	// =====================================================================================
	CExchRep ();
	~CExchRep ();

	// =====================================================================================
	// punk stuff
	// =====================================================================================
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	// =====================================================================================
	// IExchExt
	// =====================================================================================
	STDMETHODIMP Install (LPEXCHEXTCALLBACK lpExchCallback, ULONG mecontext, ULONG ulFlags);

	// =====================================================================================
	// IExchExtSessionEvents
	// =====================================================================================
    STDMETHODIMP OnDelivery (LPEXCHEXTCALLBACK lpExchCallback);	

	// =====================================================================================
	// My Functions
	// =====================================================================================
    VOID LoadConfig (VOID);
};

#endif __EXCHREP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\exchrep\exchrep.cpp ===
// =====================================================================================
// Exchange Plus ! Main
// =====================================================================================
#include "pch.hxx"
#include "Imnapi.h"
#include "Exchrep.h"
#include "mapiconv.h"

// =====================================================================================
// Defines
// =====================================================================================
#define REGPATH             "Software\\Microsoft\\Exchange Internet Mail Router"
#define MAILNEWS_PATH       "MailNews Path"
#define ROUTE_TO_DISPLAY    "Route To Display"
#define ROUTE_TO_ADDRESS    "Route To Address"

#define ROUTER_DISPLAY      "Microsoft Exchange Internet Mail Router"
#define ROUTER_ADDRESS      "exchrep"

// =====================================================================================
// Globals
// =====================================================================================
HINSTANCE   g_hInst;

// =====================================================================================
// Prototypes
// =====================================================================================
VOID FreeImsg (LPIMSG lpImsg);

// =====================================================================================
// Dll entry point
// =====================================================================================
int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
    case DLL_PROCESS_ATTACH:
	    g_hInst = hInstance;
	    return 1;

	case DLL_PROCESS_DETACH:
        return 1;
   }

	// Not Handled
	return 0;
}

// =====================================================================================
// Exchange Interface entry point
// =====================================================================================
LPEXCHEXT CALLBACK ExchEntryPoint(void)
{
	// Create and return Exchange Interface Object
	return (IExchExt *)new CExchRep;
}

// =====================================================================================
// Inst my exchange interface object
// =====================================================================================
CExchRep::CExchRep () 
{ 
    m_uRef = 1; 
    m_lpSession = NULL;
    m_hwnd = NULL;
    m_hMailNews = NULL;
    m_lpfnHrImnRouteMessage = NULL;
    m_lpfnMailNewsDllInit = NULL;
}

// =====================================================================================
// Inst my exchange interface object
// =====================================================================================
CExchRep::~CExchRep () 
{ 
    if (m_lpSession)
        m_lpSession->Release ();
    if (m_hMailNews)
    {
        if (m_lpfnMailNewsDllInit)
            (*m_lpfnMailNewsDllInit)(FALSE);
        FreeLibrary (m_hMailNews);
    }
}

// =====================================================================================
// Add Ref
// =====================================================================================
STDMETHODIMP_(ULONG) CExchRep::AddRef () 
{												  	
	++m_uRef; 								  
	return m_uRef; 						  
}

// =====================================================================================
// Release 
// =====================================================================================
STDMETHODIMP_(ULONG) CExchRep::Release () 
{ 
    ULONG uCount = --m_uRef;
    if (!uCount) 
        delete this; 
   return uCount;
}

// =====================================================================================
// IExchExt - tells exchange what interfaces I am supporting
// =====================================================================================
STDMETHODIMP CExchRep::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	// Locals
    HRESULT hr = S_OK;

    *ppvObj = NULL;

    // IUnknown or IExchExt interface, this is it dude
    if ((IID_IUnknown == riid) || (IID_IExchExt == riid))
    {
		*ppvObj = (LPUNKNOWN)(IExchExt *)this;
    }
   
	// IExchExtCommands interface ?
	else if (IID_IExchExtSessionEvents == riid) 
	{
		*ppvObj = (LPUNKNOWN)(IExchExtSessionEvents *)this;
    }
 
	// Else, interface is not supported
	else hr = E_NOINTERFACE;

    // Increment Reference Count
	if (NULL != *ppvObj) ((LPUNKNOWN)*ppvObj)->AddRef();

	// Done
    return hr;
}

// =====================================================================================
// Install is called
// =====================================================================================
STDMETHODIMP CExchRep::Install (LPEXCHEXTCALLBACK lpExchCallback, ULONG mecontext, ULONG ulFlags)
{
    // Locals
    HRESULT			    hr = S_OK;

    // Only in session context
    if (mecontext != EECONTEXT_SESSION)
        return S_OK;

    // Get Window Handle
    lpExchCallback->GetWindow (&m_hwnd);

    // Get Session Object
    hr = lpExchCallback->GetSession (&m_lpSession, NULL);
    if (FAILED (hr) || !m_lpSession)
    {
        MessageBox (m_hwnd, "IExchExtCallback::GetSession Failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Load Config
    LoadConfig ();

exit:
    // Done
    return S_OK;
}

// =====================================================================================
// LoadConfig
// =====================================================================================
VOID CExchRep::LoadConfig (VOID)
{
    // Locals
    HKEY                hReg = NULL;
    ULONG               cbRegData;
    DWORD               dwType;

    // Open the Reg Key
    if (RegOpenKeyEx (HKEY_CURRENT_USER, REGPATH, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
    {
        MessageBox (m_hwnd, "Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Display To
    cbRegData = sizeof (m_szDisplayTo);
    dwType = REG_SZ;
    if (RegQueryValueEx (hReg, ROUTE_TO_DISPLAY, 0, &dwType, (LPBYTE)m_szDisplayTo, &cbRegData) != ERROR_SUCCESS)
    {
        MessageBox (m_hwnd, "Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Address To
    cbRegData = sizeof (m_szAddressTo);
    dwType = REG_SZ;
    if (RegQueryValueEx (hReg, ROUTE_TO_ADDRESS, 0, &dwType, (LPBYTE)m_szAddressTo, &cbRegData) != ERROR_SUCCESS)
    {
        MessageBox (m_hwnd, "Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Get mail news dll path
    cbRegData = sizeof (m_szMailNewsPath);
    dwType = REG_SZ;
    if (RegQueryValueEx (hReg, MAILNEWS_PATH, 0, &dwType, (LPBYTE)m_szMailNewsPath, &cbRegData) == ERROR_SUCCESS)
    {
        // Lets Load mailnews.dll
        m_hMailNews = LoadLibrary ("c:\\thor\\build\\debug\\mailnews.dll");
        if (m_hMailNews == NULL)
        {
            MessageBox (m_hwnd, "Unable to load mailnews.dll. Exchange Internet Mail Router is not configured.", "ExchRep", MB_OK | MB_SETFOREGROUND);
            goto exit;
        }

        // Fixup Procedure addresses
        m_lpfnHrImnRouteMessage = (PFNHRIMNROUTEMESSAGE)GetProcAddress (m_hMailNews, "HrImnRouteMessage");
        m_lpfnMailNewsDllInit = (PFNMAILNEWSDLLINIT)GetProcAddress (m_hMailNews, "MailNewsDllInit");;

        // Could get proc addresses
        if (!m_lpfnHrImnRouteMessage || !m_lpfnMailNewsDllInit)
        {
            FreeLibrary (m_hMailNews);
            m_hMailNews = NULL;
            goto exit;
        }

        // Init the dll
        (*m_lpfnMailNewsDllInit)(TRUE);
    }

exit:
    // Cleanup
    if (hReg)
        RegCloseKey (hReg);

    // Done
    return;
}

// =====================================================================================
// OnDeliver - This function never fail
// =====================================================================================
STDMETHODIMP CExchRep::OnDelivery (LPEXCHEXTCALLBACK lpExchCallback)
{
    // Locals
    HRESULT             hr = S_OK;
    LPMDB               lpMdb = NULL;
    LPMESSAGE           lpMessage = NULL;
    IMSG                rImsg;
    IADDRINFO           rIaddr[2];

    // No mailnews.dll
    if (!m_hMailNews || !m_lpfnHrImnRouteMessage || !m_lpfnMailNewsDllInit)
        goto exit;

    // Get object (IMessage
    hr = lpExchCallback->GetObject(&lpMdb, (LPMAPIPROP *)&lpMessage);
    if (FAILED (hr) || !lpMessage)
    {
        MessageBox (m_hwnd, "IExchExtCallback::GetObject failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Convert MAPI Message to mime message
    hr = HrMapiToImsg (lpMessage, &rImsg);
    if (FAILED (hr))
    {
        MessageBox (m_hwnd, "HrMapiToImsg failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

    // Set the rout to address
    rIaddr[0].dwType = IADDR_TO;
    rIaddr[0].lpszDisplay = m_szDisplayTo;
    rIaddr[0].lpszAddress = m_szAddressTo;
    rIaddr[1].dwType = IADDR_FROM;
    rIaddr[1].lpszDisplay = ROUTER_DISPLAY;
    rIaddr[1].lpszAddress = ROUTER_ADDRESS;

    // Send the message
    hr = (*m_lpfnHrImnRouteMessage)(rIaddr, 2, &rImsg);
    if (FAILED (hr))
    {
        MessageBox (m_hwnd, "HrImnRouteMessage failed", "ExchRep", MB_OK | MB_SETFOREGROUND);
        goto exit;
    }

exit:
    // Cleanup
    if (lpMdb)
        lpMdb->Release ();
    if (lpMessage)
        lpMessage->Release ();
    FreeImsg (&rImsg);

    // Done
    return S_OK;
}

// =====================================================================================
// FreeImsg
// =====================================================================================
VOID FreeImsg (LPIMSG lpImsg)
{
    // Locals
    ULONG           i;

    // Nothing
    if (lpImsg == NULL)
        return;

    // Free Stuff
    if (lpImsg->lpszSubject)
        free (lpImsg->lpszSubject);
    lpImsg->lpszSubject = NULL;
    
    if (lpImsg->lpszBody)
        free (lpImsg->lpszBody);
    lpImsg->lpszBody = NULL;

    if (lpImsg->lpstmRtf)
        lpImsg->lpstmRtf->Release ();
    lpImsg->lpstmRtf = NULL;

    // Walk Address list
    for (i=0; i<lpImsg->cAddress; i++)
    {
        if (lpImsg->lpIaddr[i].lpszAddress)
            free (lpImsg->lpIaddr[i].lpszAddress);
        lpImsg->lpIaddr[i].lpszAddress = NULL;

        if (lpImsg->lpIaddr[i].lpszDisplay)
            free (lpImsg->lpIaddr[i].lpszDisplay);
        lpImsg->lpIaddr[i].lpszDisplay = NULL;
    }

    // Free Address list
    if (lpImsg->lpIaddr)
        free (lpImsg->lpIaddr);
    lpImsg->lpIaddr = NULL;

    // Walk Attachment list
    for (i=0; i<lpImsg->cAttach; i++)
    {
        if (lpImsg->lpIatt[i].lpszFileName)
            free (lpImsg->lpIatt[i].lpszFileName);
        lpImsg->lpIatt[i].lpszFileName = NULL;

        if (lpImsg->lpIatt[i].lpszPathName)
            free (lpImsg->lpIatt[i].lpszPathName);
        lpImsg->lpIatt[i].lpszPathName = NULL;

        if (lpImsg->lpIatt[i].lpszExt)
            free (lpImsg->lpIatt[i].lpszExt);
        lpImsg->lpIatt[i].lpszExt = NULL;

        if (lpImsg->lpIatt[i].lpImsg)
        {
            FreeImsg (lpImsg->lpIatt[i].lpImsg);
            free (lpImsg->lpIatt[i].lpImsg);
            lpImsg->lpIatt[i].lpImsg = NULL;
        }

        if (lpImsg->lpIatt[i].lpstmAtt)
            lpImsg->lpIatt[i].lpstmAtt->Release ();
        lpImsg->lpIatt[i].lpstmAtt = NULL;
    }

    // Free the att list
    if (lpImsg->lpIatt)
        free (lpImsg->lpIatt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\exchrep\mapiconv.h ===
// =====================================================================================
// MAPI IMessage to IMN message
// =====================================================================================
#ifndef __MAPICONV_H
#define __MAPICONV_H

#ifdef DEBUG
void AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine);
#endif

HRESULT HrMapiToImsg (LPMESSAGE lpMessage, LPIMSG lpImsg);

#endif // __MAPICONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\imntnef\imntnef.h ===
// ==============================================================================
// I M N T N E F . H
// ==============================================================================
#ifndef __IMNTNEF_H
#define __IMNTNEF_H

#define IMNTNEF_DLL "imntnef.dll"

typedef HRESULT (STDAPICALLTYPE *PFNHRGETTNEFRTFSTREAM)(LPSTREAM lpstmTnef, LPSTREAM *lppstmRtf);
typedef HRESULT (STDAPICALLTYPE *PFNHRINIT)(BOOL fInit);

#endif // __IMNTNEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\exchrep\mapiconv.cpp ===
// =====================================================================================
// m a p c o n v . c p p
// conver a MAPI message to and from an RFC 822/RFC 1521 (mime) internet message
// =====================================================================================
#include "pch.hxx"
#include "Imnapi.h"
#include "Exchrep.h"
#include "Mapiconv.h"
#include "Error.h"

HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb);

// =====================================================================================
// MAPI Message Properties that I want
// =====================================================================================
enum 
{ 
    colSenderAddrType,
    colSenderName,
    colSenderEMail,
    colSubject, 
    colDeliverTime,
    colBody,
    colPriority,
    colLast1
};

SizedSPropTagArray (colLast1, sptMessageProps) = 
{ 
	colLast1, 
	{
        PR_SENDER_ADDRTYPE,
        PR_SENDER_NAME,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SUBJECT,
        PR_MESSAGE_DELIVERY_TIME,
        PR_BODY,
        PR_PRIORITY
    }
};

// =====================================================================================
// MAPI Recip Props
// =====================================================================================
enum 
{ 
    colRecipAddrType,
    colRecipName,
    colRecipAddress,
    colRecipType,
    colLast2
};

SizedSPropTagArray (colLast2, sptRecipProps) = 
{ 
	colLast2, 
	{
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_RECIPIENT_TYPE
    }
};

// =====================================================================================
// MAPI Attachment Props
// =====================================================================================
enum 
{ 
    colAttMethod,
    colAttNum,
    colAttLongFilename,
    colAttLongPathname,
    colAttPathname,
    colAttTag,
    colAttFilename,
    colAttExtension,
    colAttSize,
    colLast3
};

SizedSPropTagArray (colLast3, sptAttProps) = 
{ 
	colLast3, 
	{
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_LONG_FILENAME,
        PR_ATTACH_LONG_PATHNAME,
        PR_ATTACH_PATHNAME,
        PR_ATTACH_TAG,
        PR_ATTACH_FILENAME,
        PR_ATTACH_EXTENSION,
        PR_ATTACH_SIZE
    }
};

// =============================================================================================
// StringDup - duplicates a string
// =============================================================================================
LPTSTR StringDup (LPCTSTR lpcsz)
{
    // Locals
    LPTSTR       lpszDup;

    if (lpcsz == NULL)
        return NULL;

    INT nLen = lstrlen (lpcsz) + 1;

    lpszDup = (LPTSTR)malloc (nLen * sizeof (TCHAR));

    if (lpszDup)
        CopyMemory (lpszDup, lpcsz, nLen);

    return lpszDup;
}

// =====================================================================================
// HrMapiToImsg
// =====================================================================================
HRESULT HrMapiToImsg (LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    // Locals
    HRESULT         hr = S_OK;
    ULONG           cProp, i;
	LPSPropValue	lpMsgPropValue = NULL;
    LPSRowSet       lpRecipRows = NULL, lpAttRows = NULL;
    LPMAPITABLE     lptblRecip = NULL, lptblAtt = NULL;
    LPATTACH        lpAttach = NULL;
    LPMESSAGE       lpMsgAtt = NULL;
    LPSTREAM        lpstmRtfComp = NULL, lpstmRtf = NULL;

    // Zero init
    ZeroMemory (lpImsg, sizeof (IMSG));

    // Get the propsw
    hr = lpMessage->GetProps ((LPSPropTagArray)&sptMessageProps, 0, &cProp, &lpMsgPropValue);
    if (FAILED (hr))
        goto exit;

    // Subject
    if (PROP_TYPE(lpMsgPropValue[colSubject].ulPropTag) != PT_ERROR)
        lpImsg->lpszSubject = StringDup (lpMsgPropValue[colSubject].Value.lpszA);

    // Body
    if (PROP_TYPE(lpMsgPropValue[colBody].ulPropTag) != PT_ERROR)
        lpImsg->lpszBody = StringDup (lpMsgPropValue[colBody].Value.lpszA);

    // RTF
    if (!FAILED (lpMessage->OpenProperty (PR_RTF_COMPRESSED, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpstmRtfComp)))
        if (!FAILED (WrapCompressedRTFStream (lpstmRtfComp, 0, &lpstmRtf)))
            if (!FAILED (CreateStreamOnHFile (NULL, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpstmRtf)))
                HrCopyStream (lpstmRtf, lpImsg->lpstmRtf, NULL);

    // Delivery Time
    if (PROP_TYPE(lpMsgPropValue[colDeliverTime].ulPropTag) != PT_ERROR)
        CopyMemory (&lpImsg->ftDelivery, &lpMsgPropValue[colDeliverTime].Value.ft, sizeof (FILETIME));

    // Priority
    lpImsg->wPriority = PRI_NORMAL;
    if (PROP_TYPE(lpMsgPropValue[colPriority].ulPropTag) != PT_ERROR)
    {
        switch (lpMsgPropValue[colPriority].Value.l)
        {
        case PRIO_NORMAL:
            lpImsg->wPriority = PRI_NORMAL;
            break;

        case PRIO_URGENT:
            lpImsg->wPriority = PRI_HIGH;
            break;

        case PRIO_NONURGENT:
        default:
            lpImsg->wPriority = PRI_LOW;
            break;
        }
    }

    // Get the recipient table
    hr = lpMessage->GetRecipientTable (0, &lptblRecip);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = HrQueryAllRows (lptblRecip, (LPSPropTagArray)&sptRecipProps, NULL, NULL, 0, &lpRecipRows);
    if (FAILED (hr))
        goto exit;

    // Allocate Recipient Array
    lpImsg->cAddress = lpRecipRows->cRows + 1;
    lpImsg->lpIaddr =  (LPIADDRINFO)malloc (sizeof (IADDRINFO) * lpImsg->cAddress);
    if (lpImsg->lpIaddr == NULL)
        goto exit;

    // Originator of the message "From: "
    lpImsg->lpIaddr[0].dwType = IADDR_FROM;

    if (PROP_TYPE(lpMsgPropValue[colSenderName].ulPropTag) != PT_ERROR)
    {
        lpImsg->lpIaddr[0].lpszDisplay = StringDup (lpMsgPropValue[colSenderName].Value.lpszA);
        lpImsg->lpIaddr[0].lpszAddress = StringDup (lpMsgPropValue[colSenderName].Value.lpszA);
    }
    
    if (PROP_TYPE(lpMsgPropValue[colSenderEMail].ulPropTag) != PT_ERROR &&
        PROP_TYPE(lpMsgPropValue[colSenderAddrType].ulPropTag) != PT_ERROR &&
        lstrcmpi (lpMsgPropValue[colSenderAddrType].Value.lpszA, "SMTP") == 0)
    {
        lpImsg->lpIaddr[0].lpszAddress = StringDup (lpMsgPropValue[colSenderEMail].Value.lpszA);
    }

    // Add in the rest of the recipients
	for (i=0; i<lpRecipRows->cRows; i++)
	{	
        assert (i+1 < lpImsg->cAddress);

        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipType].ulPropTag) != PT_ERROR)
        {
            switch (lpRecipRows->aRow[i].lpProps[colRecipType].Value.ul)
            {
            case MAPI_TO:
                lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                break;

            case MAPI_ORIG:
                lpImsg->lpIaddr[i+1].dwType = IADDR_FROM;
                break;

            case MAPI_CC:
                lpImsg->lpIaddr[i+1].dwType = IADDR_CC;
                break;

            case MAPI_BCC:
                lpImsg->lpIaddr[i+1].dwType = IADDR_BCC;
                break;

            default:
                Assert (FALSE);
                lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                break;
            }
        }
        else
            lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
        
        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipName].ulPropTag) != PT_ERROR)
        {
            lpImsg->lpIaddr[i+1].lpszDisplay = StringDup (lpRecipRows->aRow[i].lpProps[colRecipName].Value.lpszA); 
            lpImsg->lpIaddr[i+1].lpszAddress = StringDup (lpRecipRows->aRow[i].lpProps[colRecipName].Value.lpszA); 
        }
    
        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipName].ulPropTag) != PT_ERROR &&
            PROP_TYPE(lpMsgPropValue[colRecipAddrType].ulPropTag) != PT_ERROR &&
            lstrcmpi (lpMsgPropValue[colRecipAddrType].Value.lpszA, "SMTP") == 0)
        {
            lpImsg->lpIaddr[i+1].lpszAddress = StringDup (lpRecipRows->aRow[i].lpProps[colRecipAddress].Value.lpszA);
        }
	}

    // Free Rows
    if (lpRecipRows)
        FreeProws (lpRecipRows);
    lpRecipRows = NULL;

    // Attachments
    hr = lpMessage->GetAttachmentTable (0, &lptblAtt);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = HrQueryAllRows (lptblAtt, (LPSPropTagArray)&sptAttProps, NULL, NULL, 0, &lpAttRows);
    if (FAILED (hr))
        goto exit;

    // Allocate files list
    if (lpAttRows->cRows == 0)
        goto exit;

    // Allocate memory
    lpImsg->cAttach = lpAttRows->cRows;
    lpImsg->lpIatt = (LPIATTINFO)malloc (sizeof (IATTINFO) * lpImsg->cAttach);
    if (lpImsg->lpIatt == NULL)
        goto exit;

    // Zero init
    ZeroMemory (lpImsg->lpIatt, sizeof (IATTINFO) * lpImsg->cAttach);

    // Walk the rows
	for (i=0; i<lpAttRows->cRows; i++)
	{	
        if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttMethod].ulPropTag) != PT_ERROR &&
            PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttNum].ulPropTag) != PT_ERROR)
        {
            // Basic Properties
            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttPathname].ulPropTag) != PT_ERROR)
                lpImsg->lpIatt[i].lpszPathName = StringDup (lpAttRows->aRow[i].lpProps[colAttPathname].Value.lpszA);      

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttFilename].ulPropTag) != PT_ERROR)
                lpImsg->lpIatt[i].lpszFileName = StringDup (lpAttRows->aRow[i].lpProps[colAttFilename].Value.lpszA);      

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttExtension].ulPropTag) != PT_ERROR)
                lpImsg->lpIatt[i].lpszExt = StringDup (lpAttRows->aRow[i].lpProps[colAttExtension].Value.lpszA);     

            // Open the attachment
            hr = lpMessage->OpenAttach (lpAttRows->aRow[i].lpProps[colAttNum].Value.l, NULL, MAPI_BEST_ACCESS, &lpAttach);
            if (FAILED (hr))
            {
                lpImsg->lpIatt[i].fError = TRUE;
                continue;
            }

            // Handle the attachment method
            switch (lpAttRows->aRow[i].lpProps[colAttMethod].Value.ul)
            {
            case NO_ATTACHMENT:
                lpImsg->lpIatt[i].dwType = 0;
                lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_RESOLVE:
            case ATTACH_BY_VALUE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_BIN, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_ONLY:
            case ATTACH_BY_REFERENCE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = CreateStreamOnHFile (lpImsg->lpIatt[i].lpszPathName, GENERIC_READ,  FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_EMBEDDED_MSG:
                lpImsg->lpIatt[i].dwType = IATT_MSG;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_OBJ, (LPIID)&IID_IMessage, 0, 0, (LPUNKNOWN *)&lpMsgAtt);
                if (FAILED (hr) || lpMsgAtt == NULL)
                    lpImsg->lpIatt[i].fError = TRUE;
                else
                {
                    lpImsg->lpIatt[i].lpImsg = (LPIMSG)malloc (sizeof (IMSG));
                    if (lpImsg->lpIatt[i].lpImsg == NULL)
                        lpImsg->lpIatt[i].fError = TRUE;
                    else
                    {
                        hr = HrMapiToImsg (lpMsgAtt, lpImsg->lpIatt[i].lpImsg);
                        if (FAILED (hr))
                            lpImsg->lpIatt[i].fError = TRUE;
                    }    
                    lpMsgAtt->Release ();
                    lpMsgAtt = NULL;
                }
                break;

            case ATTACH_OLE:
            default:
                lpImsg->lpIatt[i].dwType = IATT_OLE;
                lpImsg->lpIatt[i].fError = TRUE;
                break;
            }

            // Free Attachment
            if (lpAttach)
                lpAttach->Release ();
            lpAttach = NULL;
        }
    }

exit:
    // Cleanup
    if (lpAttach)
        lpAttach->Release ();
    if (lptblAtt)
        lptblAtt->Release ();
    if (lpAttRows)
        FreeProws (lpAttRows);
    if (lpRecipRows)
        FreeProws (lpRecipRows);
    if (lpMsgPropValue)
        MAPIFreeBuffer (lpMsgPropValue);
    if (lptblRecip)
        lptblRecip->Release ();
    if (lpMsgAtt)
        lpMsgAtt->Release ();
    if (lpstmRtfComp)
        lpstmRtfComp->Release ();
    if (lpstmRtf)
        lpstmRtf->Release ();

    // Done
    return hr;
}


void AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    static const char rgch1[]     = "File %s, line %d:";
    static const char rgch2[]     = "Unknown file:";
    static const char szAssert[]  = "Assert Failure";

    char    rgch[512];
    char   *lpsz;
    int     ret, cch;

    if (szFile)
        wsprintf(rgch, rgch1, szFile, nLine);
    else
        lstrcpy(rgch, rgch2);

    cch = lstrlen(rgch);
    Assert(lstrlen(szMsg)<(512-cch-3));
    lpsz = &rgch[cch];
    *lpsz++ = '\n';
    *lpsz++ = '\n';
    lstrcpy(lpsz, szMsg);

    ret = MessageBox(GetActiveWindow(), rgch, szAssert, MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND);

    if (ret != IDIGNORE)
        DebugBreak();

    /* Force a hard exit w/ a GP-fault so that Dr. Watson generates a nice stack trace log. */
    if (ret == IDABORT)
        *(LPBYTE)0 = 1; // write to address 0 causes GP-fault
}

// =====================================================================================
// HrCopyStream - caller must do the commit
// =====================================================================================
HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbTotal = 0;

    do
    {
        hr = lpstmIn->Read (buf, sizeof (buf), &cbRead);
        if (FAILED (hr))
            goto exit;

        if (cbRead == 0) break;
        
        hr = lpstmOut->Write (buf, cbRead, NULL);
        if (FAILED (hr))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    if (pcb)
        *pcb = cbTotal;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\util\imntnef\imntnef.cpp ===
// ==============================================================================
// I M N T N E F . C P P
// ==============================================================================
#define INITGUID
#define USES_IID_IMessage
#define USES_IID_IMAPIPropData

#include <windows.h>
#include <assert.h>
#include <ole2.h>
#include <initguid.h>
#include <mapiguid.h>
#include <mapi.h>
#include <mapix.h>
#include <mapiutil.h>
#include <tnef.h>

// =====================================================================================
// G L O B A L S
// =====================================================================================
HINSTANCE       g_hInst = NULL;
LPMAPISESSION   g_lpSession = NULL;
LPADRBOOK       g_lpAdrBook = NULL;

// =====================================================================================
// S T R U C T U R E S
// =====================================================================================
class CImnMsg : public IMessage
{
private:
    ULONG               m_cRef;
    LPPROPDATA          m_lpPropData;

public:
    // =====================================================================================
	// Creation
	// =====================================================================================
    CImnMsg ();
    ~CImnMsg ();

    // =====================================================================================
	// IUnknown
	// =====================================================================================
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

    // =====================================================================================
	// IMAPIProp
	// =====================================================================================
    STDMETHODIMP CopyProps (LPSPropTagArray lpIncludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems);
    STDMETHODIMP CopyTo (ULONG ciidExclude, LPCIID rgiidExclude, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems);
    STDMETHODIMP DeleteProps (LPSPropTagArray lpPropTagArray, LPSPropProblemArray FAR * lppProblems);
    STDMETHODIMP GetIDsFromNames (ULONG cPropNames, LPMAPINAMEID FAR * lppPropNames, ULONG ulFlags, LPSPropTagArray FAR * lppPropTags);
    STDMETHODIMP GetLastError (HRESULT hResult, ULONG ulFlags, LPMAPIERROR FAR * lppMAPIError);
    STDMETHODIMP GetNamesFromIDs (LPSPropTagArray FAR * lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG FAR * lpcPropNames, LPMAPINAMEID FAR * FAR * lpppPropNames);
    STDMETHODIMP GetPropList (ULONG ulFlags, LPSPropTagArray FAR * lppPropTagArray);
    STDMETHODIMP GetProps (LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG FAR * lpcValues, LPSPropValue FAR * lppPropArray);
    STDMETHODIMP OpenProperty (ULONG ulPropTag, LPCIID lpiid, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN FAR * lppUnk);
    STDMETHODIMP SaveChanges (ULONG ulFlags);
    STDMETHODIMP SetProps (ULONG cValues, LPSPropValue lpPropArray, LPSPropProblemArray FAR * lppProblems);

    // =====================================================================================
	// IMessage
	// =====================================================================================
    STDMETHODIMP CreateAttach (LPCIID lpInterface, ULONG ulFlags, ULONG FAR * lpulAttachmentNum, LPATTACH FAR * lppAttach);
    STDMETHODIMP DeleteAttach (ULONG ulAttachmentNum, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags);
    STDMETHODIMP GetAttachmentTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable);	
    STDMETHODIMP GetRecipientTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable);
    STDMETHODIMP ModifyRecipients (ULONG ulFlags, LPADRLIST lpMods);
    STDMETHODIMP OpenAttach (ULONG ulAttachmentNum, LPCIID lpInterface, ULONG ulFlags, LPATTACH FAR * lppAttach);
    STDMETHODIMP SetReadFlag (ULONG ulFlags);
    STDMETHODIMP SubmitMessage (ULONG ulFlags);
};

// =====================================================================================
// P R O T O T Y P E S
// =====================================================================================
HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb);
HRESULT HrRewindStream (LPSTREAM lpstm);

// =====================================================================================
// D l l M a i n
// =====================================================================================
int APIENTRY DllMain (HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInstance;
        return 1;

    case DLL_PROCESS_DETACH:
        return 1;
    }

    // Done
	return 0;
}

// =====================================================================================
// H r I n i t
// =====================================================================================
HRESULT HrInit (BOOL fInit)
{
    // Locals
    HRESULT         hr = S_OK;

    // If initing
    if (fInit)
    {
        // iNIT
        hr = MAPIInitialize (NULL);
        if (FAILED (hr))
            goto exit;

        // Logon to mapi
        if (g_lpSession == NULL)
        {
            hr = MAPILogonEx (0, NULL, NULL, MAPI_NO_MAIL | MAPI_USE_DEFAULT, &g_lpSession);
            if (FAILED (hr))
            {
                if (g_lpSession)
                {
                    g_lpSession->Release ();
                    g_lpSession = NULL;
                }
                goto exit;
            }
        }

        // Get an address book object
        if (g_lpAdrBook == NULL)
        {
            hr = g_lpSession->OpenAddressBook (0, NULL, AB_NO_DIALOG, &g_lpAdrBook);
            if (FAILED (hr))
            {
                if (g_lpAdrBook)
                {
                    g_lpAdrBook->Release ();
                    g_lpAdrBook = NULL;
                }
                goto exit;
            }
        }
    }

    else
    {
        // Release Address Book
        if (g_lpAdrBook)
        {
            g_lpAdrBook->Release ();
            g_lpAdrBook = NULL;
        }

        // Log off session
        if (g_lpSession)
        {
            g_lpSession->Logoff (0, 0, 0);
            g_lpSession->Release ();
            g_lpSession = NULL;
        }

        // MAPI de-init
        MAPIUninitialize ();
    }

exit:
    // Done
    return hr;
}

// =====================================================================================
// HrGetTnefRtfStream
// =====================================================================================
HRESULT HrGetTnefRtfStream (LPSTREAM lpstmTnef, LPSTREAM lpstmRtf)
{
    // Locals
    HRESULT             hr = S_OK;
    SYSTEMTIME          st;
    WORD                wKey;
    LPITNEF             lpTnef = NULL;
    LPSTREAM            lpstmRtfComp = NULL, lpstmRtfUncomp = NULL;
    CImnMsg            *lpImnMsg = NULL;
    ULONG               cValues;
    LPSPropValue        lpPropValue = NULL;

    SizedSPropTagArray (1, spa) = {1, { PR_RTF_COMPRESSED } };

    // Bad init
    if (!g_lpSession || !g_lpAdrBook || !lpstmTnef || !lpstmRtf)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Bullet style uniquification for wKey
    GetSystemTime (&st);
    wKey = (st.wHour << 8) + st.wSecond;

    // Create one of my message objects
    lpImnMsg = new CImnMsg;
    if (lpImnMsg == NULL)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Initiates a TNEF session
    hr = OpenTnefStreamEx (NULL, lpstmTnef, "WINMAIL.DAT", TNEF_DECODE,
                           (LPMESSAGE)lpImnMsg, wKey, g_lpAdrBook, &lpTnef);
    if (FAILED (hr))
        goto exit;

    // ExtractProps
    hr = lpTnef->ExtractProps (TNEF_PROP_INCLUDE, (SPropTagArray *)&spa, NULL);
    if (FAILED (hr))
        goto exit;

    // RTF stream
    hr = lpImnMsg->GetProps ((SPropTagArray *)&spa, 0, &cValues, &lpPropValue);
    if (FAILED (hr))
        goto exit;

    // Property not found ?
    if (PROP_TYPE (lpPropValue[0].ulPropTag) == PT_ERROR)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Create Hglobal
    hr = CreateStreamOnHGlobal (NULL, TRUE, &lpstmRtfComp);
    if (FAILED (hr))
        goto exit;

    // Write my binary into lpstmRtfComp
    hr = lpstmRtfComp->Write (lpPropValue[0].Value.bin.lpb, lpPropValue[0].Value.bin.cb, NULL);
    if (FAILED (hr))
        goto exit;

    // Commit and rewind the stream
    hr = lpstmRtfComp->Commit (STGC_DEFAULT);
    if (FAILED (hr))
        goto exit;

    // Rewind
    hr = HrRewindStream (lpstmRtfComp);
    if (FAILED (hr))
        goto exit;

    // un compress it
    hr = WrapCompressedRTFStream (lpstmRtfComp, 0, &lpstmRtfUncomp);
    if (FAILED (hr))
        goto exit;

    // Copy strem
    hr = HrCopyStream (lpstmRtfUncomp, lpstmRtf, NULL);
    if (FAILED (hr))
        goto exit;

    // Rewind lpstmRtf
    hr = HrRewindStream (lpstmRtf);
    if (FAILED (hr))
        goto exit;

exit:
    // Cleanup
    if (lpPropValue)
        MAPIFreeBuffer (lpPropValue);
    if (lpTnef)
        lpTnef->Release ();
    if (lpstmRtfComp)
        lpstmRtfComp->Release ();
    if (lpstmRtfUncomp)
        lpstmRtfUncomp->Release ();
    if (lpImnMsg)
        lpImnMsg->Release ();

    // Done
    return hr;
}

// =====================================================================================
// HrCopyStream - caller must do the commit
// =====================================================================================
HRESULT HrCopyStream (LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbTotal = 0;

    do
    {
        hr = lpstmIn->Read (buf, sizeof (buf), &cbRead);
        if (FAILED (hr))
            goto exit;

        if (cbRead == 0) break;
        
        hr = lpstmOut->Write (buf, cbRead, NULL);
        if (FAILED (hr))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    if (pcb)
        *pcb = cbTotal;
    return hr;
}

// =====================================================================================
// HrRewindStream
// =====================================================================================
HRESULT HrRewindStream (LPSTREAM lpstm)
{
    LARGE_INTEGER  liOrigin = {0,0};
    return lpstm->Seek (liOrigin, STREAM_SEEK_SET, NULL);
}

// =====================================================================================
// CImnMsg::~CImnMsg
// =====================================================================================
CImnMsg::CImnMsg ()
{
    m_cRef = 1;
    CreateIProp (&IID_IMAPIPropData, (ALLOCATEBUFFER *)MAPIAllocateBuffer,
                 (ALLOCATEMORE *)MAPIAllocateMore, (FREEBUFFER *)MAPIFreeBuffer, 
                 NULL, &m_lpPropData);
    assert (m_lpPropData);
}

// =====================================================================================
// CImnMsg::~CImnMsg
// =====================================================================================
CImnMsg::~CImnMsg ()
{
    if (m_lpPropData)
        m_lpPropData->Release ();
}

// =====================================================================================
// Add Ref
// =====================================================================================
STDMETHODIMP_(ULONG) CImnMsg::AddRef () 
{												  	
	++m_cRef; 								  
	return m_cRef; 						  
}

// =====================================================================================
// Release 
// =====================================================================================
STDMETHODIMP_(ULONG) CImnMsg::Release () 
{ 
    ULONG uCount = --m_cRef;
    if (!uCount) 
        delete this; 
   return uCount;
}

// =====================================================================================
// CImnMsg::QueryInterface
// =====================================================================================
STDMETHODIMP CImnMsg::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	// Locals
    HRESULT hr = S_OK;

    // Init
    *ppvObj = NULL;

    // IUnknown or IExchExt interface, this is it dude
    if (IID_IUnknown == riid)
    {
		*ppvObj = (LPUNKNOWN)(IUnknown *)this;
    }
   
	// IID_IMessage
	else if (IID_IMessage == riid) 
	{
		*ppvObj = (LPUNKNOWN)(IMessage *)this;
    }
 
	// IID_IMAPIProp
	else if (IID_IMAPIPropData == riid) 
	{
        assert (m_lpPropData);
		*ppvObj = (LPUNKNOWN)(IMAPIProp *)m_lpPropData;
    }

    // Else, interface is not supported
	else 
        hr = E_NOINTERFACE;

    // Increment Reference Count
	if (NULL != *ppvObj) 
        ((LPUNKNOWN)*ppvObj)->AddRef();

	// Done
    return hr;
}

// =====================================================================================
// CImnMsg::CopyProps
// =====================================================================================
STDMETHODIMP CImnMsg::CopyProps (LPSPropTagArray lpIncludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->CopyProps (lpIncludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
}

// =====================================================================================
// CImnMsg::CopyTo
// =====================================================================================
STDMETHODIMP CImnMsg::CopyTo (ULONG ciidExclude, LPCIID rgiidExclude, LPSPropTagArray lpExcludeProps, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, LPCIID lpInterface, LPVOID lpDestObj, ULONG ulFlags, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->CopyTo (ciidExclude, rgiidExclude, lpExcludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
}

// =====================================================================================
// CImnMsg::DeleteProps
// =====================================================================================
STDMETHODIMP CImnMsg::DeleteProps (LPSPropTagArray lpPropTagArray, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->DeleteProps (lpPropTagArray, lppProblems);
}

// =====================================================================================
// CImnMsg::GetIDsFromNames
// =====================================================================================
STDMETHODIMP CImnMsg::GetIDsFromNames (ULONG cPropNames, LPMAPINAMEID FAR * lppPropNames, ULONG ulFlags, LPSPropTagArray FAR * lppPropTags)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetIDsFromNames (cPropNames, lppPropNames, ulFlags, lppPropTags);
}

// =====================================================================================
// CImnMsg::GetLastError
// =====================================================================================
STDMETHODIMP CImnMsg::GetLastError (HRESULT hResult, ULONG ulFlags, LPMAPIERROR FAR * lppMAPIError)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetLastError (hResult, ulFlags, lppMAPIError);
}

// =====================================================================================
// CImnMsg::GetNamesFromIDs
// =====================================================================================
STDMETHODIMP CImnMsg::GetNamesFromIDs (LPSPropTagArray FAR * lppPropTags, LPGUID lpPropSetGuid, ULONG ulFlags, ULONG FAR * lpcPropNames, LPMAPINAMEID FAR * FAR * lpppPropNames)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetNamesFromIDs (lppPropTags, lpPropSetGuid, ulFlags, lpcPropNames, lpppPropNames);
}

// =====================================================================================
// CImnMsg::GetPropList
// =====================================================================================
STDMETHODIMP CImnMsg::GetPropList (ULONG ulFlags, LPSPropTagArray FAR * lppPropTagArray)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetPropList (ulFlags, lppPropTagArray);
}

// =====================================================================================
// CImnMsg::GetProps
// =====================================================================================
STDMETHODIMP CImnMsg::GetProps (LPSPropTagArray lpPropTagArray, ULONG ulFlags, ULONG FAR * lpcValues, LPSPropValue FAR * lppPropArray)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->GetProps (lpPropTagArray, ulFlags, lpcValues, lppPropArray);
}

// =====================================================================================
// CImnMsg::OpenProperty
// =====================================================================================
STDMETHODIMP CImnMsg::OpenProperty (ULONG ulPropTag, LPCIID lpiid, ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN FAR * lppUnk)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->OpenProperty (ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk);
}

// =====================================================================================
// CImnMsg::SaveChanges
// =====================================================================================
STDMETHODIMP CImnMsg::SaveChanges (ULONG ulFlags)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->SaveChanges (ulFlags);
}

// =====================================================================================
// CImnMsg::SetProps
// =====================================================================================
STDMETHODIMP CImnMsg::SetProps (ULONG cValues, LPSPropValue lpPropArray, LPSPropProblemArray FAR * lppProblems)
{
    if (m_lpPropData == NULL)
    {
        assert (m_lpPropData);
        return E_FAIL;
    }

    return m_lpPropData->SetProps (cValues, lpPropArray, lppProblems);
}

// =====================================================================================
// CImnMsg::CreateAttach
// =====================================================================================
STDMETHODIMP CImnMsg::CreateAttach (LPCIID lpInterface, ULONG ulFlags, ULONG FAR * lpulAttachmentNum, LPATTACH FAR * lppAttach)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::DeleteAttach
// =====================================================================================
STDMETHODIMP CImnMsg::DeleteAttach (ULONG ulAttachmentNum, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::GetAttachmentTable
// =====================================================================================
STDMETHODIMP CImnMsg::GetAttachmentTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::GetRecipientTable
// =====================================================================================
STDMETHODIMP CImnMsg::GetRecipientTable (ULONG ulFlags, LPMAPITABLE FAR * lppTable)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::ModifyRecipients
// =====================================================================================
STDMETHODIMP CImnMsg::ModifyRecipients (ULONG ulFlags, LPADRLIST lpMods)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::OpenAttach
// =====================================================================================
STDMETHODIMP CImnMsg::OpenAttach (ULONG ulAttachmentNum, LPCIID lpInterface, ULONG ulFlags, LPATTACH FAR * lppAttach)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::SetReadFlag
// =====================================================================================
STDMETHODIMP CImnMsg::SetReadFlag (ULONG ulFlags)
{
    assert (FALSE);
    return E_NOTIMPL;
}

// =====================================================================================
// CImnMsg::SubmitMessage
// =====================================================================================
STDMETHODIMP CImnMsg::SubmitMessage (ULONG ulFlags)
{
    assert (FALSE);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\view\listevt.h ===
#pragma once

#include "msoedisp.h"

//////////////////////////////////////////////////////////////////////////////
// CProxy_MessageListEvents
template <class T>
class CProxy_MessageListEvents : public IConnectionPointImpl<T, &DIID__MessageListEvents, CComDynamicUnkArray>
{
public:
//methods:
//_MessageListEvents : IDispatch
public:
    HRESULT Fire_OnMessageAvailable(MESSAGEID idMessage, HRESULT hrComplete)
    {
        HRESULT hr;
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[2];
        if(!pvars)
            return E_OUTOFMEMORY;
        
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I8;
                pvars[0].ullVal= (ULONGLONG)idMessage;
                pvars[1].vt = VT_ERROR;
                pvars[1].scode = hrComplete;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                hr = pDispatch->Invoke(DISPID_LISTEVENT_ONMESSAGEAVAILABLE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
        return hr;
    }


    void Fire_OnSelectionChanged(long cSelected)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= cSelected;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_SELECTIONCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnFocusChanged(long fFocus)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= fFocus;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_FOCUSCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnMessageCountChanged(IMessageTable *pTable)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[3];
        if(!pvars)
            return;
        for (int i = 0; i < 3; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {                
                pvars[0].vt = VT_I4;
                if (pTable)
                {
                    pTable->GetCount(MESSAGE_COUNT_ALL, (DWORD *) &(pvars[0].lVal));
                }

                pvars[1].vt = VT_I4;
                if (pTable)
                {
                    pTable->GetCount(MESSAGE_COUNT_UNREAD, (DWORD *) &(pvars[1].lVal));
                }

                pvars[2].vt = VT_I4;
                if (pTable)
                {
                    pTable->GetCount(MESSAGE_COUNT_NOTDOWNLOADED, (DWORD *) &(pvars[2].lVal));
                }
                DISPPARAMS disp = { pvars, NULL, 3, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_COUNTCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnUpdateStatus(LPCTSTR pszStatus)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {   
                TCHAR szBuf[CCHMAX_STRINGRES];

                // If this is a string resource ID, load it first
                if (IS_INTRESOURCE(pszStatus))
                {
                    AthLoadString(PtrToUlong(pszStatus), szBuf, ARRAYSIZE(szBuf));
                    pszStatus = szBuf;
                }
/*
                CComBSTR cString(pszStatus);
*/
                pvars->vt = VT_BSTR;
                pvars->bstrVal = (BSTR) pszStatus;

                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_UPDATESTATUS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnUpdateProgress(long lProgress, long lMax = 100, long lState = PROGRESS_STATE_DEFAULT)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[3];
        if(!pvars)
            return;
        for (int i = 0; i < 3; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= lProgress;
                pvars[1].vt = VT_I4;
                pvars[1].lVal = lMax;
                pvars[2].vt = VT_I4;
                pvars[2].lVal = lState;
                DISPPARAMS disp = { pvars, NULL, 3, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_UPDATEPROGRESS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }


    void Fire_OnError(DWORD ids)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= ids;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_ERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnItemActivate(void)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_ITEMACTIVATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_OnUpdateCommandState(void)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_UPDATECOMMANDSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
    
    void Fire_OnFilterChanged(RULEID ridFilter)
    {
        VARIANT varResult;
        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I8;
                pvars[0].ullVal= (ULONGLONG) ridFilter;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_LISTEVENT_FILTERCHANGED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnAdUrlAvailable(LPSTR   pszAdUrl)
    {
        VARIANT     varResult;
        BSTR        Bstr;

        VariantInit(&varResult);
        VARIANTARG* pvars = new VARIANTARG[1];
        if(!pvars)
            return;
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                if SUCCEEDED(HrLPSZToBSTR(pszAdUrl, &Bstr))
                {                
                    pvars[0].vt         = VT_BSTR;
                
                    pvars[0].bstrVal    = Bstr;

                    DISPPARAMS disp = { pvars, NULL, 1, 0 };

                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(DISPID_LISTEVENT_ADURL_AVAILABLE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);

                    SysFreeString(Bstr);
                }
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\makefile.inc ===
$O\msimn.res : selfreg.inf

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\view\msglist.h ===
// msglist.h : Declaration of the CMessageList

#ifndef __MESSAGELIST_H_
#define __MESSAGELIST_H_

#include "resource.h"       // main symbols
#include "columns.h"
#include "thormsgs.h"
#include "msoeobj.h"
#include "listevt.h"
#include "mimeole.h"
#include "storutil.h"
#include "util.h"

#define WM_FOLDER_LOADED WM_USER + 1

interface IMessageTable;
interface IMessageViewNotify;
interface IFindNext;
interface IListSelector;

#define     NOT_KNOWN           0x0
#define     CONNECTED           0x1
#define     NOT_CONNECTED       0x2

/////////////////////////////////////////////////////////////////////////////
// Creator Function
//
HRESULT CreateMessageList(IUnknown *pUnkOuter, IMessageList **ppList);


/////////////////////////////////////////////////////////////////////////////
// CMessageList
//
class ATL_NO_VTABLE CMessageList : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMessageList, &CLSID_MessageList>,
    public CComControl<CMessageList>,
    public IDispatchImpl<IOEMessageList, &IID_IOEMessageList, &LIBID_MSOEOBJ>,
    public IProvideClassInfo2Impl<&CLSID_MessageList, &DIID__MessageListEvents, &LIBID_MSOEOBJ>,
    public IPersistStreamInitImpl<CMessageList>,
    public IPersistStorageImpl<CMessageList>,
    public IQuickActivateImpl<CMessageList>,
    public IOleControlImpl<CMessageList>,
    public IOleObjectImpl<CMessageList>,
    public IOleInPlaceActiveObjectImpl<CMessageList>,
    public IViewObjectExImpl<CMessageList>,
    public IOleInPlaceObjectWindowlessImpl<CMessageList>,
    public IDataObjectImpl<CMessageList>,
    public CProxy_MessageListEvents<CMessageList>,
    public IConnectionPointContainerImpl<CMessageList>,
    public IPropertyNotifySinkCP<CMessageList>,
    public ISpecifyPropertyPagesImpl<CMessageList>,
    public IOleCommandTarget, 
    public IDropSource,
    public IStoreCallback,
    public IMessageTableNotify,
    public IFontCacheNotify,
    public IMessageList,
    public ITimeoutCallback,
    public IConnectionNotify
{
public:

    // Declare our own window class that doesn't have the CS_HREDRAW etc set
    static CWndClassInfo& GetWndClassInfo() 
    { 
        static CWndClassInfo wc = 
        { 
            { sizeof(WNDCLASSEX), 0, StartWindowProc, 
              0, 0, 0, 0, 0, 0, 0, "Outlook Express Message List", 0 }, 
            NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
        }; 
        return wc; 
    }

    DECLARE_NO_REGISTRY()

    /////////////////////////////////////////////////////////////////////////////
    // This is our QueryInterface implementation
    //
    BEGIN_COM_MAP(CMessageList)
        COM_INTERFACE_ENTRY(IOEMessageList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IDataObject)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IDropSource)
        COM_INTERFACE_ENTRY(IStoreCallback)
        COM_INTERFACE_ENTRY(IMessageTableNotify)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY(IFontCacheNotify)
        COM_INTERFACE_ENTRY(IMessageList)
        COM_INTERFACE_ENTRY(ITimeoutCallback)
        COM_INTERFACE_ENTRY(IConnectionNotify)
    END_COM_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // Maps Dispatch IDs to property description strings for automation
    //
    BEGIN_PROPERTY_MAP(CMessageList)
        // Example entries
        // PROP_ENTRY("Property Description", dispid, clsid)
        PROP_ENTRY("Count",             DISPID_LISTPROP_COUNT,               CLSID_StockColorPage)
        PROP_ENTRY("ExpandGroups",      DISPID_LISTPROP_EXPAND_GROUPS,       CLSID_StockColorPage)
        PROP_ENTRY("Folder",            DISPID_LISTPROP_FOLDER,              CLSID_StockColorPage)
        PROP_ENTRY("GroupMessages",     DISPID_LISTPROP_GROUP_MESSAGES,      CLSID_StockColorPage)
        PROP_ENTRY("MessageTips",       DISPID_LISTPROP_MESSAGE_TIPS,        CLSID_StockColorPage)
        PROP_ENTRY("PreviewMessage",    DISPID_LISTPROP_COUNT,               CLSID_StockColorPage)
        PROP_ENTRY("ScrollTips",        DISPID_LISTPROP_SCROLL_TIPS,         CLSID_StockColorPage)
        PROP_ENTRY("SelectedCount",     DISPID_LISTPROP_SELECTED_COUNT,      CLSID_StockColorPage)
        PROP_ENTRY("SelectFirstUnread", DISPID_LISTPROP_SELECT_FIRST_UNREAD, CLSID_StockColorPage)
        PROP_ENTRY("UnreadCount",       DISPID_LISTPROP_UNREAD_COUNT,        CLSID_StockColorPage)
        PROP_ENTRY("FilterMessages",    DISPID_LISTPROP_FILTER_MESSAGES,     CLSID_StockColorPage)
        PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // This are our outgoing connection points
    //
    BEGIN_CONNECTION_POINT_MAP(CMessageList)
        CONNECTION_POINT_ENTRY(DIID__MessageListEvents)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP()


    /////////////////////////////////////////////////////////////////////////
    // Creation and Initialization
    //
public:
    CMessageList();
    ~CMessageList();

    HRESULT FinalConstruct(void);

    /////////////////////////////////////////////////////////////////////////
    // Overrides of base class members
    //

    // IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);
    
    // CComControl
    HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

    // IOleInPlaceActiveObject
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);

public:
    /////////////////////////////////////////////////////////////////////////
    // IMessageList interface
    //
    STDMETHOD(SetFolder)(FOLDERID idFolder, IMessageServer *pServer, BOOL fSubFolders, FINDINFO *pFindInfo, IStoreCallback *pCallback);
    STDMETHOD(SetViewOptions)(FOLDER_OPTIONS *pOptions);
    STDMETHOD(GetViewOptions)(FOLDER_OPTIONS *pOptions);
    STDMETHOD(OnClose)(void);
    STDMETHOD(GetRect)(LPRECT prcList);
    STDMETHOD(SetRect)(RECT rc);
    STDMETHOD(HasFocus)(void);
    STDMETHOD(OnPopupMenu)(HMENU hMenu, DWORD idPopup);
    STDMETHOD(GetSelected)(DWORD *pdwFocused, DWORD *pcSelected, DWORD **prgSelected);
    STDMETHOD(GetSelectedCount)(DWORD *pdwCount);
    STDMETHOD(GetMessage)(DWORD dwRow, BOOL fDownload, BOOL fBookmark, IUnknown **ppMessage);
    STDMETHOD(GetMessageInfo)(DWORD dwRow, MESSAGEINFO **ppMsgInfo);
    STDMETHOD(GetRowFolderId)(DWORD dwRow, LPFOLDERID pidFolder);
    STDMETHOD(MarkMessage)(DWORD dwRow, MARK_TYPE mark);
    STDMETHOD(FreeMessageInfo)(MESSAGEINFO *pMsgInfo);
    STDMETHOD(MarkRead)(BOOL fBookmark, DWORD dwRow);
    STDMETHOD(GetMessageTable)(IMessageTable **ppTable);
    STDMETHOD(CreateList)(HWND hwndParent, IUnknown *pFrame, HWND *phwndList);
    STDMETHOD(GetListSelector)(IListSelector **ppListSelector);
    STDMETHOD(GetMessageCounts)(DWORD *cTotal, DWORD *cUnread, DWORD *cOnServer);
    STDMETHOD(GetMessageServer)(IMessageServer **ppServer);
    STDMETHOD(GetFocusedItemState)(DWORD *pdwState);
    STDMETHOD(ProcessReceipt)(IMimeMessage *pMessage);
    STDMETHOD(GetAdBarUrl)(void);

    /////////////////////////////////////////////////////////////////////////
    // IOEMessageList interface
    //
    STDMETHOD(get_Folder)(/*[out, retval]*/ ULONGLONG *pVal);
    STDMETHOD(put_Folder)(/*[in]*/ ULONGLONG newVal);
    STDMETHOD(get_ExpandGroups)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ExpandGroups)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_GroupMessages)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_GroupMessages)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_SelectFirstUnread)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_SelectFirstUnread)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_MessageTips)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_MessageTips)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_ScrollTips)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ScrollTips)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_UnreadCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_SelectedCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PreviewMessage)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FilterMessages)(/*[out, retval]*/ ULONGLONG *pVal);
    STDMETHOD(put_FilterMessages)(/*[in]*/ ULONGLONG newVal);
    STDMETHOD(get_ShowDeleted)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ShowDeleted)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_ShowReplies)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ShowReplies)(/*[in]*/ BOOL newVal);

    /////////////////////////////////////////////////////////////////////////
    // IDropSource interface
    //
    STDMETHOD(QueryContinueDrag)(BOOL fEscPressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget interface
    //
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                           OLECMDTEXT *pCmdText); 
    STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                    VARIANTARG *pvaIn, VARIANTARG *pvaOut);    

    /////////////////////////////////////////////////////////////////////////
    // IFontCacheNotify
    //
	STDMETHOD(OnPreFontChange)(void);
	STDMETHOD(OnPostFontChange)(void);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback interface
    //
    STDMETHOD(OnBegin)(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHOD(OnProgress)(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHOD(OnTimeout)(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHOD(CanConnect)(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHOD(OnLogonPrompt)(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHOD(OnComplete)(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHOD(OnPrompt)(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHOD(GetParentWindow)(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // IMessageTableNotify interface
    //
    STDMETHOD(OnInsertRows)(DWORD cRows, LPROWINDEX prgiRow, BOOL fExpanded);
    STDMETHOD(OnDeleteRows)(DWORD cRows, LPROWINDEX prgiRow, BOOL fCollapsed);
    STDMETHOD(OnUpdateRows)(ROWINDEX iRowMin, ROWINDEX iRowMax);
    STDMETHOD(OnRedrawState)(BOOL fRedraw);
    STDMETHOD(OnResetView)(void);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback
    //
    STDMETHOD(OnTimeoutResponse)(TIMEOUTRESPONSE eResponse);

    /////////////////////////////////////////////////////////////////////////
    // IConnectioNotify
    //
    STDMETHOD(OnConnectionNotify)(CONNNOTIFY    nCode, LPVOID   pvData, CConnectionManager  *pconman);

    /////////////////////////////////////////////////////////////////////////
    // Window Message Handlers
    //
protected:
    BEGIN_MSG_MAP(CMessageList)
        // These are all the normal window messages we handle
        MESSAGE_HANDLER(WM_PAINT,               OnPaint)
        MESSAGE_HANDLER(WM_NOTIFY,              OnNotify)
        MESSAGE_HANDLER(WM_SIZE,                OnSize)
        MESSAGE_HANDLER(WM_SETFOCUS,            OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS,           OnKillFocus)
        MESSAGE_HANDLER(WM_CREATE,              OnCreate)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE,      OnSysColorChange)
        MESSAGE_HANDLER(WM_WININICHANGE,        OnSysColorChange)
        MESSAGE_HANDLER(WM_TIMECHANGE,          OnTimeChange)
        MESSAGE_HANDLER(WM_CONTEXTMENU,         OnContextMenu)
        MESSAGE_HANDLER(WM_TIMER,               OnTimer)
        MESSAGE_HANDLER(MVM_REDOCOLUMNS,        OnRedoColumns)
        MESSAGE_HANDLER(WM_DESTROY,             OnDestroy)
        MESSAGE_HANDLER(WM_SELECTROW,           OnSelectRow)
        
    // ListView
    ALT_MSG_MAP(1)
        MESSAGE_HANDLER(WM_SETCURSOR,           OnListSetCursor)
        MESSAGE_HANDLER(WM_VSCROLL,             OnListVScroll)
#ifdef OLDTOOLTIPS
        MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnListMouseEvent)
        MESSAGE_HANDLER(WM_MOUSEMOVE,           OnListMouseMove)
        MESSAGE_HANDLER(WM_MOUSELEAVE,          OnListMouseLeave)
    // Scroll Bar tooltip
#endif // OLDTIPS
    ALT_MSG_MAP(2)

    END_MSG_MAP()

    HRESULT OnDraw(ATL_DRAWINFO& di);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimeChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRedoColumns(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSelectRow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyGetInfoTip(LPARAM lParam);

    LRESULT OnHeaderStateChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUpdateAndRefocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDiskFull(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnArticleProgress(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnBodyError(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnBodyAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnStatusChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnListVScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
#ifdef OLDTOOLTIPS
    LRESULT OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
#endif // OLDTIPS
    LRESULT OnListSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    /////////////////////////////////////////////////////////////////////////
    // Command Target Handlers
    //
    HRESULT CmdSelectAll(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCopyClipboard(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdProperties(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdExpandCollapse(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdColumnsDlg(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdSort(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdSaveAs(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdMark(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdMarkTopic(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdGetNextItem(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdGetHeaders(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdMoveCopy(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdDelete(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFind(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFindNext(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdPurgeFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdSpaceAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdWatchIgnore(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void    _UpdateListViewCount(void);
    HRESULT _GetSelectedCachedMessage(BOOL fSecure, IMimeMessage **ppMessage);
    HRESULT _ExpandCollapseThread(int iItem);
    BOOL    _IsSelectedMessage(DWORD dwState, BOOL fCondition, BOOL fAll, BOOL fThread = FALSE);
    void    _SelectDefaultRow(void);
    void    _LoadAndFormatString(LPTSTR pszOut, const TCHAR *pFmt, ...);
    BOOL    _IsSelectionDeletable(void);


    LRESULT _OnColumnClick(int iColumn, int iSortType);
    void    _OnBeginDrag(NM_LISTVIEW *pnmlv);
    void    _OnGetDisplayInfo(LV_DISPINFO *plvdi);
    LRESULT _OnCustomDraw(NMCUSTOMDRAW *pnmcd);
    void    _GetColumnText(MESSAGEINFO *pInfo, COLUMN_ID idColumn, LPTSTR pszText, DWORD cchTextMax);
    void    _GetColumnImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, COLUMN_ID idColumn, int *piImage);
    void    _GetColumnStateImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, LV_DISPINFO *plvdi);
    void    _FilterView(RULEID ridFilter);
    HRESULT _EnablePopupMenu(HMENU hPopup);
    void    _SetColumnSet(FOLDERID id, BOOL fFind);
    void    _ResetView(MESSAGEID idSel);

#ifdef OLDTOOLTIPS
    BOOL    _UpdateViewTip(int x, int y, BOOL fForceUpdate = FALSE);
    LRESULT _OnViewTipShow(void);
    LRESULT _OnViewTipGetDispInfo(LPNMTTDISPINFO pttdi);
    BOOL    _IsItemTruncated(int iItem, int iSubItem);
#endif // OLDTIPS
    FNTSYSTYPE _GetRowFont(int iItem);
    HRESULT  PromptToGoOnline();
    HRESULT  Resynchronize();
    void     UpdateConnInfo();
    void    _DoColumnCheck(COLUMN_ID id);
    void    _DoFilterCheck(RULEID ridFilter);
    BOOL    _PollThisAccount(FOLDERID id);

    /////////////////////////////////////////////////////////////////////////
    // Class Member Data
    //
private:
    CContainedWindow        m_ctlList;
    CColumns                m_cColumns;
    HWND                    m_hwndParent;
    BOOL                    m_fInOE;
    BOOL                    m_fMailFolder;
    BOOL                    m_fGroupSubscribed;
    BOOL                    m_fColumnsInit;

    // Settings
    FOLDERID                m_idFolder;
    BOOL                    m_fJunkFolder;
    BOOL                    m_fFindFolder;
    BOOL                    m_fAutoExpandThreads;
    BOOL                    m_fThreadMessages;
    BOOL                    m_fShowDeleted;
    BOOL                    m_fShowReplies;
    BOOL                    m_fSelectFirstUnread;
    COLUMN_SET_TYPE         m_ColumnSetType;
    BOOL                    m_fViewTip;
    BOOL                    m_fScrollTip;
    BOOL                    m_fInFire;
    DWORD                   m_clrWatched;
    DWORD                   m_dwGetXHeaders;

    // Groovy Pointers
    IMessageTable          *m_pTable;
    IOleCommandTarget      *m_pCmdTarget;
    CEmptyList              m_cEmptyList;
    UINT                    m_idsEmptyString;

    BOOL                    m_fRtDrag;          // The user is dragging a message with the right mouse button
    DWORD                   m_iColForPopup;     // Column that the user context menued over
    BOOL                    m_fViewMenu;

    // Bookmarks, etc
    RULEID                  m_ridFilter;
    MESSAGEID               m_idPreDelete;
    MESSAGEID               m_idSelection;
    MESSAGEID               m_idGetMsg;
    DWORD                   m_ulExpect;
    IListSelector          *m_pListSelector;

    HMENU                   m_hMenuPopup;
    POINT                   m_ptMenuPopup;

    DWORD                   m_cSortItems;
    DWORD                   m_cSortCurrent;
    HTIMEOUT                m_hTimeout;
    BOOL                    m_fNotifyRedraw;

    DWORD                   m_dwFontCacheCookie;        // For the Advise on the font cache

    LPSTR                   m_pszSubj;                  // cached subject of current message
    MESSAGEID               m_idMessage;                // currently downloading message
    STOREOPERATIONTYPE      m_tyCurrent;
    IOperationCancel       *m_pCancel;
    DWORD                   m_dwPollInterval;

#ifdef OLDTOOLTIPS
    // Scrolling Tooltips
    CContainedWindow        m_ctlScrollTip;
    BOOL                    m_fScrollTipVisible;

    // Trucated listview items Tooltips
    CContainedWindow        m_ctlViewTip;
    BOOL                    m_fViewTipVisible;
    BOOL                    m_fTrackSet;
    int                     m_iItemTip;
    int                     m_iSubItemTip;
#endif // OLDTIPS
    FOLDERINFO              m_FolderInfo;

    // Find
    HWND                    m_hwndFind;
    IFindNext              *m_pFindNext;
    MESSAGEID               m_idFindFirst;
    DWORD                   m_cFindWrap;

    BOOL                    m_fSyncAgain;
    DWORD                   m_dwConnectState;

    HCHARSET                m_hCharset;
};



/////////////////////////////////////////////////////////////////////////////
// CListSelector
//

class CListSelector : public IListSelector
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CListSelector();
    ~CListSelector();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IListSelector
    //
    STDMETHODIMP SetActiveRow(ROWINDEX iRow);
    STDMETHODIMP Advise(HWND hwndAdvise);
    STDMETHODIMP Unadvise(void);

private:
    ULONG m_cRef;
    HWND  m_hwndAdvise;
};

#endif //__MESSAGELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\pch.h ===
#include <windows.h>
#include <windowsx.h>
#include <mapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\view\msglist.cpp ===
// msglist.cpp : Implementation of CMessageList

#include "pch.hxx"
#include "msoeobj.h"
#include "msglist.h"
#include "msgtable.h"
#include "fonts.h"
#include "imagelst.h"
#include "goptions.h"
#include "note.h"
#include "mimeutil.h"
#include "xputil.h"
#include "menuutil.h"
#include "instance.h"
#include <oerules.h>
#include "msgprop.h"
#include "storutil.h"
#include "ipab.h"
#include "shlwapip.h" 
#include "newfldr.h"
#include "storutil.h"
#include "menures.h"
#include "dragdrop.h"
#include "find.h"
#include <storecb.h>
#include "util.h"
#include <ruleutil.h>
#include "receipts.h"
#include "msgtable.h"
#include "demand.h"
#include "mirror.h"
#define SERVER_HACK

/////////////////////////////////////////////////////////////////////////////
// Types 
//
#define C_RGBCOLORS 16
extern const DWORD rgrgbColors16[C_RGBCOLORS];

// Indiciates the sort direction for calls to OnColumnClick
typedef enum tagSORT_TYPE {
    LIST_SORT_ASCENDING = 0,
    LIST_SORT_DESCENDING,
    LIST_SORT_TOGGLE,
    LIST_SORT_DEFAULT
};

// Selection change timer ID
#define IDT_SEL_CHANGE_TIMER 1002
#define IDT_SCROLL_TIP_TIMER 1003
#define IDT_POLLMSGS_TIMER   1004
#define IDT_VIEWTIP_TIMER    1005

//--------------------------------------------------------------------------
// Mail Icons
//--------------------------------------------------------------------------
#define ICONF_UNSENT    8               // +------- Unsent
#define ICONF_SIGNED    4               // | +----- Signed
#define ICONF_ENCRYPTED 2               // | | +--- Encrypted
#define ICONF_UNREAD    1               // | | | +- Unread
                                        // | | | |
static const int c_rgMailIconTable[16] = {
    iiconReadMail,                      // 0 0 0 0
    iiconUnReadMail,                    // 0 0 0 1
    iiconMailReadEncrypted,             // 0 0 1 0
    iiconMailUnReadEncrypted,           // 0 0 1 1
    iiconMailReadSigned,                // 0 1 0 0
    iiconMailUnReadSigned,              // 0 1 0 1
    iiconMailReadSignedAndEncrypted,    // 0 1 1 0
    iiconMailUnReadSignedAndEncrypted,  // 0 1 1 1
    iiconUnSentMail,                    // 1 0 0 0
    iiconUnSentMail,                    // 1 0 0 1
    iiconMailReadEncrypted,             // 1 0 1 0
    iiconMailUnReadEncrypted,           // 1 0 1 1
    iiconMailReadSigned,                // 1 1 0 0
    iiconMailUnReadSigned,              // 1 1 0 1
    iiconMailReadSignedAndEncrypted,    // 1 1 1 0
    iiconMailUnReadSignedAndEncrypted   // 1 1 1 1
};

//--------------------------------------------------------------------------
// News Icons
//--------------------------------------------------------------------------
                                        // +------- Unsent
#define ICONF_FAILED    4               // | +----- Failed
#define ICONF_HASBODY   2               // | | +--- HasBody
                                        // | | | +- Unread
                                        // | | | |
static const int c_rgNewsIconTable[16] = {
    iiconNewsHeaderRead,                // 0 0 0 0
    iiconNewsHeader,                    // 0 0 0 1
    iiconNewsRead,                      // 0 0 1 0
    iiconNewsUnread,                    // 0 0 1 1
    iiconNewsFailed,                    // 0 1 0 0
    iiconNewsFailed,                    // 0 1 0 1
    iiconNewsFailed,                    // 0 1 1 0
    iiconNewsFailed,                    // 0 1 1 1
    iiconNewsUnsent,                    // 1 0 0 0
    iiconNewsUnsent,                    // 1 0 0 1
    iiconNewsUnsent,                    // 1 0 1 0
    iiconNewsUnsent,                    // 1 0 1 1
    iiconNewsFailed,                    // 1 1 0 0
    iiconNewsFailed,                    // 1 1 0 1
    iiconNewsFailed,                    // 1 1 1 0
    iiconNewsFailed,                    // 1 1 1 1
};


//
//  FUNCTION:   CreateMessageList()
//
//  PURPOSE:    Creates the CMessageList object and returns it's IUnknown 
//              pointer.
//
//  PARAMETERS: 
//      [in]  pUnkOuter - Pointer to the IUnknown that this object should
//                        aggregate with.
//      [out] ppUnknown - Returns the pointer to the newly created object.
//
HRESULT CreateMessageList(IUnknown *pUnkOuter, IMessageList **ppList)
{
    HRESULT     hr;
    IUnknown   *pUnknown;

    TraceCall("CreateMessageList");

    // Get the class factory for the MessageList object
    IClassFactory *pFactory = NULL;
    hr = _Module.GetClassObject(CLSID_MessageList, IID_IClassFactory, 
                                (LPVOID *) &pFactory);

    // If we got the factory, then get an object pointer from it
    if (SUCCEEDED(hr))
    {
        hr = pFactory->CreateInstance(pUnkOuter, IID_IOEMessageList, 
                                      (LPVOID *) &pUnknown);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IMessageList, (LPVOID *) ppList);
            pUnknown->Release();
        }
        pFactory->Release();
    }

    return (hr);
}


/////////////////////////////////////////////////////////////////////////////
// CMessageList
//

CMessageList::CMessageList() : m_ctlList(_T("SysListView32"), this, 1)
{ 
    m_bWindowOnly = TRUE; 

    m_hwndParent = 0;
    m_fInOE = FALSE;
    m_fMailFolder = FALSE;
    m_fColumnsInit = FALSE;

    m_idFolder = FOLDERID_INVALID;
    m_fJunkFolder = FALSE;
    m_fFindFolder = FALSE;
    m_fAutoExpandThreads = FALSE;
    m_fThreadMessages = FALSE;
    m_fShowDeleted = TRUE;
    m_fShowReplies = FALSE;
    m_fSelectFirstUnread = TRUE;
    m_ColumnSetType = COLUMN_SET_MAIL;

//     m_fViewTip = TRUE;
    m_fScrollTip = TRUE;    
    m_fNotifyRedraw = TRUE;
    m_clrWatched = 0;
    m_dwGetXHeaders = 0;
    m_fInFire = FALSE;

    m_pTable = NULL;
    m_pCmdTarget = NULL;
    m_idsEmptyString = idsEmptyView;

    m_fRtDrag = FALSE;
    m_iColForPopup = -1;
    m_fViewMenu = TRUE;

    m_ridFilter = RULEID_VIEW_ALL;
    m_idPreDelete = 0;
    m_idSelection = 0;
    m_idGetMsg = 0;
    m_ulExpect = 0;
    m_hTimeout = NULL;
    m_pListSelector = NULL;

    m_hMenuPopup = 0;
    m_ptMenuPopup.x = 0;
    m_ptMenuPopup.y = 0;

    m_cSortItems = 0;

    m_dwFontCacheCookie = 0;
    m_tyCurrent = SOT_INVALID;
    m_pCancel = NULL;

#ifdef OLDTIPS
    m_fScrollTipVisible = FALSE;

    m_fViewTipVisible = FALSE;
    m_fTrackSet = FALSE;
    m_iItemTip = -1;
    m_iSubItemTip = -1;
#endif // OLDTIPS

    m_hwndFind = NULL;
    m_pFindNext = NULL;
    m_pszSubj = NULL;
    m_idFindFirst = 0;

    m_idMessage = MESSAGEID_INVALID;
    m_dwPollInterval = OPTION_OFF;
    m_fSyncAgain        = FALSE;
    
    m_dwConnectState    = NOT_KNOWN;

    m_hCharset      = NULL;

    // Initialize the applicaiton
    g_pInstance->DllAddRef();
    CoIncrementInit("CMessageList::CMessageList", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}


CMessageList::~CMessageList()
{
    if (m_pFindNext)
    {
        m_pFindNext->Close();
        m_pFindNext->Release();
    }
    
    // Register Notify
    if (m_pTable)
    {
        m_pTable->UnregisterNotify((IMessageTableNotify *)this);
        m_pTable->ConnectionRelease();
        m_pTable->Close();
        m_pTable->Release();
        m_pTable = NULL;
    }

    SafeMemFree(m_pszSubj);
    CallbackCloseTimeout(&m_hTimeout);

    if (g_pConMan)
    {
        g_pConMan->Unadvise((IConnectionNotify*)this);
    }

    g_pInstance->DllRelease();
    CoDecrementInit("CMessageList::CMessageList", NULL);
}


//
//  FUNCTION:   CMessageList::FinalConstruct()
//
//  PURPOSE:    This function get's called after the class is created but 
//              before the call to CClassFactory::CreateInstance() returns.
//              Perform any inititalization that can fail here.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageList::FinalConstruct(void)
{
    TraceCall("CMessageList::FinalConstruct");
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::GetViewStatus()
//
//  PURPOSE:    We override this member of IViewObjectEx to return the view 
//              status flags that are appropriate to our object.
//
//  PARAMETERS: 
//      [out] pdwStatus - Returns the status flags for our object
//
STDMETHODIMP CMessageList::GetViewStatus(DWORD* pdwStatus)
{
    TraceCall("IViewObjectExImpl::GetViewStatus");
    *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;

    return S_OK;
}


//
//  FUNCTION:   CMessageList::CreateControlWindow()
//
//  PURPOSE:    Creates our Message List window.  We override this from 
//              CComControl so we can add the WS_EX_CONTROLPARENT style.
//
//  PARAMETERS: 
//      [in] hWndParent - Handle of the window that will be our parent
//      [in] rcPos      - Initial position of the window
//
HWND CMessageList::CreateControlWindow(HWND hWndParent, RECT& rcPos)
{
    TraceCall("CMessageList::CreateControlWindow");

    m_hwndParent = hWndParent;

    return (Create(hWndParent, rcPos, NULL, WS_VISIBLE | WS_CHILD | 
                   WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_CONTROLPARENT));
}


STDMETHODIMP CMessageList::TranslateAccelerator(LPMSG pMsg)
{
    if (IsWindow(m_hwndFind) && m_pFindNext)
    {
        return m_pFindNext->TranslateAccelerator(pMsg);
    }

    return (S_FALSE);        
}


//
//  FUNCTION:   CMessageList::QueryContinueDrag()
//
//  PURPOSE:    While the user is dragging an item out of our ListView, this 
//              function get's called so we can define what the behavior of 
//              keys like ALT or CTRL have on the drop.
//
//  PARAMETERS: 
//      [in] fEscPressed - TRUE if the user has pressed the Escape key
//      [in] grfKeyState - Status of the keys being pressed while dragging
//
//  RETURN VALUE:
//      DRAGDROP_S_CANCEL
//      DRAGDROP_S_DROP
//
STDMETHODIMP CMessageList::QueryContinueDrag(BOOL fEscPressed, DWORD grfKeyState)
{
    TraceCall("CMessageList::QueryContinueDrag");

    // If the user presses Escape, we abort
    if (fEscPressed)
        return (DRAGDROP_S_CANCEL);

    // If the user was dragging with the left mouse button, and then clicks the
    // right button, we abort.  If they let go of the left button, we drop.  If
    // the user is dragging with the right mouse button, same actions only 
    // reversed.
    if (!m_fRtDrag)
    {
        if (grfKeyState & MK_RBUTTON)
            return (DRAGDROP_S_CANCEL);
        if (!(grfKeyState & MK_LBUTTON))
            return (DRAGDROP_S_DROP);
    }
    else
    {
        if (grfKeyState & MK_LBUTTON)
            return (DRAGDROP_S_CANCEL);
        if (!(grfKeyState & MK_RBUTTON))
            return (DRAGDROP_S_DROP);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::GiveFeedback()
//
//  PURPOSE:    Allows the drag source to give feedback during a drag-drop.
//              We just let OLE do it's natural thing.
//
//  PARAMETERS: 
//      [in] dwEffect - The effect returned by the drop target.
//
//  RETURN VALUE:
//      DRAGDROP_S_USEDEFAULTCURSORS 
//
STDMETHODIMP CMessageList::GiveFeedback(DWORD dwEffect)
{
    TraceCall("CMessageList::GiveFeedback");
    return (DRAGDROP_S_USEDEFAULTCURSORS);
}


// 
//  FUNCTION:   CMessageList::QueryStatus()
//
//  PURPOSE:    Allows the caller to determine if a command supported by this
//              object is currently enabled or disabled.
//
//  PARAMETERS:
//      [in] pguidCmdGroup - GUID identifing this array of commands
//      [in] cCmds         - Number of commands in prgCmds
//      [in,out] prgCmds   - Array of commands the caller is requesting status for
//      [out] pCmdText     - Status text for the requested command
//
STDMETHODIMP CMessageList::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                       OLECMD *prgCmds, OLECMDTEXT *pCmdText)
{
    DWORD     dwState;
    COLUMN_ID idSort;
    BOOL      fAscending;

    // Verify these commands are ones that we support
    if (pguidCmdGroup && (*pguidCmdGroup != CMDSETID_OEMessageList) && (*pguidCmdGroup != CMDSETID_OutlookExpress))
        return (OLECMDERR_E_UNKNOWNGROUP);

    // Gather some initial information about ourselves
    HWND hwndFocus = GetFocus();
    BOOL fItemFocus = (hwndFocus == m_ctlList) /* || fPreviewFocus */;
    UINT cSel = ListView_GetSelectedCount(m_ctlList);
    int  iSel = ListView_GetFirstSel(m_ctlList);
    int  iFocus = ListView_GetFocusedItem(m_ctlList);
    
    // If the user is trying to get command text, tell them we're too lame
    if (pCmdText)
        return (E_FAIL);
                            
    // Loop through the commands 
    for (DWORD i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // Default to supported.  If it's not, we'll remove it later
            prgCmds[i].cmdf = OLECMDF_SUPPORTED;

            // Check to see if this is the sort menu
            if (prgCmds[i].cmdID >= ID_SORT_MENU_FIRST && prgCmds[i].cmdID <= ID_SORT_MENU_FIRST + m_cSortItems)
            {
                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                if (prgCmds[i].cmdID == m_cSortCurrent)
                    prgCmds[i].cmdf |= OLECMDF_NINCHED;
            }
            else
            {
                switch (prgCmds[i].cmdID)
                {
                    case ID_SAVE_AS:
                        // One item selected and it must be downloaded
                        if (cSel == 1 && iSel != -1 && _IsSelectedMessage(ROW_STATE_HAS_BODY, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_PROPERTIES:
                        // One item is selected
                        if (hwndFocus == m_ctlList)
                        {
                            if (cSel == 1 && _IsSelectedMessage(ROW_STATE_HAS_BODY, TRUE, FALSE))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        else
                        {
                            // If we're in OE we can assume that any children of our 
                            // parent is either us or the preview pane.
                            if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            else
                                prgCmds[i].cmdf = 0;
                        }
                        break;

                    case ID_COPY:
                        // One item is selected and it has it's body, and the focus is in 
                        // the ListView
                        if ((hwndFocus == m_ctlList) && (iSel != -1) && (cSel == 1) && _IsSelectedMessage(ROW_STATE_HAS_BODY, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        else
                        {
                            // Do this so the preview pane get's it.
                            if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
                                prgCmds[i].cmdf = 0;
                        }
                        break;

                    case ID_SELECT_ALL:
                    {
                        DWORD cItems = 0;

                        // The focus must be in the ListView or TreeView and there 
                        // must be items.
                        cItems = ListView_GetItemCount(m_ctlList);

                        if (hwndFocus == m_ctlList)
                        {
                            if (cItems > 0 && ListView_GetSelectedCount(m_ctlList) != cItems)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        else
                        {
                            if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
                                prgCmds[i].cmdf = 0;
                        }
                        break;
                    }

                    case ID_PURGE_DELETED:
                        // only available for IMAP
                        prgCmds[i].cmdf = (GetFolderType(m_idFolder) == FOLDER_IMAP) ? OLECMDF_SUPPORTED|OLECMDF_ENABLED:OLECMDF_SUPPORTED;
                        break;

                    case ID_MOVE_TO_FOLDER:
                        // The current folder cannot be a newsgroup.
                        if (GetFolderType(m_idFolder) != FOLDER_NEWS && cSel != 0)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_COPY_TO_FOLDER:
                        // Something must be selected
                        if (cSel)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;
                 
                    case ID_DELETE:
                    case ID_DELETE_NO_TRASH:
                        // Some of the selected items aren't already deleted
#if 0
                        if (GetFolderType(m_idFolder) != FOLDER_NEWS && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
#endif
                        if (_IsSelectionDeletable() && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_UNDELETE:
                        // Some of the selected items are deleted
                        if ((m_fFindFolder || GetFolderType(m_idFolder) == FOLDER_IMAP) && fItemFocus && 
                            _IsSelectedMessage(ROW_STATE_DELETED, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_FIND_NEXT:
                    case ID_FIND_IN_FOLDER:
                        // There must be something here
                        if (ListView_GetItemCount(m_ctlList))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;
            
                    case ID_SORT_ASCENDING:
                        // Make sure the right one is radio-buttoned
                        m_cColumns.GetSortInfo(&idSort, &fAscending);
                        if (fAscending)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_SORT_DESCENDING:
                        // All of these items always work
                        m_cColumns.GetSortInfo(&idSort, &fAscending);
                        if (!fAscending)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED | OLECMDF_NINCHED;
                        else
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_COLUMNS:
                    case ID_POPUP_SORT:
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_EXPAND:
                        // Expand will only be enabled if the selected item is
                        // expandable, and only if one item is selected.
                        if (cSel == 1 && m_fThreadMessages && iSel != -1)
                        {
                            if (SUCCEEDED(m_pTable->GetRowState(iSel, ROW_STATE_HAS_CHILDREN | ROW_STATE_EXPANDED, &dwState)))
                            {
                                if ((dwState & ROW_STATE_HAS_CHILDREN) && !(dwState & ROW_STATE_EXPANDED))
                                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            }
                        }
                        break;

                    case ID_COLLAPSE:
                        // Collapse is enabled if the selected item is collapsable and
                        // there is only one item selected.
                        if (cSel == 1 && m_fThreadMessages && iSel != -1)
                        {
                            if (SUCCEEDED(m_pTable->GetRowState(iSel, ROW_STATE_HAS_CHILDREN | ROW_STATE_EXPANDED, &dwState)))
                            {
                                if ((dwState & ROW_STATE_HAS_CHILDREN) && (dwState & ROW_STATE_EXPANDED))
                                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            }
                        }
                        break;

                    case ID_NEXT_MESSAGE:
                        // There must be an item focused and the focused item must not be the last item 
                        if ((-1 != iFocus) && (iSel < ListView_GetItemCount(m_ctlList) - 1))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_PREVIOUS:
                        // There must be a focused item and it cannot be the first item
                        if (0 < iFocus)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_NEXT_UNREAD_MESSAGE:
                        // There must be a focused item
                        if (iFocus != -1 /* && (iFocus < ListView_GetItemCount(m_ctlList) - 1) */ )
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_NEXT_UNREAD_THREAD:
                        // There must be a focused item and we must be threaded
                        if ((-1 != iFocus) && m_fThreadMessages /* && (iFocus < ListView_GetItemCount(m_ctlList) - 1) */ )
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_STOP:
                        // We must have a stop callback
                        if (m_pCancel)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_FLAG_MESSAGE:
                        // At least one item must be selected
                        if (cSel != 0)
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                              
                            if (iFocus != -1)
                            {
                                m_pTable->GetRowState(iFocus, ROW_STATE_FLAGGED, &dwState);
                                if (dwState & ROW_STATE_FLAGGED)
                                    prgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }             
                        }
                        break;

                    case ID_MARK_READ:
                        // Some of the selected items are unread
                        if (_IsSelectedMessage(ROW_STATE_READ, FALSE, FALSE) && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_UNREAD:
                        // Some of the selected items are read
                        if (_IsSelectedMessage(ROW_STATE_READ, TRUE, FALSE) && _IsSelectedMessage(ROW_STATE_DELETED, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_ALL_READ:
                        // Must have items in the view that are unread
                        if (ListView_GetItemCount(m_ctlList) > 0)
                        {
                            DWORD dwCount = 0; 

                            if (m_pTable && SUCCEEDED(m_pTable->GetCount(MESSAGE_COUNT_UNREAD, &dwCount)) && dwCount)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        break;

                    case ID_MARK_RETRIEVE_ALL:
                        // Must have items in the view
                        if (GetFolderType(m_idFolder) != FOLDER_LOCAL && ListView_GetItemCount(m_ctlList) > 0)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_POPUP_RETRIEVE:
                        // Always there except local
                        if (GetFolderType(m_idFolder) != FOLDER_LOCAL)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_UNMARK_MESSAGE:
                        if (cSel >= 1 && 
                            _IsSelectedMessage(ROW_STATE_MARKED_DOWNLOAD, TRUE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_RETRIEVE_MESSAGE:
                        // Something must be selected that is not downloaded and does
                        // not already have a body.
                        if (cSel >= 1 && 
                            _IsSelectedMessage(ROW_STATE_MARKED_DOWNLOAD | ROW_STATE_HAS_BODY, FALSE, FALSE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_MARK_THREAD_READ:
                        // The focus is in the listview or preview pane and one item 
                        // is selected. 
                        if (m_fThreadMessages&& 1 == cSel  /* &&
                            _IsSelectedMessage(ROW_STATE_READ, FALSE, FALSE, TRUE) */)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_WATCH_THREAD:
                        // At least one item must be selected
                        if (cSel > 0)
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                              
                            if (iFocus != -1)
                            {
                                m_pTable->GetRowState(iFocus, ROW_STATE_WATCHED, &dwState);
                                if (dwState & ROW_STATE_WATCHED)
                                    prgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }             
                        }
                        break;

                    case ID_IGNORE_THREAD:
                        // At least one item must be selected
                        if (cSel > 0)
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                              
                            if (iFocus != -1)
                            {
                                m_pTable->GetRowState(iFocus, ROW_STATE_IGNORED, &dwState);
                                if (dwState & ROW_STATE_IGNORED)
                                    prgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }             
                        }
                        break;

                    case ID_MARK_RETRIEVE_THREAD:
                        // The focus is in the listview or preview pane and one item 
                        // is selected. 
                        if (m_fThreadMessages && 1 == cSel &&
                            _IsSelectedMessage(ROW_STATE_MARKED_DOWNLOAD | ROW_STATE_HAS_BODY, FALSE, FALSE, TRUE))
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_REFRESH_INNER:
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    case ID_GET_HEADERS:
                        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        break;

                    default:
                        prgCmds[i].cmdf = 0;
                }
            }
        }
    }

    return (S_OK);
}

                                           
STDMETHODIMP CMessageList::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                                VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // Verify these commands are ones that we support
    if (pguidCmdGroup && (*pguidCmdGroup != CMDSETID_OutlookExpress))
        return (OLECMDERR_E_UNKNOWNGROUP);

    // Check first to see if this is our sort menu
    if (nCmdID >= ID_SORT_MENU_FIRST && nCmdID < (ID_SORT_MENU_FIRST + m_cSortItems))
    {
        DWORD rgOrder[COLUMN_MAX];
        DWORD cOrder;

        // Get the count of columns in the header
        HWND hwndHeader = ListView_GetHeader(m_ctlList);
        cOrder = Header_GetItemCount(hwndHeader);

        // The columns might have been reordered by the user, so get the order 
        // arrray from the ListView
        ListView_GetColumnOrderArray(m_ctlList, cOrder, rgOrder);

        _OnColumnClick(rgOrder[nCmdID - ID_SORT_MENU_FIRST], LIST_SORT_DEFAULT);
        return (S_OK);
    }

    // Dispatch the commands appropriately
    switch (nCmdID)
    {
        case ID_SAVE_AS:
            return CmdSaveAs(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_PROPERTIES:
            return CmdProperties(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COPY:
            return CmdCopyClipboard(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_SELECT_ALL:
            return CmdSelectAll(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_PURGE_DELETED:
            return CmdPurgeFolder(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_MOVE_TO_FOLDER:
        case ID_COPY_TO_FOLDER:
            // We don't know where user wants to put message, so
            // set pvaIn param to NULL
            return CmdMoveCopy(nCmdID, nCmdExecOpt, NULL, pvaOut);

        case ID_DELETE:
        case ID_DELETE_NO_TRASH:
        case ID_UNDELETE:
            return CmdDelete(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_FIND_NEXT:
            return CmdFindNext(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
            
        case ID_FIND_IN_FOLDER:
            return CmdFind(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_SORT_ASCENDING:
        case ID_SORT_DESCENDING:
            return CmdSort(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COLUMNS:
            return CmdColumnsDlg(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_EXPAND:
        case ID_COLLAPSE:
            return CmdExpandCollapse(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_NEXT_MESSAGE:
        case ID_PREVIOUS:
        case ID_NEXT_UNREAD_MESSAGE:
        case ID_NEXT_UNREAD_THREAD:
            return CmdGetNextItem(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_STOP:
            return CmdStop(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_FLAG_MESSAGE:
        case ID_MARK_READ:
        case ID_MARK_UNREAD:
        case ID_MARK_ALL_READ:
        case ID_MARK_RETRIEVE_ALL:
        case ID_MARK_RETRIEVE_MESSAGE:
        case ID_UNMARK_MESSAGE:
            return CmdMark(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_WATCH_THREAD:
        case ID_IGNORE_THREAD:
            return CmdWatchIgnore(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_MARK_THREAD_READ:
        case ID_MARK_RETRIEVE_THREAD:
            return CmdMarkTopic(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REFRESH_INNER:
            return CmdRefresh(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_GET_HEADERS:
            return CmdGetHeaders(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_RESYNCHRONIZE:
            return Resynchronize();

        case ID_SPACE_ACCEL:
            return CmdSpaceAccel(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
    }

    return (OLECMDERR_E_NOTSUPPORTED);
}


//
//  FUNCTION:   CMessageList::SetFolder()
//
//  PURPOSE:    Tells the Message List to view the contents of the specified 
//              folder.
//
//  PARAMETERS: 
//      [in] tyStore
//      [in] pAccountId
//      [in] pFolderId
//      [in] pSync
//
STDMETHODIMP CMessageList::SetFolder(FOLDERID idFolder, IMessageServer *pServer,
                                     BOOL fSubFolders, FINDINFO *pFindInfo, 
                                     IStoreCallback *pCallback)
{
    HRESULT           hr = S_OK;
    IServiceProvider *pSP=NULL;
    ULONG             ulDisplay;
    DWORD             dwChunks, dwPollInterval;
    COLUMN_ID         idSort;
    BOOL              fAscending;
    FOLDERINFO        fiFolderInfo;
    FOLDERSORTINFO    SortInfo;
    IMessageFolder   *pFolder;
    FOLDERUSERDATA    UserData = {0};

    TraceCall("CMessageList::SetFolder");

    // If we already have a message table, release it.
    if (m_pTable)
    {
        // Unload the ListView
        if (IsWindow(m_ctlList))
        {
            ListView_UnSelectAll(m_ctlList);
            ListView_SetItemCount(m_ctlList, 0);
        }
        m_pTable->ConnectionRelease();
        m_pTable->Close();
        m_pTable->Release();
        m_pTable = NULL;
    }

    // If the caller passed FOLDERID_INVALID, then we don't load a new table
    if (idFolder == FOLDERID_INVALID)
        goto exit;

    // Create a Message Table
    IF_NULLEXIT(m_pTable = new CMessageTable);

    // Tell the table which folder to look at
    if (FAILED(hr = m_pTable->Initialize(idFolder, pServer, pFindInfo ? TRUE : FALSE, this)))
    {
        m_pTable->Release();
        m_pTable = 0;
        goto exit;
    }

    m_pTable->ConnectionAddRef();
    m_pTable->SetOwner(this);

    // Command Target ?
    if (FAILED(m_pTable->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)))
        goto exit;

    // Get the IMessageFolder from the Table
    if (FAILED(pSP->QueryService(IID_IMessageFolder, IID_IMessageFolder, (LPVOID *)&pFolder)))
        goto exit;
        
    // Get the user data to get the filter id
    if (FAILED(pFolder->GetUserData(&UserData, sizeof(FOLDERUSERDATA))))
        goto exit;

    m_ridFilter = UserData.ridFilter;

    // If this is a find, then get the folder id from the table
    if (pFindInfo)
    {
        // Get the Real folder id
        pFolder->GetFolderId(&m_idFolder);
    }
    // Otherwise, just use id idFolder
    else
    {
        // Hang on to this
        m_idFolder = idFolder;
    }

    // Release pFolder
    pFolder->Release();
        
    hr = g_pStore->GetFolderInfo(m_idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {   
        m_fJunkFolder = (FOLDER_LOCAL == fiFolderInfo.tyFolder) && (FOLDER_JUNK == fiFolderInfo.tySpecial);
        m_fMailFolder = (FOLDER_LOCAL == fiFolderInfo.tyFolder) || (FOLDER_IMAP == fiFolderInfo.tyFolder) || (FOLDER_HTTPMAIL == fiFolderInfo.tyFolder);
        m_fGroupSubscribed = !!(fiFolderInfo.dwFlags & FOLDER_SUBSCRIBED);
        g_pStore->FreeRecord(&fiFolderInfo);
    }
    else
        m_fMailFolder = FALSE;

    // Set up our columns
    m_fFindFolder = pFindInfo != 0;
    _SetColumnSet(m_idFolder, m_fFindFolder);

    // Set Sort Information
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Tell the table to change its sort order
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);
    
    // Register Notify
    m_pTable->RegisterNotify(REGISTER_NOTIFY_NOADDREF, (IMessageTableNotify *) this);

    // Get the new count of items in the table
    m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &ulDisplay);

    // Tell the ListView about it
    ListView_SetItemCountEx(m_ctlList, ulDisplay, LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

    if (m_fThreadMessages)
        ListView_SetImageList(m_ctlList, GetImageList(GIML_STATE), LVSIL_STATE);
    else
        ListView_SetImageList(m_ctlList, NULL, LVSIL_STATE);

    // Tell the table to go sync any headers from the server
    if (GetFolderType(m_idFolder) == FOLDER_NEWS)
    {
        if (OPTION_OFF != m_dwGetXHeaders)
            hr = m_pTable->Synchronize(SYNC_FOLDER_XXX_HEADERS | SYNC_FOLDER_NEW_HEADERS, m_dwGetXHeaders, this);
        else
            hr = m_pTable->Synchronize(NOFLAGS, 0, this);
    }
    else
    {
        hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
    }

    // Check to see if we need to put up the empty list warning.
    if (!pFindInfo && 0 == ulDisplay && ((FAILED(hr) && hr != E_PENDING) || hr == S_FALSE))
    {
        m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
    }

    // Set any options
    //_FilterView(m_ridFilter);
    
    // Update the focused item
    _SelectDefaultRow();

    // Update the status
    Fire_OnMessageCountChanged(m_pTable);
    
    // Send the update notification
    Fire_OnFilterChanged(m_ridFilter);

    // Tell the table which folder to look at
    if (pFindInfo)
    {
        // Execute the find
        m_pTable->StartFind(pFindInfo, pCallback);
    }

    if (m_dwPollInterval != OPTION_OFF)
    {
        FOLDERTYPE  ftFolderType;

        ftFolderType = GetFolderType(m_idFolder);
        if (FOLDER_NEWS == ftFolderType || FOLDER_IMAP == ftFolderType)
        {
            if (_PollThisAccount(m_idFolder))
            {
                Assert(m_dwPollInterval);
                UpdateConnInfo();
                SetTimer(IDT_POLLMSGS_TIMER, m_dwPollInterval, NULL);
            }
        }
    }

exit:
    SafeRelease(pSP);
    return (hr);
}


//
//  FUNCTION:   CMessageList::GetSelected()
//
//  PURPOSE:    Returns an array of all the selected rows.
//
//  PARAMETERS: 
//      [out] pcSelected - Pointer to the number of items in prgSelected
//      [out] prgSelected - Array containing the rows that are selected
//
//  RETURN VALUE:
//      
//
STDMETHODIMP CMessageList::GetSelected(DWORD *pdwFocused, DWORD *pcSelected, DWORD **prgSelected)
{
    TraceCall("CMessageList::GetSelected");

    // If one is focused, do that first
    if (pdwFocused)
        *pdwFocused = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);

    // First determine how many are selected
    if (pcSelected)
    {
        *pcSelected = ListView_GetSelectedCount(m_ctlList);

        if (prgSelected)
        {
            // If nothing is selected, bail
            if (*pcSelected == 0)
            {
                *prgSelected = NULL;
                return (S_OK);
            }

            // Allocate an array for the selected rows
            if (!MemAlloc((LPVOID *) prgSelected, (sizeof(DWORD) * (*pcSelected))))
                return (E_OUTOFMEMORY);
        
            DWORD *pRow = *prgSelected;

            // Loop through all the selected rows
            int iRow = -1;
            while (-1 != (iRow = ListView_GetNextItem(m_ctlList, iRow, LVNI_SELECTED)))
            {
                *pRow = iRow;
                pRow++;
            }
        }
    }
    
    return S_OK;
}


//
//  FUNCTION:   CMessageList::GetSelectedCount()
//
//  PURPOSE:    Allows the caller to retrieve the number of selected rows in
//              the ListView.
//
//  PARAMETERS: 
//      [out] pdwCount - Returns the number of selected rows.
//
//  RETURN VALUE:
//      S_OK, E_INVALIDARG 
//
STDMETHODIMP CMessageList::GetSelectedCount(DWORD *pdwCount)
{
    TraceCall("CMessageList::GetSelectedCount");

    if (!pdwCount)
        return (E_INVALIDARG);

    *pdwCount = ListView_GetSelectedCount(m_ctlList);
    return S_OK;
}


//
//  FUNCTION:   CMessageList::SetViewOptions()
//
//  PURPOSE:    Allows the caller to set various options that control how
//              we display the list of messages.
//
//  PARAMETERS: 
//      [in] pOptions - Struct containing the settings the caller want's 
//                      changed.
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::SetViewOptions(FOLDER_OPTIONS *pOptions)
{
    BOOL fUpdateSort = FALSE;

    TraceCall("CMessageList::SetViewOptions");

    if (!pOptions || pOptions->cbSize != sizeof(FOLDER_OPTIONS))
        return (E_INVALIDARG);

    // Thread Messages
    if (pOptions->dwMask & FOM_THREAD)
    {
        if (m_fThreadMessages != pOptions->fThread)
        {
            m_fThreadMessages = pOptions->fThread;
        }
    }

    // Auto Expand Threads
    if (pOptions->dwMask & FOM_EXPANDTHREADS)
    {
        // Only set this if the value is different
        if (pOptions->fExpandThreads != m_fAutoExpandThreads)
        {
            // Save the setting
            m_fAutoExpandThreads = !!pOptions->fExpandThreads;
            fUpdateSort = TRUE;        
        }    
    }

    // Select first unread message 
    if (pOptions->dwMask & FOM_SELECTFIRSTUNREAD)
    {
        if (m_fSelectFirstUnread != pOptions->fSelectFirstUnread)
        {
            // Save the value.  We don't change any selection however.
            m_fSelectFirstUnread = pOptions->fSelectFirstUnread;
        }
    }

    // Message List Tips
    if (pOptions->dwMask & FOM_MESSAGELISTTIPS)
    {
#ifdef OLDTIPS
        m_fViewTip = pOptions->fMessageListTips;
#endif // OLDTIPS
        m_fScrollTip = pOptions->fMessageListTips;
    }

    // Watched message color
    if (pOptions->dwMask & FOM_COLORWATCHED)
    {
        m_clrWatched = pOptions->clrWatched;
        m_ctlList.InvalidateRect(0, 0);
    }

    // Download chunks
    if (pOptions->dwMask & FOM_GETXHEADERS)
    {
        m_dwGetXHeaders = pOptions->dwGetXHeaders;
    }

    // Show Deleted messages
    if (pOptions->dwMask & FOM_SHOWDELETED)
    {
        m_fShowDeleted = pOptions->fDeleted;
    }

    // Show Deleted messages
    if (pOptions->dwMask & FOM_SHOWREPLIES)
    {
        m_fShowReplies = m_fThreadMessages ? pOptions->fReplies : FALSE;
    }

    if (fUpdateSort)
    {
        if (m_pTable)
        {
            COLUMN_ID idSort;
            BOOL fAscending;
            FOLDERSORTINFO SortInfo;

            // Get the current sort information
            m_cColumns.GetSortInfo(&idSort, &fAscending);

            // Get the current selection
            DWORD iSel = ListView_GetFirstSel(m_ctlList);

            // Bookmark the current selection
            MESSAGEID idSel = 0;
            if (iSel != -1)
                m_pTable->GetRowMessageId(iSel, &idSel);

            // Fill a SortInfo
            SortInfo.idColumn = idSort;
            SortInfo.fAscending = fAscending;
            SortInfo.fThreaded = m_fThreadMessages;
            SortInfo.fExpandAll = m_fAutoExpandThreads;
            SortInfo.ridFilter = m_ridFilter;
            SortInfo.fShowDeleted = m_fShowDeleted;
            SortInfo.fShowReplies = m_fShowReplies;

            // Update the message list
            m_pTable->SetSortInfo(&SortInfo, this);

            // Make sure the filter got set correctly
            _DoFilterCheck(SortInfo.ridFilter);
            
            // Reset the list view
            _ResetView(idSel);
        }

        // Update the count of items 
        _UpdateListViewCount();
    }

    if (pOptions->dwMask & FOM_POLLTIME)
    {
        if (pOptions->dwPollTime != m_dwPollInterval)
        {
            FOLDERTYPE  ftFolderType;

            ftFolderType = GetFolderType(m_idFolder);

            if (m_pTable != NULL &&
                ((ftFolderType == FOLDER_NEWS) || (ftFolderType == FOLDER_IMAP)))
            {
                if (pOptions->dwPollTime == OPTION_OFF)
                {
                    KillTimer(IDT_POLLMSGS_TIMER);
                }
                else
                {
                    Assert(pOptions->dwPollTime != 0);
                    SetTimer(IDT_POLLMSGS_TIMER, pOptions->dwPollTime, NULL);
                }
            }

            m_dwPollInterval = pOptions->dwPollTime;
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::GetViewOptions()
//
//  PURPOSE:    Allows the caller to get various options that control how
//              we display the list of messages.
//
//  PARAMETERS: 
//      [in] pOptions - Struct containing the settings the caller want's 
//                      changed.
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::GetViewOptions(FOLDER_OPTIONS *pOptions)
{
    BOOL fUpdateSort = FALSE;

    TraceCall("CMessageList::GetViewOptions");

    if (!pOptions || pOptions->cbSize != sizeof(FOLDER_OPTIONS))
        return (E_INVALIDARG);

    // Thread Messages
    if (pOptions->dwMask & FOM_THREAD)
        pOptions->fThread = m_fThreadMessages;

    // Auto Expand Threads
    if (pOptions->dwMask & FOM_EXPANDTHREADS)
        pOptions->fExpandThreads = m_fAutoExpandThreads;

    // Select first unread message 
    if (pOptions->dwMask & FOM_SELECTFIRSTUNREAD)
        pOptions->fSelectFirstUnread = m_fSelectFirstUnread;

    // Message List Tips
    if (pOptions->dwMask & FOM_MESSAGELISTTIPS)
        pOptions->fMessageListTips = m_fViewTip;

    // Watched message color
    if (pOptions->dwMask & FOM_COLORWATCHED)
        pOptions->clrWatched = m_clrWatched;

    // Download chunks
    if (pOptions->dwMask & FOM_GETXHEADERS)
        pOptions->dwGetXHeaders = m_dwGetXHeaders;

    // Show Deleted messages
    if (pOptions->dwMask & FOM_SHOWDELETED)
        pOptions->fDeleted = m_fShowDeleted;

    // Show Replies messages
    if (pOptions->dwMask & FOM_SHOWREPLIES)
        pOptions->fReplies = m_fShowReplies;

    return (S_OK);
}

HRESULT CMessageList::GetRowFolderId(DWORD dwRow, LPFOLDERID pidFolder)
{
    HRESULT hr;

    TraceCall("CMessageList::GetRowFolderId");

    if (!pidFolder || !m_pTable)
        return (E_INVALIDARG);

    hr = m_pTable->GetRowFolderId(dwRow, pidFolder);
    return (hr);
}

//
//  FUNCTION:   CMessageList::GetMessageInfo()
//
//  PURPOSE:    Allows the caller to retreive the message header information
//              for a particular row.
//
//  PARAMETERS: 
//      [in]  dwRow - Row the caller is interested in
//      [out] pMsgInfo - Returned structure containing the information
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageList::GetMessageInfo(DWORD dwRow, MESSAGEINFO **ppMsgInfo)
{
    HRESULT hr;

    TraceCall("CMessageList::GetMessageInfo");

    if (!ppMsgInfo || !m_pTable)
        return (E_INVALIDARG);

    hr = m_pTable->GetRow(dwRow, ppMsgInfo);
    return (hr);
}

HRESULT CMessageList::MarkMessage(DWORD dwRow, MARK_TYPE mark)
{
    HRESULT hr;

    TraceCall("CMessageList::MarkMessage");

    if (!m_pTable)
        return (E_INVALIDARG);

    hr = m_pTable->Mark(&dwRow, 1, APPLY_SPECIFIED, mark, this);
    return (hr);
}

HRESULT CMessageList::FreeMessageInfo(MESSAGEINFO *pMsgInfo)
{
    TraceCall("CMessageList::FreeMessageInfo");

    if (!pMsgInfo || !m_pTable)
        return (E_INVALIDARG);

    return m_pTable->ReleaseRow(pMsgInfo);
}

//
//  FUNCTION:   CMessageList::GetSelectedMessage()
//
//  PURPOSE:    Returns the contents of the selected message.
//
//  PARAMETERS: 
//      [out] ppMsg - 
//      [in] pfMarkRead
//      BOOL fDownload
//      LONG * pidErr
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::GetMessage(DWORD dwRow, BOOL fDownload, BOOL fBookmark, IUnknown ** ppMsg)
{
    DWORD   iSel=dwRow;
    BOOL    fCached;
    HRESULT hr = E_FAIL;
    DWORD   dwState;
    DWORD   flags = 0;
    IMimeMessage *pMessage = 0;

    TraceCall("CMessageList::GetSelectedMessage");

    if (!ppMsg)
        return (E_INVALIDARG);

    // If we don't have a table, this will be really hard.
    if (!m_pTable)
        return (E_UNEXPECTED);

    // Initialize these
    *ppMsg = NULL;

    // Get the row state to see if it already has a body or not
    m_pTable->GetRowState(dwRow, ROW_STATE_HAS_BODY | ROW_STATE_READ, &dwState);

    // If the row does not have a body and we're not allowed to download the
    // message, then we bail.
    if ((ROW_STATE_HAS_BODY != (dwState & ROW_STATE_HAS_BODY)) && !fDownload)
    {
        return (STORE_E_NOBODY);
    }

    // Try to retrieve the message
    hr = m_pTable->OpenMessage(dwRow, 0, &pMessage, 
                               (IStoreCallback *) this);
    if (pMessage)
        pMessage->QueryInterface(IID_IUnknown, (LPVOID *) ppMsg);

    // If the caller wanted us to bookmark this row, do it
    if (FAILED(m_pTable->GetRowMessageId(ListView_GetFocusedItem(m_ctlList), &m_idGetMsg)))
        m_idGetMsg = 0;

    SafeRelease(pMessage);
    return (hr);
}


//
//  FUNCTION:   CMessageList::OnClose()
//
//  PURPOSE:    Called to tell the list to persist it's settings.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageList::OnClose(void)
{
    FOLDERINFO info;
    HRESULT hr;
    char sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];

    if (Header_GetItemCount(ListView_GetHeader(m_ctlList)))
    {
        // Save the column set only if there are columns in the listview
        m_cColumns.Save(0, 0);
    }
    
    hr = g_pStore->GetFolderInfo(m_idFolder, &info);
    if (SUCCEEDED(hr))
    {
        if (info.tyFolder == FOLDER_NEWS)
        {
            if (0 == (info.dwFlags & FOLDER_SUBSCRIBED) && !m_fGroupSubscribed)
            {
                AthLoadString(idsWantToSubscribe, sz, ARRAYSIZE(sz));
                wsprintf(szT, sz, info.pszName);

                if (IDYES == DoDontShowMeAgainDlg(m_hWnd, c_szRegAskSubscribe, MAKEINTRESOURCE(idsAthena), szT, MB_YESNO))
                {
                    g_pStore->SubscribeToFolder(m_idFolder, TRUE, NOSTORECALLBACK);
                }
            }

            // If this is a newsgroup, and the user has the option to "Mark All Read when ...",
            // then mark everything read
            if (DwGetOption(OPT_MARKALLREAD))
            {
                if (m_pTable)
                    m_pTable->Mark(NULL, 0, APPLY_SPECIFIED, MARK_MESSAGE_READ, this);
            }
        }

        g_pStore->FreeRecord(&info);
    }

    if (m_pTable)
    {
        IServiceProvider *pService;

        m_pTable->UnregisterNotify((IMessageTableNotify *)this);

        if (SUCCEEDED(m_pTable->QueryInterface(IID_IServiceProvider, (void **)&pService)))
        {
            IIMAPStore *pIMAPStore;

            if (SUCCEEDED(pService->QueryService(SID_MessageServer, IID_IIMAPStore, (void **)&pIMAPStore)))
            {
                pIMAPStore->ExpungeOnExit();
                pIMAPStore->Release();
            }

            pService->Release();
        }
    }

    // Release our view pointer
    SafeRelease(m_pCmdTarget);

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::SetRect()
//
//  PURPOSE:    Allows the caller to position the control window.
//
//  PARAMETERS: 
//      RECT rc
//
//  RETURN VALUE:
//      STDMETHODIMP 
//
STDMETHODIMP CMessageList::SetRect(RECT rc)
{
    TraceCall("CMessageList::SetRect");

    if (IsWindow(m_hWnd))
    {
        // Update the position of our window
        SetWindowPos(NULL, rc.left, rc.top, rc.right, rc.bottom, SWP_NOACTIVATE | SWP_NOZORDER);
    }
    return S_OK;
}


//
//  FUNCTION:   CMessageList::GetRect()
//
//  PURPOSE:    Allows the caller to get the position of the outer control window.
//
//  PARAMETERS: 
//      [out] prcList - contains the position of the window if visible.
//
STDMETHODIMP CMessageList::GetRect(LPRECT prcList)
{
    TraceCall("CMessageList::GetRect");

    // Make sure the caller gave us a return value pointer
    if (!prcList)
        return (E_INVALIDARG);

    // If the window exists
    if (IsWindow(m_hWnd))
    {
        // Get the rect for it
        GetWindowRect(prcList);
        return (S_OK);
    }

    return (E_FAIL);
}


STDMETHODIMP CMessageList::MarkRead(BOOL fBookmark, DWORD dwRow)
{
    ROWINDEX iRow = -1;
    HRESULT  hr = S_OK;
    DWORD    dwState = 0;

    // Figure out which row to mark
    if (fBookmark)
        hr = m_pTable->GetRowIndex(m_idGetMsg, &iRow);
    else
        iRow = dwRow;

    if (SUCCEEDED(hr))
    {
        // Check to see if the message is actually unread
        if (SUCCEEDED(m_pTable->GetRowState(iRow, ROW_STATE_READ, &dwState)))
        {
            if ((ROW_STATE_READ & dwState) == 0)
            {
                hr = m_pTable->Mark(&iRow, 1, APPLY_SPECIFIED, MARK_MESSAGE_READ, this);

                if (m_fInOE && m_fMailFolder && NULL != g_pInstance)
                    g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
            }
        }
    }
    return (hr);
}

STDMETHODIMP CMessageList::ProcessReceipt(IMimeMessage *pMessage)
{
    ROWINDEX iRow = -1;
    HRESULT  hr = S_OK;
    DWORD    dwState = 0;

    hr = m_pTable->GetRowIndex(m_idGetMsg, &iRow);
    if (SUCCEEDED(hr))
    {
        ProcessReturnReceipts(m_pTable, (IStoreCallback*)this, iRow, READRECEIPT, m_idFolder, pMessage);
    }
    return (hr);
}

STDMETHODIMP CMessageList::GetMessageTable(IMessageTable **ppTable) 
{
    if (ppTable) 
    {
        *ppTable = m_pTable;
        m_pTable->AddRef();
        return S_OK;
    }

    return E_INVALIDARG;
}


STDMETHODIMP CMessageList::GetListSelector(IListSelector **ppListSelector)
{
    if (ppListSelector) 
    {
        Assert(m_pListSelector);
        *ppListSelector = m_pListSelector;
        m_pListSelector->AddRef();
        return S_OK;
    }

    return E_INVALIDARG;
}


STDMETHODIMP CMessageList::GetMessageCounts(DWORD *pcTotal, DWORD *pcUnread, DWORD *pcOnServer)
{
    if (pcTotal && pcUnread && pcOnServer)
    {
        // If we haven't been initialized with a table yet, everything is zero
        if (!m_pTable)
        {
            *pcTotal = 0;
            *pcUnread = 0;
            *pcOnServer = 0;
        }
        else
        {
            m_pTable->GetCount(MESSAGE_COUNT_ALL, pcTotal);
            m_pTable->GetCount(MESSAGE_COUNT_UNREAD, pcUnread);
            m_pTable->GetCount(MESSAGE_COUNT_NOTDOWNLOADED, pcOnServer);
        }

        return (S_OK);
    }
    
    return (E_INVALIDARG);
}


STDMETHODIMP CMessageList::GetMessageServer(IMessageServer **ppServer)
{
    IServiceProvider *pSP = NULL;
    HRESULT           hr = E_FAIL;

    
    // HACKHACK: BUG #43642. This method is called by the msgview when it is fishing for a server
    // object so that is can reuse the connection. If there is an operation in progress, then we
    // don't want to use this connection as it may take a while to complete, so we fail this
    // and the msgview makes a new server object
    if (m_tyCurrent != SOT_INVALID)
        return E_FAIL;

        if (m_pTable && SUCCEEDED(m_pTable->QueryInterface(IID_IServiceProvider, (LPVOID *) &pSP)))
        {
            hr = pSP->QueryService(SID_MessageServer, IID_IMessageServer, (LPVOID *) ppServer);
            pSP->Release();    
        }
    return (hr);
}


STDMETHODIMP CMessageList::GetFocusedItemState(DWORD *pdwState)
{
    int iFocused;
    
    if (!pdwState)
        return (E_INVALIDARG);

    // Figure out who has the focus
    iFocused = ListView_GetFocusedItem(m_ctlList);

    // It's possible for nothing to be focused
    if (-1 == iFocused)
    {
        iFocused = 0;
        ListView_SetItemState(m_ctlList, iFocused, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    // Check to see if that item is selected
    *pdwState = ListView_GetItemState(m_ctlList, iFocused, LVIS_SELECTED);

    return (S_OK);
}


STDMETHODIMP CMessageList::CreateList(HWND hwndParent, IUnknown *pFrame, HWND *phwndList)
{
    HWND hwnd;
    RECT rcPos = { 0, 0, 10, 10 };

    hwnd = CreateControlWindow(hwndParent, rcPos);
    if (phwndList)
        *phwndList = hwnd;

    // Get the command target from the frame
    Assert(pFrame);

    pFrame->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pCmdTarget);

    // This is only called to create us as part of OE
    m_fInOE = TRUE;

    if (g_pConMan)
    {
        g_pConMan->Advise((IConnectionNotify*)this);
    }

    return (S_OK);
}



//
//  FUNCTION:   CMessageList::OnPreFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache before it changes the fonts we're 
//              using.  In response we tell the ListView to dump any custom 
//              font's it's using.
//
STDMETHODIMP CMessageList::OnPreFontChange(void)
{
    m_ctlList.SendMessage(WM_SETFONT, 0, 0);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnPostFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache after it updates the font's we're
//              using.  In response, we set the new font for the current charset.
//
STDMETHODIMP CMessageList::OnPostFontChange(void)
{
    m_hCharset = GetListViewCharset();
    SetListViewFont(m_ctlList, m_hCharset, TRUE);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnCreate()
//
//  PURPOSE:    Creates our child control, initializes options on that ListView, 
//              and initializes the columns and font in that ListView.
//
LRESULT CMessageList::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnCreate");

    RECT rcPos = {0, 0, 10, 10};

    // Create the ListView control first
    HWND hwndList;
    hwndList = m_ctlList.Create(m_hWnd, rcPos, "Outlook Express Message List", WS_CHILD | WS_VISIBLE |  
                     WS_TABSTOP | WS_CLIPCHILDREN | LVS_SHOWSELALWAYS |  
                     LVS_OWNERDATA | LVS_SHAREIMAGELISTS | LVS_REPORT |
                     WS_BORDER, WS_EX_CLIENTEDGE);

    if (!hwndList)
        return (-1);


    // Get the listview charset
    m_hCharset = GetListViewCharset();

    // Set the callback mask and image lists
    ListView_SetCallbackMask(m_ctlList, LVIS_STATEIMAGEMASK);
    ListView_SetImageList(m_ctlList, GetImageList(GIML_SMALL), LVSIL_SMALL);
    
    // Set some extended styles
    ListView_SetExtendedListViewStyle(m_ctlList, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_INFOTIP);
    // ListView_SetExtendedListViewStyleEx(m_ctlList, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_INFOTIP | LVS_EX_LABELTIP, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_INFOTIP | LVS_EX_LABELTIP);

    // Initialize the columns class
    m_cColumns.Initialize(m_ctlList, m_ColumnSetType);

    // Set the font for the ListView
    m_ctlList.SendMessage(WM_SETFONT, NULL, 0);
    SetListViewFont(m_ctlList, m_hCharset, TRUE);
 
#ifdef OLDTIPS
    // Create the tooltips second
    m_ctlScrollTip.Create(m_hWnd, rcPos, NULL, TTS_NOPREFIX);

    // Add the tool
    TOOLINFO ti = {0};
    ti.cbSize   = sizeof(TOOLINFO);
    ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd     = m_hWnd;
    ti.uId      = (UINT_PTR)(HWND) m_ctlList;
    ti.lpszText = "";
    
    m_ctlScrollTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM) &ti);

    // Create the ListView tooltip
    if (m_fViewTip)
    {
        m_ctlViewTip.Create(m_hWnd, rcPos, NULL, TTS_NOPREFIX);

        // Add the tool
        ti.cbSize   = sizeof(TOOLINFO);
        ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd     = m_hWnd;
        ti.uId      = (UINT_PTR)(HWND) m_ctlList;
        ti.lpszText = "";
        ti.lParam   = 0;

        m_ctlViewTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM) &ti);
        m_ctlViewTip.SendMessage(TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM) 500);

        // m_ctlViewTip.SendMessage(TTM_SETTIPBKCOLOR, GetSysColor(COLOR_WINDOW), 0);
        // m_ctlViewTip.SendMessage(TTM_SETTIPTEXTCOLOR, GetSysColor(COLOR_WINDOWTEXT), 0);
    }
#endif // OLDTIPS

#if 0
    // $REVIEW - Debug create the table 
    ACCOUNTID aid;
    aid.type = ACTID_NAME;
    aid.pszName = _T("red-msg-52");

    FOLDERID fid;
    fid.type = FLDID_HFOLDER;
    fid.hFolder = 1;
    SetFolder(STORE_ACCOUNT, &aid, &fid, NULL, NULL);
#endif

    // If there is a global font cache running around, register for
    // notifications.
    if (g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Advise((IUnknown *)(IFontCacheNotify *) this, &m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    // Do this so we can hand this badboy off to the notes
    m_pListSelector = new CListSelector();
    if (m_pListSelector)
        m_pListSelector->Advise(m_hWnd);

    return (0);
}


LRESULT CMessageList::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Let the base classes have a crack at it
    CComControlBase::OnSetFocus(uMsg, wParam, lParam, bHandled);

    // Make sure the focus is set to the ListView
    m_ctlList.SetFocus();

    return (0);
}


LRESULT CMessageList::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    int iSel;

    // Resize the ListView to fit within the parent window
    if (IsWindow(m_ctlList))
    {
        m_ctlList.SetWindowPos(NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), 
                               SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

        // Make sure the selected item is still visible
        iSel = ListView_GetFocusedItem(m_ctlList);
        if (-1 != iSel)
            ListView_EnsureVisible(m_ctlList, iSel, FALSE);
    }

    return (0);
}


//
//  FUNCTION:   CMessageList::OnNotify()
//
//  PURPOSE:    Processes notification messages from our ListView.
//
LRESULT CMessageList::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR            *pnmhdr = (LPNMHDR) lParam;
    NM_LISTVIEW      *pnmlv =  (NM_LISTVIEW *) lParam;
    HD_NOTIFY        *phdn =   (HD_NOTIFY *) lParam;
    LV_KEYDOWN       *plvkd =  (LV_KEYDOWN *) lParam;
    NM_ODSTATECHANGE *pnm =    (PNM_ODSTATECHANGE) lParam;
    NMLVCACHEHINT    *plvch =  (NMLVCACHEHINT *) lParam;

    switch (pnmhdr->code)
    {
        // Send the cache hint's to the message table
        case LVN_ODCACHEHINT:
        {
            //m_pTable->CacheHint(plvch->iFrom, plvch->iTo);
            break;
        }

        // Open the selected items
        case LVN_ITEMACTIVATE:
        {
            // Tell our host to open the selected items
            Fire_OnItemActivate();
            break;
        }

        // This notification is only used for threading.  All activation is 
        // handled by LVN_ITEMACTIVATE and NM_DBLCLK
        case NM_CLICK:
        {
            if (pnmhdr->hwndFrom == m_ctlList)
            {
                DWORD          dwPos;
                LV_HITTESTINFO lvhti;

                // Find out where the click happened
                dwPos = GetMessagePos();
                lvhti.pt.x = (int)(short) LOWORD(dwPos);
                lvhti.pt.y = (int)(short) HIWORD(dwPos);
                m_ctlList.ScreenToClient(&lvhti.pt);

                // Have the ListView tell us what element this was on
                if (-1 != ListView_SubItemHitTest(m_ctlList, &lvhti))
                {
                    if (lvhti.flags & LVHT_ONITEM)
                    {
                        if (m_cColumns.GetId(lvhti.iSubItem) == COLUMN_FLAG)
                        {
                            CmdMark(ID_FLAG_MESSAGE, 0, NULL, NULL);
                            break;
                        }

                        if (m_cColumns.GetId(lvhti.iSubItem) == COLUMN_DOWNLOADMSG)
                        {
                            HRESULT hr;
                            DWORD nCmdID, dwState = 0;

                            hr = m_pTable->GetRowState(lvhti.iItem, ROW_STATE_MARKED_DOWNLOAD, &dwState);
                            Assert(SUCCEEDED(hr));
        
                            if (!!(dwState & ROW_STATE_MARKED_DOWNLOAD))
                                nCmdID = ID_UNMARK_MESSAGE;
                            else
                                nCmdID = ID_MARK_RETRIEVE_MESSAGE;

                            CmdMark(nCmdID, 0, NULL, NULL);
                            break;
                        }
                        
                        if (m_cColumns.GetId(lvhti.iSubItem) == COLUMN_THREADSTATE)
                        {
                            HRESULT hr;
                            DWORD nCmdID, dwState = 0;

                            hr = m_pTable->GetRowState(lvhti.iItem, ROW_STATE_WATCHED, 
                                                       &dwState);
                            Assert(SUCCEEDED(hr));

                            if (0 != (dwState & ROW_STATE_WATCHED))
                            {
                                nCmdID = ID_IGNORE_THREAD;
                            }
                            else
                            {
                                hr = m_pTable->GetRowState(lvhti.iItem, ROW_STATE_IGNORED, &dwState);
                                Assert(SUCCEEDED(hr));

                                if (0 != (dwState & ROW_STATE_IGNORED))
                                {
                                    nCmdID = ID_IGNORE_THREAD;
                                }
                                else
                                {
                                    nCmdID = ID_WATCH_THREAD;
                                }
                            }
                            
                            CmdWatchIgnore(nCmdID, 0, NULL, NULL);
                            break;
                        }
                    }

                    if (m_fThreadMessages && (lvhti.flags & LVHT_ONITEMSTATEICON) && !(lvhti.flags & LVHT_ONITEMLABEL))
                        _ExpandCollapseThread(lvhti.iItem);
                }
            }

            break;
        }

        // We change the font etc based on the row.
        case NM_CUSTOMDRAW:
        {
            if (pnmhdr->hwndFrom == m_ctlList)
                return _OnCustomDraw((NMCUSTOMDRAW *) pnmhdr);
            break;
        }

        // Check asynchronously if we need to redo our columns.
        case HDN_ENDDRAG:
        {
            PostMessage(MVM_REDOCOLUMNS, 0, 0);
            break;
        }

        // Update our internal column data when columns are resized
        case HDN_ENDTRACK:
        {
            m_cColumns.SetColumnWidth(phdn->iItem, phdn->pitem->cxy);
            break;
        }

        // When the user double clicks on a header divider, we're supposed to
        // autosize that column.
        case HDN_DIVIDERDBLCLICK:
        {
            m_cColumns.SetColumnWidth(phdn->iItem, ListView_GetColumnWidth(m_ctlList, phdn->iItem));
            break;
        }

        // If the keystrokes are either VK_RIGHT or VK_LEFT then we need to 
        // expand or collapse the thread.
        case LVN_KEYDOWN:
        {
            DWORD iNewSel;
            int iSel = ListView_GetFocusedItem(m_ctlList);

            if (plvkd->wVKey == VK_RIGHT)
            {
                if (m_fThreadMessages && iSel != -1 && m_pTable)
                {
                    DWORD dwState;

                    if (SUCCEEDED(m_pTable->GetRowState(iSel, -1, &dwState)))
                    {
                        m_pTable->GetRelativeRow(iSel, RELATIVE_ROW_CHILD, &iNewSel);
                        if (iNewSel != -1)
                            ListView_SelectItem(m_ctlList, iNewSel);
                        break;
                    }
                }
            }

            if (plvkd->wVKey == VK_ADD)
            {
                CmdExpandCollapse(ID_EXPAND, 0, 0, 0);                
                return (TRUE);
            }

            if (plvkd->wVKey == VK_LEFT)
            {
                if (m_fThreadMessages && iSel != -1 && m_pTable)
                {
                    DWORD dwState;

                    if (SUCCEEDED(m_pTable->GetRowState(iSel, -1, &dwState)))
                    {
                        m_pTable->GetRelativeRow(iSel, RELATIVE_ROW_PARENT, &iNewSel);
                        if (iNewSel != -1)
                            ListView_SelectItem(m_ctlList, iNewSel);
                        break;
                    }
                }
            }

            if (plvkd->wVKey == VK_SUBTRACT)
            {
                CmdExpandCollapse(ID_COLLAPSE, 0, 0, 0);                
                return (TRUE);
            }

            break;
        }

        // When the user clicks on a column header, we need to resort on that
        // column.
        case LVN_COLUMNCLICK:
        {
            COLUMN_ID idSort;
            BOOL      fAscending;
            
            // Get the column we're currently sorted on
            m_cColumns.GetSortInfo(&idSort, &fAscending);

            // If the user clicked on the column we're already sorted on, then
            // we toggle the direction
            if (idSort == m_cColumns.GetId(pnmlv->iSubItem))
                _OnColumnClick(pnmlv->iSubItem, LIST_SORT_TOGGLE);
            else
                _OnColumnClick(pnmlv->iSubItem, LIST_SORT_DEFAULT);

            break;
        }

        // When the selection changes, we set a timer so we can update the
        // preview pane once the user stops moving the selection.
        case LVN_ODSTATECHANGED:
        {
            UINT uChanged;
            MESSAGEID idMessage;
            BOOL fChanged;

            // Figure out if it's the selection that changed
            uChanged = pnm->uNewState ^ pnm->uOldState;
            if (uChanged & LVIS_SELECTED)
            {
                idMessage = m_idSelection;

                // Bookmark the currently select row
                int iRow = ListView_GetFocusedItem(m_ctlList);
                m_pTable->GetRowMessageId(iRow, &m_idSelection);

                fChanged = (idMessage != m_idSelection);

                if (fChanged)
                    SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);
            }

            break;
        }

        // If the selection changes we set a timer to delay update the 
        // preview pane.
        case LVN_ITEMCHANGED:
        {
            UINT uChanged;
            MESSAGEID idMessage;
            BOOL fChanged = FALSE;
            DWORD dwState = 0;

            if (pnmlv->uChanged & LVIF_STATE)
            {
                uChanged = pnmlv->uNewState ^ pnmlv->uOldState;
                if (uChanged & LVIS_SELECTED || uChanged & LVIS_FOCUSED)
                {
                    idMessage = m_idSelection;

                    // Check to see if the focused item has selection too
                    int iRow = ListView_GetFocusedItem(m_ctlList);
                    if (-1 != iRow)                    
                        dwState = ListView_GetItemState(m_ctlList, iRow, LVIS_SELECTED);

                    if (dwState)
                    {
                        // Create a bookmark on the newly selected row
                        if (pnmlv->iItem >= 0)
                            m_pTable->GetRowMessageId(pnmlv->iItem, &m_idSelection);

                        // Compare 'em
                        fChanged = (idMessage != m_idSelection);

                        // Set the delay timer
                        if (fChanged)
                            SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);
                    }
                    else
                    {
                        // See if _anything_ is selected
                        if (0 == ListView_GetSelectedCount(m_ctlList))
                        {
                            SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);

                            // Free the previous bookmark
                            if (m_idSelection)
                            {
                                m_idSelection = 0;
                            }
                        }
                    }
                }
            }

            break;
        }

        // Focus changes need to be sent back to the host
        case NM_KILLFOCUS:
        {
            Fire_OnFocusChanged(FALSE);
            break;
        }

        // Focus changes need to be sent back to the host
        case NM_SETFOCUS:
        {
            Fire_OnFocusChanged(TRUE);
            Fire_OnUpdateCommandState();
            break;
        }

        // This is called when the ListView needs information to fill in a 
        // row.
        case LVN_GETDISPINFO:
        {
            _OnGetDisplayInfo((LV_DISPINFO *) pnmhdr);
            break;
        }

        // Prevents drag-selecting things
        case LVN_MARQUEEBEGIN:
            return (1);

        // Start a Drag & Drop operation
        case LVN_BEGINDRAG:
        {
            m_fRtDrag = FALSE;
            _OnBeginDrag(pnmlv);
            break;
        }

        // Start a Drag & Drop operation
        case LVN_BEGINRDRAG:
        {
            m_fRtDrag = TRUE;
            _OnBeginDrag(pnmlv);
            break;
        }
        case LVN_GETINFOTIP:
        {
           OnNotifyGetInfoTip(lParam);
           break;
        }
        // User is typing
        case LVN_ODFINDITEM:
        {
            NMLVFINDITEM *plvfi = (NMLVFINDITEM *) lParam;
            ROWINDEX iNext;

            // Ask the message table to find that next row for us
            if (m_pTable && SUCCEEDED(m_pTable->FindNextRow(plvfi->iStart, plvfi->lvfi.psz,
                                      FINDNEXT_TYPEAHEAD, FALSE, &iNext, NULL)))
                return (iNext);
            else
                return -1;

            break;
        }
    }

    return (0);
}

LRESULT CMessageList::OnNotifyGetInfoTip(LPARAM lParam)
{
    NMLVGETINFOTIP *plvgit = (NMLVGETINFOTIP *) lParam;

    if (plvgit->dwFlags & LVGIT_UNFOLDED)
    {
        // If this is not a messenger item and the text
        // isn't truncated do not display a tooltip.

        plvgit->pszText[0] = L'\0';
    }

    return 0;
}
//
//  FUNCTION:   CMessageList::_OnGetDisplayInfo()
//
//  PURPOSE:    Handles the LVN_GETDISPINFO notification by returning the 
//              appropriate information from the table.
//
void CMessageList::_OnGetDisplayInfo(LV_DISPINFO *plvdi)
{
    LPMESSAGEINFO pInfo;
    COLUMN_ID idColumn;

    TraceCall("CMessageList::_OnGetDisplayInfo");

    // IF we don't have a table object, we can't display information
    if (!m_pTable)
        return;

    // Get the row from the table
    if (FAILED(m_pTable->GetRow(plvdi->item.iItem, &pInfo)))
        return;

    // Convert the iSubItem to a COLUMN_ID
    idColumn = m_cColumns.GetId(plvdi->item.iSubItem);

    // The ListView needs text for this row
    if (plvdi->item.mask & LVIF_TEXT)
    {
        _GetColumnText(pInfo, idColumn, plvdi->item.pszText, plvdi->item.cchTextMax);
    }

    // The ListView needs an image
    if (plvdi->item.mask & LVIF_IMAGE)
    {
        _GetColumnImage(plvdi->item.iItem, plvdi->item.iSubItem, pInfo, idColumn, &(plvdi->item.iImage));
    }

    // The ListView needs the indent level
    if (plvdi->item.mask & LVIF_INDENT)
    {
        if (m_fThreadMessages)
            m_pTable->GetIndentLevel(plvdi->item.iItem, (LPDWORD) &(plvdi->item.iIndent));
        else
            plvdi->item.iIndent = 0;
    }

    // The ListView needs the state image
    if (plvdi->item.mask & LVIF_STATE)
    {
        _GetColumnStateImage(plvdi->item.iItem, plvdi->item.iSubItem, pInfo, plvdi);
    }

    // Free the memory
    m_pTable->ReleaseRow(pInfo);
}


//
//  FUNCTION:   CMessageList::_GetColumnText()
//
//  PURPOSE:    This function looks up the appropriate text for a column in 
//              the requested row.
//
void CMessageList::_GetColumnText(MESSAGEINFO *pInfo, COLUMN_ID idColumn, LPTSTR pszText, DWORD cchTextMax)
{
    Assert(pszText);
    Assert(cchTextMax);

    *pszText = 0;

    switch (idColumn)
    {
        case COLUMN_TO:
            if (pInfo->pszDisplayTo)
                lstrcpyn(pszText, pInfo->pszDisplayTo, cchTextMax);
            break;

        case COLUMN_FROM:
            if (pInfo->pszDisplayFrom)
                lstrcpyn(pszText, pInfo->pszDisplayFrom, cchTextMax);
            break;

        case COLUMN_SUBJECT:
            if (pInfo->pszSubject)
                lstrcpyn(pszText, pInfo->pszSubject, cchTextMax);
            break;

        case COLUMN_RECEIVED:
            if (!!(pInfo->dwFlags & ARF_PARTIAL_RECVTIME))
                CchFileTimeToDateTimeSz(&pInfo->ftReceived, pszText, cchTextMax, DTM_NOTIMEZONEOFFSET | DTM_NOTIME);
            else if (pInfo->ftReceived.dwLowDateTime || pInfo->ftReceived.dwHighDateTime)
                CchFileTimeToDateTimeSz(&pInfo->ftReceived, pszText, cchTextMax, DTM_NOSECONDS);
            break;

        case COLUMN_SENT:
            if (pInfo->ftSent.dwLowDateTime || pInfo->ftSent.dwHighDateTime)
                CchFileTimeToDateTimeSz(&pInfo->ftSent, pszText, cchTextMax, DTM_NOSECONDS);
            break;

        case COLUMN_SIZE:
            AthFormatSizeK(pInfo->cbMessage, pszText, cchTextMax);
            break;

        case COLUMN_FOLDER:
            if (pInfo->pszFolder)
                lstrcpyn(pszText, pInfo->pszFolder, cchTextMax);
            break;

        case COLUMN_ACCOUNT:
            if (pInfo->pszAcctName)
                lstrcpyn(pszText, pInfo->pszAcctName, cchTextMax);
            break;

        case COLUMN_LINES:
            wsprintf(pszText, "%lu", pInfo->cLines);
            break;
    }
}


//
//  FUNCTION:   CMessageList::_GetColumnImage()
//
//  PURPOSE:    Figures out the right image to show for a column in the 
//              specified row.
//
void CMessageList::_GetColumnImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, 
                                   COLUMN_ID idColumn, int *piImage)
{
    WORD wIcon = 0;
    DWORD dwState = 0;

    *piImage = -1;

    TraceCall("CMessageList::_GetColumnImage");

    if (!m_pTable)
        return;

    // Get the row state flags
    m_pTable->GetRowState(iRow, -1, &dwState);

    // Column zero always contains the message state (read, etc)
    if (iColumn == 0)
    {
        // Set some basic information first
        if (pInfo->dwFlags & ARF_UNSENT)
            wIcon |= ICONF_UNSENT;
    
        if (0 == (dwState & ROW_STATE_READ))
            wIcon |= ICONF_UNREAD;

        // Voice Mail Messages
        if (pInfo->dwFlags & ARF_VOICEMAIL)
        {
            *piImage = iiconVoiceMail;
            return;
        }

        // News Messages
        if (pInfo->dwFlags & ARF_NEWSMSG)
        {
            if ((pInfo->dwFlags & ARF_ARTICLE_EXPIRED) || (pInfo->dwFlags & ARF_ENDANGERED))
                wIcon |= ICONF_FAILED;
            else if (pInfo->dwFlags & ARF_HASBODY)
                wIcon |= ICONF_HASBODY;
            
            if (pInfo->dwFlags & ARF_SIGNED)
            {
                if (0 == (dwState & ROW_STATE_READ))
                    *piImage = iiconNewsUnreadSigned;
                else 
                    *piImage = iiconNewsReadSigned;

                return;
            }
            
            *piImage = c_rgNewsIconTable[wIcon];
            return;
        }

        // Mail Messages
        if (pInfo->dwFlags & (ARF_ARTICLE_EXPIRED | ARF_ENDANGERED))
        {
            *piImage = iiconMailDeleted;
            return;
        }

        if (!ISFLAGSET(pInfo->dwFlags, ARF_HASBODY))
        {
            *piImage = iiconMailHeader;
            return;
        }
        
        // Look up S/MIME flags
        if (pInfo->dwFlags & ARF_SIGNED)
            wIcon |= ICONF_SIGNED;
        
        if (pInfo->dwFlags & ARF_ENCRYPTED)
            wIcon |= ICONF_ENCRYPTED;

        *piImage = c_rgMailIconTable[wIcon];
        return;
    }

    else if (idColumn == COLUMN_PRIORITY)
    {
        if (IMSG_PRI_HIGH == pInfo->wPriority)
            *piImage = iiconPriHigh;
        else if (IMSG_PRI_LOW == pInfo->wPriority)
            *piImage = iiconPriLow;

        return;
    }

    else if (idColumn == COLUMN_ATTACHMENT)
    {
        if (ARF_HASATTACH & pInfo->dwFlags)
            *piImage = iiconAttach;

        return;
    }

    else if (idColumn == COLUMN_FLAG)
    {
        if (ARF_FLAGGED & pInfo->dwFlags)
            *piImage = iiconFlag;
    }

    else if (idColumn == COLUMN_DOWNLOADMSG)
    {
        if (ARF_DOWNLOAD & pInfo->dwFlags)
            *piImage = iiconDownload;
    }
    
    else if (idColumn == COLUMN_THREADSTATE)
    {
        if (ROW_STATE_WATCHED & dwState)
            *piImage = iiconWatchThread;
        else if (ROW_STATE_IGNORED & dwState)
            *piImage = iiconIgnoreThread;
    }
}


void CMessageList::_GetColumnStateImage(DWORD iRow, DWORD iColumn, MESSAGEINFO *pInfo, LV_DISPINFO *plvdi)
{
    DWORD dwState = 0;
    int   iIcon = 0;

    if (!m_pTable)
        return;

    if (0 == iColumn)
    {
        if (SUCCEEDED(m_pTable->GetRowState(iRow, -1, &dwState)))
        {
            if (m_fThreadMessages && (dwState & ROW_STATE_HAS_CHILDREN))
            {
                if (dwState & ROW_STATE_EXPANDED)
                    iIcon = iiconStateExpanded + 1;
                else
                    iIcon = iiconStateCollapsed + 1;
            }

            // Replied or forwarded flags
            if (pInfo && (pInfo->dwFlags & ARF_REPLIED))
            {
                plvdi->item.state |= INDEXTOOVERLAYMASK(OVERLAY_REPLY);
                plvdi->item.stateMask |= LVIS_OVERLAYMASK;
            }

            else if (pInfo && (pInfo->dwFlags & ARF_FORWARDED))
            {
                plvdi->item.state |= INDEXTOOVERLAYMASK(OVERLAY_FORWARD);
                plvdi->item.stateMask |= LVIS_OVERLAYMASK;
            }
        }

        plvdi->item.state |= INDEXTOSTATEIMAGEMASK(iIcon);
    }
}


LRESULT CMessageList::_OnCustomDraw(NMCUSTOMDRAW *pnmcd)
{
    FNTSYSTYPE fntType;
    LPMESSAGEINFO pInfo = NULL;    
    DWORD dwState;
    
    // If this is a prepaint notification, we tell the control we're interested
    // in further notfications.
    if (pnmcd->dwDrawStage == CDDS_PREPAINT && m_pTable)
        return (CDRF_NOTIFYITEMDRAW);
    
    // If this is an Item prepaint notification, then we do some work
    if ((pnmcd->dwDrawStage == CDDS_ITEMPREPAINT) || (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM)))
    {
        // Determine the right font for this row
        fntType = _GetRowFont((DWORD)(pnmcd->dwItemSpec));
        
        // We should get the "system" font of the codepage from the Default_Codepage
        // in the registry.
        SelectObject(pnmcd->hdc, HGetCharSetFont(fntType, m_hCharset));
        
        // Figure out if this row is highlighted
        if(SUCCEEDED(m_pTable->GetRow((DWORD)(pnmcd->dwItemSpec), &pInfo)))
        {
            if (pInfo->wHighlight > 0 && pInfo->wHighlight <= 16)
            {
                LPNMLVCUSTOMDRAW(pnmcd)->clrText = rgrgbColors16[pInfo->wHighlight - 1];
                
            }
            else if (SUCCEEDED(m_pTable->GetRowState((DWORD)(pnmcd->dwItemSpec), -1, &dwState)))
            {
                if ((dwState & ROW_STATE_WATCHED) && (m_clrWatched > 0 && m_clrWatched <=16))
                {
                    // If the row already doesn't have a color from a rule, check to see if
                    // it's watched or ignored.
                    LPNMLVCUSTOMDRAW(pnmcd)->clrText = rgrgbColors16[m_clrWatched - 1];
                }
                else if (dwState & ROW_STATE_IGNORED)
                {
                    LPNMLVCUSTOMDRAW(pnmcd)->clrText = GetSysColor(COLOR_GRAYTEXT);
                }
            }
            m_pTable->ReleaseRow(pInfo);
            
            // Do some extra work here to not show the selection on the priority or
            // attachment sub columns.
            if (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT|CDDS_SUBITEM) &&
                (m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_PRIORITY ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_ATTACHMENT ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_FLAG ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_DOWNLOADMSG ||
                m_cColumns.GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem) == COLUMN_THREADSTATE))
                pnmcd->uItemState &= ~(CDIS_SELECTED|CDIS_FOCUS);
            return CDRF_NEWFONT|CDRF_NOTIFYSUBITEMDRAW;
        }
        else
            return(CDRF_SKIPDEFAULT);
    }
    
    return (CDRF_DODEFAULT);
}


LRESULT CMessageList::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Need to forward this notifications to our child windows
    if (IsWindow(m_ctlList))
        m_ctlList.SendMessage(uMsg, wParam, lParam);

    return (0);
}


LRESULT CMessageList::OnTimeChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Force the ListView to repaint
    m_ctlList.InvalidateRect(NULL);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnContextMenu()
//
//  PURPOSE:    
//
LRESULT CMessageList::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HMENU       hPopup = 0;
    HWND        hwndHeader;
    int         id = 0;
    POINT       pt = { (int)(short) LOWORD(lParam), (int)(short) HIWORD(lParam) };
    COLUMN_ID   idSort;
    BOOL        fAscending;
    IOleCommandTarget *pTarget = 0;

    TraceCall("CMessageList::OnContextMenu");

    // Figure out if this came from the keyboard or not
    if (lParam == -1)
    {
        Assert((HWND) wParam == m_ctlList);
        int i = ListView_GetFirstSel(m_ctlList);
        if (i == -1)
            return (0);

        ListView_GetItemPosition(m_ctlList, i, &pt);
        m_ctlList.ClientToScreen(&pt);
    }

    // Get the window handle of the header in the ListView
    hwndHeader = ListView_GetHeader(m_ctlList);

    // Check to see if the click was on the header
    if (WindowFromPoint(pt) == hwndHeader)
    {
        HD_HITTESTINFO hht;

        hht.pt = pt;
        ::ScreenToClient(hwndHeader, &hht.pt);
        ::SendMessage(hwndHeader, HDM_HITTEST, 0, (LPARAM) &hht);
        m_iColForPopup = hht.iItem;

        // Popup the context menu
        hPopup = LoadPopupMenu(IDR_COLUMNS_POPUP);
        if (!hPopup)
            goto exit;

        // Disable sort options if it's a bad column
        if (m_iColForPopup == -1 || m_iColForPopup >= COLUMN_MAX)
        {
            EnableMenuItem(hPopup, ID_SORT_ASCENDING, MF_GRAYED | MF_DISABLED);
            EnableMenuItem(hPopup, ID_SORT_DESCENDING, MF_GRAYED | MF_DISABLED);
        }
        else
        {
            // If we've clicked on a column that is sorted, check it
            m_cColumns.GetSortInfo(&idSort, &fAscending);
            if (m_cColumns.GetId(m_iColForPopup) == idSort)
            {
                CheckMenuItem(hPopup, fAscending ? ID_SORT_ASCENDING : ID_SORT_DESCENDING,
                              MF_BYCOMMAND | MF_CHECKED);
            }
        }
    }
    else if ((HWND) wParam == m_ctlList)
    {
        // We clicked on the ListView, or focus is in the listview for keyboard
        // context menu goo.  
        int idMenuRes;
        FOLDERTYPE ty = GetFolderType(m_idFolder);

        if (m_fFindFolder)
            idMenuRes = IDR_FIND_MESSAGE_POPUP;
        else if (ty == FOLDER_LOCAL)
            idMenuRes = IDR_LOCAL_MESSAGE_POPUP;
        else if (ty == FOLDER_IMAP)
            idMenuRes = IDR_IMAP_MESSAGE_POPUP;
        else if (ty == FOLDER_HTTPMAIL)
            idMenuRes = IDR_HTTP_MESSAGE_POPUP;
        else if (ty == FOLDER_NEWS)
            idMenuRes = IDR_NEWS_MESSAGE_POPUP;
        else
        {
            Assert(FALSE);
            return (0);
        }
        
        hPopup = LoadPopupMenu(idMenuRes);
        if (!hPopup)
            goto exit;

        MenuUtil_SetPopupDefault(hPopup, ID_OPEN);

        // Figure out which command target to use
        if (m_pCmdTarget)
            pTarget = m_pCmdTarget;
        else
            pTarget = this;

        MenuUtil_EnablePopupMenu(hPopup, pTarget);
    }

    if (hPopup)
    {
        m_hMenuPopup = hPopup;
        m_ptMenuPopup = pt;
        id = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, m_hwndParent, NULL);
        m_hMenuPopup = NULL;
    }

    if (id)
    {
        if (pTarget)
        {
            pTarget->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }
        else
        {
            // Just route it through ourselves, eh?
            Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }
    }

exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnTimer()
//
//  PURPOSE:    When the timer fires and the selection has changed, we tell
//              the host so they can update the preview pane.
//
LRESULT CMessageList::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnTimer");

    DWORD dwMsgId;
    int   iSel;
    int   iSelOld = -1;

#ifdef OLDTIPS
    if (wParam == IDT_SCROLL_TIP_TIMER)
    {
        Assert(m_fScrollTipVisible);

        if (!GetAsyncKeyState(GetSystemMetrics(SM_SWAPBUTTON) ? VK_RBUTTON : VK_LBUTTON))
        {
            KillTimer(IDT_SCROLL_TIP_TIMER);
            m_fScrollTipVisible = FALSE;

            TOOLINFO ti = { 0 };
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd   = m_hWnd;
            ti.uId    = (UINT_PTR)(HWND) m_ctlList;

            m_ctlScrollTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
        }
    }
    else 
#endif //OLDTIPS
    if (wParam == IDT_SEL_CHANGE_TIMER)
    {
        // Turn this off
        KillTimer(IDT_SEL_CHANGE_TIMER);

        // Check to see if something was bookmarked
        if (m_idSelection)
        {
            // Check to see if the selection has changed
            iSel = ListView_GetSelFocused(m_ctlList);

            // Get the row index from the bookmark
            if (m_pTable)
                m_pTable->GetRowIndex(m_idSelection, (DWORD *) &iSelOld);
            if(!m_fInFire)
            {
                m_fInFire = TRUE;
                Fire_OnSelectionChanged(ListView_GetSelectedCount(m_ctlList));
                m_fInFire = FALSE;
            }
        }
        else
        {
            // If there was no previous selection, go ahead and fire
            // the notification
            if(!m_fInFire)
            {
                m_fInFire = TRUE;
                Fire_OnSelectionChanged(ListView_GetSelectedCount(m_ctlList));
                m_fInFire = FALSE;
            }
        }
    }

    else if (wParam == IDT_POLLMSGS_TIMER)
    {
        if (m_dwConnectState == CONNECTED)
        {
            if (m_pTable)
                m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }

#ifdef OLDTIPS
    else if (wParam == IDT_VIEWTIP_TIMER)
    {
        KillTimer(IDT_VIEWTIP_TIMER);

        POINT pt;
        GetCursorPos(&pt);
        ::ScreenToClient(m_ctlList, &pt);
        _UpdateViewTip(pt.x, pt.y, TRUE);
    }
#endif // OLDTIPS

    return (0);
}


//
//  FUNCTION:   CMessageList::OnRedoColumns()
//
//  PURPOSE:    Asynchronously update the column order.
//
LRESULT CMessageList::OnRedoColumns(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    COLUMN_SET *rgColumns;
    DWORD       cColumns;

    TraceCall("CMessageList::OnRedoColumns");

    // Update the order array from the ListView
    m_cColumns.GetColumnInfo(NULL, &rgColumns, &cColumns);

    // Update the ListView so the order array is always at it's 
    // most efficient and so the image columns are never column zero.
    m_cColumns.SetColumnInfo(rgColumns, cColumns);
    g_pMalloc->Free(rgColumns);            
    return (0);
}


HRESULT CMessageList::OnDraw(ATL_DRAWINFO& di)
{
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    DrawText(di.hdcDraw, _T("Outlook Express Message List Control"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    return S_OK;
}


//
//  FUNCTION:   CmdSelectAll()
//
//  PURPOSE:    Selects all of the messages in the ListView.
//
HRESULT CMessageList::CmdSelectAll(DWORD nCmdID, DWORD nCmdExecOpt, 
                                   VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("OnSelectAll");

    // Make sure the focus is in the ListView
    HWND hwndFocus = GetFocus();

    if (!IsWindow(m_ctlList))
        return (OLECMDERR_E_DISABLED);

    if (hwndFocus != m_ctlList)
    {
        if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
            return (OLECMDERR_E_NOTSUPPORTED);
        else
            return (OLECMDERR_E_DISABLED);
    }
    
    // Select everything
    ListView_SelectAll(m_ctlList);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdCopyClipboard()
//
//  PURPOSE:    Copies the selected message to the ClipBoard
//
HRESULT CMessageList::CmdCopyClipboard(DWORD nCmdID, DWORD nCmdExecOpt, 
                                       VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = S_OK;
    IMimeMessage *pMessage = NULL;
    IDataObject  *pDataObj = NULL;

    TraceCall("CMessageList::CmdCopy");

    // Make sure the focus is in the ListView
    HWND hwndFocus = GetFocus();

    if (!IsWindow(m_ctlList))
        return (OLECMDERR_E_DISABLED);

    if (hwndFocus != m_ctlList)
    {
        if (m_fInOE && ::IsChild(m_hwndParent, hwndFocus))
            return (OLECMDERR_E_NOTSUPPORTED);
        else
            return (OLECMDERR_E_DISABLED);
    }
    
    // If the message is not cached, then we cannot copy
    if (FAILED(_GetSelectedCachedMessage(TRUE, &pMessage)))
        return (OLECMDERR_E_DISABLED);

    // Query the message for it's IDataObject interface
    if (FAILED(hr = pMessage->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObj)))
    {
        pMessage->Release();
        return (hr);
    }

    // Set it to the ClipBoard
    hr = OleSetClipboard(pDataObj);

    // Free everything
    pDataObj->Release();
    pMessage->Release();

    return (hr);
}

//
//  FUNCTION:   CMessageList::CmdPurgeFolder()
//
//  PURPOSE:    Purge deleted messages from an IMAP folder
//
HRESULT CMessageList::CmdPurgeFolder(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    return m_pTable ? m_pTable->Synchronize(SYNC_FOLDER_PURGE_DELETED, 0, this) : E_FAIL;
}

//
//  FUNCTION:   CMessageList::CmdProperties()
//
//  PURPOSE:    Displays a property sheet for the selected message.
//
HRESULT CMessageList::CmdProperties(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    LPMESSAGEINFO pInfo = NULL;
    HRESULT hr = S_OK;

    TraceCall("CMessageList::CmdProperties");

    if (m_fInOE && !::IsChild(m_hwndParent, GetFocus()))
        return (OLECMDERR_E_NOTSUPPORTED);

    int iSel = ListView_GetFirstSel(m_ctlList);
    if (-1 != iSel)
    {
        // Get the row info
        if (SUCCEEDED(m_pTable->GetRow(iSel, &pInfo)))
        {
            // Fill out one of these badboys
            MSGPROP msgProp = {0};

            msgProp.hwndParent = m_hWnd;
            msgProp.type = (pInfo->dwFlags & ARF_NEWSMSG) ? MSGPROPTYPE_NEWS : MSGPROPTYPE_MAIL;
            msgProp.mpStartPage = MP_GENERAL;
            msgProp.fSecure = (pInfo->dwFlags & ARF_SIGNED) || (pInfo->dwFlags & ARF_ENCRYPTED);
            msgProp.dwFlags = pInfo->dwFlags;

            FOLDERINFO rFolderInfo = { 0 };
            if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rFolderInfo)))
            {
                msgProp.szFolderName = rFolderInfo.pszName;
            }

            hr = m_pTable->OpenMessage(iSel, OPEN_MESSAGE_CACHEDONLY, &msgProp.pMsg, this);

            if(FAILED(hr))
            {
                AthErrorMessageW(m_hWnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsProperyAccessDenied), hr);
                goto exit;
            }

            if (msgProp.fSecure)
            {
                m_pTable->OpenMessage(iSel, OPEN_MESSAGE_CACHEDONLY | OPEN_MESSAGE_SECURE, &msgProp.pSecureMsg, 
                                     this);
                HrGetWabalFromMsg(msgProp.pSecureMsg, &msgProp.lpWabal);
            }

            msgProp.fFromListView = TRUE;

            HrMsgProperties(&msgProp);

exit:
            ReleaseObj(msgProp.lpWabal);
            ReleaseObj(msgProp.pMsg);
            ReleaseObj(msgProp.pSecureMsg);
            if (rFolderInfo.pAllocated)
                g_pStore->FreeRecord(&rFolderInfo);

            m_pTable->ReleaseRow(pInfo);
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdExpandCollapse()
//
//  PURPOSE:    Expands or collapses the currently selected thread.
//
HRESULT CMessageList::CmdExpandCollapse(DWORD nCmdID, DWORD nCmdExecOpt,
                                        VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CMessageList::CmdExpandCollapse");

    _ExpandCollapseThread(ListView_GetFocusedItem(m_ctlList));
    return (S_OK);
}
    

//
//  FUNCTION:   CMessageList::CmdColumnsDlg()
//
//  PURPOSE:    Expands or collapses the currently selected thread.
//
HRESULT CMessageList::CmdColumnsDlg(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CMessageList::CmdColumnsDlg");

    if (nCmdExecOpt == OLECMDEXECOPT_DODEFAULT || nCmdExecOpt == OLECMDEXECOPT_PROMPTUSER)
    {
        m_cColumns.ColumnsDialog(m_ctlList);
        return (S_OK);
    }

    return (OLECMDERR_E_DISABLED);
}


//
//  FUNCTION:   CMessageList::CmdSort()
//
//  PURPOSE:    Sorts the ListView based on the selected column
//
HRESULT CMessageList::CmdSort(DWORD nCmdID, DWORD nCmdExecOpt,
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CMessageList::CmdSort");
    
    // If m_iColForPopup is -1, then this came from the menu bar as opposed to
    // a context menu on the header itself.
    if (m_iColForPopup != -1)
    {
        COLUMN_ID idSort;
        BOOL      fAscending;
        
        // Get the current sort information
        m_cColumns.GetSortInfo(&idSort, &fAscending);
        
        // If the column to sort on changed, or the sort order changed, then go
        // ahead and perform the sort.
        if (idSort != m_cColumns.GetId(m_iColForPopup) || fAscending != (ID_SORT_ASCENDING == nCmdID))
            _OnColumnClick(m_iColForPopup, nCmdID == ID_SORT_ASCENDING ? LIST_SORT_ASCENDING : LIST_SORT_DESCENDING);
    }
    else
    {
        // Change the sort direction on the column that we're already sorted on
        _OnColumnClick(-1, nCmdID == ID_SORT_ASCENDING ? LIST_SORT_ASCENDING : LIST_SORT_DESCENDING);
    }
    
    return (S_OK);
    
}

//
//  FUNCTION:   CMessageList::CmdSaveAs()
//
//  PURPOSE:    Takes the selected message and saves it to a file.
//
HRESULT CMessageList::CmdSaveAs(DWORD nCmdID, DWORD nCmdExecOpt,
                                VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    IMimeMessage *pMessage = NULL;
    IMimeMessage *pSecMsg  = NULL;
    LPMESSAGEINFO pInfo = NULL;
    int           iSelectedMessage;
    HRESULT       hr = S_OK;
    
    TraceCall("CMessageList::CmdSaveAs");

    // Without a message table this doesn't work
    if (!m_pTable)
        return (OLECMDERR_E_DISABLED);
    
    // Get the selected message
    iSelectedMessage = ListView_GetFirstSel(m_ctlList);
    if (iSelectedMessage == -1)
        return (OLECMDERR_E_DISABLED);
        
    // Get the message type from the row        
    if (SUCCEEDED(m_pTable->GetRow(iSelectedMessage, &pInfo)))
    {
        // Retrieve the selected message from the cache
        hr = _GetSelectedCachedMessage(FALSE, &pMessage);
        if (SUCCEEDED(hr))
        {
            _GetSelectedCachedMessage(TRUE, &pSecMsg);
            HrSaveMessageToFile(m_hWnd, pSecMsg, pMessage, pInfo->dwFlags & ARF_NEWSMSG, FALSE);
            SafeRelease(pSecMsg); 
            SafeRelease(pMessage); 
        }
        else
            AthErrorMessageW(m_hWnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsUnableToSaveMessage), hr);

        m_pTable->ReleaseRow(pInfo);
    }
    
    return (S_OK);
    
}                                    


//
//  FUNCTION:    CMessageList::CmdMark()
//
//  PURPOSE:     Enumerates the selected rows and applies the selected marks
//               those rows.
//
HRESULT CMessageList::CmdMark(DWORD nCmdID, DWORD nCmdExecOpt,
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr=S_OK;
    ROWINDEX   *rgRows = NULL, *pRow;
    DWORD       dwRows=0, iItem;
    MARK_TYPE   mark;    
    HCURSOR     hCursor;
    BOOL        fRemoveTrayIcon = FALSE;
    
    // This could potentially take some time
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    if (nCmdID != ID_MARK_ALL_READ && nCmdID != ID_MARK_RETRIEVE_ALL)
    {
        // Figure out how many rows have been selected
        dwRows = ListView_GetSelectedCount(m_ctlList);
    
        // Make sure there is something selected
        if (0 == dwRows)
            return (OLECMDERR_E_DISABLED);        
    
        // Allocate an array of Row ID's for all of the selected rows
        if (!MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * dwRows))
            return (E_OUTOFMEMORY);
        
        // Build an array of the selected row indexes
        iItem = -1;
        pRow = rgRows;
        while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
            *pRow++ = iItem;
    }
        
    // Figure out the mark to apply
    if (nCmdID == ID_MARK_READ || nCmdID == ID_MARK_ALL_READ)
    {
        fRemoveTrayIcon = TRUE;
        mark = MARK_MESSAGE_READ;
    }
    else if (nCmdID == ID_MARK_UNREAD)
        mark = MARK_MESSAGE_UNREAD;
    else if (nCmdID == ID_MARK_RETRIEVE_MESSAGE)
        mark = MARK_MESSAGE_DOWNLOAD;
    else if (nCmdID == ID_FLAG_MESSAGE)
    {
        // Get the row state for the focused item.  That will determine whether
        // or not this is a flag or un-flag.
        iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
        if (-1 == iItem)
            iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED);

        DWORD dwState = 0;
        hr = m_pTable->GetRowState(iItem, ROW_STATE_FLAGGED, &dwState);
        Assert(SUCCEEDED(hr));
        
        if (dwState & ROW_STATE_FLAGGED)
            mark = MARK_MESSAGE_UNFLAGGED;
        else
        {
            mark = MARK_MESSAGE_FLAGGED;

            _DoColumnCheck(COLUMN_FLAG);
        }
    }
    else if (nCmdID == ID_MARK_RETRIEVE_ALL)
    {
        mark = MARK_MESSAGE_DOWNLOAD;
    }
    else if (nCmdID == ID_UNMARK_MESSAGE)
    {
        mark = MARK_MESSAGE_UNDOWNLOAD;
    }
    else
    {
        AssertSz(FALSE, "How did we get here?");        
    }

    // Tell the table to mark these messages
    if (m_pTable)
    {
        hr = m_pTable->Mark(rgRows, dwRows, m_fThreadMessages ? APPLY_COLLAPSED : APPLY_SPECIFIED, mark, this);
        if (fRemoveTrayIcon && m_fInOE && m_fMailFolder && NULL != g_pInstance)
            g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
    }
    
    // Free the array of rows
    SafeMemFree(rgRows);
    
    // Change the cursor back and notify the host that the unread count etc. 
    // might have changed.
    if (SUCCEEDED(hr))
    {
        Fire_OnMessageCountChanged(m_pTable);
        Fire_OnUpdateCommandState();
    }
    
    SetCursor(hCursor);
    return (hr);   
}    

//
//  FUNCTION:   CMessageList::CmdWatchIgnore()
//
//  PURPOSE:    Enumerates the selected rows and either marks the row as
//              watched or ignored.
//
HRESULT CMessageList::CmdWatchIgnore(DWORD nCmdID, DWORD nCmdExecOpt, 
                                     VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr;
    ROWINDEX   *rgRows = NULL, *pRow;
    DWORD       dwRows, iItem;
    MARK_TYPE   mark;    
    HCURSOR     hCursor;
    ROWINDEX    iParent;
    DWORD       cRows = 0;
    DWORD       dwState = 0;

    // This could potentially take some time
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // Start by building an array of thread parents
    dwRows = ListView_GetSelectedCount(m_ctlList);
    
    // Make sure there is something selected
    if (0 == dwRows)
        return (OLECMDERR_E_DISABLED);        
    
    // Allocate an array of Row ID's for the maximum number of rows
    if (!MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * dwRows))
        return (E_OUTOFMEMORY);
        
    // Build an array of the selected row indexes
    iItem = -1;
    while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
    {
        // Get the thread parent
        if (SUCCEEDED(hr = m_pTable->GetRelativeRow(iItem, RELATIVE_ROW_ROOT, &iParent)))
        {
            // Check to see if we've already inserted that one
            if (cRows == 0 || (cRows != 0 && rgRows[cRows - 1] != iParent))
            {
                rgRows[cRows] = iParent;
                cRows++;
            }
        }
        else
        {
            rgRows[cRows] = iItem;
            cRows++;
        }
    }
        
    // Figure out the mark to apply
    if (nCmdID == ID_WATCH_THREAD)
    {
        // Get the row state for the focused item.  That will determine whether
        // or not this is a flag or un-flag.
        iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
        if (-1 == iItem)
            iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED);

        hr = m_pTable->GetRowState(iItem, ROW_STATE_WATCHED, &dwState);
        Assert(SUCCEEDED(hr));

        if (dwState & ROW_STATE_WATCHED)
            mark = MARK_MESSAGE_NORMALTHREAD;
        else
        {
            mark = MARK_MESSAGE_WATCH;
            _DoColumnCheck(COLUMN_THREADSTATE);
        }
    }
    else if (nCmdID == ID_IGNORE_THREAD)
    {
        // Get the row state for the focused item.  That will determine whether
        // or not this is a flag or un-flag.
        iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
        if (-1 == iItem)
            iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED);

        hr = m_pTable->GetRowState(iItem, ROW_STATE_IGNORED, &dwState);
        Assert(SUCCEEDED(hr));
        
        if (dwState & ROW_STATE_IGNORED)
            mark = MARK_MESSAGE_NORMALTHREAD;
        else
            mark = MARK_MESSAGE_IGNORE;
    }

    // Tell the table to mark these messages
    if (m_pTable)
        hr = m_pTable->Mark(rgRows, cRows, APPLY_CHILDREN, mark, this);
    
    // Free the array of rows
    SafeMemFree(rgRows);
    
    // Change the cursor back and notify the host that the unread count etc. 
    // might have changed.
    if (SUCCEEDED(hr))
    {
        Fire_OnMessageCountChanged(m_pTable);
        Fire_OnUpdateCommandState();
    }
    
    SetCursor(hCursor);
    return (hr);   
}
                                
//
//  FUNCTION:   CMessageList::CmdMarkTopic()
// 
//  PURPOSE:    Marks the message contained within the selected topic.
//
HRESULT CMessageList::CmdMarkTopic(DWORD nCmdID, DWORD nCmdExecOpt,
                                   VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr;
    DWORD       iItemSel, iItemRoot;
    MARK_TYPE   mark;
    HCURSOR     hCursor;

    // If we don't have a table, bail
    if (!m_pTable)
        return (OLECMDERR_E_DISABLED);
    
    // This might take a while
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // Make sure there is a selected message
    iItemSel = ListView_GetFirstSel(m_ctlList);
    if (-1 == iItemSel)
        return (OLECMDERR_E_DISABLED);
        
    // Get the mark type
    if (nCmdID == ID_MARK_THREAD_READ)
        mark = MARK_MESSAGE_READ;
    else if (nCmdID == ID_MARK_RETRIEVE_THREAD)
        mark = MARK_MESSAGE_DOWNLOAD;
        
    // Get the parent of the thread
    if (SUCCEEDED(hr = m_pTable->GetRelativeRow(iItemSel, RELATIVE_ROW_ROOT, &iItemRoot)))
    {
        hr = m_pTable->Mark(&iItemRoot, 1, APPLY_CHILDREN, mark, this);
    }
    
    // Set the cursor back and update the host
    SetCursor(hCursor);    
    if (SUCCEEDED(hr))
        Fire_OnMessageCountChanged(m_pTable);
    
    return (hr);
}


//
//  FUNCTION:   CMessageList::CmdGetNextItem()
//
//  PURPOSE:    Selects the next or previous message based on the specified
//              criteria.
//
HRESULT CMessageList::CmdGetNextItem(DWORD nCmdID, DWORD nCmdExecOpt,
                                     VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwNext = -1;
    int             iFocused; 
    GETNEXTFLAGS    flag=0;
    GETNEXTTYPE     tyDirection;
    ROWMESSAGETYPE  tyMessage=ROWMSG_ALL;

    TraceCall("CMessageList::CmdGetNextItem");

    // No table - no next item
    if (!m_pTable)
        return (OLECMDERR_E_DISABLED);
    
    // Figure out what the current item is
    iFocused = ListView_GetFocusedItem(m_ctlList);

    // Convert the command ID to the appropriate mark flag
    if (nCmdID == ID_NEXT_MESSAGE)
        tyDirection = GETNEXT_NEXT;
    else if (nCmdID == ID_PREVIOUS)
        tyDirection = GETNEXT_PREVIOUS;
    else if (nCmdID == ID_NEXT_UNREAD_THREAD)
    {
        tyDirection = GETNEXT_NEXT;
        flag = GETNEXT_UNREAD | GETNEXT_THREAD;
    }
    else if (nCmdID == ID_NEXT_UNREAD_MESSAGE)
    {
        tyDirection = GETNEXT_NEXT;
        flag = GETNEXT_UNREAD;
    }
    
    // Ask the table what the next item is
    hr = m_pTable->GetNextRow(iFocused, tyDirection, tyMessage, flag, &dwNext);
    if (SUCCEEDED(hr) && dwNext != -1)
    {
        ListView_UnSelectAll(m_ctlList);
        ListView_SelectItem(m_ctlList, dwNext);
        ListView_EnsureVisible(m_ctlList, dwNext, FALSE);
    }
    else
    {
        if (FALSE == m_fFindFolder && (nCmdID == ID_NEXT_UNREAD_THREAD || nCmdID == ID_NEXT_UNREAD_MESSAGE))
        {
            if (IDYES == AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
                                       MAKEINTRESOURCEW(idsNoMoreUnreadMessages),
                                       0, MB_YESNO))
            {
                HWND hwndBrowser = GetTopMostParent(m_ctlList);
                ::PostMessage(hwndBrowser, WM_COMMAND, ID_NEXT_UNREAD_FOLDER, 0);
            }
        }
        else
        {
            MessageBeep(MB_OK);
        }
    }
    
    return (hr);    
}


//
//  FUNCTION:   CMessageList::CmdStop()
//
//  PURPOSE:    Stops the current operation.
//
HRESULT CMessageList::CmdStop(DWORD nCmdID, DWORD nCmdExecOpt,
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (m_pCancel)
    {
        m_pCancel->Cancel(CT_CANCEL);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdRefresh()
//
//  PURPOSE:    Refreshes the contents of the ListView.
//
HRESULT CMessageList::CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt,
                                 VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = E_FAIL;

    //Since this is an action explicitly initiated from the menus, so go online if we are offline
    if (PromptToGoOnline() == S_OK)
    {
        // Tell the message table to hit the server and look for new messages
        if (m_pTable)
        {
            hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }

    if (m_pTable)
    {
        FOLDERSORTINFO SortInfo;

        if (SUCCEEDED(m_pTable->GetSortInfo(&SortInfo)))
        {
            _FilterView(SortInfo.ridFilter);
        }
    }
    return (hr);
}


//
//  FUNCTION:   CMessageList::CmdGetHeaders()
//
//  PURPOSE:    Refreshes the contents of the ListView.
//
HRESULT CMessageList::CmdGetHeaders(DWORD nCmdID, DWORD nCmdExecOpt,
                                    VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = E_FAIL;
    DWORD   cHeaders;

    //Since this is an action explicitly initiated from the menus, so go online if we are offline
    if (PromptToGoOnline() == S_OK)
    {
        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
        {
            if (OPTION_OFF != m_dwGetXHeaders)
                hr = m_pTable->Synchronize(SYNC_FOLDER_XXX_HEADERS, m_dwGetXHeaders, this);
            else
                hr = m_pTable->Synchronize(NOFLAGS, 0, this);
        }
        else
        {
            hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }
    return (hr);
}


//
//  FUNCTION:   CMessageList::CmdMoveCopy()
//
//  PURPOSE:    Moves or copies the selected messages to another folder.
//
//  PARAMS:     nCmdID
//                  ID_MOVE_TO_FOLDER or ID_COPY_TO_FOLDER
//              nCmdExecOpt
//                  Unused
//              pvaIn
//                  NULL or a VT_I4 specifying destination folder id (0 for unknown)
//              pvaOut
//                  Unused
HRESULT CMessageList::CmdMoveCopy(DWORD nCmdID, DWORD nCmdExecOpt, 
                                  VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    int      idsTitle, idsCaption;
    DWORD    dwFlags;
    DWORD    dwCopyFlags;
    FOLDERID idFolderDest = FOLDERID_INVALID;
    HRESULT  hr;

    TraceCall("CMessageList::CmdMoveCopy");

    // Set up the move versus copy options
    if (nCmdID == ID_MOVE_TO_FOLDER)
    {
        idsTitle    = idsMove;
        idsCaption  = idsMoveCaption;
        dwFlags     = FD_MOVEFLAGS | FD_DISABLESERVERS | TREEVIEW_NONEWS;
        dwCopyFlags = COPY_MESSAGE_MOVE;
    }
    else
    {
        Assert(nCmdID == ID_COPY_TO_FOLDER);
        idsTitle    = idsCopy;
        idsCaption  = idsCopyCaption;
        dwFlags     = FD_COPYFLAGS | FD_DISABLESERVERS | TREEVIEW_NONEWS;
        dwCopyFlags = 0;
    }

    // If the user passed in a folder ID, we don't need to ask this.
    if (!pvaIn || (pvaIn && !pvaIn->lVal))
    {
        // Let the user select the destination folder
        hr = SelectFolderDialog(m_hWnd, SFD_SELECTFOLDER, m_idFolder, dwFlags, (LPCTSTR)IntToPtr(idsTitle),
                                (LPCTSTR)IntToPtr(idsCaption), &idFolderDest);
    }
    else
    {
        Assert(pvaIn->vt == VT_I4);
        idFolderDest = (FOLDERID)((LONG_PTR)pvaIn->lVal);
    }

    if (idFolderDest != FOLDERID_INVALID)
    {
        IMessageFolder *pDest;

        hr = g_pStore->OpenFolder(idFolderDest, NULL, NOFLAGS, &pDest);
        if (SUCCEEDED(hr))
        {
            // Gather the information together to do the move
            IServiceProvider *pService;
            IMessageFolder   *pFolder;
            MESSAGEIDLIST     rMsgIDList;
            ROWINDEX         *rgRows;
            MESSAGEINFO       rInfo;
            DWORD             i = 0;
            DWORD             iRow = -1;
            DWORD             cRows;

            // Figure out how many rows there are selected
            cRows = ListView_GetSelectedCount(m_ctlList);

            // Allocate an array
            if (MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * cRows))
            {
                // Loop through the rows getting their row indexs
                while (-1 != (iRow = ListView_GetNextItem(m_ctlList, iRow, LVNI_SELECTED)))
                {
                    rgRows[i++] = iRow;
                }

                // Now ask the table for a message ID list
                if (SUCCEEDED(m_pTable->GetMessageIdList(FALSE, cRows, rgRows, &rMsgIDList)))
                {
                    hr = m_pTable->QueryInterface(IID_IServiceProvider, (void **)&pService);
                    if (SUCCEEDED(hr))
                    {
                        hr = pService->QueryService(IID_IMessageFolder, IID_IMessageFolder, (void **)&pFolder);
                        if (SUCCEEDED(hr))
                        {
                            hr = CopyMessagesProgress(GetTopMostParent(m_hWnd), pFolder, pDest, dwCopyFlags, &rMsgIDList, NULL);
                            if (FAILED(hr))
                                AthErrorMessageW(GetTopMostParent(m_hWnd), MAKEINTRESOURCEW(idsAthena), 
                                                ISFLAGSET(dwCopyFlags, COPY_MESSAGE_MOVE) ? 
                                                    MAKEINTRESOURCEW(idsErrMoveMsgs) : 
                                                    MAKEINTRESOURCEW(idsErrCopyMsgs), hr); 

                            pFolder->Release();
                        }

                        pService->Release();
                    }
                }

                SafeMemFree(rMsgIDList.prgidMsg);
                MemFree(rgRows);
            }

            pDest->Release();

            // If we're in OE, then we remove the tray icon if this is the inbox
            if (m_fInOE && m_fMailFolder && NULL != g_pInstance)
                g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
        }
    }

    return (S_OK);                                    
}


//
//  FUNCTION:   CMessageList::CmdDelete()
//
//  PURPOSE:    Deletes the selected messages from the folder.
//
HRESULT CMessageList::CmdDelete(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    DELETEMESSAGEFLAGS dwFlags = NOFLAGS;
    DWORD              dwState = 0;
    BOOL               fOnce = TRUE;

    TraceCall("CMessageList::CmdDelete");

    // Check to see if this is enabled
    if (!_IsSelectedMessage(ROW_STATE_DELETED, ID_UNDELETE == nCmdID, FALSE))
    {
        return (OLECMDERR_E_DISABLED);
    }

    // news folders only allow permanent deletes from local store
    if ((nCmdID == ID_DELETE) && GetFolderType(m_idFolder) == FOLDER_NEWS)
        nCmdID = ID_DELETE_NO_TRASH;

    // Figure out what operation we're doing here
    if (nCmdID == ID_UNDELETE)
        dwFlags = DELETE_MESSAGE_UNDELETE;
    else if (nCmdID == ID_DELETE_NO_TRASH)
        dwFlags = DELETE_MESSAGE_NOTRASHCAN;

    // Get the number of selected rows
    DWORD cRows = ListView_GetSelectedCount(m_ctlList);

    // Allocate an array large enough for that array
    if (cRows && m_pTable)
    {
        ROWINDEX *rgRows = 0;
        if (MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * cRows))
        {
            // Loop through the rows and copy them into the array
            DWORD index = 0, row = -1;
        
            while (-1 != (row = ListView_GetNextItem(m_ctlList, row, LVNI_SELECTED)))
            {
                if (m_fThreadMessages && fOnce && nCmdID != ID_UNDELETE)
                {
                    if (SUCCEEDED(m_pTable->GetRowState(row, ROW_STATE_HAS_CHILDREN | ROW_STATE_EXPANDED, &dwState)))
                    {
                        if ((dwState & ROW_STATE_HAS_CHILDREN) && (0 == (dwState & ROW_STATE_EXPANDED)))
                        {
                            fOnce = FALSE;

                            // Tell the user that we're going to delete everything in the thread
                            if (IDNO == DoDontShowMeAgainDlg(m_hWnd, c_szRegWarnDeleteThread, 
                                                             MAKEINTRESOURCE(idsAthena),
                                                             MAKEINTRESOURCE(idsDSDeleteCollapsedThread),
                                                             MB_YESNO))
                            {
                                MemFree(rgRows);
                                return (S_OK);
                            }
                        }
                    }
                }

                rgRows[index] = row;
                index++;

                Assert(index <= cRows);
            }

            // Delete or Undelete
            m_pTable->DeleteRows(dwFlags, cRows, rgRows, TRUE, this);

            // Free the memory
            MemFree(rgRows);

            // If we're in OE and we deleted, we remove the tray icon
            if (m_fInOE && m_fMailFolder && nCmdID == ID_DELETE && g_pInstance)
                g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdFind()
//
//  PURPOSE:    Creates a find dialog so the user can search for messages in
//              this folder.
//
HRESULT CMessageList::CmdFind(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // Create the class
    if (!m_pFindNext)
    {
        m_pFindNext = new CFindNext();
        if (!m_pFindNext)
            return (E_OUTOFMEMORY);
    }

    // Initialize some state so we can show a lot of dialogs later
    int iFocus = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
    if (iFocus == -1)
        iFocus = 0;

    if (FAILED(m_pTable->GetRowMessageId(iFocus, &m_idFindFirst)))
        return (E_UNEXPECTED);

    m_cFindWrap = 0;

    // Show the find dialog
    if (FAILED(m_pFindNext->Show(m_hWnd, &m_hwndFind)))
        return (E_UNEXPECTED);

    CmdFindNext(nCmdID, nCmdExecOpt, pvaIn, pvaOut);        
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::CmdFindNext()
//
//  PURPOSE:    Get's called whenever the user clicks Find Next in the find
//              window.  In return, we move the listview select to the next
//              item in the list that matches the find criteria.
//
HRESULT CMessageList::CmdFindNext(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TCHAR    sz[CCHMAX_FIND];
    FINDINFO rFindInfo = { 0 };
    ROWINDEX iNextRow;
    BOOL     fBodies = 0;
    ROWINDEX iFirstRow = -1;
    BOOL     fWrapped = FALSE;
	
    TraceCall("CMessageList::OnFindMsg");
	
    // Check to see if the user has done a "Find" first
    if (!m_pFindNext)
        return CmdFind(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
	
    // Get the find information
    if (SUCCEEDED(m_pFindNext->GetFindString(sz, ARRAYSIZE(sz), &fBodies)))
    {
        int iFocus = ListView_GetNextItem(m_ctlList, -1, LVNI_FOCUSED);
		if(iFocus < 0)
			iFocus = 0;
		
        // Do the find
        m_pTable->FindNextRow((DWORD) iFocus, sz, FINDNEXT_ALLCOLUMNS, fBodies, &iNextRow, &fWrapped);
		
        if (iNextRow == -1 || fWrapped)
        {
            // We passed our starting position
			if(iFocus > 0)
			{
				if (IDYES == AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
					MAKEINTRESOURCEW(idsFindNextFinished), 0,
					MB_YESNO | MB_ICONEXCLAMATION))
				{
					m_pTable->FindNextRow(0, sz, FINDNEXT_ALLCOLUMNS, fBodies, &iNextRow, &fWrapped);
					if (iNextRow == -1)
					{
						// We failed to find the search string
						AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
							MAKEINTRESOURCEW(idsFindNextFinishedFailed), 0,
							MB_OK | MB_ICONEXCLAMATION);
					}
					else
					{
						ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
						ListView_SetItemState(m_ctlList, iNextRow, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
						ListView_EnsureVisible(m_ctlList, iNextRow, FALSE);
					}
				}
            }
            else if (iNextRow == -1)
			{
				// We failed to find the search string
				AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
					MAKEINTRESOURCEW(idsFindNextFinishedFailed), 0,
					MB_OK | MB_ICONEXCLAMATION);
			}
        }
        else
        {
            ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
            ListView_SetItemState(m_ctlList, iNextRow, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            ListView_EnsureVisible(m_ctlList, iNextRow, FALSE);
        }
    }
	
#if 0
	// Figure out where we started
	Assert(m_bmFindFirst);
	m_pTable->GetRowIndex(m_bmFindFirst, &iFirstRow);
	
	// Figure out if we've wrapped
	m_cFindWrap += (!!fWrapped);
	
	// Here's where we do a lot of stuff to display some useless dialogs
	if (iNextRow == -1)
	{
		// We failed to find the search string
		AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
			MAKEINTRESOURCEW(idsFindNextFinishedFailed), 0,
			MB_OK | MB_ICONEXCLAMATION);
		iNextRow = iFocus;
	}
	else if (m_cFindWrap >= 2 || (m_cFindWrap == 1 && iNextRow >= iFirstRow))
	{
		// We passed our starting position
		AthMessageBoxW(m_ctlList, MAKEINTRESOURCEW(idsAthena), 
			MAKEINTRESOURCEW(idsFindNextFinished), 0,
			MB_OK | MB_ICONEXCLAMATION);
		m_cFindWrap = 0;
	}
	else
	{           
		ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
		ListView_SetItemState(m_ctlList, iNextRow, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		ListView_EnsureVisible(m_ctlList, iNextRow, FALSE);
	}
}

#endif 
return (0);
}


//
//  FUNCTION:   CMessageList::CmdSpaceAccel()
//
//  PURPOSE:    If the user presses <SPACE> while in the view, we need to
//              go to the next message unless the focused item is not 
//              selected.
//
HRESULT CMessageList::CmdSpaceAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    int     iFocused;
    DWORD   dwState = 0;
    HRESULT hr;
    
    // Figure out who has the focus
    iFocused = ListView_GetFocusedItem(m_ctlList);

    // It's possible for nothing to be focused
    if (-1 == iFocused)
    {
        iFocused = 0;
        ListView_SetItemState(m_ctlList, iFocused, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    // Check to see if that item is selected
    if (0 == ListView_GetItemState(m_ctlList, iFocused, LVIS_SELECTED))
    {
        // Select that item
        if (GetAsyncKeyState(VK_CONTROL) < 0)
        {
            ListView_SetItemState(m_ctlList, iFocused, LVIS_SELECTED, LVIS_SELECTED);
        }
        else
        {
            ListView_SetItemState(m_ctlList, -1, 0, LVIS_SELECTED);
            ListView_SetItemState(m_ctlList, iFocused, LVIS_SELECTED, LVIS_SELECTED);
        }
    }
    else
    {
        // If the selection is on a collapsed thread, expand it first
        if (m_fThreadMessages)
        {
            hr = m_pTable->GetRowState(iFocused, ROW_STATE_EXPANDED | ROW_STATE_HAS_CHILDREN, &dwState);
            if (SUCCEEDED(hr) && (dwState & ROW_STATE_HAS_CHILDREN) && (0 == (dwState & ROW_STATE_EXPANDED)))
            {
                _ExpandCollapseThread(iFocused);
            }
        }
        
        // Go to the next item        
        CmdGetNextItem(ID_NEXT_MESSAGE, 0, NULL, NULL);
    }

    return (S_OK);
}


//
//  FUNCTION:   _UpdateListViewCount()
//
//  PURPOSE:    Gets the number of items in the message table and tells the
//              listview to display that many rows.
//
void CMessageList::_UpdateListViewCount(void)
{
    DWORD dwCount = 0;

    TraceCall("_UpdateListViewCount");

    // Get the number of items from the table
    if (m_pTable)
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount);

    // If that count is not the same as the number of items already in the 
    // ListView, update the control.
    if (dwCount != (DWORD) ListView_GetItemCount(m_ctlList))
    {
        ListView_SetItemCount(m_ctlList, dwCount);
        Fire_OnMessageCountChanged(m_pTable);
    }
}


//
//  FUNCTION:   CMessageList::_GetSelectedCachedMessage()
//
//  PURPOSE:    Retrieves the selected message if the body has already been 
//              downloaded into the cache.
//
//  PARAMETERS: 
//      [in]  fSecure   -
//      [out] ppMessage -
//
HRESULT CMessageList::_GetSelectedCachedMessage(BOOL fSecure, IMimeMessage **ppMessage)
{
    int     iSelectedMessage;
    BOOL    fCached = FALSE;
    DWORD   dwState = 0;
    HRESULT hr = E_FAIL;

    TraceCall("CMessageList::_GetSelectedCachedMessage");

    // Without a table there's nothing to get
    if (!m_pTable)
        return (E_UNEXPECTED);

    // Get the selected article header index
    iSelectedMessage = ListView_GetFirstSel(m_ctlList);

    // If there was a selected message, see if the body is preset
    if (-1 != iSelectedMessage)
    {
        m_pTable->GetRowState(iSelectedMessage, ROW_STATE_HAS_BODY, &dwState);
        if (dwState & ROW_STATE_HAS_BODY)
        {
            hr = m_pTable->OpenMessage(iSelectedMessage, OPEN_MESSAGE_CACHEDONLY | (fSecure ? OPEN_MESSAGE_SECURE : 0), ppMessage, this);
        }
    }

    return (hr);
}


//
//  FUNCTION:   CMessageList::_ExpandCollapseThread()
//
//  PURPOSE:    Takes the sepecified item in the ListView and toggles it's
//              expanded or collapsed state.
//
//  PARAMETERS: 
//      [in] iItem - item to expand or collapse
//
HRESULT CMessageList::_ExpandCollapseThread(int iItem)
{
    DWORD   dwState;
    LV_ITEM lvi = { 0 };
    HRESULT hr;

    TraceCall("CMessageList::_ExpandCollapseThread");

    // There's nothing to expand or collapse if there's no table
    if (!m_pTable)
        return (E_FAIL);

    // If we're not threaded right now, this is silly
    if (!m_fThreadMessages)
        return (E_FAIL);

    // Make sure this selected item has children
    hr = m_pTable->GetRowState(iItem, ROW_STATE_EXPANDED | ROW_STATE_HAS_CHILDREN, &dwState);
    if (SUCCEEDED(hr) && (dwState & ROW_STATE_HAS_CHILDREN))
    {
        // If the item is expanded
        if (dwState & ROW_STATE_EXPANDED)
        {
            // Loop through all the selected rows which are children of the row being collapsed.
            int i = iItem;
            while (-1 != (i = ListView_GetNextItem(m_ctlList, i, LVNI_SELECTED | LVNI_ALL)))
            {
                hr = m_pTable->IsChild(iItem, i);
                if (S_OK == hr)
                {
                    ListView_SelectItem(m_ctlList, iItem);
                    break;
                }
            }

            // Collapse the branch
            m_pTable->Collapse(iItem);
        }
        else
        {
            // Expand the branch
            m_pTable->Expand(iItem);
        }

        // Redraw the item that was expanded or collapsed so the + or - is 
        // correct.
        ListView_RedrawItems(m_ctlList, iItem, iItem);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageList::_IsSelectedMessage()
//
//  PURPOSE:    Checks to see if all or some of the selected messages in the 
//              listview have the specified state bits set.
//
//  PARAMETERS: 
//      [in] dwState    - State bits to check on each selected row.
//      [in] fCondition - Whether the state bits should be there or not.
//      [in] fAll       - The caller requires that ALL selected message meet the 
//                        criteria.
//
BOOL CMessageList::_IsSelectedMessage(DWORD dwState, BOOL fCondition, BOOL fAll, BOOL fThread)
{
    TraceCall("CMessageList::_IsSelectedMessage");

    DWORD   iItem = -1;
    DWORD   dw;
    DWORD   cRowsChecked = 0;

    // No table, no service
    if (!m_pTable)
        return (FALSE);

    while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
    {
        // Get the state for the row
        if (SUCCEEDED(m_pTable->GetRowState(iItem, dwState, &dw)))
        {
            if (fAll)
            {
                // If all must match and this one doesn't, then we can quit now.
                if (0 == (fCondition == !!(dwState & dw)))
                    return (FALSE);
            }
            else
            {
                // If only one needs to match and this one does, then we can
                // quit now.
                if (fCondition == !!(dwState & dw))
                    return (TRUE);
            }
        }

        // This is a perf safeguard.  We only look at 100 rows.  If we didn't
        // find anything in those rows to invalidate the criteria we assume it
        // will succeed.  
        cRowsChecked++;
        if (cRowsChecked > 100)
            return (TRUE);
    }

    // If the user wanted all to match, and we get here all did match.  If the
    // user wanted only one to match and we get here, then none matched and we
    // fail.
    return (fAll);
}


//
//  FUNCTION:   CMessageList::_SelectDefaultRow()
//
//  PURPOSE:    Selects the first unread item in the folder, or if that fails
//              the first or last item based on the sort order.
//
void CMessageList::_SelectDefaultRow(void)
{
    DWORD iItem, cItems;
    DWORD dwState;
    DWORD iItemFocus = -1;

    TraceCall("CMessageList::_SelectDefaultRow");

    if (-1 == ListView_GetFirstSel(m_ctlList))
    {
        // Get the total number of items in the view
        cItems = ListView_GetItemCount(m_ctlList);

        // If this folder has the "Select first unread" property, then find
        // that row.
        if (m_fSelectFirstUnread)
        {
            for (iItem = 0; iItem < cItems; iItem++)
            {
                if (SUCCEEDED(m_pTable->GetRowState(iItem, ROW_STATE_READ, &dwState)))
                {
                    if (0 == (dwState & ROW_STATE_READ))
                    {
                        iItemFocus = iItem;
                        goto exit;
                    }
                }
            }
        }

        // If we didn't set the selection because there aren't any unread, or
        // the setting was not to find the first unread, then set the selection
        // either the first or last item depending on the sort direction.
        if (cItems)
        {
            BOOL fAscending;
            COLUMN_ID idSort;

            // Get the sort direction
            m_cColumns.GetSortInfo(&idSort, &fAscending);
            if (fAscending && (idSort == COLUMN_SENT || idSort == COLUMN_RECEIVED))
                iItemFocus = cItems - 1;
            else
                iItemFocus = 0;
        }
    }

exit:
    if (iItemFocus != -1)
    {
        if (m_fSelectFirstUnread)
        {
            ListView_SetItemState(m_ctlList, iItemFocus, LVIS_FOCUSED, LVIS_FOCUSED);
        }
        else
        {
            ListView_SelectItem(m_ctlList, iItemFocus);
        }

        ListView_EnsureVisible(m_ctlList, iItemFocus, FALSE);    
    }
}


//
//  FUNCTION:   CMessageList::_LoadAndFormatString()
//
//  PURPOSE:    This function loads the string resource ID provided, merges the
//              variable argument list into the string, and copies that all into
//              pszOut.
//
void CMessageList::_LoadAndFormatString(LPTSTR pszOut, const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT;
    TCHAR       szFmt[CCHMAX_STRINGRES];

    TraceCall("CMessageList::_LoadAndFormatString");

    // If we were passed a string resource ID, then load it
    if (0 == HIWORD(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;

    // Format the string
    va_start(pArgs, pFmt);
    i = wvsprintf(pszOut, pszT, pArgs);
    va_end(pArgs);    
}


//
//  FUNCTION:   CMessageList::OnHeaderStateChange()
//
//  PURPOSE:    Whenever the state of a header changes, we need to redraw that 
//              item.
//
//  PARAMETERS: 
//      [in] wParam - lower index of the items which changed.  -1 for everything.
//      [in] lParam - upper index of the items which changed
//
LRESULT CMessageList::OnHeaderStateChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnHeaderStateChange");

    // If this is the case, then we redraw everything
    if (wParam == -1)
    {
        ListView_RedrawItems(m_ctlList, 0, ListView_GetItemCount(m_ctlList));
    }
    else 
    {
        // If this is the case, we just redraw the one item
        if (0 == lParam)
        {
            ListView_RedrawItems(m_ctlList, wParam, wParam);
        }
        else
        {
            // If this is the case, we want to invalidate just the 
            // intersection of (wParam, lParam) and the items visible
            DWORD dwTop, dwBottom;
            dwTop = ListView_GetTopIndex(m_ctlList);
            dwBottom = dwTop + ListView_GetCountPerPage(m_ctlList) + 1;

            // Make sure they intersect
            if ((dwTop > (DWORD) lParam) || (dwBottom < wParam))
                goto exit;

            ListView_RedrawItems(m_ctlList,
                                 max((int) wParam, (int) dwTop),
                                 min((int) lParam, (int) dwBottom));
        }
    }

exit:
    Fire_OnMessageCountChanged(m_pTable);
    Fire_OnUpdateCommandState();
    return (0);
}


//
//  FUNCTION:   CMessageList::OnUpdateAndRefocus()
//
//  PURPOSE:    This was originally called by the table after calls to GetNext()
//              to update the ListView count and select a message.  The usage
//              looks pretty suspect.
//
LRESULT CMessageList::OnUpdateAndRefocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnUpdateAndRefocus");
    AssertSz(0, "why is this called?");
    return (0);
}



//
//  FUNCTION:   CMessageList::OnDiskFull()
//
//  PURPOSE:    Sent when the table cannot write to disk because it is full.
//
//  PARAMETERS: 
//      [in] wParam - Contains the HRESULT with the error.
//
LRESULT CMessageList::OnDiskFull(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = (HRESULT) wParam;
    UINT    ids;

    TraceCall("CMessageList::OnDiskFull");

    if (hr == STG_E_MEDIUMFULL)
        ids = idsHTMLDiskOutOfSpace;
    else
        ids = idsHTMLErrNewsCantOpen;

    // Update the host
    Fire_OnError(ids);
    Fire_OnUpdateProgress(0);
    Fire_OnMessageCountChanged(m_pTable);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnArticleProgress()
//
//  PURPOSE:    Sent by the sync to provide article download progress.
//
//  PARAMETERS: 
//      [in] wParam - Progress
//      [in] lParam - Progress max
//
LRESULT CMessageList::OnArticleProgress(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TCHAR szBuf[CCHMAX_STRINGRES + 40];

    TraceCall("CMessageList::OnArticleProgress");

    if (lParam)
    {
        _LoadAndFormatString(szBuf, (LPTSTR) idsDownloadingArticle, min(100, (wParam * 100) / lParam));
        Fire_OnUpdateStatus(szBuf);
        Fire_OnUpdateProgress((DWORD)((wParam * 100) / lParam));
    }

    return (0);
}


//
//  FUNCTION:   CMessageList::OnBodyError()
//
//  PURPOSE:    Sent when there is an error downloading a message body
//
//  PARAMETERS: 
//      [in] lParam - Pointer to a CNNTPResponse class with the details of 
//                    the error.
//
LRESULT CMessageList::OnBodyError(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnBodyError");

#ifdef NEWSISBROKE
    CNNTPResponse *pResp;
    LPNNTPRESPONSE pr;

    pResp = (CNNTPResponse *) lParam;
    pResp->Get(&pr);

    // If the error is that the message is not available, then don't show the error -- it
    // happens way to frequently.
    if (pr->rIxpResult.hrResult != IXP_E_NNTP_ARTICLE_FAILED)
        XPUtil_DisplayIXPError(m_ Parent, &pr->rIxpResult, pr->pTransport);

    pResp->Release();
#endif
    return (0);
}


//
//  FUNCTION:   CMessageList::OnBodyAvailable()
//
//  PURPOSE:    Sent when the table has finished downloading the body of a 
//              message.
//
//  PARAMETERS: 
//      [in] wParam - Message ID of the new message body.
//      [in] lParam - HRESULT indicating success or failure.
//
LRESULT CMessageList::OnBodyAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr = (HRESULT) wParam;
    DWORD_PTR   dwMsgId = (DWORD_PTR) lParam;
    int         iSel;
    RECT        rcFirst, rcLast, rcUnion;
    UINT        ids = 0;

    TraceCall("CMessageList::OnBodyAvailable");

    // If the user has a context menu visible right now, force it to repaint 
    // since the status of some of the items might be changed now.
    if (m_hMenuPopup)
    {
        MenuUtil_EnablePopupMenu(m_hMenuPopup, this);

        GetMenuItemRect(m_hWnd, m_hMenuPopup, 0, &rcFirst);
        GetMenuItemRect(m_hWnd, m_hMenuPopup, GetMenuItemCount(m_hMenuPopup) - 1, &rcLast);
        UnionRect(&rcUnion, &rcFirst, &rcLast);
        OffsetRect(&rcUnion, m_ptMenuPopup.x - rcUnion.left, m_ptMenuPopup.y - rcUnion.top);
        ::RedrawWindow(NULL, &rcUnion, NULL, RDW_INVALIDATE|RDW_UPDATENOW|RDW_ALLCHILDREN);
    }

    // Figure which item has the selection
    iSel = ListView_GetSelFocused(m_ctlList);

    // If there is a focused item, then update the preview pane
    if (-1 != iSel)
    {
        // Get the row info
        LPMESSAGEINFO pInfo;

        if (m_pTable)
        {
            m_pTable->GetRow(iSel, &pInfo);

            // If that message id is the one we just downloaded, update
            if ((DWORD_PTR)pInfo->idMessage == dwMsgId)
            {
                if (FAILED(hr))
                {            
                    // Convert the error to a string to show in the preview
                    // pane.
                    switch (hr)
                    {
                        case E_INVALIDARG:
                            ids = idsHTMLErrNewsExpired;
                            break;

                        case hrUserCancel:
                            ids = idsHTMLErrNewsDLCancelled;
                            break;

                        case IXP_E_FAILED_TO_CONNECT:
                            ids = idsHTMLErrArticleNotCached;
                            break;

                        case STG_E_MEDIUMFULL:
                            ids = idsHTMLDiskOutOfSpace;
                            break;

                        default:
                            ids = idsHTMLErrNewsCantOpen;
                            break;
                    }
                }
                Fire_OnError(ids);
            }

            m_pTable->ReleaseRow(pInfo);
        }
    }

    Fire_OnUpdateProgress(0);
    Fire_OnMessageCountChanged(m_pTable);

    return (0);
}


//
//  FUNCTION:   CMessageList::OnStatusChange()
//
//  PURPOSE:    We simply forward this notification to our parent
//
LRESULT CMessageList::OnStatusChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceCall("CMessageList::OnStatusChange");

    return ::SendMessage(m_hwndParent, uMsg, wParam, lParam);
}


//
//  FUNCTION:   CMessageList::_FilterView()
//
//  PURPOSE:    Tells the table to filter itself, while preserving the 
//              selection if possible.
//
void CMessageList::_FilterView(RULEID ridFilter)
{
    COLUMN_ID idSort;
    BOOL fAscending;
    FOLDERSORTINFO SortInfo;

    TraceCall("CMessageList::_FilterView");
   
    m_ridFilter = ridFilter;

    // It is possible to get here and not have a table
    if (!m_pTable)
        return;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Get the current sort information
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill sort info
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Tell the table to change its sort order
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reset the view
    _ResetView(idSel);

    Fire_OnMessageCountChanged(m_pTable);
}

void CMessageList::_ResetView(MESSAGEID idSel)
{
    // Reset the ListView count
    DWORD dwItems, iSel;
    m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwItems);
    ListView_SetItemCount(m_ctlList, dwItems);

    // Get the new index from the bookmark
    if (idSel)
    {
        if (FAILED(m_pTable->GetRowIndex(idSel, &iSel)) || iSel == -1)
        {
            COLUMN_ID idSort;
            BOOL      fAscending;

            // Get the current sort information
            m_cColumns.GetSortInfo(&idSort, &fAscending);

            if (fAscending)
                iSel = dwItems - 1;
            else
                iSel = 0;
        }

        // Reset the selection
        ListView_UnSelectAll(m_ctlList);
        if (iSel < dwItems)
        {
            ListView_SelectItem(m_ctlList, iSel);
            ListView_EnsureVisible(m_ctlList, iSel, FALSE);
        }
        else
        {
            if(!m_fInFire)
            {
                m_fInFire = TRUE;
                Fire_OnSelectionChanged(ListView_GetSelectedCount(m_ctlList));
                m_fInFire = FALSE;
            }
        }
    }

    // Check to see if we need to reset the empty list thing
    if (0 == dwItems)
    {
        m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
    }
    else
    {
        m_cEmptyList.Hide();
    }

    m_ctlList.InvalidateRect(NULL, TRUE);
}

//
//  FUNCTION:   CMessageList::_OnColumnClick()
//
//  PURPOSE:    Called to resort the ListView based on the provided column
//              and direction.
//
//  PARAMETERS: 
//      [in] iColumn   - Index of the column to sort on
//      [in] iSortType - Type of sorting to do.
//
LRESULT CMessageList::_OnColumnClick(int iColumn, int iSortType)
{
    HCURSOR     hcur;
    MESSAGEID   idMessage = 0;
    DWORD       iSel;

    TraceCall("CMessageList::_OnColumnClick");

    // In case this takes a while
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Clear old sort arrow image from the column header
    COLUMN_ID idSort;
    BOOL      fAscending;

    // Get the current sort information
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // If the caller passed in a new sort column, get it's id
    if (iColumn != -1)
    {
        idSort = m_cColumns.GetId(iColumn);
    }
        
    // Figure out what the new sort order will be
    if (iSortType == LIST_SORT_TOGGLE)
        fAscending = !fAscending;
    else if (iSortType == LIST_SORT_ASCENDING)
        fAscending = TRUE;
    else if (iSortType == LIST_SORT_DESCENDING)
        fAscending = FALSE;

    // Update the sort information
    m_cColumns.SetSortInfo(idSort, fAscending);

    // Now resort the table
    if (m_pTable)
    {
        // Locals
        FOLDERSORTINFO SortInfo;

        // Save the selection
        if (-1 != (iSel = ListView_GetFirstSel(m_ctlList)))
            m_pTable->GetRowMessageId(iSel, &idMessage);

        // Fill a SortInfo
        SortInfo.idColumn = idSort;
        SortInfo.fAscending = fAscending;
        SortInfo.fThreaded = m_fThreadMessages;
        SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
        SortInfo.ridFilter = m_ridFilter;
        SortInfo.fShowDeleted = m_fShowDeleted;
        SortInfo.fShowReplies = m_fShowReplies;

        // Sort the table
        m_pTable->SetSortInfo(&SortInfo, this);

        // Make sure the filter got set correctly
        _DoFilterCheck(SortInfo.ridFilter);
        
        // Sorting can change the threading, which affects the item count
        _UpdateListViewCount();

        // Restore the selected message
        if (idMessage != 0)
        {
            // Convert the bookmark to a item number
            m_pTable->GetRowIndex(idMessage, &iSel);
            if (iSel == -1)
            {
                // we couldn't find the item that previously had the focus, so
                // select the first item.
                iSel = 0;
            }

            // Tell the ListView to select the correct item and make sure it's 
            // visible.
            ListView_UnSelectAll(m_ctlList);
            ListView_SelectItem(m_ctlList, iSel);
            ListView_EnsureVisible(m_ctlList, iSel, FALSE);
        }

        // With a new sort order we should redraw the ListView viewing area
        m_ctlList.InvalidateRect(NULL, TRUE);
    }
            
    // Let the user get back to work
    SetCursor(hcur);
    return (0);
}

void CMessageList::_OnBeginDrag(NM_LISTVIEW *pnmlv)
{
    CMessageDataObject *pDataObject = 0;
    HRESULT             hr = S_OK;
    DWORD               dwEffectOk = DROPEFFECT_COPY;
    DWORD               dwEffect = 0;
    MESSAGEIDLIST       rMsgIDList;
    ROWINDEX           *rgRows;
    DWORD               i = 0;
    DWORD               cRows;
    int                 iItem = -1;

    // Create the data object
    if (0 == (pDataObject = new CMessageDataObject()))
        return;

    // Figure out how many rows there are selected
    cRows = ListView_GetSelectedCount(m_ctlList);

    // Allocate an array
    if (!MemAlloc((LPVOID *) &rgRows, sizeof(ROWINDEX) * cRows))
        goto exit;

    // Loop through the rows getting their row indexs
    while (-1 != (iItem = ListView_GetNextItem(m_ctlList, iItem, LVNI_SELECTED)))
    {
        rgRows[i++] = iItem;
    }

    // Now ask the table for a message ID list
    if (FAILED(m_pTable->GetMessageIdList(FALSE, cRows, rgRows, &rMsgIDList)))
        goto exit;

    // Initialize the data object
    pDataObject->Initialize(&rMsgIDList, m_idFolder);

    // If this folder is a news folder, then we only allow copies
    if (FOLDER_NEWS != GetFolderType(m_idFolder))
        dwEffectOk |= DROPEFFECT_MOVE;

    // AddRef() the drop source while we do this
    ((IDropSource *) this)->AddRef();
    hr = DoDragDrop(pDataObject, (IDropSource *) this, dwEffectOk, &dwEffect);
    ((IDropSource *) this)->Release();

exit:
    SafeMemFree(rgRows);
    SafeMemFree(rMsgIDList.prgidMsg);
    SafeRelease(pDataObject);

    return;
}

HRESULT CMessageList::OnResetView(void)
{
    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Sel change notification should happen here
    SetTimer(IDT_SEL_CHANGE_TIMER, GetDoubleClickTime() / 2, NULL);

    // Reset the view
    _ResetView(idSel);

    // Done
    return(S_OK);
}

HRESULT CMessageList::OnRedrawState(BOOL fRedraw)
{
    // Just take the state
    m_fNotifyRedraw = fRedraw;

    // No Redraw ?
    if (FALSE == m_fNotifyRedraw)
        SetWindowRedraw(m_ctlList, FALSE);
    else
        SetWindowRedraw(m_ctlList, TRUE);

    // Done
    return(S_OK);
}


HRESULT CMessageList::OnInsertRows(DWORD cRows, LPROWINDEX prgiRow, BOOL fExpanded)
{
    // Trace
    TraceCall("CMessageList::OnInsertRows");

    BOOL        fScroll;
    LV_ITEM     lvi = {0};
    COLUMN_ID   idSort;
    BOOL        fAscending;
    DWORD       top, count, page;

    // If we have the empty list window visible, hide it
    m_cEmptyList.Hide();

    // Get the current sort column and direction
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Gather the information we need to determine if we should scroll
    top = ListView_GetTopIndex(m_ctlList);
    page = ListView_GetCountPerPage(m_ctlList);
    count = ListView_GetItemCount(m_ctlList);

    // We scroll if the user is sorted by date and the new item would
    // be off the bottom of the page.
    fScroll = fAscending && (idSort == COLUMN_SENT || idSort == COLUMN_RECEIVED) &&
              (top + page >= count - 1);

    // Insert the row
    for (ULONG i=0; i<cRows; i++)
    {
        lvi.iItem = prgiRow[i];
        ListView_InsertItem(m_ctlList, &lvi);
    }

#ifdef OLDTIPS
    // If we have tooltips turned on, update them too
    if (m_fViewTip && m_ctlViewTip)
    {
        POINT pt;
        GetCursorPos(&pt);
        ::ScreenToClient(m_ctlList, &pt);
        _UpdateViewTip(pt.x, pt.y, TRUE);
    }
#endif // OLDTIPS

    // Scroll if we need to
    if (fScroll && m_fMailFolder)
        ListView_EnsureVisible(m_ctlList, ListView_GetItemCount(m_ctlList) - 1, FALSE);

    int iFocus = ListView_GetFocusedItem(m_ctlList);
    
    if (!m_fMailFolder && iFocus != -1 && !fExpanded)
        ListView_EnsureVisible(m_ctlList, iFocus, TRUE);

    // Update the host
    Fire_OnMessageCountChanged(m_pTable);
    return (S_OK);
}

HRESULT CMessageList::OnDeleteRows(DWORD cDeleted, LPROWINDEX rgdwDeleted, BOOL fCollapsed)
{
    int     iItemFocus = -1;
    DWORD   dwCount;
    DWORD   iNewSel;
    BOOL    fFocusDeleted = FALSE;
    BOOL    fFocusHasSel = FALSE;

    // Can't delete that which we do not have
    if (!m_pTable)
        return (0);

    // If we're going to delete everything
    if (cDeleted == (DWORD) -1)
    {
        iItemFocus = ListView_GetFirstSel(m_ctlList);
        if (iItemFocus != -1)
        {
            m_pTable->GetRowMessageId(iItemFocus, &m_idPreDelete);
        }
        else
            m_idPreDelete = 0;
    }
    else if (cDeleted != 0)
    {
        // Figure out which row has the focus.
        iItemFocus = ListView_GetFocusedItem(m_ctlList);

        // Figure out if the focused item was selected
        if (iItemFocus != -1)
            fFocusHasSel = !!(ListView_GetItemState(m_ctlList, iItemFocus, LVIS_SELECTED));

        for (ULONG i = 0; i < cDeleted; i++)
        {
            // If we're removing the row that has the focus, we're going to 
            // need to fix up the selection later.
            if (0 != ListView_GetItemState(m_ctlList, rgdwDeleted[i], LVIS_FOCUSED))
                fFocusDeleted = TRUE;

            ListView_DeleteItem(m_ctlList, rgdwDeleted[i]);
        }

        // Check to see if we deleted the item that had focus
        if (fFocusDeleted && fFocusHasSel)
        {
            // Get the new row with focus.  This ListView keeps moving the focus
            // as we delete rows.
            iItemFocus = ListView_GetFocusedItem(m_ctlList);

            // Select that item now.
            ListView_SelectItem(m_ctlList, iItemFocus);
        }

        // ListView_EnsureVisible(m_ctlList, iItemFocus, FALSE);

#ifdef OLDTIPS
        // If we have tooltips turned on, update them too
        if (m_fViewTip && m_ctlViewTip)
        {
            POINT pt;
            GetCursorPos(&pt);
            ::ScreenToClient(m_ctlList, &pt);
            _UpdateViewTip(pt.x, pt.y, TRUE);
        }
#endif // OLDTIPS
    }
    else
    {
        // If cDel is zero, then we should just reset the count of messages
        // with what's in the container.
        m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount);

        // Get the first selected item
        iItemFocus = ListView_GetFirstSel(m_ctlList);

        // Set the new number of items
        ListView_SetItemCountEx(m_ctlList, dwCount, LVSICF_NOSCROLL);

        // If there are messages then make sure the focus is appropriate
        if (dwCount)
        {
            if (iItemFocus != -1)
            {
                if (m_idPreDelete != 0)
                {
                    // Get the index of the bookmarked row
                    m_pTable->GetRowIndex(m_idPreDelete, &iNewSel);
                    if (iNewSel != -1)
                        iItemFocus = (int) iNewSel;
                    m_idPreDelete = 0;
                }

                // Clear the selection, then select this item and ensure it's 
                // visible.
                ListView_UnSelectAll(m_ctlList);
                ListView_SelectItem(m_ctlList, min((int) iItemFocus, (int) dwCount - 1));
                ListView_EnsureVisible(m_ctlList, min((int) iItemFocus, (int) dwCount - 1), FALSE);
            }
            else
            {
                ListView_UnSelectAll(m_ctlList);
                _SelectDefaultRow();
            }
        }
    }

    // Check to see if we need to put up the empty list warning.
    if (SUCCEEDED(m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount)))
    {
        if (0 == dwCount)
        {
            m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
        }
    }

    Fire_OnMessageCountChanged(m_pTable);

    // Done
    return(S_OK);
}

HRESULT CMessageList::OnUpdateRows(ROWINDEX iRowMin, ROWINDEX iRowMax)
{
    // Locals
    BOOL fHandled;

    // Trace
    TraceCall("CMessageList::OnUpdateRows");

    // Just do it
    OnHeaderStateChange(IMC_HDRSTATECHANGE, iRowMin, iRowMax, fHandled);

    // Done
    return(S_OK);
}

HRESULT CMessageList::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    // If this isn't NULL, then we forgot to free it last time.
    Assert(m_tyCurrent == SOT_INVALID);

    m_tyCurrent = tyOperation;

    if (tyOperation == SOT_GET_MESSAGE && pOpInfo)
    {
        // cache the current get message, for the oncomplete notification
        m_idMessage = pOpInfo->idMessage;        
    }

    // Got to hang on to this
    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();

        // Update the toolbar to activate ID_STOP.
        Fire_OnUpdateCommandState();
    }

    // Start the progress parade
    Fire_OnUpdateProgress(0, 0, PROGRESS_STATE_BEGIN);

    SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
    return (S_OK);
}


HRESULT CMessageList::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}


HRESULT CMessageList::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


HRESULT CMessageList::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwndParent, pServer, ixpServerType);
}


HRESULT CMessageList::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, 
                               UINT uType, INT *piUserResponse) 
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwndParent, hrError, pszText, pszCaption, uType, piUserResponse);
}


HRESULT CMessageList::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent,
                                 DWORD dwMax, LPCSTR pszStatus)
{
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES];
    TCHAR szProg[MAX_PATH + CCHMAX_STRINGRES];

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Deal with universal progress types
    switch (tyOperation)
    {
        // pszStatus == Server Name, dwCurrent = IXPSTATUS
        case SOT_CONNECTION_STATUS:
        {
            Assert(dwCurrent < IXP_LAST);

            // Create some lovely status text
            if (dwCurrent == IXP_DISCONNECTED)
            {
                AthLoadString(idsNotConnectedTo, szRes, ARRAYSIZE(szRes));
                wsprintf(szBuf, szRes, pszStatus);
                Fire_OnUpdateStatus(szBuf);
            }
            else
            {
                int ids = XPUtil_StatusToString((IXPSTATUS) dwCurrent);
                AthLoadString(ids, szRes, ARRAYSIZE(szRes));
            
                // Hit our host with this lovely string
                Fire_OnUpdateStatus(szRes);
            }
            break;
        }

        case SOT_NEW_MAIL_NOTIFICATION:
            ::PostMessage(m_hwndParent, WM_NEW_MAIL, 0, 0);
            break;
    }

    // If we're expecting progress for one command, but this ain't it, blow
    // it off.
    if (m_tyCurrent != tyOperation)
        return (S_OK);

    // Deal with the the various operation types
    switch (tyOperation)
    {
        case SOT_SORTING:
        {
            static CHAR s_szSorting[255]={0};
            if ('\0' == *s_szSorting)
                AthLoadString(idsSortingFolder, s_szSorting, ARRAYSIZE(s_szSorting));
            DWORD dwPercent = dwMax > 0 ? ((dwCurrent * 100) / dwMax) : 0;
            wsprintf(szBuf, s_szSorting, dwPercent);
            Fire_OnUpdateStatus(szBuf);
            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
            break;
        }

        // pszStatus == folder name
        case SOT_SYNC_FOLDER:
        {
            // Create some lovely status text
            AthLoadString(idsIMAPDnldProgressFmt, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, dwCurrent, dwMax);
            Fire_OnUpdateStatus(szBuf);

            // Also update the progress bar too
            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
            break;
        }

        case SOT_SET_MESSAGEFLAGS:
        {
            // If we were given status text, then tell our host
            if (pszStatus)
            {
                // Create some lovely status text
                AthLoadString(idsMarkingMessages, szRes, ARRAYSIZE(szRes));
                Fire_OnUpdateStatus(szRes);
            }

            // Also update the progress bar too
            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
            break;
        }
    
        case SOT_GET_MESSAGE:
        {
            ROWINDEX    iRow;
            LPMESSAGEINFO pInfo;
            
            if (!m_pszSubj)
            {
                if (m_pTable && (!FAILED(m_pTable->GetRowIndex(m_idMessage, &iRow))))
                {
                    if (!FAILED(m_pTable->GetRow(iRow, &pInfo)))
                    {
                        // clip subject to MAX_PATH chars to avoid buffer overrun
                        m_pszSubj = PszDupLenA(pInfo->pszSubject, MAX_PATH-1);
                        m_pTable->ReleaseRow(pInfo);
                    }
                } 
            }
            
            if (m_pszSubj)
            {
                // Show "Downloading Message: '<subject>'" (<subject> is clipped to MAX_PATH)
                AthLoadString(idsFmtDownloadingMessage, szRes, ARRAYSIZE(szRes));
                wsprintf(szProg, szRes, m_pszSubj);
                Fire_OnUpdateStatus(szProg);
            }

            Fire_OnUpdateProgress(dwCurrent, dwMax, PROGRESS_STATE_DEFAULT);
        }

    }

    return (S_OK);
}


HRESULT CMessageList::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete,
                                 LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    if (m_tyCurrent != tyOperation)
        return S_OK;

    // AddRef
    ((IStoreCallback *) this)->AddRef();

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    if (tyOperation == SOT_GET_ADURL )
    {
        if (SUCCEEDED(hrComplete) && pOpInfo)
            Fire_OnAdUrlAvailable(pOpInfo->pszUrl);

        if (m_pCancel)
        {
            m_pCancel->Release();
            m_pCancel = NULL;
        }

        // Close any timeout dialog, if present
        CallbackCloseTimeout(&m_hTimeout);
        Fire_OnUpdateProgress(0, 0, PROGRESS_STATE_END);

        goto exit;
    }

    if (tyOperation == SOT_GET_MESSAGE)
    {
        // message-download complete, fire a notification to
        // our host
    
        // supress article expired failures, we want to update the preview pane anyway
        // and it will update with an error that it has expired
        if (hrComplete == IXP_E_NNTP_ARTICLE_FAILED && pErrorInfo && 
            (pErrorInfo->uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_NUM || pErrorInfo->uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_FOUND))
            hrComplete = STORE_E_EXPIRED;

        // if call to OnMessageAvailable reutrn S_OK, then it has been handled so supress
        // error messages
        if (Fire_OnMessageAvailable(m_idMessage, hrComplete)==S_OK)
            hrComplete = S_OK;

        m_idMessage = MESSAGEID_INVALID;
        SafeMemFree(m_pszSubj);
    }

    // Release our cancel pointer
    if (m_pCancel)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
        Fire_OnUpdateCommandState();
    }

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // We're done now
    Fire_OnUpdateProgress(0, 0, PROGRESS_STATE_END);

    // Display an Error on Failures
    if (FAILED(hrComplete) && hrComplete != HR_E_OFFLINE)
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwndParent, hrComplete, pErrorInfo);
    }

    if (NULL != m_pTable && tyOperation == SOT_SYNC_FOLDER || tyOperation == SOT_SEARCHING)
    {
        DWORD dwCount;  

        Assert (m_pTable);

        // Get the current selection
        DWORD iSel = ListView_GetFirstSel(m_ctlList);

        // Bookmark the current selection
        MESSAGEID idSel = 0;
        if (iSel != -1)
            m_pTable->GetRowMessageId(iSel, &idSel);

        // If this succeeds reset the view
        if (SUCCEEDED(m_pTable->OnSynchronizeComplete()))
        {
            // Reset the view
            _ResetView(idSel);

            // Update the status
            Fire_OnMessageCountChanged(m_pTable);
        }

        // Check to see if we need to put up the empty list warning.
        if (SUCCEEDED(m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, &dwCount)))
        {
            if (0 == dwCount)
            {
                m_cEmptyList.Show(m_ctlList, (LPTSTR)IntToPtr(m_idsEmptyString));
            }
        }
    }
    
exit:
    m_tyCurrent = SOT_INVALID;

    // Release
    ((IStoreCallback *) this)->Release();

    return (S_OK);
}


HRESULT CMessageList::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hrResult;

    TraceCall("CMessageList::GetParentWindow");
    if (IsWindow(m_hwndParent))
    {
        *phwndParent = m_hwndParent;
        hrResult = S_OK;
    }
    else
    {
        *phwndParent = NULL;
        hrResult = E_FAIL;
    }

    return hrResult;
}


HRESULT CMessageList::CanConnect(LPCSTR pszAccountId, DWORD dwFlags) 
{ 
    BOOL        fPrompt = FALSE;
    HWND        hwndParent;
    DWORD       dwReserved = 0;
    HRESULT     hr;

    //Irrespective of the operation, prompt if we are not offline
    fPrompt = (g_pConMan->IsGlobalOffline() == FALSE);

    if (GetParentWindow(dwReserved, &hwndParent) != S_OK)
    {
        fPrompt = FALSE;
    }

    if (CC_FLAG_DONTPROMPT & dwFlags)
        fPrompt = FALSE;

    hr = CallbackCanConnect(pszAccountId, hwndParent, fPrompt);

    if ((hr == HR_E_DIALING_INPROGRESS) && (m_tyCurrent == SOT_SYNC_FOLDER))
    {
        //this sync operation will eventually fail. But we sync again when we get called in Resynchronize
        m_fSyncAgain = TRUE;
    }
    return hr;
}

HRESULT CMessageList::Resynchronize()
{
    DWORD       dwChunks;
    HRESULT     hr = S_OK;

    if (m_fSyncAgain)
    {
        m_fSyncAgain = FALSE;

        //If we are offline, that is because the user hit cancel or work offline on dialer UI
        if (g_pConMan && (g_pConMan->IsGlobalOffline()))
        {
            g_pConMan->SetGlobalOffline(FALSE);
        }

        // Tell the table to go sync any headers from the server
        if (GetFolderType(m_idFolder) == FOLDER_NEWS)
        {
            if (OPTION_OFF != m_dwGetXHeaders)
                hr = m_pTable->Synchronize(SYNC_FOLDER_XXX_HEADERS, m_dwGetXHeaders, this);
            else
                hr = m_pTable->Synchronize(NOFLAGS, 0, this);
        }
        else
        {
            hr = m_pTable->Synchronize(SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS, 0, this);
        }
    }
    return hr;
}

HRESULT CMessageList::HasFocus(void)
{
    if (GetFocus() == m_ctlList)
        return (S_OK);
    else
        return (S_FALSE);
}


#define MF_CHECKFLAGS(b)    (MF_BYCOMMAND|(b?MF_CHECKED:MF_UNCHECKED))
HRESULT CMessageList::OnPopupMenu(HMENU hMenu, DWORD idPopup)
{
    MENUITEMINFO    mii;
    
    // Edit Menu
    if (idPopup == ID_POPUP_EDIT)
    {
        // Figure out which item is focused
        int iItem = ListView_GetFocusedItem(m_ctlList);
        if (-1 != iItem && m_pTable)
        {
            DWORD dwState;

            m_pTable->GetRowState(iItem, ROW_STATE_FLAGGED, &dwState);
            CheckMenuItem(hMenu, ID_FLAG_MESSAGE, MF_BYCOMMAND | (dwState & ROW_STATE_FLAGGED) ? MF_CHECKED : MF_UNCHECKED);
        }
    } 

    // View Menu
    else if (idPopup == ID_POPUP_VIEW)
    {
        // Get the handle of the "Sort" menu
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU;
    
        if (GetMenuItemInfo(hMenu, ID_POPUP_SORT, FALSE, &mii))
        {
            // Add the sort menu information
            m_cColumns.FillSortMenu(mii.hSubMenu, ID_SORT_MENU_FIRST, &m_cSortItems, &m_cSortCurrent);                
            m_iColForPopup = -1;
        }
    }    
    return (S_OK);
}


LRESULT CMessageList::OnListVScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT     lResult;
    int         iTopIndex;
    TOOLINFO    ti = {0};
    TCHAR       sz[1024];
    BOOL        fLogicalLeft = FALSE;

    // Let the ListView have the scroll message first
    lResult = m_ctlList.DefWindowProc(uMsg, wParam, lParam);

    // We only do the scroll tips if m_fScrollTip is TRUE
    if (!m_fScrollTip)
        return (lResult);

    // If the user is dragging the thumb, then update our tooltip
    if (LOWORD(wParam) == SB_THUMBTRACK)
    {
        // Figure out what the top most index is
        iTopIndex = ListView_GetTopIndex(m_ctlList);

        // Set the tip text
        ti.cbSize   = sizeof(TOOLINFO);
        ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd     = m_hWnd;
        ti.uId      = (UINT_PTR)(HWND) m_ctlList;

        COLUMN_ID idSort;
        BOOL      fAscending;
        DWORD     col;
        
        // Get the column we're currently sorted on
        m_cColumns.GetSortInfo(&idSort, &fAscending);

        // Get the row from the table
        LPMESSAGEINFO pInfo;

        if (SUCCEEDED(m_pTable->GetRow(iTopIndex, &pInfo)))
        {
            // Get the display text for this row
            if (idSort != COLUMN_SUBJECT)
                _GetColumnText(pInfo, idSort, sz, ARRAYSIZE(sz));
            else if (pInfo->pszNormalSubj)
                lstrcpyn(sz, pInfo->pszNormalSubj, ARRAYSIZE(sz));
            else
                //Bug #101352 - (erici) Don't pass NULL src to lstrcpyn.  It will fail and not initialize this buffer.
                memset(&sz, 0, sizeof(sz));

            if (*sz == 0)
                AthLoadString(idsNoSubject, sz, ARRAYSIZE(sz));

            ti.lpszText = sz;
#ifdef OLDTIPS
            m_ctlScrollTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM) &ti);
    
            // Update the position.  The y position will be where the mouse 
            // cursor is.  The x position is either fixed to the right edge
            // of the scroll bar, or the left edge depending on how close
            // the edge of the screen is.
            POINT pt;
            RECT rc;
            RECT rcTip;
            DWORD cxScreen;
            BOOL bMirrored = IS_WINDOW_RTL_MIRRORED(m_hWnd);
            // Get the mouse position, the window position, and the screen
            // width.
            GetCursorPos(&pt);
            GetWindowRect(&rc);
            m_ctlScrollTip.GetWindowRect(&rcTip);
            cxScreen = GetSystemMetrics(SM_CXSCREEN);

            // Check to see if we're too close to the screen edge
            if (((cxScreen - pt.x > 100) && !bMirrored) || ((pt.x > 100) && bMirrored))
            {
               if(bMirrored)
               {
                    pt.x = rc.left - GetSystemMetrics(SM_CXBORDER);

                    // Make sure the tip isn't wider than the screen.
                    m_ctlScrollTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, pt.x);
                    pt.x -= (rcTip.right - rcTip.left);
               
               }
               else
               {
                    pt.x = rc.right + GetSystemMetrics(SM_CXBORDER);

                    // Make sure the tip isn't wider than the screen.
                    m_ctlScrollTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, cxScreen - pt.x);
                }
            }
            else
            {
                // So we can verify later
                fLogicalLeft = TRUE;

                // Figure out how wide the string will be
                SIZE size;
                HDC hdcTip = m_ctlScrollTip.GetDC();
                GetTextExtentPoint32(hdcTip, sz, lstrlen(sz), &size);
                m_ctlScrollTip.ReleaseDC(hdcTip);

                // Figure out if the string is wider than our window
                if (size.cx > (rc.right - rc.left))
                {
                    if(bMirrored)
                    {
                        pt.x = rc.right - (rcTip.right - rcTip.left);                    
                    }
                    else
                    {
                        pt.x = rc.left;
                    }    
                }
                else
                {
                    RECT rcMargin;
                    m_ctlScrollTip.SendMessage(TTM_GETMARGIN, 0, (LPARAM) &rcMargin);
                    if(bMirrored)
                    {
                        pt.x = rc.left + GetSystemMetrics(SM_CXHTHUMB);                    
                    }
                    else
                    {
                        pt.x = rc.right - GetSystemMetrics(SM_CXHTHUMB) - rcMargin.left - rcMargin.right - size.cx;
                    }
                }

                // Make sure the tip isn't wider than the window
                m_ctlScrollTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, rc.right - rc.left);
            }

            // Show the tooltip
            if (!m_fScrollTipVisible)
            {               
                m_ctlScrollTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
                m_fScrollTipVisible = TRUE;

                // Set the autohide timer
                SetTimer(IDT_SCROLL_TIP_TIMER, 250, NULL);
            }
            
            // Update the tip position
            m_ctlScrollTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));

            if (fLogicalLeft)
            {
                // Get the position of the tip

                int x;
                m_ctlScrollTip.GetWindowRect(&rcTip);
                
                if(bMirrored)
                {
                    x = rc.left + GetSystemMetrics(SM_CXHTHUMB) + 4;
                    
                }
                else
                {
                    x = rc.right - GetSystemMetrics(SM_CXHTHUMB) - (rcTip.right - rcTip.left) - 4;
                }
                m_ctlScrollTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(x, rcTip.top));

            }
#endif //OLDTIPS
            m_pTable->ReleaseRow(pInfo);
        }
    }

    return (lResult);
}



//
//  FUNCTION:   CMessageList::OnDestroy()
//
//  PURPOSE:    When we get destroyed, we need to make sure we destroy the tooltips
//              as well.  If we don't we will fault on shutdown.
//
LRESULT CMessageList::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    KillTimer(IDT_POLLMSGS_TIMER);

    // Don't care about these any more
    if (m_pListSelector)
    {
        m_pListSelector->Unadvise();
        m_pListSelector->Release();
    }

#ifdef OLDTIPS
    if (IsWindow(m_ctlScrollTip))
    {
        m_ctlScrollTip.SendMessage(TTM_POP, 0, 0);
        m_ctlScrollTip.DestroyWindow();
    }

    if (IsWindow(m_ctlViewTip))
    {
        m_ctlViewTip.SendMessage(TTM_POP, 0, 0);
        m_ctlViewTip.DestroyWindow();
    }
#endif // OLDTIPS

    // Release the font cache if we are advised on it.
    if (m_dwFontCacheCookie && g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Unadvise(m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    return (0);
}


//
//  FUNCTION:   CMessageList::OnSelectRow()
//
//  PURPOSE:    This get's called when the user does a next / prev in the notes.
//
LRESULT CMessageList::OnSelectRow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (lParam < ListView_GetItemCount(m_ctlList))
    {
        ListView_SetItemState(m_ctlList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
        ListView_SetItemState(m_ctlList, lParam, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        ListView_EnsureVisible(m_ctlList, lParam, FALSE);
    }

    return (0);
}


#ifdef OLDTIPS
//
//  FUNCTION:   CMessageList::OnListMouseEvent()
//
//  PURPOSE:    Whenever we get our first mouse event in a series, we call
//              TrackMouseEvent() so we know when the mouse leaves the ListView.
//
LRESULT CMessageList::OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If we have the view tooltip, then we track all mouse events
    if (!m_fTrackSet && m_fViewTip && (uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST))
    {
        TRACKMOUSEEVENT tme;

        tme.cbSize = sizeof(tme);
        tme.hwndTrack = m_ctlList;
        tme.dwFlags = TME_LEAVE;

        if (_TrackMouseEvent(&tme))
            m_fTrackSet = TRUE;
    }

    bHandled = FALSE;
    return (0);
}


//
//  FUNCTION:   CMessageList::OnListMouseMove()
//
//  PURPOSE:    If the ListView tooltips are turned on, we need to relay mouse
//              move messages to the tooltip control and update our cached 
//              information about what the mouse is over.
//
LRESULT CMessageList::OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    MSG msg;
    LVHITTESTINFO lvhti;

    // If we're displaying view tips, then we need to figure out if the mouse is
    // over the same item or not.
    if (m_fViewTip && m_ctlViewTip)
    {
        if (_UpdateViewTip(LOWORD(lParam), HIWORD(lParam)))
        {
            /*
            msg.hwnd    = m_ctlList;
            msg.message = uMsg;
            msg.wParam  = wParam;
            msg.lParam  = lParam;
            m_ctlViewTip.SendMessage(TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
            */
        }
    }

    bHandled = FALSE;
    return (0);
}


//
//  FUNCTION:   CMessageList::OnListMouseLeave()
//
//  PURPOSE:    When the mouse leaves the ListView window, we need to make
//              sure we hide the tooltip.
//
LRESULT CMessageList::OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TOOLINFO ti = {0};

    if (m_fViewTip && m_ctlViewTip)
    {
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)(HWND) m_ctlList;

        // Hide the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
        m_fViewTipVisible = FALSE;

        // Reset our item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        // Tracking is no longer set
        m_fTrackSet = FALSE;
    }

    bHandled = FALSE;
    return (0);
}
#endif // OLDTIPS


LRESULT CMessageList::OnListSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If an operation is pending and the cursor would be the arrow, change it
    // into the appstart arrow
    if (m_pCancel && LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        return (1);
    }
        
    // Find out what the default is
    return ::DefWindowProc(m_ctlList, uMsg, wParam, lParam);
}


#ifdef OLDTIPS
BOOL CMessageList::_UpdateViewTip(int x, int y, BOOL fForceUpdate)
{
    LVHITTESTINFO lvhti;
    TOOLINFO      ti = {0};
    FNTSYSTYPE    fntType;
    RECT          rc;
    LPMESSAGEINFO pInfo;
    COLUMN_ID     idColumn;
    TCHAR         szText[256] = _T("");
    POINT         pt;
    LVITEM        lvi;
    int           top, page;

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd   = m_hWnd;
    ti.uId    = (UINT_PTR)(HWND) m_ctlList;

    // Get the item and subitem the mouse is currently over
    lvhti.pt.x = x;
    lvhti.pt.y = y;
    ListView_SubItemHitTest(m_ctlList, &lvhti);

    top = ListView_GetTopIndex(m_ctlList);
    page = ListView_GetCountPerPage(m_ctlList);

    // If the item doesn't exist, then the above call returns the item -1.  If
    // we encounter -1, we break the loop and return FALSE.
    if (lvhti.iItem < top || lvhti.iItem > (top + page) || -1 == lvhti.iItem || !_IsItemTruncated(lvhti.iItem, lvhti.iSubItem) || !::IsChild(GetForegroundWindow(), m_ctlList))
    {
        // Hide the tip
        if (m_fViewTipVisible)
        {
            m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
            m_fViewTipVisible = FALSE;
        }

        // Reset the item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        return (FALSE);
    }

    // If we don't have the tooltip visible right now, then delay before we display it
    if (!m_fViewTipVisible && !fForceUpdate)
    {
        ::SetTimer(m_hWnd, IDT_VIEWTIP_TIMER, 500, NULL);
        return (FALSE);
    }

    // If the newly found item & subitem is different from what we're already
    // set up to show, then update the tooltip
    if (fForceUpdate || (m_iItemTip != lvhti.iItem || m_iSubItemTip != lvhti.iSubItem))
    {
        // Update our cached item / subitem
        m_iItemTip = lvhti.iItem;
        m_iSubItemTip = lvhti.iSubItem;

        // Set the font for the tooltip
        fntType = _GetRowFont(m_iItemTip);
        m_ctlViewTip.SendMessage(WM_SETFONT, (WPARAM) HGetCharSetFont(fntType, m_hCharset), 0);

        // Get the row from the table
        if (m_pTable && SUCCEEDED(m_pTable->GetRow(m_iItemTip, &pInfo)))
        {
            // Convert the iSubItem to a COLUMN_ID
            idColumn = m_cColumns.GetId(m_iSubItemTip);

            // Get the display text for this row
            _GetColumnText(pInfo, idColumn, szText, ARRAYSIZE(szText));

            ti.lpszText = szText;
            m_ctlViewTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM) &ti);

            // Figure out where to place the tip
            ListView_GetSubItemRect(m_ctlList, m_iItemTip, m_iSubItemTip, LVIR_LABEL, &rc);
            m_ctlList.MapWindowPoints(HWND_DESKTOP, (LPPOINT)&rc, 2);

            // Make sure the tip is no wider than our window
            RECT rcWindow;
            GetWindowRect(&rcWindow);
            m_ctlViewTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, rcWindow.right - rc.left);

            // Do some voodoo to line up the tooltip
            pt.x = rc.left;
            pt.y = rc.top;

            // Figure out if this column has an image
            lvi.mask = LVIF_IMAGE;
            lvi.iItem = m_iItemTip;
            lvi.iSubItem = m_iSubItemTip;
            ListView_GetItem(m_ctlList, &lvi);

            if (lvi.iImage == -1)
            {                
                RECT rcHeader;
                HWND hwndHeader = ListView_GetHeader(m_ctlList);
                Header_GetItemRect(hwndHeader, m_iSubItemTip, &rcHeader);
                ::MapWindowPoints(hwndHeader, HWND_DESKTOP, (LPPOINT) &rcHeader,2);
                pt.x = rcHeader.left + (GetSystemMetrics(SM_CXEDGE) * 2) - 1;
            }
            else
                pt.x -= GetSystemMetrics(SM_CXBORDER);

            // Update the tooltip position
            pt.y -= 2 * GetSystemMetrics(SM_CXBORDER);

            m_ctlViewTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));

            // Update the tooltip
            m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
            m_fViewTipVisible = TRUE;

            m_pTable->ReleaseRow(pInfo);

            return (TRUE);
        }
    }

    return (FALSE);
}


//
//  FUNCTION:   CMessageList::_OnViewTipShow()
//
//  PURPOSE:    When the tooltip for the ListView get's shown, we need to 
//              update the font and position for the tip.
//
LRESULT CMessageList::_OnViewTipShow(void)
{
    RECT       rc;
    FNTSYSTYPE fntType;

    // We only get the text for items that exist
    if (m_iItemTip != -1 && m_iSubItemTip != -1)
    {
        // Set the font for the tooltip
        fntType = _GetRowFont(m_iItemTip);
        m_ctlViewTip.SendMessage(WM_SETFONT, (WPARAM) HGetCharSetFont(fntType, m_hCharset), 0);
                                 
        // Figure out where to place the tip
        ListView_GetSubItemRect(m_ctlList, m_iItemTip, m_iSubItemTip, LVIR_LABEL, &rc);
        m_ctlList.ClientToScreen(&rc);

        // Set the position of the tip
        m_ctlViewTip.SetWindowPos(NULL, rc.left - GetSystemMetrics(SM_CXBORDER), 
                                  rc.top - GetSystemMetrics(SM_CXBORDER), 0, 0, 
                                  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    }

    return (0);
}


LRESULT CMessageList::_OnViewTipGetDispInfo(LPNMTTDISPINFO pttdi)
{
    LPMESSAGEINFO pInfo;
    COLUMN_ID idColumn;

    // If this is the case, there's nothing to provide
    if (-1 == m_iItemTip || !m_pTable)
        return (0);

    // Sanity check
    if (m_iItemTip > (ListView_GetItemCount(m_ctlList) - 1))
    {
        Assert(FALSE);
        m_iItemTip = -1;
        return (0);
    }

    // Get the row from the table
    if (FAILED(m_pTable->GetRow(m_iItemTip, &pInfo)))
        return (0);

    // Convert the iSubItem to a COLUMN_ID
    idColumn = m_cColumns.GetId(m_iSubItemTip);

    // Get the text for the item from the table
    _GetColumnText(pInfo, idColumn, pttdi->szText, ARRAYSIZE(pttdi->szText));

    m_pTable->ReleaseRow(pInfo);

    if (*pttdi->szText == 0)
        return (0);

    return (1);
}


BOOL CMessageList::_IsItemTruncated(int iItem, int iSubItem)
{
    HDC     hdc;
    SIZE    size;
    BOOL    bRet = TRUE;
    LVITEM  lvi;
    TCHAR   szText[256] = _T("");
    int     cxEdge;
    BOOL    fBold;
    RECT    rcText;
    int     cxWidth;
    HFONT   hf;

    // Get the text of the specified item
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
    lvi.iItem = iItem;
    lvi.iSubItem = iSubItem;
    lvi.pszText = szText;
    lvi.cchTextMax = ARRAYSIZE(szText);
    ListView_GetItem(m_ctlList, &lvi);

    // If there's no text, it's not truncated, eh?
    if (0 == *szText)
        return (FALSE);

    // ListView uses this for padding
    cxEdge = GetSystemMetrics(SM_CXEDGE);

    // Get the sub item rect from the ListView
    ListView_GetSubItemRect(m_ctlList, iItem, iSubItem, LVIR_LABEL, &rcText);

    // Figure out the width
    cxWidth = rcText.right - rcText.left;
    if (lvi.iImage == -1)
        cxWidth -= (4 * cxEdge);
    else
        cxWidth -= (2 * cxEdge);

    // Figure out the width of the string
    hdc = m_ctlList.GetDC();
    hf = SelectFont(hdc, HGetCharSetFont(_GetRowFont(iItem), m_hCharset));

    GetTextExtentPoint(hdc, szText, lstrlen(szText), &size);

    SelectFont(hdc, hf);
    m_ctlList.ReleaseDC(hdc);

    return (cxWidth < size.cx);
}
#endif // OLDTIPS


FNTSYSTYPE CMessageList::_GetRowFont(int iItem)
{
    HFONT      hFont;
    FNTSYSTYPE fntType;
    DWORD      dwState;

    // Get the row state information
    m_pTable->GetRowState(iItem, ROW_STATE_DELETED, &dwState);

    // Determine the right font for this row
    if (dwState & ROW_STATE_DELETED)
        fntType = FNT_SYS_ICON_STRIKEOUT;
    else
    {
        m_pTable->GetRowState(iItem, ROW_STATE_READ, &dwState);
        if (dwState & ROW_STATE_READ)
            fntType = FNT_SYS_ICON;
        else
            fntType = FNT_SYS_ICON_BOLD;
    }        

    return (fntType);
}


void CMessageList::_SetColumnSet(FOLDERID id, BOOL fFind)
{
    FOLDERINFO      rFolder;
    COLUMN_SET_TYPE set;
    HRESULT         hr;

    // If we've already initialized, bail
    if (m_fColumnsInit)
        return;

    // Get the folder type from the store
    hr = g_pStore->GetFolderInfo(id, &rFolder);
    if (FAILED(hr))
        return;

    // Local store
    if (FOLDER_LOCAL == rFolder.tyFolder)
    {
        // Find
        if (fFind)
            set = COLUMN_SET_FIND;
        else 
        {
            // If this is the Outbox or Sent Items folder, we use the outbound
            // folder columns.
            if (rFolder.tySpecial == FOLDER_OUTBOX || rFolder.tySpecial == FOLDER_SENT || rFolder.tySpecial == FOLDER_DRAFT)
                set = COLUMN_SET_OUTBOX;
            else
                set = COLUMN_SET_MAIL;
        }
    }
    else if (FOLDER_IMAP == rFolder.tyFolder)
    {
        // If this is the Outbox or Sent Items folder, we use the outbound
        // folder columns.
        if (rFolder.tySpecial == FOLDER_OUTBOX || rFolder.tySpecial == FOLDER_SENT)
            set = COLUMN_SET_IMAP_OUTBOX;
        else
            set = COLUMN_SET_IMAP;
    }
    else if (FOLDER_NEWS == rFolder.tyFolder)
    {
        if (fFind)
            set = COLUMN_SET_FIND;
        else
            set = COLUMN_SET_NEWS;
    }
    else if (FOLDER_HTTPMAIL == rFolder.tyFolder)
    {
        if (rFolder.tySpecial == FOLDER_OUTBOX || rFolder.tySpecial == FOLDER_SENT)
            set = COLUMN_SET_HTTPMAIL_OUTBOX;
        else
            set = COLUMN_SET_HTTPMAIL;
    }

    // Save it
    m_ColumnSetType = set;

    // If the ListView has already been created, update the columns.
    if (IsWindow(m_ctlList))
    {
        BYTE rgBuffer[256];
        DWORD cb = ARRAYSIZE(rgBuffer);

        m_cColumns.Initialize(m_ctlList, m_ColumnSetType);

        // Get the column info from the table
        m_cColumns.ApplyColumns(COLUMN_LOAD_REGISTRY, 0, 0);
    }

    g_pStore->FreeRecord(&rFolder);
    m_fColumnsInit = TRUE;
}

HRESULT CMessageList::get_Folder(ULONGLONG *pVal)
{
    if (pVal)
    {
        *pVal = (ULONGLONG) m_idFolder;
        return (S_OK);
    }

    return (E_FAIL);
}


HRESULT CMessageList::put_Folder(ULONGLONG newVal)
{
    HRESULT hr = S_OK;

    if (FireOnRequestEdit(DISPID_LISTPROP_FOLDER) == S_FALSE)
        return S_FALSE;

    if (SUCCEEDED(hr = SetFolder((FOLDERID) newVal, NULL, FALSE, NULL, this)))
    {
        FireOnChanged(DISPID_LISTPROP_FOLDER);
        return (S_OK);
    }

    return (hr);
}


HRESULT CMessageList::get_ExpandGroups(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fAutoExpandThreads;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ExpandGroups(BOOL newVal)
{
    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_EXPAND_GROUPS) == S_FALSE)
        return S_FALSE;

    // Save it.  If we haven't got a table yet we'll save the value for later.
    m_fAutoExpandThreads = newVal;

    // Only party if we have a message table, eh?
    if (m_pTable)
    {
        // Do it
        if (m_fAutoExpandThreads)
            m_pTable->Expand(-1);
        else
            m_pTable->Collapse(-1);

        _UpdateListViewCount();
    }

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_EXPAND_GROUPS);

    return (S_OK);
}


HRESULT CMessageList::get_GroupMessages(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fThreadMessages;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_GroupMessages(BOOL newVal)
{
    // Update the ListView
    COLUMN_ID       idSort;
    BOOL            fAscending;
    FOLDERSORTINFO  SortInfo;

    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_GROUP_MESSAGES) == S_FALSE)
        return S_FALSE;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Save the new setting
    m_fThreadMessages = newVal;

    // Adjust show replies filter
    m_fShowReplies = m_fThreadMessages ? m_fShowReplies : FALSE;
   
    // Get the Sort Info
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Set the Sort Info
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reload the table.
    _ResetView(idSel);

    if (m_fThreadMessages)
        ListView_SetImageList(m_ctlList, GetImageList(GIML_STATE), LVSIL_STATE);
    else
        ListView_SetImageList(m_ctlList, NULL, LVSIL_STATE);

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_GROUP_MESSAGES);

    return S_OK;
}


HRESULT CMessageList::get_SelectFirstUnread(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fSelectFirstUnread;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_SelectFirstUnread(BOOL newVal)
{
    if (FireOnRequestEdit(DISPID_LISTPROP_SELECT_FIRST_UNREAD) == S_FALSE)
        return S_FALSE;

    // Save the value.  We don't change any selection however.
    m_fSelectFirstUnread = newVal;

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_SELECT_FIRST_UNREAD);

    return S_OK;
}


HRESULT CMessageList::get_MessageTips(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fViewTip;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_MessageTips(BOOL newVal)
{
    if (FireOnRequestEdit(DISPID_LISTPROP_MESSAGE_TIPS) == S_FALSE)
        return S_FALSE;

    m_fViewTip = newVal;

    FireOnChanged(DISPID_LISTPROP_MESSAGE_TIPS);
    return (S_OK);
}


HRESULT CMessageList::get_ScrollTips(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fScrollTip;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ScrollTips(BOOL newVal)
{
    if (FireOnRequestEdit(DISPID_LISTPROP_SCROLL_TIPS) == S_FALSE)
        return S_FALSE;

    m_fScrollTip = newVal;

    FireOnChanged(DISPID_LISTPROP_SCROLL_TIPS);
    return (S_OK);
}


HRESULT CMessageList::get_Count(long *pVal)
{
    if (pVal)
    {
        if (m_pTable)
            m_pTable->GetCount(MESSAGE_COUNT_VISIBLE, (ULONG *) pVal);
        else 
            *pVal = 0;

        return S_OK;
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::get_UnreadCount(long *pVal)
{
    if (pVal)
    {
        if (m_pTable)
            m_pTable->GetCount(MESSAGE_COUNT_UNREAD, (ULONG *) pVal);
        else 
            *pVal = 0;

        return S_OK;
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::get_SelectedCount(long *pVal)
{
    if (pVal)
    {
        if (IsWindow(m_ctlList))
            *pVal = ListView_GetSelectedCount(m_ctlList);
        else 
            *pVal = 0;

        return S_OK;
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::get_PreviewMessage(BSTR *pbstr)
{
    IMimeMessage    *pMsg;
    IStream         *pstm;
 
    *pbstr = NULL;
    
    // hack for HOTMAIL demo
    if (SUCCEEDED(_GetSelectedCachedMessage(TRUE, &pMsg)))
    {
        if (pMsg->GetMessageSource(&pstm, 0)==S_OK)
        {
            WriteStreamToFile(pstm, "c:\\oe_prev$.eml", CREATE_ALWAYS, GENERIC_WRITE);
            pstm->Release();
        }
        *pbstr = SysAllocString(L"c:\\oe_prev$.eml");
        pMsg->Release();
    }
    
    return (S_OK);
}

HRESULT CMessageList::get_FilterMessages(ULONGLONG *pVal)
{
    if (pVal)
    {
        *pVal = (ULONGLONG) m_ridFilter;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_FilterMessages(ULONGLONG newVal)
{
    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_FILTER_MESSAGES) == S_FALSE)
        return S_FALSE;

    // Reload the table.
    _FilterView((RULEID) newVal);

    // Tell people about it    
    FireOnChanged(DISPID_LISTPROP_FILTER_MESSAGES);

    // Send the update notification
    Fire_OnFilterChanged(m_ridFilter);
    
    return S_OK;
}

HRESULT CMessageList::get_ShowDeleted(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fShowDeleted;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ShowDeleted(BOOL newVal)
{
    // Update the ListView
    COLUMN_ID       idSort;
    BOOL            fAscending;
    FOLDERSORTINFO  SortInfo;

    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_SHOW_DELETED) == S_FALSE)
        return S_FALSE;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Save the new setting
    m_fShowDeleted = newVal;
   
    // Get the Sort Info
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Set the Sort Info
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reload the table.
    _ResetView(idSel);

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_SHOW_DELETED);

    return S_OK;
}

HRESULT CMessageList::get_ShowReplies(BOOL *pVal)
{
    if (pVal)
    {
        *pVal = m_fShowReplies;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageList::put_ShowReplies(BOOL newVal)
{
    // Update the ListView
    COLUMN_ID       idSort;
    BOOL            fAscending;
    FOLDERSORTINFO  SortInfo;

    // See if we're allowed to party
    if (FireOnRequestEdit(DISPID_LISTPROP_SHOW_REPLIES) == S_FALSE)
        return S_FALSE;

    // Get the current selection
    DWORD iSel = ListView_GetFirstSel(m_ctlList);

    // Bookmark the current selection
    MESSAGEID idSel = 0;
    if (iSel != -1)
        m_pTable->GetRowMessageId(iSel, &idSel);

    // Save the new setting
    m_fShowReplies = newVal;
   
    // Get the Sort Info
    m_cColumns.GetSortInfo(&idSort, &fAscending);

    // Gots to be threaded
    if (m_fShowReplies)
        m_fThreadMessages = TRUE;

    // Fill a SortInfo
    SortInfo.idColumn = idSort;
    SortInfo.fAscending = fAscending;
    SortInfo.fThreaded = m_fThreadMessages;
    SortInfo.fExpandAll = DwGetOption(OPT_AUTOEXPAND);
    SortInfo.ridFilter = m_ridFilter;
    SortInfo.fShowDeleted = m_fShowDeleted;
    SortInfo.fShowReplies = m_fShowReplies;

    // Set the Sort Info
    m_pTable->SetSortInfo(&SortInfo, this);

    // Make sure the filter got set correctly
    _DoFilterCheck(SortInfo.ridFilter);

    // Reload the table.
    _ResetView(idSel);

    if (m_fThreadMessages)
        ListView_SetImageList(m_ctlList, GetImageList(GIML_STATE), LVSIL_STATE);
    else
        ListView_SetImageList(m_ctlList, NULL, LVSIL_STATE);

    // The counts Change Here...
    Fire_OnMessageCountChanged(m_pTable);

    // Tell people about it
    FireOnChanged(DISPID_LISTPROP_SHOW_REPLIES);

    return S_OK;
}


HRESULT CMessageList::PromptToGoOnline()
{
    HRESULT     hr;

    if (g_pConMan->IsGlobalOffline())
    {
        if (IDYES == AthMessageBoxW(m_hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))    
        {
            g_pConMan->SetGlobalOffline(FALSE);
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT CMessageList::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, 
                                         CConnectionManager *pConMan)
{
    m_dwConnectState = 0L;
    if ((nCode == CONNNOTIFY_WORKOFFLINE && pvData) || 
        (nCode == CONNNOTIFY_DISCONNECTING) || 
        (nCode == CONNNOTIFY_DISCONNECTED))
    {
        m_dwConnectState = NOT_CONNECTED;
    }
    else
    if (nCode == CONNNOTIFY_CONNECTED)
    {
        m_dwConnectState = CONNECTED;
    }
    else
    if (nCode == CONNNOTIFY_WORKOFFLINE && !pvData)
    {  
        UpdateConnInfo();
    }

    return S_OK;
}

void CMessageList::UpdateConnInfo()
{
    FOLDERINFO      rFolderInfo = {0};
    TCHAR           AccountId[CCHMAX_ACCOUNT_NAME];

    if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rFolderInfo)))
    {
        if (SUCCEEDED(GetFolderAccountId(&rFolderInfo, AccountId)))
        {
            if (g_pConMan)
            {
                if (g_pConMan->CanConnect(AccountId) == S_OK)
                {
                    m_dwConnectState = CONNECTED;
                }
                else
                {
                    m_dwConnectState = NOT_CONNECTED;
                }
            }
        }
        g_pStore->FreeRecord(&rFolderInfo);
    }
}


void CMessageList::_DoColumnCheck(COLUMN_ID id)
{
    // Check to see if the user has the column visible
    BOOL fVisible = FALSE;

    m_cColumns.IsColumnVisible(id, &fVisible);
    if (!fVisible)
    {
        if (IDYES == DoDontShowMeAgainDlg(m_ctlList, c_szRegColumnHidden, (LPTSTR) idsAthena,
                                  (LPTSTR) idsColumnHiddenWarning, MB_YESNO))
        {
            m_cColumns.InsertColumn(id, 0);
        }
    }
}

void CMessageList::_DoFilterCheck(RULEID ridFilter)
{
    // Make sure the filter got set correctly
    if (m_ridFilter != ridFilter)
    {
        m_ridFilter = ridFilter; 
    }
    
    // Reset the empty string
    if (RULEID_VIEW_ALL == m_ridFilter)
    {
        if (FALSE != m_fFindFolder)
        {
            m_idsEmptyString = idsMonitoring;
        }
        else if ((FALSE != m_fJunkFolder) && (0 != (g_dwAthenaMode & MODE_JUNKMAIL)) && (FALSE == DwGetOption(OPT_FILTERJUNK)))
        {
            m_idsEmptyString = idsEmptyJunkMail;
        }
        else
        {
            m_idsEmptyString = idsEmptyView;
        }
    }
    else
    {
        m_idsEmptyString = idsEmptyFilteredView;
    }
}


BOOL CMessageList::_IsSelectionDeletable(void)
{
    BOOL      fReturn = FALSE;
    DWORD     cRows;
    ROWINDEX *rgiRow = 0;

    // Make sure we have a table
    if (!m_pTable)
        return (FALSE);

    // First we need to come up with an array for the row indicies
    cRows = ListView_GetSelectedCount(m_ctlList);
    if (!cRows)
        return (FALSE);

    // Allocate the array
    if (MemAlloc((LPVOID *) &rgiRow, sizeof(ROWINDEX) * cRows))
    {
        // Loop through all the selected rows
        int       iRow = -1;
        ROWINDEX *pRow = rgiRow;

        while (-1 != (iRow = ListView_GetNextItem(m_ctlList, iRow, LVNI_SELECTED)))
        {
            *pRow = iRow;
            pRow++;
        }

        DWORD dwState = 0;

        if (SUCCEEDED(m_pTable->GetSelectionState(cRows, rgiRow, SELECTION_STATE_DELETABLE,
                                                  m_fThreadMessages, &dwState)))
        {
            // the return value here seems backward.  
            fReturn = !(dwState & SELECTION_STATE_DELETABLE) || (GetFolderType(m_idFolder) == FOLDER_NEWS);
        }

        MemFree(rgiRow);
    }

    return (fReturn);
}


BOOL CMessageList::_PollThisAccount(FOLDERID id)
{
    HRESULT      hr;
    FOLDERINFO   fi;
    TCHAR        szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAccount = 0;
    BOOL         fReturn = FALSE;
    DWORD        dw;

    // Get the server for this folder
    if (SUCCEEDED(hr = GetFolderServer(id, &fi)))
    {
        // Get the account ID for the server
        if (SUCCEEDED(hr = GetFolderAccountId(&fi, szAccountId)))
        {
            // Get the account interface
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount)))
            {
                if (SUCCEEDED(hr = pAccount->GetPropDw(AP_NNTP_POLL, &dw)))
                {
                    fReturn = (0 != dw);
                }

                pAccount->Release();
            }
        }
        g_pStore->FreeRecord(&fi);
    }

    return (fReturn);
}

HRESULT CMessageList::GetAdBarUrl()
{
    HRESULT     hr = S_OK;

    if (m_pTable)
    {
        IF_FAILEXIT(hr = m_pTable->GetAdBarUrl(this));
    }

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CListSelector
//

CListSelector::CListSelector()
{
    m_cRef = 1;
    m_hwndAdvise = 0;
}

CListSelector::~CListSelector()
{
}


//
//  FUNCTION:   CListSelector::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CListSelector::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CListSelector::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IListSelector))
        *ppvObj = (LPVOID) (IListSelector *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CListSelector::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CListSelector::AddRef(void)
{
    TraceCall("CListSelector::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CListSelector::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CListSelector::Release(void)
{
    TraceCall("CListSelector::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


HRESULT CListSelector::SetActiveRow(ROWINDEX iRow)
{
    if (m_hwndAdvise && IsWindow(m_hwndAdvise))
    {
        PostMessage(m_hwndAdvise, WM_SELECTROW, 0, iRow);
    }

    return (S_OK);
}


HRESULT CListSelector::Advise(HWND hwndAdvise)
{
    if (0 == m_hwndAdvise && IsWindow(hwndAdvise))
    {
        m_hwndAdvise = hwndAdvise;
        return (S_OK);
    }

    return (E_UNEXPECTED);
}


HRESULT CListSelector::Unadvise(void)
{
    m_hwndAdvise = 0;
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\view\msgview.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     msgview.h
//
//  PURPOSE:    Defines the Outlook Express view class that handles 
//              displaying the contents of folders with messages.
//

#pragma once

#include "browser.h"
#include "ibodyopt.h"
#include "mimeole.h"
#include "ibodyobj.h"
#include "dragdrop.h"

#define HANDLE_WM_FOLDER_LOADED(hwnd, wParam, lParam, fn)    \
    OnFolderLoaded((hwnd), (wParam), (lParam))


/////////////////////////////////////////////////////////////////////////////
// Forward References
//

interface IMessageList;
interface IBodyObj2;
class CGetNewGroups;
class CViewMenu;

class CMessageView : IViewWindow,
                     IMessageWindow,
                     IDispatch,
                     IOleCommandTarget,
                     IBodyOptions,
                     IMimeEditEventSink,
                     IServerInfo
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    //
    CMessageView();
    ~CMessageView();

    HRESULT Initialize(FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    /////////////////////////////////////////////////////////////////////////
    // IOleWindow
    //
    STDMETHOD(GetWindow)(HWND *pHwnd);                         
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);            
                                         
    /////////////////////////////////////////////////////////////////////////
    // IViewWindow
    //
    STDMETHOD(TranslateAccelerator)(THIS_ LPMSG pMsg);
    STDMETHOD(UIActivate)(THIS_ UINT uState);
    STDMETHOD(CreateViewWindow)(THIS_ IViewWindow *pPrevView, IAthenaBrowser *pBrowser,
                                RECT *prcView, HWND *pHwnd);
    STDMETHOD(DestroyViewWindow)(THIS);
    STDMETHOD(SaveViewState)(THIS);
    STDMETHOD(OnPopupMenu)(THIS_ HMENU hMenu, HMENU hMenuPopup, UINT uID);

    /////////////////////////////////////////////////////////////////////////
    // IMessageWindow
    //
    STDMETHOD(OnFrameWindowActivate)(THIS_ BOOL fActivate);
    STDMETHOD(GetCurCharSet)(THIS_ UINT *cp);
    STDMETHOD(UpdateLayout)(THIS_ BOOL fPreviewVisible, BOOL fPreviewHeader, 
                            BOOL fPreviewVert, BOOL fReload);
    STDMETHOD(GetMessageList)(THIS_ IMessageList ** ppMsgList);
    
    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                           OLECMDTEXT *pCmdText); 
    STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                    VARIANTARG *pvaIn, VARIANTARG *pvaOut); 
    
    /////////////////////////////////////////////////////////////////////////
    // IDispatch
    //
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                             LCID lcid, DISPID *rgDispId)
    {
        return (E_NOTIMPL);
    }
    STDMETHOD(GetTypeInfo)(unsigned int iTInfo, LCID lcid, ITypeInfo **ppTInfo)
    {
        return (E_NOTIMPL);
    }
    STDMETHOD(GetTypeInfoCount)(unsigned int FAR* pctinfo)
    {
        return (E_NOTIMPL);
    }
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                      DISPPARAMS* pDispParams, VARIANT* pVarResult,
                      EXCEPINFO* pExcepInfo, unsigned int* puArgErr);

    /////////////////////////////////////////////////////////////////////////
    // IBodyOptions
    //
    STDMETHOD(SignatureEnabled)(BOOL fAuto)
    { 
        return (E_NOTIMPL);
    }
    STDMETHOD(GetSignature)(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr)
    { 
        return (E_NOTIMPL);
    }
    STDMETHOD(GetMarkAsReadTime)(LPDWORD pdwSecs);
    STDMETHOD(GetFlags)(LPDWORD pdwFlags);
    STDMETHOD(GetInfo)(BODYOPTINFO *pBOI)
    { 
        return (E_NOTIMPL);
    }
    STDMETHOD(GetAccount)(IImnAccount **ppAcct);

    /////////////////////////////////////////////////////////////////////////
    // IMimeEditEventSink
    //
    STDMETHOD(EventOccurred)(DWORD cmdID, IMimeMessage *pMessage);

    /////////////////////////////////////////////////////////////////////////
    // IServerInfo
    //
    STDMETHOD(GetFolderId)(FOLDERID *pID);
    STDMETHOD(GetMessageFolder)(IMessageServer **ppServer);

    /////////////////////////////////////////////////////////////////////////
    // Window Handling 
    //
protected:
    static LRESULT CALLBACK ViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnPostCreate(HWND hwnd);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    void    OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void    OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void    OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
    void    OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void    OnDestroy(HWND hwnd);
    void    OnSetFocus(HWND hwnd, HWND hwndOldFocus);
    void    OnFolderLoaded(HWND  hwnd, WPARAM wParam, LPARAM  lParam);
    LRESULT OnTestGetMsgId(HWND hwnd);
    LRESULT OnTestSaveMessage(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Command Handlers
    //
    HRESULT CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFillPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdShowPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdAddToWab(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    //
    BOOL    _InitMessageList(void);
    BOOL    _InitPreviewPane(void);
    HRESULT _SetListOptions(void);
    BOOL    _IsPreview(void);
    void    _UpdatePreviewPane(BOOL fForceDownload=FALSE);
    void    _SetProgressStatusText(BSTR bstr);
    void    _SetDefaultStatusText(void);
    HRESULT _OnMessageAvailable(MESSAGEID idMessage, HRESULT hrCompletion);
    HRESULT _DoEmailBombCheck(LPMIMEMESSAGE pMsg);
    void    _OptionUpdate(DWORD dwUpdate);
    BOOL    _ReuseMessageFolder(IViewWindow *pPrevView);
    HRESULT _StoreCharsetOntoRows(HCHARSET hCharset);

    /////////////////////////////////////////////////////////////////////////
    // Member Data
private:
    ULONG                   m_cRef;

    // Handy window handles
    HWND                    m_hwnd;
    HWND                    m_hwndParent;
    HWND                    m_hwndList;

    // Shell stuff
    IAthenaBrowser         *m_pBrowser;
    FOLDERID                m_idFolder;
    CDropTarget            *m_pDropTarget;

    // Message List
    IMessageList           *m_pMsgList;
    IOleCommandTarget      *m_pMsgListCT;
    IOleInPlaceActiveObject *m_pMsgListAO;
    DWORD                   m_dwCookie;
    IMessageServer         *m_pServer;

    // Preview Pane
    IBodyObj2              *m_pPreview;
    IOleCommandTarget      *m_pPreviewCT;
    MESSAGEID               m_idMessageFocus;
    CStatusBar              *m_pProgress;
    BOOL                    m_fNotDownloaded;

    // Layout
    BOOL                    m_fSplitHorz;
    RECT                    m_rcSplit;
    DWORD                   m_dwSplitVertPct;
    DWORD                   m_dwSplitHorzPct;
    BOOL                    m_fDragging;

    // State
    UINT                    m_uUIState;
    DWORD                   m_cItems;
    DWORD                   m_cUnread;
    DWORD                   m_cLastChar;

    CGetNewGroups          *m_pGroups;

    // For View.Current View menu
    CViewMenu              *m_pViewMenu;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\view\msgview.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     msgview.cpp
//
//  PURPOSE:    Implements the Outlook Express view class that handles 
//              displaying the contents of folders with messages.
//

#include "pch.hxx"
#include "msgview.h"
#include "browser.h"
#include "thormsgs.h"
#include "msglist.h"
#include "msoedisp.h"
#include "statbar.h"
#include "ibodyobj.h"
#include "mehost.h"
#include "util.h"
#include "shlwapip.h" 
#include "menuutil.h"
#include "storutil.h"
#include "ruleutil.h"
#include "note.h"
#include "newsutil.h"
#include "menures.h"
#include "ipab.h"
#include "order.h"
#include <inetcfg.h>
#include "instance.h"

/////////////////////////////////////////////////////////////////////////////
// Global Data
//

static const char s_szMessageViewWndClass[] = TEXT("Outlook Express Message View");

extern BOOL g_fBadShutdown;

/////////////////////////////////////////////////////////////////////////////
// Prototypes
//


/////////////////////////////////////////////////////////////////////////////
// Message Macros
//

// void OnPostCreate(HWND hwnd)
#define HANDLE_WM_POSTCREATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_POSTCREATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_POSTCREATE, 0L, 0L)

// LRESULT OnTestGetMsgId(HWND hwnd)
#define HANDLE_WM_TEST_GETMSGID(hwnd, wParam, lParam, fn) \
    (LRESULT)((fn)(hwnd))
#define FORWARD_WM_TEST_GETMSGID(hwnd, fn) \
    (LRESULT)(fn)((hwnd), WM_TEST_GETMSGID, 0L, 0L)

// LRESULT OnTestSaveMessage(HWND hwnd)
#define HANDLE_WM_TEST_SAVEMSG(hwnd, wParam, lParam, fn) \
    (LRESULT)((fn)(hwnd))
#define FORWARD_WM_TEST_SAVEMSG(hwnd, fn) \
    (LRESULT)(fn)((hwnd), WM_TEST_SAVEMSG, 0L, 0L)

/////////////////////////////////////////////////////////////////////////////
// Constructors, Destructors, and Initialization
//

CMessageView::CMessageView()
{
    m_cRef = 1;

    m_hwnd = NULL;
    m_hwndParent = NULL;

    m_pBrowser = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_pDropTarget = NULL;

    m_pMsgList = NULL;
    m_pMsgListCT = NULL;
    m_pMsgListAO = NULL;
    m_dwCookie = 0;
    m_pServer = NULL;

    m_pPreview = NULL;
    m_pPreviewCT = NULL;

    m_fSplitHorz = TRUE;
    SetRect(&m_rcSplit, 0, 0, 0, 0);
    m_dwSplitVertPct = 50;
    m_dwSplitHorzPct = 50;
    m_fDragging = FALSE;

    m_uUIState = SVUIA_DEACTIVATE;
    m_cUnread = 0;
    m_cItems = 0;
    m_pGroups = NULL;
    m_idMessageFocus = MESSAGEID_INVALID;
    m_pProgress = NULL;
    m_fNotDownloaded = FALSE;
    m_cLastChar = GetTickCount();

    m_pViewMenu = NULL;
}


CMessageView::~CMessageView()
{
    SafeRelease(m_pViewMenu);
    if (m_pGroups != NULL)
    {
        m_pGroups->Close();
        m_pGroups->Release();
    }
    SafeRelease(m_pBrowser);
    SafeRelease(m_pMsgList);
    SafeRelease(m_pMsgListCT);
    SafeRelease(m_pMsgListAO);
    SafeRelease(m_pPreview);
    SafeRelease(m_pPreviewCT);
    SafeRelease(m_pProgress);
    SafeRelease(m_pDropTarget);
    Assert(NULL == m_pServer);
}


//
//  FUNCTION:   CMessageView::Initialize()
//
//  PURPOSE:    Get's called to initialize the object and tell it what folder
//              it will be looking at.
//
//  PARAMETERS: 
//      [in]  pidl
//      [in] *pFolder
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::Initialize(FOLDERID idFolder)
{
    TraceCall("CMessageView::Initialize");

    // Copy the pidl, we'll use it later
    m_idFolder = idFolder;

    return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown
//

HRESULT CMessageView::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IOleWindow))
        *ppvObj = (LPVOID) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IViewWindow))
        *ppvObj = (LPVOID) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IMessageWindow))
        *ppvObj = (LPVOID) (IMessageWindow *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;
    else if (IsEqualIID(riid, IID_IBodyOptions))
        *ppvObj = (LPVOID) (IBodyOptions *) this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, DIID__MessageListEvents))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, IID_IServerInfo))
        *ppvObj = (LPVOID) (IServerInfo *) this;

    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return S_OK;
}


ULONG CMessageView::AddRef(void)
{
    return InterlockedIncrement((LONG *) &m_cRef);
}

ULONG CMessageView::Release(void)
{
    InterlockedDecrement((LONG *) &m_cRef);
    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }
    return (m_cRef);
}

/////////////////////////////////////////////////////////////////////////////
// IOleWindow
//

HRESULT CMessageView::GetWindow(HWND *pHwnd)
{
    if (!pHwnd)
        return (E_INVALIDARG);
    
    if (m_hwnd)
    {
        *pHwnd = m_hwnd;
        return (S_OK);
    }

    return (E_FAIL);
}


HRESULT CMessageView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return (E_NOTIMPL);
}


/////////////////////////////////////////////////////////////////////////////
// IViewWindow
//


//
//  FUNCTION:   CMessageView::TranslateAccelerator()
//
//  PURPOSE:    Called by the frame window to give us first crack at messages.
//
//  PARAMETERS: 
//      [in] pMsg - The current message to be processed.
//
//  RETURN VALUE:
//      S_OK if the message was handled here and should not be processed further.
//      S_FALSE if the message should continued to be processed elsewhere.
// 
HRESULT CMessageView::TranslateAccelerator(LPMSG pMsg)
{
    DWORD dwState = 0;

    // See if the Preview Pane is interested
    if (m_pPreview)
    {
        if (S_OK == m_pPreview->HrTranslateAccelerator(pMsg))
            return (S_OK);
    
        if (IsChild(m_hwnd, GetFocus()))
        {
            if (pMsg->message == WM_KEYDOWN && pMsg->wParam != VK_SPACE)
                m_cLastChar = GetTickCount();

            if (pMsg->message == WM_KEYDOWN && 
                pMsg->wParam == VK_SPACE &&
                GetTickCount() - m_cLastChar > 1000)
            {
                if (m_fNotDownloaded)
                {
                    _UpdatePreviewPane(TRUE);
                }
                else if (SUCCEEDED(m_pMsgList->GetFocusedItemState(&dwState)) && dwState != 0)
                {
                    if (m_pPreview->HrScrollPage()!=S_OK)
                        m_pMsgListCT->Exec(NULL, ID_SPACE_ACCEL, 0, NULL, NULL);
                }
                else
                    m_pMsgListCT->Exec(NULL, ID_SPACE_ACCEL, 0, NULL, NULL);
            
                return S_OK;
            }
        }
    }

    // See if the message list is interested
    if (m_pMsgListAO)
    {
        if (S_OK == m_pMsgListAO->TranslateAccelerator(pMsg))
            return (S_OK);
    }

    return (S_FALSE);
}


//
//  FUNCTION:   CMessageView::UIActivate()
//
//  PURPOSE:    Called to notify the view when different activation and 
//              deactivation events occur.
//
//  PARAMETERS: 
//      [in] uState - SVUIA_ACTIVATE_FOCUS, SVUIA_ACTIVATE_NOFOCUS, and
//                    SVUIA_DEACTIVATE.
//
//  RETURN VALUE:
//      Returns S_OK all the time.
//
HRESULT CMessageView::UIActivate(UINT uState)
{
    if (uState != SVUIA_DEACTIVATE)
    {
        // If the focus stays within our frame, bug goes outside our view,
        // i.e. the folder list get's focus, then we get an 
        // SVUIA_ACTIVATE_NOFOCUS.  We need to UI Deactivate the preview
        // pane when this happens.
        if (uState == SVUIA_ACTIVATE_NOFOCUS && m_pPreview)
            m_pPreview->HrUIActivate(FALSE);

        if (m_uUIState != uState)
        {
            // Update our internal state
            m_uUIState = uState;

            // Update the toolbar state
            m_pBrowser->UpdateToolbar();
        }            
    }
    else
    {
        // Only deactivate if we're not already deactivated
        if (m_uUIState != SVUIA_DEACTIVATE)
        {
            // Update our internal state
            m_uUIState = uState;
        }
    }
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CreateViewWindow()
//
//  PURPOSE:    Called when it's time for the view to create it's window.
//
//  PARAMETERS: 
//      [in]  pPrevView - Pointer to the previous view if there was one
//      [in]  pBrowser - Pointer to the browser that hosts this view
//      [in]  prcView - Initial position and size of the view
//      [out] pHwnd - Returns the HWND of the newly created view window
//
//  RETURN VALUE:
//      S_OK if the view window was created successfully.  
//      E_FAIL if the window couldn't be created for some reason or another.
//
HRESULT CMessageView::CreateViewWindow(IViewWindow *pPrevView, IAthenaBrowser *pBrowser,
                                       RECT *prcView, HWND *pHwnd)
{
    WNDCLASS wc;

    // Without a browser pointer nothing will ever work.  
    if (!pBrowser)
        return (E_INVALIDARG);

    // Hang on to the browser pointer
    m_pBrowser = pBrowser;
    m_pBrowser->AddRef();

    // Get the window handle of the browser
    m_pBrowser->GetWindow(&m_hwndParent);
    Assert(IsWindow(m_hwndParent));

    // Load our persisted settings.  If this fails will just run with defaults.
    // _LoadSettings();

    // Register our window class if we haven't already
    if (!GetClassInfo(g_hInst, s_szMessageViewWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = CMessageView::ViewWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = s_szMessageViewWndClass;

        if (!RegisterClass(&wc))
            return (E_FAIL);
    }

    // Create the view window
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT , s_szMessageViewWndClass, NULL, 
                            WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            prcView->left, prcView->top, prcView->right - prcView->left,
                            prcView->bottom - prcView->top, m_hwndParent, NULL,
                            g_hInst, (LPVOID) this);
    if (!m_hwnd)
        return (E_FAIL);

    *pHwnd = m_hwnd;

    // Get the message folder object from the previous folder here.
    _ReuseMessageFolder(pPrevView);

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::DestroyViewWindow()
//
//  PURPOSE:    Called by the browser to destroy the view window.
//
//  RETURN VALUE:
//      S_OK is returned always.
//
HRESULT CMessageView::DestroyViewWindow(void)
{
    // This is of course only interesting if we actually _have_ a window to 
    // destroy.
    if (m_hwnd)
    {
        // Tell the message list we're done with this folder
        if (m_pMsgList)
        {
            m_pMsgList->SetFolder(FOLDERID_INVALID, NULL, 0, 0, 0);
        }

        // Unadvise our connection point
        if (m_dwCookie)
        {
            AtlUnadvise(m_pMsgList, DIID__MessageListEvents, m_dwCookie);
            m_dwCookie = 0;
        }

        // $REVIEW - PreDestroyViewWindow() used to be called here to tell the subclasses
        //           of the iminent destruction.

        // Set our cached HWND to NULL before destroying prevents us from 
        // handling notifications after important stuff has been freed.
        HWND hwndDest = m_hwnd;
        m_hwnd = NULL;
        DestroyWindow(hwndDest);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::SaveViewState()
//
//  PURPOSE:    Called by the browser to give the view a chance to save it's 
//              settings before it is destroyed.
//
//  RETURN VALUE:
//      E_NOTIMPL
//
HRESULT CMessageView::SaveViewState(void)
{
    FOLDERTYPE ft = GetFolderType(m_idFolder);

    // Tell the message list to save it's state
    if (m_pMsgList)
    {
        m_pMsgList->OnClose();

        // We also need to save any settings that might have changed
        FOLDER_OPTIONS fo = { 0 };

        fo.cbSize = sizeof(FOLDER_OPTIONS);
        fo.dwMask = FOM_THREAD | FOM_OFFLINEPROMPT | FOM_SHOWDELETED | FOM_SHOWREPLIES;

        if (SUCCEEDED(m_pMsgList->GetViewOptions(&fo)))
        {
            switch (ft)
            {
                case FOLDER_NEWS:
                    SetDwOption(OPT_NEWS_THREAD, fo.fThread, 0, 0);
                    break;

                case FOLDER_LOCAL:
                case FOLDER_HTTPMAIL:
                    SetDwOption(OPT_MAIL_THREAD, fo.fThread, 0, 0);
                    break;

                case FOLDER_IMAP:
                    SetDwOption(OPT_MAIL_THREAD, fo.fThread, 0, 0);
                    break;
            }
            SetDwOption(OPT_SHOW_DELETED, (DWORD) (fo.fDeleted), 0, 0);
            SetDwOption(OPT_SHOW_REPLIES, (DWORD) (fo.fReplies), 0, 0);
        }
    }

    // Reset the contents of the status bar
    CStatusBar *pStatusBar;
    m_pBrowser->GetStatusBar(&pStatusBar);
    if (pStatusBar)
    {
        pStatusBar->SetStatusText("");
        pStatusBar->Release();
    }

    return (S_OK);
}

//
//  FUNCTION:   CMessageView::OnPopupMenu()
//
//  PURPOSE:    Called whenever the frame receives a WM_INITMENUPOPUP 
//              notification.  The view adds any menu items or sets any
//              check marks that are appropriate.
//
//  PARAMETERS: 
//      [in] hMenu - The handle of the root menu bar
//      [in] hMenuPopup -  The handle of the specific popup menu
//      [in] uID - The ID of the popup menu
//
//  RETURN VALUE:
//      Unused 
//
HRESULT CMessageView::OnPopupMenu(HMENU hMenu, HMENU hMenuPopup, UINT uID)
{
    MENUITEMINFO mii;
    UINT         uItem;
    HCHARSET     hCharset;

    // Handle our items
    switch (uID)
    {
        case ID_POPUP_LANGUAGE:
        {
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_SUBMENU;
            UINT uiCodepage = 0;
            HMENU hLangMenu = NULL;
            m_pPreview->HrGetCharset(&hCharset);
            uiCodepage = CustomGetCPFromCharset(hCharset, TRUE);
            if(m_pBrowser->GetLanguageMenu(&hLangMenu, uiCodepage) == S_OK)
            {
                if(IsMenu(hMenuPopup))
                    DestroyMenu(hMenuPopup);

                hMenuPopup = mii.hSubMenu = hLangMenu;
                SetMenuItemInfo(hMenu, ID_POPUP_LANGUAGE, FALSE, &mii);
            }  
            
            break;
        }

        case ID_POPUP_VIEW:
        {
            if (NULL == m_pViewMenu)
            {
                // Create the view menu
                HrCreateViewMenu(0, &m_pViewMenu);
            }
            
            if (NULL != m_pViewMenu)
            {
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU;
                
                if (FALSE == GetMenuItemInfo(hMenuPopup, ID_POPUP_FILTER, FALSE, &mii))
                {
                    break;
                }
                
                // Remove the old filter submenu
                if(IsMenu(mii.hSubMenu))
                    DestroyMenu(mii.hSubMenu);

                // Replace the view menu
                if (FAILED(m_pViewMenu->HrReplaceMenu(0, hMenuPopup)))
                {
                    break;
                }
            }
            break;
        }
        
        case ID_POPUP_FILTER:
        {
            if (NULL != m_pViewMenu)
            {
                m_pViewMenu->UpdateViewMenu(0, hMenuPopup, m_pMsgList);
            }
            break;
        }
    }

    // Let the message list update it's menus
    if (m_pMsgList)
        m_pMsgList->OnPopupMenu(hMenuPopup, uID);

    // Let the preview pane update it's menus
    if (m_pPreview)
        m_pPreview->HrOnInitMenuPopup(hMenuPopup, uID);


    return (S_OK);
}



HRESULT CMessageView::OnFrameWindowActivate(BOOL fActivate)
{
    if (m_pPreview)
        return m_pPreview->HrFrameActivate(fActivate);
    
    return (S_OK);
}

HRESULT CMessageView::UpdateLayout(BOOL fVisible, BOOL fHeader, BOOL fVert, 
                                   BOOL fUpdate)
{
    // If we haven't created the preview pane yet, and the call is telling
    // us to make it visible, then we need to initialize it first.
    if (!m_pPreview && fVisible)
    {
        if (!_InitPreviewPane())
            return (E_UNEXPECTED);
    }

    // Header on / off
    if (m_pPreview)
    {
        m_pPreview->HrSetStyle(fHeader ? MESTYLE_PREVIEW : MESTYLE_MINIHEADER);
    }

    // Split direction
    if (m_pPreview)
    {
        RECT rcClient;

        m_fSplitHorz = !fVert;
        GetClientRect(m_hwnd, &rcClient);
        OnSize(m_hwnd, SIZE_RESTORED, rcClient.right, rcClient.bottom);
    }

    //
    // [PaulHi] 6/11/99  Raid 79491
    // Backing out this fix that BrettM made for Raid 63739 because of problems
    // with security message warnings.
    //
#if 0
    if (fVisible)
    {
        // if showing update the preview pane
        _UpdatePreviewPane();
    }
    else
    {
        // if hiding, clear the contents
        if (NULL != m_pPreview)
            m_pPreview->HrUnloadAll(NULL, 0);
    }
#endif

    return (S_OK);
}

HRESULT CMessageView::GetMessageList(IMessageList ** ppMsgList)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == ppMsgList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppMsgList = NULL;

    // Get the message list
    if (NULL != m_pMsgList)
    {
        *ppMsgList = m_pMsgList;
        (*ppMsgList)->AddRef();
    }

    // Set the return value
    hr = (NULL == *ppMsgList) ? S_FALSE : S_OK;
    
exit:
    return hr;
}

HRESULT CMessageView::GetCurCharSet(UINT *cp)
{
    HCHARSET     hCharset;

    if(_IsPreview())
    {
        m_pPreview->HrGetCharset(&hCharset);
        *cp = CustomGetCPFromCharset(hCharset, TRUE);
    }
    else
        *cp = GetACP();

    return S_OK;
}

//
//  FUNCTION:   CMessageView::QueryStatus()
//
//  PURPOSE:    Called by the browser to determine if a list of commands should
//              should be enabled or disabled.
//
//  PARAMETERS: 
//      [in] pguidCmdGroup - Group the commands are part of (unused)
//      [in] cCmds - Number of commands to be evaluated
//      [in] prgCmds - List of commands
//      [out] pCmdText - Description text for a command
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                  OLECMDTEXT *pCmdText) 
{
    DWORD   cSel;
    HRESULT hr;
    HWND    hwndFocus = GetFocus();
    BOOL    fChildFocus = (hwndFocus != NULL && IsChild(m_hwnd, hwndFocus));
    DWORD   cFocus;
    DWORD  *rgSelected = 0;
    FOLDERTYPE ftType;

    // Let the sub objects look first
    if (m_pMsgListCT)
    {
        hr = m_pMsgListCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    if (_IsPreview() && m_pPreviewCT)
    {
        hr = m_pPreviewCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // Up front some work
    m_pMsgList->GetSelected(&cFocus, &cSel, &rgSelected);

    // Now loop through the commands in the prgCmds array looking for ones the 
    // sub objects didn't handle.
    for (UINT i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // If this command is from the language menu
            if (prgCmds[i].cmdID >= ID_LANG_FIRST && prgCmds[i].cmdID <= ID_LANG_LAST)
            {
                HCHARSET     hCharset;

                m_pPreview->HrGetCharset(&hCharset);

                // Enable only the supported languages
                if (prgCmds[i].cmdID < (UINT) (ID_LANG_FIRST + GetIntlCharsetLanguageCount()))
                {
#if 0
                    if(SetMimeLanguageCheckMark(CustomGetCPFromCharset(hCharset, TRUE), prgCmds[i].cmdID - ID_LANG_FIRST))
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
#else
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | SetMimeLanguageCheckMark(CustomGetCPFromCharset(hCharset, TRUE), prgCmds[i].cmdID - ID_LANG_FIRST);
#endif
                }
                else
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                continue;
            }

            // if the command id from the View.Current View menu
            if ((ID_VIEW_FILTER_FIRST <= prgCmds[i].cmdID) && (ID_VIEW_FILTER_LAST >= prgCmds[i].cmdID))
            {
                if (NULL == m_pViewMenu)
                {
                    // Create the view menu
                    HrCreateViewMenu(0, &m_pViewMenu);
                }
            
                if (NULL != m_pViewMenu)
                {
                    m_pViewMenu->QueryStatus(m_pMsgList, &(prgCmds[i]));
                }

                continue;
            }
            
            // Look to see if it's a command we provide
            switch (prgCmds[i].cmdID)
            {
                case ID_OPEN:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    m_pMsgList->GetSelectedCount(&cSel);
                    if (cSel)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_REPLY:
                case ID_REPLY_ALL:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0 && (0 == (pInfo->dwFlags & ARF_UNSENT)))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }

                case ID_SAVE_AS:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (_IsPreview() && (cSel == 1))
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }


                case ID_PRINT:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is more than one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (_IsPreview() && cSel > 0)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }

                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel > 0)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        // Default to success
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        for (DWORD iItem = 0; iItem < cSel && (prgCmds[i].cmdf & OLECMDF_ENABLED); iItem++)
                        {
                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[iItem], &pInfo)))
                            {
                                if (pInfo->faStream == 0 || (0 != (pInfo->dwFlags & ARF_UNSENT)))
                                {
                                    prgCmds[i].cmdf &= ~OLECMDF_ENABLED;
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }

                    break;
                }

                case ID_REPLY_GROUP:
                {
                    // Enabled only if there is one news message selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->faStream != 0 && (pInfo->dwFlags & ARF_NEWSMSG)  && (0 == (pInfo->dwFlags & ARF_UNSENT)))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }

                case ID_CANCEL_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (DwGetOption(OPT_CANCEL_ALL_NEWS))
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    else
                    {
                        if (cSel == 1)
                        {
                            LPMESSAGEINFO pInfo;

                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                            {
                                if (NewsUtil_FCanCancel(m_idFolder, pInfo))
                                {
                                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }
                    break;
                }

                case ID_POPUP_FILTER:
                case ID_PREVIEW_PANE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }

                case ID_POPUP_LANGUAGE_DEFERRED:
                case ID_POPUP_LANGUAGE:
                case ID_POPUP_LANGUAGE_MORE:
                case ID_LANGUAGE:
                {
                    // These are OK if the preview pane is visible and not empty
                    if (cSel > 0 && _IsPreview())
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    break;
                }

                case ID_PREVIEW_SHOW:
                case ID_PREVIEW_BELOW:
                case ID_PREVIEW_BESIDE:
                case ID_PREVIEW_HEADER:
                {
                    FOLDERTYPE  ftType;
                    DWORD       dwOpt;
                    LAYOUTPOS   pos;
                    BOOL        fVisible;
                    DWORD       dwFlags;

                    // Default return value
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    
                    // Get the folder type
                    m_pBrowser->GetFolderType(&ftType);
                    if (ftType == FOLDER_NEWS)
                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
                    else
                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

                    // Get the settings from the browser
                    m_pBrowser->GetViewLayout(dwOpt, &pos, &fVisible, &dwFlags, NULL);
                    
                    switch (prgCmds[i].cmdID)
                    {
                        case ID_PREVIEW_SHOW:
                        {
                            // Always enabled, checked if already visible
                            if (fVisible)
                                prgCmds[i].cmdf |= (OLECMDF_ENABLED | OLECMDF_LATCHED);
                            else
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            break;
                        }

                        case ID_PREVIEW_BESIDE:
                        case ID_PREVIEW_BELOW:
                        {
                            // The command is enabled only if the preview pane
                            // is visible.
                            if (fVisible)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            // If the preview pane is already beside, it should be latched etc.
                            if ((pos == LAYOUT_POS_LEFT && prgCmds[i].cmdID == ID_PREVIEW_BESIDE) ||
                                (pos == LAYOUT_POS_BOTTOM && prgCmds[i].cmdID == ID_PREVIEW_BELOW))
                                prgCmds[i].cmdf |= OLECMDF_NINCHED;

                            break;
                        }

                        case ID_PREVIEW_HEADER:
                        {
                            // Always enabled, checked if already visible
                            if (dwFlags)
                                prgCmds[i].cmdf |= (OLECMDF_ENABLED | OLECMDF_LATCHED);
                            else
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            break;
                        }
                    }

                    break;
                }

                case ID_REFRESH:
                {
                    // Best I can tell, these are always enabled
                    prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    break;
                }

                case ID_GET_HEADERS:
                {
                    // Only in news
                    m_pBrowser->GetFolderType(&ftType);
                    if (ftType != FOLDER_LOCAL)
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    break;
                }

                case ID_ADD_SENDER:
                case ID_BLOCK_SENDER:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected and
                    // we have access to the from address
                    // Not in IMAP or HTTPMAIL
                    m_pBrowser->GetFolderType(&ftType);
                    if (cSel == 1 &&
                        (prgCmds[i].cmdID == ID_ADD_SENDER || (FOLDER_HTTPMAIL != ftType && FOLDER_IMAP != ftType)))
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0])) || (0 != pInfo->faStream))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }
                
                case ID_CREATE_RULE_FROM_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected
                    // Not in IMAP or HTTPMAIL
                    m_pBrowser->GetFolderType(&ftType);
                    if ((cSel == 1) && (FOLDER_HTTPMAIL != ftType) && (FOLDER_IMAP != ftType))
                    {
                        LPMESSAGEINFO pInfo;
                        
                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }
                
                case ID_COMBINE_AND_DECODE:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    m_pMsgList->GetSelectedCount(&cSel);
                    if (cSel > 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

            }
        }
    }

    SafeMemFree(rgSelected);

    return (S_OK);
}

HRESULT CMessageView::_StoreCharsetOntoRows(HCHARSET hCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    INETCSETINFO    CsetInfo;
    IMessageTable  *pTable=NULL;
    DWORD          *rgRows=NULL;
    DWORD           cRows=0;
    HCURSOR         hCursor=NULL;

    // Trace
    TraceCall("CMessageView::_StoreCharsetOntoRows");

    // Invalid Args
    if (NULL == m_pMsgList || NULL == hCharset)
        return(TraceResult(E_INVALIDARG));

    // Wait Cursor
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Get charset info
    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CsetInfo));

    // Get selected rows
    IF_FAILEXIT(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows));

    // Get the message table
    IF_FAILEXIT(hr = m_pMsgList->GetMessageTable(&pTable));

    // Set the Language
    SideAssert(SUCCEEDED(pTable->SetLanguage(cRows, rgRows, CsetInfo.cpiInternet)));

exit:
    // Cleanup
    SafeRelease(pTable);
    SafeMemFree(rgRows);

    // Reset Cursor
    if (hCursor)
        SetCursor(hCursor);

    // Done
    return(hr);
}

//
//  FUNCTION:   CMessageView::Exec()
//
//  PURPOSE:    Called to execute a verb that this view supports
//
//  PARAMETERS: 
//      [in]  pguidCmdGroup - unused
//      [in]  nCmdID - ID of the command to execute
//      [in]  nCmdExecOpt - Options that define how the command should execute
//      [in]  pvaIn - Any arguments for the command
//      [out] pvaOut - Any return values for the command
//
//  RETURN VALUE:
//       
//
HRESULT CMessageView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                           VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    // See if our message list wants the command
    if (m_pMsgListCT)
    {
        if (OLECMDERR_E_NOTSUPPORTED != m_pMsgListCT->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut))
            return (S_OK);
    }

    if (m_pPreviewCT)
    {
        if (OLECMDERR_E_NOTSUPPORTED != m_pPreviewCT->Exec(&CMDSETID_OutlookExpress, nCmdID, nCmdExecOpt, pvaIn, pvaOut))
            return (S_OK);
    }

    // If the sub objects didn't support the command, then we should see if
    // it's one of ours

    // Language menu first
    if (nCmdID >= ID_LANG_FIRST && nCmdID <= ID_LANG_LAST)
    {
        HCHARSET    hCharset = NULL;
        HCHARSET    hOldCharset = NULL;
        HRESULT hr = S_OK;

        if(!m_pPreview)
            return S_OK;

        m_pPreview->HrGetCharset(&hOldCharset);

        hCharset = GetMimeCharsetFromMenuID(nCmdID);

        if(!hCharset || (hOldCharset == hCharset))
            return(S_OK);

        Assert (hCharset);

        if(FAILED(hr = m_pPreview->HrSetCharset(hCharset)))
        {
            AthMessageBoxW(  m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                        MAKEINTRESOURCEW((hr == hrIncomplete)?idsViewLangMimeDBBad:idsErrViewLanguage), 
                        NULL, MB_OK|MB_ICONEXCLAMATION);
            return E_FAIL;
        }

        // Set the charset onto the selected rows....
        _StoreCharsetOntoRows(hCharset);

        // SetDefaultCharset(hCharset);

        // SwitchLanguage(nCmdID, TRUE);
        return (S_OK);
    }

    // Handle the View.Current View menu
    if ((ID_VIEW_FILTER_FIRST <= nCmdID) && (ID_VIEW_FILTER_LAST >= nCmdID))
    {
        if (NULL == m_pViewMenu)
        {
            // Create the view menu
            HrCreateViewMenu(0, &m_pViewMenu);
        }
        
        if (NULL != m_pViewMenu)
        {
            // What we get from the browser is of type VT_I8, but rules only needs filter id which 
            // is a dword. So changing the type here is safe. Bug# 74275
            pvaIn->vt = VT_I4;
            if (SUCCEEDED(m_pViewMenu->Exec(m_hwnd, nCmdID, m_pMsgList, pvaIn, pvaOut)))
            {
                return (S_OK);
            }
        }
    }
    
    // Go through the rest of the commands
    switch (nCmdID)
    {
        case ID_OPEN:
            return CmdOpen(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REPLY:
        case ID_REPLY_ALL:
        case ID_FORWARD:
        case ID_FORWARD_AS_ATTACH:
        case ID_REPLY_GROUP:
            return CmdReplyForward(nCmdID, nCmdExecOpt, pvaIn, pvaOut);            

        case ID_CANCEL_MESSAGE:
            return CmdCancelMessage(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_DOWNLOAD_MESSAGE:
            return CmdFillPreview(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_PREVIEW_PANE:
        case ID_PREVIEW_SHOW:
        case ID_PREVIEW_BELOW:
        case ID_PREVIEW_BESIDE:
        case ID_PREVIEW_HEADER:
            return CmdShowPreview(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REFRESH:
            return CmdRefresh(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_BLOCK_SENDER:
            return CmdBlockSender(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_CREATE_RULE_FROM_MESSAGE:
            return CmdCreateRule(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_VIEW_SOURCE:
        case ID_VIEW_MSG_SOURCE:
            if (m_pPreview)
                return m_pPreview->HrViewSource((ID_VIEW_SOURCE==nCmdID)?MECMD_VS_HTML:MECMD_VS_MESSAGE);
            else
                break;

        case ID_ADD_SENDER:
            return CmdAddToWab(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COMBINE_AND_DECODE:
            return CmdCombineAndDecode(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
    }

    return (E_FAIL);
}


//
//  FUNCTION:   CMessageView::Invoke()
//
//  PURPOSE:    This is where we receive notifications from the message list.
//
//  PARAMETERS: 
//      <too many to list>
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                             WORD wFlags, DISPPARAMS* pDispParams, 
                             VARIANT* pVarResult, EXCEPINFO* pExcepInfo, 
                             unsigned int* puArgErr)
{
    switch (dispIdMember)
    {

        // Fired whenever the selection in the ListView changes
        case DISPID_LISTEVENT_SELECTIONCHANGED:
        {
            // Need to load the preview pane with the new selected message
            if (_IsPreview())
                _UpdatePreviewPane();

            // Tell the browser to update it's toolbar
            if (m_pBrowser)
                m_pBrowser->UpdateToolbar();
            
            break;
        }

        // Fired whenever the ListView get's or loses focus.
        case DISPID_LISTEVENT_FOCUSCHANGED:
        {
            // If the ListView is getting the focus, we need to UI deactivate
            // the preview pane.
            if (pDispParams->rgvarg[0].lVal)
            {
                if (m_pPreview)
                {
                    m_pPreview->HrUIActivate(FALSE);
                    m_pBrowser->OnViewWindowActive(this);
                }
            }
            break;
        }

        // Fired when the number of messages or unread messages changes
        case DISPID_LISTEVENT_COUNTCHANGED:
        {
            // If we have a browser, update the status bar
            if (m_pBrowser && !m_pProgress)
            {
                DWORD cTotal, cUnread, cOnServer;

                // Readability forces me to do this
                cTotal = pDispParams->rgvarg[0].lVal;
                cUnread = pDispParams->rgvarg[1].lVal;
                cOnServer = pDispParams->rgvarg[2].lVal;

                // Got to update the status bar if there is one
                CStatusBar *pStatusBar = NULL;
                m_pBrowser->GetStatusBar(&pStatusBar);

                if (pStatusBar)
                {
                    TCHAR szStatus[CCHMAX_STRINGRES + 20];
                    TCHAR szFmt[CCHMAX_STRINGRES];
                    DWORD ids;

                    // If there are still messages on server load a different
                    // status string.
                    if (cOnServer)
                    {
                        AthLoadString(idsXMsgsYUnreadZonServ, szFmt, ARRAYSIZE(szFmt));
                        wsprintf(szStatus, szFmt, cTotal, cUnread, cOnServer);
                    }
                    else
                    {
                        AthLoadString(idsXMsgsYUnread, szFmt, ARRAYSIZE(szFmt));
                        wsprintf(szStatus, szFmt, cTotal, cUnread);
                    }

                    pStatusBar->SetStatusText(szStatus);
                    pStatusBar->Release();
                }

                // Also update the toolbar since commands like "Mark as Read" might
                // change.  However, we only do this if we go between zero and some or
                // vice versa.
                if ((m_cItems == 0 && cTotal) || (m_cItems != 0 && cTotal == 0) ||
                    (m_cUnread == 0 && cUnread) || (m_cUnread != 0 && cUnread == 0))
                {
                    m_pBrowser->UpdateToolbar();
                }

                // Save this for next time.
                m_cItems = cTotal;
                m_cUnread = cUnread;
            }
            break;
        }

        // Fired when the message list want's to show status text
        case DISPID_LISTEVENT_UPDATESTATUS:
        {
            _SetProgressStatusText(pDispParams->rgvarg->bstrVal);
            break;
        }

        // Fired when progress happens
        case DISPID_LISTEVENT_UPDATEPROGRESS:
        {
            CBands *pCoolbar = NULL;

            // If this is a begin, then we start animating the logo
            if (pDispParams->rgvarg[2].lVal == PROGRESS_STATE_BEGIN)
            {
                if (SUCCEEDED(m_pBrowser->GetCoolbar(&pCoolbar)))
                {
                    pCoolbar->Invoke(idDownloadBegin, NULL);
                    pCoolbar->Release();
                }
            }

            // If this is a continue, then we might get progress numbers
            else if (pDispParams->rgvarg[2].lVal == PROGRESS_STATE_DEFAULT)
            {
                if (!m_pProgress)
                {
                    if (m_pBrowser->GetStatusBar(&m_pProgress)==S_OK)
                        m_pProgress->ShowProgress(pDispParams->rgvarg[1].lVal);
                }

                if (m_pProgress)
                    m_pProgress->SetProgress(pDispParams->rgvarg[0].lVal);
            }

            // Or if this is an end, stop animating and clean up the status bar
            else if (pDispParams->rgvarg[2].lVal == PROGRESS_STATE_END)
            {
                if (m_pProgress)
                {
                    m_pProgress->HideProgress();
                    m_pProgress->Release();
                    m_pProgress = NULL;
                }

                if (SUCCEEDED(m_pBrowser->GetCoolbar(&pCoolbar)))
                {
                    pCoolbar->Invoke(idDownloadEnd, NULL);
                    pCoolbar->Release();
                }

                // Reset the status bar back to it's default state
                _SetDefaultStatusText();
            }

            break;
        }

        // Fired when the user double clicks an item in the ListView
        case DISPID_LISTEVENT_ITEMACTIVATE:
        {
            CmdOpen(ID_OPEN, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            break;
        }

        // Fired when we need to call update toolbar
        case DISPID_LISTEVENT_UPDATECOMMANDSTATE:
        {
            PostMessage(m_hwndParent, CM_UPDATETOOLBAR, 0, 0L);
            break;
        }

        
        // Fired when a message has been downloaded by the messagelist
        case DISPID_LISTEVENT_ONMESSAGEAVAILABLE:
        {
            return _OnMessageAvailable((MESSAGEID)((LONG_PTR)pDispParams->rgvarg[0].lVal), (HRESULT)pDispParams->rgvarg[1].scode);
        }

        // Fired when the filter changes
        case DISPID_LISTEVENT_FILTERCHANGED:
        {
            // If we have a browser, update the status bar
            if (m_pBrowser && !m_pProgress)
            {
                // Got to update the status bar if there is one
                CStatusBar *pStatusBar = NULL;
                m_pBrowser->GetStatusBar(&pStatusBar);

                if (pStatusBar)
                {
                    pStatusBar->SetFilter((RULEID)((ULONG_PTR)pDispParams->rgvarg[0].ulVal));
                    pStatusBar->Release();
                }

                CBands*  pBands;
                if (m_pBrowser->GetCoolbar(&pBands) == S_OK)
                {
                    pBands->Invoke(idNotifyFilterChange, &pDispParams->rgvarg[0].ulVal);
                    pBands->Release();
                }
            }
            break;
        }

        case DISPID_LISTEVENT_ADURL_AVAILABLE:
        {
            if (m_pBrowser)
            {
                m_pBrowser->ShowAdBar(pDispParams->rgvarg[0].bstrVal);
            }   
            break;
        }

    }

    return (S_OK);
}


HRESULT CMessageView::GetMarkAsReadTime(LPDWORD pdwSecs)
{
    if (!pdwSecs)
    {
        AssertSz(FALSE, "Null Pointer");
        return (E_INVALIDARG);
    }

    *pdwSecs = DwGetOption(OPT_MARKASREAD);
    
    return (S_OK);
}

HRESULT CMessageView::GetAccount(IImnAccount **ppAcct)
{
    FOLDERINFO      FolderInfo;
    HRESULT         hr = E_FAIL;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    
    if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
    {
        if (SUCCEEDED(GetFolderAccountId(&FolderInfo, szAccountId) && *szAccountId))
        {
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, ppAcct);  
            // If local store then we can fail
            if(FAILED(hr))
            {
                DWORD   dwRow = 0;
                DWORD   cSel = 0;
                if (SUCCEEDED(m_pMsgList->GetSelected(&dwRow, &cSel, NULL)))
                {
                    LPMESSAGEINFO pMsgInfo;
                    if (SUCCEEDED(m_pMsgList->GetMessageInfo(dwRow, &pMsgInfo)))
                    {
                        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pMsgInfo->pszAcctId, ppAcct);  
                        m_pMsgList->FreeMessageInfo(pMsgInfo);
                    }
                }
            }
        }
        g_pStore->FreeRecord(&FolderInfo);
    }
    return(hr);
}

HRESULT CMessageView::GetFlags(LPDWORD pdwFlags)
{
    FOLDERTYPE ftType;

    if (!pdwFlags)
    {
        AssertSz(FALSE, "Null Pointer");
        return (E_INVALIDARG);
    }

    *pdwFlags = BOPT_AUTOINLINE | BOPT_HTML | BOPT_INCLUDEMSG | BOPT_FROMSTORE;

    if (m_pMsgList)
    {
        DWORD   dwRow = 0;
        DWORD   cSel = 0;
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwRow, &cSel, NULL)))
        {
            LPMESSAGEINFO pMsgInfo;

            if (cSel > 1)
                *pdwFlags |= BOPT_MULTI_MSGS_SELECTED;

            if (SUCCEEDED(m_pMsgList->GetMessageInfo(dwRow, &pMsgInfo)))
            {
                if (0 == (pMsgInfo->dwFlags & ARF_READ))
                    *pdwFlags |= BOPT_UNREAD;
                if (0 == (pMsgInfo->dwFlags & ARF_NOSECUI))
                    *pdwFlags |= BOPT_SECURITYUIENABLED;
                m_pMsgList->FreeMessageInfo(pMsgInfo);
            }
        }
    }

    m_pBrowser->GetFolderType(&ftType);
    if (FOLDER_NEWS != ftType)
        *pdwFlags |= BOPT_MAIL;

    return (S_OK);
}



//
//  FUNCTION:   CMessageView::EventOccurred()
//
//  PURPOSE:    Get's hit whenever an interesting event happens in the preview 
//              pane.
//
//  PARAMETERS: 
//      DWORD nCmdID
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::EventOccurred(DWORD nCmdID, IMimeMessage *pMessage)
{
    TraceCall("CMessageView::EventOccurred");

    switch (nCmdID)
    {
        case MEHC_CMD_DOWNLOAD:    
            Assert(m_fNotDownloaded);
            
            // If we're offline, we can make the reasonable assumption that
            // the user wants to be online since they said they wanted to 
            // download this message.
            if (g_pConMan && g_pConMan->IsGlobalOffline())
                g_pConMan->SetGlobalOffline(FALSE);

            _UpdatePreviewPane(TRUE);
            break;

        case MEHC_CMD_MARK_AS_READ:
            if (m_pMsgList)
                m_pMsgList->MarkRead(TRUE, 0);
            break;

        case MEHC_CMD_CONNECT:
            if (g_pConMan)
                g_pConMan->SetGlobalOffline(FALSE);
            _UpdatePreviewPane();
            break;

        case MEHC_BTN_OPEN:
        case MEHC_BTN_CONTINUE:
            // Update the toolbar state
            m_pBrowser->UpdateToolbar();
            break;

        case MEHC_UIACTIVATE:
            m_pBrowser->OnViewWindowActive(this);
            break;

        case MEHC_CMD_PROCESS_RECEIPT:
            if (m_pMsgList)
                m_pMsgList->ProcessReceipt(pMessage);
            break;

        default:
           /*  AssertSz(FALSE, "CMessageView::EventOccured() - Unhandled Event."); */ // Valid situation - Warning message for S/MIME
            break;
    }

    return (S_FALSE);
}


HRESULT CMessageView::GetFolderId(FOLDERID *pID)
{
    if (pID)
    {
        *pID = m_idFolder;
        return (S_OK);
    }

    return (E_INVALIDARG);
}


HRESULT CMessageView::GetMessageFolder(IMessageServer **ppServer)
{
    if (m_pMsgList)
        return (m_pMsgList->GetMessageServer(ppServer));

    return (E_NOTIMPL);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Window Message Handling
//


//
//  FUNCTION:   CMessageView::ViewWndProc()
//
//  PURPOSE:    Callback handler for the view window.  This function grabs the
//              correct this pointer for the window and uses that to dispatch
//              the message to the private message handler.
//
LRESULT CALLBACK CMessageView::ViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                           LPARAM lParam)
{
    LRESULT       lResult;
    CMessageView *pThis;

    // WM_NCCREATE is the first message our window will receive.  The lParam
    // will have the pointer to the object that created this instance of the
    // window.
    if (uMsg == WM_NCCREATE)
    {
        // Save the object pointer in the window's extra bytes.
        pThis = (CMessageView *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
    {
        // If this is any other message, we need to get the object pointer
        // from the window before dispatching the message.
        pThis = (CMessageView *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    // If this ain't true, we're in trouble.
    if (pThis)
    {
        return (pThis->_WndProc(hwnd, uMsg, wParam, lParam));
    }
    else
    {
        Assert(pThis);
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}


//
//  FUNCTION:   CMessageView::_WndProc()
//
//  PURPOSE:    This private message handler dispatches messages to the 
//              appropriate handler.
//
LRESULT CALLBACK CMessageView::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_POSTCREATE,     OnPostCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN,    OnLButtonDown);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,      OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,      OnLButtonUp);
        HANDLE_MSG(hwnd, WM_NOTIFY,         OnNotify);
        HANDLE_MSG(hwnd, WM_DESTROY,        OnDestroy);
        HANDLE_MSG(hwnd, WM_SETFOCUS,       OnSetFocus);
        HANDLE_MSG(hwnd, WM_TEST_GETMSGID,  OnTestGetMsgId);
        HANDLE_MSG(hwnd, WM_TEST_SAVEMSG,   OnTestSaveMessage);

        case WM_FOLDER_LOADED:
            OnFolderLoaded(hwnd, wParam, lParam);
            break;

        case WM_NEW_MAIL:
            // Propagate up to browser
            PostMessage(m_hwndParent, WM_NEW_MAIL, 0, 0);
            break;

        case NVM_GETNEWGROUPS:
            if (m_pGroups != NULL)
            {
                m_pGroups->HandleGetNewGroups();
                m_pGroups->Release();
                m_pGroups = NULL;
            }
            return(0);

        case WM_UPDATE_PREVIEW:
            if (m_idMessageFocus == (MESSAGEID)wParam)
            {
                _UpdatePreviewPane();
            }
            break;

        case CM_OPTIONADVISE:
            _OptionUpdate((DWORD) wParam);
            break;

        case WM_MENUSELECT:
            // HANDLE_WM_MENUSELECT() has a bug that prevents popups from displaying correctly.
            OnMenuSelect(hwnd, wParam, lParam);
            return (0);

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            if (m_pMsgList)
            {
                IOleWindow *pWindow;
                if (SUCCEEDED(m_pMsgList->QueryInterface(IID_IOleWindow, (LPVOID *) &pWindow)))
                {
                    HWND hwndList;
                    pWindow->GetWindow(&hwndList);
                    SendMessage(hwndList, uMsg, wParam, lParam);
                    pWindow->Release();
                }
            }
            return (0);
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}
 
// PURPOSE: WM_FOLDER_LOADED message is sent when messagelist is done loading the cached headers/messages etc
void CMessageView::OnFolderLoaded(HWND  hwnd, WPARAM wParam, LPARAM lParam)
{
    FOLDERINFO      FolderInfo;
    if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
    {
        CHAR szAccountId[CCHMAX_ACCOUNT_NAME];

        if (SUCCEEDED(GetFolderAccountId(&FolderInfo, szAccountId)))
        {
            HRESULT     hr;

            if (g_pConMan)
            {
                hr = g_pConMan->CanConnect(szAccountId);
                if ((hr != S_OK) && (hr != HR_E_DIALING_INPROGRESS) && (hr != HR_E_OFFLINE))
                    g_pConMan->Connect(szAccountId, hwnd, TRUE);
            }
        }
        g_pStore->FreeRecord(&FolderInfo);
    }
}

//
//  FUNCTION:   CMessageView::OnCreate()
//
//  PURPOSE:    Handler for the WM_CREATE message.  In return we create our 
//              dependant objects and initialize them.
//
//  PARAMETERS: 
//      [in] hwnd - Handle of the window being created
//      [in] lpCreateStruct - Pointer to a structure with information about the
//                            creation.
//
//  RETURN VALUE:
//      Returns FALSE if something fails and the window should not be created,
//      and returns TRUE if everything works fine.
//
BOOL CMessageView::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    HRESULT hr;
    HWND hwndList;

    TraceCall("CMessageView::OnCreate");

    // Save the window handle
    m_hwnd = hwnd;

    // Create the message list object
    if (!_InitMessageList())
        return (FALSE);

    // Create the preview pane.  If it fails that's OK, we'll just
    // run without it.
    _InitPreviewPane();

    // Get updates when options change
    OptionAdvise(m_hwnd);

    // For later
    PostMessage(m_hwnd, WM_POSTCREATE, 0, 0);

    return (TRUE);
}


//
//  FUNCTION:   CMessageView::OnPostCreate()
//
//  PURPOSE:    Notifies when the view has finished being created.  Any 
//              initialization that takes time can happen here, like loading
//              the message table etc.
//
//  PARAMETERS: 
//      [in] hwnd - Handle of the window
//
void CMessageView::OnPostCreate(HWND hwnd)
{
    HRESULT     hr;
    FOLDERTYPE  FolderType;
    FOLDERINFO  fiServerNode = {0};
    HRESULT     hrTemp;

    TraceCall("CMessageView::OnPostCreate");

    if (!g_pStore)
        return;

    FolderType = GetFolderType(m_idFolder);
    
    ProcessICW(hwnd, FolderType);

    // BETA-2: If this is IMAP folder, check if IMAP folderlist is dirty.
    // If so, prompt user to refresh folderlist

    hrTemp = GetFolderServer(m_idFolder, &fiServerNode);
    TraceError(hrTemp);
    if (SUCCEEDED(hrTemp))
    {
        if (FOLDER_IMAP == FolderType)
            CheckIMAPDirty(fiServerNode.pszAccountId, hwnd, fiServerNode.idFolder, NOFLAGS);
    }

    // Tell the Message List control to load itself
    if (m_pMsgList)
    {
        // Tell the message list to change folders
        hr = m_pMsgList->SetFolder(m_idFolder, m_pServer, FALSE, NULL, NOSTORECALLBACK);
        if (FAILED(hr) && hr != E_PENDING && m_pPreview)
        {
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_FldrFail);
        }
    }

    
    if (m_pServer)
    {
        m_pServer->ConnectionRelease();
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Create a drop target
    m_pDropTarget = new CDropTarget();
    if (m_pDropTarget)
    {
        if (SUCCEEDED(m_pDropTarget->Initialize(m_hwnd, m_idFolder)))
        {
            RegisterDragDrop(m_hwnd, m_pDropTarget);
        }
    }

    if (FolderType == FOLDER_NEWS)
        NewsUtil_CheckForNewGroups(hwnd, m_idFolder, &m_pGroups);

    // If its HTTP folder (Should have been hotmail folder), and if we are connected we ask for the ad url.
    if ((FolderType == FOLDER_HTTPMAIL) &&
        (g_pConMan && (S_OK == g_pConMan->CanConnect(fiServerNode.pszAccountId))))
    {
        m_pMsgList->GetAdBarUrl();
    }

    g_pStore->FreeRecord(&fiServerNode);
}

#define SPLIT_SIZE 3

void CMessageView::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rc = {0, 0, cxClient, cyClient};
    int  split;

    // If we are displaying the preview pane, we need to split the client area
    // based on the position of the split bar.
    if (_IsPreview())
    {
        // Line the windows up based on the split direction
        if (m_fSplitHorz)
        {
            // Determine the split height
            split = (cyClient * m_dwSplitHorzPct) / 100;

            // Save the rect that the split bar occupies
            SetRect(&m_rcSplit, 0, split, cxClient, split + SPLIT_SIZE);

            // Set the position of the preview pane
            rc.top = m_rcSplit.bottom;
            rc.bottom = cyClient;
            
            if (m_pPreview)
                m_pPreview->HrSetSize(&rc);

            // Set the position of the message list
            SetRect(&rc, -1, 0, cxClient + 2, split);
            m_pMsgList->SetRect(rc);
        }
        else
        {
            // Determine the split width
            split = (cxClient * m_dwSplitVertPct) / 100;

            // Save the rect that the split bar occupies
            SetRect(&m_rcSplit, split, 0, split + SPLIT_SIZE, cyClient);

            // Set the position of the message list
            rc.right = split;
            m_pMsgList->SetRect(rc);

            // Set the position of the preview pane
            rc.left = m_rcSplit.right;
            rc.right = cxClient;
            
            if (m_pPreview)
                m_pPreview->HrSetSize(&rc);
        }
    }
    else
    {
        SetRect(&rc, -1, 0, cxClient + 2, cyClient);
        m_pMsgList->SetRect(rc);
    }

    return;
}


//
//  FUNCTION:   CMessageView::OnLButtonDown
//
//  PURPOSE:    We check to see if we're over the splitter bar and if so start
//              a drag operation.
//
//  PARAMETERS:
//      hwnd         - Handle to the view window.
//      fDoubleClick - TRUE if this is a double click.
//      x, y         - Position of the mouse in client coordinates.
//      keyFlags     - State of the keyboard.
//    
void CMessageView::OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    POINT       pt = {x, y};

    // Check to see if the mouse is over the split bar
    if (_IsPreview() && PtInRect(&m_rcSplit, pt))
    {
        // Capture the mouse
        SetCapture(m_hwnd);

        // Start dragging
        m_fDragging = TRUE;
    }
}


//
//  FUNCTION:   CMessageView::OnMouseMove
//
//  PURPOSE:    We update any drag and drop information in response to mouse
//              moves if a drag and drop is in progress.
//
//  PARAMETERS:
//      hwnd     - Handle to the view window.
//      x, y     - Position of the mouse in client coordinates.
//      keyFlags - State of the keyboard.
//
void CMessageView::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    HCURSOR hcur;
    POINT pt = {x, y};
    RECT  rcClient;

    // If we're dragging the split bar, update the window sizes
    if (m_fDragging)
    {
        // Get the size of the window
        GetClientRect(m_hwnd, &rcClient);

        // Calculate the new split percentage
        if (m_fSplitHorz)
        {
            // Make sure the user hasn't gone off the deep end
            if (y > 32 && y < (rcClient.bottom - 32))
                m_dwSplitHorzPct = (y * 100) / rcClient.bottom;
        }
        else
        {
            // Make sure the user hasn't gone off the deep end
            if (x > 32 && x < (rcClient.right - 32))
                m_dwSplitVertPct = (x * 100) / rcClient.right;
        }

        // Update the window sizes
        OnSize(m_hwnd, SIZE_RESTORED, rcClient.right, rcClient.bottom);
    }
    else
    {
        // Just update the cursor
        if (PtInRect(&m_rcSplit, pt))
            {
            if (m_fSplitHorz)
                hcur = LoadCursor(NULL, MAKEINTRESOURCE(IDC_SIZENS));
            else
                hcur = LoadCursor(NULL, MAKEINTRESOURCE(IDC_SIZEWE));    
            }
        else
            hcur = LoadCursor(NULL, IDC_ARROW);

        SetCursor(hcur);
    }
}

//
//  FUNCTION:   CMessageView::OnLButtonUp
//
//  PURPOSE:    If a drag opteration is currently in progress (as determined
//              by the g_fDragging variable) then this function handles 
//              ending the drag and updating the split position.
//
//  PARAMETERS:
//      hwnd     - handle of the window receiving the message
//      x        - horizontal mouse position in client coordinates
//      y        - vertical mouse position in client coordinates
//      keyFlags - Indicates whether various virtual keys are down
//
void CMessageView::OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    DWORD       dwHeader;
    DWORD       dwSize;
    BOOL        fVisible;
    DWORD       dwOpt;
    FOLDERTYPE  ftType;

    if (m_fDragging)
    {
        ReleaseCapture();
        m_fDragging = FALSE;

        // Get the old settings
        m_pBrowser->GetFolderType(&ftType);
        if (ftType == FOLDER_NEWS)
            dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
        else
            dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

        m_pBrowser->GetViewLayout(dwOpt, 0, &fVisible, &dwHeader, &dwSize);

        // Update the new splits
        if (m_fSplitHorz)
            dwSize = MAKELONG(m_dwSplitHorzPct, 0);
        else
            dwSize = MAKELONG(0, m_dwSplitVertPct);

        // Set the settings back to the browser
        m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, fVisible, dwHeader, dwSize);
    }
}


//
//  FUNCTION:   CMessageView::OnMenuSelect()
//
//  PURPOSE:    Put's helpful text on the status bar describing the selected
//              menu item.
//
void CMessageView::OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // Let the preview pane have it first
    if (m_pPreview)
    {
        if (S_OK == m_pPreview->HrWMMenuSelect(hwnd, wParam, lParam))
            return;
    }

    // Handle it ourselves
    CStatusBar *pStatusBar = NULL;
    m_pBrowser->GetStatusBar(&pStatusBar);
    HandleMenuSelect(pStatusBar, wParam, lParam);
    pStatusBar->Release();
}


//
//  FUNCTION:   CMessageView::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the view window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CMessageView::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    switch (pnmhdr->code)
    {
        case BDN_HEADERDBLCLK:
        {
            if (m_pPreview)
            {
                DWORD dw = 0;
                BOOL  f = 0;
                FOLDERTYPE ftType;
                DWORD dwOpt;

                m_pBrowser->GetFolderType(&ftType);
                if (ftType == FOLDER_NEWS)
                    dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
                else
                    dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

                m_pBrowser->GetViewLayout(dwOpt, 0, &f, &dw, 0);
                m_pPreview->HrSetStyle(!dw ? MESTYLE_PREVIEW : MESTYLE_MINIHEADER);
                m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, f, !dw, 0);
            }
            break;
        }
        case BDN_MARKASSECURE:
        {
            if (m_pMsgList)
            {
                DWORD dwRow = 0;
                if (SUCCEEDED(m_pMsgList->GetSelected(&dwRow, NULL, NULL)))
                    m_pMsgList->MarkMessage(dwRow, MARK_MESSAGE_NOSECUI);
            }
            break;
        }
    }

    return (0);
}


void CMessageView::OnDestroy(HWND hwnd)
{
    if (m_pDropTarget)
    {
        RevokeDragDrop(hwnd);
        m_pDropTarget->Release();
        m_pDropTarget = 0;
    }

    // Stop advising for option changes
    OptionUnadvise(m_hwnd);

    // Release the preview pane
    if (m_pPreview)
    {
        m_pPreview->HrUnloadAll(NULL, 0);
        m_pPreview->HrClose();
    }
}


void CMessageView::OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    IOleWindow *pWindow = 0;
    HWND        hwndList = 0;

    if (m_pMsgList)
    {
        if (SUCCEEDED(m_pMsgList->QueryInterface(IID_IOleWindow, (LPVOID *) &pWindow)))
        {
            if (SUCCEEDED(pWindow->GetWindow(&hwndList)))
            {
                SetFocus(hwndList);
            }
            pWindow->Release();
        }
    }
}


//
//  FUNCTION:   CMessageView::OnTestGetMsgId()
//
//  PURPOSE:    This function is for the testing team.  Please consult Racheli
//              before modifying it in any way.
//
LRESULT CMessageView::OnTestGetMsgId(HWND hwnd)
{
    DWORD       cSel;
    DWORD      *rgSelected = NULL;
    LRESULT     lResult = -1;
    LPMESSAGEINFO pInfo;

    TraceCall("CMessageView::OnTestGetMsgId");

    // Only handle this if we're in test mode
    if (!DwGetOption(OPT_TEST_MODE))
        return (-1);

    // Get the range of selected messages
    if (SUCCEEDED(m_pMsgList && m_pMsgList->GetSelected(NULL, &cSel, &rgSelected)))
    {
        // Get the message info for the selected row
        if (cSel && SUCCEEDED(m_pMsgList->GetMessageInfo(*rgSelected, &pInfo)))
        {
            lResult = (LRESULT) pInfo->idMessage;
            m_pMsgList->FreeMessageInfo(pInfo);
        }

        MemFree(&rgSelected);
    }

    return (lResult);
}


//
//  FUNCTION:   CMessageView::OnTestSaveMessage()
//
//  PURPOSE:    This method is for the testing team.  Please consult Racheli
//              before making any changes.
//
LRESULT CMessageView::OnTestSaveMessage(HWND hwnd)
{
    DWORD         cSel;
    DWORD        *rgSelected = NULL;
    TCHAR         szFile[MAX_PATH];
    IUnknown     *pUnkMessage;
    IMimeMessage *pMessage = NULL;
    LRESULT       lResult = -1;

    TraceCall("CMessageView::OnTestSaveMessage");

    // Make sure we only do this in test mode
    if (!DwGetOption(OPT_TEST_MODE))
        return (-1);

    // Get the dump file name
    if (!GetOption(OPT_DUMP_FILE, szFile, ARRAYSIZE(szFile)))
        return (-1);

    // Get the selected range
    if (SUCCEEDED(m_pMsgList->GetSelected(NULL, &cSel, &rgSelected)))
    {
        // Load the first selected message from the store
        if (cSel && SUCCEEDED(m_pMsgList->GetMessage(*rgSelected, FALSE, FALSE, &pUnkMessage)))
        {
            // Get the IMimeMessage interface from the message
            if (pUnkMessage && SUCCEEDED(pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage)))
            {
                // Save the message 
                HrSaveMsgToFile(pMessage, (LPTSTR) szFile);
                pMessage->Release();
                lResult = 0;
            }

            pUnkMessage->Release();
        }

        MemFree(rgSelected);
    }

    return (lResult);
}


//
//  FUNCTION:   CMessageView::CmdOpen()
//
//  PURPOSE:    Opens the selected messages.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr;

    TraceCall("CMessageView::CmdOpen");

    // If more than 10 messages are selected, warn the user with a "Don't show
    // me again" dialog that this could be bad.
    DWORD dwSel = 0;
    
    m_pMsgList->GetSelectedCount(&dwSel);
    if (dwSel > 10)
    {
        TCHAR szBuffer[CCHMAX_STRINGRES];
        LRESULT lResult;

        AthLoadString(idsErrOpenManyMessages, szBuffer, ARRAYSIZE(szBuffer));
        lResult = DoDontShowMeAgainDlg(m_hwnd, c_szRegManyMsgWarning, 
                                       MAKEINTRESOURCE(idsAthena), szBuffer, 
                                       MB_OKCANCEL);
        if (IDCANCEL == lResult)
            return (S_OK);
    }

    // Get the array of selected rows from the message list
    DWORD *rgRows = NULL;
    DWORD cRows = 0;

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    LPMESSAGEINFO  pInfo;
    IMessageTable *pTable = NULL;

    hr = m_pMsgList->GetMessageTable(&pTable);
    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; (i < cRows && m_pMsgList != NULL); i++)
        {
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[i], &pInfo)))
            {
                INIT_MSGSITE_STRUCT initStruct;
                DWORD dwCreateFlags;
                initStruct.initTable.pListSelect = NULL;
                m_pMsgList->GetListSelector(&initStruct.initTable.pListSelect);
                
                // Initialize note struct
                initStruct.dwInitType = OEMSIT_MSG_TABLE;
                initStruct.initTable.pMsgTable = pTable;
                initStruct.folderID = m_idFolder;
                initStruct.initTable.rowIndex = rgRows[i];

                // Decide whether it is news or mail
                if (pInfo->dwFlags & ARF_NEWSMSG)
                    dwCreateFlags = OENCF_NEWSFIRST;
                else
                    dwCreateFlags = 0;

                m_pMsgList->FreeMessageInfo(pInfo);

                // Create and Open Note
                hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct, m_hwnd);
                ReleaseObj(initStruct.initTable.pListSelect);

                if (FAILED(hr))
                    break;
            }
        }
        pTable->Release();
    }

    if (SUCCEEDED(hr) && g_pInstance)
    {
        FOLDERTYPE ft = GetFolderType(m_idFolder);
        if (ft == FOLDER_IMAP || ft == FOLDER_LOCAL || ft == FOLDER_HTTPMAIL)
            g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);
    }

    SafeMemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CmdReply()
//
//  PURPOSE:    Replies or Reply-All's to the selected message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;
    OLECMD          cmd;
    IMessageTable  *pTable = NULL;
    PROPVARIANT     var;

    // We can hit this via accelerators.  Since accelerators don't go through 
    // QueryStatus(), we need to make sure this should really be enabled.
    cmd.cmdID = nCmdID;
    cmd.cmdf = 0;
    if (FAILED(QueryStatus(NULL, 1, &cmd, NULL)) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
        return (S_OK);

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            INIT_MSGSITE_STRUCT rInitSite;
            DWORD               dwCreateFlags;
            DWORD               dwAction = 0;

            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            if ((1 < cRows) && ((ID_FORWARD == nCmdID) || (ID_FORWARD_AS_ATTACH == nCmdID)))
            {
                IMimeMessage   *pMsgFwd = NULL;
                BOOL            fErrorsOccured = FALSE,
                                fCreateNote = TRUE;

                hr = HrCreateMessage(&pMsgFwd);
                if (FAILED(hr))
                    goto exit;

                // Raid 80277; Set default charset
                if (NULL == g_hDefaultCharsetForMail) 
                    ReadSendMailDefaultCharset();

                pMsgFwd->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
                
                rInitSite.dwInitType = OEMSIT_MSG;
                rInitSite.pMsg = pMsgFwd;
                rInitSite.folderID = m_idFolder;

                dwCreateFlags = 0;
                dwAction = OENA_COMPOSE;

                for (DWORD i = 0; i < cRows; i++)
                {
                    DWORD           iRow = rgRows[i];
                    IMimeMessage   *pMsg = NULL;

                    // Since this command is 
                    hr = pTable->OpenMessage(iRow, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK);
                    if (SUCCEEDED(hr))
                    {
                        // If this is the first message, get the account ID from it
                        if (i == 0)
                        {
                            var.vt = VT_LPSTR;
                            if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
                            {
                                pMsgFwd->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
                            }
                        }

                        if (FAILED(pMsgFwd->AttachObject(IID_IMimeMessage, (LPVOID)pMsg, NULL)))
                            fErrorsOccured = TRUE;
                        pMsg->Release();
                    }
                    else
                        fErrorsOccured = TRUE;
                }

                if (fErrorsOccured)
                {
                    if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                            MAKEINTRESOURCEW(idsErrorAttachingMsgsToNote), NULL, MB_OKCANCEL) == IDCANCEL)
                        fCreateNote = FALSE;
                }

                if (fCreateNote)
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd);                
                pMsgFwd->Release();
            }
            else
            {
                LPMESSAGEINFO   pInfo;

                // Get some information about the message
                if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
                {
                    // Determine if this is a news or mail message.
                    if (pInfo->dwFlags & ARF_NEWSMSG)
                        dwCreateFlags = OENCF_NEWSFIRST;
                    else
                        dwCreateFlags = 0;

                    // Reply or forward
                    if (nCmdID == ID_FORWARD)
                        dwAction = OENA_FORWARD;
                    else if (nCmdID == ID_FORWARD_AS_ATTACH)
                        dwAction = OENA_FORWARDBYATTACH;
                    else if (nCmdID == ID_REPLY)
                        dwAction = OENA_REPLYTOAUTHOR;
                    else if (nCmdID == ID_REPLY_ALL)
                        dwAction = OENA_REPLYALL;
                    else if (nCmdID == ID_REPLY_GROUP)
                        dwAction = OENA_REPLYTONEWSGROUP;
                    else
                        AssertSz(FALSE, "Didn't ask for a valid action");

                    // Fill out the initialization information
                    rInitSite.dwInitType = OEMSIT_MSG_TABLE;
                    rInitSite.initTable.pMsgTable = pTable;
                    rInitSite.initTable.pListSelect = NULL;
                    rInitSite.folderID  = m_idFolder;
                    rInitSite.initTable.rowIndex  = dwFocused;

                    m_pMsgList->FreeMessageInfo(pInfo);

                    // Create the note object
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd);
                }
            }
        }
    }

exit:
    ReleaseObj(pTable);
    SafeMemFree(rgRows);
    return (S_OK);
}

HRESULT CMessageView::CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            IMessageTable  *pTable = NULL;
            LPMESSAGEINFO   pInfo;
            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            // Get some information about the message
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
            {
                hr = NewsUtil_HrCancelPost(m_hwnd, m_idFolder, pInfo);

                m_pMsgList->FreeMessageInfo(pInfo);
            }
            pTable->Release();
        }
    }

exit:
    SafeMemFree(rgRows);
    return (S_OK);
}

//
//  FUNCTION:   CMessageView::CmdFillPreview()
//
//  PURPOSE:    Fills the preview pane with the selected & focused message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdFillPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    AssertSz(FALSE, "NYI");
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CMessageView::CmdShowPreview()
//
//  PURPOSE:    Handles updating the settings dealing with the preview pane.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdShowPreview(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    FOLDERTYPE  ftType;
    DWORD       dwOpt;
    LAYOUTPOS   pos;
    BOOL        fVisible;
    DWORD       dwFlags;

    // Get the folder type
    m_pBrowser->GetFolderType(&ftType);
    if (ftType == FOLDER_NEWS)
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
    else
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

    // Get the current settings from the browser
    m_pBrowser->GetViewLayout(dwOpt, NULL, &fVisible, &dwFlags, NULL);

    // Update the settings just based on the command
    switch (nCmdID)
    {
        case ID_PREVIEW_PANE:
        case ID_PREVIEW_SHOW:
        {
            // Set the complement of the visible bit
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, !fVisible, dwFlags, NULL);
            if (!fVisible)
            {
                // if showing update the preview pane
                _UpdatePreviewPane();
            }
            else
            {
                // if hiding, clear the contents
                m_pPreview->HrUnloadAll(NULL, 0);
            }

            break;
        }

        case ID_PREVIEW_BELOW:
        {
            // Update the position
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_BOTTOM, fVisible, dwFlags, NULL);
            break;
        }

        case ID_PREVIEW_BESIDE:
        {
            // Update the position
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_LEFT, fVisible, dwFlags, NULL);
            break;
        }

        case ID_PREVIEW_HEADER:
        {
            // Toggle the header flags
            m_pBrowser->SetViewLayout(dwOpt, LAYOUT_POS_NA, fVisible, !dwFlags, NULL);
            break;
        }

        default:
            Assert(FALSE);
    }

    return (S_OK);
}



//
//  FUNCTION:   CMessageView::CmdRefresh()
//
//  PURPOSE:    Refreshes the contents of the message list.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdRefresh(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr = E_FAIL;
    FOLDERINFO  FolderInfo;

    TraceCall("CMessageView::CmdRefresh");

    // Call into the message list now and let it refresh
    if (m_pMsgListCT)
        hr = m_pMsgListCT->Exec(NULL, ID_REFRESH_INNER, nCmdExecOpt, pvaIn, pvaOut);

    // If we succeeded in refreshing the message list, also try to reload the 
    // preview pane.
    _UpdatePreviewPane();

    // If this is a local folder and this isn't newsonly mode, in the past we 
    // do a Send & Recieve.
    if (FOLDER_LOCAL == GetFolderType(m_idFolder) && 0 == (g_dwAthenaMode & MODE_NEWSONLY))
        PostMessage(m_hwndParent, WM_COMMAND, ID_SEND_RECEIVE, 0);

    return (hr);
}


//
//  FUNCTION:   CMessageView::CmdBlockSender()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr = S_OK;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;
    LPSTR           pszEmailFrom = NULL;
    ADDRESSPROPS    rSender = {0};
    CHAR            szRes[CCHMAX_STRINGRES];
    LPSTR           pszResult = NULL;
    IOERule *       pIRule = NULL;
    BOOL            fMsgInfoFreed = FALSE;

    TraceCall("CMessageView::CmdBlockSender");

    hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows);
    if (FAILED(hr))
    {
        goto exit;
    }

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we already have the address?
    if ((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0]))
    {
        pszEmailFrom = PszDupA(pInfo->pszEmailFrom);
        if (NULL == pszEmailFrom)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

    }
    else
    {
        // Load that message from the store
        hr = m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        if (NULL == pUnkMessage)
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Get the IMimeMessage interface from the message
        hr = pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage);
        if (FAILED(hr))
        {
            goto exit;
        }

        rSender.dwProps = IAP_EMAIL;
        hr = pMessage->GetSender(&rSender);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));
        if ((NULL == rSender.pszEmail) || ('\0' == rSender.pszEmail[0]))
        {
            hr = E_FAIL;
            goto exit;
        }

        pszEmailFrom = PszDupA(rSender.pszEmail);
        if (NULL == pszEmailFrom)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // We don't need the message anymore
        g_pMoleAlloc->FreeAddressProps(&rSender);
        ZeroMemory(&rSender, sizeof(rSender));
        SafeRelease(pMessage);
    }

    // Free up the info
    m_pMsgList->FreeMessageInfo(pInfo);
    fMsgInfoFreed = TRUE;

    // Bring up the rule editor for this message
    hr = RuleUtil_HrAddBlockSender((0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, pszEmailFrom);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Load the template string
    AthLoadString(idsSenderAddedPrompt, szRes, sizeof(szRes));

    // Allocate the space to hold the final string
    hr = HrAlloc((VOID **) &pszResult, sizeof(*pszResult) * (lstrlen(szRes) + lstrlen(pszEmailFrom) + 1));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the warning string
    wsprintf(pszResult, szRes, pszEmailFrom);

    // Show the success dialog
    if (IDYES == AthMessageBox(m_hwnd, MAKEINTRESOURCE(idsAthena), pszResult, NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        // Create a block sender rule
        hr = HrBlockSendersFromFolder(m_hwnd, 0, m_idFolder, &pszEmailFrom, 1);
        if (FAILED(hr))
        {
            goto exit;
        }        
    }

    hr = S_OK;

exit:
    SafeRelease(pIRule);
    SafeMemFree(pszResult);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    SafeRelease(pMessage);
    SafeRelease(pUnkMessage);
    SafeMemFree(pszEmailFrom);
    if (FALSE == fMsgInfoFreed)
    {
        m_pMsgList->FreeMessageInfo(pInfo);
    }
    SafeMemFree(rgRows);
    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSenderError), NULL, MB_OK | MB_ICONERROR);
    }
    return (hr);
}


//
//  FUNCTION:   CMessageView::CmdCreateRule()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;

    TraceCall("CMessageView::CmdCreateRule");

    // Get the array of selected rows from the message list

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo)))
    {
        // Load that message from the store
        if (S_OK == m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage))
        {
            // Get the IMimeMessage interface from the message
            if (NULL != pUnkMessage)
            {
                pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage);
            }
        }
        
        // Bring up the rule editor for this message
        hr = HrCreateRuleFromMessage(m_hwnd, (0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? 
                    CRFMF_NEWS : CRFMF_MAIL, pInfo, pMessage);
    }

    SafeRelease(pMessage);
    SafeRelease(pUnkMessage);
    m_pMsgList->FreeMessageInfo(pInfo);
    SafeMemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CmdAddToWab()
//
//  PURPOSE:    Add the sender of the selected messages to the WAB
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdAddToWab(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr = S_OK;
    DWORD      *rgRows = NULL;
    DWORD       cRows = 0;
    LPMESSAGEINFO pInfo;
    LPWAB       pWAB = 0;

    TraceCall("CMessageView::CmdAddToWab");

    // Get the array of selected rows from the message list
    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // Get the header info for the message
    if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo)))
    {
        // Get a WAB object
        if (SUCCEEDED(hr = HrCreateWabObject(&pWAB)))
        {
            // Add the sender to the WAB
            if (FAILED(hr = pWAB->HrAddNewEntryA(pInfo->pszDisplayFrom, pInfo->pszEmailFrom)))
            {
                if (hr == MAPI_E_COLLISION)
                    AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrAddrDupe), 0, MB_OK | MB_ICONSTOP);
                else
                    AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrAddToWabSender), 0, MB_OK | MB_ICONSTOP);
            }

            pWAB->Release();
        }
        
        m_pMsgList->FreeMessageInfo(pInfo);
    }

    SafeMemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CMessageView::CmdCombineAndDecode()
//
//  PURPOSE:    Combines the selected messages into a single message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageView::CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    DWORD             *rgRows = NULL;
    DWORD              cRows = 0;
    CCombineAndDecode *pDecode = NULL;
    HRESULT            hr;

    // Create the decoder object
    pDecode = new CCombineAndDecode();
    if (!pDecode)
        return (S_OK);

    // Get the array of selected rows from the message list
    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // Get a pointer to the message table
    IMessageTable *pTable = NULL;
    if (SUCCEEDED(m_pMsgList->GetMessageTable(&pTable)))
    {
        // Initialize the decoder
        pDecode->Start(m_hwnd, pTable, rgRows, cRows, m_idFolder);
    }

    SafeMemFree(rgRows);
    pDecode->Release();
    pTable->Release();

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::_SetListOptions()
//
//  PURPOSE:    Maps the folder that we're about to view to the correct column
//              set and various options.
//
//  RETURN VALUE:
//      Returns S_OK if the column set was identified and set correctly.  Returns
//      a standard error HRESULT otherwise.
//
HRESULT CMessageView::_SetListOptions(void)
{
    HRESULT     hr;
    BOOL        fSelectFirst = FALSE;
    FOLDERTYPE  ft = GetFolderType(m_idFolder);

    // Make sure this badboy exists
    if (!m_pMsgList)
        return (E_UNEXPECTED);

    FOLDER_OPTIONS fo     = {0};
    fo.cbSize             = sizeof(FOLDER_OPTIONS);
    fo.dwMask             = FOM_EXPANDTHREADS | FOM_SELECTFIRSTUNREAD | FOM_THREAD | FOM_MESSAGELISTTIPS | FOM_POLLTIME | FOM_COLORWATCHED | FOM_GETXHEADERS | FOM_SHOWDELETED | FOM_SHOWREPLIES;
    fo.fExpandThreads     = DwGetOption(OPT_AUTOEXPAND);
    fo.fMessageListTips   = DwGetOption(OPT_MESSAGE_LIST_TIPS);
    fo.dwPollTime         = DwGetOption(OPT_POLLFORMSGS);
    fo.clrWatched         = DwGetOption(OPT_WATCHED_COLOR);
    fo.dwGetXHeaders      = DwGetOption(OPT_DOWNLOADCHUNKS);
    fo.fDeleted           = DwGetOption(OPT_SHOW_DELETED);
    fo.fReplies           = DwGetOption(OPT_SHOW_REPLIES);

    switch (ft)
    {
        case FOLDER_NEWS:
            fo.fThread = DwGetOption(OPT_NEWS_THREAD);
            fo.fSelectFirstUnread = TRUE;
            break;

        case FOLDER_LOCAL:
        case FOLDER_HTTPMAIL:
            fo.fThread = DwGetOption(OPT_MAIL_THREAD);
            fo.fSelectFirstUnread = FALSE;
            break;

        case FOLDER_IMAP:
            fo.fThread = DwGetOption(OPT_MAIL_THREAD);
            fo.fSelectFirstUnread = FALSE;
            break;
    }

    hr = m_pMsgList->SetViewOptions(&fo);
    return (hr);
}


BOOL CMessageView::_IsPreview(void)
{
    FOLDERTYPE  ftType;
    DWORD       dwOpt;

    // Get the folder type
    m_pBrowser->GetFolderType(&ftType);
    if (ftType == FOLDER_NEWS)
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
    else
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

    // Ask the browser if it should be on or off
    BOOL f = FALSE;
    if (m_pBrowser)
        m_pBrowser->GetViewLayout(dwOpt, 0, &f, 0, 0);

    return f;
}


BOOL CMessageView::_InitMessageList(void)
{
    HWND hwndList;

    // Create the message list object
    if (FAILED(CreateMessageList(NULL, &m_pMsgList)))
        return (FALSE);

    // Initialize the message list
    m_pMsgList->CreateList(m_hwnd, (IViewWindow *) this, &hwndList);

    // Get the command target interface for the list
    m_pMsgList->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pMsgListCT);
    m_pMsgList->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *) &m_pMsgListAO);

    // Request Notifications 
    AtlAdvise(m_pMsgList, (IUnknown *)(IViewWindow *) this, DIID__MessageListEvents, &m_dwCookie);

    // Set the column set for the message list
    _SetListOptions();

    return (TRUE);
}



//
//  FUNCTION:   CMessageView::_InitPreviewPane()
//
//  PURPOSE:    Creates the Preview Pane object and initializes it.
//
//  RETURN VALUE:
//      TRUE if the object was created and initialized, FALSE otherwise.
//
BOOL CMessageView::_InitPreviewPane(void)
{
    CMimeEditDocHost   *pDocHost = NULL;
    CStatusBar         *pStatusBar = NULL;
    DWORD               dwHeader;
    LAYOUTPOS           pos;
    BOOL                fVisible;
    DWORD               dwOpt;
    HRESULT             hr;
    FOLDERTYPE          ftType;
    DWORD               dwSize;

    TraceCall("CMessageView::_InitPreviewPane");

    // We only create the preview pane if it's supposed to be visible.
    m_pBrowser->GetFolderType(&ftType);
    if (ftType == FOLDER_NEWS)
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
    else
        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

    // Get the settings from the browser
    m_pBrowser->GetViewLayout(dwOpt, &pos, &fVisible, &dwHeader, &dwSize);

    // Stash this info
    m_dwSplitHorzPct = LOWORD(dwSize);
    m_dwSplitVertPct = HIWORD(dwSize);

    if (fVisible)
    {
        // Create the dochost
        pDocHost = new CMimeEditDocHost(MEBF_OUTERCLIENTEDGE);
        if (!pDocHost)
            goto error;
    
        // We want to get the IBodyObj2 interface from it.
        pDocHost->QueryInterface(IID_IBodyObj2, (LPVOID *) &m_pPreview);
        if (!m_pPreview)
            goto error;
        pDocHost->Release();

        // Also get the IOleCommandTarget interface from it.  If it fails, that's OK.
        m_pPreview->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pPreviewCT);

        if (m_pBrowser->GetStatusBar(&pStatusBar)==S_OK)
        {
            m_pPreview->HrSetStatusBar(pStatusBar);
            pStatusBar->Release();
        }

        // Create the preview window
        if (FAILED(m_pPreview->HrInit(m_hwnd, IBOF_DISPLAYTO|IBOF_TABLINKS, (IBodyOptions *) this)))
            goto error;

        hr = m_pPreview->HrShow(fVisible);
        if (FAILED(hr))
            goto error;

        m_pPreview->HrSetText(MAKEINTRESOURCE(idsHTMLEmptyPreviewSel));    
    
        UpdateLayout(fVisible, dwHeader, pos == LAYOUT_POS_LEFT, FALSE);

        // Give the preview pane our event sink interface
        m_pPreview->SetEventSink((IMimeEditEventSink *) this);
                
        return (TRUE);
    }

error:
    SafeRelease(pDocHost);
    SafeRelease(m_pPreview);

    return (FALSE);
}


void CMessageView::_UpdatePreviewPane(BOOL fForceDownload)
{
    DWORD     dwFocused;
    DWORD     cSelected;
    DWORD    *rgSelected = 0;
    IUnknown *pUnkMessage = 0;
    HRESULT   hr;


    if (m_pMsgList && m_pPreview)
    {
        m_idMessageFocus = MESSAGEID_INVALID;
        m_fNotDownloaded = FALSE;

        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cSelected, &rgSelected)))
        {
            // If there is a focused item 
            if (-1 == dwFocused || 0 == cSelected)
            {
                m_pPreview->HrUnloadAll(idsHTMLEmptyPreviewSel, 0);
            }
            else
            {
                // Load that message from the store
                hr = m_pMsgList->GetMessage(dwFocused, fForceDownload || DwGetOption(OPT_AUTOFILLPREVIEW), TRUE, &pUnkMessage);
                
                switch (hr)
                {
                    case MIME_E_SECURITY_CANTDECRYPT:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeEncrypt);
                        break;

#ifdef SMIME_V3
                    case MIME_E_SECURITY_LABELACCESSDENIED:
                    case MIME_E_SECURITY_LABELACCESSCANCELLED:
                    case MIME_E_SECURITY_LABELCORRUPT:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeLabel);
                        break;
#endif // SMIME_V3
                    case STORE_E_EXPIRED:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_Expired);
                        break;
                    
                    case STORE_E_NOBODY:
                        AssertSz(DwGetOption(OPT_AUTOFILLPREVIEW)==FALSE, "AutoPreview is on, download should have been started!");
                        if (g_pConMan->IsGlobalOffline())
                            m_pPreview->LoadHtmlErrorPage(c_szErrPage_Offline);
                        else
                            m_pPreview->LoadHtmlErrorPage(c_szErrPage_NotDownloaded);
                        m_fNotDownloaded = TRUE;
                        break;
                    
                    case DB_E_DISKFULL:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_DiskFull);
                        break;

                    case DB_S_NOTFOUND:
                    {
                        FOLDERINFO      FolderInfo;

                        //I don't think we need this coz its being handled in callbackcanconnect

                        //If the message is not found in the store, we ask it to download.
                        if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
                        {
                            if(g_pConMan && !(g_pConMan->IsGlobalOffline()))
                            {
                                CHAR szAccountId[CCHMAX_ACCOUNT_NAME];

                                if (SUCCEEDED(GetFolderAccountId(&FolderInfo, szAccountId)))
                                {
                                    if (g_pConMan->Connect(szAccountId, m_hwnd, TRUE)== S_OK)
                                        hr = m_pMsgList->GetMessage(dwFocused, TRUE, TRUE, &pUnkMessage);            
                                }
                            }
                            g_pStore->FreeRecord(&FolderInfo);
                        }
                        break;
                    }


                    case STORE_S_ALREADYPENDING:
                    case E_PENDING:
                    {
                        // if the message is being downloaded, let's store the message-id and wait for an update    
                        LPMESSAGEINFO pInfo;

                        // clear the contents waiting for the new message to download
                        m_pPreview->HrUnloadAll(NULL, 0);

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
                        {
                            m_idMessageFocus = pInfo->idMessage;
                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                        break;
                    }

                    case E_NOT_ONLINE:
                    {
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_Offline);
                        break;
                    }

                    case S_OK:
                    {
                        // Get the IMimeMessage interface from the message
                        IMimeMessage *pMessage = 0;

                        if (pUnkMessage && SUCCEEDED(pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage)))
                        {
                            // bobn, brianv says we have to remove this...
                            /*if (g_dwBrowserFlags == 1)
                            {
                                LPSTR lpsz = NULL;
                                if (SUCCEEDED(MimeOleGetBodyPropA(pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpsz)))
                                {
                                    if (0 == strcmp(lpsz, "Credits"))
                                        g_dwBrowserFlags |= 2;
                                    else
                                        g_dwBrowserFlags = 0;

                                    SafeMimeOleFree(lpsz);
                                }
                            }*/

                            if (_DoEmailBombCheck(pMessage)==S_OK)
                            {
                                // Get the load interface from the preview pane object
                                IPersistMime *pPersistMime = 0;

                                if (SUCCEEDED(m_pPreview->QueryInterface(IID_IPersistMime, (LPVOID *) &pPersistMime)))
                                {
                                    DWORD               dwHeader;
                                    LAYOUTPOS           pos;
                                    BOOL                fVisible;
                                    DWORD               dwOpt;
                                    DWORD               dwSize;
                                    FOLDERTYPE          ftType;

                                    CStatusBar         *pStatusBar = NULL;

                                    // remember focus
                                    BOOL fFocused = ((m_pPreview->HrHasFocus() == S_OK) ? TRUE : FALSE);

                                    m_pBrowser->GetFolderType(&ftType);
                                    if (ftType == FOLDER_NEWS)
                                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_NEWS;
                                    else
                                        dwOpt = DISPID_MSGVIEW_PREVIEWPANE_MAIL;

                                    // Get the settings from the browser
                                    m_pBrowser->GetViewLayout(dwOpt, &pos, &fVisible, &dwHeader, &dwSize);
                                    m_pPreview->HrResetDocument();
                                    m_pPreview->HrSetStyle(dwHeader ? MESTYLE_PREVIEW : MESTYLE_MINIHEADER);
                                    // Give the preview pane our event sink interface
                                    m_pPreview->SetEventSink((IMimeEditEventSink *) this);
                                    pPersistMime->Load(pMessage);
                                    pPersistMime->Release();

                                    // restore status bar
                                    if (m_pBrowser->GetStatusBar(&pStatusBar)==S_OK)
                                    {
                                        m_pPreview->HrSetStatusBar(pStatusBar);
                                        pStatusBar->Release();
                                    }

                                    // return focus
                                    if(fFocused)
                                        m_pPreview->HrSetUIActivate();
                                }
                            }
                            pMessage->Release();
                        }
                        pUnkMessage->Release();
                        break;
                    }
                    default:
                        m_pPreview->LoadHtmlErrorPage(c_szErrPage_GenFailure);
                        break;
                }
            }

            if (rgSelected)
                MemFree(rgSelected);
        }
    }
}


//
//  FUNCTION:   CMessageView::_SetProgressStatusText()
//
//  PURPOSE:    Takes the provided BSTR, converts it to ANSI, and smacks it
//              on the status bar.
//
//  PARAMETERS: 
//      [in] bstr - henious BSTR to put on the status bar.
//
void CMessageView::_SetProgressStatusText(BSTR bstr)
{
    LPTSTR      psz = NULL;
    CStatusBar *pStatusBar = NULL;
    m_pBrowser->GetStatusBar(&pStatusBar);

    
    if (pStatusBar)
    {   
        pStatusBar->SetStatusText((LPTSTR) bstr);
    /*
        CComBSTR cString(bstr);

        // Allocate a string large enough
        if (MemAlloc((LPVOID *) &psz, 2 * cString.Length()))
        {
            WideCharToMultiByte(CP_ACP, 0, cString, -1,
                                psz, 2 * cString.Length(), NULL, NULL);
            pStatusBar->SetStatusText((LPTSTR) psz);
            MemFree(psz);
        }
    */
        pStatusBar->Release();
    }
}

//
//  FUNCTION:   CMessageView::_OnMessageAvailable()
//
//  PURPOSE:    Fired by the listview when a message has completed downloading
//              if the message is the currently selected message in the preview
//              then we update it. If it is not, we ignore the notification.
//              We check for downloading errors and display and appropriate message
//
//  PARAMETERS: 
//      [in] idMessage      - message id of the message that was downloaded
//      [in] hrCompletion   - hresult indicating possible error failure
//
HRESULT CMessageView::_OnMessageAvailable(MESSAGEID idMessage, HRESULT hrCompletion)
{
    if (m_idMessageFocus != idMessage)
        return S_FALSE;

    switch (hrCompletion)
    {
        // if we get a STORE_E_EXPIRED, then reload the preview pane to show error
        case S_OK:
        case STORE_E_EXPIRED:
            // we post a message to ourselves to update the preview pane. We do this because
            // any refcounts on the IStream into the store at this point have it locked for write
            // if we post, then the stack is unwound after the notifications are fired and we're in a
            // good state.
            PostMessage(m_hwnd, WM_UPDATE_PREVIEW, (WPARAM)idMessage, 0);
            break;

        case S_FALSE:
        case STORE_E_OPERATION_CANCELED:
        case hrUserCancel:
        case IXP_E_USER_CANCEL:
            // S_FALSE means the operation was canceled
            if (m_idMessageFocus != MESSAGEID_INVALID)
                m_pPreview->LoadHtmlErrorPage(c_szErrPage_DownloadCanceled);
            break;

        case STG_E_MEDIUMFULL:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_DiskFull);
            break;

        case HR_E_USER_CANCEL_CONNECT:
        case HR_E_OFFLINE:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_Offline);
            break;

        case MIME_E_SECURITY_CANTDECRYPT:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeEncrypt);
            break;

#ifdef SMIME_V3
        case MIME_E_SECURITY_LABELACCESSDENIED:
        case MIME_E_SECURITY_LABELACCESSCANCELLED:
        case MIME_E_SECURITY_LABELCORRUPT:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_SMimeLabel);
            break;
#endif // SMIME_V3

        default:
            m_pPreview->LoadHtmlErrorPage(c_szErrPage_GenFailure);
            break;
    }
    return S_OK;
}


//
//  FUNCTION:   CMessageView::_DoEmailBombCheck
//
//  PURPOSE:    Validates to ensure that the last time we closed OE we shutdown
//              correctly. If we did not shutdown correctly, we look at the msgid stamp 
//              that we stored in the registry for the last selected preview message
//              if it was the message we are about to preview, we do not show the
//              message, to prevent jscript attacks etc.
//
//  PARAMETERS: 
//              none
//
HRESULT CMessageView::_DoEmailBombCheck(LPMIMEMESSAGE pMsg)
{
    FILETIME    ft;
    PROPVARIANT va;
    DWORD       dwType,
                cb;

    va.vt = VT_FILETIME;
    if (pMsg && pMsg->GetProp(PIDTOSTR(STR_HDR_DATE), 0, &va)==S_OK)
    {
        if (g_fBadShutdown)
        {
            g_fBadShutdown=FALSE;
            
            cb = sizeof(FILETIME);
            
            if (AthUserGetValue(NULL, c_szLastMsg, &dwType, (LPBYTE)&ft, &cb)==S_OK &&
                (ft.dwLowDateTime == va.filetime.dwLowDateTime && 
                ft.dwHighDateTime == va.filetime.dwHighDateTime))
            {
                // possible the same dude
                m_pPreview->LoadHtmlErrorPage(c_szErrPage_MailBomb);
                return S_FALSE;
            }
        }
        AthUserSetValue(NULL, c_szLastMsg, REG_BINARY, (LPBYTE)&va.filetime, sizeof(FILETIME));
    }
    
    return S_OK;
}


void CMessageView::_OptionUpdate(DWORD dwUpdate)
{
    if (m_pMsgList &&
        (dwUpdate == OPT_AUTOEXPAND || 
         dwUpdate == OPT_MESSAGE_LIST_TIPS || 
         dwUpdate == OPT_POLLFORMSGS || 
         dwUpdate == OPT_WATCHED_COLOR ||
         dwUpdate == OPT_DOWNLOADCHUNKS))
    {
        FOLDER_OPTIONS fo     = {0};
        
        fo.cbSize             = sizeof(FOLDER_OPTIONS);
        fo.dwMask             = FOM_EXPANDTHREADS | FOM_MESSAGELISTTIPS | FOM_POLLTIME | FOM_COLORWATCHED | FOM_GETXHEADERS;
        fo.fExpandThreads     = DwGetOption(OPT_AUTOEXPAND);
        fo.fMessageListTips   = DwGetOption(OPT_MESSAGE_LIST_TIPS);
        fo.dwPollTime         = DwGetOption(OPT_POLLFORMSGS);
        fo.clrWatched         = DwGetOption(OPT_WATCHED_COLOR);
        fo.dwGetXHeaders      = DwGetOption(OPT_DOWNLOADCHUNKS);

        m_pMsgList->SetViewOptions(&fo);
    }
}


void CMessageView::_SetDefaultStatusText(void)
{
    DWORD       cTotal;
    DWORD       cUnread;
    DWORD       cOnServer;
    CStatusBar *pStatusBar = NULL;
    TCHAR       szStatus[CCHMAX_STRINGRES + 20];
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       ids;

    // If we don't have a browser pointer, we can't get the status bar
    if (!m_pBrowser || !m_pMsgList)
        return;

    // Get the status bar if there is one.
    m_pBrowser->GetStatusBar(&pStatusBar);
    if (pStatusBar)
    {
        // Get the counts from the table
        if (SUCCEEDED(m_pMsgList->GetMessageCounts(&cTotal, &cUnread, &cOnServer)))
        {
            // If there are still messages on server load a different
            // status string.
            if (cOnServer)
            {
                AthLoadString(idsXMsgsYUnreadZonServ, szFmt, ARRAYSIZE(szFmt));
                wsprintf(szStatus, szFmt, cTotal, cUnread, cOnServer);
            }
            else
            {
                AthLoadString(idsXMsgsYUnread, szFmt, ARRAYSIZE(szFmt));
                wsprintf(szStatus, szFmt, cTotal, cUnread);
            }
            pStatusBar->SetStatusText(szStatus);

            // Also update the toolbar since commands like "Mark as Read" might
            // change.  However, we only do this if we go between zero and some or
            // vice versa.
            if ((m_cItems == 0 && cTotal) || (m_cItems != 0 && cTotal == 0) ||
                (m_cUnread == 0 && cUnread) || (m_cUnread != 0 && cUnread == 0))
            {
                m_pBrowser->UpdateToolbar();
            }

            // Save this for next time.
            m_cItems = cTotal;
            m_cUnread = cUnread;
        }

        pStatusBar->Release();
    }
}


BOOL CMessageView::_ReuseMessageFolder(IViewWindow *pPrevView)
{
    IServerInfo *pInfo = NULL;
    FOLDERID     idPrev = FOLDERID_INVALID;
    FOLDERID     idServerPrev = FOLDERID_INVALID;
    FOLDERID     idServerCur = FOLDERID_INVALID;
    BOOL         fReturn = FALSE;

    if (pPrevView && SUCCEEDED(pPrevView->QueryInterface(IID_IServerInfo, (LPVOID *) &pInfo)))
    {
        if (SUCCEEDED(pInfo->GetFolderId(&idPrev)))
        {
            if (SUCCEEDED(GetFolderServerId(idPrev, &idServerPrev)))
            {
                if (SUCCEEDED(GetFolderServerId(m_idFolder, &idServerCur)))
                {
                    if (idServerPrev == idServerCur)
                    {
                        if (S_OK == pInfo->GetMessageFolder(&m_pServer))
                        {
                            m_pServer->ConnectionAddRef();
                            fReturn = TRUE;
                        }
                    }
                }
            }
        }

        pInfo->Release();
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\mapitest.c ===
#include "pch.h"
#include "resource.h"

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow);
BOOL CALLBACK SendMailDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
void LoadFunctions(HWND hwnd);
void UnloadFunctions();
void SendMail(HWND hwnd);
void SendDocuments(HWND hwnd);
void Address(HWND hwnd) ;
void ResolveName(HWND hwnd) ;
void Details(HWND hwnd);
void FindNext(HWND hwnd);
void ReadMail(HWND hwnd);
void SaveMail(HWND hwnd);
void DeleteMail(HWND hwnd);



HINSTANCE                       g_hInstMAPI = NULL;
LPMAPILOGON                     g_pfnMAPILogon = NULL;
LPMAPILOGOFF            g_pfnMAPILogoff = NULL;
LPMAPISENDMAIL          g_pfnMAPISendMail = NULL;
LPMAPISENDDOCUMENTS g_pfnMAPISendDocuments = NULL ;
LPMAPIADDRESS           g_pfnMAPIAddress = NULL ;
LPMAPIRESOLVENAME       g_pfnMAPIResolveName = NULL ;
LPMAPIDETAILS           g_pfnMAPIDetails = NULL ;
LPMAPIFREEBUFFER        g_pfnMAPIFreeBuffer = NULL ;
LPMAPIFINDNEXT      g_pfnMAPIFindNext=NULL;
LPMAPIREADMAIL      g_pfnMAPIReadMail=NULL;
LPMAPISAVEMAIL      g_pfnMAPISaveMail=NULL;
LPMAPIDELETEMAIL    g_pfnMAPIDeleteMail=NULL;



// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine;

    pszCmdLine = GetCommandLine();
	


    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
	/*
	 * Scan, and skip over, subsequent characters until
	 * another double-quote or a null is encountered.
	 */
	while ( *++pszCmdLine && (*pszCmdLine
	     != TEXT('\"')) );
	/*
	 * If we stopped on a double-quote (usual case), skip
	 * over it.
	 */
	if ( *pszCmdLine == TEXT('\"') )
	    pszCmdLine++;
    }
    else {
	while (*pszCmdLine > TEXT(' '))
	    pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
	pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
		   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    return i;
}

int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    return DialogBox(hInst, MAKEINTRESOURCE(IDD_SENDMAIL), NULL, SendMailDlgProc);
}


BOOL CALLBACK SendMailDlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    HWND hCombo ;
    switch (msg)
	{
	case WM_INITDIALOG:
	    hCombo = GetDlgItem(hwnd,IDC_DLLCOMBO);

	    //SetDlgItemText(hwnd, IDC_DLLCOMBO, "c:\\winnt\\system32\\mapi32.dll");

	    SendMessage(hCombo,CB_ADDSTRING,(WPARAM)0,(LPARAM)(LPCTSTR)"c:\\winnt\\system32\\mapi32.dll") ;
	    SendMessage(hCombo,CB_ADDSTRING,(WPARAM)0,(LPARAM)(LPCTSTR)"c:\\nt\\drop\\debug\\msoe.dll") ;

	    SetDlgItemText(hwnd, IDC_DLLPATH, "c:\\winnt\\system32\\mapi32.dll");
	    CheckRadioButton(hwnd, IDC_RECIP_NONE, IDC_RECIP_AMBIG, IDC_RECIP_NONE); 
	    CheckRadioButton(hwnd, IDC_EXITPROC, IDC_WAITRETURN, IDC_WAITRETURN);
	    return TRUE;

	case WM_DESTROY:
	    UnloadFunctions();
	    break;

	case WM_CLOSE:
	    EndDialog(hwnd, IDOK);
	    return TRUE;

	case WM_COMMAND:
	    switch (GET_WM_COMMAND_ID(wp, lp))
		{
		case IDOK:
		    EndDialog(hwnd, IDOK);
		    break;
		case IDC_LOADDLL:
		    LoadFunctions(hwnd);
		    break;
		case IDC_SEND:
		    SendMail(hwnd);
		    break;
				case IDC_SENDDOC:
					SendDocuments(hwnd) ;
					break;
				case IDC_MAPIADDRESS:
					Address(hwnd) ;
					break;
				case IDC_MAPIRESOLVENAME:
					ResolveName(hwnd);
					break;
				case IDC_MAPIDETAILS:
					Details(hwnd) ;
					break;
		case IDC_FINDNEXT:
		    FindNext(hwnd);
		    break;
		case IDC_READMAIL:
		    ReadMail(hwnd);
		    break;
		case IDC_SAVEMAIL:
		    SaveMail(hwnd);
		    break;
		case IDC_DELETEMAIL:
		    DeleteMail(hwnd);
		    break;
		}
	    return TRUE;

	case WM_TIMER:
	    if (wp == 1)
		OutputDebugString("MAPITEST: WM_TIMER\r\n");
	    else if (wp == 2)
		ExitProcess(0);
	    return TRUE;
	}
    return FALSE;
}

void LoadFunctions(HWND hwnd)
{
    TCHAR szDLL[MAX_PATH];
	DWORD dwError =0;

    UnloadFunctions();
    
    GetDlgItemText(hwnd, IDC_DLLPATH, szDLL, ARRAYSIZE(szDLL));
    g_hInstMAPI = LoadLibrary(szDLL);
	dwError = GetLastError() ;
    if (!g_hInstMAPI)
	{
	MessageBox(hwnd, "LoadLibrary() failed.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
	return;
	}

    g_pfnMAPILogon = (LPMAPILOGON)GetProcAddress(g_hInstMAPI, "MAPILogon");
    g_pfnMAPILogoff = (LPMAPILOGOFF)GetProcAddress(g_hInstMAPI, "MAPILogoff");
    g_pfnMAPISendMail = (LPMAPISENDMAIL)GetProcAddress(g_hInstMAPI, "MAPISendMail");
    g_pfnMAPISendDocuments = (LPMAPISENDDOCUMENTS)GetProcAddress(g_hInstMAPI, "MAPISendDocuments");
	g_pfnMAPIAddress = (LPMAPIADDRESS)GetProcAddress(g_hInstMAPI,"MAPIAddress") ;
	g_pfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress(g_hInstMAPI,"MAPIResolveName") ;
    g_pfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(g_hInstMAPI,"MAPIFreeBuffer") ;
	g_pfnMAPIDetails = (LPMAPIDETAILS)GetProcAddress(g_hInstMAPI,"MAPIDetails") ;
    g_pfnMAPIFindNext= (LPMAPIFINDNEXT)GetProcAddress(g_hInstMAPI,"MAPIFindNext");
    g_pfnMAPIReadMail= (LPMAPIREADMAIL)GetProcAddress(g_hInstMAPI,"MAPIReadMail");
    g_pfnMAPISaveMail= (LPMAPISAVEMAIL)GetProcAddress(g_hInstMAPI,"MAPISaveMail");
    g_pfnMAPIDeleteMail=(LPMAPIDELETEMAIL)GetProcAddress(g_hInstMAPI,"MAPIDeleteMail");

    if (!(g_pfnMAPILogon && g_pfnMAPILogoff && g_pfnMAPISendMail && g_pfnMAPISendDocuments && g_pfnMAPIAddress && g_pfnMAPIResolveName && g_pfnMAPIFreeBuffer && g_pfnMAPIDetails && g_pfnMAPIFindNext && g_pfnMAPIReadMail && g_pfnMAPISaveMail && g_pfnMAPIDeleteMail))
	MessageBox(hwnd, "GetProcAddress() failed.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
}

void UnloadFunctions()
{
    if (g_hInstMAPI)
	{
	FreeLibrary(g_hInstMAPI);
	g_hInstMAPI = NULL;
	g_pfnMAPILogon = NULL;   
	g_pfnMAPILogoff = NULL;  
	g_pfnMAPISendMail = NULL;
	}

}

void SendMail(HWND hwnd)
{
    ULONG           ulRet;
    FLAGS           fl = 0;
    MapiMessage     mm;
    MapiRecipDesc   mr,mo;
    LHANDLE         lhSession = 0;
    TCHAR           szBuf[MAX_PATH];
    MapiRecipDesc   recips[1];  

    // Just for testing lpEntryID - Begin
    char                    rgchSeedMsgID[513];
    char                    rgchMsgID[513];
    lpMapiMessage           rgMessage;

    // Just for testing lpEntryID - End

    if (!g_pfnMAPISendMail)
	{
	MessageBox(hwnd, "Need to load MAPI first.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
	return;
	}

    // Just for testing lpEntryID in MAPISendMail - Begin

     ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    
 
   
    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}  
    
    //   Just for testing lpEntryID in MAPISEndMail - End



    mm.ulReserved           = 0;
    mm.lpszSubject          = "Ha Ha Ha. Subject";
    mm.lpszNoteText         = "Ha Ha Ha. I got it Body\r\nLine 2";
    mm.lpszMessageType      = NULL;
    mm.lpszDateReceived     = NULL;
    mm.lpszConversationID   = NULL;
    mm.flFlags              = 0;
    mm.lpOriginator         = NULL;
    mm.nFileCount           = 0;
    mm.lpFiles              = NULL;
    mm.nRecipCount          = 1;



    if (IsDlgButtonChecked(hwnd, IDC_RECIP_NONE))
	{
	mm.nRecipCount = 0;
	mm.lpRecips = NULL;
	}
    else
	{
	mr.ulReserved = 0;
	mr.ulRecipClass = MAPI_TO;
	mr.ulEIDSize = 0;
	mr.lpEntryID = 0;
	if (IsDlgButtonChecked(hwnd, IDC_RECIP_RESOLVED))
	    {
	    mr.lpszName = "Senthil Kumar Natarajan";
	    mr.lpszAddress = "v-snatar@microsoft.com";
	    }
	else
	    {
	    mr.lpszName = "Senthil";
	    mr.lpszAddress = NULL;
	    }
	mm.nRecipCount = 1;
	mm.lpRecips = &mr;    
	}

   	mo.ulReserved = 0;
	mo.ulRecipClass = MAPI_ORIG	;
	mo.ulEIDSize = 0;
	mo.lpEntryID = 0;
    mo.lpszName = "Senthil Kumar Natarajan";
    mo.lpszAddress = "v-snatar@microsoft.com";


    if (IsDlgButtonChecked(hwnd, IDC_MAPI_DIALOG))
	fl |= MAPI_DIALOG;
    if (IsDlgButtonChecked(hwnd, IDC_MAPI_LOGON_UI))
	fl |= MAPI_LOGON_UI;
    if (IsDlgButtonChecked(hwnd, IDC_MAPI_NEW_SESSION))
	fl |= MAPI_NEW_SESSION;

    SetTimer(hwnd, 1, 500, NULL);
    if (IsDlgButtonChecked(hwnd, IDC_EXITPROC))
	SetTimer(hwnd, 2, 3000, NULL);

    mr.ulReserved = 0;
	mr.ulRecipClass = MAPI_TO;
	mr.ulEIDSize = rgMessage->lpRecips[0].ulEIDSize ;//0;
	mr.lpEntryID = rgMessage->lpRecips[0].lpEntryID ;//0;
    mr.lpszName = NULL;//"Senthil Kumar Natarajan";
	mr.lpszAddress = NULL;//"v-snatar@microsoft.com";

    mm.lpRecips = &mr; 
    mm.nRecipCount = 1;

    ulRet = (*g_pfnMAPISendMail)(lhSession, (ULONG)hwnd, &mm, fl, 0);

    KillTimer(hwnd, 1);
    KillTimer(hwnd, 2);

    wsprintf(szBuf, "MAPISendMail() returned %lu.", ulRet);
    MessageBox(hwnd, szBuf, "MAPITest", MB_OK);

    // Just to test lpEntryID - Begin

    ulRet = (*g_pfnMAPIFreeBuffer)(rgMessage);
    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFreeBuffer  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    // Just to test lpentryID - End
}

void SendDocuments(HWND hwnd)
{
    ULONG           ulRet;
    FLAGS           fl = 0;
    MapiMessage     mm;
    MapiRecipDesc   mr;
    LHANDLE         lhSession = 0;
    TCHAR           szBuf[MAX_PATH];

    if (!g_pfnMAPISendDocuments)
	{
	MessageBox(hwnd, "Need to load MAPI first.", "MAPITest", MB_OK|MB_ICONEXCLAMATION);
	return;
	}

    //ulRet = (*g_pfnMAPISendDocuments)((ULONG)hwnd,";","c:\\nt\\drop\\debug\\wab.exe","Junk Fellows",0);

    ulRet = (*g_pfnMAPISendDocuments)((ULONG)hwnd,";","c:\\nt\\drop\\debug\\wab.exe;c:\\nt\\drop\\debug\\wab.exe;c:\\dos\\append.exe;c:\\Program files\\common files\\mscreate.dir",NULL,0);

    wsprintf(szBuf, "MAPISendDocuments() returned %lu.", ulRet);
    MessageBox(hwnd, szBuf, "MAPITest", MB_OK);
}

void Address(HWND hwnd)
{
	ULONG err,ulret;
	MapiRecipDesc recips[4],temprecips[4],     // this message needs two recipients.
				 *tempRecip[3] ;//,*finalRecip[3];  // for use by MAPIResolveName and MAPIAddress
	 
	lpMapiRecipDesc finalRecip;
	//MapiRecipDesc *finalRecip ;

    TCHAR           szBuf[MAX_PATH];
	MapiMessage             note ;
	FLAGS                   fl=0 ;
	ULONG                   ulOut ;
	

	// create the same file attachment as in the previous example.
	MapiFileDesc attachment = {0,         // ulReserved, must be 0
							   0,         // no flags; this is a data file
							   (ULONG)-1, // position not specified
							   "c:\\dos\\append.exe",  // pathname
							   "append",      // original filename
							   NULL};               // MapiFileTagExt unused
	

    /*
    
	// get Senthil Kumar Natarajan as the MAPI_TO recipient:
	err = (*g_pfnMAPIResolveName)(0L,            // implicit session
								  0L,            // no UI handle
								  "Senthil Kumar Natarajan", // friendly name
								  0L,            // no flags, no UI allowed
								  0L,            // reserved; must be 0
								  &tempRecip[0]);// where to put the result
	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[0].ulReserved   = tempRecip[0]->ulReserved;
		recips[0].ulRecipClass = MAPI_TO;
		recips[0].lpszName     = tempRecip[0]->lpszName;
		recips[0].lpszAddress  = tempRecip[0]->lpszAddress;
		recips[0].ulEIDSize    = tempRecip[0]->ulEIDSize;
		recips[0].lpEntryID    = tempRecip[0]->lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Senthil Kumar Natarajan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

	


	// get the Marketing alias as the MAPI_CC recipient:
	err = (*g_pfnMAPIResolveName)(0L,                                       // implicit session
								 0L,                                    // no UI handle
								 "Shyam Sundar Rajagopalan",   // friendly name
								 0L,                                    // no flags, no UI allowed
								 0L,                                    // reserved; must be 0
								 &tempRecip[1]);                // where to put the result

	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[1].ulReserved   = tempRecip[1]->ulReserved;
		recips[1].ulRecipClass = MAPI_CC;
		recips[1].lpszName     = tempRecip[1]->lpszName;
		recips[1].lpszAddress  = tempRecip[1]->lpszAddress;
		recips[1].ulEIDSize    = tempRecip[1]->ulEIDSize;
		recips[1].lpEntryID    = tempRecip[1]->lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Shyam Sundar Rajagopalan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

		// get Senthil Kumar Natarajan as the MAPI_TO recipient:
	err = (*g_pfnMAPIResolveName)(0L,            // implicit session
								  0L,            // no UI handle
								  "Venkatesh Sundaresan", // friendly name
								  0L,            // no flags, no UI allowed
								  0L,            // reserved; must be 0
								  &tempRecip[2]);// where to put the result
	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[2].ulReserved   = tempRecip[2]->ulReserved;
		recips[2].ulRecipClass = MAPI_BCC;
		recips[2].lpszName     = tempRecip[2]->lpszName;
		recips[2].lpszAddress  = tempRecip[2]->lpszAddress;
		recips[2].ulEIDSize    = tempRecip[2]->ulEIDSize;
		recips[2].lpEntryID    = tempRecip[2]->lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Venkatesh Sundaresan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
	
    
	  
	if (IsDlgButtonChecked(hwnd, IDC_MAPI_LOGON_UI))
		fl |= MAPI_LOGON_UI;
    if (IsDlgButtonChecked(hwnd, IDC_MAPI_NEW_SESSION))
	fl |= MAPI_NEW_SESSION;
	*/
    
    recips[0].lpszName = "Sone Sone" ;    
    recips[0].lpszAddress ="sone@sone.com";
    recips[0].ulRecipClass=MAPI_BCC;
    recips[0].ulEIDSize=0;

    recips[1].lpszName = "Zebra" ;    
    recips[1].lpszAddress ="zebra@zebra.com";
    recips[1].ulRecipClass=MAPI_TO;
    recips[1].ulEIDSize=0;

    recips[2].lpszName = "Sone Sone" ;    
    recips[2].lpszAddress ="sone@sone.com";
    recips[2].ulRecipClass=MAPI_CC;
    recips[2].ulEIDSize=0;


    recips[3].lpszName = "yahoooo" ;
    recips[3].lpszAddress ="yahoo@everywhere.com";
    recips[3].ulRecipClass=MAPI_TO;
    recips[3].ulEIDSize=0;
   

    
	//ulret = (*g_pfnMAPIAddress)(0L,(ULONG)hwnd,"My Address Book",2,"",3,recips,fl,0,&ulOut,&finalRecip);
	ulret = (*g_pfnMAPIAddress)(0L,(ULONG)hwnd,"My Address Book",3,"Hello",4,recips,fl,0,&ulOut,&finalRecip);

	if (ulret != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIAddress Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

	if (0)
	{       
		note.ulReserved=0;
		note.lpszSubject= "Budget Proposal";
		note.lpszNoteText="Here is my budget proposal.\r\n";
		note.lpszMessageType= NULL ;
		note.lpszDateReceived= NULL;
		note.lpszConversationID= NULL;
		note.flFlags=0;
		note.lpOriginator= NULL;
		note.nRecipCount=2;
		note.lpRecips=recips;
		note.nFileCount=1;
		note.lpFiles=&attachment;

		if (IsDlgButtonChecked(hwnd, IDC_MAPI_DIALOG))
			fl |= MAPI_DIALOG;
		if (IsDlgButtonChecked(hwnd, IDC_MAPI_LOGON_UI))
			fl |= MAPI_LOGON_UI;
		if (IsDlgButtonChecked(hwnd, IDC_MAPI_NEW_SESSION))
			fl |= MAPI_NEW_SESSION;

		err = (*g_pfnMAPISendMail) (0L,    // use implicit session.
									0L,    // ulUIParam; 0 is always valid
									&note,  //&note, // the message being sent
									fl,    // do not allow the user to edit the message
									0L);   // reserved; must be 0
		if (err != SUCCESS_SUCCESS )
		{
			wsprintf(szBuf, "SendMail Failed");
			MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
		}
	}

    err = (*g_pfnMAPIFreeBuffer)((LPVOID)&(*finalRecip)); 

    if (err != SUCCESS_SUCCESS)
    { 
	wsprintf(szBuf,"MAPIFreeBuffer failed");
	MessageBox(hwnd,szBuf,"MAPITest",MB_OK);
    }
  }
    


void ResolveName(HWND hwnd)
{
	ULONG err,ulret;
	MapiRecipDesc recips[3];//,temprecips[1],     // this message needs two recipients.
	 
	lpMapiRecipDesc finalRecip;

    TCHAR           szBuf[MAX_PATH];
	MapiMessage             note ;
	FLAGS                   fl=0 ;
	ULONG                   ulOut ;

	// create the same file attachment as in the previous example.
	MapiFileDesc attachment = {0,         // ulReserved, must be 0
							   0,         // no flags; this is a data file
							   (ULONG)-1, // position not specified
							   "c:\\dos\\append.exe",  // pathname
							   "append",      // original filename
							   NULL};               // MapiFileTagExt unused
	

	if (IsDlgButtonChecked(hwnd, IDC_MAPI_DIALOG))
		fl |= MAPI_DIALOG;
	
	// get Senthil Kumar Natarajan as the MAPI_TO recipient:
	err = (*g_pfnMAPIResolveName)(0L,            // implicit session
								  (ULONG)hwnd,
								  "Senthil Kumar Natarajan", // friendly name
								  fl,
								  0L,            // reserved; must be 0
								  &finalRecip);// where to put the result
	if(err == SUCCESS_SUCCESS)
	{ // memberwise copy the appropriate fields in the returned
	  // recipient descriptor.
		recips[0].ulReserved   = (*finalRecip).ulReserved;
		recips[0].ulRecipClass = MAPI_TO;
		recips[0].lpszName     = (*finalRecip).lpszName;
		recips[0].lpszAddress  = (*finalRecip).lpszAddress;
		recips[0].ulEIDSize    = (*finalRecip).ulEIDSize;
		recips[0].lpEntryID    = (*finalRecip).lpEntryID;
	}
	else
	{
	    wsprintf(szBuf, "Error: Senthil Kumar Natarajan didn't resolve to a single address");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    err = (*g_pfnMAPIFreeBuffer)((LPVOID)&(*finalRecip)); 

    if (err != SUCCESS_SUCCESS)
    { 
	wsprintf(szBuf,"MAPIFreeBuffer failed");
	MessageBox(hwnd,szBuf,"MAPITest",MB_OK);
    }
}

void Details(HWND hwnd)
{
	ULONG err,ulret;
	MapiRecipDesc recips[3];         
	lpMapiRecipDesc finalRecip;

    TCHAR           szBuf[MAX_PATH];
	MapiMessage             note ;
	FLAGS                   fl=0 ;
	ULONG                   ulOut ;
    
    ulret = (*g_pfnMAPIAddress)(0L,(ULONG)hwnd,"My Address Book",2,"",0,NULL,fl,0,&ulOut,&finalRecip);
    
    if (ulret != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    


    if (IsDlgButtonChecked(hwnd, IDC_MAPI_AB_NOMODIFY))
	    fl |= MAPI_AB_NOMODIFY;

    recips[0].lpszName = "Sone Sone" ;    
    recips[0].lpszAddress ="SMTP:sone@sone.com";
    recips[0].ulRecipClass=MAPI_BCC;
    recips[0].ulEIDSize=0;

	ulret = (*g_pfnMAPIDetails)(0L,(ULONG)hwnd,&finalRecip[0],fl,0);

	if (ulret != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    err = (*g_pfnMAPIFreeBuffer)((LPVOID)&(*finalRecip)); 

    if (err != SUCCESS_SUCCESS)
    { 
	wsprintf(szBuf,"MAPIFreeBuffer failed");
	MessageBox(hwnd,szBuf,"MAPITest",MB_OK);
    }
}

void FindNext(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513]="10";
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    int                     i;
    LPSTR                   pszTemp=NULL;

    
   
    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchSeedMsgID);


    for (i=1;i<=10;i++)
    {  
        ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,rgchSeedMsgID,MAPI_LONG_MSGID,0,rgchMsgID);
        lstrcpy(rgchSeedMsgID,rgchMsgID);
    }


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDetails  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    

   


}

void ReadMail(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513]="1";
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    lpMapiMessage           rgMessage;


    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    
   
    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    /*
    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    */
    



    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}


    MessageBox(NULL,rgMessage->lpszNoteText,"Text",MB_OK);

    ulRet = (*g_pfnMAPIFreeBuffer)(rgMessage);
    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFreeBuffer  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

}

void SaveMail(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513];
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    MapiMessage             rgMessage;//=new MapiMessage;
    MapiMessage             mm;
    MapiRecipDesc           mr;


    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    
    ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
    

    mm.ulReserved           = 0;
    mm.lpszSubject          = "MAPISendMail Subject";
    mm.lpszNoteText         = "MAPISendMail Body\r\nLine 2";
    mm.lpszMessageType      = NULL;
    mm.lpszDateReceived     = NULL;
    mm.lpszConversationID   = NULL;
    mm.flFlags              = 0;
    mm.lpOriginator         = NULL;
    mm.nFileCount           = 0;
    mm.lpFiles              = NULL;
    mm.nRecipCount          = 1;

    mr.ulReserved = 0;
	mr.ulRecipClass = MAPI_TO;
	mr.ulEIDSize = 0;
	mr.lpEntryID = 0;
    mr.lpszName = "Senthil Kumar Natarajan";
	mr.lpszAddress = "v-snatar@microsoft.com";

    mm.nRecipCount = 1;
	mm.lpRecips = &mr;      


    //rgchMsgID[0]='0';

    ulRet = (*g_pfnMAPISaveMail)(lhSession,(ULONG)hwnd,&mm,0,0,rgchMsgID);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
}

void DeleteMail(HWND hwnd)
{
    ULONG                   ulRet;
    char                    rgchSeedMsgID[513];
    TCHAR                   szBuf[MAX_PATH];
    LHANDLE                 lhSession=0;
    char                    rgchMsgID[513];
    lpMapiMessage           rgMessage;


    ulRet=(g_pfnMAPILogon)((ULONG)hwnd,"Microsoft Outlook",0,0,0,&lhSession);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogon  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}    

    
     ulRet = (*g_pfnMAPIFindNext)(lhSession,(ULONG)hwnd,NULL,NULL,MAPI_LONG_MSGID,0,rgchMsgID);       


    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIFindNext  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    ulRet = (*g_pfnMAPIReadMail)(lhSession,(ULONG)hwnd,rgchMsgID,MAPI_SUPPRESS_ATTACH|MAPI_PEEK,0,&rgMessage);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIReadMail  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}

    MessageBox(NULL,rgMessage->lpszNoteText,"Text",MB_OK);


    ulRet = (*g_pfnMAPIDeleteMail)(lhSession,(ULONG)hwnd,rgchMsgID,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPIDelete  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}



    ulRet=(*g_pfnMAPILogoff)(lhSession,(ULONG)hwnd,0,0);

    if (ulRet != SUCCESS_SUCCESS )
	{
		wsprintf(szBuf, "MAPILogoff  Failed");
		MessageBox(hwnd, szBuf, "MAPITest", MB_OK);     
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\resource.h ===
#define IDD_SENDMAIL                    101
#define IDC_MAPI_DIALOG                 1000
#define IDC_MAPI_LOGON_UI               1001
#define IDC_MAPI_NEW_SESSION            1002
#define IDC_RECIP_NONE                  1006
#define IDC_RECIP_RESOLVED              1007
#define IDC_RECIP_AMBIG                 1008
#define IDC_DLLPATH                     1009
#define IDC_LOADDLL                     1010
#define IDC_EXITPROC                    1011
#define IDC_MAPILOGOFF                  1012
#define IDC_WAITRETURN                  1013
#define IDC_SEND                        1014
#define IDC_SENDDOC						1015
#define IDC_MAPIADDRESS					1016
#define IDC_MAPIRESOLVENAME				1017
#define IDC_MAPIDETAILS					1018
#define IDC_MAPI_AB_NOMODIFY			1019
#define IDC_DLLCOMBO                    1020
#define IDC_FINDNEXT                    1021
#define IDC_READMAIL                    1022
#define IDC_SAVEMAIL                    1023
#define IDC_DELETEMAIL                  1024
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mapitest.rc
//
#define IDC_SENDDOC                     1015
#define IDC_MAPIADDRESS                 1016
#define IDC_SAVEMAIL                    1021
#define IDC_DELETEMAIL                  1022
#define IDC_READMAIL                    1023
#define IDC_FINDNEXT                    1024

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\pdkver.h ===
#define rmj     4
#define rmm     934
#define rup     0
#define szVerName   ""
#define szVerUser   "TDSRC"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\client.c ===
/*
 -  C L I E N T . C
 -
 *  Purpose:
 *      Sample mail client for the MAPI 1.0 PDK.
 *              Exclusively uses the Simple MAPI interface.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>
#include <mapiwin.h>
#include <mapidbg.h>
#include "client.h"
#include "bitmap.h"
#include "pvalloc.h"

HANDLE hInst;
HINSTANCE hlibMAPI = 0;

LPMAPILOGON lpfnMAPILogon = NULL;
LPMAPILOGOFF lpfnMAPILogoff = NULL;
LPMAPISENDMAIL lpfnMAPISendMail = NULL;
LPMAPISENDDOCUMENTS lpfnMAPISendDocuments = NULL;
LPMAPIFINDNEXT lpfnMAPIFindNext = NULL;
LPMAPIREADMAIL lpfnMAPIReadMail = NULL;
LPMAPISAVEMAIL lpfnMAPISaveMail = NULL;
LPMAPIDELETEMAIL lpfnMAPIDeleteMail = NULL;
LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL;
LPMAPIADDRESS lpfnMAPIAddress = NULL;
LPMAPIDETAILS lpfnMAPIDetails = NULL;
LPMAPIRESOLVENAME lpfnMAPIResolveName = NULL;

/* Static Data */

static BOOL fDialogIsActive = FALSE;
static DWORD cUsers = 0;
static ULONG flSendMsgFlags = 0;
static LHANDLE lhSession = 0L;
static HBITMAP hReadBmp = 0;
static HBITMAP hReadABmp = 0;
static HBITMAP hUnReadBmp = 0;
static HBITMAP hUnReadABmp = 0;
static HCURSOR hWaitCur;
static LPMSGID lpReadMsgNode;
static lpMapiMessage lpmsg = NULL;

#ifdef _WIN32
#define szMAPIDLL       "MAPI32.DLL"
#else
#define szMAPIDLL       "MAPI.DLL"
#endif

int WINAPI
WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpszCmd, int nCmdShow)
{
    MSG msg;

    if (!hPrevInst)
    if (!InitApplication (hInstance))
        return (FALSE);

    if (!InitInstance (hInstance, nCmdShow))
    return (FALSE);

    while (GetMessage (&msg, 0, 0, 0))
    {
    TranslateMessage (&msg);
    DispatchMessage (&msg);
    }

    DeinitApplication ();

    return (msg.wParam);
}

/*
 -  InitApplication
 -
 *  Purpose:
 *      Initialize the application.
 *
 *  Parameters:
 *      hInstance   - Instance handle
 *
 *  Returns:
 *      True/False
 *
 */

BOOL
InitApplication (HANDLE hInstance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon (hInstance, "NoMail");
    wc.hCursor = LoadCursor (0, IDC_ARROW);
    wc.hbrBackground = GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName = "MailMenu";
    wc.lpszClassName = "Client";

    return (RegisterClass (&wc));
}

/*
 -  InitInstance
 -
 *  Purpose:
 *      Initialize this instance.
 *
 *  Parameters:
 *      hInstance   - Instance handle
 *      nCmdShow    - Do we show the window?
 *
 *  Returns:
 *      True/False
 *
 */

BOOL
InitInstance (HANDLE hInstance, int nCmdShow)
{
    HWND hWnd;
    BOOL fInit;
    ULONG ulResult;

    hInst = hInstance;

    hWnd = CreateWindow ("Client", "MAPI Sample Mail Client",
        WS_OVERLAPPEDWINDOW, 5, 5, 300, 75, 0, 0, hInst, NULL);

    if (!hWnd)
    return (FALSE);

    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);

    hWaitCur = LoadCursor(0, IDC_WAIT);

    if (fInit = InitSimpleMAPI ())
    {
    
        /* MAPILogon might yield control to Windows. So to prevent the user
        from clicking "logon" while we are in the process of loggin on we
        have to disable it*/
        SecureMenu(hWnd, TRUE);
        
        if ((ulResult = MAPILogon ((ULONG) hWnd, NULL, NULL,
            MAPI_LOGON_UI | MAPI_NEW_SESSION,
            0, &lhSession)) == SUCCESS_SUCCESS)
        {
            ToggleMenuState (hWnd, TRUE);
        }
        else
        {
            SecureMenu(hWnd, FALSE);
            lhSession = 0;
            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR);
        }
    }

    return (fInit);
}

/*
 -  InitSimpleMAPI
 -
 *  Purpose:
 *      Loads the DLL containing the simple MAPI functions and sets
 *      up a pointer to each. Wrappers for the  function pointers
 *      are declared in SMAPI.H.
 *
 *  Returns:
 *      TRUE if sucessful, else FALSE
 *
 *  Side effects:
 *      Loads a DLL and sets up function pointers
 */
BOOL
InitSimpleMAPI (void)
{
    UINT fuError;

    /*
     *Check if MAPI is installed on the system
     */
    if(!fSMAPIInstalled())
        return FALSE;

    fuError = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hlibMAPI = LoadLibrary(szMAPIDLL);
    SetErrorMode(fuError);

#ifdef _WIN32
    if (!hlibMAPI)
#else
    if (hlibMAPI < 32)
#endif
    return (FALSE);

    if (!(lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hlibMAPI, "MAPILogon")))
    return (FALSE);
    if (!(lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress (hlibMAPI, "MAPILogoff")))
    return (FALSE);
    if (!(lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hlibMAPI, "MAPISendMail")))
    return (FALSE);
    if (!(lpfnMAPISendDocuments = (LPMAPISENDDOCUMENTS) GetProcAddress (hlibMAPI, "MAPISendDocuments")))
    return (FALSE);
    if (!(lpfnMAPIFindNext = (LPMAPIFINDNEXT) GetProcAddress (hlibMAPI, "MAPIFindNext")))
    return (FALSE);
    if (!(lpfnMAPIReadMail = (LPMAPIREADMAIL) GetProcAddress (hlibMAPI, "MAPIReadMail")))
    return (FALSE);
    if (!(lpfnMAPISaveMail = (LPMAPISAVEMAIL) GetProcAddress (hlibMAPI, "MAPISaveMail")))
    return (FALSE);
    if (!(lpfnMAPIDeleteMail = (LPMAPIDELETEMAIL) GetProcAddress (hlibMAPI, "MAPIDeleteMail")))
    return (FALSE);
    if (!(lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress (hlibMAPI, "MAPIFreeBuffer")))
    return (FALSE);
    if (!(lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress (hlibMAPI, "MAPIAddress")))
    return (FALSE);
    if (!(lpfnMAPIDetails = (LPMAPIDETAILS) GetProcAddress (hlibMAPI, "MAPIDetails")))
    return (FALSE);
    if (!(lpfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress (hlibMAPI, "MAPIResolveName")))
    return (FALSE);

    return (TRUE);
}

/*
 -  fSMAPIInstalled
 -
 *  Purpose:
 *      Checks the appropriate win.ini/registry value to see if Simple MAPI is
 *      installed in the system. 
 *  
 *  Returns:
 *      TRUE if Simple MAPI is installed, else FALSE
 *
 */
BOOL
fSMAPIInstalled(void)
{
#ifdef _WIN32
    /* on win32, if it's NT 3.51 or lower the value to check is 
        win.ini \ [Mail] \ MAPI, otherwise it's a registry value
        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Messaging Subsystem\MAPI
    */
    
    OSVERSIONINFO osvinfo;
    LONG lr;
    HKEY hkWMS;
    
    #define MAPIVSize 8
    char szMAPIValue[MAPIVSize];
    DWORD dwType;
    DWORD cbMAPIValue = MAPIVSize;

    osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&osvinfo))
        return FALSE;

    if( osvinfo.dwMajorVersion > 3 ||
        (osvinfo.dwMajorVersion == 3 && osvinfo.dwMinorVersion > 51))
    { //check the registry value
        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\Windows Messaging Subsystem",
                         0, KEY_READ, &hkWMS);
        if(ERROR_SUCCESS == lr)
        {
            lr = RegQueryValueEx(hkWMS, "MAPI", 0, &dwType, szMAPIValue, &cbMAPIValue);
            RegCloseKey(hkWMS);
            if(ERROR_SUCCESS == lr)
            {
                Assert(dwType == REG_SZ);
                if(lstrcmp(szMAPIValue, "1") == 0)
                    return TRUE;
            }
        }
        
        return FALSE;
    }

    /* fall through*/
#endif /*_WIN32*/
    
    /*check the win.ini value*/
    return GetProfileInt("Mail", "MAPI", 0);
    
}


void
DeinitApplication ()
{
    DeinitSimpleMAPI ();
}

void
DeinitSimpleMAPI ()
{
    if (hlibMAPI)
    {
    FreeLibrary (hlibMAPI);
    hlibMAPI = 0;
    }
}

/*
 -  MainWndProc
 -
 *  Purpose:
 *      Main Window Procedure for test program.
 *
 *  Parameters:
 *      hWnd
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *
 *
 */

LONG FAR PASCAL
MainWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ULONG ulResult;

    switch (msg)
    {
    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDM_LOGON:
        if (!lhSession)
        {
        /* MAPILogon might yield control to Windows. So to prevent the user
        from clicking "logon" while we are in the process of loggin on we
        have to disable it*/
        SecureMenu(hWnd, TRUE);

        if ((ulResult = MAPILogon ((ULONG) hWnd, NULL, NULL,
                MAPI_LOGON_UI | MAPI_NEW_SESSION,
                0, &lhSession)) == SUCCESS_SUCCESS)
        {
            ToggleMenuState (hWnd, TRUE);
        }
        else
        {
            SecureMenu(hWnd, FALSE);
            lhSession = 0;
            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR);
        }
        }
        break;

    case IDM_LOGOFF:
        if (lhSession)
        {
        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0);
        ToggleMenuState (hWnd, FALSE);
        lhSession = 0;
        }
        break;

    case IDM_COMPOSE:
            fDialogIsActive = TRUE; 
        DialogBox (hInst, "ComposeNote", hWnd, ComposeDlgProc);
            fDialogIsActive = FALSE;        
        break;

    case IDM_READ:
            fDialogIsActive = TRUE; 
        DialogBox (hInst, "InBox", hWnd, InBoxDlgProc);
            fDialogIsActive = FALSE;        
        break;

    case IDM_SEND:
        if(lhSession)
            {
                MapiMessage msgSend;

                memset(&msgSend, 0, sizeof(MapiMessage));
                fDialogIsActive = TRUE; 
                MAPISendMail(lhSession, (ULONG)hWnd, &msgSend, MAPI_DIALOG, 0L);
                fDialogIsActive = FALSE;        
            }
        break;

    case IDM_ADDRBOOK:
        if (lhSession)
        {
                fDialogIsActive = TRUE; 
        if ((ulResult = MAPIAddress (lhSession, (ULONG) hWnd,
                NULL, 0, NULL, 0, NULL, 0, 0, NULL, NULL)))
        {
            if (ulResult != MAPI_E_USER_ABORT)
            MakeMessageBox (hWnd, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR);
        }
                fDialogIsActive = FALSE;        
        }
        break;

    case IDM_DETAILS:
        if (lhSession)
            {
                fDialogIsActive = TRUE; 
        DialogBox(hInst, "Details", hWnd, DetailsDlgProc);
                fDialogIsActive = FALSE;        
            }
        break;

    case IDM_ABOUT:
            fDialogIsActive = TRUE; 
        DialogBox (hInst, "AboutBox", hWnd, AboutDlgProc);
            fDialogIsActive = FALSE;        
        break;

    case IDM_EXIT:
        if (lhSession)
        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0);

        PostQuitMessage (0);
        break;

    default:
        return (DefWindowProc (hWnd, msg, wParam, lParam));
    }
    break;

    case WM_QUERYENDSESSION:
    {       

        /*
         *      If we have a modal dialog open (all our dialogs are modal, so
         *      just see if we have a dialog open), veto the shutdown.
         */

        if (fDialogIsActive)
        {
            LPCSTR szTitle = "MAPI Sample Mail Client"; 
            char szText[256]; 

        LoadString (hInst, IDS_DIALOGACTIVE, szText, 255);

        #ifdef WIN16
            MessageBox((HWND)NULL, szText, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        #else
            MessageBoxA(NULL, szText, szTitle, MB_OK | MB_ICONSTOP | MB_TASKMODAL | MB_SETFOREGROUND);
        #endif
        return FALSE;
        }

        else
        {
        return TRUE;
        }
    }

    case WM_ENDSESSION:

        if (wParam)
        {
        DestroyWindow (hWnd);
        }

    break;

    case WM_CLOSE:
    case WM_DESTROY:
    if (lhSession)
        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0);

    PostQuitMessage (0);
    break;

    default:
    return (DefWindowProc (hWnd, msg, wParam, lParam));
    }
    return FALSE;
}

/*
 -  AboutDlgProc
 -
 *  Purpose:
 *      About box dialog procedure
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
AboutDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{

#include <pdkver.h>

    char    rgchVersion[80];

    switch (msg)
    {
    case WM_INITDIALOG:
        wsprintf(rgchVersion, "Version %d.%d.%d (%s)", rmj, rmm, rup,
            szVerName && *szVerName ? szVerName : "BUDDY");
        SetDlgItemText(hDlg, IDC_VERSION, rgchVersion);
    return TRUE;

    case WM_COMMAND:
    if (wParam == IDOK || wParam == IDCANCEL)
    {
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  OptionsDlgProc
 -
 *  Purpose:
 *      Message Options dialog procedure
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
OptionsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
    CheckDlgButton (hDlg, IDC_RETURN,
        !!(flSendMsgFlags & MAPI_RECEIPT_REQUESTED));
    return TRUE;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDOK:
        if (IsDlgButtonChecked (hDlg, IDC_RETURN))
        flSendMsgFlags |= MAPI_RECEIPT_REQUESTED;
        else
        flSendMsgFlags &= ~MAPI_RECEIPT_REQUESTED;

    case IDCANCEL:
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  DetailsDlgProc
 -
 *  Purpose:
 *      User Details dialog procedure
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
DetailsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    LPSTR lpszType = NULL;
    LPSTR lpszAddr = NULL;
    LPSTR lpszName;
    ULONG cRecips;
    ULONG ulResult;
    lpMapiRecipDesc lpRecip = NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
    while(!lpRecip)
    {
        if ((ulResult = MAPIAddress (lhSession, (ULONG) hDlg,
            "Select One User", 1, "User:", 0, NULL, 0, 0,
            &cRecips, &lpRecip)))
        {
        if (ulResult != MAPI_E_USER_ABORT)
            MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR);

        EndDialog (hDlg, TRUE);
        return TRUE;
        }

        if (cRecips == 0)
        {
        EndDialog (hDlg, TRUE);
        return TRUE;
        }

        if (cRecips > 1)
        {
        cRecips = 0;
        MAPIFreeBuffer (lpRecip);
        lpRecip = NULL;
        MakeMessageBox (hDlg, 0, IDS_DETAILS_TOO_MANY, MBS_OOPS);
        }
    }
    lpszName = lpRecip->lpszName;
    if(lpRecip->lpszAddress)
    {
        lpszType = strtok(lpRecip->lpszAddress, ":");
        lpszAddr = strtok(NULL, "\n");
    }

    SetDlgItemText(hDlg, IDC_NAME, lpszName);
    SetDlgItemText(hDlg, IDC_TYPE, (lpszType ? lpszType : "MSPEER"));
    SetDlgItemText(hDlg, IDC_ADDR, (lpszAddr ? lpszAddr : ""));

    MAPIFreeBuffer (lpRecip);
    return TRUE;

    case WM_COMMAND:
    if(LOWORD(wParam) == IDC_CLOSE || LOWORD(wParam) ==IDCANCEL)
    {
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  ComposeDlgProc
 -
 *  Purpose:
 *      Dialog procedure for the ComposeNote dialog.
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
ComposeDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    char szUnResNames[TO_EDIT_MAX];
    char szDisplayNames[TO_EDIT_MAX];
   /* char szAttach[FILE_ATTACH_MAX];*/
    BOOL fUnResTo, fUnResCc;
    LONG cb, cLines;
    ULONG ulResult;
    HCURSOR hOldCur;
    static LPSTR lpszSubject;
    static LPSTR lpszNoteText;
    static ULONG cRecips;
    static ULONG cNewRecips;
    static ULONG cAttach;
    static lpMapiRecipDesc lpRecips;
    static lpMapiRecipDesc lpNewRecips;
    static lpMapiFileDesc lpAttach;
    ULONG idx;

    switch (msg)
    {
    case WM_INITDIALOG:
    if (lpmsg)
    {
        /* ComposeNote is being called to either forward or reply */
        /* to a message in the Inbox.  So, we'll initialize the   */
        /* ComposeNote form with data from the global MapiMessage */

        lpszSubject = lpmsg->lpszSubject;
        lpszNoteText = lpmsg->lpszNoteText;
        cRecips = lpmsg->nRecipCount;
        cAttach = lpmsg->nFileCount;
        lpRecips = lpmsg->lpRecips;
        lpAttach = lpmsg->lpFiles;

        if (cRecips)
        {
        MakeDisplayNameStr (szDisplayNames, MAPI_TO,
            cRecips, lpRecips);
        if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_TO, szDisplayNames);

        MakeDisplayNameStr (szDisplayNames, MAPI_CC,
            cRecips, lpRecips);
        if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_CC, szDisplayNames);
        }
        SetDlgItemText (hDlg, IDC_SUBJECT, lpmsg->lpszSubject);
        SetDlgItemText (hDlg, IDC_NOTE, lpmsg->lpszNoteText);
        if (!cAttach)
        {
            EnableWindow (GetDlgItem (hDlg, IDC_CATTACHMENT), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDT_CATTACHMENT), FALSE);
        }
        else
        {
            for(idx = 0; idx < cAttach; idx++)
            if (lpAttach[idx].lpszFileName)
                SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_ADDSTRING, 0,
                (LPARAM)lpAttach[idx].lpszFileName);

           /*SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_SETCURSEL, 0, 0L);*/
        }

        SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);
        SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);
        SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_SETMODIFY, FALSE, 0);
        SendDlgItemMessage (hDlg, IDC_NOTE, EM_SETMODIFY, FALSE, 0);
        if(cRecips)
        SetFocus (GetDlgItem (hDlg, IDC_NOTE));
        else
        SetFocus (GetDlgItem (hDlg, IDC_TO));
    }
    else
    {
        lpmsg = (lpMapiMessage)PvAlloc(sizeof(MapiMessage));

        if (!lpmsg)
        goto cleanup;

            memset (lpmsg, 0, sizeof (MapiMessage));

        lpszSubject = NULL;
        lpszNoteText = NULL;
        cRecips = 0;
        cAttach = 0;
        lpRecips = NULL;
        lpNewRecips = NULL;
        lpAttach = NULL;

        lpmsg->flFlags = flSendMsgFlags;
        SetFocus (GetDlgItem (hDlg, IDC_TO));
    }
    return FALSE;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDC_ATTACH:
        if (GetNextFile (hDlg, (ULONG) -1, &cAttach, &lpAttach) == SUCCESS_SUCCESS)
        {
                /* if the first attachment */
                if (cAttach == 1)
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_CATTACHMENT), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDT_CATTACHMENT), TRUE);
                }

                if (lpAttach[cAttach - 1].lpszFileName)
            SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_ADDSTRING, 0,
            (LPARAM)lpAttach[cAttach -1].lpszFileName);

             /* Now, send a little render message to the NoteText edit */

        /*wsprintf (szAttach, "<<File: %s>>",
            lpAttach[cAttach - 1].lpszFileName);

        SendDlgItemMessage (hDlg, IDC_NOTE, EM_REPLACESEL, 0,
            (LPARAM) ((LPSTR) szAttach));*/
        }
        break;

    case IDC_ADDRBOOK:
            SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_RESOLVE,0), 0);
        ulResult = MAPIAddress (lhSession, (ULONG) hDlg, NULL,
        2, NULL, cRecips, lpRecips, 0, 0,
        &cNewRecips, &lpNewRecips);
        if (ulResult)
        {
        if (ulResult != MAPI_E_USER_ABORT)
            MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR);
        }
        else
        {
        if (cNewRecips)
        {
            PvFree(lpRecips);
            lpRecips = (lpMapiRecipDesc)PvAlloc(cNewRecips*sizeof(MapiRecipDesc));
            cRecips = cNewRecips;

                    while(cNewRecips--)
                        CopyRecipient(lpRecips, &lpRecips[cNewRecips],
                                &lpNewRecips[cNewRecips]);

            MAPIFreeBuffer(lpNewRecips);
            lpNewRecips = NULL;
            cNewRecips = 0;

            MakeDisplayNameStr (szDisplayNames, MAPI_TO,
            cRecips, lpRecips);
            if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_TO, szDisplayNames);

            MakeDisplayNameStr (szDisplayNames, MAPI_CC,
            cRecips, lpRecips);
            if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_CC, szDisplayNames);

            SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);
            SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);
        }
        }
        break;

    case IDC_OPTIONS:
        DialogBox (hInst, "Options", hDlg, OptionsDlgProc);
        break;

    case IDC_SEND:
    case IDC_RESOLVE:
        fUnResTo = FALSE;
        fUnResCc = FALSE;

        hOldCur = SetCursor(hWaitCur);

        
        /* Get the names from the To: field and resolve them first */

        /*if (SendDlgItemMessage (hDlg, IDC_TO, EM_GETMODIFY, 0, 0) && */
         if (cb = SendDlgItemMessage (hDlg, IDC_TO, WM_GETTEXT,
            (WPARAM)sizeof(szUnResNames), (LPARAM)szUnResNames))
        {
        if (!ResolveFriendlyNames (hDlg, szUnResNames, MAPI_TO,
            &cRecips, &lpRecips))
        {
            MakeDisplayNameStr (szDisplayNames, MAPI_TO,
            cRecips, lpRecips);
            if (*szDisplayNames)
            {
            if (*szUnResNames)
            {
                lstrcat (szDisplayNames, "; ");
                lstrcat (szDisplayNames, szUnResNames);
                fUnResTo = TRUE;
            }

            SetDlgItemText (hDlg, IDC_TO, szDisplayNames);
            }
            else
            {
            if (*szUnResNames)
            {
                SetDlgItemText (hDlg, IDC_TO, szUnResNames);
                fUnResTo = TRUE;
            }
            }
        }
        /*SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);*/
        }

        /* Now, get the names from the Cc: field and resolve them */

        /*if (SendDlgItemMessage (hDlg, IDC_CC, EM_GETMODIFY, 0, 0) &&*/
        if (cb = SendDlgItemMessage (hDlg, IDC_CC, WM_GETTEXT,
            (WPARAM)sizeof(szUnResNames), (LPARAM)szUnResNames))
        {
        if (!ResolveFriendlyNames (hDlg, szUnResNames, MAPI_CC,
            &cRecips, &lpRecips))
        {
            MakeDisplayNameStr (szDisplayNames, MAPI_CC,
            cRecips, lpRecips);
            if (*szDisplayNames)
            {
            if (*szUnResNames)
            {
                lstrcat (szDisplayNames, "; ");
                lstrcat (szDisplayNames, szUnResNames);
                fUnResCc = TRUE;
            }

            SetDlgItemText (hDlg, IDC_CC, szDisplayNames);
            }
            else
            {
            if (*szUnResNames)
            {
                SetDlgItemText (hDlg, IDC_CC, szUnResNames);
                fUnResCc = TRUE;
            }
            }
        }
        /*SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);*/
        }

        /* If we were just Resolving Names then we can leave now */

        if (LOWORD (wParam) == IDC_RESOLVE)
        {
        SetCursor(hOldCur);
        break;
        }

        if (cRecips == 0 || fUnResTo || fUnResCc)
        {
        if (!cRecips)
            MakeMessageBox (hDlg, 0, IDS_NORECIPS, MBS_OOPS);

        if (fUnResTo)
            SetFocus (GetDlgItem (hDlg, IDC_TO));
        else if (fUnResCc)
            SetFocus (GetDlgItem (hDlg, IDC_CC));
        else
            SetFocus (GetDlgItem (hDlg, IDC_TO));

        SetCursor(hOldCur);
        break;
        }

        /* Everything is OK so far, lets get the Subject */
        /* and the NoteText and try to send the message. */

        /* Get Subject from Edit */

        if (SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_GETMODIFY, 0, 0))
        {
        cb = SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_LINELENGTH, 0, 0L);

        PvFree(lpszSubject);
        lpszSubject = (LPTSTR)PvAlloc(cb + 1);

        if (!lpszSubject)
            goto cleanup;

        GetDlgItemText (hDlg, IDC_SUBJECT, lpszSubject, (int)cb+1);
        }

        /* Get the NoteText from Edit */

        if (SendDlgItemMessage (hDlg, IDC_NOTE, EM_GETMODIFY, 0, 0))
        {
        cLines = SendDlgItemMessage (hDlg, IDC_NOTE,
            EM_GETLINECOUNT, 0, 0L);

        if (cLines)
        {
            /* Get the total number of bytes in the multi-line */

            cb = SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINEINDEX,
            (UINT)cLines - 1, 0L);
            cb += SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINELENGTH,
            (UINT)cb, 0L);

            /* The next line is to account for CR-LF pairs per line. */

            cb += cLines * 2;

                    PvFree(lpszNoteText);
            lpszNoteText = (LPTSTR)PvAlloc(cb + 1);

            if (!lpszNoteText)
            goto cleanup;

            /* Get the Note Text from the edit */

            GetDlgItemText (hDlg, IDC_NOTE, lpszNoteText, (int)cb);
        }
        else
        {
            /* Make an empty string for NoteText */

            lpszNoteText = (LPTSTR)PvAlloc(1);
            if (!lpszNoteText)
            goto cleanup;
            *lpszNoteText = '\0';
        }
        }

        lpmsg->lpszSubject = lpszSubject;
        lpmsg->lpszNoteText = lpszNoteText;
        lpmsg->nRecipCount = cRecips;
        lpmsg->lpRecips = lpRecips;
        lpmsg->nFileCount = cAttach;
        lpmsg->lpFiles = lpAttach;
        lpmsg->flFlags = flSendMsgFlags;

        ulResult = MAPISendMail (lhSession, (ULONG) hDlg, lpmsg, 0, 0);

        LogSendMail(ulResult);

        if (ulResult)
        {
        MakeMessageBox (hDlg, ulResult, IDS_SENDERROR, MBS_ERROR);
        SetCursor(hOldCur);
        break;
        }
cleanup:
        SetCursor(hOldCur);

    case IDCANCEL:
        PvFree(lpmsg->lpszMessageType);
        PvFree(lpmsg->lpszConversationID);
        PvFree(lpmsg);
        PvFree(lpRecips);
        PvFree(lpAttach);
        PvFree(lpszSubject);
        PvFree(lpszNoteText);
        lpmsg = NULL;

        EndDialog (hDlg, TRUE);
        return TRUE;
        break;

    default:
        break;
    }
    break;
    }
    return FALSE;
}

/*
 -  InBoxDlgProc
 -
 *  Purpose:
 *      Dialog procedure for the InBox dialog.
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
InBoxDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    char szMsgID[512];
    char szSeedMsgID[512];
    LPMSGID lpMsgNode;
    static LPMSGID lpMsgIdList = NULL;
    lpMapiMessage lpMessage;
    ULONG ulResult;
    DWORD nIndex;
    RECT Rect;
    HCURSOR hOldCur;

    switch (msg)
    {
    case WM_INITDIALOG:
    hOldCur = SetCursor(hWaitCur);

        InitBmps(hDlg, IDC_MSG);

    /* Populate List Box with all messages in InBox. */
    /* This is a painfully slow process for now.     */

    ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, NULL,
        MAPI_GUARANTEE_FIFO | MAPI_LONG_MSGID, 0, szMsgID);

    while (ulResult == SUCCESS_SUCCESS)
    {
        ulResult = MAPIReadMail (lhSession, (ULONG) hDlg, szMsgID,
        MAPI_PEEK | MAPI_ENVELOPE_ONLY,
        0, &lpMessage);

        if (!ulResult)
        {
        lpMsgNode = MakeMsgNode (lpMessage, szMsgID);

        if (lpMsgNode)
        {
            InsertMsgNode (lpMsgNode, &lpMsgIdList);

            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING,
            0, (LONG) lpMsgNode);
        }
        MAPIFreeBuffer (lpMessage);
        }

        lstrcpy (szSeedMsgID, szMsgID);
        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, szSeedMsgID,
        MAPI_GUARANTEE_FIFO | MAPI_LONG_MSGID, 0, szMsgID);
    }

    SetCursor(hOldCur);
    SetFocus (GetDlgItem (hDlg, IDC_MSG));
    return TRUE;
    break;

    case WM_SETFOCUS:
    SetFocus (GetDlgItem (hDlg, IDC_MSG));
    break;

    case WM_MEASUREITEM:
    /* Sets the height of the owner-drawn List-Box */
        MeasureItem(hDlg, (MEASUREITEMSTRUCT *)lParam);
    break;

    case WM_DRAWITEM:
    DrawItem((DRAWITEMSTRUCT *)lParam);
    break;

    case WM_DELETEITEM:
    /* This message is handled by the IDC_DELETE message */
    return TRUE;
    break;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDC_NEW:
        hOldCur = SetCursor(hWaitCur);

        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, NULL,
        MAPI_UNREAD_ONLY | MAPI_LONG_MSGID, 0, szMsgID);

        while (ulResult == SUCCESS_SUCCESS)
        {
        if (!FindNode (lpMsgIdList, szMsgID))
        {
            ulResult = MAPIReadMail (lhSession, (ULONG) hDlg, szMsgID,
            MAPI_PEEK | MAPI_ENVELOPE_ONLY, 0, &lpMessage);

            if (!ulResult)
            {
            lpMsgNode = MakeMsgNode (lpMessage, szMsgID);
            InsertMsgNode (lpMsgNode, &lpMsgIdList);

            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING,
                0, (LONG) lpMsgNode);

            MAPIFreeBuffer (lpMessage);
            }
        }

        lstrcpy (szSeedMsgID, szMsgID);
        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, szSeedMsgID,
            MAPI_UNREAD_ONLY | MAPI_LONG_MSGID, 0, szMsgID);
        }
        SetCursor(hOldCur);
        break;

    case IDC_MSG:
        if(HIWORD(wParam) != LBN_DBLCLK)
        break;

    case IDC_READ:
        nIndex = SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0);

        if (nIndex == LB_ERR)
        break;

        lpReadMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG,
        LB_GETITEMDATA, (UINT)nIndex, 0L);

        if (lpReadMsgNode)
        DialogBox (hInst, "ReadNote", hDlg, ReadMailDlgProc);

        /* Update the Messages List-Box with new icon */

        SendDlgItemMessage (hDlg, IDC_MSG, LB_GETITEMRECT, (UINT)nIndex, (LPARAM) &Rect);
        InvalidateRect(GetDlgItem(hDlg, IDC_MSG), &Rect, FALSE);
        break;

    case IDC_DELETE:
        nIndex = SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0);

        if (nIndex == LB_ERR)
        break;

        lpMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG,
        LB_GETITEMDATA, (UINT)nIndex, 0);

        if (lpMsgNode)
        {
        MAPIDeleteMail (lhSession, (ULONG) hDlg, lpMsgNode->lpszMsgID, 0, 0);
        DeleteMsgNode (lpMsgNode, &lpMsgIdList);
        }

        SendDlgItemMessage (hDlg, IDC_MSG, LB_DELETESTRING, (UINT)nIndex, 0);
        break;

    case IDC_CLOSE:
    case IDCANCEL:
        FreeMsgList (lpMsgIdList);
        lpMsgIdList = NULL;

            DeInitBmps();

        EndDialog (hDlg, TRUE);
        return TRUE;
        break;

    default:
        break;
    }
    break;
    }

    return FALSE;
}

/*
 -  ReadMailDlgProc
 -
 *  Purpose:
 *      Dialog procedure for the ReadMail dilaog.
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
ReadMailDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    ULONG ulResult;
    char szTo[TO_EDIT_MAX];
    char szCc[TO_EDIT_MAX];
    char szChangeMsg[512];
    ULONG idx;
    static lpMapiMessage lpReadMsg;

    switch (msg)
    {
    case WM_INITDIALOG:
    if (ulResult = MAPIReadMail (lhSession, (LONG) hDlg, lpReadMsgNode->lpszMsgID,
        0, 0, &lpReadMsg))
    {
        MakeMessageBox(hDlg, ulResult, IDS_READFAIL, MBS_ERROR);
        EndDialog (hDlg, TRUE);
        return TRUE;
    }

    lpReadMsgNode->fUnRead = FALSE;

    szTo[0] = '\0';
    szCc[0] = '\0';

    for (idx = 0; idx < lpReadMsg->nRecipCount; idx++)
    {
        if (lpReadMsg->lpRecips[idx].ulRecipClass == MAPI_TO)
        {
        lstrcat (szTo, lpReadMsg->lpRecips[idx].lpszName);
        lstrcat (szTo, "; ");
        }
        else if (lpReadMsg->lpRecips[idx].ulRecipClass == MAPI_CC)
        {
        lstrcat (szCc, lpReadMsg->lpRecips[idx].lpszName);
        lstrcat (szCc, "; ");
        }
        else
        {
        /* Must be Bcc, lets ignore it! */
        }
    }

    if(*szTo)
        szTo[lstrlen (szTo) - 2] = '\0';
    if(*szCc)
        szCc[lstrlen (szCc) - 2] = '\0';

    SetDlgItemText (hDlg, IDC_RFROM,
        (lpReadMsg->lpOriginator && lpReadMsg->lpOriginator->lpszName ?
                lpReadMsg->lpOriginator->lpszName : ""));
    SetDlgItemText (hDlg, IDC_RDATE,
        (lpReadMsg->lpszDateReceived ? lpReadMsg->lpszDateReceived : ""));
    SetDlgItemText (hDlg, IDC_RTO, szTo);
    SetDlgItemText (hDlg, IDC_RCC, szCc);
    SetDlgItemText (hDlg, IDC_RSUBJECT,
        (lpReadMsg->lpszSubject ? lpReadMsg->lpszSubject : ""));
    SetDlgItemText (hDlg, IDC_READNOTE,
        (lpReadMsg->lpszNoteText ? lpReadMsg->lpszNoteText : ""));

    if (!lpReadMsg->nFileCount)
    {
        EnableWindow (GetDlgItem (hDlg, IDC_SAVEATTACH), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_ATTACHMENT), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDT_ATTACHMENT), FALSE);
    }
    else
    {
        for(idx = 0; idx < lpReadMsg->nFileCount; idx++)
        if (lpReadMsg->lpFiles[idx].lpszFileName)
            SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_ADDSTRING, 0,
            (LPARAM)lpReadMsg->lpFiles[idx].lpszFileName);

        SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_SETCURSEL, 0, 0L);
    }

    SetFocus (GetDlgItem (hDlg, IDC_READNOTE));
    return FALSE;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDC_SAVECHANGES:
        if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0))
        ulResult = SaveMsgChanges (hDlg, lpReadMsg, lpReadMsgNode->lpszMsgID);
        SendDlgItemMessage (hDlg, IDC_READNOTE, EM_SETMODIFY, 0, 0);
        break;

    case IDC_ATTACHMENT:
        if(HIWORD(wParam) != LBN_DBLCLK)
        break;

    case IDC_SAVEATTACH:
        idx = SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_GETCURSEL, 0, 0L);

        if(idx != LB_ERR)
        {
        SaveFileAttachments(hDlg, &lpReadMsg->lpFiles[idx]);
        SetFocus(GetDlgItem (hDlg, IDC_ATTACHMENT));
        return FALSE;

        }
        break;

    case IDC_REPLY:
    case IDC_REPLYALL:
    case IDC_FORWARD:
        MakeNewMessage (lpReadMsg, LOWORD (wParam));
        DialogBox (hInst, "ComposeNote", hDlg, ComposeDlgProc);
        break;

    case IDCANCEL:
        if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0))
        {
        wsprintf (szChangeMsg, "Save changes to: '%s' in Inbox?",
            (lpReadMsg->lpszSubject ? lpReadMsg->lpszSubject : ""));

        if (MessageBox (hDlg, szChangeMsg, "Mail", MB_YESNO) == IDYES)
        {
            ulResult = SaveMsgChanges (hDlg, lpReadMsg, lpReadMsgNode->lpszMsgID);
        }
        }

        /* If there were file attachments, then delete the temps */

        for(idx = 0; idx < lpReadMsg->nFileCount; idx++)
        if (lpReadMsg->lpFiles[idx].lpszPathName)
            DeleteFile(lpReadMsg->lpFiles[idx].lpszPathName);

        MAPIFreeBuffer (lpReadMsg);
        lpReadMsg = NULL;
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  MakeMessageBox
 -
 *  Purpose:
 *      Gets resource string and displays an error message box.
 *
 *  Parameters:
 *      hWnd            - Handle to parent window
 *      idString        - Resource ID of message in StringTable
 *
 *  Returns:
 *      Void
 *
 */

void
MakeMessageBox (HWND hWnd, ULONG ulResult, UINT idString, UINT fStyle)
{
    char szMessage[256];
    char szMapiReturn[64];

    LoadString (hInst, idString, szMessage, 255);

    if (ulResult)
    {
    LoadString (hInst, (UINT)ulResult, szMapiReturn, 64);
    lstrcat (szMessage, "\nReturn Code: ");
    lstrcat (szMessage, szMapiReturn);
    }

    MessageBox (hWnd, szMessage, "Problem", fStyle);
}

/*
 -  ResolveFriendlyNames
 -
 *  Purpose:
 *      Helper function to convert a string of ';' delimited friendly
 *      names into an array of MapiRecipDescs.
 *
 *  Side Effects:                                             
 *      The display string passed in is modified to contain the
 *      friendly names of the mail users as found in the sample
 *      address book.
 *
 *  Note:
 *      Duplicate names in the address book will result in undefined
 *      behavior.
 *
 *  Parameters:
 *      hWnd                - Handle to parent window
 *      lpszDisplayNames    - string of ';' delimited user names
 *      ulRecipClass        - either MAPI_TO, MAPI_CC, or MAPI_BCC
 *      lpcRecips           - Address of recipient count to be returned
 *      lppRecips           - Address of recipient array to be returned
 *
 *  Return:
 *      ulResult
 */

ULONG
ResolveFriendlyNames (HWND hWnd, LPSTR lpszDisplayNames, ULONG ulRecipClass,
    ULONG * lpcRecips, lpMapiRecipDesc * lppRecips)
{
    char szResolve[TO_EDIT_MAX];
    LPSTR lpszNameToken;
    ULONG cRecips = 0;
    ULONG cFails = 0;
    ULONG ulResult;
    lpMapiRecipDesc lpRecip;
    lpMapiRecipDesc lpRecipList;

    *szResolve = '\0';
    lpszNameToken = strtok (lpszDisplayNames, ";\n");

    while (lpszNameToken)
    {
    /* Strip leading blanks from name */

    while (*lpszNameToken == ' ')
        lpszNameToken++;

    /* Check if name has already been resolved */

    if (!FNameInList (lpszNameToken, *lpcRecips, *lppRecips))
    {
        lstrcat (szResolve, lpszNameToken);
        lstrcat (szResolve, "; ");
        cRecips++;
    }

    /* Get Next Token */

    lpszNameToken = strtok (NULL, ";\n");
    }

    *lpszDisplayNames = '\0';

    if (!szResolve[0])
    {
    ulResult = SUCCESS_SUCCESS;
    goto err;
    }

    szResolve[lstrlen (szResolve) - 2] = '\0';

    lpRecipList = (lpMapiRecipDesc)PvAlloc((cRecips + *lpcRecips) * sizeof (MapiRecipDesc));

    if (!lpRecipList)
    {
    ulResult = MAPI_E_INSUFFICIENT_MEMORY;
    goto err;
    }
    memset (lpRecipList, 0, (size_t)(cRecips+*lpcRecips)*sizeof(MapiRecipDesc));

    cRecips = 0;

    while (cRecips < *lpcRecips)
    {
    ulResult = CopyRecipient (lpRecipList, &lpRecipList[cRecips],
        *lppRecips + cRecips);

    if (ulResult)
    {
        PvFree(lpRecipList);
        goto err;
    }

    cRecips++;
    }

    PvFree(*lppRecips);

    lpszNameToken = strtok (szResolve, ";\n");

    while (lpszNameToken)
    {
    /* Strip leading blanks (again) */

    while (*lpszNameToken == ' ')
        lpszNameToken++;

    ulResult = MAPIResolveName (lhSession, (ULONG) hWnd, lpszNameToken,
        MAPI_DIALOG, 0, &lpRecip);

    if (ulResult == SUCCESS_SUCCESS)
    {
        lpRecip->ulRecipClass = ulRecipClass;
        ulResult = CopyRecipient (lpRecipList, &lpRecipList[cRecips], lpRecip);

        MAPIFreeBuffer (lpRecip);

        if (ulResult)
        goto cleanup;

        cRecips++;
    }
    else
    {
        lstrcat (lpszDisplayNames, lpszNameToken);
        lstrcat (lpszDisplayNames, "; ");
        cFails++;
    }
    lpszNameToken = strtok (NULL, ";\n");
    }

    /* if cFails > 0 then we have partial success */

    ulResult = SUCCESS_SUCCESS;

    if (cFails)
    MakeMessageBox (hWnd, 0, IDS_UNRESOLVEDNAMES, MBS_INFO);

cleanup:
    *lpcRecips = cRecips;
    *lppRecips = lpRecipList;
err:
    if (*lpszDisplayNames)
    lpszDisplayNames[lstrlen (lpszDisplayNames) - 2] = '\0';

    return ulResult;
}

/*
 -  CopyRecipient
 -
 *  Purpose:
 *      Called in support of ResolveFriendlyNames() to build an array
 *      of chained MapiRecipDescs.
 *
 *  Parameters:
 *      lpParent        - Parent memory that allocations get chained to
 *      lpDest          - Destination Recipient
 *      lpSrc           - Source Recipient
 *
 *  Return:
 *      ulResult
 */

ULONG
CopyRecipient (lpMapiRecipDesc lpParent,
    lpMapiRecipDesc lpDest,
    lpMapiRecipDesc lpSrc)
{
    lpDest->ulReserved = lpSrc->ulReserved;
    lpDest->ulRecipClass = lpSrc->ulRecipClass;
    lpDest->ulEIDSize = lpSrc->ulEIDSize;

    if (lpSrc->lpszName)
    {
    lpDest->lpszName = (LPTSTR)PvAllocMore(lstrlen(lpSrc->lpszName) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszName)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszName, lpSrc->lpszName);
    }
    else
    lpDest->lpszName = NULL;

    if (lpSrc->lpszAddress)
    {
    lpDest->lpszAddress = (LPTSTR)PvAllocMore(lstrlen (lpSrc->lpszAddress) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszAddress)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszAddress, lpSrc->lpszAddress);
    }
    else
    lpDest->lpszAddress = NULL;

    if (lpSrc->lpEntryID)
    {
    lpDest->lpEntryID = (LPBYTE)PvAllocMore(lpSrc->ulEIDSize,
            (LPVOID)lpParent);

    if (!lpDest->lpEntryID)
        return MAPI_E_INSUFFICIENT_MEMORY;

        if (lpSrc->ulEIDSize)
            memcpy (lpDest->lpEntryID, lpSrc->lpEntryID, (size_t)lpSrc->ulEIDSize);
    }
    else
    lpDest->lpEntryID = NULL;

    return SUCCESS_SUCCESS;

}

/*
 -  GetNextFile
 -
 *  Purpose:
 *      Called when user clicks 'Attach' button in Compose Note form.
 *      We will build a chained memory chunk for mmore than one file
 *      attachment so the memory can be freed with a single call to
 *      PvFree.
 *
 *  Parameters:
 *      hWnd            - Window handle of Compose Note dialog
 *      nPos            - Render position of attachment in Notetext.
 *      lpcAttach       - Pointer to the count of attachments.
 *      lppAttach       - Pointer to the MapiFileDesc array.
 *
 *  Return:
 *      ulResult.
 */

ULONG
GetNextFile (HWND hWnd, ULONG nPos, ULONG * lpcAttach,
    lpMapiFileDesc * lppAttach)
{
    lpMapiFileDesc lpAttach;
    lpMapiFileDesc lpAttachT;
    OPENFILENAME ofn;
    char szFileName[256] = "";
    char szFilter[256];
    static char szFileTitle[16];
    static char szDirName[256] = "";
    LPSTR lpszEndPath;
    ULONG idx;
    ULONG ulResult = SUCCESS_SUCCESS;

    if (!szDirName[0])
    GetSystemDirectory ((LPSTR) szDirName, 255);
    else
    lstrcpy (szFileName, szFileTitle);

    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter));

    for (idx = 0; szFilter[idx] != '\0'; idx++)
    if (szFilter[idx] == '|')
        szFilter[idx] = '\0';

    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = 0;
    ofn.hInstance = 0;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 1L;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = 256;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = 16;
    ofn.lpstrInitialDir = szDirName;
    ofn.lpstrTitle = "Attach";
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    if (!GetOpenFileName (&ofn))
    return MAPI_USER_ABORT;

    /* Save the directory for the next time we call this */

    lstrcpy (szDirName, szFileName);
    if (lpszEndPath = strstr (szDirName, szFileTitle))
    *(--lpszEndPath) = '\0';

    lpAttach = (lpMapiFileDesc)PvAlloc(((*lpcAttach) + 1) * sizeof (MapiFileDesc));

    if(!lpAttach)
    goto err;

    memset (lpAttach, 0, (size_t)(*lpcAttach + 1) * sizeof (MapiFileDesc));

    lpAttachT = *lppAttach;

    for (idx = 0; idx < *lpcAttach; idx++)
    if(ulResult = CopyAttachment (lpAttach, &lpAttach[idx], &lpAttachT[idx]))
        goto err;

    lpAttach[idx].ulReserved = 0;
    lpAttach[idx].flFlags = 0;
    lpAttach[idx].nPosition = (ULONG)(-1);
    lpAttach[idx].lpFileType = NULL;

    lpAttach[idx].lpszPathName = (LPTSTR)PvAllocMore(lstrlen (szFileName) + 1,
        (LPVOID)lpAttach);

    if(!lpAttach[idx].lpszPathName)
    goto err;

    lpAttach[idx].lpszFileName = (LPTSTR)PvAllocMore(lstrlen (szFileTitle) + 1,
        (LPVOID)lpAttach);

    if(!lpAttach[idx].lpszFileName)
    goto err;

    lstrcpy (lpAttach[idx].lpszPathName, szFileName);
    lstrcpy (lpAttach[idx].lpszFileName, szFileTitle);

    PvFree(lpAttachT);

    *lppAttach = lpAttach;
    (*lpcAttach)++;

err:
    if(ulResult)
    PvFree(lpAttach);

    return ulResult;
}

/*
 -  CopyAttachment
 -
 *  Purpose:
 *      Called in support of GetNextFile() to re-build an array
 *      of chained MapiFileDescs.
 *
 *  Parameters:
 *      lpParent        - Parent memory that allocations get chained to
 *      lpDest          - Destination Recipient
 *      lpSrc           - Source Recipient
 *
 *  Return:
 *      Void.
 */

ULONG
CopyAttachment (lpMapiFileDesc lpParent,
    lpMapiFileDesc lpDest,
    lpMapiFileDesc lpSrc)
{
    lpDest->ulReserved = lpSrc->ulReserved;
    lpDest->flFlags = lpSrc->flFlags;
    lpDest->nPosition = lpSrc->nPosition;
    lpDest->lpFileType = lpSrc->lpFileType;

    if (lpSrc->lpszPathName)
    {
    lpDest->lpszPathName = (LPTSTR)PvAllocMore(lstrlen (lpSrc->lpszPathName) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszPathName)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszPathName, lpSrc->lpszPathName);
    }
    else
    lpDest->lpszPathName = NULL;

    if (lpSrc->lpszFileName)
    {
    lpDest->lpszFileName = (LPTSTR)PvAllocMore(lstrlen (lpSrc->lpszFileName) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszFileName)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszFileName, lpSrc->lpszFileName);
    }
    else
    lpDest->lpszFileName = NULL;

    return SUCCESS_SUCCESS;

}

/*
 -  FNameInList
 -
 *  Purpose:
 *      To find lpszName in an array of recipients.  Used to determine
 *      if user name has already been resolved.
 *
 *  Parameters:
 *      lpszName        - Friendly name to search for
 *      cRecips         - Count of recipients in lpRecips
 *      lpRecips        - Array of MapiRecipDescs
 *
 *  Return:
 *      TRUE/FALSE
 */

BOOL
FNameInList (LPSTR lpszName, ULONG cRecips, lpMapiRecipDesc lpRecips)
{
    /* Case sensitive compare of each friendly name in list.  */

    if (!cRecips || !lpRecips)
    return FALSE;

    while (cRecips--)
    if (!lstrcmp (lpszName, lpRecips[cRecips].lpszName))
        return TRUE;

    return FALSE;
}


/*
 -  MakeMsgNode
 -
 *  Purpose:
 *      Allocate memory for a new MSGID node and initialize its
 *      data members to the values passed in.
 *
 *  Parameters:
 *      lpMsg           - Pointer to a MapiMessage
 *      lpszMsgID       - Opaque message identifier
 *
 *  Return:
 *      lpMsgNode       - Pointer to new node
 */

LPMSGID
MakeMsgNode (lpMapiMessage lpMsg, LPSTR lpszMsgID)
{
    LPMSGID lpMsgNode = NULL;

    if (!lpMsg || !lpszMsgID)
    goto err;

    lpMsgNode = (LPMSGID)PvAlloc(sizeof (MSGID));

    if (!lpMsgNode)
    goto err;

    memset (lpMsgNode, 0, sizeof (MSGID));

    if (lpMsg->nFileCount)
    lpMsgNode->fHasAttach = TRUE;

    if (lpMsg->flFlags & MAPI_UNREAD)
    lpMsgNode->fUnRead = TRUE;

    lpMsgNode->lpszMsgID = (LPTSTR)PvAllocMore(lstrlen (lpszMsgID) + 1,
        (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszMsgID)
    goto err;

    lstrcpy (lpMsgNode->lpszMsgID, lpszMsgID);

    if (lpMsg->lpOriginator && lpMsg->lpOriginator->lpszName)
    {
    lpMsgNode->lpszFrom = (LPTSTR)PvAllocMore(lstrlen(lpMsg->lpOriginator->lpszName) + 1,
            (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszFrom)
        goto err;

    lstrcpy (lpMsgNode->lpszFrom, lpMsg->lpOriginator->lpszName);
    }

    if (lpMsg->lpszSubject)
    {
    lpMsgNode->lpszSubject = (LPTSTR)PvAllocMore(lstrlen (lpMsg->lpszSubject) + 1,
            (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszSubject)
        goto err;

    lstrcpy (lpMsgNode->lpszSubject, lpMsg->lpszSubject);
    }

    if (lpMsg->lpszDateReceived)
    {
    lpMsgNode->lpszDateRec = (LPTSTR)PvAllocMore(lstrlen (lpMsg->lpszDateReceived) + 1,
            (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszDateRec)
        goto err;

    lstrcpy (lpMsgNode->lpszDateRec, lpMsg->lpszDateReceived);
    }

    return lpMsgNode;

err:
    PvFree(lpMsgNode);
    return NULL;
}

/*
 -  InsertMsgNode
 -
 *  Purpose:
 *      Currently (for simplicity) we will insert the nodes
 *      at the beginning of the list.  This can later be
 *      replaced with a routine that can insert sorted on
 *      different criteria, like DateReceived, From, or
 *      Subject.  But for now...
 *
 *  Parameters:
 *      lpMsgNode       - Pointer to a MSGID node
 *      lppMsgHead      - Pointer to the head of the list
 *
 *  Return:
 *      Void.
 */

void
InsertMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead)
{
    if (*lppMsgHead)
    {
    lpMsgNode->lpNext = *lppMsgHead;
    (*lppMsgHead)->lpPrev = lpMsgNode;
    }
    else
    lpMsgNode->lpNext = NULL;

    /* The next 2 assignments are here in case the node came from somewhere */
    /* other than a call to MakeMsgNode () in which case we aren't sure */
    /* they're already NULL. */

    lpMsgNode->lpPrev = NULL;
    *lppMsgHead = lpMsgNode;
}

/*
 -  DeleteMsgNode
 -
 *  Purpose:
 *      Removes the node passed in from the list.  This
 *      may seem like a strange way to do this but it's
 *      not, because the Owner-Drawn List Box gives us
 *      direct access to elements in the list that makes
 *      it easier to do things this way.
 *
 *  Parameters:
 *      lpMsgNode       - Pointer to the MSGID node to delete
 *      lppMsgHead      - Pointer to the head of the list
 *
 *  Return:
 *      Void.
 */

void
DeleteMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead)
{
    if (!lpMsgNode)
    return;

    /* Check if we are the first node */

    if (lpMsgNode->lpPrev)
    lpMsgNode->lpPrev->lpNext = lpMsgNode->lpNext;

    /* Check if we are the last node */

    if (lpMsgNode->lpNext)
    lpMsgNode->lpNext->lpPrev = lpMsgNode->lpPrev;

    /* check if we are the only node */

    if(lpMsgNode == *lppMsgHead)
    *lppMsgHead = NULL;

    PvFree(lpMsgNode);
    return;
}



/*
 -  FindNode
 -
 *  Purpose:
 *      Returns a pointer to the node containing lpszMsgID.
 *      Returns NULL if node doesn't exist or lpszMsgID is NULL.
 *
 *  Parameters:
 *      lpMsgHead       - Pointer to the head of the list
 *      lpszMsgID       - Message ID to search for
 *
 *  Return:
 *      lpMsgNode       - Pointer to the node returned
 */

LPMSGID
FindNode (LPMSGID lpMsgHead, LPSTR lpszMsgID)
{
    if (!lpszMsgID)
    return NULL;

    while (lpMsgHead)
    {
    if (!lstrcmp (lpMsgHead->lpszMsgID, lpszMsgID))
        break;

    lpMsgHead = lpMsgHead->lpNext;
    }

    return lpMsgHead;
}



/*
 -  FreeMsgList
 -
 *  Purpose:
 *      Walks down the MsgList and frees each node.
 *
 *  Parameters:
 *      lpMsgHead       - Pointer to the head of the list
 *
 *  Return:
 *      Void.
 */

void
FreeMsgList (LPMSGID lpMsgHead)
{
    LPMSGID lpT;

    while (lpMsgHead)
    {
    lpT = lpMsgHead;
    lpMsgHead = lpMsgHead->lpNext;
    PvFree(lpT);
    }
}

/*
 -  MakeDisplayNameStr
 -
 *  Purpose:
 *      Finds all recipients of type ulRecipClass in lpRecips and adds
 *      their friendly name to the display string.
 *
 *  Parameters:
 *      lpszDisplay         - Destination string for names
 *      ulRecipClass        - Recipient types to search for
 *      cRecips             - Count of recipients in lpRecips
 *      lpRecips            - Pointer to array of MapiRecipDescs
 *
 *  Return:
 *      Void.
 */

void
MakeDisplayNameStr (LPSTR lpszDisplay, ULONG ulRecipClass,
    ULONG cRecips, lpMapiRecipDesc lpRecips)
{
    ULONG idx;

    *lpszDisplay = '\0';

    for (idx = 0; idx < cRecips; idx++)
    {
    if (lpRecips[idx].ulRecipClass == ulRecipClass)
    {
        lstrcat (lpszDisplay, lpRecips[idx].lpszName);
        lstrcat (lpszDisplay, "; ");
    }
    }

    if (*lpszDisplay)
    lpszDisplay[lstrlen (lpszDisplay) - 2] = '\0';
}



/*
 -  SaveMsgChanges
 -
 *  Purpose:
 *      If while reading a message the user changes the notetext at all
 *      then this function is called to save those changes in the Inbox.
 *
 *  Parameters:
 *      hWnd            - handle to the window/dialog who called us
 *      lpMsg           - pointer to the MAPI message to be saved
 *      lpszMsgID       - ID of the message to save
 *
 *  Return:
 *      ulResult        - Indicating success/failure
 */

ULONG
SaveMsgChanges (HWND hWnd, lpMapiMessage lpMsg, LPSTR lpszMsgID)
{
    LPSTR lpszT;
    LPSTR lpszNoteText = NULL;
    LONG cLines, cb;
    ULONG ulResult = MAPI_E_INSUFFICIENT_MEMORY;

    lpszT = lpMsg->lpszNoteText;

    cLines = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_GETLINECOUNT, 0, 0L);
    cb = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINEINDEX, (UINT)cLines - 1, 0L);
    cb += SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINELENGTH, (UINT)cb, 0L);
    cb += cLines * 2;

    lpszNoteText = (LPTSTR)PvAlloc(cb + 1);

    if (!lpszNoteText)
    goto err;

    SendDlgItemMessage (hWnd, IDC_READNOTE, WM_GETTEXT,
    (WPARAM) cb, (LPARAM) lpszNoteText);

    lpMsg->lpszNoteText = lpszNoteText;
    ulResult = MAPISaveMail (lhSession, (ULONG) hWnd, lpMsg, MAPI_LONG_MSGID,
        0, lpReadMsgNode->lpszMsgID);

    PvFree(lpszNoteText);

err:
    lpMsg->lpszNoteText = lpszT;
    return ulResult;
}



/*
 -  MakeNewMessage
 -
 *  Purpose:
 *      This function is used to construct a new message for the
 *      ComposeNote UI.  This gets called as a result of a Reply,
 *      ReplyAll, or a Forward action on a message being read.
 *      The destination for the new message is lpmsg, the global
 *      MapiMessage struct pointer used by ComposeNoteDlgProc.
 *      ComposeNoteDlgProc always frees the memory consumed by
 *      this object whether it allocated it or not.
 *
 *  Parameters:
 *      lpSrcMsg            - MapiMessage to be copied
 *      flType              - Specifies the action that caused this call
 *                            either: IDC_REPLY, IDC_REPLYALL, or IDC_FORWARD
 *
 *  Return:
 *      ulResult            - Indicates success/failure
 */

ULONG
MakeNewMessage (lpMapiMessage lpSrcMsg, UINT flType)
{
    ULONG idx;
    ULONG ulResult = SUCCESS_SUCCESS;

    if (!lpSrcMsg)
    return MAPI_E_FAILURE;

    lpmsg = (lpMapiMessage)PvAlloc(sizeof (MapiMessage));

    if (!lpmsg)
    goto err;

    memset (lpmsg, 0, sizeof (MapiMessage));

    lpmsg->flFlags = flSendMsgFlags;

    if (lpSrcMsg->lpszSubject)
    {
    lpmsg->lpszSubject = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg->lpszSubject) + 5);

    if (!lpmsg->lpszSubject)
        goto err;

    if (flType == IDC_FORWARD)
        lstrcpy (lpmsg->lpszSubject, "FW: ");
    else
        lstrcpy (lpmsg->lpszSubject, "RE: ");

    lstrcat (lpmsg->lpszSubject, lpSrcMsg->lpszSubject);
    }

    if (lpSrcMsg->lpszNoteText)
    {
    lpmsg->lpszNoteText = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg->lpszNoteText) + 32);

    if (!lpmsg->lpszNoteText)
        goto err;

    lstrcpy (lpmsg->lpszNoteText, "\r\n--------------------------\r\n");
    lstrcat (lpmsg->lpszNoteText, lpSrcMsg->lpszNoteText);
    }

    if (lpSrcMsg->lpszMessageType)
    {
    lpmsg->lpszMessageType = (LPTSTR)PvAlloc(lstrlen (lpSrcMsg->lpszMessageType) + 1);

    if (!lpmsg->lpszMessageType)
        goto err;

    lstrcpy (lpmsg->lpszMessageType, lpSrcMsg->lpszMessageType);
    }

    if (lpSrcMsg->lpszConversationID)
    {
    lpmsg->lpszConversationID = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg->lpszConversationID) + 1);

    if (!lpmsg->lpszConversationID)
        goto err;

    lstrcpy (lpmsg->lpszConversationID, lpSrcMsg->lpszConversationID);
    }

    if (lpSrcMsg->nFileCount && flType == IDC_FORWARD )
    {
    lpmsg->nFileCount = lpSrcMsg->nFileCount;

    lpmsg->lpFiles = (lpMapiFileDesc)PvAlloc(lpmsg->nFileCount * sizeof (MapiFileDesc));

    if (!lpmsg->lpFiles)
        goto err;
        memset (lpmsg->lpFiles, 0, (size_t)lpmsg->nFileCount * sizeof (MapiFileDesc));

        for (idx = 0; idx < lpmsg->nFileCount; idx++)
    {       
        CopyAttachment (lpmsg->lpFiles, &lpmsg->lpFiles[idx],
        &lpSrcMsg->lpFiles[idx]);
        
            if ((&lpmsg->lpFiles[idx])->nPosition != (ULONG) -1)
            {       
                /*lpmsg->lpszNoteText[(&lpmsg->lpFiles[idx])->nPosition 
                            + lstrlen("\r\n--------------------------\r\n")] = '+';*/
                (&lpmsg->lpFiles[idx])->nPosition = (ULONG) -1;
                
            }
                                
            
        }
    }

    if (flType == IDC_REPLY || flType == IDC_REPLYALL)
    {
        ULONG idxSrc;

    if(lpSrcMsg->lpOriginator)
        lpmsg->nRecipCount = 1;

    if (flType == IDC_REPLYALL)
        lpmsg->nRecipCount += lpSrcMsg->nRecipCount;

        if(!lpmsg->nRecipCount)
            return ulResult;

    lpmsg->lpRecips = (lpMapiRecipDesc)PvAlloc(lpmsg->nRecipCount * sizeof (MapiRecipDesc));

    if (!lpmsg->lpRecips)
        goto err;

        memset (lpmsg->lpRecips, 0, (size_t)lpmsg->nRecipCount * sizeof (MapiRecipDesc));
        idx = 0;

        if(lpSrcMsg->lpOriginator)
        {
        lpSrcMsg->lpOriginator->ulRecipClass = MAPI_TO;
        CopyRecipient (lpmsg->lpRecips, lpmsg->lpRecips,
                lpSrcMsg->lpOriginator);
        lpSrcMsg->lpOriginator->ulRecipClass = MAPI_ORIG;
            idx = 1;
        }

    for (idxSrc = 0; idx < lpmsg->nRecipCount; idxSrc++, idx++)
        CopyRecipient (lpmsg->lpRecips, &lpmsg->lpRecips[idx],
        &lpSrcMsg->lpRecips[idxSrc]);
    }

    return ulResult;

err:
    if(lpmsg)
    {
        PvFree(lpmsg->lpszSubject);
    PvFree(lpmsg->lpszNoteText);
        PvFree(lpmsg->lpszMessageType);
        PvFree(lpmsg->lpszConversationID);
        PvFree(lpmsg->lpRecips);
        PvFree(lpmsg->lpFiles);
        PvFree(lpmsg);
        lpmsg = NULL;
    }
    return ulResult;
}



/*
 -  LogSendMail
 -
 *  Purpose:
 *      Used to track how many messages were sent with this client.
 *      This information is used strictly for gathering stats on
 *      how many messages were pumped through the spooler/transport.
 *
 *  Usage:
 *      Add the following to the win.ini file:
 *          [MAPI Client]
 *          LogFile=filepath
 *
 *      where: filepath can be a full UNC path or some local path & file
 *
 *  Parameters:
 *      ulResult        - Currently unused; should be used to count errors
 *
 *  Result:
 *      Void.
 */

void LogSendMail(ULONG ulResult)
{
    char szLogFile[128];
    char szCount[32];
    OFSTRUCT ofs;
    HFILE hf = HFILE_ERROR;
    int cSent = 1;

    if(!GetProfileString("MAPI Client", "LogFile", "mapicli.log",
        szLogFile, sizeof(szLogFile)))
    return;

    if((hf = OpenFile(szLogFile, &ofs, OF_READWRITE)) == HFILE_ERROR)
    {
    if((hf = OpenFile(szLogFile, &ofs, OF_CREATE|OF_READWRITE)) == HFILE_ERROR)
        return;
    }
    else
    {
    if(!_lread(hf, szCount, sizeof(szCount)))
    {
        _lclose(hf);
        return;
    }

    cSent = atoi(szCount) + 1;
    }

    wsprintf(szCount, "%d", cSent);

    _llseek(hf, 0, 0);

    _lwrite(hf, szCount, lstrlen(szCount));
    _lclose(hf);

    return;
}



/*
 -  SaveFileAttachments
 -
 *  Purpose:
 *      Displays a 'Save As' common dialog to allow the user to save
 *      file attachments contained in the current message.
 *
 *  Parameters:
 *      hWnd            - Window handle of calling WndProc
 *      cFiles          - Count of the files in the file array
 *      lpFiles         - Array of MapiFileDescs
 *
 *  Return:
 *      Void.
 */

void SaveFileAttachments(HWND hWnd, lpMapiFileDesc lpFile)
{
    OPENFILENAME ofn;
    char szFileName[256] = "";
    char szFilter[256];
    static char szFileTitle[16];
    static char szDirName[256] = "";
    LPSTR lpszEndPath;
    ULONG idx;

    if (!lpFile)
    return;

    if (!szDirName[0])
    GetTempPath (sizeof(szDirName), szDirName);

    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter));

    for (idx = 0; szFilter[idx] != '\0'; idx++)
    if (szFilter[idx] == '|')
        szFilter[idx] = '\0';

    lstrcpy (szFileName, lpFile->lpszFileName);

    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = 0;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 1L;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName);
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = sizeof(szFileTitle);
    ofn.lpstrInitialDir = szDirName;
    ofn.lpstrTitle = "Save Attachment";
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;

    if (!GetSaveFileName (&ofn))
    return;

    /* Save the directory for the next time we call this */

    lstrcpy (szDirName, szFileName);
    if (lpszEndPath = strstr (szDirName, szFileTitle))
    *(--lpszEndPath) = '\0';

    /* Use CopyFile to carry out the operation. */

    if(!CopyFile(lpFile->lpszPathName, szFileName, FALSE))
    MakeMessageBox (hWnd, 0, IDS_SAVEATTACHERROR, MBS_ERROR);
}



/*
 -  ToggleMenuState
 -
 *  Purpose:
 *      Enables/Disables menu items depending on the session state.
 *
 *  Parameters:
 *      hWnd            - handle to the window/dialog who called us
 *      fLoggedOn       - TRUE if logged on, FALSE if logged off
 *
 *  Return:
 *      Void.
 */

void ToggleMenuState(HWND hWnd, BOOL fLoggedOn)
{
    EnableMenuItem (GetMenu (hWnd), IDM_LOGOFF,   !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_COMPOSE,  !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_READ,     !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_SEND,     !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_ADDRBOOK, !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_DETAILS,  !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_LOGON,    fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,           FALSE);
}

//
//  SecureMenu
//
//  Purpose:
//      Enables/Disables Logon and Exit menu items.
//      CMCLogon might yield control to Windows, so the user might be able to
//      access the window menu (for example click Logon) after we call
//      MAPILogon, but before it returns.
//
//  Parameters:
//      hWnd            - handle to the window/dialog who called us
//      fBeforeLogon    - TRUE when this function is called when we are about
//                      to call MAPILogon, FALSE if called after logon (failed)
//                      if Logon succeddes ToggleMenuState is called instead of
//                      this function.
//
//  Return:
//      Void.
//


void SecureMenu(HWND hWnd, BOOL fBeforeLogon)
{
    EnableMenuItem (GetMenu (hWnd), IDM_LOGON, fBeforeLogon);
    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,  fBeforeLogon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\bitmap.h ===
/*
 -  B I T M A P . H
 *  
 *  Purpose:
 *      Definitions for the Owner-Drawn Listbox bitmap stuff.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */


/* Listbox string formatting defines */

#define chBOLD              TEXT('\b')
#define chUNDERLINE         TEXT('\v')
#define chTAB               TEXT('\t')
#define chBITMAP            TEXT('\001')

#define BMWIDTH             16
#define BMHEIGHT            16
#define NUMBMPS             4
#define RGBREPLACE          ((DWORD)0x00FF0000) // solid blue


/* Font style of font to use in listbox */

typedef struct
{
    int     lfHeight;
    int     lfWeight;
    BYTE    lfItalic;
    TCHAR   lfFaceName[LF_FACESIZE];
} FONTSTYLE;


/* Function Prototypes */

VOID    DrawItem(LPDRAWITEMSTRUCT pDI);
VOID    MeasureItem(HANDLE hwnd, LPMEASUREITEMSTRUCT mis);
VOID    SetRGBValues(void);
BOOL    InitBmps(HWND hwnd, int idLB);
VOID    DeInitBmps(void);
BOOL    LoadBitmapLB(void);
VOID    DeleteBitmapLB(void);
VOID    ConvertDateRec(LPSTR lpszDateRec, LPSTR lpszDateDisplay);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\client.h ===
/*
 -  C L I E N T . H
 -
 *  Purpose:
 *      Header file for the sample mail client based on Simple MAPI.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */


#include "smapi.h"

/* Menu Item IDs */

#define IDM_LOGON       100
#define IDM_LOGOFF      101
#define IDM_EXIT        102
#define IDM_COMPOSE     103
#define IDM_READ        104
#define IDM_SEND        105
#define IDM_ADDRBOOK    106
#define IDM_DETAILS     107
#define IDM_ABOUT       108

/* Resource IDs */

#define ICON_NOMAIL     200
#define ICON_MAIL       201
#define IDB_ENVELOPE    300


/* Address Book Control IDs */

#define IDT_ADDRESS     101
#define IDC_ADDRESS     102
#define IDT_LIST        103
#define IDC_LIST        104
#define IDC_ADD         105
#define IDC_REMOVE      106


/* Compose Note Control IDs */

#define IDC_SEND        101
#define IDC_RESOLVE     102
#define IDC_ATTACH      103
#define IDC_OPTIONS     104
#define IDC_ADDRBOOK    105
#define IDT_TO          106
#define IDC_TO          107
#define IDT_CC          108
#define IDC_CC          109
#define IDT_SUBJECT     110
#define IDC_SUBJECT     111
#define IDC_NOTE        112
#define IDC_CATTACHMENT 113
#define IDT_CATTACHMENT 114
#define IDC_LINE1       -1
#define IDC_LINE2       -1


/* InBox Control IDs */

#define IDT_MSG         101
#define IDC_MSG         102
#define IDC_NEW         103
#define IDC_READ        104
#define IDC_DELETE      105
#define IDC_CLOSE       106


/* ReadNote Control IDs */

#define IDC_SAVECHANGES 101
#define IDC_SAVEATTACH  102
#define IDC_REPLY       103
#define IDC_REPLYALL    104
#define IDC_FORWARD     105
#define IDT_RFROM       106
#define IDT_RDATE       107
#define IDT_RTO         108
#define IDT_RCC         109
#define IDT_RSUBJECT    110
#define IDC_RFROM       111
#define IDC_RDATE       112
#define IDC_RTO         113
#define IDC_RCC         114
#define IDC_RSUBJECT    115
#define IDC_READNOTE    116
#define IDT_ATTACHMENT  117
#define IDC_ATTACHMENT  118


/* Options Control IDs */

#define IDC_RETURN      101


/* Details Control IDs */

#define IDT_NAME        100
#define IDC_NAME        101
#define IDT_TYPE        102
#define IDC_TYPE        103
#define IDT_ADDR        104
#define IDC_ADDR        105

/* About Box Control IDs */

#define IDC_VERSION     101


/* String Table IDs */

#define MAPI_ERROR_MAX          30

#define IDS_LOGONFAIL           (MAPI_ERROR_MAX + 1)
#define IDS_ADDRBOOKFAIL        (MAPI_ERROR_MAX + 2)
#define IDS_RESOLVEFAIL         (MAPI_ERROR_MAX + 3)
#define IDS_UNRESOLVEDNAMES     (MAPI_ERROR_MAX + 4)
#define IDS_SENDERROR           (MAPI_ERROR_MAX + 5)
#define IDS_DETAILS_TOO_MANY    (MAPI_ERROR_MAX + 6)
#define IDS_DETAILSFAIL         (MAPI_ERROR_MAX + 7)
#define IDS_NORECIPS            (MAPI_ERROR_MAX + 8)
#define IDS_SAVEATTACHERROR     (MAPI_ERROR_MAX + 9)
#define IDS_READFAIL            (MAPI_ERROR_MAX + 10)
#define IDS_DIALOGACTIVE        (MAPI_ERROR_MAX + 11)

#define IDS_FILTER              (MAPI_ERROR_MAX + 50)

/* Manifest Constants */

#define ADDR_MAX            128
#define MAXUSERS            10
#define TO_EDIT_MAX         512
#define CC_EDIT_MAX         512
#define SUBJECT_EDIT_MAX    128
#define NOTE_LINE_MAX       1024
#define FILE_ATTACH_MAX     32

/* Message Box styles */

#define MBS_ERROR           (MB_ICONSTOP | MB_OK)
#define MBS_INFO            (MB_ICONINFORMATION | MB_OK)
#define MBS_OOPS            (MB_ICONEXCLAMATION | MB_OK)

/* Structure Definitions */

typedef struct _msgid *LPMSGID;

typedef struct _msgid
{
    LPSTR       lpszMsgID;
    BOOL        fHasAttach;
    BOOL        fUnRead;
    LPSTR       lpszFrom;
    LPSTR       lpszSubject;
    LPSTR       lpszDateRec;
    LPMSGID     lpPrev;
    LPMSGID     lpNext;
} MSGID;



/* Function Prototypes */

int  PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
void DeinitApplication(void);
long FAR PASCAL MainWndProc(HWND, UINT, UINT, LPARAM);
BOOL FAR PASCAL AboutDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL ComposeDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL InBoxDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL ReadMailDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL OptionsDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL DetailsDlgProc(HWND, UINT, UINT, LONG);
void    MakeMessageBox(HWND, ULONG, UINT, UINT);
ULONG   ResolveFriendlyNames(HWND, LPSTR, ULONG, ULONG *, lpMapiRecipDesc *);
ULONG   CopyRecipient(lpMapiRecipDesc, lpMapiRecipDesc, lpMapiRecipDesc);
ULONG   GetNextFile(HWND, ULONG, ULONG *, lpMapiFileDesc *);
ULONG   CopyAttachment(lpMapiFileDesc, lpMapiFileDesc, lpMapiFileDesc);
BOOL    FNameInList(LPSTR, ULONG, lpMapiRecipDesc);
LPMSGID MakeMsgNode(lpMapiMessage, LPSTR);
LPMSGID FindNode(LPMSGID, LPSTR);
void    InsertMsgNode(LPMSGID, LPMSGID *);
void    DeleteMsgNode(LPMSGID, LPMSGID *);
void    FreeMsgList(LPMSGID);
void    MakeDisplayNameStr(LPSTR, ULONG, ULONG, lpMapiRecipDesc);
ULONG   SaveMsgChanges(HWND, lpMapiMessage, LPSTR);
ULONG   MakeNewMessage(lpMapiMessage, UINT);
void    LogSendMail(ULONG);
void    SaveFileAttachments(HWND, lpMapiFileDesc);
void    ToggleMenuState(HWND, BOOL);   
BOOL    fSMAPIInstalled(void);
void SecureMenu(HWND hWnd, BOOL fBeforeLogon);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\mapidbg.c ===
/*
 *  MAPIDBG.C
 *
 *  MAPI Debugging Utilities
 *
 *  Copyright (C) 1986-1996 Microsoft Corporation. All rights reserved.
 */

#ifdef DEBUG

#pragma warning(disable:4100)   /* unreferenced formal parameter */
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4201)   /* nameless struct/union */
#pragma warning(disable:4206)   /* translation unit is empty */
#pragma warning(disable:4209)   /* benign typedef redefinition */
#pragma warning(disable:4214)   /* bit field types other than int */
#pragma warning(disable:4001)   /* single line comments */
#pragma warning(disable:4050)   /* different code attributes */

#ifdef _MAC
#define INC_OLE2
#include <windows.h>
#include <macname1.h>
#include <macos\menus.h>
#include <stdio.h>
#include <mapiprof.h>

#define GetPrivateProfileIntA       MAPIGetPrivateProfileInt

#elif defined(WIN16) || defined(_WIN32)
#pragma warning(disable:4115)   /* named type definition in parentheses */
#include <windows.h>
#include <mapiwin.h>

#ifdef _WIN32
#pragma warning(disable:4001)   /* single line comments */
#pragma warning(disable:4115)   /* named type definition in parentheses */
#pragma warning (disable:4514)  /* unreferenced inline function */
#include <objerror.h>
#endif

#else

#include <stdio.h>
void __far __pascal OutputDebugString(char __far *);
#define wvsprintf           vsprintf
#define wsprintf            sprintf

#endif      /* _MAC */

#ifdef DOS
#define lstrcpyA            strcpy
#define lstrlenA            strlen
#define lstrcatA            strcat
#define wvsprintfA          wvsprintf
#define wsprintfA           wsprintf
#define OutputDebugStringA  OutputDebugString
#endif

#include <mapidbg.h>
#include <mapidefs.h>
#include <mapitags.h>
#include <mapicode.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>
#ifdef _MAC
#include <macname2.h>
#endif

#if defined(DBCS) && defined(DOS)
#include <gapidos.h>
#endif

#if defined(DEBUG) && defined(_WINNT)
#include <lmcons.h>
#include <lmalert.h>
#endif

/*  Patch/Hack for 16bit, optimized builds.
 *
 *  memcpy with a size of 0 bytes causes a
 *  crash.
 */

#ifndef __MEMCPY_H_
#define __MEMCPY_H_

#if defined(WIN16) && !defined(DEBUG)
#define MemCopy(_dst,_src,_cb)      do                                  \
                                    {                                   \
                                        size_t __cb = (size_t)(_cb);    \
                                        if (__cb)                       \
                                            memcpy(_dst,_src,__cb);     \
                                    } while (FALSE)
#else
#define MemCopy(_dst,_src,_cb)  memcpy(_dst,_src,(size_t)(_cb))
#endif

#endif

#if (defined(WIN16) || defined(DOS)) && !defined(NO_BASED_DEBUG)
#define BASED_DEBUG __based(__segname("DEBUG_DATA"))
#else
#define BASED_DEBUG
#endif

#if defined(WIN16)
#define BASED_CODE          __based(__segname("_CODE"))
#else
#define BASED_CODE
#endif



#if defined(WIN16) || defined(_WIN32)
static BOOL fTraceEnabled               = -1;
static BOOL fUseEventLog                = -1;
static BOOL fAssertLeaks                = -1;
#if defined(_WIN32) && !defined(_MAC)
BOOL fInhibitTrapThread                 = 2;
#endif

static char szKeyTraceEnabled[]         = "DebugTrace";
static char szKeyInhibitTrapThread[]    = "TrapOnSameThread";
static char szKeyEventLog[]             = "EventLog";
static char szKeyUseVirtual[]           = "VirtualMemory";
static char szKeyAssertLeaks[]          = "AssertLeaks";
static char szKeyCheckOften[]           = "CheckHeapOften";
static char szKeyFillRandom[]           = "MemoryFillRandom";
static char szSectionDebug[]            = "General";
static char szDebugIni[]                = "MAPIDBG.INI";
#endif

#ifndef VTABLE_FILL
#ifdef _MAC
#define VTABLE_FILL     NULL,
#else
#define VTABLE_FILL
#endif
#endif

#if defined(DEBUG) && defined(_WINNT)
typedef BOOL  (WINAPI   *ReportEventFN)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCTSTR *, LPVOID);
typedef HANDLE (WINAPI  *RegisterEventSourceAFN)(LPCTSTR, LPCTSTR);

ReportEventFN pfnReportEvent = NULL;
RegisterEventSourceAFN pfnRegisterEventSourceA = NULL;
#endif


#ifdef  WIN16
#pragma code_seg("Debug")
#endif  

#if defined( _WINNT)

/*++

Routine Description:

    This routine returns if the service specified is running interactively
    (not invoked \by the service controller).

Arguments:

    None

Return Value:

    BOOL - TRUE if the service is an EXE.


Note:

--*/

BOOL WINAPI IsDBGServiceAnExe( VOID )
{
    HANDLE hProcessToken = NULL;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;

    // Start with assumption that process is an EXE, not a Service.
    BOOL fExe = TRUE;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
        goto ret;

    if (groupInfo == NULL)
        goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            goto ret;

        LocalFree(groupInfo);
        groupInfo = NULL;
    
        groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);
    
        if (groupInfo == NULL)
            goto ret;
    
        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            goto ret;
        }
    }

    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
        0, 0, 0, 0, 0, &InteractiveSid))
    {
        goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
        0, 0, 0, 0, &ServiceSid))
    {
        goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;
    
        //
        //  Check to see if the group we're looking at is one of
        //  the 2 groups we're interested in.
        //
    
        if (EqualSid(Sid, InteractiveSid))
        {
            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //
            goto ret;
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //
            fExe = FALSE;
            goto ret;
        }
    }

    //
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
    fExe = FALSE;

ret:

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    if (ServiceSid)
        FreeSid(ServiceSid);

    if (groupInfo)
        LocalFree(groupInfo);

    if (hProcessToken)
        CloseHandle(hProcessToken);

    return(fExe);
}

#endif

/* LogIt */

#ifndef _MAC
void    LogIt(LPSTR plpcText, BOOL  fUseAlert)
{
#if defined(DEBUG) && defined(_WINNT)
    LPSTR           llpcStr[2];
    static HANDLE   hEventSource = NULL;

    if (pfnRegisterEventSourceA == NULL)
    {
        /* This handle is not important as the lib will be freed on exit (and it's debug only) */
        HINSTANCE       lhLib = LoadLibraryA("advapi32.dll");
        
        if (!lhLib)
            return;
        
        pfnRegisterEventSourceA = (RegisterEventSourceAFN) GetProcAddress(lhLib, "RegisterEventSourceA");
        pfnReportEvent = (ReportEventFN) GetProcAddress(lhLib, "ReportEventA");
        
        if (!pfnRegisterEventSourceA || !pfnReportEvent)
            return;
    }
        
    if (!hEventSource)                                      
        hEventSource = pfnRegisterEventSourceA(NULL, "MAPIDebug");

    llpcStr[0] = "MAPI Debug Log";
    llpcStr[1] = plpcText;

    pfnReportEvent(hEventSource,    /* handle of event source */
        EVENTLOG_ERROR_TYPE,        /* event type             */
        0,                          /* event category         */
        0,                          /* event ID               */
        NULL,                       /* current user's SID     */
        2,                          /* strings in lpszStrings */
        0,                          /* no bytes of raw data   */
        llpcStr,                    /* array of error strings */
        NULL);                      /* no raw data            */
        
    /* Now we generate an Alert! */
    /* This code is adapted from PierreC's stuff, and NEEDS TO BE UNICODE!!!! */
    if (fUseAlert)
    {
#define MAX_LINE        256

typedef NET_API_STATUS  (WINAPI *NAREFN)(TCHAR *, ADMIN_OTHER_INFO *, ULONG, TCHAR *);

        BYTE                rgb[sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * MAX_LINE)];
        ADMIN_OTHER_INFO *  poi     = (ADMIN_OTHER_INFO *) rgb;
        WCHAR *             pch     = (WCHAR *) (rgb + sizeof(ADMIN_OTHER_INFO));
        NET_API_STATUS      nas;
        static   NAREFN     fnNetAlertRaiseEx = NULL;
        
        /* Resolve function here, never free library as it's debug only */
        if (!fnNetAlertRaiseEx)
        {
            HINSTANCE       lhLib = LoadLibrary("NETAPI32.DLL");
            if (lhLib)
                fnNetAlertRaiseEx = (NAREFN) GetProcAddress(lhLib, "NetAlertRaiseEx");
        }
        
        if (fnNetAlertRaiseEx)
        {
            poi->alrtad_errcode = (DWORD) -1;
            poi->alrtad_numstrings = 1;
            
            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, plpcText, -1, pch, MAX_LINE))
            {
                nas = fnNetAlertRaiseEx(
                            (TCHAR *) L"ADMIN",
                            poi, 
                            sizeof(ADMIN_OTHER_INFO) + ((lstrlenW(pch) + 1) * sizeof(WCHAR)),
                            (TCHAR *) L"MAPI Assert");
                    
                        
            }
        }
    }
    
#endif /* DEBUG && NT */
}
#endif /* !_MAC */

/* DebugOutputFn ------------------------------------------------------------ */

char BASED_CODE szCR[] = "\r";

void DebugOutputFn(char *psz)
{
#if defined(_MAC)

    OutputDebugString(psz);

#else

#if defined(WIN16) || defined(_WIN32)
    if (fTraceEnabled == -1)
    {
        fTraceEnabled = GetPrivateProfileIntA(szSectionDebug, szKeyTraceEnabled,
            0, szDebugIni);

        fUseEventLog = GetPrivateProfileIntA(szSectionDebug, szKeyEventLog,
            0, szDebugIni);     
    }

    if (!fTraceEnabled)
        return;

    if (fUseEventLog)
#else
    if (FALSE)
#endif
        LogIt(psz, FALSE);

#ifdef WIN16
    OutputDebugString(psz);
    OutputDebugString(szCR);
#else
    OutputDebugStringA(psz);
    OutputDebugStringA(szCR);
#endif
    
#endif  /* _MAC */
}


/* DebugTrapFn -------------------------------------------------------------- */

#if defined(_WIN32) && !defined(_MAC)

typedef struct {
    char *      sz1;
    char *      sz2;
    UINT        rgf;
    int         iResult;
} MBContext;

DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
    if (fUseEventLog)
    {
        LogIt(pmbc->sz1, TRUE);
        pmbc->iResult = IDIGNORE;
    }
    else
        pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
            pmbc->rgf | MB_SETFOREGROUND);

    return(0);
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
    HANDLE      hThread;
    DWORD       dwThreadId;
    MBContext   mbc;

    mbc.sz1     = sz1;
    mbc.sz2     = sz2;
    mbc.rgf     = rgf;
    mbc.iResult = IDRETRY;

    #if defined(_WIN32) && !defined(_MAC)
    if (fInhibitTrapThread == 2)
        fInhibitTrapThread = GetPrivateProfileIntA(szSectionDebug,
            szKeyInhibitTrapThread, 0, szDebugIni);
    #endif

    if (fInhibitTrapThread)
    {
        MessageBoxFnThreadMain(&mbc);
    }
    else
    {
        hThread = CreateThread(NULL, 0,
            (PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &mbc, 0, &dwThreadId);

        if (hThread != NULL) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    }

    return(mbc.iResult);
}
#else
#define MessageBoxFn(sz1, sz2, rgf)     MessageBoxA(NULL, sz1, sz2, rgf)
#endif

int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
    char    sz[512];
    va_list vl;

    #if defined(WIN16) || defined(_WIN32)
    int     id;
    #endif
    #if defined(_WIN32) && !defined(_MAC)
    static int iServiceFlag = -1;
    #endif

    lstrcpyA(sz, "++++ MAPI Debug Trap (");
    _strdate(sz + lstrlenA(sz));
    lstrcatA(sz, " ");
    _strtime(sz + lstrlenA(sz));
    lstrcatA(sz, ")\n");
    DebugOutputFn(sz);

    va_start(vl, pszFormat);
    wvsprintfA(sz, pszFormat, vl);
    va_end(vl);

    wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    DebugOutputFn(sz);

    #if defined(DOS)
    _asm { int 3 }
    #endif

#if defined(WIN16) || defined(_WIN32)
    /* Hold down control key to prevent MessageBox */
    if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
    {
        UINT uiFlags = MB_ABORTRETRYIGNORE;

        if (fFatal)
            uiFlags |= MB_DEFBUTTON1;
        else
            uiFlags |= MB_DEFBUTTON3;

        #ifdef WIN16
        uiFlags |= MB_ICONEXCLAMATION | MB_SYSTEMMODAL;
        #else
        uiFlags |= MB_ICONSTOP | MB_TASKMODAL;
        #endif

        #if defined(_WIN32) && !defined(_MAC)
        if (iServiceFlag == -1)
        {
            DWORD dwVersion = GetVersion();

            if (dwVersion & 0x80000000)
            {
                if (LOBYTE(LOWORD(dwVersion)) < 4)
                {
                    //  NT 3.51
                    iServiceFlag = 0x00040000;
                }
                else
                {
                    //  NT 4.0+
                    iServiceFlag = 0x00200000;
                }
            }
            else
                //  not NT, skip this
                iServiceFlag = 0;
        }

        if (!IsDBGServiceAnExe())
            uiFlags |= (UINT) iServiceFlag;
        #endif

        id = MessageBoxFn(sz, "MAPI Debug Trap", uiFlags);

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }
#endif

    return(0);
}

/* DebugTraceFn ------------------------------------------------------------- */

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...)
{
    char    sz[768];
    int     fAutoLF = 0;
    va_list vl;

    if (*pszFormat == '~') {
        pszFormat += 1;
        fAutoLF = 1;
    }

    va_start(vl, pszFormat);
    wvsprintfA(sz, pszFormat, vl);
    va_end(vl);

#ifndef _MAC
    if (fAutoLF)
        lstrcatA(sz, "\n");
#endif

    DebugOutputFn(sz);

    return(0);
}

/* DebugTraceProblemsFn */

void EXPORTDBG __cdecl DebugTraceProblemsFn(LPSTR sz, LPVOID pv)
{
    LPSPropProblemArray pprobs = (LPSPropProblemArray)pv;
    SPropProblem *      pprob = pprobs->aProblem;
    int                 cprob = (int)pprobs->cProblem;

    DebugTraceFn("%s: SetProps problem\n", sz);
    while (cprob--)
    {
        DebugTraceFn("Property %s (index %ld): failed with %s\n",
            SzDecodeUlPropTagFn(pprob->ulPropTag),
            pprob->ulIndex,
            SzDecodeScodeFn(pprob->scode));
    }
}

/* SCODE & PropTag decoding ------------------------------------------------- */

typedef struct
{
    char *          psz;
    unsigned long   ulPropTag;
} PT;

typedef struct
{
    char *  psz;
    SCODE   sc;
} SC;

#define Pt(_ptag)   {#_ptag, _ptag}
#define Sc(_sc)     {#_sc, _sc}

#if !defined(DOS)
static PT BASED_DEBUG rgpt[] = {
    
#include "_tags.h"
    
/*
 * Property types
 */
    Pt(PR_NULL),
    Pt(PT_UNSPECIFIED),
    Pt(PT_NULL),
    Pt(PT_I2),
    Pt(PT_LONG),
    Pt(PT_R4),
    Pt(PT_DOUBLE),
    Pt(PT_CURRENCY),
    Pt(PT_APPTIME),
    Pt(PT_ERROR),
    Pt(PT_BOOLEAN),
    Pt(PT_OBJECT),
    Pt(PT_I8),
    Pt(PT_STRING8),
    Pt(PT_UNICODE),
    Pt(PT_SYSTIME),
    Pt(PT_CLSID),
    Pt(PT_BINARY),
    Pt(PT_TSTRING),
    Pt(PT_MV_I2),
    Pt(PT_MV_LONG),
    Pt(PT_MV_R4),
    Pt(PT_MV_DOUBLE),
    Pt(PT_MV_CURRENCY),
    Pt(PT_MV_APPTIME),
    Pt(PT_MV_SYSTIME),
    Pt(PT_MV_STRING8),
    Pt(PT_MV_BINARY),
    Pt(PT_MV_UNICODE),
    Pt(PT_MV_CLSID),
    Pt(PT_MV_I8)
};

#define cpt (sizeof(rgpt) / sizeof(PT))

static SC BASED_DEBUG rgsc[] = {

/* FACILITY_NULL error codes from OLE */

    Sc(S_OK),
    Sc(S_FALSE),

    Sc(E_UNEXPECTED),
    Sc(E_NOTIMPL),
    Sc(E_OUTOFMEMORY),
    Sc(E_INVALIDARG),
    Sc(E_NOINTERFACE),
    Sc(E_POINTER),
    Sc(E_HANDLE),
    Sc(E_ABORT),
    Sc(E_FAIL),
    Sc(E_ACCESSDENIED),

/* MAPI error codes from MAPICODE.H */
#include "_scode.h"
                    
};

#define csc (sizeof(rgsc) / sizeof(SC))
#endif

char * EXPORTDBG __cdecl
SzDecodeScodeFn(SCODE sc)
{
    static char rgch[64];

    #if !defined(DOS)
    int isc;
    for (isc = 0; isc < csc; ++isc)
        if (sc == rgsc[isc].sc)
            return rgsc[isc].psz;
    #endif

    wsprintfA (rgch, "%08lX", sc);
    return rgch;
}

char * EXPORTDBG __cdecl
SzDecodeUlPropTypeFn(unsigned long ulPropType)
{
    static char rgch[8];

    switch (ulPropType)
    {
    case PT_UNSPECIFIED:    return("PT_UNSPECIFIED");   break;
    case PT_NULL:           return("PT_NULL");          break;
    case PT_I2:             return("PT_I2");            break;
    case PT_LONG:           return("PT_LONG");          break;
    case PT_R4:             return("PT_R4");            break;
    case PT_DOUBLE:         return("PT_DOUBLE");        break;
    case PT_CURRENCY:       return("PT_CURRENCY");      break;
    case PT_APPTIME:        return("PT_APPTIME");       break;
    case PT_ERROR:          return("PT_ERROR");         break;
    case PT_BOOLEAN:        return("PT_BOOLEAN");       break;
    case PT_OBJECT:         return("PT_OBJECT");        break;
    case PT_I8:             return("PT_I8");            break;
    case PT_STRING8:        return("PT_STRING8");       break;
    case PT_UNICODE:        return("PT_UNICODE");       break;
    case PT_SYSTIME:        return("PT_SYSTIME");       break;
    case PT_CLSID:          return("PT_CLSID");         break;
    case PT_BINARY:         return("PT_BINARY");        break;
    }

    wsprintfA(rgch, "0x%04lX", ulPropType);
    return rgch;
}

char *  EXPORTDBG __cdecl
SzDecodeUlPropTagFn(unsigned long ulPropTag)
{
    static char rgch[64];

    #if !defined(DOS)
    int ipt;
    for (ipt = 0; ipt < cpt; ++ipt)
        if (ulPropTag == rgpt[ipt].ulPropTag)
            return rgpt[ipt].psz;
    #endif

    wsprintfA(rgch, "PROP_TAG(%s, 0x%04lX)",
        SzDecodeUlPropType(PROP_TYPE(ulPropTag)),
        PROP_ID(ulPropTag));
    return rgch;
}

SCODE  EXPORTDBG __cdecl
ScodeFromSzFn(char *psz)
{
    #if !defined(DOS)
    int isc;
    for (isc = 0; isc < csc; ++isc)
        {
        if (lstrcmpA(psz, rgsc[isc].psz) == 0)
            {
            return rgsc[isc].sc;
            }
        }
    #endif
    return 0;
}

unsigned long EXPORTDBG __cdecl
UlPropTagFromSzFn(char *psz)
{
    #if !defined(DOS)
    int ipt;
    for (ipt = 0; ipt < cpt; ++ipt)
        {
        if (lstrcmpA(psz, rgpt[ipt].psz) == 0)
            {
            return rgpt[ipt].ulPropTag;
            }
        }
    #endif
    return 0;
}

/* ScCheckScFn -------------------------------------------------------------- */

#if !defined(DOS)

SCODE EXPORTDBG __cdecl ScCheckScFn(    SCODE   sc,
                    SCODE * lpscLegal,
                    char *  lpszMethod,
                    char *  lpszFile,
                    int     iLine)
{
    BOOL fIsQueryInterface = (lpscLegal == IUnknown_QueryInterface_Scodes);

    if (sc == S_OK)
        return(sc);

    while( *lpscLegal != S_OK && sc != *lpscLegal )
    {
        lpscLegal++;
    }

    if ( *lpscLegal == S_OK )
    {
        SCODE *lpscNextCommon = Common_Scodes;

        /* see if this is a common scode */
            if ( !fIsQueryInterface )
                while(  *lpscNextCommon != S_OK &&
                        sc != *lpscNextCommon )
                {
                    lpscNextCommon++;
                }

        /* this is an illegal error or an RPC error */
           if ( (*lpscNextCommon == S_OK || fIsQueryInterface) &&
                ( SCODE_FACILITY(sc) != FACILITY_RPC) )
           {
                DebugTrace( "Unrecognized scode %s from %s\n\t in file %s line %d\n",
                        SzDecodeScode( sc ), lpszMethod, lpszFile, iLine);
            }
    }

    return(sc);
}
#endif

/* SCODE lists -------------------------------------------------------------- */

#if !defined(DOS)

#define STANDARD_OPENENTRY_SCODES \
    E_NOINTERFACE,  \
    MAPI_E_NOT_FOUND

SCODE BASED_DEBUG Common_Scodes[] =
{
    MAPI_E_BAD_CHARWIDTH,
    MAPI_E_CALL_FAILED,
    MAPI_E_INVALID_ENTRYID,
    MAPI_E_INVALID_OBJECT,
    MAPI_E_INVALID_PARAMETER,
    MAPI_E_NO_ACCESS,
    MAPI_E_NO_SUPPORT,
    MAPI_E_NOT_ENOUGH_MEMORY,
    MAPI_E_UNKNOWN_FLAGS,
    S_OK
};

SCODE BASED_DEBUG MAPILogon_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    MAPI_E_LOGON_FAILED,
    S_OK
};

SCODE BASED_DEBUG MAPIAllocateBuffer_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    S_OK
};

SCODE BASED_DEBUG MAPIAllocateMore_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    S_OK
};

SCODE BASED_DEBUG MAPIFreeBuffer_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IUnknown_QueryInterface_Scodes[] =
{
    E_INVALIDARG,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IUnknown_GetLastError_Scodes[] =
{
    MAPI_E_EXTENDED_ERROR,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_CopyTo_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_E_INVALID_TYPE,
    MAPI_E_FOLDER_CYCLE,
    MAPI_E_DECLINE_COPY,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_CopyProps_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_W_PARTIAL_COMPLETION,
    MAPI_E_INVALID_TYPE,
    MAPI_E_FOLDER_CYCLE,
    MAPI_E_DECLINE_COPY,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_DeleteProps_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_E_INVALID_TYPE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetIDsFromNames_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    MAPI_E_TABLE_TOO_BIG,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetLastError_Scodes[] =
{
    MAPI_E_EXTENDED_ERROR,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetNamesFromIDs_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetPropList_Scodes[] =
{
    MAPI_W_ERRORS_RETURNED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetProps_Scodes[] =
{
    MAPI_E_NOT_FOUND,
    MAPI_E_OBJECT_DELETED,
    MAPI_W_ERRORS_RETURNED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_OpenProperty_Scodes[] =
{
    MAPI_E_INTERFACE_NOT_SUPPORTED,
    MAPI_E_NOT_FOUND,
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_SetProps_Scodes[] =
{
    MAPI_E_COMPUTED,
    MAPI_E_UNEXPECTED_TYPE,
    MAPI_E_INVALID_TYPE,
    S_OK
};

SCODE BASED_DEBUG IMAPIProp_SaveChanges_Scodes[] =
{
    MAPI_E_NOT_ENOUGH_DISK,
    MAPI_E_OBJECT_CHANGED,
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IStream_Read_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Write_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Seek_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_SetSize_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Tell_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_LockRegion_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_UnlockRegion_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Clone_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_CopyTo_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Revert_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Stat_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Commit_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPITable_GetLastError_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_Advise_Scodes[] =
{
    S_OK
};
SCODE BASED_DEBUG IMAPITable_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_GetStatus_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SetColumns_Scodes[] =
{
    MAPI_E_BUSY,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_QueryColumns_Scodes[] =
{
    MAPI_E_BUSY,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_GetRowCount_Scodes[] =
{
    MAPI_E_BUSY,
    MAPI_W_APPROX_COUNT,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_SeekRow_Scodes[] =
{
    MAPI_E_INVALID_BOOKMARK,
    MAPI_E_UNABLE_TO_COMPLETE,
    MAPI_W_POSITION_CHANGED,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_SeekRowApprox_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_QueryPosition_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_FindRow_Scodes[] =
{
    MAPI_E_INVALID_BOOKMARK,
    MAPI_E_NOT_FOUND,
    MAPI_W_POSITION_CHANGED,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_Restrict_Scodes[] =
{
    MAPI_E_BUSY,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_CreateBookmark_Scodes[] =
{
    MAPI_E_UNABLE_TO_COMPLETE,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_FreeBookmark_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SortTable_Scodes[] =
{
    MAPI_E_TOO_COMPLEX,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_QuerySortOrder_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_QueryRows_Scodes[] =
{
    MAPI_E_INVALID_BOOKMARK,
    MAPI_W_POSITION_CHANGED,
    S_OK
};

SCODE BASED_DEBUG IMAPITable_Abort_Scodes[] =
{
    MAPI_E_UNABLE_TO_ABORT,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_ExpandRow_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_CollapseRow_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_WaitForCompletion_Scodes[] =
{
    MAPI_E_TIMEOUT,
    S_OK
};
SCODE BASED_DEBUG IMAPITable_GetCollapseState_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SetCollapseState_Scodes[] = {S_OK};


SCODE BASED_DEBUG IMAPISession_LogOff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Release_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_GetLastError_Scodes[] =
{
    MAPI_E_EXTENDED_ERROR,
    S_OK
};
SCODE BASED_DEBUG IMAPISession_GetMsgStoresTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_GetStatusTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_OpenMsgStore_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_OpenAddressBook_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPISession_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    S_OK
};

SCODE BASED_DEBUG IMAPISession_OpenProfileSection_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Advise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_MessageOptions_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_QueryDefaultMessageOpt_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_EnumAdrTypes_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_QueryIdentity_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMsgStore_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMsgStore_SetReceiveFolder_Scodes[] =
{
    MAPI_E_BAD_CHARWIDTH,
    MAPI_E_NOT_FOUND,
    S_OK
};

SCODE BASED_DEBUG IMsgStore_GetReceiveFolder_Scodes[] =
{
    MAPI_E_BAD_CHARWIDTH,
    S_OK
};

SCODE BASED_DEBUG IMsgStore_GetReceiveFolderTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_StoreLogoff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_Advise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_GetOutgoingQueue_Scodes[] = {
    MAPI_E_NO_SUPPORT,
    S_OK};
SCODE BASED_DEBUG IMsgStore_SetLockState_Scodes[] = {
    MAPI_E_NO_SUPPORT,
    MAPI_E_NOT_FOUND,
    S_OK};
SCODE BASED_DEBUG IMsgStore_FinishedMsg_Scodes[] = {
    MAPI_E_NO_SUPPORT,
    S_OK};
SCODE BASED_DEBUG IMsgStore_AbortSubmit_Scodes[] = {
    MAPI_E_UNABLE_TO_ABORT,
    MAPI_E_NOT_IN_QUEUE,
    S_OK};
SCODE BASED_DEBUG IMsgStore_NotifyNewMail_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPIFolder_GetContentsTable_Scodes[] =
{
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetHierarchyTable_Scodes[] =
{
    MAPI_E_OBJECT_DELETED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SaveContentsSort_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CreateMessage_Scodes[] =
{
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CopyMessages_Scodes[] =
{
    E_NOINTERFACE,
    MAPI_E_SUBMITTED,
    MAPI_E_DECLINE_COPY,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_DeleteMessages_Scodes[] =
{
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CreateFolder_Scodes[] =
{
    E_NOINTERFACE,
    MAPI_E_COLLISION,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CopyFolder_Scodes[] =
{
    E_NOINTERFACE,
    MAPI_E_COLLISION,
    MAPI_E_FOLDER_CYCLE,
    MAPI_E_DECLINE_COPY,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_DeleteFolder_Scodes[] =
{
    MAPI_E_HAS_FOLDERS,
    MAPI_E_HAS_MESSAGES,
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetSearchCriteria_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetSearchCriteria_Scodes[] =
{
    MAPI_E_NOT_INITIALIZED,
    MAPI_E_CORRUPT_STORE,
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetReadFlags_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetMessageStatus_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetMessageStatus_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMAPIFolder_EmptyFolder_Scodes[] =
{
    MAPI_E_SUBMITTED,
    S_OK
};

SCODE BASED_DEBUG IMessage_GetAttachmentTable_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMessage_OpenAttach_Scodes[] =
{
    MAPI_E_NOT_FOUND,
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMessage_CreateAttach_Scodes[] =
{
    E_NOINTERFACE,
    S_OK
};

SCODE BASED_DEBUG IMessage_DeleteAttach_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMessage_GetRecipientTable_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IMessage_ModifyRecipients_Scodes[] =
{
    MAPI_E_NOT_FOUND,
    S_OK
};

SCODE BASED_DEBUG IMessage_SubmitMessage_Scodes[] =
{
    MAPI_E_NO_RECIPIENTS,
    MAPI_E_NON_STANDARD,
    S_OK
};

SCODE BASED_DEBUG IMessage_SetReadFlag_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IAttach_SaveChanges_Scodes[] =
{
    S_OK
};

SCODE BASED_DEBUG IAddrBook_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    S_OK
};

SCODE BASED_DEBUG IAddrBook_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_CreateOneOff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_ResolveName_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_Address_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_Details_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_RecipOptions_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_QueryDefaultRecipOpt_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_ButtonPress_Scodes[] = {S_OK};
SCODE BASED_DEBUG IABContainer_GetContentsTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IABContainer_GetHierarchyTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG INotifObj_ChangeEvMask_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_ChangePassword_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_FlushQueues_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_SettingsDialog_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_ValidateState_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPILogon_Scodes[] = {
    MAPI_E_LOGON_FAILED,
    S_OK};
SCODE BASED_DEBUG SMAPI_MAPILogoff_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIFreeBuffer_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISendMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISendDocuments_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIFindNext_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIReadMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISaveMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIDeleteMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIAddress_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIResolveName_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIDetails_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMSProvider_Logon_Scodes[] = {
    MAPI_E_UNCONFIGURED,
    MAPI_E_FAILONEPROVIDER,
    MAPI_E_STRING_TOO_LONG,
    MAPI_E_LOGON_FAILED,
    MAPI_E_CORRUPT_STORE,
    MAPI_E_USER_CANCEL,
    S_OK};
SCODE BASED_DEBUG IMSProvider_Deinit_Scodes[] = {
    S_OK};
SCODE BASED_DEBUG IMSProvider_Shutdown_Scodes[] = {
    S_OK};

SCODE BASED_DEBUG IMSProvider_Init_Scodes[] = {
    MAPI_E_VERSION,
    S_OK};
SCODE BASED_DEBUG IMSProvider_SpoolerLogon_Scodes[] = {
    MAPI_E_LOGON_FAILED,
    S_OK};

SCODE BASED_DEBUG IMSLogon_OpenEntry_Scodes[] =
{
    STANDARD_OPENENTRY_SCODES,
    S_OK
};

SCODE BASED_DEBUG IMSLogon_OpenStatusEntry_Scodes[] = {
    S_OK};

SCODE BASED_DEBUG IMSLogon_CompareEntryIDs_Scodes[] = {
    S_OK};

SCODE BASED_DEBUG IMSLogon_Advise_Scodes[] = {
    S_OK};
SCODE BASED_DEBUG IMSLogon_Unadvise_Scodes[] = {
    S_OK};
SCODE BASED_DEBUG IMSLogon_Logoff_Scodes[] = {
    S_OK};
#endif

/* DBGMEM ------------------------------------------------------------------- */

#undef  INTERFACE
#define INTERFACE struct _DBGMEM
DECLARE_INTERFACE(DBGMEM_)
{
    BEGIN_INTERFACE
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE; \
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE; \
    STDMETHOD_(ULONG,Release)       (THIS) PURE; \
    STDMETHOD_(void FAR*, Alloc)    (THIS_ ULONG cb) PURE; \
    STDMETHOD_(void FAR*, Realloc)  (THIS_ void FAR* pv, ULONG cb) PURE; \
    STDMETHOD_(void, Free)          (THIS_ void FAR* pv) PURE; \
    STDMETHOD_(ULONG, GetSize)      (THIS_ void FAR* pv) PURE; \
    STDMETHOD_(int, DidAlloc)       (THIS_ void FAR* pv) PURE; \
    STDMETHOD_(void, HeapMinimize)  (THIS) PURE; \
};

extern DBGMEM_Vtbl vtblDBGMEM;

typedef struct _DBGMEM  DBGMEM,  FAR *PDBGMEM;
typedef struct _BLK     BLK,     *PBLK;
typedef struct _BLK UNALIGNED * PUABLK;
typedef struct _BLKTAIL BLKTAIL, *PBLKTAIL;

struct _DBGMEM {
    DBGMEM_Vtbl *       lpVtbl;
    ULONG               cRef;
    LPMALLOC            pmalloc;
    char                szSubsys[16];
    ULONG               ulAllocNum;
    ULONG               ulAllocAt;
    ULONG               ulFailureAt;
    BOOL                fCheckOften;
    BOOL                fUnleakable;
    ULONG               cbVirtual;
    BOOL                fFillRandom;
    int                 cbExtra;
    int                 cbTail;
    PBLK                pblkHead;
#if defined(_WIN32) && defined(_X86_)
    CRITICAL_SECTION    cs;
#endif
};

#define NCALLERS    12

struct _BLK {
    PDBGMEM         pdbgmem;        /* pointer to the allocator */
    PBLK            pblkNext;       /* next link in chain of allocated blocks */
    PBLK            pblkPrev;       /* prev link in chain of allocated blocks */
    ULONG           ulAllocNum;     /* internal allocation number */
    BOOL            fUnleakable;    /* TRUE if leak code should ignore block */
    #if defined(_WIN32) && defined(_X86_)
    FARPROC         pfnCallers[NCALLERS];
    #endif
    PBLKTAIL        pblktail;       /* pointer to block tail */
};

struct _BLKTAIL {
    PBLK            pblk;           /* pointer back to beginning of the block */
};

#define PblkToPv(pblk)          ((LPVOID)((PBLK)(pblk) + 1))
#define PvToPblk(pblk)          ((PBLK)(pv) - 1)
#define PblkClientSize(pblk)    ((ULONG)((char *)(pblk)->pblktail - (char *)PblkToPv(pblk)))
#define PblkAllocSize(pblk)     (PblkClientSize(pblk) + sizeof(BLK) + (pblk)->pdbgmem->cbTail)

#if defined(_WIN32) && defined(_X86_)
#define DBGMEM_EnterCriticalSection(pdbgmem)    \
        EnterCriticalSection(&(pdbgmem)->cs)
#define DBGMEM_LeaveCriticalSection(pdbgmem)    \
        LeaveCriticalSection(&(pdbgmem)->cs)
#else
#define DBGMEM_EnterCriticalSection(pdbgmem)
#define DBGMEM_LeaveCriticalSection(pdbgmem)
#endif

#define INITGUID
#include <initguid.h>

DEFINE_OLEGUID(DBGMEM_IID_IUnknown,     0x00000000L, 0, 0);
DEFINE_OLEGUID(DBGMEM_IID_IMalloc,      0x00000002L, 0, 0);
DEFINE_OLEGUID(DBGMEM_IID_IBaseMalloc,  0x000203FFL, 0, 0);

/* Forward Declarations ----------------------------------------------------- */

BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, char ** pszReason);
BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, char * pszFunc);
STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void * pv);

/* Call Stack (_WIN32) ------------------------------------------------------- */

#if defined(_WIN32) && defined(_X86_)

#ifdef _WIN95
#define dwStackLimit    0x00400000      /*  4MB for Windows 95 */
#else
#define dwStackLimit    0x00010000      /*  64KB for NT */
#endif

void EXPORTDBG __cdecl GetCallStack(DWORD *pdwCaller, int cSkip, int cFind)
{
    DWORD * pdwStack;
    DWORD * pdwStackPrev = (DWORD *)0;
    DWORD   dwCaller;

    __asm mov pdwStack, ebp

    memset(pdwCaller, 0, cFind * sizeof(DWORD));

    while (cSkip + cFind > 0)
    {
        pdwStack = (DWORD *)*pdwStack;

        if (    pdwStack <= (DWORD *)dwStackLimit
            ||  pdwStackPrev >= pdwStack
            ||  IsBadReadPtr(pdwStack, 2 * sizeof(DWORD)))
            break;

        dwCaller = *(pdwStack + 1);

        if (dwCaller <= dwStackLimit)
            break;
        else if (cSkip > 0)
            cSkip -= 1;
        else
        {
            *pdwCaller++ = dwCaller;
            cFind -= 1;

            pdwStackPrev = pdwStack;
        }
    }
}

#endif

/* Virtual Memory Support (_WIN32) ------------------------------------------- */

#if defined(_WIN32) && (defined(_X86_) || defined(_PPC_) || defined(_MIPS_))

#define PAGE_SIZE       4096
#define PvToVMBase(pv)  ((void *)((ULONG)pv & 0xFFFF0000))

BOOL VMValidatePvEx(void *pv, ULONG cbCluster)
{
    void *  pvBase;
    BYTE *  pb;

    pvBase = PvToVMBase(pv);

    pb = (BYTE *)pvBase + sizeof(ULONG);

    while (pb < (BYTE *)pv) {
        if (*pb++ != 0xAD) {
            TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
            return(FALSE);
        }
    }

    if (cbCluster != 1)
    {
        ULONG cb = *((ULONG *)pvBase);
        ULONG cbPad = 0;

        if (cb % cbCluster)
            cbPad = (cbCluster - (cb % cbCluster));

        if (cbPad)
        {
            BYTE *pbMac;

            pb = (BYTE *)pv + cb;
            pbMac = pb + cbPad;

            while (pb < pbMac)
            {
                if (*pb++ != 0xBC)
                {
                    TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been "
                        "overwritten", pv);
                    return(FALSE);
                }
            }
        }
    }

    return(TRUE);
}

void * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
    return VMAllocEx(cb, 1);
}

void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
    ULONG   cbAlloc;
    void *  pvR;
    void *  pvC;
    ULONG   cbPad   = 0;

    // a cluster size of 0 means don't use the virtual allocator.

    AssertSz(cbCluster != 0, "Cluster size is zero.");

    if (cb > 0x100000)
        return(0);

    if (cb % cbCluster)
        cbPad = (cbCluster - (cb % cbCluster));

    cbAlloc = sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
    cbAlloc -= cbAlloc % PAGE_SIZE;
    cbAlloc += PAGE_SIZE;

    pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

    if (pvR == 0)
        return(0);

    pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

    if (pvC != pvR)
    {
        VirtualFree(pvR, 0, MEM_RELEASE);
        return(0);
    }

    *(ULONG *)pvC = cb;

    memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
        (UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

    if (cbPad)
        memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
            (UINT) cbPad);

    return((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}

void EXPORTDBG __cdecl VMFree(void *pv)
{
    VMFreeEx(pv, 1);
}

void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster)
{
    VMValidatePvEx(pv, cbCluster);

    if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
        TrapSz2("VMFreeEx(pv=%08lX): VirtualFree failed (%08lX)",
            pv, GetLastError());
}

void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb)
{
    return VMReallocEx(pv, cb, 1);
}

void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster)
{
    void *  pvNew = 0;
    ULONG   cbCopy;

    VMValidatePvEx(pv, cbCluster);

    cbCopy = *(ULONG *)PvToVMBase(pv);
    if (cbCopy > cb)
        cbCopy = cb;

    pvNew = VMAllocEx(cb, cbCluster);

    if (pvNew)
    {
        MemCopy(pvNew, pv, cbCopy);
        VMFreeEx(pv, cbCluster);
    }

    return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(void *pv)
{
    return VMGetSizeEx(pv, 1);
}

ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG cbCluster)
{
    return(*(ULONG *)PvToVMBase(pv));
}

#endif

/* Virtual Memory Support (WIN16) ------------------------------------------- */

#ifdef WIN16

#define PvToVMBase(pv)  ((void *)((ULONG)pv & 0xFFFF0000))

BOOL VMValidatePvEx(void *pv, ULONG cbCluster)
{
    void *  pvBase;
    BYTE *  pb;

    pvBase = PvToVMBase(pv);

    pb = (BYTE *)pvBase + sizeof(ULONG);

    while (pb < (BYTE *)pv) {
        if (*pb++ != 0xAD) {
            TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
            return(FALSE);
        }
    }

    if (cbCluster != 1)
    {
        ULONG cb = *((ULONG *)pvBase);
        ULONG cbPad = 0;

        if (cb % cbCluster)
            cbPad = (cbCluster - (cb % cbCluster));

        if (cbPad)
        {
            BYTE *pbMac;

            pb = (BYTE *)pv + cb;
            pbMac = pb + cbPad;

            while (pb < pbMac)
            {
                if (*pb++ != 0xBC)
                {
                    TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been "
                        "overwritten", pv);
                    return(FALSE);
                }
            }
        }
    }

    return(TRUE);
}

BOOL VMValidatePv(void *pv)
{
    return VMValidatePvEx(pv, 1);
}

void * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
    return VMAllocEx(cb, 1);
}

void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
    HGLOBAL hGlobal;
    ULONG   cbAlloc;
    ULONG   cbAllocFromSys;
    void *  pvAlloc;
    ULONG   cbPad   = 0;

    if (cb > 0x10000 - sizeof(ULONG))
        return(0);

    if (cb % cbCluster)
        cbPad = (cbCluster - (cb % cbCluster));

    cbAlloc = sizeof(ULONG) + cb + cbPad;

    if (cbAlloc > 0x10000)
        return(0);

#ifdef SIMPLE_MAPI
    hGlobal = GlobalAlloc(GPTR | GMEM_SHARE, cbAlloc);
#else   
    hGlobal = GlobalAlloc(GPTR, cbAlloc);
#endif  

    if (hGlobal == 0)
        return(0);

    cbAllocFromSys = GlobalSize(hGlobal);

    Assert(cbAllocFromSys >= cbAlloc);

    cbAlloc = cbAllocFromSys;

    pvAlloc = GlobalLock(hGlobal);

    if (pvAlloc == 0) {
        GlobalFree(hGlobal);
        return(0);
    }

    Assert(((ULONG)pvAlloc & 0x0000FFFF) == 0);

    *(ULONG *)pvAlloc = cb;

    memset((BYTE *)pvAlloc + sizeof(ULONG), 0xAD,
        (size_t)(cbAlloc - cb - cbPad - sizeof(ULONG)));

    if (cbPad)
        memset((BYTE *)pvAlloc + cbAlloc - cbPad, 0xBC, (size_t) cbPad);

    return((BYTE *)pvAlloc + (cbAlloc - cb - cbPad));
}

void EXPORTDBG __cdecl VMFree(void *pv)
{
    VMFreeEx(pv, 1);
}

void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster)
{
    if (VMValidatePvEx(pv, cbCluster))
    {
        HGLOBAL hGlobal;
        ULONG cb = *(ULONG *)PvToVMBase(pv);

        memset(pv, 0xFE, (size_t)cb);

        hGlobal = (HGLOBAL)((ULONG)pv >> 16);
        GlobalFree(hGlobal);
    }
}

void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb)
{
    return VMReallocEx(pv, cb, 1);
}

void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster)
{
    void *  pvNew = 0;
    ULONG   cbCopy;

    if (VMValidatePvEx(pv, cbCluster)) {
        cbCopy = *(ULONG *)PvToVMBase(pv);
        if (cbCopy > cb)
            cbCopy = cb;

        pvNew = VMAllocEx(cb, cbCluster);

        if (pvNew) {
            MemCopy(pvNew, pv, (size_t)cbCopy);
            VMFreeEx(pv, cbCluster);
        }
    }

    return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(void *pv)
{
    return VMGetSizeEx(pv, 1);
}

ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG ulCluster)
{
    if (VMValidatePvEx(pv, ulCluster))
        return(*(ULONG *)PvToVMBase(pv));

    return(0);
}

#endif

/* Virtual Memory Support (Others) ------------------------------------------ */
/*
 *  The VM Allocators do not currently work on:
 *      ALPHA
 *      MAC
 */
#if defined(MAC) || defined(_ALPHA_)
#define VMAlloc(cb)             0
#define VMAllocEx(cb, ul)       0
#define VMRealloc(pv, cb)       0
#define VMReallocEx(pv, cb, ul) 0
#define VMFree(pv)
#define VMFreeEx(pv, ul)
#define VMGetSize(pv)           0
#define VMGetSizeEx(pv, ul)     0
#endif

/* PblkEnqueue / PblkDequeue ------------------------------------------------ */

void PblkEnqueue(PBLK pblk)
{
    pblk->pblkNext          = pblk->pdbgmem->pblkHead;
    pblk->pblkPrev          = 0;
    pblk->pdbgmem->pblkHead = pblk;

    if (pblk->pblkNext)
        pblk->pblkNext->pblkPrev = pblk;

}

void PblkDequeue(PBLK pblk)
{
    if (pblk->pblkNext)
        pblk->pblkNext->pblkPrev = pblk->pblkPrev;

    if (pblk->pblkPrev)
        pblk->pblkPrev->pblkNext = pblk->pblkNext;
    else
        pblk->pdbgmem->pblkHead  = pblk->pblkNext;
}

/* QueryInterface/AddRef/Release -------------------------------------------- */

STDMETHODIMP DBGMEM_QueryInterface(PDBGMEM pdbgmem, REFIID riid, LPVOID FAR* ppvObj)
{
    if (memcmp(riid, &DBGMEM_IID_IBaseMalloc, sizeof(IID)) == 0) {
        pdbgmem->pmalloc->lpVtbl->AddRef(pdbgmem->pmalloc);
        *ppvObj = pdbgmem->pmalloc;
        return(0);
    }

    if (memcmp(riid, &DBGMEM_IID_IMalloc, sizeof(IID)) == 0 ||
        memcmp(riid, &DBGMEM_IID_IUnknown, sizeof(IID)) == 0) {
        ++pdbgmem->cRef;
        *ppvObj = pdbgmem;
        return(0);
    }

    *ppvObj = NULL; /* OLE requires zeroing [out] parameter */
    return(ResultFromScode(E_NOINTERFACE));
}

STDMETHODIMP_(ULONG) DBGMEM_AddRef(PDBGMEM pdbgmem)
{
    ULONG cRef;

    DBGMEM_EnterCriticalSection(pdbgmem);
    cRef = ++pdbgmem->cRef;
    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(cRef);
}

STDMETHODIMP_(ULONG) DBGMEM_Release(PDBGMEM pdbgmem)
{
    ULONG       cRef;
    LPMALLOC    pmalloc;

    DBGMEM_EnterCriticalSection(pdbgmem);
    cRef = --pdbgmem->cRef;
    DBGMEM_LeaveCriticalSection(pdbgmem);

    if (cRef == 0) {
        DBGMEM_CheckMemFn(pdbgmem, TRUE);
        pmalloc = pdbgmem->pmalloc;
        pdbgmem->lpVtbl = 0;
        #if defined(_WIN32) && defined(_X86_)
        DeleteCriticalSection(&pdbgmem->cs);
        #endif
        pmalloc->lpVtbl->Free(pmalloc, pdbgmem);
        pmalloc->lpVtbl->Release(pmalloc);
    }

    return(cRef);
}

/* IMalloc::Alloc ----------------------------------------------------------- */

STDMETHODIMP_(void FAR *) DBGMEM_Alloc(PDBGMEM pdbgmem, ULONG cb)
{
    PBLK    pblk;
    ULONG   cbAlloc;
    LPVOID  pvAlloc = 0;
    BYTE    bFill   = 0xFA;

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pdbgmem->fCheckOften)
        DBGMEM_CheckMemFn(pdbgmem, FALSE);

    cbAlloc = sizeof(BLK) + cb + pdbgmem->cbTail;

    if (pdbgmem->ulFailureAt != 0)
    {
        if (pdbgmem->ulFailureAt != pdbgmem->ulAllocAt)
            ++pdbgmem->ulAllocAt;
        else
            cbAlloc = 0;
    }

    if (cbAlloc < cb)
        pblk = 0;
    else if (pdbgmem->cbVirtual)
        pblk = VMAllocEx(cbAlloc, pdbgmem->cbVirtual);
    else
        pblk = (PBLK)pdbgmem->pmalloc->lpVtbl->Alloc(pdbgmem->pmalloc, cbAlloc);

    if (pblk) {
        pblk->pdbgmem       = pdbgmem;
        pblk->ulAllocNum    = ++pdbgmem->ulAllocNum;
        pblk->fUnleakable   = FALSE;
        pblk->pblktail      = (PBLKTAIL)((char *)pblk + sizeof(BLK) + cb);

        if (!pdbgmem->cbVirtual)
            *((PUABLK UNALIGNED * )
            &((struct _BLKTAIL UNALIGNED *) pblk->pblktail)->pblk) = pblk;

        PblkEnqueue(pblk);

        #if defined(_WIN32) && defined(_X86_)
        GetCallStack((DWORD *)pblk->pfnCallers, 0, NCALLERS);
        #endif

        if (pdbgmem->fCheckOften)
            DBGMEM_CheckMemFn(pdbgmem, FALSE);

        pvAlloc = PblkToPv(pblk);

        if (pdbgmem->fFillRandom)
            bFill = (BYTE)pblk->ulAllocNum;

        memset(pvAlloc, bFill, (size_t)cb);

        if (pdbgmem->cbExtra)
            memset(pblk->pblktail + 1, 0xAE, pdbgmem->cbExtra * sizeof(ULONG));
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(pvAlloc);
}

/* IMalloc::Realloc --------------------------------------------------------- */

STDMETHODIMP_(void FAR *) DBGMEM_Realloc(PDBGMEM pdbgmem, void FAR* pv, ULONG cb)
{
    ULONG   cbAlloc;
    LPVOID  pvAlloc = 0;
    BYTE    bFill = 0xFA;

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pdbgmem->fCheckOften)
        DBGMEM_CheckMemFn(pdbgmem, FALSE);

    if (pv == 0) {
        TrapSz1("DBGMEM_Realloc(pv=NULL,cb=%ld): IMalloc::Realloc is being used allocate a new memory block.  Explicit use of IMalloc::Alloc is preferred.", cb);
        pvAlloc = DBGMEM_Alloc(pdbgmem, cb);
    } else if (cb == 0) {
        TrapSz1("DBGMEM_Realloc(pv=%08lX,cb=0): IMalloc::Realloc is being used to free a memory block.  Explicit use of IMalloc::Free is preferred.", pv);
        DBGMEM_Free(pdbgmem, pv);
        pvAlloc = 0;
    } else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_Realloc")) {
        PBLK    pblk    = PvToPblk(pv);
        ULONG   cbOld   = PblkClientSize(pblk);
        PBLK    pblkNew;

        PblkDequeue(pblk);

        cbAlloc = sizeof(BLK) + cb + pdbgmem->cbTail;

        if (pdbgmem->ulFailureAt != 0)
        {
            if (pdbgmem->ulFailureAt != pdbgmem->ulAllocAt)
                ++pdbgmem->ulAllocAt;
            else
                cbAlloc = 0;
        }

        if (cbAlloc < cb)
            pblkNew = 0;
        else if (pdbgmem->cbVirtual)
            pblkNew = (PBLK)VMReallocEx(pblk, cbAlloc, pdbgmem->cbVirtual);
        else
            pblkNew = (PBLK)pdbgmem->pmalloc->lpVtbl->Realloc(pdbgmem->pmalloc, pblk, cbAlloc);

        if (pblkNew == 0) {
            PblkEnqueue(pblk);
            pvAlloc = 0;
        } else {
            pblkNew->pblktail = (PBLKTAIL)((char *)pblkNew + sizeof(BLK) + cb);

            if (!pdbgmem->cbVirtual)
                *((PUABLK UNALIGNED * )
                &((struct _BLKTAIL UNALIGNED *) pblkNew->pblktail)->pblk) = pblkNew;

            PblkEnqueue(pblkNew);

            pvAlloc = PblkToPv(pblkNew);

            if (pdbgmem->fFillRandom)
                bFill = (BYTE)pblkNew->ulAllocNum;

            if (cb > cbOld)
                memset((char *)pvAlloc + cbOld, bFill, (size_t)(cb - cbOld));

            if (pdbgmem->cbExtra)
                memset(pblkNew->pblktail + 1, 0xAE, pdbgmem->cbExtra * sizeof(ULONG));
        }
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(pvAlloc);
}

/* IMalloc::Free ------------------------------------------------------------ */

STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void FAR * pv)
{
    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pdbgmem->fCheckOften)
        DBGMEM_CheckMemFn(pdbgmem, FALSE);

    if (pv && DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_Free")) {
        PBLK pblk = PvToPblk(pv);

        PblkDequeue(pblk);

        memset(pblk, 0xDC, (size_t)PblkAllocSize(pblk));

        if (pdbgmem->cbVirtual)
            VMFreeEx(pblk, pdbgmem->cbVirtual);
        else
            pdbgmem->pmalloc->lpVtbl->Free(pdbgmem->pmalloc, pblk);
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* IMalloc::GetSize --------------------------------------------------------- */

STDMETHODIMP_(ULONG) DBGMEM_GetSize(PDBGMEM pdbgmem, void FAR * pv)
{
    ULONG ulResult = (ULONG)(-1);

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pv == 0)
        TrapSz("Although technically not an error, I bet you didn't really want to pass a NULL pointer to IMalloc::GetSize, did you?  I hope you can deal with a size of -1, because that's the offical answer.  Good luck.");
    else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_GetSize"))
        ulResult = PblkClientSize(PvToPblk(pv));

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(ulResult);
}

/* IMalloc::DidAlloc -------------------------------------------------------- */

STDMETHODIMP_(int) DBGMEM_DidAlloc(PDBGMEM pdbgmem, void FAR * pv)
{
    PBLK    pblk;
    char *  pszReason;
    int     iResult = 0;

    DBGMEM_EnterCriticalSection(pdbgmem);

    for (pblk = pdbgmem->pblkHead; pblk; pblk = pblk->pblkNext)
    {
        AssertSz2(DBGMEM_ValidatePblk(pdbgmem,pblk,&pszReason)==TRUE,
                 "Block header (pblk=%08lX) is invalid\n%s",
                 pblk, pszReason);
        if (PblkToPv(pblk) == pv) {
            iResult = 1;
            break;
        }
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);

    return(iResult);
}

/* IMalloc::HeapMinimize ---------------------------------------------------- */

STDMETHODIMP_(void) DBGMEM_HeapMinimize(PDBGMEM pdbgmem)
{
    pdbgmem->pmalloc->lpVtbl->HeapMinimize(pdbgmem->pmalloc);
}

/* DBGMEM_ValidatePblk ------------------------------------------------------ */

BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, char ** pszReason)
{
    #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
    if (IsBadWritePtr(pblk, sizeof(BLK))) {
        *pszReason = "Block header cannot be written to";
        goto err;
    }
    #endif

    if (pblk->pdbgmem != pdbgmem) {
        *pszReason = "Block header does not have correct pointer back to allocator";
        goto err;
    }

    if (pblk->pblkNext) {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (IsBadWritePtr(pblk->pblkNext, sizeof(BLK))) {
            *pszReason = "Block header has invalid next link pointer";
            goto err;
        }
        #endif

        if (pblk->pblkNext->pblkPrev != pblk) {
            *pszReason = "Block header points to a next block which doesn't point back to it";
            goto err;
        }
    }

    if (pblk->pblkPrev) {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (IsBadWritePtr(pblk->pblkPrev, sizeof(BLK))) {
            *pszReason = "Block header has invalid prev link pointer";
            goto err;
        }
        #endif

        if (pblk->pblkPrev->pblkNext != pblk) {
            *pszReason = "Block header points to a prev block which doesn't point back to it";
            goto err;
        }
    } else if (pdbgmem->pblkHead != pblk) {
        *pszReason = "Block header has a zero prev link but the allocator doesn't believe it is the first block";
        goto err;
    }

    if (pblk->ulAllocNum > pdbgmem->ulAllocNum) {
        *pszReason = "Block header has an invalid internal allocation number";
        goto err;
    }

    if (!pdbgmem->cbVirtual) {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (IsBadWritePtr(pblk->pblktail, pdbgmem->cbTail)) {
            *pszReason = "Block header has invalid pblktail pointer";
            goto err;
        }
        #endif

        if (*((PUABLK UNALIGNED * )
            &((struct _BLKTAIL UNALIGNED *) pblk->pblktail)->pblk) != pblk) {
            *pszReason = "Block trailer does not point back to the block header";
            goto err;
        }
    }

    if (pdbgmem->cbExtra) {
        ULONG UNALIGNED * pul = (ULONG UNALIGNED *)(pblk->pblktail + 1);
        int n = pdbgmem->cbExtra;
        for (; --n >= 0; ++pul)
            if (*pul != 0xAEAEAEAE) {
                *pszReason = "Block trailer spiddle-zone has been overwritten";
                goto err;
            }
    }

    return(TRUE);

err:
    return(FALSE);
}

/* DBGMEM_ValidatePv -------------------------------------------------------- */

BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, char * pszFunc)
{
    char *  pszReason;

    if (DBGMEM_DidAlloc(pdbgmem, pv) == 0) {
        TrapSz3("DBGMEM_ValidatePv(subsys=%s,pv=%08lX) [via %s]\nDetected a memory block which was not allocated by this allocator",
            pdbgmem->szSubsys, pv, pszFunc);
        return(FALSE);
    }

    if (DBGMEM_ValidatePblk(pdbgmem,PvToPblk(pv),&pszReason))
        return(TRUE);

    TrapSz4("DBGMEM_ValidatePv(%s,pv=%08lX) [via %s]\n%s",
        pdbgmem->szSubsys, pv, pszFunc, pszReason);

    return(FALSE);
}

/* DBGMEM_ReportLeak -------------------------------------------------------- */

#if defined(_WIN32) && defined(_X86_)
void EXPORTDBG __cdecl DBGMEM_LeakHook(FARPROC pfn)
{
    /* Dummy function so that you can set a breakpoint with command   */
    /* "ln ecx;g", in order to get the debugger to print out the name */
    /* of the function which allocated the leaked memory block        */
}
#endif

void DBGMEM_ReportLeak(PDBGMEM pdbgmem, PBLK pblk)
{
    int i = 0;

    DebugTrace("%s Memory Leak: @%08lX, allocation #%ld, size %ld\n",
        pdbgmem->szSubsys, PblkToPv(pblk), pblk->ulAllocNum, PblkClientSize(pblk));

    #if defined(_WIN32) && defined(_X86_)
    for (i = 0; i < NCALLERS && pblk->pfnCallers[i] != 0; i++) {
        DebugTrace("[%d] %08lX ", i, pblk->pfnCallers[i]);
        DBGMEM_LeakHook(pblk->pfnCallers[i]);
    }
    DebugTrace("\n");
    #endif
}

/* DBGMEM_NoLeakDetectFn ---------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv)
{
    PDBGMEM pdbgmem = (PDBGMEM)pmalloc;

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pv == 0)
        pdbgmem->fUnleakable = TRUE;
    else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_NoLeakDetectFn"))
        PvToPblk(pv)->fUnleakable = TRUE;

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* DBGMEM_SetFailureAtFn ---------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt)
{
    PDBGMEM pdbgmem = (PDBGMEM)pmalloc;

    DBGMEM_EnterCriticalSection(pdbgmem);

    pdbgmem->ulFailureAt = ulFailureAt;

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* DBGMEM_CheckMemFn -------------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_CheckMemFn(void * pmalloc, BOOL fReportOrphans)
{
    PDBGMEM pdbgmem = (PDBGMEM)pmalloc;
    PBLK    pblk;
    int     cLeaks = 0;

    DBGMEM_EnterCriticalSection(pdbgmem);

    for (pblk = pdbgmem->pblkHead; pblk; pblk = pblk->pblkNext) {
        if (!DBGMEM_ValidatePv(pdbgmem, PblkToPv(pblk), "DBGMEM_CheckMemFn"))
            break;

        if (fReportOrphans && !pdbgmem->fUnleakable && !pblk->fUnleakable) {
            DBGMEM_ReportLeak(pdbgmem, pblk);
            cLeaks += 1;
        }
    }

    #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
    if (fAssertLeaks == -1)
    {
        fAssertLeaks = GetPrivateProfileIntA(szSectionDebug, szKeyAssertLeaks,
            0, szDebugIni);
    }
    #endif

    if (cLeaks > 0)
    {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (fAssertLeaks)
        {
            TrapSz3("DBGMEM detected %d memory leak%s in subsystem %s",
                cLeaks, cLeaks == 1 ? "" : "s", pdbgmem->szSubsys);
        }
        else
        {
            TraceSz3("DBGMEM detected %d memory leak%s in subsystem %s",
                cLeaks, cLeaks == 1 ? "" : "s", pdbgmem->szSubsys);
        }
        #else
        TraceSz3("DBGMEM detected %d memory leak%s in subsystem %s",
            cLeaks, cLeaks == 1 ? "" : "s", pdbgmem->szSubsys);
        #endif
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* vtblDBGMEM --------------------------------------------------------------- */

DBGMEM_Vtbl BASED_DEBUG vtblDBGMEM =
{
    VTABLE_FILL
    DBGMEM_QueryInterface,
    DBGMEM_AddRef,
    DBGMEM_Release,
    DBGMEM_Alloc,
    DBGMEM_Realloc,
    DBGMEM_Free,
    DBGMEM_GetSize,
    DBGMEM_DidAlloc,
    DBGMEM_HeapMinimize
};

/* DBGMEM_EncapsulateFn ----------------------------------------------------- */

void * EXPORTDBG __cdecl DBGMEM_EncapsulateFn(void * pvmalloc, char *pszSubsys, BOOL fCheckOften)
{
    LPMALLOC    pmalloc = (LPMALLOC)pvmalloc;
    PDBGMEM     pdbgmem;
    LPMALLOC    pmallocBase;
    ULONG       cbVirtual = 0;
    BOOL        fFillRandom = FALSE;
    HRESULT     hr;

    hr = pmalloc->lpVtbl->QueryInterface(pmalloc, &DBGMEM_IID_IBaseMalloc, &pmallocBase);
    if (hr) {
        pmallocBase = pmalloc;
        pmallocBase->lpVtbl->AddRef(pmallocBase);
    }

    pdbgmem = (PDBGMEM)pmallocBase->lpVtbl->Alloc(pmallocBase, sizeof(DBGMEM));

    if (pdbgmem == 0) {
        TrapSz("DBGMEM: Failed trying to allocate memory for the first time!\n");
        return(pmallocBase);
    }

    #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
    cbVirtual = GetPrivateProfileIntA(szSectionDebug, szKeyUseVirtual, 0,
        szDebugIni);

    if (cbVirtual != 0 && cbVirtual != 1 && cbVirtual != 4)
        cbVirtual = 1;

    if (cbVirtual)
        DebugTrace("DBGMEM: Subsystem '%s' using virtual memory allocator -"
            " align %d.\n", pszSubsys, cbVirtual);

    if (!fCheckOften)
        fCheckOften = GetPrivateProfileIntA(szSectionDebug, szKeyCheckOften, 0,
            szDebugIni);

    fFillRandom = GetPrivateProfileIntA(szSectionDebug, szKeyFillRandom, 0,
        szDebugIni);

    #endif

    memset(pdbgmem, 0, sizeof(DBGMEM));

    pdbgmem->lpVtbl         = &vtblDBGMEM;
    pdbgmem->cRef           = 1;
    pdbgmem->pmalloc        = pmallocBase;
    pdbgmem->fCheckOften    = fCheckOften;
    pdbgmem->fUnleakable    = FALSE;
    pdbgmem->cbVirtual      = cbVirtual;
    pdbgmem->fFillRandom    = fFillRandom;
    pdbgmem->cbExtra        = 0;
    pdbgmem->ulAllocAt      = 1L;
    pdbgmem->ulFailureAt    = 0L;

    if (pdbgmem->cbVirtual)
        pdbgmem->cbTail     = 0;
    else
        pdbgmem->cbTail     = sizeof(BLKTAIL) + pdbgmem->cbExtra * sizeof(ULONG);

    lstrcpyn(pdbgmem->szSubsys, pszSubsys, sizeof(pdbgmem->szSubsys));

    #if defined(_WIN32) && defined(_X86_)
    InitializeCriticalSection(&pdbgmem->cs);
    #endif

    return(pdbgmem);
}

/* DBGMEM_ShutdownFn -------------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_ShutdownFn(void *pvmalloc)
{
    LPMALLOC    pmalloc = (LPMALLOC)pvmalloc;
    PDBGMEM     pdbgmem = (PDBGMEM)pvmalloc;
    LPMALLOC    pmallocBase;
    HRESULT     hr;

    hr = pmalloc->lpVtbl->QueryInterface(pmalloc, &DBGMEM_IID_IBaseMalloc, &pmallocBase);
    if (hr == 0) {
        pmallocBase->lpVtbl->Release(pmallocBase);
        if (pdbgmem->cRef != 1) {
            TrapSz2("DBGMEM_Shutdown: Expected a cRef of 1; instead have %ld for %s",
                pdbgmem->cRef, pdbgmem->szSubsys);
            pdbgmem->cRef = 1;
        }
    }

    pmalloc->lpVtbl->Release(pmalloc);
}

/* -------------------------------------------------------------------------- */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\bitmap.c ===
/*
 -  B I T M A P . C
 -
 *  Purpose:
 *      Bitmap and Listbox support functions for InBox in sample mail client.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <windowsx.h>
#ifdef _WIN32
#include <objerror.h>
#include <objbase.h>
#endif
#ifdef WIN16
#include <compobj.h>
#endif
#include <mapiwin.h>
#include <mapidbg.h>
#include <mapi.h>
#include <mapix.h>
#include "bitmap.h"
#include "client.h"

// Fonts to use in dialogs

#ifdef _WIN32
#define SHELL_FONT "MS Shell Dlg"
#define SHELL_FONT_SIZE 8
#else
#define SHELL_FONT "MS Sans Serif"
#define SHELL_FONT_SIZE 8
#endif

/*
 *  globals
 */
 
DWORD   rgbWindowColor = 0xFF000000;    // variables for the current
DWORD   rgbHiliteColor = 0xFF000000;    // system color settings.
DWORD   rgbWindowText  = 0xFF000000;    // on a WM_SYSCOLORCHANGE
DWORD   rgbHiliteText  = 0xFF000000;    // we check to see if we need
DWORD   rgbGrayText    = 0xFF000000;    // to reload our bitmap.
DWORD   rgbDDWindow    = 0xFF000000;    //
DWORD   rgbDDHilite    = 0xFF000000;    // 0xFF000000 is an invalid RGB

// an array of integers containing the tab stops, in pixels. The tab 
// stops must be sorted in ascending order; back tabs are not allowed. 

int     rgTabs[] = { 2, 28, 135, 292 };
int     dxbmpLB, dybmpLB;   // dx and dy of listbox bmps

HDC     hdcMemory = 0;      // hdc to hold listbox bitmaps (for speed)
HBITMAP hbmpOrigMemBmp = 0; // original null bitmap in hdcMemory
HBITMAP hbmpLB = 0;         // cached listbox bitmaps
HFONT   hfontLB = 0;        // hfont of LB
HWND    hwndLB = 0;         // hwnd of LB

FONTSTYLE fontStyle = { SHELL_FONT_SIZE, FW_NORMAL, 0, TEXT(SHELL_FONT) };

extern HANDLE hInst;


/*
 -  DeInitBmps
 -  
 *  Purpose:
 *      cleans up LB hfonts, hdc, and hbmps
 */
 
VOID DeInitBmps(VOID)
{
    DeleteBitmapLB();
    if(hdcMemory)
    {
        DeleteDC(hdcMemory);
        hdcMemory = 0;
    }

    if(hfontLB)
    {
        SetWindowFont(hwndLB, GetStockObject(SYSTEM_FONT), FALSE);
        DeleteObject(hfontLB);
        hfontLB = 0;
    }
}


/*
 -  SetLBFont
 -  
 *  Purpose:
 *      creates a font from the global fontStyle
 *      sets global hfontLB to new font and WM_SETFONTs
 *      the hwndLB to the new font
 */
 
VOID SetLBFont(VOID)
{
    LOGFONT lf;

    lf.lfHeight = fontStyle.lfHeight;
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = fontStyle.lfWeight;
    lf.lfItalic = fontStyle.lfItalic;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
    lstrcpy(lf.lfFaceName, fontStyle.lfFaceName);

    hfontLB = CreateFontIndirect(&lf);
    if(hfontLB)
        SetWindowFont(hwndLB, hfontLB, FALSE);        
}


/*
 -  InitBmps
 -  
 *  Purpose:
 *      inits listbox globals, creates listbox
 *  
 *  Arguments:
 *      HWND    main hwnd of app (parent of LB)
 *  
 *  Returns:
 *      TRUE - success; FALSE - failed
 */
 
BOOL InitBmps(HWND hwnd, int idLB)
{
    HDC     hdcScreen;
    HBITMAP hbmpTemp;

    hdcScreen = GetDC(0);
    if(!hdcScreen)
        goto CantInit;
    hdcMemory = CreateCompatibleDC(hdcScreen);
    if(!hdcMemory)
        goto ReleaseScreenDC;

    hbmpTemp = CreateCompatibleBitmap(hdcMemory, 1, 1);
    if(!hbmpTemp)
        goto ReleaseMemDC;
    hbmpOrigMemBmp = SelectObject(hdcMemory, hbmpTemp); // get hbmp of NULL
    if(!hbmpOrigMemBmp)                                 // bmp for hdcMemory
        goto ReleaseMemDC;                              // for when we delete
    SelectObject(hdcMemory, hbmpOrigMemBmp);            // it later in life
    DeleteObject(hbmpTemp);
    ReleaseDC(0, hdcScreen);

    SetRGBValues();     // set the global RGB values
    LoadBitmapLB();     // load the bmps into hdcMemory

    hwndLB = GetDlgItem(hwnd, idLB);
    
    SetLBFont();    // set the font of our listbox
    return TRUE;

/* Error recovery exits */
ReleaseMemDC:
    DeleteDC(hdcMemory);
    hdcMemory = 0;

ReleaseScreenDC:
    ReleaseDC(0, hdcScreen);

CantInit:
    return FALSE;
}


/*
 -  SetRGBValues
 -  
 *  Purpose:
 *      To set various system colors in static variables.  Called at
 *      init time and when system colors change.
 */
 
VOID SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}


/*
 -  MeasureItem
 -  
 *  Purpose:
 *      called from msg WM_MEASUREITEM: returns max dy of listbox items
 *  
 *  Arguments:
 *      HWND        hwnd of main window
 *      pmis        measureitemstruct from WM_MEASUREITEM call
 */
 
VOID MeasureItem(HANDLE hwnd, LPMEASUREITEMSTRUCT pmis)
{
    HDC        hDC = GetDC(hwnd);
    HANDLE     hFont = hfontLB;
    TEXTMETRIC TM;

    if(!hFont)
        hFont = GetStockObject(SYSTEM_FONT);
    hFont = SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &TM);
    SelectObject(hDC, hFont);
    ReleaseDC(hwnd, hDC);

    // set the height to be max of (dyfont or dybitmap)
    pmis->itemHeight = max(dybmpLB, TM.tmHeight);
}


/*
 -  OutTextFormat
 -  
 *  Purpose:
 *      to parse the string in the listbox and draw it accordingly:
 *      first char == chBOLD: line is bold
 *      first char == chUNDERLINE: line is underlined (can follow chBOLD)
 *      char == chTAB: go to next column in rgTabs
 *      '/001#': bitblt that numbered bitmap.
 *      otherwise, outtext the line
 *  
 *  Arguments:
 *      pDI     from DrawItem from WM_DRAWITEM msg
 */
 
VOID OutTextFormat(LPDRAWITEMSTRUCT pDI)
{
    TCHAR   szDateRec[32];
    TCHAR   szItem[256];
    TCHAR   szTemp[4];
    TCHAR   szDots[4] = {"..."};
    TCHAR   *pch;
    INT     nT;
    INT     nTab = 0;           // current tab we is on
    INT     nBmp;               // index of envelope bitmap
    HFONT   hfDef = 0;
    HFONT   hfOld = 0;          // bold or underlined font
    TCHAR   *pchBuff = NULL;
    LPMSGID lpMsgId = (LPMSGID)pDI->itemData;

    pch = szItem;

    // Format a string from the info in lpMsgNode
    // First, calculate the index to the desired bitmap
    
    nBmp = ((!lpMsgId->fUnRead) * 2) + ((!!lpMsgId->fHasAttach) * 1 );

    // Convert our received date and build string
    
    ConvertDateRec (lpMsgId->lpszDateRec, szDateRec);

    // Limit our subject size
    
    szTemp[0] = '\0';
    
    if(lpMsgId->lpszSubject && (lstrlen(lpMsgId->lpszSubject) > 32))
    {
        memcpy(szTemp, &lpMsgId->lpszSubject[28], 4);
        memcpy(&lpMsgId->lpszSubject[28], szDots, 4);
    }
    
    wsprintf(szItem, "\001%d\t%s\t%s\t%s", nBmp, 
            (lpMsgId->lpszFrom ? lpMsgId->lpszFrom : ""),
            (lpMsgId->lpszSubject ? lpMsgId->lpszSubject : ""),
            szDateRec);

    // erase background
    ExtTextOut(pDI->hDC, 0, 0, ETO_OPAQUE, &pDI->rcItem, NULL, 0, NULL);

    // underline or bold this line?  Only check first & second char
    if(*pch == chBOLD || *pch == chUNDERLINE)
    {
        LOGFONT     lf;

        hfOld = GetWindowFont(pDI->hwndItem);
        if(!hfOld)
            hfOld = GetStockObject(SYSTEM_FONT);
        GetObject(hfOld, sizeof(lf), &lf);

        if(*pch == chBOLD)
        {
            lf.lfWeight = FW_BOLD;
            pch++;
        }
        if(*pch == chUNDERLINE)
        {
            lf.lfUnderline = TRUE;
            pch++;
        }

        hfDef = CreateFontIndirect(&lf);
        if(hfDef)
            SelectObject(pDI->hDC, hfDef);
    }

    // selected or nonselected bmps?
    nT = (ODS_SELECTED & pDI->itemState) ? (BMWIDTH * NUMBMPS) : 0;

    // parse the string
    for(; *pch; pch++)
    {
        TCHAR   *pchT;
        RECT    rc;

        if(*pch == chBITMAP)     // do we have a bitmap?
        {
            ++pch;
            // draw the bitmap
            BitBlt(pDI->hDC, pDI->rcItem.left + rgTabs[nTab],
                pDI->rcItem.top, BMWIDTH, BMHEIGHT, hdcMemory,
                nT + (int)(*pch - TEXT('0')) * BMWIDTH, 0, SRCCOPY);
            continue;
        }

        if(*pch == chTAB)    // move to next tabstop?
        {
            nTab++;
            continue;
        }

        pchT = pch;     // find end of the column of text
        while(*pchT && (*pchT != chTAB))
            pchT++;

        // set rect to drawtext in
        SetRect(&rc, pDI->rcItem.left + rgTabs[nTab], pDI->rcItem.top, 
            pDI->rcItem.right, pDI->rcItem.bottom);

        // draw the text
        ExtTextOut(pDI->hDC, rc.left, rc.top + 1, ETO_OPAQUE | ETO_CLIPPED,
            &rc, pch, pchT - pch, NULL);
        pch = pchT - 1; // move to end of this column
    }

    if(hfDef)   // delete underline or bold font if we created it
    {
        SelectObject(pDI->hDC, hfOld);
        DeleteObject(hfDef);
    }

    if(szTemp[0] != '\0')
    {
        memcpy(&lpMsgId->lpszSubject[28], szTemp, 4);
    }
}


/*
 -  DrawItem
 -
 *  Purpose:
 *      Handles WM_DRAWITEM for both drive and directory listboxes.
 *
 *  Parameters:
 *      pDI     LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message.
 */
 
VOID DrawItem(LPDRAWITEMSTRUCT pDI)
{
    COLORREF    crText, crBack;

    if((int)pDI->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pDI->itemAction)
    {
        if(pDI->itemState & ODS_SELECTED)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pDI->hDC, rgbHiliteText);
            crBack = SetBkColor(pDI->hDC, rgbHiliteColor);
        }

        // parse and spit out bmps and text
        OutTextFormat(pDI);

        // Restore original colors if we changed them above.
        if(pDI->itemState & ODS_SELECTED)
        {
            SetTextColor(pDI->hDC, crText);
            SetBkColor(pDI->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pDI->itemAction) || (ODS_FOCUS & pDI->itemState))
        DrawFocusRect(pDI->hDC, &pDI->rcItem);
}


/*
 -  ConvertDateRec
 -
 *  Purpose:
 *      To convert the lpszDateReceived field of a message to a
 *      more paletable display format; namely: mm/dd/yy hh:mmAM.
 *
 *  Parameters:
 *      lpszDateRec         - Original format
 *      lpszDateDisplay     - Display format
 */

VOID ConvertDateRec (LPSTR lpszDateRec, LPSTR lpszDateDisplay)
{
    char  szDateTmp[32];
    LPSTR lpszYear;
    LPSTR lpszMonth;
    LPSTR lpszDay;
    LPSTR lpszHour;
    LPSTR lpszMinute;
    int nHour;
    static char szFoo[2][3] =
    {"AM", "PM"};

    *lpszDateDisplay = 0;
    if (!lpszDateRec || !*lpszDateRec)
        return;

    lstrcpy(szDateTmp, lpszDateRec);

    lpszYear = strtok (szDateTmp, "/ :");
    lpszMonth = strtok (NULL, "/ :");
    lpszDay = strtok (NULL, "/ :");
    lpszHour = strtok (NULL, "/ :");
    lpszMinute = strtok (NULL, "/ :");

    if(lpszHour)
        nHour = atoi (lpszHour);
    else
        nHour = 0;

    if (nHour > 12)
        wsprintf (lpszHour, "%d", nHour - 12);

    wsprintf (lpszDateDisplay, "%s/%s/%s %s:%s%s", lpszMonth,
        (lpszDay ? lpszDay : ""),
        (lpszYear ? lpszYear : ""),
        (lpszHour ? lpszHour : ""),
        (lpszMinute ? lpszMinute : ""),
        szFoo[(nHour > 11 ? 1 : 0)]);
}


/*
 *  RgbInvertRgb
 *  
 *  Purpose:
 *      To reverse the byte order of the RGB value (for file format
 *  
 *  Arguments:
 *  
 *  Returns:
 *      New color value (RGB to BGR)
 */
 
#define RgbInvertRgb(_rgbOld) \
    (DWORD)RGB(GetBValue(_rgbOld), GetGValue(_rgbOld), GetRValue(_rgbOld))


/*
 *  LoadAlterBitmap (mostly stolen from commdlg)
 *  
 *  Purpose:
 *      Loads the IDB_ENVELOPE bitmap and gives all the pixels that are
 *      RGBREPLACE a new color.
 *
 *  Assumption:
 *      This function will work on one bitmap during it's lifetime.
 *      (Due to the fact that it finds RGBREPLACE once and then
 *      operates on that offset whenever called again because under NT,
 *      it appears that the bitmap is cached, so the second time you go
 *      looking for RGBREPLACE, it won't be found.) You could load the
 *      resource, copy it, then modify the copy as a workaround. But I
 *      chose the cheap way out as I will only ever modify one bmp.
 *  
 *  Arguments:
 *      rgbInstead  rgb value to replace defined RGBREPLACE with
 *  
 *  Returns:
 *      NULL - failed or hbmp of new modified bitmap
 */

HBITMAP LoadAlterBitmap(DWORD rgbInstead)
{
    HANDLE              hbmp = 0;
    LPBITMAPINFOHEADER  qbihInfo;
    HDC                 hdcScreen;
    HRSRC               hresLoad;
    HGLOBAL             hres;
    LPBYTE              qbBits;
    DWORD               rgbReplace = 0;
    DWORD               *rgdw = NULL;
    DWORD               *lpdw = NULL;
    ULONG               cb = 0;
    
    if (rgbInstead)
        rgbReplace = RGBREPLACE;

    // load our listbox bmps resource
    hresLoad = FindResource(hInst, MAKEINTRESOURCE(IDB_ENVELOPE), RT_BITMAP);
    if(hresLoad == 0)
        return 0;
    hres = LoadResource(hInst, hresLoad);
    if(hres == 0)
        return 0;

    rgbReplace = RgbInvertRgb(rgbReplace);
    rgbInstead = RgbInvertRgb(rgbInstead);
    qbihInfo = (LPBITMAPINFOHEADER)LockResource(hres);

    // Skip over the header structure
    qbBits = (LPBYTE)(qbihInfo + 1);

    // Skip the color table entries, if any
    qbBits += (1 << (qbihInfo->biBitCount)) * sizeof(RGBQUAD);

    // Copy the resource into writable memory so we can
    // munge the color table to set our background color
    cb = (ULONG)(qbBits - (LPBYTE)qbihInfo) + qbihInfo->biSizeImage;
    rgdw = (DWORD *)GlobalAllocPtr(GMEM_MOVEABLE, cb);
    
    CopyMemory((LPVOID)rgdw, (LPVOID)qbihInfo, cb);
    
    // find the color to replace in the color table
    for(lpdw = (DWORD *)((LPBYTE)rgdw + qbihInfo->biSize); ; lpdw++)
    {
        if(*lpdw == rgbReplace)
            break;
    }

    // replace that color value with our new one
    *lpdw = (DWORD)rgbInstead;

    // Create a color bitmap compatible with the display device
    hdcScreen = GetDC(0);
    if(hdcScreen != 0)
    {
        hbmp = CreateDIBitmap(hdcScreen, (LPBITMAPINFOHEADER)rgdw, 
                (LONG)CBM_INIT, qbBits, (LPBITMAPINFO) rgdw, DIB_RGB_COLORS);
        ReleaseDC(0, hdcScreen);
    }

    UnlockResource(hres);
    FreeResource(hres);

    GlobalFreePtr(rgdw);
    
    return hbmp;
}


/*
 *  DeleteBitmapLB
 *  
 *  Purpose:
 *      Get rid of hbmpLB, if it exists
 */
 
VOID DeleteBitmapLB(VOID)
{
    if(hbmpOrigMemBmp)
    {
        SelectObject(hdcMemory, hbmpOrigMemBmp);
        if(hbmpLB != 0)
        {
            DeleteObject(hbmpLB);
            hbmpLB = 0;
        }
    }
}


/*
 *  LoadBitmapLB (mostly stolen from commdlg)
 *  
 *  Purpose:
 *      Creates the listbox bitmap. If an appropriate bitmap
 *      already exists, it just returns immediately.  Otherwise, it
 *      loads the bitmap and creates a larger bitmap with both regular
 *      and highlight colors.
 *
 *  Returns:
 *      TRUE - success; FALSE - failure
 */
 
BOOL LoadBitmapLB(VOID)
{
    BITMAP  bmp;
    HANDLE  hbmp, hbmpOrig;
    HDC     hdcTemp;
    BOOL    bWorked = FALSE;

    // check for existing bitmap and validity
    if( (hbmpLB != 0) &&
        (rgbWindowColor == rgbDDWindow) &&
        (rgbHiliteColor == rgbDDHilite))
    {
        if(SelectObject(hdcMemory, hbmpLB))
            return TRUE;
    }

    DeleteBitmapLB();

    rgbDDWindow = rgbWindowColor;
    rgbDDHilite = rgbHiliteColor;

    if(!(hdcTemp = CreateCompatibleDC(hdcMemory)))
        goto LoadExit;

    if(!(hbmp = LoadAlterBitmap(rgbWindowColor)))
        goto DeleteTempDC;

    GetObject(hbmp, sizeof(BITMAP), (LPBYTE) &bmp);
    dybmpLB = bmp.bmHeight;
    dxbmpLB = bmp.bmWidth;

    hbmpOrig = SelectObject(hdcTemp, hbmp);

    hbmpLB = CreateDiscardableBitmap(hdcTemp, dxbmpLB*2, dybmpLB);
    if(!hbmpLB)
        goto DeleteTempBmp;

    if(!SelectObject(hdcMemory, hbmpLB))
    {
        DeleteBitmapLB();
        goto DeleteTempBmp;
    }

    BitBlt(hdcMemory, 0, 0, dxbmpLB, dybmpLB,   // copy unhighlited bmps
           hdcTemp, 0, 0, SRCCOPY);             // into hdcMemory
    SelectObject(hdcTemp, hbmpOrig);

    DeleteObject(hbmp);

    if(!(hbmp = LoadAlterBitmap(rgbHiliteColor)))
        goto DeleteTempDC;

    hbmpOrig = SelectObject(hdcTemp, hbmp);
    BitBlt(hdcMemory, dxbmpLB, 0, dxbmpLB, dybmpLB, // copy highlited bmps
        hdcTemp, 0, 0, SRCCOPY);                    // into hdcMemory
    SelectObject(hdcTemp, hbmpOrig);

    bWorked = TRUE;

DeleteTempBmp:
    DeleteObject(hbmp);
DeleteTempDC:
    DeleteDC(hdcTemp);
LoadExit:
    return bWorked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\pvalloc.c ===
/*
 -  P V A L L O C . C
 -
 *  Copyright (C) 1995 Microsoft Corporation
 *  Purpose:
 *      Implementation of a chained memory manager.
 *
 */

#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <pvalloc.h>

#undef _PVALLOC_LOG

#ifdef _PVALLOC_LOG
static CB       cbTotalAlloc    = 0;
static CB       ulTotalBlockNum = 0;
#endif




/*
 -  PvAlloc
 -
 *  Purpose:
 *      Allocates a chunk of memory on the global heap.
 *
 *  Parameters:
 *      cbSize          - Count of bytes requested.
 *
 *  Returns:
 *      lpv             - Pointer to the allocated memory
 *
 */

PV PvAlloc(CB cbSize)
{
    PV      lpv         = pvNull;
    HANDLE  hMem;
    PPVINFO ppvinfo;
#ifdef _PVALLOC_LOG
    char    szFileName[80];
    LPSTR   lpszTemp    = NULL;
    FILE    *pFile      = NULL;
    char    szBuff[128];
#endif

    /* Make sure allocations are in multiples of 4 */

    if(cbSize < 4)
        cbSize = 4;
    else if(cbSize & 3)
        cbSize += 4 - (cbSize & 3);

    /* Allocate the block */

    hMem = GlobalAlloc(GMEM_MOVEABLE, cbSize + sizeof(PVINFO));
    if(hMem)
    {
        ppvinfo = (PPVINFO)GlobalLock(hMem);
        ppvinfo->hMem    = hMem;
        ppvinfo->lpvNext = pvNull;
        ppvinfo->lpvBuf  = ((PB)ppvinfo) + sizeof(PVINFO);
#ifdef _PVALLOC_LOG
        ppvinfo->cbSize  = cbSize;
        ulTotalBlockNum++;
        ppvinfo->ulBlockNum = ulTotalBlockNum;
        cbTotalAlloc += cbSize;
        
        // log to file
        lpszTemp = getenv("TEMP");

        if(lpszTemp)
            strcpy(szFileName, lpszTemp);
        else
            strcpy(szFileName, "c:\\temp");

        strcat(szFileName, "\\pvalloc.log");

        
        pFile = fopen(szFileName,"a");
        if (pFile == NULL)     
            goto NoFile;      
//           return NULL;

        fprintf(pFile, "Block: \t%lu\tPvAlloc: %ld Bytes\t\tTotal: %ld Bytes\n",
                 ulTotalBlockNum, cbSize, cbTotalAlloc);

        if (pFile)
            fclose(pFile);
        
        // log to comm port
        wsprintf(szBuff,"Block: \t%lu\tPvAlloc: %ld Bytes\t\tTotal: %ld Bytes\n",
                 ulTotalBlockNum, cbSize, cbTotalAlloc);
        OutputDebugString(szBuff);
                        
NoFile:                           

#ifdef _WIN32
        memset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#else
        _fmemset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#endif  /* _WIN32 */

#endif  /* _PVALLOC_LOG */
        lpv = ppvinfo->lpvBuf;
    }

    return lpv;
}

/*
 -  PvAllocMore
 -
 *  Purpose:
 *      Allocates a chunk of memory and chains it to a parent block.
 *
 *  Parameters:
 *      cbSize          - Count of additional bytes to allocate
 *      lpvParent       - Pointer to parent in memory chain
 *
 *  Returns:
 *      lpv             - Pointer to the allocated memory
 *
 */

PV PvAllocMore(CB cbSize, PV lpvParent)
{
    PV          lpvStep = lpvParent;
    PV          lpv     = pvNull;
    PPVINFO     ppvinfoMore;
    HANDLE      hMem;
    PPVINFO     ppvinfo;

    /* Step to the last link */
    do
    {
        ppvinfoMore = (PPVINFO)(((PB)lpvStep) - sizeof(PVINFO));
        lpvStep = ppvinfoMore->lpvNext;
    }
    while(ppvinfoMore->lpvNext != pvNull);

    // beginning of section that was taken from PvAlloc

    if(cbSize < 4)
        cbSize = 4;
    else if(cbSize & 3)
        cbSize += 4 - (cbSize & 3);


    hMem = GlobalAlloc(GMEM_MOVEABLE, cbSize + sizeof(PVINFO));
    if(hMem)
    {
        ppvinfo = (PPVINFO)GlobalLock(hMem);
        ppvinfo->hMem       = hMem;
        ppvinfo->lpvNext    = pvNull;
        ppvinfo->lpvBuf     = ((PB)ppvinfo) + sizeof(PVINFO);
#ifdef _PVALLOC_LOG
        ppvinfo->cbSize     = cbSize;
        ppvinfo->ulBlockNum = ppvinfoMore->ulBlockNum;
        cbTotalAlloc += cbSize;

#ifdef _WIN32
        memset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#else
        _fmemset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#endif

#endif
        lpv = ppvinfo->lpvBuf;
    }
    else
        return lpv;
        
    // end of section taken from pvalloc

#ifdef _WIN32
        memset(lpv, 0xbb, (size_t)cbSize);
#else
        _fmemset(lpv, 0xbb, (size_t)cbSize);
#endif  /* _WIN32 */

    ppvinfoMore->lpvNext = lpv;

    return lpv;
}



/*
 -  PvFree
 -
 *  Purpose:
 *      This function frees memory allocated by PvAlloc or PvAllocMore.
 *      After the call, the pointer memory will be invalid and should
 *      not be referenced again.
 *      When memory is allocated by PvAlloc and PvAllocMore, which can
 *      contain several levels of pointers, all the application needs to
 *      do to free the entire structure is call this routine with the
 *      base pointer returned by the PvAlloc call.
 *
 *  Parameters:
 *      lpv             - Pointer to memory to be freed.
 *
 *  Returns:
 *      Void
 *
 */

BOOL PvFree(PV lpv)
{
    PPVINFO ppvinfo;
#ifdef _PVALLOC_LOG
    CB      cbSize;
    CB      ulBlockNum;
    FILE    *pFile  = NULL;
    CB      cbFree  = 0;
    CB      cbTotalBeforeFree = cbTotalAlloc;
    char    szFileName[80];
    LPSTR   lpszTemp    = NULL;
    char    szBuff[128];
#endif

    if(!lpv)
        return 0;

    ppvinfo = (PPVINFO)(((PB)lpv) - sizeof(PVINFO));

    while(ppvinfo)
    {
        lpv = ppvinfo->lpvNext;

#ifdef _PVALLOC_LOG
        cbSize      = ppvinfo->cbSize;
        cbFree      += ppvinfo->cbSize;
        ulBlockNum  = ppvinfo->ulBlockNum;

#ifdef _WIN32
        memset(ppvinfo->lpvBuf, 0xcc, (size_t)ppvinfo->cbSize);
#else
        _fmemset(ppvinfo->lpvBuf, 0xcc, (size_t)ppvinfo->cbSize);
#endif  /* _WIN32 */

#endif  /* _PVALLOC_LOG */

        if(GlobalUnlock(ppvinfo->hMem))
            goto err;  // Our lock count is non-zero

        if(GlobalFree(ppvinfo->hMem))
            goto err;  // Failure

#ifdef _PVALLOC_LOG
        cbTotalAlloc -= cbSize;
#endif

        if(lpv)
            ppvinfo = (PPVINFO)(((PB)lpv) - sizeof(PVINFO));
        else
            break;
    }


#ifdef _PVALLOC_LOG
    
    if((cbTotalBeforeFree - cbTotalAlloc) != cbFree)
       goto err;
       
    // log to file
    lpszTemp = getenv("TEMP");

    if(lpszTemp)
        strcpy(szFileName, lpszTemp);
    else
        strcpy(szFileName, "c:\\temp");

    strcat(szFileName, "\\pvalloc.log");
        
    pFile = fopen(szFileName,"a");
       
    if (pFile == NULL)
       goto err;

    fprintf(pFile, "Block: \t%lu\t\t***PvFree***,  Freeing  %lu Bytes(Alloc and AllocMore)\tUnFreed: %ld Bytes\n",
                    ulBlockNum, cbFree, cbTotalAlloc);
    if (pFile)
        fclose(pFile);

     // log to comm port
    wsprintf(szBuff,"Block: \t%lu\t\t***PvFree***,  Freeing  %lu Bytes(Alloc and AllocMore)\tUnFreed: %ld Bytes\n",
                    ulBlockNum, cbFree, cbTotalAlloc);
    OutputDebugString(szBuff);

#endif  /* _PVALLOC_LOG */

    return 0; // Success!

err:
#ifdef _PVALLOC_LOG

    // find file to open
    lpszTemp = getenv("TEMP");

    if(lpszTemp)
        strcpy(szFileName, lpszTemp);
    else
        strcpy(szFileName, "c:\\temp");

    strcat(szFileName, "\\pvalloc.log");

        
    pFile = fopen(szFileName,"a");

    if (pFile == NULL)
       return 1;

    fprintf(pFile, "Block: %lu Failure freeing: %ld Bytes\tUnFreed: %ld Bytes\n",
             ulBlockNum, cbSize, cbTotalAlloc);
    if (pFile)
        fclose(pFile);

#endif  /* _PVALLOC_LOG */

    return 1; // Failure!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\smapi.h ===
/*
 -  S M A P I . H
 -
 *  Purpose:
 *      Header file for Simple MAPI definitions.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPI_H
#include <mapi.h>
#endif

extern HINSTANCE    hlibMAPI;

extern LPMAPILOGON lpfnMAPILogon;
extern LPMAPILOGOFF lpfnMAPILogoff;
extern LPMAPISENDMAIL lpfnMAPISendMail;
extern LPMAPISENDDOCUMENTS lpfnMAPISendDocuments;
extern LPMAPIFINDNEXT lpfnMAPIFindNext;
extern LPMAPIREADMAIL lpfnMAPIReadMail;
extern LPMAPISAVEMAIL lpfnMAPISaveMail;
extern LPMAPIDELETEMAIL lpfnMAPIDeleteMail;
extern LPMAPIFREEBUFFER lpfnMAPIFreeBuffer;
extern LPMAPIADDRESS lpfnMAPIAddress;
extern LPMAPIDETAILS lpfnMAPIDetails;
extern LPMAPIRESOLVENAME lpfnMAPIResolveName;

#undef MAPILogon
#undef MAPILogoff
#undef MAPISendMail
#undef MAPISendDocuments
#undef MAPIFindNext
#undef MAPIReadMail
#undef MAPISaveMail
#undef MAPIDeleteMail
#undef MAPIFreeBuffer
#undef MAPIAddress
#undef MAPIDetails
#undef MAPIResolveName
#define MAPILogon           (*lpfnMAPILogon)
#define MAPILogoff          (*lpfnMAPILogoff)
#define MAPISendMail        (*lpfnMAPISendMail)
#define MAPISendDocuments   (*lpfnMAPISendDocuments)
#define MAPIFindNext        (*lpfnMAPIFindNext)
#define MAPIReadMail        (*lpfnMAPIReadMail)
#define MAPISaveMail        (*lpfnMAPISaveMail)
#define MAPIDeleteMail      (*lpfnMAPIDeleteMail)
#define MAPIFreeBuffer      (*lpfnMAPIFreeBuffer)
#define MAPIAddress         (*lpfnMAPIAddress)
#define MAPIDetails         (*lpfnMAPIDetails)
#define MAPIResolveName     (*lpfnMAPIResolveName)

extern BOOL InitSimpleMAPI(void);
extern void DeinitSimpleMAPI(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\pvalloc.h ===
/*
 -  P V A L L O C . H
 -
 *  Purpose:
 *      Header file for sample memory manager.  Provides chained
 *      memory data structures.
 *
 */

#ifndef __PVALLOC_H__
#define __PVALLOC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define pvNull NULL

typedef unsigned long CB;
typedef void FAR * PV;
typedef char FAR * SZ;
typedef BYTE FAR * PB;

/* Memory allocation node */

typedef struct
{
    HANDLE  hMem;
    CB      cbSize;
    PV      lpvNext;
    PV      lpvBuf;
    CB      ulBlockNum;
    unsigned long   ulAlignPad;
} PVINFO, * PPVINFO;

#define cbPvMax (65520L-sizeof(PVINFO))
#define cbPvMin (1024L-sizeof(PVINFO))

/* Memory manager function prototypes */

PV   PvAlloc(CB cbSize);
PV   PvAllocMore(CB cbSize, PV lpvParent);
BOOL PvFree(PV lpv);

#ifdef __cplusplus
}       /* extern "C" */
#endif

#endif  /* __PVALLOC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\downoe5.cpp ===
// --------------------------------------------------------------------------------
// DownOE5.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "utility.h"
#include "migrate.h"
#include "migerror.h"
#include "structs.h"
#include "resource.h"
#include <oestore.h>
#include <mimeole.h>

const static BYTE rgbZero[4] = {0};

//--------------------------------------------------------------------------
// PFNREADTYPEDATA
//--------------------------------------------------------------------------
typedef void (APIENTRY *PFNREADTYPEDATA)(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs);

//--------------------------------------------------------------------------
// g_rgpfnReadTypeData
//--------------------------------------------------------------------------
extern const PFNREADTYPEDATA g_rgpfnReadTypeData[CDT_LASTTYPE];

//--------------------------------------------------------------------------
// ReadTypeData
//--------------------------------------------------------------------------
#define ReadTypeData(_pbSource, _cbLength, _pColumn, _pRecord, _pcPtrRefs) \
    (*(g_rgpfnReadTypeData[(_pColumn)->type]))(_pbSource, _cbLength, (_pColumn), _pRecord, _pcPtrRefs)

//--------------------------------------------------------------------------
inline void ReadTypeDataFILETIME(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(FILETIME));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(FILETIME));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataFIXSTRA(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == pColumn->cbSize);
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, pColumn->cbSize);
}

//--------------------------------------------------------------------------
inline void ReadTypeDataVARSTRA(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert((LPSTR)((LPBYTE)pbSource)[cbLength - 1] == '\0');
    *((LPSTR *)((LPBYTE)pRecord + pColumn->ofBinding)) = (LPSTR)((LPBYTE)pbSource);
    (*pcPtrRefs)++;
}

//--------------------------------------------------------------------------
inline void ReadTypeDataBYTE(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(BYTE));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(BYTE));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataDWORD(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(DWORD));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(DWORD));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataWORD(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(WORD));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(WORD));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataSTREAM(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(FILEADDRESS));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(FILEADDRESS));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataVARBLOB(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pRecord + pColumn->ofBinding);
    pBlob->cbSize = cbLength;
    if (pBlob->cbSize > 0) 
    { 
        pBlob->pBlobData = pbSource; 
        (*pcPtrRefs)++; 
    }
    else
        pBlob->pBlobData = NULL;
}

//--------------------------------------------------------------------------
inline void ReadTypeDataFIXBLOB(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(pColumn->cbSize == cbLength);
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, pColumn->cbSize);
}

//--------------------------------------------------------------------------
const PFNREADTYPEDATA g_rgpfnReadTypeData[CDT_LASTTYPE] = {
    (PFNREADTYPEDATA)ReadTypeDataFILETIME,
    (PFNREADTYPEDATA)ReadTypeDataFIXSTRA,
    (PFNREADTYPEDATA)ReadTypeDataVARSTRA,
    (PFNREADTYPEDATA)ReadTypeDataBYTE,
    (PFNREADTYPEDATA)ReadTypeDataDWORD,
    (PFNREADTYPEDATA)ReadTypeDataWORD,
    (PFNREADTYPEDATA)ReadTypeDataSTREAM,
    (PFNREADTYPEDATA)ReadTypeDataVARBLOB,
    (PFNREADTYPEDATA)ReadTypeDataFIXBLOB
};

// --------------------------------------------------------------------------------
// DowngradeReadMsgInfoV5
// --------------------------------------------------------------------------------
HRESULT DowngradeReadMsgInfoV5(LPRECORDBLOCKV5 pRecord, LPMESSAGEINFO pMsgInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    DWORD               cColumns;
    DWORD               cbRead=0;
    DWORD               cbLength;
    DWORD               cbData;
    DWORD               cPtrRefs;
    LPBYTE              pbData;
    LPBYTE              pbSource;
    LPDWORD             prgdwOffset=(LPDWORD)((LPBYTE)pRecord + sizeof(RECORDBLOCKV5));

    // Trace
    TraceCall("DowngradeReadMsgInfoV5");

    // Set cbData
    cbData = (pRecord->cbRecord - sizeof(RECORDBLOCKV5) - (pRecord->cColumns * sizeof(DWORD)));

    // Allocate
    IF_NULLEXIT(pbData = (LPBYTE)g_pMalloc->Alloc(cbData));

    // Free This
    pMsgInfo->pvMemory = pbData;

    // Set pbData
    pbSource = (LPBYTE)((LPBYTE)pRecord + sizeof(RECORDBLOCKV5) + (pRecord->cColumns * sizeof(DWORD)));

    // Copy the data
    CopyMemory(pbData, pbSource, cbData);

    // Compute number of columns to read
    cColumns = min(pRecord->cColumns, MSGCOL_LASTID);

    // Read the Record
    for (i=0; i<cColumns; i++)
    {
        // Compute cbLength
        cbLength = (i + 1 == cColumns) ? (cbData - prgdwOffset[i]) : (prgdwOffset[i + 1] - prgdwOffset[i]);

        // Bad-Record
        if (prgdwOffset[i] != cbRead || cbRead + cbLength > cbData)
        {
            hr = TraceResult(MIGRATE_E_BADRECORDFORMAT);
            goto exit;
        }

        // ReadTypeData
        ReadTypeData(pbData + cbRead, cbLength, &g_MessageTableSchema.prgColumn[i], pMsgInfo, &cPtrRefs);

        // Increment cbRead
        cbRead += cbLength;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeLocalStoreFileV5
// --------------------------------------------------------------------------------
HRESULT DowngradeLocalStoreFileV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPMEMORYFILE pFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cRecords=0;
    CHAR                szIdxPath[MAX_PATH + MAX_PATH];
    CHAR                szMbxPath[MAX_PATH + MAX_PATH];
    HANDLE              hIdxFile=NULL;
    HANDLE              hMbxFile=NULL;
    MESSAGEINFO         MsgInfo={0};
    IDXFILEHEADER       IdxHeader;
    MBXFILEHEADER       MbxHeader;
    MBXMESSAGEHEADER    MbxMessage;
    IDXMESSAGEHEADER    IdxMessage;
    LPRECORDBLOCKV5     pRecord;
    LPSTREAMBLOCK       pStmBlock;
    LPBYTE              pbData;
    DWORD               faRecord;
    DWORD               faIdxWrite;
    DWORD               faMbxWrite;
    DWORD               faStreamBlock;
    DWORD               cbAligned;
    DWORD               faMbxCurrent;
    LPTABLEHEADERV5     pHeader=(LPTABLEHEADERV5)pFile->pView;

    // Trace
    TraceCall("DowngradeLocalStoreFileV5");

    // Set idx path
    ReplaceExtension(pInfo->szFilePath, ".idx", szIdxPath);

    // Set mbx path
    ReplaceExtension(pInfo->szFilePath, ".mbx", szMbxPath);

    // Delete Both Files
    DeleteFile(szIdxPath);
    DeleteFile(szMbxPath);

    // Open the idx file
    hIdxFile = CreateFile(szIdxPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hIdxFile)
    {
        hIdxFile = NULL;
        hr = TraceResult(MIGRATE_E_CANTOPENFILE);
        goto exit;
    }

    // Initialize Idx Header
    ZeroMemory(&IdxHeader, sizeof(IDXFILEHEADER));
    IdxHeader.dwMagic = CACHEFILE_MAGIC;
    IdxHeader.ver = CACHEFILE_VER;
    IdxHeader.verBlob = 1; // this will force the .idx blobs to be rebuilt when imn 1.0 or oe v4.0 is run again

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hIdxFile, 0, &IdxHeader, sizeof(IDXFILEHEADER)));

    // Open the mbx file
    hMbxFile = CreateFile(szMbxPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hMbxFile)
    {
        hMbxFile = NULL;
        hr = TraceResult(MIGRATE_E_CANTOPENFILE);
        goto exit;
    }

    // Initialize MBX Header
    ZeroMemory(&MbxHeader, sizeof(MBXFILEHEADER));
    MbxHeader.dwMagic = MSGFILE_MAGIC;
    MbxHeader.ver = MSGFILE_VER;

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hMbxFile, 0, &MbxHeader, sizeof(MBXFILEHEADER)));

    // Set First Record
    faRecord = pHeader->faFirstRecord;

    // Set faIdxWrite
    faIdxWrite = sizeof(IDXFILEHEADER);

    // Set faMbxWrite
    faMbxWrite = sizeof(MBXFILEHEADER);

    // While we have a record
    while(faRecord)
    {
        // Bad Length
        if (faRecord + sizeof(RECORDBLOCKV5) > pFile->cbSize)
        {
            hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
            goto exit;
        }

        // Cast the Record
        pRecord = (LPRECORDBLOCKV5)((LPBYTE)pFile->pView + faRecord);

        // Invalid Record Signature
        if (faRecord != pRecord->faRecord)
        {
            hr = TraceResult(MIGRATE_E_BADRECORDSIGNATURE);
            goto exit;
        }

        // Bad Length
        if (faRecord + pRecord->cbRecord > pFile->cbSize)
        {
            hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
            goto exit;
        }

        // Load MsgInfo
        IF_FAILEXIT(hr = DowngradeReadMsgInfoV5(pRecord, &MsgInfo));

        // No Stream ?
        if (0 == MsgInfo.faStream)
            goto NextRecord;

        // Set msgidLast
        if ((DWORD)MsgInfo.idMessage > MbxHeader.msgidLast)
            MbxHeader.msgidLast = (DWORD)MsgInfo.idMessage;

        // Zero Out the Message Structures
        ZeroMemory(&MbxMessage, sizeof(MBXMESSAGEHEADER));
        ZeroMemory(&IdxMessage, sizeof(IDXMESSAGEHEADER));

        // Fill MbxMessage
        MbxMessage.dwMagic = MSGHDR_MAGIC;
        MbxMessage.msgid = (DWORD)MsgInfo.idMessage;

        // Fixup the Flags
        if (FALSE == ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            FLAGSET(IdxMessage.dwState, MSG_UNREAD);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_VOICEMAIL))
            FLAGSET(IdxMessage.dwState, MSG_VOICEMAIL);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_REPLIED))
            FLAGSET(IdxMessage.dwState, MSG_REPLIED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_FORWARDED))
            FLAGSET(IdxMessage.dwState, MSG_FORWARDED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_FLAGGED))
            FLAGSET(IdxMessage.dwState, MSG_FLAGGED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_RCPTSENT))
            FLAGSET(IdxMessage.dwState, MSG_RCPTSENT);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_NOSECUI))
            FLAGSET(IdxMessage.dwState, MSG_NOSECUI);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_NEWSMSG))
            FLAGSET(IdxMessage.dwState, MSG_NEWSMSG);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_UNSENT))
            FLAGSET(IdxMessage.dwState, MSG_UNSENT);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_SUBMITTED))
            FLAGSET(IdxMessage.dwState, MSG_SUBMITTED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_RECEIVED))
            FLAGSET(IdxMessage.dwState, MSG_RECEIVED);

        // Save faMbxCurrent
        faMbxCurrent = faMbxWrite;

        // Validate alignment
        Assert((faMbxCurrent % 4) == 0);

        // Write the mbx header
        IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxCurrent, &MbxMessage, sizeof(MBXMESSAGEHEADER)));

        // Increment faMbxWrite
        faMbxWrite += sizeof(MBXMESSAGEHEADER);

        // Initialize dwMsgSize
        MbxMessage.dwMsgSize = sizeof(MBXMESSAGEHEADER);

        // Set faStreamBlock
        faStreamBlock = MsgInfo.faStream;

        // While we have stream block
        while(faStreamBlock)
        {
            // Bad Length
            if (faStreamBlock + sizeof(STREAMBLOCK) > pFile->cbSize)
            {
                hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
                goto exit;
            }

            // Cast the Record
            pStmBlock = (LPSTREAMBLOCK)((LPBYTE)pFile->pView + faStreamBlock);

            // Invalid Record Signature
            if (faStreamBlock != pStmBlock->faThis)
            {
                hr = TraceResult(MIGRATE_E_BADSTREAMBLOCKSIGNATURE);
                goto exit;
            }

            // Bad Length
            if (faStreamBlock + pStmBlock->cbBlock > pFile->cbSize)
            {
                hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
                goto exit;
            }

            // Set pbData
            pbData = (LPBYTE)((LPBYTE)(pStmBlock) + sizeof(STREAMBLOCK));

            // Write into the stream
            IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxWrite, pbData, pStmBlock->cbData));

            // Increment dwBodySize
            MbxMessage.dwBodySize += pStmBlock->cbData;

            // Increment dwMsgSize
            MbxMessage.dwMsgSize += pStmBlock->cbData;

            // Increment faMbxWrite
            faMbxWrite += pStmBlock->cbData;

            // Goto Next Block
            faStreamBlock = pStmBlock->faNext;
        }

        // Pad the Message on a dword boundary
        cbAligned = (faMbxWrite % 4);

        // cbAligned ?
        if (cbAligned)
        {
            // Reset cbAligned
            cbAligned = 4 - cbAligned;

            // Write the mbx header
            IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxWrite, (LPVOID)rgbZero, cbAligned));

            // Increment faMbxWrite
            faMbxWrite += cbAligned;

            // Increment 
            MbxMessage.dwMsgSize += cbAligned;
        }

        // Validate alignment
        Assert((faMbxWrite % 4) == 0);

        // Write the mbx header again
        IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxCurrent, &MbxMessage, sizeof(MBXMESSAGEHEADER)));

        // Fill IdxMessage
        IdxMessage.dwLanguage = (DWORD)MAKELONG(MsgInfo.wLanguage, MsgInfo.wHighlight);
        IdxMessage.msgid = (DWORD)MsgInfo.idMessage;
        IdxMessage.dwOffset = faMbxCurrent;
        IdxMessage.dwMsgSize = MbxMessage.dwMsgSize;
        IdxMessage.dwHdrOffset = 0;
        IdxMessage.dwSize = sizeof(IDXMESSAGEHEADER);
        IdxMessage.dwHdrSize = 0;
        IdxMessage.rgbHdr[4] = 0;

        // Write the mbx header
        IF_FAILEXIT(hr = MyWriteFile(hIdxFile, faIdxWrite, &IdxMessage, sizeof(IDXMESSAGEHEADER)));

        // Increment faIdxWrite
        faIdxWrite += IdxMessage.dwSize;

        // Increment cRecords
        cRecords++;

NextRecord:
        // Progress
        IncrementProgress(pProgress, pInfo);

        // Cleanup
        SafeMemFree(MsgInfo.pvMemory);

        // Goto Next
        faRecord = pRecord->faNext;
    }

    // Set the Record Counts
    MbxHeader.cMsg = cRecords;
    IdxHeader.cMsg = cRecords;

    // Set the Flags
    IdxHeader.dwFlags = 1; // STOREINIT_MAIL
    MbxHeader.dwFlags = 1; // STOREINIT_MAIL

    // Get the Size of the idx file
    IdxHeader.cbValid = ::GetFileSize(hIdxFile, NULL);
    if (0xFFFFFFFF == IdxHeader.cbValid)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // Get the Size of the mbx file
    MbxHeader.cbValid = ::GetFileSize(hMbxFile, NULL);
    if (0xFFFFFFFF == MbxHeader.cbValid)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hIdxFile, 0, &IdxHeader, sizeof(IDXFILEHEADER)));

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hMbxFile, 0, &MbxHeader, sizeof(MBXFILEHEADER)));

exit:
    // Cleanup
    SafeCloseHandle(hIdxFile);
    SafeCloseHandle(hMbxFile);
    SafeMemFree(MsgInfo.pvMemory);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeRecordV5
// --------------------------------------------------------------------------------
HRESULT DowngradeRecordV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPMEMORYFILE pFile, LPCHAINNODEV5 pNode, LPDWORD pcbRecord)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbRecord=0;
    DWORD               cbOffsets;
    DWORD               cbData;
    DWORD               cb;
    LPBYTE              pbData;
    LPBYTE              pbStart;
    MESSAGEINFO             MsgInfo={0};
    RECORDBLOCKV5B1     RecordOld;
    LPRECORDBLOCKV5     pRecord;

    // Trace
    TraceCall("DowngradeRecordV5");

    // Invalid
    if (pNode->faRecord + sizeof(RECORDBLOCKV5) > pFile->cbSize || 0 == pNode->faRecord)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // Access the Record
    pRecord = (LPRECORDBLOCKV5((LPBYTE)pFile->pView + pNode->faRecord));

    // Bad Record
    if (pRecord->faRecord != pNode->faRecord)
        return TraceResult(MIGRATE_E_BADRECORDSIGNATURE);

    // Invalid
    if (pNode->faRecord + sizeof(RECORDBLOCKV5) + pRecord->cbRecord > pFile->cbSize)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // Fill an old record header
    RecordOld.faRecord = pRecord->faRecord;
    RecordOld.faNext = pRecord->faNext;
    RecordOld.faPrevious = pRecord->faPrevious;

    // Reformat the record
    if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
    {
        // Read the v5 record into a msginfo structure
        IF_FAILEXIT(hr = DowngradeReadMsgInfoV5(pRecord, &MsgInfo));
    }

    // Compute offset table length
    cbOffsets = (pRecord->cColumns * sizeof(DWORD));

    // Cast the datablock
    pbData = ((LPBYTE)pRecord + sizeof(RECORDBLOCKV5B1));

    // Set Size
    cbData = (pRecord->cbRecord - cbOffsets - sizeof(RECORDBLOCKV5));

    // Remove the Offset Table
    MoveMemory(pbData, ((LPBYTE)pRecord + sizeof(RECORDBLOCKV5) + cbOffsets), cbData);

    // Reformat the record
    if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
    {
        // Set pbStart
        pbStart = pbData;

        // DWORD - idMessage
        CopyMemory(pbData, &MsgInfo.idMessage, sizeof(MsgInfo.idMessage));
        pbData += sizeof(MsgInfo.idMessage);

        // VERSION - dwFlags
        if (IMSG_PRI_HIGH == MsgInfo.wPriority)
            FLAGSET(MsgInfo.dwFlags, 0x00000200);
        else if (IMSG_PRI_LOW == MsgInfo.wPriority)
            FLAGSET(MsgInfo.dwFlags, 0x00000100);

        // VERSION - Normalized Subject -  
        if (lstrcmpi(MsgInfo.pszSubject, MsgInfo.pszNormalSubj) != 0)
            MsgInfo.dwFlags = (DWORD)MAKELONG(MsgInfo.dwFlags, MAKEWORD(0, 4));

        // DWORD - dwFlags
        CopyMemory(pbData, &MsgInfo.dwFlags, sizeof(MsgInfo.dwFlags));
        pbData += sizeof(MsgInfo.dwFlags);

        // FILETIME - ftSent
        CopyMemory(pbData, &MsgInfo.ftSent, sizeof(MsgInfo.ftSent));
        pbData += sizeof(MsgInfo.ftSent);

        // DWORD - cLines
        CopyMemory(pbData, &MsgInfo.cLines, sizeof(MsgInfo.cLines));
        pbData += sizeof(MsgInfo.cLines);

        // DWORD - faStream
        CopyMemory(pbData, &MsgInfo.faStream, sizeof(MsgInfo.faStream));
        pbData += sizeof(MsgInfo.faStream);

        // VERSION - DWORD - cbArticle 
        CopyMemory(pbData, &MsgInfo.cbMessage, sizeof(MsgInfo.cbMessage));
        pbData += sizeof(MsgInfo.cbMessage);

        // FILETIME - ftDownloaded
        CopyMemory(pbData, &MsgInfo.ftDownloaded, sizeof(MsgInfo.ftDownloaded));
        pbData += sizeof(MsgInfo.ftDownloaded);

        // LPSTR - pszMessageId
        cb = lstrlen(MsgInfo.pszMessageId) + 1;
        CopyMemory(pbData, MsgInfo.pszMessageId, cb);
        pbData += cb;

        // LPSTR - pszSubject
        cb = lstrlen(MsgInfo.pszSubject) + 1;
        CopyMemory(pbData, MsgInfo.pszSubject, cb);
        pbData += cb;

        // LPSTR - pszFromHeader
        cb = lstrlen(MsgInfo.pszFromHeader) + 1;
        CopyMemory(pbData, MsgInfo.pszFromHeader, cb);
        pbData += cb;

        // LPSTR - pszReferences
        cb = lstrlen(MsgInfo.pszReferences) + 1;
        CopyMemory(pbData, MsgInfo.pszReferences, cb);
        pbData += cb;

        // LPSTR - pszXref
        cb = lstrlen(MsgInfo.pszXref) + 1;
        CopyMemory(pbData, MsgInfo.pszXref, cb);
        pbData += cb;

        // LPSTR - pszServer
        cb = lstrlen(MsgInfo.pszServer) + 1;
        CopyMemory(pbData, MsgInfo.pszServer, cb);
        pbData += cb;

        // LPSTR - pszDisplayFrom
        cb = lstrlen(MsgInfo.pszDisplayFrom) + 1;
        CopyMemory(pbData, MsgInfo.pszDisplayFrom, cb);
        pbData += cb;

        // LPSTR - pszEmailFrom
        cb = lstrlen(MsgInfo.pszEmailFrom) + 1;
        CopyMemory(pbData, MsgInfo.pszEmailFrom, cb);
        pbData += cb;

        // Going to V4 ?
        if (DOWNGRADE_V5_TO_V4 == tyMigrate)
        {
            // WORD - wLanguage
            CopyMemory(pbData, &MsgInfo.wLanguage, sizeof(MsgInfo.wLanguage));
            pbData += sizeof(MsgInfo.wLanguage);

            // WORD - wReserved
            MsgInfo.wHighlight = 0;
            CopyMemory(pbData, &MsgInfo.wHighlight, sizeof(MsgInfo.wHighlight));
            pbData += sizeof(MsgInfo.wHighlight);

            // DWORD - cbMessage
            CopyMemory(pbData, &MsgInfo.cbMessage, sizeof(MsgInfo.cbMessage));
            pbData += sizeof(MsgInfo.cbMessage);

            // DWORD - ftReceived
            CopyMemory(pbData, &MsgInfo.ftReceived, sizeof(MsgInfo.ftReceived));
            pbData += sizeof(MsgInfo.ftReceived);

            // LPSTR - pszDisplayTo
            cb = lstrlen(MsgInfo.pszDisplayTo) + 1;
            CopyMemory(pbData, MsgInfo.pszDisplayTo, cb);
            pbData += cb;
        }

        // Add on Reserved
        cbRecord = (40 + sizeof(RECORDBLOCKV5B1) + (pbData - pbStart));

        // Better be smaller
        Assert(cbRecord <= pRecord->cbRecord);
    }

    // Otherwise, much easier
    else
    {
        // Set Size
        cbRecord = (pRecord->cbRecord - cbOffsets - sizeof(RECORDBLOCKV5)) + sizeof(RECORDBLOCKV5B1);
    }

    // Set the Record Size
    RecordOld.cbRecord = cbRecord;

    // Write the new record header
    CopyMemory((LPBYTE)pRecord, &RecordOld, sizeof(RECORDBLOCKV5B1));

    // Return size
    *pcbRecord = cbRecord;

exit:
    // Cleanup
    SafeMemFree(MsgInfo.pvMemory);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeIndexV5
// --------------------------------------------------------------------------------
HRESULT DowngradeIndexV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPMEMORYFILE pFile, LPPROGRESSINFO pProgress, DWORD faRootChain, DWORD faChain)
{
    // Locals
    HRESULT             hr=S_OK;
    LONG                i;
    LPCHAINBLOCKV5      pChain;
    CHAINBLOCKV5B1      ChainOld;
    DWORD               cbRecord;

    // Trace
    TraceCall("DowngradeIndexV5");

    // Nothing to validate
    if (0 == faChain)
        return S_OK;

    // Out-of-bounds
    if (faChain + CB_CHAIN_BLOCKV5 > pFile->cbSize)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // De-ref the block
    pChain = (LPCHAINBLOCKV5)((LPBYTE)pFile->pView + faChain);

    // Out-of-Bounds
    if (pChain->faStart != faChain)
        return TraceResult(MIGRATE_E_BADCHAINSIGNATURE);

    // Too many nodes
    if (pChain->cNodes > BTREE_ORDER)
        return TraceResult(MIGRATE_E_TOOMANYCHAINNODES);

    // Validate Minimum Filled Constraint
    if (pChain->cNodes < BTREE_MIN_CAP && pChain->faStart != faRootChain)
        return TraceResult(MIGRATE_E_BADMINCAPACITY);

    // Go to the left
    IF_FAILEXIT(hr = DowngradeIndexV5(tyMigrate, pInfo, pFile, pProgress, faRootChain, pChain->faLeftChain));

    // Convert pChain to ChainOld
    ChainOld.faStart = pChain->faStart;
    ChainOld.cNodes = pChain->cNodes;
    ChainOld.faLeftChain = pChain->faLeftChain;

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Bump Progress
        IncrementProgress(pProgress, pInfo);

        /// Downgrad this record
        IF_FAILEXIT(hr = DowngradeRecordV5(tyMigrate, pInfo, pFile, &pChain->rgNode[i], &cbRecord));

        // Update Old Node
        ChainOld.rgNode[i].faRecord = pChain->rgNode[i].faRecord;
        ChainOld.rgNode[i].cbRecord = cbRecord;
        ChainOld.rgNode[i].faRightChain = pChain->rgNode[i].faRightChain;

        // Validate the Right Chain
        IF_FAILEXIT(hr = DowngradeIndexV5(tyMigrate, pInfo, pFile, pProgress, faRootChain, pChain->rgNode[i].faRightChain));
    }

    // Write this new chain
    CopyMemory((LPBYTE)pChain, &ChainOld, CB_CHAIN_BLOCKV5B1);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeFileV5
// --------------------------------------------------------------------------------
HRESULT DowngradeFileV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    TABLEHEADERV5       HeaderV5;
    LPTABLEHEADERV5B1   pHeaderV5B1;
    CHAR                szDstFile[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("DowngradeFileV5");

    // Local message file
    if (FILE_IS_LOCAL_MESSAGES == pInfo->tyFile)
    {
        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradeLocalStoreFileV5
        IF_FAILEXIT(hr = DowngradeLocalStoreFileV5(tyMigrate, pInfo, &File, pProgress));
    }

    // Old News or Imap file
    else
    {
        // Create xxx.nch file
        if (FILE_IS_POP3UIDL == pInfo->tyFile)
            ReplaceExtension(pInfo->szFilePath, ".dat", szDstFile);
        else
            ReplaceExtension(pInfo->szFilePath, ".nch", szDstFile);

        // Copy the file
        if (0 == CopyFile(pInfo->szFilePath, szDstFile, FALSE))
        {
            hr = TraceResult(MIGRATE_E_CANTCOPYFILE);
            goto exit;
        }

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(szDstFile, &File));

        // Copy Table Header
        CopyMemory(&HeaderV5, (LPBYTE)File.pView, sizeof(TABLEHEADERV5));

        // De-Ref the header
        pHeaderV5B1 = (LPTABLEHEADERV5B1)File.pView;

        // Fixup the Header
        ZeroMemory(pHeaderV5B1, sizeof(TABLEHEADERV5B1));
        pHeaderV5B1->dwSignature = HeaderV5.dwSignature;
        pHeaderV5B1->wMajorVersion = (WORD)HeaderV5.dwMajorVersion;
        pHeaderV5B1->faRootChain = HeaderV5.rgfaIndex[0];
        pHeaderV5B1->faFreeRecordBlock = HeaderV5.faFreeRecordBlock;
        pHeaderV5B1->faFirstRecord = HeaderV5.faFirstRecord;
        pHeaderV5B1->faLastRecord = HeaderV5.faLastRecord;
        pHeaderV5B1->cRecords = HeaderV5.cRecords;
        pHeaderV5B1->cbAllocated = HeaderV5.cbAllocated;
        pHeaderV5B1->cbFreed = HeaderV5.cbFreed;
        pHeaderV5B1->dwReserved1 = 0;
        pHeaderV5B1->dwReserved2 = 0;
        pHeaderV5B1->cbUserData = HeaderV5.cbUserData;
        pHeaderV5B1->cDeletes = 0;
        pHeaderV5B1->cInserts = 0;
        pHeaderV5B1->cActiveThreads = 0;
        pHeaderV5B1->dwReserved3 = 0;
        pHeaderV5B1->cbStreams = HeaderV5.cbStreams;
        pHeaderV5B1->faFreeStreamBlock = HeaderV5.faFreeStreamBlock;
        pHeaderV5B1->faFreeChainBlock = HeaderV5.faFreeChainBlock;
        pHeaderV5B1->faNextAllocate = HeaderV5.faNextAllocate;
        pHeaderV5B1->dwNextId = HeaderV5.dwNextId;
	    pHeaderV5B1->AllocateRecord = HeaderV5.AllocateRecord;
	    pHeaderV5B1->AllocateChain = HeaderV5.AllocateChain;
	    pHeaderV5B1->AllocateStream = HeaderV5.AllocateStream;
        pHeaderV5B1->fCorrupt = FALSE;
        pHeaderV5B1->fCorruptCheck = TRUE;

        // DowngradeIndexV5
        IF_FAILEXIT(hr = DowngradeIndexV5(tyMigrate, pInfo, &File, pProgress, pHeaderV5B1->faRootChain, pHeaderV5B1->faRootChain));

        // Reset the version
        pHeaderV5B1->wMajorVersion = OBJECTDB_VERSION_PRE_V5;

        // Set the Minor Version
        if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
            pHeaderV5B1->wMinorVersion = ACACHE_VERSION_PRE_V5;

        // Folder cache version
        else if (FILE_IS_LOCAL_FOLDERS == pInfo->tyFile || FILE_IS_IMAP_FOLDERS == pInfo->tyFile)
            pHeaderV5B1->wMinorVersion = FLDCACHE_VERSION_PRE_V5;

        // UIDL Cache Version
        else if (FILE_IS_POP3UIDL == pInfo->tyFile)
            pHeaderV5B1->wMinorVersion = UIDCACHE_VERSION_PRE_V5;

        // Bad mojo
        else
            Assert(FALSE);
    }

exit:
    // Cleanup
    CloseMemoryFile(&File);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeProcessFileListV5
// --------------------------------------------------------------------------------
HRESULT DowngradeProcessFileListV5(LPFILEINFO pHead, LPDWORD pcMax, LPDWORD pcbNeeded)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPFILEINFO          pCurrent;
    LPTABLEHEADERV5     pHeader;

    // Trace
    TraceCall("DowngradeProcessFileListV5");

    // Invalid Arg
    Assert(pHead);

    // Init
    *pcMax = 0;
    *pcbNeeded = 0;

    // Loop
    for (pCurrent=pHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Get the File Header
        hr = OpenMemoryFile(pCurrent->szFilePath, &File);

        // Failure ?
        if (FAILED(hr))
        {
            // Don't Migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = hr;

            // Reset hr
            hr = S_OK;

            // Get the LastError
            pCurrent->dwLastError = GetLastError();

            // Goto Next
            goto NextFile;
        }

        // De-Ref the header
        pHeader = (LPTABLEHEADERV5)File.pView;

        // Check the Signature...
        if (File.cbSize < sizeof(TABLEHEADERV5) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_V5 != pHeader->dwMajorVersion)
        {
            // Not a file that should be migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

            // Goto Next
            goto NextFile;
        }

        // Save the Number of record
        pCurrent->cRecords = pHeader->cRecords;

        // Initialize counters
        InitializeCounters(&File, pCurrent, pcMax, pcbNeeded, FALSE);

        // Yes, Migrate
        pCurrent->fMigrate = TRUE;

NextFile:
        // Close the File
        CloseMemoryFile(&File);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeDeleteFilesV5
// --------------------------------------------------------------------------------
void DowngradeDeleteFilesV5(LPFILEINFO pHeadFile)
{
    // Locals
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("DowngradeDeleteFilesV5");

    // Delete all files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Succeeded
        Assert(SUCCEEDED(pCurrent->hrMigrate));

        // Delete the file
        DeleteFile(pCurrent->szFilePath);
    }

    // Done
    return;
}

// --------------------------------------------------------------------------------
// DowngradeDeleteIdxMbxNchDatFilesV5
// --------------------------------------------------------------------------------
void DowngradeDeleteIdxMbxNchDatFilesV5(LPFILEINFO pHeadFile)
{
    // Locals
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("DowngradeDeleteIdxMbxNchDatFilesV5");

    // Delete all old files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // If local message file, need to delete the idx file
        if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".idx", szDstFile);

            // Delete the file
            DeleteFile(szDstFile);

            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".mbx", szDstFile);

            // Delete the file
            DeleteFile(szDstFile);
        }

        // Otherwise, pop3uidl.dat
        else if (FILE_IS_POP3UIDL == pCurrent->tyFile)
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".dat", szDstFile);

            // Delete the file
            DeleteFile(szDstFile);
        }

        // Otherwise, it has a .nch extension
        else
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".nch", szDstFile);

            // Delete the file
            DeleteFile(szDstFile);
        }
    }

    // Done
    return;
}

// --------------------------------------------------------------------------------
// DowngradeV5
// --------------------------------------------------------------------------------
HRESULT DowngradeV5(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreRoot,
    LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    ENUMFILEINFO    EnumInfo={0};
    LPFILEINFO      pCurrent;
    DWORD           cbNeeded;
    DWORDLONG       dwlFree;

    // Trace
    TraceCall("DowngradeV5");

    // Initialize
    *ppHeadFile = NULL;

    // Setup the EnumFile Info
    EnumInfo.pszExt = ".dbx";
    EnumInfo.pszFoldFile = "folders.dbx";
    EnumInfo.pszUidlFile = "pop3uidl.dbx";

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreRoot, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Compute some Counts, and validate that the files are valid to migrate...
    IF_FAILEXIT(hr = DowngradeProcessFileListV5(*ppHeadFile, &pProgress->cMax, &cbNeeded));

    // Delete all source files
    DowngradeDeleteIdxMbxNchDatFilesV5(*ppHeadFile);

    // Enought DiskSpace ?
    IF_FAILEXIT(hr = GetAvailableDiskSpace(pszStoreRoot, &dwlFree));

    // Not Enought Diskspace
    if (((DWORDLONG) cbNeeded) > dwlFree)
    {
        // cbNeeded is DWORD and in this case we can downgrade dwlFree to DWORD
        g_cbDiskNeeded = cbNeeded; g_cbDiskFree = ((DWORD) dwlFree);
        hr = TraceResult(MIGRATE_E_NOTENOUGHDISKSPACE);
        goto exit;
    }

    // Loop through the files and migrate each one
    for (pCurrent=*ppHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Migrate this file ?
        if (pCurrent->fMigrate)
        {
            // Set Progress File
            SetProgressFile(pProgress, pCurrent);

            // Downgrade the file
            hr = pCurrent->hrMigrate = DowngradeFileV5(tyMigrate, pCurrent, pProgress);

            // Failure ?
            if (FAILED(pCurrent->hrMigrate))
            {
                // Set Last Error
                pCurrent->dwLastError = GetLastError();

                // Done
                break;
            }
        }
    }

    // Failure, delete all destination files
    if (FAILED(hr))
    {
        // Delete.idx, .mbx and .nch fles
        DowngradeDeleteIdxMbxNchDatFilesV5(*ppHeadFile);
    }

    // Otherwise, delete source files
    else
    {
        // Delete all source files
        DowngradeDeleteFilesV5(*ppHeadFile);
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\_scode.h ===
/*
 *  _ S C O D E . H
 *
 *  Status Codes returned by MAPI routines
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SCODE_H
#define _SCODE_H

/* Define S_OK and ITF_* */

#ifdef _WIN32
#include <winerror.h>
#endif

/*
 *  MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or winerror.h (Windows NT and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */

/* The following two macros are used to build OLE 2.0 style sCodes */


#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one MAPI object) */


Sc(MAPI_E_NO_SUPPORT),
Sc(MAPI_E_BAD_CHARWIDTH),
Sc(MAPI_E_STRING_TOO_LONG),
Sc(MAPI_E_UNKNOWN_FLAGS),
Sc(MAPI_E_INVALID_ENTRYID),
Sc(MAPI_E_INVALID_OBJECT),
Sc(MAPI_E_OBJECT_CHANGED),
Sc(MAPI_E_OBJECT_DELETED),
Sc(MAPI_E_BUSY),
Sc(MAPI_E_NOT_ENOUGH_DISK),
Sc(MAPI_E_NOT_ENOUGH_RESOURCES),
Sc(MAPI_E_NOT_FOUND),
Sc(MAPI_E_VERSION),
Sc(MAPI_E_LOGON_FAILED),
Sc(MAPI_E_SESSION_LIMIT),
Sc(MAPI_E_USER_CANCEL),
Sc(MAPI_E_UNABLE_TO_ABORT),
Sc(MAPI_E_NETWORK_ERROR),
Sc(MAPI_E_DISK_ERROR),
Sc(MAPI_E_TOO_COMPLEX),
Sc(MAPI_E_BAD_COLUMN),
Sc(MAPI_E_EXTENDED_ERROR),
Sc(MAPI_E_COMPUTED),
Sc(MAPI_E_CORRUPT_DATA),
Sc(MAPI_E_UNCONFIGURED),
Sc(MAPI_E_FAILONEPROVIDER),
Sc(MAPI_E_UNKNOWN_CPID),
Sc(MAPI_E_UNKNOWN_LCID),

/* MAPI base function and status object specific errors and warnings */

Sc(MAPI_E_END_OF_SESSION),
Sc(MAPI_E_UNKNOWN_ENTRYID),
Sc(MAPI_E_MISSING_REQUIRED_COLUMN),
Sc(MAPI_W_NO_SERVICE),

/* Property specific errors and warnings */

Sc(MAPI_E_BAD_VALUE),
Sc(MAPI_E_INVALID_TYPE),
Sc(MAPI_E_TYPE_NO_SUPPORT),
Sc(MAPI_E_UNEXPECTED_TYPE),
Sc(MAPI_E_TOO_BIG),
Sc(MAPI_E_DECLINE_COPY),
Sc(MAPI_E_UNEXPECTED_ID),

Sc(MAPI_W_ERRORS_RETURNED),

/* Table specific errors and warnings */

Sc(MAPI_E_UNABLE_TO_COMPLETE),
Sc(MAPI_E_TIMEOUT),
Sc(MAPI_E_TABLE_EMPTY),
Sc(MAPI_E_TABLE_TOO_BIG),

Sc(MAPI_E_INVALID_BOOKMARK),

Sc(MAPI_W_POSITION_CHANGED),
Sc(MAPI_W_APPROX_COUNT),

/* Transport specific errors and warnings */

Sc(MAPI_E_WAIT),
Sc(MAPI_E_CANCEL),
Sc(MAPI_E_NOT_ME),

Sc(MAPI_W_CANCEL_MESSAGE),

/* Message Store, Folder, and Message specific errors and warnings */

Sc(MAPI_E_CORRUPT_STORE),
Sc(MAPI_E_NOT_IN_QUEUE),
Sc(MAPI_E_NO_SUPPRESS),
Sc(MAPI_E_COLLISION),
Sc(MAPI_E_NOT_INITIALIZED),
Sc(MAPI_E_NON_STANDARD),
Sc(MAPI_E_NO_RECIPIENTS),
Sc(MAPI_E_SUBMITTED),
Sc(MAPI_E_HAS_FOLDERS),
Sc(MAPI_E_HAS_MESSAGES),
Sc(MAPI_E_FOLDER_CYCLE),

Sc(MAPI_W_PARTIAL_COMPLETION),

/* Address Book specific errors and warnings */

Sc(MAPI_E_AMBIGUOUS_RECIP),

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#endif

#endif  /* _SCODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mapitest\sample.cli\_tags.h ===
/*
 *  _ T A G S . H
 *
 *  Property tag definitions for standard properties of MAPI
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6800    7BFF    Message class-defined content property
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _TAGS_H
#define _TAGS_H



/*
 *  Message envelope properties
 */

Pt(PR_ACKNOWLEDGEMENT_MODE),
Pt(PR_ALTERNATE_RECIPIENT_ALLOWED),
Pt(PR_AUTHORIZING_USERS),
Pt(PR_AUTO_FORWARD_COMMENT),
Pt(PR_AUTO_FORWARD_COMMENT_W),
Pt(PR_AUTO_FORWARD_COMMENT_A),
Pt(PR_AUTO_FORWARDED),
Pt(PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID),
Pt(PR_CONTENT_CORRELATOR),
Pt(PR_CONTENT_IDENTIFIER),
Pt(PR_CONTENT_IDENTIFIER_W),
Pt(PR_CONTENT_IDENTIFIER_A),
Pt(PR_CONTENT_LENGTH),
Pt(PR_CONTENT_RETURN_REQUESTED),



Pt(PR_CONVERSATION_KEY),

Pt(PR_CONVERSION_EITS),
Pt(PR_CONVERSION_WITH_LOSS_PROHIBITED),
Pt(PR_CONVERTED_EITS),
Pt(PR_DEFERRED_DELIVERY_TIME),
Pt(PR_DELIVER_TIME),
Pt(PR_DISCARD_REASON),
Pt(PR_DISCLOSURE_OF_RECIPIENTS),
Pt(PR_DL_EXPANSION_HISTORY),
Pt(PR_DL_EXPANSION_PROHIBITED),
Pt(PR_EXPIRY_TIME),
Pt(PR_IMPLICIT_CONVERSION_PROHIBITED),
Pt(PR_IMPORTANCE),
Pt(PR_IPM_ID),
Pt(PR_LATEST_DELIVERY_TIME),
Pt(PR_MESSAGE_CLASS),
Pt(PR_MESSAGE_CLASS_W),
Pt(PR_MESSAGE_CLASS_A),
Pt(PR_MESSAGE_DELIVERY_ID),





Pt(PR_MESSAGE_SECURITY_LABEL),
Pt(PR_OBSOLETED_IPMS),
Pt(PR_ORIGINALLY_INTENDED_RECIPIENT_NAME),
Pt(PR_ORIGINAL_EITS),
Pt(PR_ORIGINATOR_CERTIFICATE),
Pt(PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED),
Pt(PR_ORIGINATOR_RETURN_ADDRESS),



Pt(PR_PARENT_KEY),
Pt(PR_PRIORITY),



Pt(PR_ORIGIN_CHECK),
Pt(PR_PROOF_OF_SUBMISSION_REQUESTED),
Pt(PR_READ_RECEIPT_REQUESTED),
Pt(PR_RECEIPT_TIME),
Pt(PR_RECIPIENT_REASSIGNMENT_PROHIBITED),
Pt(PR_REDIRECTION_HISTORY),
Pt(PR_RELATED_IPMS),
Pt(PR_ORIGINAL_SENSITIVITY),
Pt(PR_LANGUAGES),
Pt(PR_LANGUAGES_W),
Pt(PR_LANGUAGES_A),
Pt(PR_REPLY_TIME),
Pt(PR_REPORT_TAG),
Pt(PR_REPORT_TIME),
Pt(PR_RETURNED_IPM),
Pt(PR_SECURITY),
Pt(PR_INCOMPLETE_COPY),
Pt(PR_SENSITIVITY),
Pt(PR_SUBJECT),
Pt(PR_SUBJECT_W),
Pt(PR_SUBJECT_A),
Pt(PR_SUBJECT_IPM),
Pt(PR_CLIENT_SUBMIT_TIME),
Pt(PR_REPORT_NAME),
Pt(PR_REPORT_NAME_W),
Pt(PR_REPORT_NAME_A),
Pt(PR_SENT_REPRESENTING_SEARCH_KEY),
Pt(PR_X400_CONTENT_TYPE),
Pt(PR_SUBJECT_PREFIX),
Pt(PR_SUBJECT_PREFIX_W),
Pt(PR_SUBJECT_PREFIX_A),
Pt(PR_NON_RECEIPT_REASON),
Pt(PR_RECEIVED_BY_ENTRYID),
Pt(PR_RECEIVED_BY_NAME),
Pt(PR_RECEIVED_BY_NAME_W),
Pt(PR_RECEIVED_BY_NAME_A),
Pt(PR_SENT_REPRESENTING_ENTRYID),
Pt(PR_SENT_REPRESENTING_NAME),
Pt(PR_SENT_REPRESENTING_NAME_W),
Pt(PR_SENT_REPRESENTING_NAME_A),
Pt(PR_RCVD_REPRESENTING_ENTRYID),
Pt(PR_RCVD_REPRESENTING_NAME),
Pt(PR_RCVD_REPRESENTING_NAME_W),
Pt(PR_RCVD_REPRESENTING_NAME_A),
Pt(PR_REPORT_ENTRYID),
Pt(PR_READ_RECEIPT_ENTRYID),
Pt(PR_MESSAGE_SUBMISSION_ID),
Pt(PR_PROVIDER_SUBMIT_TIME),
Pt(PR_ORIGINAL_SUBJECT),
Pt(PR_ORIGINAL_SUBJECT_W),
Pt(PR_ORIGINAL_SUBJECT_A),
Pt(PR_DISC_VAL),
Pt(PR_ORIG_MESSAGE_CLASS),
Pt(PR_ORIG_MESSAGE_CLASS_W),
Pt(PR_ORIG_MESSAGE_CLASS_A),
Pt(PR_ORIGINAL_AUTHOR_ENTRYID),
Pt(PR_ORIGINAL_AUTHOR_NAME),
Pt(PR_ORIGINAL_AUTHOR_NAME_W),
Pt(PR_ORIGINAL_AUTHOR_NAME_A),
Pt(PR_ORIGINAL_SUBMIT_TIME),
Pt(PR_REPLY_RECIPIENT_ENTRIES),
Pt(PR_REPLY_RECIPIENT_NAMES),
Pt(PR_REPLY_RECIPIENT_NAMES_W),
Pt(PR_REPLY_RECIPIENT_NAMES_A),

Pt(PR_RECEIVED_BY_SEARCH_KEY),
Pt(PR_RCVD_REPRESENTING_SEARCH_KEY),
Pt(PR_READ_RECEIPT_SEARCH_KEY),
Pt(PR_REPORT_SEARCH_KEY),
Pt(PR_ORIGINAL_DELIVERY_TIME),
Pt(PR_ORIGINAL_AUTHOR_SEARCH_KEY),

Pt(PR_MESSAGE_TO_ME),
Pt(PR_MESSAGE_CC_ME),
Pt(PR_MESSAGE_RECIP_ME),

Pt(PR_ORIGINAL_SENDER_NAME),
Pt(PR_ORIGINAL_SENDER_NAME_W),
Pt(PR_ORIGINAL_SENDER_NAME_A),
Pt(PR_ORIGINAL_SENDER_ENTRYID),
Pt(PR_ORIGINAL_SENDER_SEARCH_KEY),
Pt(PR_ORIGINAL_SENT_REPRESENTING_NAME),
Pt(PR_ORIGINAL_SENT_REPRESENTING_NAME_W),
Pt(PR_ORIGINAL_SENT_REPRESENTING_NAME_A),
Pt(PR_ORIGINAL_SENT_REPRESENTING_ENTRYID),
Pt(PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY),

Pt(PR_START_DATE),
Pt(PR_END_DATE),
Pt(PR_OWNER_APPT_ID),
Pt(PR_RESPONSE_REQUESTED),

Pt(PR_SENT_REPRESENTING_ADDRTYPE),
Pt(PR_SENT_REPRESENTING_ADDRTYPE_W),
Pt(PR_SENT_REPRESENTING_ADDRTYPE_A),
Pt(PR_SENT_REPRESENTING_EMAIL_ADDRESS),
Pt(PR_SENT_REPRESENTING_EMAIL_ADDRESS_W),
Pt(PR_SENT_REPRESENTING_EMAIL_ADDRESS_A),

Pt(PR_ORIGINAL_SENDER_ADDRTYPE),
Pt(PR_ORIGINAL_SENDER_ADDRTYPE_W),
Pt(PR_ORIGINAL_SENDER_ADDRTYPE_A),
Pt(PR_ORIGINAL_SENDER_EMAIL_ADDRESS),
Pt(PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W),
Pt(PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A),

Pt(PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE),
Pt(PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W),
Pt(PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A),
Pt(PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS),
Pt(PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W),
Pt(PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A),

Pt(PR_CONVERSATION_TOPIC),
Pt(PR_CONVERSATION_TOPIC_W),
Pt(PR_CONVERSATION_TOPIC_A),
Pt(PR_CONVERSATION_INDEX),

Pt(PR_ORIGINAL_DISPLAY_BCC),
Pt(PR_ORIGINAL_DISPLAY_BCC_W),
Pt(PR_ORIGINAL_DISPLAY_BCC_A),
Pt(PR_ORIGINAL_DISPLAY_CC),
Pt(PR_ORIGINAL_DISPLAY_CC_W),
Pt(PR_ORIGINAL_DISPLAY_CC_A),
Pt(PR_ORIGINAL_DISPLAY_TO),
Pt(PR_ORIGINAL_DISPLAY_TO_W),
Pt(PR_ORIGINAL_DISPLAY_TO_A),

Pt(PR_RECEIVED_BY_ADDRTYPE),
Pt(PR_RECEIVED_BY_ADDRTYPE_W),
Pt(PR_RECEIVED_BY_ADDRTYPE_A),
Pt(PR_RECEIVED_BY_EMAIL_ADDRESS),
Pt(PR_RECEIVED_BY_EMAIL_ADDRESS_W),
Pt(PR_RECEIVED_BY_EMAIL_ADDRESS_A),

Pt(PR_RCVD_REPRESENTING_ADDRTYPE),
Pt(PR_RCVD_REPRESENTING_ADDRTYPE_W),
Pt(PR_RCVD_REPRESENTING_ADDRTYPE_A),
Pt(PR_RCVD_REPRESENTING_EMAIL_ADDRESS),
Pt(PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W),
Pt(PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A),

Pt(PR_ORIGINAL_AUTHOR_ADDRTYPE),
Pt(PR_ORIGINAL_AUTHOR_ADDRTYPE_W),
Pt(PR_ORIGINAL_AUTHOR_ADDRTYPE_A),
Pt(PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS),
Pt(PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W),
Pt(PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A),

Pt(PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE),
Pt(PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W),
Pt(PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A),
Pt(PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS),
Pt(PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W),
Pt(PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A),

Pt(PR_TRANSPORT_MESSAGE_HEADERS),
Pt(PR_TRANSPORT_MESSAGE_HEADERS_W),
Pt(PR_TRANSPORT_MESSAGE_HEADERS_A),

Pt(PR_DELEGATION),



/*
 *  Message content properties
 */

Pt(PR_BODY),
Pt(PR_BODY_W),
Pt(PR_BODY_A),
Pt(PR_REPORT_TEXT),
Pt(PR_REPORT_TEXT_W),
Pt(PR_REPORT_TEXT_A),
Pt(PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY),
Pt(PR_REPORTING_DL_NAME),
Pt(PR_REPORTING_MTA_CERTIFICATE),

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

Pt(PR_RTF_SYNC_BODY_CRC),
Pt(PR_RTF_SYNC_BODY_COUNT),
Pt(PR_RTF_SYNC_BODY_TAG),
Pt(PR_RTF_SYNC_BODY_TAG_W),
Pt(PR_RTF_SYNC_BODY_TAG_A),
Pt(PR_RTF_COMPRESSED),
Pt(PR_RTF_SYNC_PREFIX_COUNT),
Pt(PR_RTF_SYNC_TRAILING_COUNT),
Pt(PR_ORIGINALLY_INTENDED_RECIP_ENTRYID),

/*
 *  Message recipient properties
 */

Pt(PR_CONTENT_INTEGRITY_CHECK),
Pt(PR_EXPLICIT_CONVERSION),
Pt(PR_IPM_RETURN_REQUESTED),
Pt(PR_MESSAGE_TOKEN),
Pt(PR_NDR_REASON_CODE),
Pt(PR_NDR_DIAG_CODE),
Pt(PR_NON_RECEIPT_NOTIFICATION_REQUESTED),
Pt(PR_DELIVERY_POINT),

Pt(PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED),
Pt(PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT),
Pt(PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY),
Pt(PR_PHYSICAL_DELIVERY_MODE),
Pt(PR_PHYSICAL_DELIVERY_REPORT_REQUEST),
Pt(PR_PHYSICAL_FORWARDING_ADDRESS),
Pt(PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED),
Pt(PR_PHYSICAL_FORWARDING_PROHIBITED),
Pt(PR_PHYSICAL_RENDITION_ATTRIBUTES),
Pt(PR_PROOF_OF_DELIVERY),
Pt(PR_PROOF_OF_DELIVERY_REQUESTED),
Pt(PR_RECIPIENT_CERTIFICATE),
Pt(PR_RECIPIENT_NUMBER_FOR_ADVICE),
Pt(PR_RECIPIENT_NUMBER_FOR_ADVICE_W),
Pt(PR_RECIPIENT_NUMBER_FOR_ADVICE_A),
Pt(PR_RECIPIENT_TYPE),
Pt(PR_REGISTERED_MAIL_TYPE),
Pt(PR_REPLY_REQUESTED),
Pt(PR_REQUESTED_DELIVERY_METHOD),
Pt(PR_SENDER_ENTRYID),
Pt(PR_SENDER_NAME),
Pt(PR_SENDER_NAME_W),
Pt(PR_SENDER_NAME_A),
Pt(PR_SUPPLEMENTARY_INFO),
Pt(PR_SUPPLEMENTARY_INFO_W),
Pt(PR_SUPPLEMENTARY_INFO_A),
Pt(PR_TYPE_OF_MTS_USER),
Pt(PR_SENDER_SEARCH_KEY),
Pt(PR_SENDER_ADDRTYPE),
Pt(PR_SENDER_ADDRTYPE_W),
Pt(PR_SENDER_ADDRTYPE_A),
Pt(PR_SENDER_EMAIL_ADDRESS),
Pt(PR_SENDER_EMAIL_ADDRESS_W),
Pt(PR_SENDER_EMAIL_ADDRESS_A),

/*
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

Pt(PR_CURRENT_VERSION),
Pt(PR_DELETE_AFTER_SUBMIT),
Pt(PR_DISPLAY_BCC),
Pt(PR_DISPLAY_BCC_W),
Pt(PR_DISPLAY_BCC_A),
Pt(PR_DISPLAY_CC),
Pt(PR_DISPLAY_CC_W),
Pt(PR_DISPLAY_CC_A),
Pt(PR_DISPLAY_TO),
Pt(PR_DISPLAY_TO_W),
Pt(PR_DISPLAY_TO_A),
Pt(PR_PARENT_DISPLAY),
Pt(PR_PARENT_DISPLAY_W),
Pt(PR_PARENT_DISPLAY_A),
Pt(PR_MESSAGE_DELIVERY_TIME),
Pt(PR_MESSAGE_FLAGS),
Pt(PR_MESSAGE_SIZE),
Pt(PR_PARENT_ENTRYID),
Pt(PR_SENTMAIL_ENTRYID),
Pt(PR_CORRELATE),
Pt(PR_CORRELATE_MTSID),
Pt(PR_DISCRETE_VALUES),
Pt(PR_RESPONSIBILITY),
Pt(PR_SPOOLER_STATUS),
Pt(PR_TRANSPORT_STATUS),
Pt(PR_MESSAGE_RECIPIENTS),
Pt(PR_MESSAGE_ATTACHMENTS),
Pt(PR_SUBMIT_FLAGS),
Pt(PR_RECIPIENT_STATUS),
Pt(PR_TRANSPORT_KEY),
Pt(PR_MSG_STATUS),
Pt(PR_MESSAGE_DOWNLOAD_TIME),
Pt(PR_CREATION_VERSION),
Pt(PR_MODIFY_VERSION),
Pt(PR_HASATTACH),
Pt(PR_BODY_CRC),
Pt(PR_NORMALIZED_SUBJECT),
Pt(PR_NORMALIZED_SUBJECT_W),
Pt(PR_NORMALIZED_SUBJECT_A),
Pt(PR_RTF_IN_SYNC),
Pt(PR_ATTACH_SIZE),
Pt(PR_ATTACH_NUM),
Pt(PR_PREPROCESS),

/* PR_ORIGINAL_DISPLAY_TO, _CC, and _BCC moved to transmittible range 03/09/95 */

Pt(PR_ORIGINATING_MTA_CERTIFICATE),
Pt(PR_PROOF_OF_SUBMISSION),


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 */

Pt(PR_ENTRYID),
Pt(PR_OBJECT_TYPE),
Pt(PR_ICON),
Pt(PR_MINI_ICON),
Pt(PR_STORE_ENTRYID),
Pt(PR_STORE_RECORD_KEY),
Pt(PR_RECORD_KEY),
Pt(PR_MAPPING_SIGNATURE),
Pt(PR_ACCESS_LEVEL),
Pt(PR_INSTANCE_KEY),
Pt(PR_ROW_TYPE),
Pt(PR_ACCESS),

/*
 * properties that are common to multiple objects (usually not including message objects)
 */

Pt(PR_ROWID),
Pt(PR_DISPLAY_NAME),
Pt(PR_DISPLAY_NAME_W),
Pt(PR_DISPLAY_NAME_A),
Pt(PR_ADDRTYPE),
Pt(PR_ADDRTYPE_W),
Pt(PR_ADDRTYPE_A),
Pt(PR_EMAIL_ADDRESS),
Pt(PR_EMAIL_ADDRESS_W),
Pt(PR_EMAIL_ADDRESS_A),
Pt(PR_COMMENT),
Pt(PR_COMMENT_W),
Pt(PR_COMMENT_A),
Pt(PR_DEPTH),
Pt(PR_PROVIDER_DISPLAY),
Pt(PR_PROVIDER_DISPLAY_W),
Pt(PR_PROVIDER_DISPLAY_A),
Pt(PR_CREATION_TIME),
Pt(PR_LAST_MODIFICATION_TIME),
Pt(PR_RESOURCE_FLAGS),
Pt(PR_PROVIDER_DLL_NAME),
Pt(PR_PROVIDER_DLL_NAME_W),
Pt(PR_PROVIDER_DLL_NAME_A),
Pt(PR_SEARCH_KEY),
Pt(PR_PROVIDER_UID),
Pt(PR_PROVIDER_ORDINAL),

/*
 *  MAPI Form properties
 */
Pt(PR_FORM_VERSION),
Pt(PR_FORM_VERSION_W),
Pt(PR_FORM_VERSION_A),
Pt(PR_FORM_CLSID),
Pt(PR_FORM_CONTACT_NAME),
Pt(PR_FORM_CONTACT_NAME_W),
Pt(PR_FORM_CONTACT_NAME_A),
Pt(PR_FORM_CATEGORY),
Pt(PR_FORM_CATEGORY_W),
Pt(PR_FORM_CATEGORY_A),
Pt(PR_FORM_CATEGORY_SUB),
Pt(PR_FORM_CATEGORY_SUB_W),
Pt(PR_FORM_CATEGORY_SUB_A),
Pt(PR_FORM_HOST_MAP),
Pt(PR_FORM_HIDDEN),
Pt(PR_FORM_DESIGNER_NAME),
Pt(PR_FORM_DESIGNER_NAME_W),
Pt(PR_FORM_DESIGNER_NAME_A),
Pt(PR_FORM_DESIGNER_GUID),
Pt(PR_FORM_MESSAGE_BEHAVIOR),

/*
 *  Message store properties
 */

Pt(PR_DEFAULT_STORE),
Pt(PR_STORE_SUPPORT_MASK),
Pt(PR_STORE_STATE),

Pt(PR_IPM_SUBTREE_SEARCH_KEY),
Pt(PR_IPM_OUTBOX_SEARCH_KEY),
Pt(PR_IPM_WASTEBASKET_SEARCH_KEY),
Pt(PR_IPM_SENTMAIL_SEARCH_KEY),
Pt(PR_MDB_PROVIDER),
Pt(PR_RECEIVE_FOLDER_SETTINGS),

Pt(PR_VALID_FOLDER_MASK),
Pt(PR_IPM_SUBTREE_ENTRYID),

Pt(PR_IPM_OUTBOX_ENTRYID),
Pt(PR_IPM_WASTEBASKET_ENTRYID),
Pt(PR_IPM_SENTMAIL_ENTRYID),
Pt(PR_VIEWS_ENTRYID),
Pt(PR_COMMON_VIEWS_ENTRYID),
Pt(PR_FINDER_ENTRYID),

/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

Pt(PR_CONTAINER_FLAGS),
Pt(PR_FOLDER_TYPE),
Pt(PR_CONTENT_COUNT),
Pt(PR_CONTENT_UNREAD),
Pt(PR_CREATE_TEMPLATES),
Pt(PR_DETAILS_TABLE),
Pt(PR_SEARCH),
Pt(PR_SELECTABLE),
Pt(PR_SUBFOLDERS),
Pt(PR_STATUS),
Pt(PR_ANR),
Pt(PR_ANR_W),
Pt(PR_ANR_A),
Pt(PR_CONTENTS_SORT_ORDER),
Pt(PR_CONTAINER_HIERARCHY),
Pt(PR_CONTAINER_CONTENTS),
Pt(PR_FOLDER_ASSOCIATED_CONTENTS),
Pt(PR_DEF_CREATE_DL),
Pt(PR_DEF_CREATE_MAILUSER),
Pt(PR_CONTAINER_CLASS),
Pt(PR_CONTAINER_CLASS_W),
Pt(PR_CONTAINER_CLASS_A),
Pt(PR_CONTAINER_MODIFY_VERSION),
Pt(PR_AB_PROVIDER_ID),
Pt(PR_DEFAULT_VIEW_ENTRYID),
Pt(PR_ASSOC_CONTENT_COUNT),

/* Don't use 36FE and 36FF */

/*
 *  Attachment properties
 */

Pt(PR_ATTACHMENT_X400_PARAMETERS),
Pt(PR_ATTACH_DATA_OBJ),
Pt(PR_ATTACH_DATA_BIN),
Pt(PR_ATTACH_ENCODING),
Pt(PR_ATTACH_EXTENSION),
Pt(PR_ATTACH_EXTENSION_W),
Pt(PR_ATTACH_EXTENSION_A),
Pt(PR_ATTACH_FILENAME),
Pt(PR_ATTACH_FILENAME_W),
Pt(PR_ATTACH_FILENAME_A),
Pt(PR_ATTACH_METHOD),
Pt(PR_ATTACH_LONG_FILENAME),
Pt(PR_ATTACH_LONG_FILENAME_W),
Pt(PR_ATTACH_LONG_FILENAME_A),
Pt(PR_ATTACH_PATHNAME),
Pt(PR_ATTACH_PATHNAME_W),
Pt(PR_ATTACH_PATHNAME_A),
Pt(PR_ATTACH_RENDERING),
Pt(PR_ATTACH_TAG),
Pt(PR_RENDERING_POSITION),
Pt(PR_ATTACH_TRANSPORT_NAME),
Pt(PR_ATTACH_TRANSPORT_NAME_W),
Pt(PR_ATTACH_TRANSPORT_NAME_A),
Pt(PR_ATTACH_LONG_PATHNAME),
Pt(PR_ATTACH_LONG_PATHNAME_W),
Pt(PR_ATTACH_LONG_PATHNAME_A),
Pt(PR_ATTACH_MIME_TAG),
Pt(PR_ATTACH_MIME_TAG_W),
Pt(PR_ATTACH_MIME_TAG_A),

/*
 *  AB Object properties
 */

Pt(PR_DISPLAY_TYPE),
Pt(PR_TEMPLATEID),
Pt(PR_PRIMARY_CAPABILITY),

/*
 *  Mail user properties
 */

Pt(PR_ACCOUNT),
Pt(PR_ACCOUNT_W),
Pt(PR_ACCOUNT_A),
Pt(PR_ALTERNATE_RECIPIENT),
Pt(PR_CALLBACK_TELEPHONE_NUMBER),
Pt(PR_CALLBACK_TELEPHONE_NUMBER_W),
Pt(PR_CALLBACK_TELEPHONE_NUMBER_A),
Pt(PR_CONVERSION_PROHIBITED),
Pt(PR_DISCLOSE_RECIPIENTS),
Pt(PR_GENERATION),
Pt(PR_GENERATION_W),
Pt(PR_GENERATION_A),
Pt(PR_GIVEN_NAME),
Pt(PR_GIVEN_NAME_W),
Pt(PR_GIVEN_NAME_A),
Pt(PR_GOVERNMENT_ID_NUMBER),
Pt(PR_GOVERNMENT_ID_NUMBER_W),
Pt(PR_GOVERNMENT_ID_NUMBER_A),
Pt(PR_BUSINESS_TELEPHONE_NUMBER),
Pt(PR_BUSINESS_TELEPHONE_NUMBER_W),
Pt(PR_BUSINESS_TELEPHONE_NUMBER_A),
Pt(PR_OFFICE_TELEPHONE_NUMBER),
Pt(PR_OFFICE_TELEPHONE_NUMBER_W),
Pt(PR_OFFICE_TELEPHONE_NUMBER_A),
Pt(PR_HOME_TELEPHONE_NUMBER),
Pt(PR_HOME_TELEPHONE_NUMBER_W),
Pt(PR_HOME_TELEPHONE_NUMBER_A),
Pt(PR_INITIALS),
Pt(PR_INITIALS_W),
Pt(PR_INITIALS_A),
Pt(PR_KEYWORD),
Pt(PR_KEYWORD_W),
Pt(PR_KEYWORD_A),
Pt(PR_LANGUAGE),
Pt(PR_LANGUAGE_W),
Pt(PR_LANGUAGE_A),
Pt(PR_LOCATION),
Pt(PR_LOCATION_W),
Pt(PR_LOCATION_A),
Pt(PR_MAIL_PERMISSION),
Pt(PR_MHS_COMMON_NAME),
Pt(PR_MHS_COMMON_NAME_W),
Pt(PR_MHS_COMMON_NAME_A),
Pt(PR_ORGANIZATIONAL_ID_NUMBER),
Pt(PR_ORGANIZATIONAL_ID_NUMBER_W),
Pt(PR_ORGANIZATIONAL_ID_NUMBER_A),
Pt(PR_SURNAME),
Pt(PR_SURNAME_W),
Pt(PR_SURNAME_A),
Pt(PR_ORIGINAL_ENTRYID),
Pt(PR_ORIGINAL_DISPLAY_NAME),
Pt(PR_ORIGINAL_DISPLAY_NAME_W),
Pt(PR_ORIGINAL_DISPLAY_NAME_A),
Pt(PR_ORIGINAL_SEARCH_KEY),
Pt(PR_POSTAL_ADDRESS),
Pt(PR_POSTAL_ADDRESS_W),
Pt(PR_POSTAL_ADDRESS_A),
Pt(PR_COMPANY_NAME),
Pt(PR_COMPANY_NAME_W),
Pt(PR_COMPANY_NAME_A),
Pt(PR_TITLE),
Pt(PR_TITLE_W),
Pt(PR_TITLE_A),
Pt(PR_DEPARTMENT_NAME),
Pt(PR_DEPARTMENT_NAME_W),
Pt(PR_DEPARTMENT_NAME_A),
Pt(PR_OFFICE_LOCATION),
Pt(PR_OFFICE_LOCATION_W),
Pt(PR_OFFICE_LOCATION_A),
Pt(PR_PRIMARY_TELEPHONE_NUMBER),
Pt(PR_PRIMARY_TELEPHONE_NUMBER_W),
Pt(PR_PRIMARY_TELEPHONE_NUMBER_A),
Pt(PR_BUSINESS2_TELEPHONE_NUMBER),
Pt(PR_BUSINESS2_TELEPHONE_NUMBER_W),
Pt(PR_BUSINESS2_TELEPHONE_NUMBER_A),
Pt(PR_OFFICE2_TELEPHONE_NUMBER),
Pt(PR_OFFICE2_TELEPHONE_NUMBER_W),
Pt(PR_OFFICE2_TELEPHONE_NUMBER_A),
Pt(PR_MOBILE_TELEPHONE_NUMBER),
Pt(PR_MOBILE_TELEPHONE_NUMBER_W),
Pt(PR_MOBILE_TELEPHONE_NUMBER_A),
Pt(PR_CELLULAR_TELEPHONE_NUMBER),
Pt(PR_CELLULAR_TELEPHONE_NUMBER_W),
Pt(PR_CELLULAR_TELEPHONE_NUMBER_A),
Pt(PR_RADIO_TELEPHONE_NUMBER),
Pt(PR_RADIO_TELEPHONE_NUMBER_W),
Pt(PR_RADIO_TELEPHONE_NUMBER_A),
Pt(PR_CAR_TELEPHONE_NUMBER),
Pt(PR_CAR_TELEPHONE_NUMBER_W),
Pt(PR_CAR_TELEPHONE_NUMBER_A),
Pt(PR_OTHER_TELEPHONE_NUMBER),
Pt(PR_OTHER_TELEPHONE_NUMBER_W),
Pt(PR_OTHER_TELEPHONE_NUMBER_A),
Pt(PR_TRANSMITABLE_DISPLAY_NAME),
Pt(PR_TRANSMITABLE_DISPLAY_NAME_W),
Pt(PR_TRANSMITABLE_DISPLAY_NAME_A),
Pt(PR_PAGER_TELEPHONE_NUMBER),
Pt(PR_PAGER_TELEPHONE_NUMBER_W),
Pt(PR_PAGER_TELEPHONE_NUMBER_A),
Pt(PR_BEEPER_TELEPHONE_NUMBER),
Pt(PR_BEEPER_TELEPHONE_NUMBER_W),
Pt(PR_BEEPER_TELEPHONE_NUMBER_A),
Pt(PR_USER_CERTIFICATE),
Pt(PR_PRIMARY_FAX_NUMBER),
Pt(PR_PRIMARY_FAX_NUMBER_W),
Pt(PR_PRIMARY_FAX_NUMBER_A),
Pt(PR_BUSINESS_FAX_NUMBER),
Pt(PR_BUSINESS_FAX_NUMBER_W),
Pt(PR_BUSINESS_FAX_NUMBER_A),
Pt(PR_HOME_FAX_NUMBER),
Pt(PR_HOME_FAX_NUMBER_W),
Pt(PR_HOME_FAX_NUMBER_A),
Pt(PR_COUNTRY),
Pt(PR_COUNTRY_W),
Pt(PR_COUNTRY_A),
Pt(PR_LOCALITY),
Pt(PR_LOCALITY_W),
Pt(PR_LOCALITY_A),
Pt(PR_STATE_OR_PROVINCE),
Pt(PR_STATE_OR_PROVINCE_W),
Pt(PR_STATE_OR_PROVINCE_A),
Pt(PR_STREET_ADDRESS),
Pt(PR_STREET_ADDRESS_W),
Pt(PR_STREET_ADDRESS_A),
Pt(PR_POSTAL_CODE),
Pt(PR_POSTAL_CODE_W),
Pt(PR_POSTAL_CODE_A),
Pt(PR_POST_OFFICE_BOX),
Pt(PR_POST_OFFICE_BOX_W),
Pt(PR_POST_OFFICE_BOX_A),
Pt(PR_TELEX_NUMBER),
Pt(PR_TELEX_NUMBER_W),
Pt(PR_TELEX_NUMBER_A),
Pt(PR_ISDN_NUMBER),
Pt(PR_ISDN_NUMBER_W),
Pt(PR_ISDN_NUMBER_A),
Pt(PR_ASSISTANT_TELEPHONE_NUMBER),
Pt(PR_ASSISTANT_TELEPHONE_NUMBER_W),
Pt(PR_ASSISTANT_TELEPHONE_NUMBER_A),
Pt(PR_HOME2_TELEPHONE_NUMBER),
Pt(PR_HOME2_TELEPHONE_NUMBER_W),
Pt(PR_HOME2_TELEPHONE_NUMBER_A),
Pt(PR_ASSISTANT),
Pt(PR_ASSISTANT_W),
Pt(PR_ASSISTANT_A),
Pt(PR_SEND_RICH_INFO),

/*
 *  Profile section properties
 */

Pt(PR_STORE_PROVIDERS),
Pt(PR_AB_PROVIDERS),
Pt(PR_TRANSPORT_PROVIDERS),

Pt(PR_DEFAULT_PROFILE),
Pt(PR_AB_SEARCH_PATH),
Pt(PR_AB_DEFAULT_DIR),
Pt(PR_AB_DEFAULT_PAB),
Pt(PR_FILTERING_HOOKS),
Pt(PR_SERVICE_NAME),
Pt(PR_SERVICE_NAME_W),
Pt(PR_SERVICE_NAME_A),
Pt(PR_SERVICE_DLL_NAME),
Pt(PR_SERVICE_DLL_NAME_W),
Pt(PR_SERVICE_DLL_NAME_A),
Pt(PR_SERVICE_ENTRY_NAME),
Pt(PR_SERVICE_UID),
Pt(PR_SERVICE_EXTRA_UIDS),
Pt(PR_SERVICES),
Pt(PR_SERVICE_SUPPORT_FILES),
Pt(PR_SERVICE_SUPPORT_FILES_W),
Pt(PR_SERVICE_SUPPORT_FILES_A),
Pt(PR_SERVICE_DELETE_FILES),
Pt(PR_SERVICE_DELETE_FILES_W),
Pt(PR_SERVICE_DELETE_FILES_A),
Pt(PR_AB_SEARCH_PATH_UPDATE),
Pt(PR_PROFILE_NAME),
Pt(PR_PROFILE_NAME_A),
Pt(PR_PROFILE_NAME_W),

/*
 *  Status object properties
 */

Pt(PR_IDENTITY_DISPLAY),
Pt(PR_IDENTITY_DISPLAY_W),
Pt(PR_IDENTITY_DISPLAY_A),
Pt(PR_IDENTITY_ENTRYID),
Pt(PR_RESOURCE_METHODS),
Pt(PR_RESOURCE_TYPE),
Pt(PR_STATUS_CODE),
Pt(PR_IDENTITY_SEARCH_KEY),
Pt(PR_OWN_STORE_ENTRYID),
Pt(PR_RESOURCE_PATH),
Pt(PR_RESOURCE_PATH_W),
Pt(PR_RESOURCE_PATH_A),
Pt(PR_STATUS_STRING),
Pt(PR_STATUS_STRING_W),
Pt(PR_STATUS_STRING_A),
Pt(PR_X400_DEFERRED_DELIVERY_CANCEL),
Pt(PR_HEADER_FOLDER_ENTRYID),
Pt(PR_REMOTE_PROGRESS),
Pt(PR_REMOTE_PROGRESS_TEXT),
Pt(PR_REMOTE_PROGRESS_TEXT_W),
Pt(PR_REMOTE_PROGRESS_TEXT_A),
Pt(PR_REMOTE_VALIDATE_OK),

/*
 * Display table properties
 */

Pt(PR_CONTROL_FLAGS),
Pt(PR_CONTROL_STRUCTURE),
Pt(PR_CONTROL_TYPE),
Pt(PR_DELTAX),
Pt(PR_DELTAY),
Pt(PR_XPOS),
Pt(PR_YPOS),
Pt(PR_CONTROL_ID),
Pt(PR_INITIAL_DETAILS_PANE),

/*
 * Secure property id range
 */



#endif  /* _TAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\migrate.cpp ===
// --------------------------------------------------------------------------------
// Migrate.cpp
// --------------------------------------------------------------------------------
#define INITGUID
#include "pch.hxx"
#include <initguid.h>
#define DEFINE_STRCONST
#include <mimeole.h>
#include "migrate.h"
#include "utility.h"
#include "resource.h"
#include "migerror.h"
#include <oestore.h>
#include "structs.h"
#include "strparse.h"
#include "msident.h"
              
// --------------------------------------------------------------------------------
// Debug Strings
// --------------------------------------------------------------------------------
#ifdef DEBUG
static const TCHAR c_szDebug[]      = "mshtmdbg.dll";
static const TCHAR c_szDebugUI[]    = "DoTracePointsDialog";
static const TCHAR c_szRegSpy[]     = "DbgRegisterMallocSpy";
static const TCHAR c_szInvokeUI[]   = "/d";
#endif

// --------------------------------------------------------------------------------
// MSHTMDBG.DLL Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
typedef void (STDAPICALLTYPE *PFNDEBUGUI)(BOOL);
typedef void (STDAPICALLTYPE *PFNREGSPY)(void);
#endif

// --------------------------------------------------------------------------------
// Debug Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
HINSTANCE g_hInstDebug=NULL;
void LoadMSHTMDBG(LPSTR pszCmdLine);
#endif

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
IMalloc             *g_pMalloc=NULL;
HINSTANCE            g_hInst=NULL;
DWORD                g_dwTlsMsgBuffIndex=0xffffffff;
DWORD                g_cbDiskNeeded=0;
DWORD                g_cbDiskFree=0;
ACCOUNTTABLE         g_AcctTable={0};
BOOL                 g_fQuiet = FALSE;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT DowngradeV5B1(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreRoot, LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile);
INT_PTR CALLBACK MigrageErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT UpgradeV5(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreSrc, LPCSTR pszStoreDst, LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile);
HRESULT ParseCommandLine(LPCSTR pszCmdLine, LPSTR pszMigrate, DWORD cbMigrateMax,
    LPSTR pszStoreSrc, DWORD cbStoreSrc, LPSTR pszStoreDst, DWORD cbStoreDst,
    LPSTR pszUserKey, DWORD cbUserKey);
HRESULT RemapUsersKey(LPSTR pszUsersKey);
void ThreadAllocateTlsMsgBuffer(void);
void ThreadFreeTlsMsgBuffer(void);

// --------------------------------------------------------------------------------
// How big is the thread local storage string buffer
// -------------------------------------------------------------------------------
#define CBMAX_THREAD_TLS_BUFFER 512

#define ICC_FLAGS (ICC_PROGRESS_CLASS|ICC_NATIVEFNTCTL_CLASS)

// --------------------------------------------------------------------------------
// WinMain
//
// Command Line Format:
// --------------------
// /type:V1+V4-V5 /src:"Source Store Root" /dst:"Destination Store Root"
// --------------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR pszCmdLine, int nCmdShow)
{
    // Locals
    HRESULT                 hr=S_OK;
    PROGRESSINFO            Progress={0};
    CHAR                    szMigrate[50];
    CHAR                    szStoreSrc[MAX_PATH];
    CHAR                    szStoreDst[MAX_PATH];
    CHAR                    szUsersKey[MAX_PATH];
    LPFILEINFO              pHeadFile=NULL;
    MIGRATETOTYPE           tyMigrate;
    CHAR                    szMsg[512];
    HANDLE                  hMutex=NULL;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    // Tracing
    TraceCall("WinMain");

    // Validation
    Assert(sizeof(TABLEHEADERV5B1) == sizeof(TABLEHEADERV5));

    // Create Mutex
    IF_NULLEXIT(hMutex = CreateMutex(NULL, FALSE, "OutlookExpressMigration"));

    // Wait for the Mutex
    if (WAIT_FAILED == WaitForSingleObject(hMutex, INFINITE))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Initialzie OLE
    IF_FAILEXIT(hr = CoInitialize(NULL));
   
    // Save hInst
    g_hInst = hInst;

    // Load Debug DLL
    IF_DEBUG(LoadMSHTMDBG(pszCmdLine);)

    szUsersKey[0] = 0;

    // Crack the command line
    IF_FAILEXIT(hr = ParseCommandLine(pszCmdLine, szMigrate, ARRAYSIZE(szMigrate), szStoreSrc, ARRAYSIZE(szStoreSrc), szStoreDst, ARRAYSIZE(szStoreDst), szUsersKey, ARRAYSIZE(szUsersKey)));

    // Load the user hive, if needed
    IF_FAILEXIT(RemapUsersKey(szUsersKey));

    // Initialzie Common Controls
    InitCommonControlsEx(&icex);

    // Get the task allocator
    IF_FAILEXIT(hr = CoGetMalloc(MEMCTX_TASK, &g_pMalloc));

    // Tlsalloc
    g_dwTlsMsgBuffIndex = TlsAlloc();

    // allocat
    ThreadAllocateTlsMsgBuffer();

    // Create Dialog
    if(!g_fQuiet)
    {
        Progress.hwndProgress = CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_PROGRESS), GetDesktopWindow(), (DLGPROC)MigrageDlgProc);

        // Bad Mojo
        if (NULL == Progress.hwndProgress)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Center
        CenterDialog(Progress.hwndProgress);

        // Show the Window
        ShowWindow(Progress.hwndProgress, SW_NORMAL);
    }

    // V5-V4
    if (lstrcmpi(szMigrate, "V5-V4") == 0)
    {
        // Locals
        CHAR szRes[255];
        CHAR szCaption[255];

        // LoadString
        LoadString(g_hInst, IDS_IMPORTMSG, szRes, ARRAYSIZE(szRes));

        // LoadString
        LoadString(g_hInst, IDS_TITLE, szCaption, ARRAYSIZE(szCaption));
        
        // Message
        if(!g_fQuiet)
            MessageBox(NULL, szRes, szCaption, MB_OK | MB_ICONEXCLAMATION);

        // Done
        goto exit;
    }

    // V5-V1
    else if (lstrcmpi(szMigrate, "V5-V1") == 0)
    {
        // Locals
        CHAR szRes[255];
        CHAR szCaption[255];

        // LoadString
        LoadString(g_hInst, IDS_V1NYI, szRes, ARRAYSIZE(szRes));

        // LoadString
        LoadString(g_hInst, IDS_TITLE, szCaption, ARRAYSIZE(szCaption));
        
        // Message
        if(!g_fQuiet)
            MessageBox(NULL, szRes, szCaption, MB_OK | MB_ICONEXCLAMATION);

        // Done
        goto exit;
    }

    // V1-V5 or V4-V5
    else if (lstrcmpi(szMigrate, "V1+V4-V5") == 0)
    {
        // Build the Account Table - Takes path to accounts not IAM
        IF_FAILEXIT(hr = BuildAccountTable(HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Account Manager\\Accounts", szStoreSrc, &g_AcctTable));

        // Set tyMigrate
        tyMigrate = UPGRADE_V1_OR_V4_TO_V5;

        // RegressFromV5ToV4orV1
        hr = UpgradeV5(tyMigrate, szStoreSrc, szStoreDst, &Progress, &pHeadFile);
    }

    // V5B1-V1
    else if (lstrcmpi(szMigrate, "V5B1-V1") == 0)
    {
        // Set tyMigrate
        tyMigrate = DOWNGRADE_V5B1_TO_V4;

        hr = DowngradeV5B1(tyMigrate, szStoreSrc, &Progress, &pHeadFile);
    }

    // V5B1-V4 
    else if (lstrcmpi(szMigrate, "V5B1-V4") == 0)
    {
        // Set tyMigrate
        tyMigrate = DOWNGRADE_V5B1_TO_V4;

        hr = DowngradeV5B1(tyMigrate, szStoreSrc, &Progress, &pHeadFile);
    }

    // Bad Command Line
    else
    {
        // Bad Command Line
        AssertSz(FALSE, "Invalid Command line arguments passed into oemig50.exe");

        // Failure
        hr = TraceResult(E_FAIL);

        // Done
        goto exit;
    }

    // Kill the Window
    if(!g_fQuiet)
        DestroyWindow(Progress.hwndProgress);
    Progress.hwndProgress = NULL;

    // Write Migration Log File
    WriteMigrationLogFile(hr, GetLastError(), szStoreSrc, szMigrate, pszCmdLine, pHeadFile);

    // Trace It
    if (FAILED(hr))
    {
        // Trace It
        TraceResult(hr);

        // Handle the Error message
        if (MIGRATE_E_NOTENOUGHDISKSPACE == hr)
        {
            // Locals
            CHAR        szRes[255];
            CHAR        szScratch1[50];
            CHAR        szScratch2[50];

            // LoadString
            LoadString(g_hInst, IDS_DISKSPACEERROR, szRes, ARRAYSIZE(szRes));

            // Format the Error
            wsprintf(szMsg, szRes, StrFormatByteSize64A(g_cbDiskNeeded, szScratch1, ARRAYSIZE(szScratch1)), StrFormatByteSize64A(g_cbDiskFree, szScratch2, ARRAYSIZE(szScratch2)));
        }

        // Sharing Violation...
        else if (MIGRATE_E_SHARINGVIOLATION == hr)
        {
            // LoadString
            LoadString(g_hInst, IDS_SHARINGVIOLATION, szMsg, ARRAYSIZE(szMsg));
        }

        // General Failure
        else
        {
            // LoadString
            LoadString(g_hInst, IDS_GENERALERROR, szMsg, ARRAYSIZE(szMsg));
        }

        // Do the dialog
        if(!g_fQuiet)           
            hr = (HRESULT) DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_MIGRATEERROR), NULL, MigrageErrorDlgProc, (LPARAM)szMsg);
    }

    // Otherwise, success
    else
        hr = MIGRATE_S_SUCCESS;

exit:
    // Cleanup
    SafeMemFree(g_AcctTable.prgAccount);
    FreeFileList(&pHeadFile);
    if (Progress.hwndProgress)
        DestroyWindow(Progress.hwndProgress);
    ThreadFreeTlsMsgBuffer();
    if (0xffffffff != g_dwTlsMsgBuffIndex)
        TlsFree(g_dwTlsMsgBuffIndex);
    SafeRelease(g_pMalloc);

    IF_DEBUG(if (g_hInstDebug) FreeLibrary(g_hInstDebug);)

    // Cleanup
    CoUninitialize();

    // Release the mutex
    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    // Done
    return (INT)hr;
}

// --------------------------------------------------------------------------------
// ParseCommandLine
// -------------------------------------------------------------------------------
HRESULT ParseCommandLine(LPCSTR pszCmdLine, LPSTR pszMigrate, DWORD cbMigrate,
    LPSTR pszStoreSrc, DWORD cbStoreSrc, LPSTR pszStoreDst, DWORD cbStoreDst, 
    LPSTR pszUsersKey, DWORD cbUsersKey)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                chToken;
    CStringParser       cParser;

    // Trace
    TraceCall("ParseCommandLine");

    // Initialize
    *pszMigrate = *pszStoreSrc = *pszStoreDst = '\0';

    // Init
    cParser.Init(pszCmdLine, lstrlen(pszCmdLine), PSF_DBCS | PSF_NOTRAILWS | PSF_NOFRONTWS);

    // Parse to first /
    chToken = cParser.ChParse("/");
    if ('/' != chToken)
        goto exit;

    // Parse to :
    chToken = cParser.ChParse(":");
    if (':' != chToken)
        goto exit;

    // Check parameter name
    if (0 != lstrcmpi(cParser.PszValue(), "type"))
        goto exit;

    // Parse to /
    chToken = cParser.ChParse("/");
    if ('/' != chToken)
        goto exit;

    // Copy the Value
    lstrcpyn(pszMigrate, cParser.PszValue(), cbMigrate - 1);

    // Parse to :
    chToken = cParser.ChParse(":");
    if (':' != chToken)
        goto exit;

    // Check parameter name
    if (0 != lstrcmpi(cParser.PszValue(), "src"))
        goto exit;

    // Parse to /
    chToken = cParser.ChParse("/");
    if ('/' != chToken)
        goto exit;

    // Copy the Value
    lstrcpyn(pszStoreSrc, cParser.PszValue(), cbStoreSrc - 1);

    // Parse to :
    chToken = cParser.ChParse(":");
    if (':' != chToken)
        goto exit;

    // Check parameter name
    if (0 != lstrcmpi(cParser.PszValue(), "dst"))
        goto exit;

    // Parse to /
    chToken = cParser.ChParse("/");
    if (('/' != chToken) && ('\0' != chToken))
        goto exit;

    // Copy the Value
    lstrcpyn(pszStoreDst, cParser.PszValue(), cbStoreDst - 1);

    if ('/' == chToken)
    {
        chToken = cParser.ChParse("/");
        if ('\0' == chToken || '/' == chToken)
        {
            if (0 == lstrcmpi(cParser.PszValue(), "quiet"))
                g_fQuiet = TRUE;
        }
    }

    if ('/' == chToken)
    {
        // Parse to :
        chToken = cParser.ChParse(":");
        if (':' == chToken)
        {
            // Check parameter name
            if (0 == lstrcmpi(cParser.PszValue(), "key")) 
            {
                // Parse to end
                chToken = cParser.ChParse("");
                if ('\0' == chToken)
                {
                    // Copy the Value
                    lstrcpyn(pszUsersKey, cParser.PszValue(), cbUsersKey - 1);
               }
           }
        }
    }

exit:
    // Failure Already
    if (FAILED(hr))
        return(hr);

    // Set hr
    hr = (*pszMigrate == '\0' || *pszStoreSrc == '\0' || *pszStoreDst == '\0') ? E_FAIL : S_OK;

    // Assert
    AssertSz(SUCCEEDED(hr), "Invalid Command line passed into oemig50.exe.");

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// LoadUserHive
// -------------------------------------------------------------------------------
HRESULT RemapUsersKey(LPSTR pszUsersKey)
{
    // Locals
    HRESULT     hr = S_OK;
    HKEY        hKey;

    if (pszUsersKey && *pszUsersKey) {
        // Open the user's key
        hr = RegOpenKey (HKEY_USERS, pszUsersKey, &hKey);

        if (SUCCEEDED(hr)) {
            // Remap HKCU to point to the user's key
            hr = RegOverridePredefKey (HKEY_CURRENT_USER, hKey);

            // Close the key
            RegCloseKey (hKey);
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// ThreadAllocateTlsMsgBuffer
// -------------------------------------------------------------------------------
void ThreadAllocateTlsMsgBuffer(void)
{
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
        TlsSetValue(g_dwTlsMsgBuffIndex, NULL);
}

// --------------------------------------------------------------------------------
// ThreadFreeTlsMsgBuffer
// -------------------------------------------------------------------------------
void ThreadFreeTlsMsgBuffer(void)
{
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
    {
        LPSTR psz = (LPSTR)TlsGetValue(g_dwTlsMsgBuffIndex);
        SafeMemFree(psz);
        SideAssert(0 != TlsSetValue(g_dwTlsMsgBuffIndex, NULL));
    }
}

// --------------------------------------------------------------------------------
// PszGetTlsBuffer
// -------------------------------------------------------------------------------
LPSTR PszGetTlsBuffer(void)
{
    // Get the buffer
    LPSTR pszBuffer = (LPSTR)TlsGetValue(g_dwTlsMsgBuffIndex);

    // If buffer has not been allocated
    if (NULL == pszBuffer)
    {
        // Allocate it
        pszBuffer = (LPSTR)g_pMalloc->Alloc(CBMAX_THREAD_TLS_BUFFER);

        // Store it
        Assert(pszBuffer);
        SideAssert(0 != TlsSetValue(g_dwTlsMsgBuffIndex, pszBuffer));
    }

    // Done
    return pszBuffer;
}

// --------------------------------------------------------------------------------
// _MSG - Used to build a string from variable length args, thread-safe
// -------------------------------------------------------------------------------
LPCSTR _MSG(LPSTR pszFormat, ...)
{
    // Locals
    va_list     arglist;
    LPSTR       pszBuffer=NULL;

    // I use tls to hold the buffer
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
    {
        // Setup the arglist
        va_start(arglist, pszFormat);

        // Get the Buffer
        pszBuffer = PszGetTlsBuffer();

        // If we have a buffer
        if (pszBuffer)
        {
            // Format the data
            wvsprintf(pszBuffer, pszFormat, arglist);
        }

        // End the arglist
        va_end(arglist);
    }

    return ((LPCSTR)pszBuffer);
}

// --------------------------------------------------------------------------------
// MigrageErrorDlgProc
// --------------------------------------------------------------------------------
INT_PTR CALLBACK MigrageErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetForegroundWindow(hwnd);
        CenterDialog(hwnd);
        SetDlgItemText(hwnd, IDS_MESSAGE, (LPSTR)lParam);
        CheckDlgButton(hwnd, IDR_DONTSTARTOE, BST_CHECKED);
        SetFocus(GetDlgItem(hwnd, IDR_DONTSTARTOE));
        return FALSE;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDOK:
        case IDCANCEL:
            if (IsDlgButtonChecked(hwnd, IDR_DONTSTARTOE))
                EndDialog(hwnd, MIGRATE_E_NOCONTINUE);
            else if (IsDlgButtonChecked(hwnd, IDR_STARTOE))
                EndDialog(hwnd, MIGRATE_S_SUCCESS);
            return 1;
        }
        break;
    }

    // Done
    return FALSE;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// LoadMSHTMDBG
// --------------------------------------------------------------------------------
void LoadMSHTMDBG(LPSTR pszCmdLine)
{
    // Load mshtmdbg.dll
    HINSTANCE g_hInstDebug = LoadLibrary(c_szDebug);

    // Did it load ?
    if (NULL != g_hInstDebug)
    {
        // Locals
        PFNREGSPY  pfnRegSpy;

        // If the user passed /d on the command line, lets configure mshtmdbg.dll
        if (0 == lstrcmpi(pszCmdLine, c_szInvokeUI))
        {
            // Locals
            PFNDEBUGUI pfnDebugUI;

            // Get the proc address of the UI
            pfnDebugUI = (PFNDEBUGUI)GetProcAddress(g_hInstDebug, c_szDebugUI);
            if (NULL != pfnDebugUI)
            {
                (*pfnDebugUI)(TRUE);
                goto exit;
            }

            // Done
            exit(1);
        }

        // Get the process address of the registration
        pfnRegSpy = (PFNREGSPY)GetProcAddress(g_hInstDebug, c_szRegSpy);
        if (NULL != pfnRegSpy)
            (*pfnRegSpy)();
    }

exit:
    // Done
    return;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#ifndef __RESOURCE_H
#define __RESOURCE_H

// --------------------------------------------------------------------------------
// Dialog Ids
// --------------------------------------------------------------------------------
#define IDD_PROGRESS                    101
#define IDD_MIGRATEERROR                102

// --------------------------------------------------------------------------------
// Icon Ids
// --------------------------------------------------------------------------------
#define IDI_MIGRATE                     102

// --------------------------------------------------------------------------------
// Dialog Control Ids
// --------------------------------------------------------------------------------
#define IDC_STATIC                      -1
#define IDC_PROGRESS                    1000
#define IDS_STATUS                      1001
#define IDS_DESCRIPT                    1002
#define IDR_STARTOE                     1003
#define IDR_DONTSTARTOE                 1004
#define IDS_MESSAGE                     1005
#define IDS_NEWSOUTBOX                  1006
#define IDS_NEWSPOSTED                  1007
#define IDS_NEWSSAVED                   1008
#define IDS_POSTEDITEMS                 1009
#define IDS_SAVEDITEMS                  1010
#define IDS_COMPLETE                    1011
#define IDS_TITLE                       1012
#define IDS_MIGRATING                   1013
#define IDS_UPGRADEMESSAGE              1014
#define IDS_DISKSPACEERROR              1015
#define IDS_GENERALERROR                1016
#define IDS_IMPORTMSG                   1017
#define IDS_V1NYI                       1018
#define IDS_SHARINGVIOLATION            1019

#define IDS_INBOX                       5000
#define IDS_OUTBOX                      5001
#define IDS_SENTITEMS                   5002
#define IDS_DELETED                     5003
#define IDS_DRAFT                       5004

// --------------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------------
#define IDS_BYTES                       0x103
#define IDS_ORDERKB                     0x104
#define IDS_ORDERMB                     0x105
#define IDS_ORDERGB                     0x106
#define IDS_ORDERTB                     0x107
#define IDS_ORDERPB                     0x108
#define IDS_ORDEREB                     0x109

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\structs.h ===
//--------------------------------------------------------------------------
// Structs.h
//--------------------------------------------------------------------------
#ifndef __STRUCTS_H
#define __STRUCTS_H

//--------------------------------------------------------------------------
// OBJECTDB_SIGNATURE
//--------------------------------------------------------------------------
#define OBJECTDB_SIGNATURE 0xfe12adcf
#define BTREE_ORDER        40
#define BTREE_MIN_CAP      20

//--------------------------------------------------------------------------
// OBJECTDB_VERSION_V5B1
//--------------------------------------------------------------------------
#define OBJECTDB_VERSION_PRE_V5     2
#define OBJECTDB_VERSION_V5         5
#define ACACHE_VERSION_PRE_V5       9
#define	FLDCACHE_VERSION_PRE_V5     2
#define UIDCACHE_VERSION_PRE_V5     4

//--------------------------------------------------------------------------
// ALLOCATEPAGE
//--------------------------------------------------------------------------
typedef struct tagALLOCATEPAGE {
	DWORD			    faPage;
	DWORD				cbPage;
	DWORD				cbUsed;
} ALLOCATEPAGE, *LPALLOCATEPAGE;

//--------------------------------------------------------------------------
// TABLEHEADERV5B1
//--------------------------------------------------------------------------
typedef struct tagTABLEHEADERV5B1 {
    DWORD               dwSignature;            // 4
    WORD                wMinorVersion;          // 6
    WORD                wMajorVersion;          // 8
    DWORD               faRootChain;            // 12
    DWORD               faFreeRecordBlock;      // 16
    DWORD               faFirstRecord;          // 20
    DWORD               faLastRecord;           // 24
    DWORD               cRecords;               // 28
    DWORD               cbAllocated;            // 32
    DWORD               cbFreed;                // 34
    DWORD               dwReserved1;            // 38
    DWORD               dwReserved2;            // 42
    DWORD               cbUserData;             // 46
    DWORD               cDeletes;               // 50
    DWORD               cInserts;               // 54
    LONG                cActiveThreads;         // 58
    DWORD               dwReserved3;            // 62
    DWORD               cbStreams;              // 66
    DWORD               faFreeStreamBlock;      // 70
    DWORD               faFreeChainBlock;       // 74
    DWORD               faNextAllocate;         // 78
    DWORD               dwNextId;               // 82
	ALLOCATEPAGE	    AllocateRecord;         // 94
	ALLOCATEPAGE	    AllocateChain;          // 106
	ALLOCATEPAGE	    AllocateStream;         // 118
    BYTE                fCorrupt;               // 119
    BYTE                fCorruptCheck;          // 120
    BYTE                rgReserved[190];        // 310
} TABLEHEADERV5B1, *LPTABLEHEADERV5B1;

//--------------------------------------------------------------------------
// TABLEHEADERV5
//--------------------------------------------------------------------------
typedef struct tagTABLEHEADERV5 {
    DWORD               dwSignature;          // 4
    CLSID               clsidExtension;       // 20
    DWORD               dwMinorVersion;       // 24
    DWORD               dwMajorVersion;       // 28
    DWORD               cbUserData;           // 32
    DWORD               rgfaIndex[32];        // 160
    DWORD               faFirstRecord;        // 164
    DWORD               faLastRecord;         // 168
	ALLOCATEPAGE		AllocateRecord;       // 180
	ALLOCATEPAGE		AllocateChain;        // 192
	ALLOCATEPAGE		AllocateStream;       // 204
    DWORD               faFreeRecordBlock;    // 208
    DWORD               faFreeStreamBlock;    // 212
    DWORD               faFreeChainBlock;     // 216
    DWORD               faNextAllocate;       // 220
    DWORD               cbAllocated;          // 224
    DWORD               cbFreed;              // 228
    DWORD               cbStreams;            // 232
    DWORD               cRecords;             // 236
    DWORD               dwNextId;             // 240
    DWORD               fCorrupt;             // 244
    DWORD               fCorruptCheck;        // 248
    DWORD               cActiveThreads;       // 252
    BYTE                rgReserved[58];       // 310
} TABLEHEADERV5, *LPTABLEHEADERV5;

//--------------------------------------------------------------------------
// CHAINNODEV5B1
//--------------------------------------------------------------------------
typedef struct tagCHAINNODEV5B1 {
    DWORD               faRecord;
    DWORD               cbRecord;
    DWORD               faRightChain;
} CHAINNODEV5B1, *LPCHAINNODEV5B1;

//--------------------------------------------------------------------------
// CHAINBLOCKV5B1
//--------------------------------------------------------------------------
typedef struct tagCHAINBLOCKV5B1 {
    DWORD               faStart;
    LONG                cNodes;
    DWORD               faLeftChain;
    CHAINNODEV5B1       rgNode[BTREE_ORDER + 1];
} CHAINBLOCKV5B1, *LPCHAINBLOCKV5B1;

#define CB_CHAIN_BLOCKV5B1 (sizeof(CHAINBLOCKV5B1) - sizeof(CHAINNODEV5B1))

//--------------------------------------------------------------------------
// CHAINNODEV5 - 492 bytes
//--------------------------------------------------------------------------
typedef struct tagCHAINNODEV5 {
    DWORD               faRecord;
    DWORD               faRightChain;
    DWORD               cRightNodes;                /* $V2$ */ 
} CHAINNODEV5, *LPCHAINNODEV5;

//--------------------------------------------------------------------------
// CHAINBLOCKV5 - 20 Bytes
//--------------------------------------------------------------------------
typedef struct tagCHAINBLOCKV5 {
    DWORD               faStart;
    DWORD               faLeftChain;
    DWORD               faParent;                   /* $V2$ */ 
    BYTE                iParent;                    /* $V2$ */ 
    BYTE                cNodes;
    WORD                wReserved;                  /* $V2$ */ 
    DWORD               cLeftNodes;                 /* $V2$ */ 
    CHAINNODEV5         rgNode[BTREE_ORDER + 1];
} CHAINBLOCKV5, *LPCHAINBLOCKV5;

#define CB_CHAIN_BLOCKV5 (sizeof(CHAINBLOCKV5))

//--------------------------------------------------------------------------
// RECORDBLOCKV5B1
//--------------------------------------------------------------------------
typedef struct tagRECORDBLOCKV5B1 {
    DWORD               faRecord;
    DWORD               cbRecord;
    DWORD               faNext;
    DWORD               faPrevious;
} RECORDBLOCKV5B1, *LPRECORDBLOCKV5B1;

//--------------------------------------------------------------------------
// RECORDBLOCKV5
//--------------------------------------------------------------------------
typedef struct tagRECORDBLOCKV5 {
    DWORD               faRecord;
    DWORD               cbRecord;
    DWORD               dwVersion;                  /* $V2$ */
    WORD                wFlags;                     /* $V2$ */
    WORD                cColumns;                   /* $V2$ */
    WORD                wFormat;                    /* $V2$ */
    WORD                wReserved;                  /* $V2$ */
    DWORD               faNext;
    DWORD               faPrevious;
} RECORDBLOCKV5, *LPRECORDBLOCKV5;

//--------------------------------------------------------------------------
// STREAMBLOCK
//--------------------------------------------------------------------------
typedef struct tagSTREAMBLOCK {
    DWORD               faThis;
    DWORD               cbBlock;
    DWORD               cbData;
    DWORD               faNext;
} STREAMBLOCK, *LPSTREAMBLOCK;

// --------------------------------------------------------------------------------
// Old Storage Migration Version and Signatures
// --------------------------------------------------------------------------------
#define MSGFILE_VER     0x00010003 // 1.0003
#define MSGFILE_MAGIC   0x36464d4a
#define CACHEFILE_VER   0x00010004 // 1.0004
#define CACHEFILE_MAGIC 0x39464d4a
#define MAIL_BLOB_VER   0x00010010 // 1.8 Opie Likes to change this a lot !!!
#define MSGHDR_MAGIC    0x7f007f00  // as bytes "0x00, 0x7f, 0x00, 0x7f"
#define MSG_HEADER_VERSISON ((WORD)1)

// --------------------------------------------------------------------------------
// MBXFILEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagMBXFILEHEADER {
    DWORD               dwMagic;
    DWORD               ver;
    DWORD               cMsg;
    DWORD               msgidLast;
    DWORD               cbValid;
    DWORD               dwFlags;
    DWORD               dwReserved[15];
} MBXFILEHEADER, *LPMBXFILEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// MBXMESSAGEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagMBXMESSAGEHEADER {
    DWORD               dwMagic;
    DWORD               msgid;
    DWORD               dwMsgSize;
    DWORD               dwBodySize;
} MBXMESSAGEHEADER, *LPMBXMESSAGEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// IDXFILEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagIDXFILEHEADER {
    DWORD               dwMagic;
        DWORD               ver;
    DWORD               cMsg;
    DWORD               cbValid;
    DWORD               dwFlags;
    DWORD               verBlob;
    DWORD               dwReserved[14];
} IDXFILEHEADER, *LPIDXFILEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// IDXMESSAGEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagIDXMESSAGEHEADER {
    DWORD               dwState;
    DWORD               dwLanguage;
    DWORD               msgid;
    DWORD               dwHdrOffset;
    DWORD               dwSize;
    DWORD               dwOffset;
    DWORD               dwMsgSize;
    DWORD               dwHdrSize;
    BYTE                rgbHdr[4];
} IDXMESSAGEHEADER, *LPIDXMESSAGEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// FOLDERUSERDATAV4
// --------------------------------------------------------------------------------
typedef struct tagFOLDERUSERDATAV4 {
    DWORD           cbCachedArticles;
    DWORD           cCachedArticles;
    FILETIME        ftOldestArticle;
    DWORD           dwFlags;
    DWORD           dwNextArticleNumber;
    TCHAR           szServer[256];
    TCHAR           szGroup[256];
    DWORD           dwUIDValidity;
    BYTE            rgReserved[1020];
} FOLDERUSERDATAV4, *LPFOLDERUSERDATAV4;

// --------------------------------------------------------------------------------
// FLDINFO
// --------------------------------------------------------------------------------
#pragma pack(1)
typedef struct tagFLDINFO {
    DWORD       idFolder;
    CHAR        szFolder[259];
    CHAR        szFile[260];
    DWORD       idParent;
    DWORD       idChild;
    DWORD       idSibling;
    DWORD       tySpecial;
    DWORD       cChildren;
    DWORD       cMessages;
    DWORD       cUnread;
    DWORD       cbTotal;
    DWORD       cbUsed;
    BYTE        bHierarchy;
    DWORD       dwImapFlags;
    BYTE        bListStamp;
    BYTE        bReserved[3];
    DWORD_PTR   idNewFolderId;
} FLDINFO, *LPFLDINFO;
#pragma pack()

// --------------------------------------------------------------------------------
// IDXMESSAGEHEADER
// --------------------------------------------------------------------------------
#define GROUPLISTVERSION 0x3
#pragma pack(1)
typedef struct tagGRPLISTHEADER {
    DWORD               dwVersion;
    CHAR                szDate[14];
    DWORD               cGroups;
} GRPLISTHEADER, *LPGRPLISTHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// Sublist Structures
// --------------------------------------------------------------------------------
#define SUBFILE_VERSION5    0xFFEAEA05
#define SUBFILE_VERSION4    0xFFEAEA04
#define SUBFILE_VERSION3    0xFFEAEA03
#define SUBFILE_VERSION2    0xFFEAEA02

typedef struct tagSUBLISTHEADER {
    DWORD               dwVersion;
    DWORD               cSubscribed;
} SUBLISTHEADER, *LPSUBLISTHEADER;

#define GSF_SUBSCRIBED      0x00000001
#define GSF_MARKDOWNLOAD    0x00000002      // We use this to persist the groups which have been marked for download
#define GSF_DOWNLOADHEADERS 0x00000004
#define GSF_DOWNLOADNEW     0x00000008
#define GSF_DOWNLOADALL     0x00000010
#define GSF_GROUPTYPEKNOWN  0x00000020
#define GSF_MODERATED       0x00000040
#define GSF_BLOCKED         0x00000080
#define GSF_NOPOSTING       0x00000100

typedef struct tagGROUPSTATUS5 {
    DWORD   dwFlags;            // subscription status, posting, etc.
    DWORD   dwReserved;         // reserved for future use
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
    ULONG   cbMarkedRange;      // length of marked range data
    ULONG   cbRequestedRange;   // length of range of data req from server
    DWORD   dwCacheFileIndex;   // cache file number
} GROUPSTATUS5, * PGROUPSTATUS5;

typedef struct tagGROUPSTATUS4 {
    DWORD   dwFlags;            // subscription status, posting, etc.
    DWORD   dwReserved;         // reserved for future use
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
    ULONG   cbMarkedRange;      // length of marked range data
    ULONG   cbRequestedRange;   // length of range of data req from server
} GROUPSTATUS4, * PGROUPSTATUS4;

typedef struct tagGROUPSTATUS3 {
    DWORD   dwFlags;            // subscription status, posting, etc.
    DWORD   dwReserved;         // reserved for future use
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
    ULONG   cbMarkedRange;      // length of marked range data
} GROUPSTATUS3, * PGROUPSTATUS3;

typedef struct tagGROUPSTATUS2 {
    BOOL    fSubscribed;        // subscription status
    BOOL    fPosting;           // posting allowed?
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
} GROUPSTATUS2, * PGROUPSTATUS2;

#endif // __STRUCTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\oe5beta1.cpp ===
// --------------------------------------------------------------------------------
// oe5beta1.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "utility.h"
#include "migrate.h"
#include "migerror.h"
#include "structs.h"
#include "resource.h"

// --------------------------------------------------------------------------------
// DowngradeProcessFileListV5B1
// --------------------------------------------------------------------------------
HRESULT DowngradeProcessFileListV5B1(LPFILEINFO pHead, LPDWORD pcMax, LPDWORD pcbNeeded)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPFILEINFO          pCurrent;
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("DowngradeProcessFileListV5B1");

    // Invalid Arg
    Assert(pHead);

    // Init
    *pcMax = 0;
    *pcbNeeded = 0;

    // Loop
    for (pCurrent=pHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Get the File Header
        hr = OpenMemoryFile(pCurrent->szFilePath, &File);

        // Failure ?
        if (FAILED(hr))
        {
            // Don't Migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = hr;

            // Reset hr
            hr = S_OK;

            // Get the LastError
            pCurrent->dwLastError = GetLastError();

            // Goto Next
            goto NextFile;
        }

        // Don't need to migrate the file
        if (FILE_IS_NEWS_MESSAGES != pCurrent->tyFile && FILE_IS_IMAP_MESSAGES != pCurrent->tyFile)
        {
            // Not a file that should be migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = S_OK;

            // Goto Next
            goto NextFile;
        }

        // De-Ref the header
        pHeader = (LPTABLEHEADERV5B1)File.pView;

        // Check the Signature...
        if (File.cbSize < sizeof(TABLEHEADERV5B1) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_PRE_V5 != pHeader->wMajorVersion)
        {
            // Not a file that should be migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

            // Goto Next
            goto NextFile;
        }

        // Save the Number of record
        pCurrent->cRecords = pHeader->cRecords;

        // Initialize counters
        InitializeCounters(&File, pCurrent, pcMax, pcbNeeded, FALSE);

        // Yes, Migrate
        pCurrent->fMigrate = TRUE;

NextFile:
        // Close the File
        CloseMemoryFile(&File);
    }

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// DowngradeRecordV5B1
//--------------------------------------------------------------------------
HRESULT DowngradeRecordV5B1(MIGRATETOTYPE tyMigrate, LPMEMORYFILE pFile, 
    LPCHAINNODEV5B1 pNode)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbRecord=0;
    LPBYTE              pbData;
    LPRECORDBLOCKV5B1   pRecord;

    // Trace
    TraceCall("DowngradeRecordV5B1");

    // Invalid
    if (pNode->faRecord + sizeof(RECORDBLOCKV5B1) + pNode->cbRecord > pFile->cbSize || 0 == pNode->cbRecord)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // Access the Record
    pRecord = (LPRECORDBLOCKV5B1((LPBYTE)pFile->pView + pNode->faRecord));

    // Cast the datablock
    pbData = ((LPBYTE)pRecord + sizeof(RECORDBLOCKV5B1));

    // Lets read the fields so that I can re-compute the records V2 length...
    cbRecord += sizeof(DWORD);     // dwMsgId
    cbRecord += sizeof(DWORD);     // dwFlags
    cbRecord += sizeof(FILETIME);  // ftSent
    cbRecord += sizeof(DWORD);     // cLines
    cbRecord += sizeof(DWORD);     // faStream
    cbRecord += sizeof(DWORD);     // cbArticle
    cbRecord += sizeof(FILETIME);  // ftDownloaded
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszMessageId
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszSubject;     
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszFromHeader;  
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszReferences;  
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszXref;        
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszServer;      
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszDisplayFrom; 
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszEmailFrom;

    // Going to V4 ?
    if (DOWNGRADE_V5B1_TO_V4 == tyMigrate && cbRecord < pNode->cbRecord)
    {
        cbRecord += sizeof(WORD);       // wLanguage
        cbRecord += sizeof(WORD);       // wReserved
        cbRecord += sizeof(DWORD);      // cbMessage
        cbRecord += sizeof(FILETIME);   // ftReceived
        cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1); // pszDisplayTo;   
    }

    // Add on Reserved
    cbRecord += (40 + sizeof(RECORDBLOCKV5B1));

    // Store the Size
    pRecord->cbRecord = cbRecord;

    // Update the Node
    pNode->cbRecord = cbRecord;

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// DowngradeIndexV5B1
//--------------------------------------------------------------------------
HRESULT DowngradeIndexV5B1(MIGRATETOTYPE tyMigrate, LPMEMORYFILE pFile, 
    LPFILEINFO pInfo, LPPROGRESSINFO pProgress, DWORD faChain)
{
    // Locals
    HRESULT             hr=S_OK;
    LONG                i;
    LPCHAINBLOCKV5B1    pChain;
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("DowngradeIndexV5B1");

    // De-Ref the header
    pHeader = (LPTABLEHEADERV5B1)pFile->pView;

    // Nothing to validate
    if (0 == faChain)
        return S_OK;

    // Out-of-bounds
    if (faChain + CB_CHAIN_BLOCKV5B1 > pFile->cbSize)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // De-ref the block
    pChain = (LPCHAINBLOCKV5B1)((LPBYTE)pFile->pView + faChain);

    // Out-of-Bounds
    if (pChain->faStart != faChain)
        return TraceResult(MIGRATE_E_BADCHAINSIGNATURE);

    // Too many nodes
    if (pChain->cNodes > BTREE_ORDER)
        return TraceResult(MIGRATE_E_TOOMANYCHAINNODES);

    // Validate Minimum Filled Constraint
    if (pChain->cNodes < BTREE_MIN_CAP && pChain->faStart != pHeader->faRootChain)
        return TraceResult(MIGRATE_E_BADMINCAPACITY);

    // Go to the left
    IF_FAILEXIT(hr = DowngradeIndexV5B1(tyMigrate, pFile, pInfo, pProgress, pChain->faLeftChain));

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Bump Progress
        IncrementProgress(pProgress, pInfo);

        /// Downgrad this record
        IF_FAILEXIT(hr = DowngradeRecordV5B1(tyMigrate, pFile, &pChain->rgNode[i]));

        // Validate the Right Chain
        IF_FAILEXIT(hr = DowngradeIndexV5B1(tyMigrate, pFile, pInfo, pProgress, pChain->rgNode[i].faRightChain));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeFileV5B1
// --------------------------------------------------------------------------------
HRESULT DowngradeFileV5B1(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("DowngradeFileV5B1");

    // Get the File Header
    IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

    // De-Ref the header
    pHeader = (LPTABLEHEADERV5B1)File.pView;

    // Recurse Through the Index
    IF_FAILEXIT(hr = DowngradeIndexV5B1(tyMigrate, &File, pInfo, pProgress, pHeader->faRootChain));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeV5B1
// --------------------------------------------------------------------------------
HRESULT DowngradeV5B1(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreRoot, 
    LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    ENUMFILEINFO    EnumInfo={0};
    LPFILEINFO      pCurrent;
    DWORD           cbNeeded;

    // Trace
    TraceCall("DowngradeV5B1");

    // Setup the EnumFile Info
    EnumInfo.pszExt = ".nch";
    EnumInfo.pszFoldFile = "folders.nch";
    EnumInfo.pszUidlFile = "pop3uidl.dat";

    // Initialize
    *ppHeadFile = NULL;

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreRoot, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Compute some Counts, and validate that the files are valid to migrate...
    IF_FAILEXIT(hr = DowngradeProcessFileListV5B1(*ppHeadFile, &pProgress->cMax, &cbNeeded));

    // Loop through the files and migrate each one
    for (pCurrent=*ppHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Migrate this file ?
        if (pCurrent->fMigrate)
        {
            // Set Progress File
            SetProgressFile(pProgress, pCurrent);

            // Downgrade the file
            pCurrent->hrMigrate = DowngradeFileV5B1(tyMigrate, pCurrent, pProgress);

            // Failure ?
            if (FAILED(pCurrent->hrMigrate))
                pCurrent->dwLastError = GetLastError();
        }
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\migrate.h ===
// --------------------------------------------------------------------------------
// Migrate.h
// --------------------------------------------------------------------------------
#ifndef __MIGRATE_H
#define __MIGRATE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "utility.h"

// --------------------------------------------------------------------------------
// MIGRATETOTYPE
// --------------------------------------------------------------------------------
typedef enum tagMIGRATETOTYPE {
    DOWNGRADE_V5B1_TO_V1,
    DOWNGRADE_V5B1_TO_V4,
    UPGRADE_V1_OR_V4_TO_V5,
    DOWNGRADE_V5_TO_V1,
    DOWNGRADE_V5_TO_V4
} MIGRATETOTYPE;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern IMalloc          *g_pMalloc;
extern HINSTANCE         g_hInst;
extern DWORD             g_cbDiskNeeded;
extern DWORD             g_cbDiskFree;
extern ACCOUNTTABLE      g_AcctTable;

#endif // __MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\upoe5.cpp ===
// --------------------------------------------------------------------------------
// upoe5.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "utility.h"
#include "migrate.h"
#include "migerror.h"
#include "structs.h"
#include "resource.h"
#define DEFINE_DIRECTDB
#include <shared.h>
#include <oestore.h>
#include <oerules.h>
#include <mimeole.h>
#include "msident.h"

// --------------------------------------------------------------------------------
// Linearly Incrementing Folder Id
// --------------------------------------------------------------------------------
static DWORD g_idFolderNext=1000;
extern BOOL g_fQuiet;

// --------------------------------------------------------------------------------
// FOLDERIDCHANGE
// --------------------------------------------------------------------------------
typedef struct tagFOLDERIDCHANGE {
    FOLDERID        idOld;
    FOLDERID        idNew;
} FOLDERIDCHANGE, *LPFOLDERIDCHANGE;

// --------------------------------------------------------------------------------
// Forward Declarations
// --------------------------------------------------------------------------------
HRESULT SetIMAPSpecialFldrType(LPSTR pszAcctID, LPSTR pszFldrName, SPECIALFOLDER *psfType);

// --------------------------------------------------------------------------------
// SplitMailCacheBlob
// --------------------------------------------------------------------------------
HRESULT SplitMailCacheBlob(IMimePropertySet *pNormalizer, LPBYTE pbCacheInfo, 
    DWORD cbCacheInfo, LPMESSAGEINFO pMsgInfo, LPSTR *ppszNormal, LPBLOB pOffsets)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           ib;
    ULONG           cbTree;
    ULONG           cbProps;
    WORD            wVersion;
    DWORD           dw;
    DWORD           cbMsg;
    DWORD           dwFlags;
    WORD            wPriority;
    PROPVARIANT     Variant;

    // Invalid Arg
    Assert(pbCacheInfo && cbCacheInfo && pMsgInfo);

    // Init
    ZeroMemory(pOffsets, sizeof(BLOB));

    // Read Version
    ib = 0;
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&wVersion, sizeof(wVersion)));

    // Version Check
    if (wVersion != MSG_HEADER_VERSISON)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Read Flags
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dwFlags, sizeof(dwFlags)));

    // IMF_ATTACHMENTS
    if (ISFLAGSET(dwFlags, IMF_ATTACHMENTS))
        FLAGSET(pMsgInfo->dwFlags, ARF_HASATTACH);

    // IMF_SIGNED
    if (ISFLAGSET(dwFlags, IMF_SIGNED))
        FLAGSET(pMsgInfo->dwFlags, ARF_SIGNED);

    // IMF_ENCRYPTED
    if (ISFLAGSET(dwFlags, IMF_ENCRYPTED))
        FLAGSET(pMsgInfo->dwFlags, ARF_ENCRYPTED);

    // IMF_VOICEMAIL
    if (ISFLAGSET(dwFlags, IMF_VOICEMAIL))
        FLAGSET(pMsgInfo->dwFlags, ARF_VOICEMAIL);

    // IMF_NEWS
    if (ISFLAGSET(dwFlags, IMF_NEWS))
        FLAGSET(pMsgInfo->dwFlags, ARF_NEWSMSG);

    // Read Reserved
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));

    // Read Message Size
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&cbMsg, sizeof(cbMsg)));

    // Read Byte Count for the content list
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&cbTree, sizeof(cbTree)));

    // Does the user want the tree ?
    if (cbTree)
    {
        pOffsets->pBlobData = (pbCacheInfo + ib);
        pOffsets->cbSize = cbTree;
    }

    // Increment passed the tree
    ib += cbTree;

    // Read Byte Count for the content list
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&cbProps, sizeof(cbProps)));

    // Partial Number
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&pMsgInfo->dwPartial, sizeof(pMsgInfo->dwPartial)));

    // Receive Time
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&pMsgInfo->ftReceived, sizeof(pMsgInfo->ftReceived)));

    // Sent Time
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&pMsgInfo->ftSent, sizeof(pMsgInfo->ftSent)));

    // Priority
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&wPriority, sizeof(wPriority)));

    // Pritority
    pMsgInfo->wPriority = wPriority;

    // Subject
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszSubject = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Init the Normalizer
    pNormalizer->InitNew();

    // Set the Subject
    Variant.vt = VT_LPSTR;
    Variant.pszVal = pMsgInfo->pszSubject;

    // Set the Property
    IF_FAILEXIT(hr = pNormalizer->SetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &Variant));

    // Get the Normalized Subject back out
    if (SUCCEEDED(pNormalizer->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), 0, &Variant)))
        *ppszNormal = pMsgInfo->pszNormalSubj = Variant.pszVal;

    // Otherwise, just use the subject
    else
        pMsgInfo->pszNormalSubj = pMsgInfo->pszSubject;

    // Display To
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszDisplayTo = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Display From
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszDisplayFrom = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Server
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszServer = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // UIDL
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszUidl = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // User Name
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    //pMsgInfo->pszUserName = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Account Name
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszAcctName = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Partial Id
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszPartialId = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Forward To
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszForwardTo = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Sanity Check
    Assert(ib == cbCacheInfo);

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// GetMsgInfoFromPropertySet
//--------------------------------------------------------------------------
HRESULT GetMsgInfoFromPropertySet(
        /* in */        IMimePropertySet           *pPropertySet,
        /* in,out */    LPMESSAGEINFO                   pMsgInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    SYSTEMTIME          st;
    FILETIME            ftCurrent;
    IMimeAddressTable  *pAdrTable=NULL;

    // Trace
    TraceCall("GetMsgInfoFromPropertySet");

    // Invalid Args
    Assert(pPropertySet && pMsgInfo);

    // Default Sent and Received Times...
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftCurrent);

    // Set Variant tyStore
    Variant.vt = VT_UI4;

    // Priority
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &Variant)))
    {
        // Set Priority
        pMsgInfo->wPriority = (WORD)Variant.ulVal;
    }

    // Partial Numbers...
    if (pPropertySet->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK)
    {
        // Locals
        WORD cParts=0, iPart=0;

        // Get Total
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_TOTAL, NOFLAGS, &Variant)))
            cParts = (WORD)Variant.ulVal;

        // Get Number
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_NUMBER, NOFLAGS, &Variant)))
            iPart = (WORD)Variant.ulVal;

        // Set Parts
        pMsgInfo->dwPartial = MAKELONG(cParts, iPart);
    }

    // Otherwise, check for user property
    else if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_COMBINED), NOFLAGS, &Variant)))
    {
        // Set the Partial Id
        pMsgInfo->dwPartial = Variant.ulVal;
    }

    // Getting some file times
    Variant.vt = VT_FILETIME;

    // Get Received Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &Variant)))
        pMsgInfo->ftReceived = Variant.filetime;
    else
        pMsgInfo->ftReceived = ftCurrent;

    // Get Sent Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &Variant)))
        pMsgInfo->ftSent = Variant.filetime;
    else
        pMsgInfo->ftSent = ftCurrent;

    // Get Address Table
    IF_FAILEXIT(hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAdrTable));

    // Display From
    pAdrTable->GetFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &pMsgInfo->pszDisplayFrom);

    // Display To
    pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &pMsgInfo->pszDisplayTo);

    // String Properties
    Variant.vt = VT_LPSTR;

    // pszDisplayFrom as newsgroups
    if (NULL == pMsgInfo->pszDisplayFrom && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &Variant)))
        pMsgInfo->pszDisplayFrom = Variant.pszVal;

    // pszMessageId
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &Variant)))
        pMsgInfo->pszMessageId = Variant.pszVal;

    // pszXref
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_XREF), NOFLAGS, &Variant)))
        pMsgInfo->pszXref = Variant.pszVal;

    // pszReferences
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(STR_HDR_REFS), NOFLAGS, &Variant)))
        pMsgInfo->pszReferences = Variant.pszVal;

    // pszSubject
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &Variant)))
        pMsgInfo->pszSubject = Variant.pszVal;

    // Normalized Subject
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &Variant)))
        pMsgInfo->pszNormalSubj = Variant.pszVal;

    // pszAccount
    if (SUCCEEDED(pPropertySet->GetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &Variant)))
        pMsgInfo->pszAcctName = Variant.pszVal;

    // pszServer
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &Variant)))
        pMsgInfo->pszServer = Variant.pszVal;

    // pszUidl
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_UIDL), NOFLAGS, &Variant)))
        pMsgInfo->pszUidl = Variant.pszVal;

    // pszPartialId
    if (pMsgInfo->dwPartial != 0 && SUCCEEDED(pPropertySet->GetProp(STR_PAR_ID, NOFLAGS, &Variant)))
        pMsgInfo->pszPartialId = Variant.pszVal;

    // ForwardTo
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_FORWARDTO), NOFLAGS, &Variant)))
        pMsgInfo->pszForwardTo = Variant.pszVal;

exit:
    // Cleanup
    SafeRelease(pAdrTable);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// GetMsgInfoFromMessage
//--------------------------------------------------------------------------
HRESULT GetMsgInfoFromMessage(IMimeMessage *pMessage, LPMESSAGEINFO pMsgInfo,
    LPBLOB pOffsets)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwImf;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    SYSTEMTIME          st;
    FILETIME            ftCurrent;
    CByteStream         cByteStm;
    IMimePropertySet   *pPropertySet=NULL;

    // Trace
    TraceCall("GetMsgInfoFromMessage");

    // Invalid Args
    Assert(pMessage && pMsgInfo);

    // Get the Root Property Set from the Message
    IF_FAILEXIT(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropertySet));

    // File pMsgInfo from pPropertySet
    IF_FAILEXIT(hr = GetMsgInfoFromPropertySet(pPropertySet, pMsgInfo));

    // Get Message Flags
    if (SUCCEEDED(pMessage->GetFlags(&dwImf)))
    {
        // IMF_ATTACHMENTS
        if (ISFLAGSET(dwImf, IMF_ATTACHMENTS))
            FLAGSET(pMsgInfo->dwFlags, ARF_HASATTACH);

        // IMF_SIGNED
        if (ISFLAGSET(dwImf, IMF_SIGNED))
            FLAGSET(pMsgInfo->dwFlags, ARF_SIGNED);

        // IMF_ENCRYPTED
        if (ISFLAGSET(dwImf, IMF_ENCRYPTED))
            FLAGSET(pMsgInfo->dwFlags, ARF_ENCRYPTED);

        // IMF_VOICEMAIL
        if (ISFLAGSET(dwImf, IMF_VOICEMAIL))
            FLAGSET(pMsgInfo->dwFlags, ARF_VOICEMAIL);

        // IMF_NEWS
        if (ISFLAGSET(dwImf, IMF_NEWS))
            FLAGSET(pMsgInfo->dwFlags, ARF_NEWSMSG);
    }

    // Get the Message Size
    pMessage->GetMessageSize(&pMsgInfo->cbMessage, 0);

    // Create the offset table
    if (SUCCEEDED(pMessage->SaveOffsetTable(&cByteStm, 0)))
    {
        // pull the Bytes out of cByteStm
        cByteStm.AcquireBytes(&pOffsets->cbSize, &pOffsets->pBlobData, ACQ_DISPLACE);
    }

exit:
    // Cleanup
    SafeRelease(pPropertySet);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// FreeMsgInfo
//--------------------------------------------------------------------------
void FreeMsgInfo(
        /* in,out */    LPMESSAGEINFO                   pMsgInfo)
{
    // Trace
    TraceCall("FreeMsgInfo");

    // Invalid Args
    Assert(pMsgInfo && NULL == pMsgInfo->pAllocated);

    // Free The Dude
    g_pMalloc->Free(pMsgInfo->pszMessageId);
    g_pMalloc->Free(pMsgInfo->pszNormalSubj);
    g_pMalloc->Free(pMsgInfo->pszSubject);
    g_pMalloc->Free(pMsgInfo->pszFromHeader);
    g_pMalloc->Free(pMsgInfo->pszReferences);
    g_pMalloc->Free(pMsgInfo->pszXref);
    g_pMalloc->Free(pMsgInfo->pszServer);
    g_pMalloc->Free(pMsgInfo->pszDisplayFrom);
    g_pMalloc->Free(pMsgInfo->pszEmailFrom);
    g_pMalloc->Free(pMsgInfo->pszDisplayTo);
    g_pMalloc->Free(pMsgInfo->pszUidl);
    g_pMalloc->Free(pMsgInfo->pszPartialId);
    g_pMalloc->Free(pMsgInfo->pszForwardTo);
    g_pMalloc->Free(pMsgInfo->pszAcctName);
    g_pMalloc->Free(pMsgInfo->pszAcctId);

    // Zero It
    ZeroMemory(pMsgInfo, sizeof(MESSAGEINFO));
}

// --------------------------------------------------------------------------------
// UpgradeLocalStoreFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradeLocalStoreFileV5(LPFILEINFO pInfo, LPMEMORYFILE pFile,
    IDatabase *pDB, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szIdxPath[MAX_PATH];
    DWORD               i;
    LPBYTE              pbStream;
    LPBYTE              pbCacheBlob;
    SYSTEMTIME          st;
    MESSAGEINFO         MsgInfo={0};
    LPSTR               pszNormal=NULL;
    MESSAGEINFO         MsgInfoFree={0};
    DWORD               faIdxRead;
    IStream            *pStream=NULL;
    IMimeMessage       *pMessage=NULL;
    BLOB                Offsets;
    LPBYTE              pbFree=NULL;
    MEMORYFILE          IdxFile;
    LPMEMORYFILE        pIdxFile=NULL;
    LPMEMORYFILE        pMbxFile=pFile;
    LPMBXFILEHEADER     pMbxHeader=NULL;
    LPIDXFILEHEADER     pIdxHeader=NULL;
    LPIDXMESSAGEHEADER  pIdxMessage=NULL;
    LPMBXMESSAGEHEADER  pMbxMessage=NULL;
    IMimePropertySet   *pNormalizer=NULL;
    LARGE_INTEGER       liOrigin={0,0};

    // Trace
    TraceCall("UpgradeLocalStoreFileV5");

    // Get System Time
    GetSystemTime(&st);

    // Create a Property Set for Normalizing Subjects
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_IMimePropertySet, NULL, CLSCTX_INPROC_SERVER, IID_IMimePropertySet, (LPVOID *)&pNormalizer));

    // Split the Path
    ReplaceExtension(pInfo->szFilePath, ".idx", szIdxPath);

    // Open the memory file
    hr = OpenMemoryFile(szIdxPath, &IdxFile);
    if (FAILED(hr))
    {
        *pfContinue = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // Set pIdxFile
    pIdxFile = &IdxFile;

    // Don't use pFile
    pFile = NULL;

    // Read the Mbx File Header
    pMbxHeader = (LPMBXFILEHEADER)(pMbxFile->pView);

    // Read the Idx File Header
    pIdxHeader = (LPIDXFILEHEADER)(pIdxFile->pView);

    // Validate the Version of th idx file
    if (pIdxHeader->ver != CACHEFILE_VER || pIdxHeader->dwMagic != CACHEFILE_MAGIC)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_INVALIDIDXHEADER);
        goto exit;
    }

    // Setup faIdxRead
    faIdxRead = sizeof(IDXFILEHEADER);

    // Prepare to Loop
    for (i=0; i<pIdxHeader->cMsg; i++)
    {
        // Done
        if (faIdxRead >= pIdxFile->cbSize)
            break;

        // Read an idx message header
        pIdxMessage = (LPIDXMESSAGEHEADER)((LPBYTE)pIdxFile->pView + faIdxRead);

        // If this message is not marked as deleted...
        if (ISFLAGSET(pIdxMessage->dwState, MSG_DELETED))
            goto NextMessage;

        // Zero Out the MsgInfo Structure
        ZeroMemory(&MsgInfo, sizeof(MESSAGEINFO));

        // Start filling message
        MsgInfo.idMessage = (MESSAGEID)IntToPtr(pIdxMessage->msgid);

        // Fixup the Flags
        if (FALSE == ISFLAGSET(pIdxMessage->dwState, MSG_UNREAD))
            FLAGSET(MsgInfo.dwFlags, ARF_READ);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_VOICEMAIL))
            FLAGSET(MsgInfo.dwFlags, ARF_VOICEMAIL);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_REPLIED))
            FLAGSET(MsgInfo.dwFlags, ARF_REPLIED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_FORWARDED))
            FLAGSET(MsgInfo.dwFlags, ARF_FORWARDED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_FLAGGED))
            FLAGSET(MsgInfo.dwFlags, ARF_FLAGGED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_RCPTSENT))
            FLAGSET(MsgInfo.dwFlags, ARF_RCPTSENT);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_NOSECUI))
            FLAGSET(MsgInfo.dwFlags, ARF_NOSECUI);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_NEWSMSG))
            FLAGSET(MsgInfo.dwFlags, ARF_NEWSMSG);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_UNSENT))
            FLAGSET(MsgInfo.dwFlags, ARF_UNSENT);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_SUBMITTED))
            FLAGSET(MsgInfo.dwFlags, ARF_SUBMITTED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_RECEIVED))
            FLAGSET(MsgInfo.dwFlags, ARF_RECEIVED);

        // Zero Offsets
        ZeroMemory(&Offsets, sizeof(BLOB));

        // Do the Blob
        if (pIdxHeader->verBlob == MAIL_BLOB_VER)
        {
            // Get the blob
            pbCacheBlob = (LPBYTE)((LPBYTE)pIdxFile->pView + (faIdxRead + (sizeof(IDXMESSAGEHEADER) - 4)));

            // Split the Cache Blob
            if (FAILED(SplitMailCacheBlob(pNormalizer, pbCacheBlob, pIdxMessage->dwHdrSize, &MsgInfo, &pszNormal, &Offsets)))
                goto NextMessage;

            // Save the Language
            MsgInfo.wLanguage = LOWORD(pIdxMessage->dwLanguage);

            // Save the Highlight
            MsgInfo.wHighlight = HIWORD(pIdxMessage->dwLanguage);
        }

        // Bad
        if (pIdxMessage->dwOffset > pMbxFile->cbSize)
            goto NextMessage;

        // Lets read the message header in the mbx file to validate the msgids
        pMbxMessage = (LPMBXMESSAGEHEADER)((LPBYTE)pMbxFile->pView + pIdxMessage->dwOffset);

        // Set Sizes
        MsgInfo.cbMessage = pMbxMessage->dwBodySize;

        // Validate the Message Ids
        if (pMbxMessage->msgid != pIdxMessage->msgid)
            goto NextMessage;

        // Check for magic
        if (pMbxMessage->dwMagic != MSGHDR_MAGIC)
            goto NextMessage;

        // Has a Body
        FLAGSET(MsgInfo.dwFlags, ARF_HASBODY);

        // Create a Virtual Stream
        IF_FAILEXIT(hr = pDB->CreateStream(&MsgInfo.faStream));

        // Open the Stream
        IF_FAILEXIT(hr = pDB->OpenStream(ACCESS_WRITE, MsgInfo.faStream, &pStream));

        // Get the stream pointer
        pbStream = (LPBYTE)((LPBYTE)pMbxFile->pView + (pIdxMessage->dwOffset + sizeof(MBXMESSAGEHEADER)));

        // Write this
        IF_FAILEXIT(hr = pStream->Write(pbStream, pMbxMessage->dwBodySize, NULL));

        // Commit
        IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

        // If not an OE4+ blob, then generate the msginfo from the message
        if (pIdxHeader->verBlob != MAIL_BLOB_VER)
        {
            // Create an IMimeMessage    
            IF_FAILEXIT(hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMessage));

            // Rewind
            if (FAILED(pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL)))
                goto NextMessage;

            // Load the Message
            if (FAILED(pMessage->Load(pStream)))
                goto NextMessage;

            // Get MsgInfo from the Message
            if (FAILED(GetMsgInfoFromMessage(pMessage, &MsgInfo, &Offsets)))
                goto NextMessage;

            // Free 
            pbFree = Offsets.pBlobData;

            // Free This MsgInfo
            CopyMemory(&MsgInfoFree, &MsgInfo, sizeof(MESSAGEINFO));
        }

        // Set MsgInfo Offsets
        MsgInfo.Offsets = Offsets;

        // Save Downloaded Time
        SystemTimeToFileTime(&st, &MsgInfo.ftDownloaded);

        // Lookup Account Id from the Account Name...
        if (MsgInfo.pszAcctName)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szAcctName, MsgInfo.pszAcctName) == 0)
                {
                    MsgInfo.pszAcctId = g_AcctTable.prgAccount[i].szAcctId;
                    break;
                }
            }
        }

        // Count
        pInfo->cMessages++;
        if (!ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            pInfo->cUnread++;

        // Migrated
        FLAGSET(MsgInfo.dwFlags, 0x00000010);

        // Store the Record
        IF_FAILEXIT(hr = pDB->InsertRecord(&MsgInfo));

NextMessage:
        // Bump Progress
        if(!g_fQuiet)           
            IncrementProgress(pProgress, pInfo);

        // Cleanup
        SafeRelease(pStream);
        SafeRelease(pMessage);
        SafeMemFree(pszNormal);
        SafeMemFree(pbFree);
        FreeMsgInfo(&MsgInfoFree);

        // Goto Next Header
        Assert(pIdxMessage);

        // Update faIdxRead
        faIdxRead += pIdxMessage->dwSize;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pMessage);
    SafeRelease(pNormalizer);
    SafeMemFree(pszNormal);
    SafeMemFree(pbFree);
    FreeMsgInfo(&MsgInfoFree);
    if (pIdxFile)
        CloseMemoryFile(pIdxFile);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// GetRecordBlock
// --------------------------------------------------------------------------------
HRESULT GetRecordBlock(LPMEMORYFILE pFile, DWORD faRecord, LPRECORDBLOCKV5B1 *ppRecord,
    LPBYTE *ppbData, BOOL *pfContinue)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetRecordBlock");

    // Bad Length
    if (faRecord + sizeof(RECORDBLOCKV5B1) > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Cast the Record
    (*ppRecord) = (LPRECORDBLOCKV5B1)((LPBYTE)pFile->pView + faRecord);

    // Invalid Record Signature
    if (faRecord != (*ppRecord)->faRecord)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_BADRECORDSIGNATURE);
        goto exit;
    }

    // Bad Length
    if (faRecord + (*ppRecord)->cbRecord > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Set pbData
    *ppbData = (LPBYTE)((LPBYTE)(*ppRecord) + sizeof(RECORDBLOCKV5B1));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// GetStreamBlock
// --------------------------------------------------------------------------------
HRESULT GetStreamBlock(LPMEMORYFILE pFile, DWORD faBlock, LPSTREAMBLOCK *ppBlock,
    LPBYTE *ppbData, BOOL *pfContinue)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetStreamBlock");

    // Bad Length
    if (faBlock + sizeof(STREAMBLOCK) > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Cast the Record
    (*ppBlock) = (LPSTREAMBLOCK)((LPBYTE)pFile->pView + faBlock);

    // Invalid Record Signature
    if (faBlock != (*ppBlock)->faThis)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_BADSTREAMBLOCKSIGNATURE);
        goto exit;
    }

    // Bad Length
    if (faBlock + (*ppBlock)->cbBlock > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Set pbData
    *ppbData = (LPBYTE)((LPBYTE)(*ppBlock) + sizeof(STREAMBLOCK));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradePropTreeMessageFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradePropTreeMessageFileV5(LPFILEINFO pInfo, LPMEMORYFILE pFile,
    IDatabase *pDB, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    LPBYTE              pbStart;
    LPBYTE              pbData;
    DWORD               faRecord;
    DWORD               faStreamBlock;
    FILEADDRESS         faDstStream;
    MESSAGEINFO         MsgInfo;
    IStream            *pStream=NULL;
    FILEADDRESS         faStream;
    LPFOLDERUSERDATAV4  pUserDataV4;
    FOLDERUSERDATA      UserDataV5;
    LPSTREAMBLOCK       pStmBlock;
    LPRECORDBLOCKV5B1   pRecord;
    LPTABLEHEADERV5B1   pHeader=(LPTABLEHEADERV5B1)pFile->pView;

    // Trace
    TraceCall("UpgradePropTreeMessageFileV5");
    
    // Validate
    Assert(sizeof(FOLDERUSERDATAV4) == sizeof(FOLDERUSERDATA));

    // Get CacheInfo
    if (sizeof(FOLDERUSERDATA) != pHeader->cbUserData)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_USERDATASIZEDIFF);
        goto exit;
    }

    // Get V4 UserData
    pUserDataV4 = (LPFOLDERUSERDATAV4)((LPBYTE)pFile->pView + sizeof(TABLEHEADERV5B1));

    // If there is a Server Name and acctid is empty...
    if ('\0' != *pUserDataV4->szServer && '\0' == *pInfo->szAcctId)
    {
        // Loop through the Accounts
        for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
        {
            // Is this the Account
            if (lstrcmpi(g_AcctTable.prgAccount[i].szServer, pUserDataV4->szServer) == 0)
            {
                lstrcpy(pInfo->szAcctId, g_AcctTable.prgAccount[i].szAcctId);
                break;
            }
        }
    }

    // If there is a folder name, copy it
    if ('\0' != *pUserDataV4->szGroup)
    {
        // Copy
        lstrcpyn(pInfo->szFolder, pUserDataV4->szGroup, ARRAYSIZE(pInfo->szFolder));
    }

    // Zero New
    ZeroMemory(&UserDataV5, sizeof(FOLDERUSERDATA));

    // Copy Over Relavent Stuff
    UserDataV5.dwUIDValidity = pUserDataV4->dwUIDValidity;

    // Set user data
    IF_FAILEXIT(hr = pDB->SetUserData(&UserDataV5, sizeof(FOLDERUSERDATA)));

    // Initialize faRecord to start
    faRecord = pHeader->faFirstRecord;

    // While we have a record
    while(faRecord)
    {
        // Get the Record
        IF_FAILEXIT(hr = GetRecordBlock(pFile, faRecord, &pRecord, &pbData, pfContinue));

        // Set pbStart
        pbStart = pbData;

        // Clear MsgInfo
        ZeroMemory(&MsgInfo, sizeof(MESSAGEINFO));

        // DWORD - idMessage
        CopyMemory(&MsgInfo.idMessage, pbData, sizeof(MsgInfo.idMessage));
        pbData += sizeof(MsgInfo.idMessage);

        // Null Message Id
        if (0 == MsgInfo.idMessage)
        {
            // Generate
            pDB->GenerateId((LPDWORD)&MsgInfo.idMessage);
        }

        // DWORD - dwFlags
        CopyMemory(&MsgInfo.dwFlags, pbData, sizeof(MsgInfo.dwFlags));
        pbData += sizeof(MsgInfo.dwFlags);

        // News ?
        if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile)
            FLAGSET(MsgInfo.dwFlags, ARF_NEWSMSG);

        // Priority
        if (ISFLAGSET(MsgInfo.dwFlags, 0x00000200))
        {
            MsgInfo.wPriority = (WORD)IMSG_PRI_HIGH;
            FLAGCLEAR(MsgInfo.dwFlags, 0x00000200);
        }
        else if (ISFLAGSET(MsgInfo.dwFlags, 0x00000100))
        {
            MsgInfo.wPriority = (WORD)IMSG_PRI_LOW;
            FLAGCLEAR(MsgInfo.dwFlags, 0x00000100);
        }
        else
            MsgInfo.wPriority = (WORD)IMSG_PRI_NORMAL;

        // DWORD - ftSent
        CopyMemory(&MsgInfo.ftSent, pbData, sizeof(MsgInfo.ftSent));
        pbData += sizeof(MsgInfo.ftSent);
        MsgInfo.ftReceived = MsgInfo.ftSent;

        // DWORD - cLines
        CopyMemory(&MsgInfo.cLines, pbData, sizeof(MsgInfo.cLines));
        pbData += sizeof(MsgInfo.cLines);

        // DWORD - faStream
        CopyMemory(&faStream, pbData, sizeof(faStream));
        pbData += sizeof(faStream);

        // Has a Body
        if (faStream)
        {
            // It has a body
            FLAGSET(MsgInfo.dwFlags, ARF_HASBODY);
        }

        // DWORD - cbArticle / cbMessage (VERSION)
        CopyMemory(&MsgInfo.cbMessage, pbData, sizeof(MsgInfo.cbMessage));
        pbData += sizeof(MsgInfo.cbMessage);

        // DWORD - ftDownloaded
        CopyMemory(&MsgInfo.ftDownloaded, pbData, sizeof(MsgInfo.ftDownloaded));
        pbData += sizeof(MsgInfo.ftDownloaded);

        // LPSTR - pszMessageId
        MsgInfo.pszMessageId = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszMessageId) + 1);

        // LPSTR - pszSubject
        MsgInfo.pszSubject = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszSubject) + 1);

        // VERSION
        MsgInfo.pszNormalSubj = MsgInfo.pszSubject + HIBYTE(HIWORD(MsgInfo.dwFlags));

        // LPSTR - pszFromHeader
        MsgInfo.pszFromHeader = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszFromHeader) + 1);

        // LPSTR - pszReferences
        MsgInfo.pszReferences = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszReferences) + 1);

        // LPSTR - pszXref
        MsgInfo.pszXref = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszXref) + 1);

        // LPSTR - pszServer
        MsgInfo.pszServer = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszServer) + 1);

        // LPSTR - pszDisplayFrom
        MsgInfo.pszDisplayFrom = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszDisplayFrom) + 1);

        // No Display From and we have a from header
        if ('\0' == *MsgInfo.pszDisplayFrom && '\0' != MsgInfo.pszFromHeader)
            MsgInfo.pszDisplayFrom = MsgInfo.pszFromHeader;

        // LPSTR - pszEmailFrom
        MsgInfo.pszEmailFrom = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszEmailFrom) + 1);

        // Going to V4 ?
        if (pRecord->cbRecord - (DWORD)(pbData - pbStart) - sizeof(RECORDBLOCKV5B1) > 40)
        {
            // WORD - wLanguage
            CopyMemory(&MsgInfo.wLanguage, pbData, sizeof(MsgInfo.wLanguage));
            pbData += sizeof(MsgInfo.wLanguage);

            // WORD - wReserved
            pbData += sizeof(WORD);

            // DWORD - cbMessage
            CopyMemory(&MsgInfo.cbMessage, pbData, sizeof(MsgInfo.cbMessage));
            pbData += sizeof(MsgInfo.cbMessage);

            // FILETIME - ftReceived
            CopyMemory(&MsgInfo.ftReceived, pbData, sizeof(MsgInfo.ftReceived));
            pbData += sizeof(MsgInfo.ftReceived);

            // SBAILEY: Raid-76295: News store corrupted when system dates are changed, Find dialog returns dates of 1900, 00 or blank
            if (0 == MsgInfo.ftReceived.dwLowDateTime && 0 == MsgInfo.ftReceived.dwHighDateTime)
                CopyMemory(&MsgInfo.ftReceived, &MsgInfo.ftSent, sizeof(FILETIME));

            // LPSTR - pszDisplayTo
            MsgInfo.pszDisplayTo = (LPSTR)pbData;
            pbData += (lstrlen(MsgInfo.pszDisplayTo) + 1);
        }

        // Otherwise
        else
        {
            // Set ftReceived
            CopyMemory(&MsgInfo.ftReceived, &MsgInfo.ftSent, sizeof(FILETIME));
        }

        // Copy over the stream...
        if (0 != faStream)
        {
            // Allocate a new stream
            IF_FAILEXIT(hr = pDB->CreateStream(&faDstStream));

            // Open the stream
            IF_FAILEXIT(hr = pDB->OpenStream(ACCESS_WRITE, faDstStream, &pStream));

            // Start Copying Message
            faStreamBlock = faStream;

            // While we have a stream block
            while(faStreamBlock)
            {
                // Get a stream block
                IF_FAILEXIT(hr = GetStreamBlock(pFile, faStreamBlock, &pStmBlock, &pbData, pfContinue));

                // Write into the stream
                IF_FAILEXIT(hr = pStream->Write(pbData, pStmBlock->cbData, NULL));

                // Goto Next Block
                faStreamBlock = pStmBlock->faNext;
            }

            // Commit
            IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

            // Set new stream location
            MsgInfo.faStream = faDstStream;

            // Release the Stream
            SafeRelease(pStream);
        }

        // If No Account Id and we have a server
        if ('\0' == *pInfo->szAcctId && '\0' != *MsgInfo.pszServer)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szServer, MsgInfo.pszServer) == 0)
                {
                    lstrcpy(pInfo->szAcctId, g_AcctTable.prgAccount[i].szAcctId);
                    break;
                }
            }
        }

        // Default to szAcctId
        MsgInfo.pszAcctId = pInfo->szAcctId;

        // Lookup Account Id from the Account Name...
        if (MsgInfo.pszAcctName)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szAcctName, MsgInfo.pszAcctName) == 0)
                {
                    MsgInfo.pszAcctId = g_AcctTable.prgAccount[i].szAcctId;
                    break;
                }
            }
        }

        // Otherwise, if we have an account Id, get the account name
        else if ('\0' != *pInfo->szAcctId)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szAcctId, MsgInfo.pszAcctId) == 0)
                {
                    MsgInfo.pszAcctName = g_AcctTable.prgAccount[i].szAcctName;
                    break;
                }
            }
        }

        // Count
        pInfo->cMessages++;
        if (!ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            pInfo->cUnread++;

        // Migrated
        FLAGSET(MsgInfo.dwFlags, 0x00000010);

        // Insert the Record
        IF_FAILEXIT(hr = pDB->InsertRecord(&MsgInfo));

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);

        // Goto the Next Record
        faRecord = pRecord->faNext;
    }

exit:
    // Cleanup
    SafeRelease(pStream);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ParseFolderFileV5
// --------------------------------------------------------------------------------
HRESULT ParseFolderFileV5(LPMEMORYFILE pFile, LPFILEINFO pInfo, 
    LPPROGRESSINFO pProgress, LPDWORD pcFolders, 
    LPFLDINFO *pprgFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    LPBYTE              pbData;
    DWORD               faRecord;
    LPFLDINFO           pFolder;
    LPFLDINFO           prgFolder=NULL;
    LPRECORDBLOCKV5B1   pRecord;
    LPTABLEHEADERV5B1   pHeader;
    BOOL                fContinue;
    DWORD               cFolders=0;

    // Trace
    TraceCall("ParseFolderFileV5");

    // De-ref the header
    pHeader = (LPTABLEHEADERV5B1)pFile->pView;

    // Get CacheInfo
    if (sizeof(STOREUSERDATA) != pHeader->cbUserData)
    {
        hr = TraceResult(MIGRATE_E_USERDATASIZEDIFF);
        goto exit;
    }

    // Allocate Folder Array
    IF_NULLEXIT(prgFolder = (LPFLDINFO)ZeroAllocate(sizeof(FLDINFO) * pHeader->cRecords));

    // Initialize faRecord to start
    faRecord = pHeader->faFirstRecord;

    // While we have a record
    while(faRecord)
    {
        // Readability
        pFolder = &prgFolder[cFolders];

        // Get the Record
        IF_FAILEXIT(hr = GetRecordBlock(pFile, faRecord, &pRecord, &pbData, &fContinue));

        // DWORD - hFolder
        CopyMemory(&pFolder->idFolder, pbData, sizeof(pFolder->idFolder));
        pbData += sizeof(pFolder->idFolder);

        // CHAR(MAX_FOLDER_NAME) - szFolder
        CopyMemory(pFolder->szFolder, pbData, sizeof(pFolder->szFolder));
        pbData += sizeof(pFolder->szFolder);

        // CHAR(260) - szFile
        CopyMemory(pFolder->szFile, pbData, sizeof(pFolder->szFile));
        pbData += sizeof(pFolder->szFile);

        // DWORD - idParent
        CopyMemory(&pFolder->idParent, pbData, sizeof(pFolder->idParent));
        pbData += sizeof(pFolder->idParent);

        // DWORD - idChild
        CopyMemory(&pFolder->idChild, pbData, sizeof(pFolder->idChild));
        pbData += sizeof(pFolder->idChild);

        // DWORD - idSibling
        CopyMemory(&pFolder->idSibling, pbData, sizeof(pFolder->idSibling));
        pbData += sizeof(pFolder->idSibling);

        // DWORD - tySpecial
        CopyMemory(&pFolder->tySpecial, pbData, sizeof(pFolder->tySpecial));
        pbData += sizeof(pFolder->tySpecial);

        // DWORD - cChildren
        CopyMemory(&pFolder->cChildren, pbData, sizeof(pFolder->cChildren));
        pbData += sizeof(pFolder->cChildren);

        // DWORD - cMessages
        CopyMemory(&pFolder->cMessages, pbData, sizeof(pFolder->cMessages));
        pbData += sizeof(pFolder->cMessages);

        // DWORD - cUnread
        CopyMemory(&pFolder->cUnread, pbData, sizeof(pFolder->cUnread));
        pbData += sizeof(pFolder->cUnread);

        // DWORD - cbTotal
        CopyMemory(&pFolder->cbTotal, pbData, sizeof(pFolder->cbTotal));
        pbData += sizeof(pFolder->cbTotal);

        // DWORD - cbUsed
        CopyMemory(&pFolder->cbUsed, pbData, sizeof(pFolder->cbUsed));
        pbData += sizeof(pFolder->cbUsed);

        // DWORD - bHierarchy
        CopyMemory(&pFolder->bHierarchy, pbData, sizeof(pFolder->bHierarchy));
        pbData += sizeof(pFolder->bHierarchy);

        // DWORD - dwImapFlags
        CopyMemory(&pFolder->dwImapFlags, pbData, sizeof(pFolder->dwImapFlags));
        pbData += sizeof(DWORD);

        // BLOB - bListStamp
        CopyMemory(&pFolder->bListStamp, pbData, sizeof(pFolder->bListStamp));
        pbData += sizeof(BYTE);

        // DWORD - bReserved[3]
        pbData += (3 * sizeof(BYTE));

        // DWORD - rgbReserved
        pbData += 40;

        // Increment Count
        cFolders++;

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);

        // Goto the Next Record
        faRecord = pRecord->faNext;
    }

    // Return Folder Count
    *pcFolders = cFolders;

    // Return the Array
    *pprgFolder = prgFolder;

    // Don't Free It
    prgFolder = NULL;

exit:
    // Cleanup
    SafeMemFree(prgFolder);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradePop3UidlFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradePop3UidlFileV5(LPFILEINFO pInfo, LPMEMORYFILE pFile,
    IDatabase *pDB, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    LPBYTE              pbData;
    DWORD               faRecord;
    UIDLRECORD          UidlInfo;
    LPRECORDBLOCKV5B1   pRecord;
    LPTABLEHEADERV5B1   pHeader=(LPTABLEHEADERV5B1)pFile->pView;

    // Trace
    TraceCall("UpgradePop3UidlFileV5");

    // Initialize faRecord to start
    faRecord = pHeader->faFirstRecord;

    // While we have a record
    while(faRecord)
    {
        // Get the Record
        IF_FAILEXIT(hr = GetRecordBlock(pFile, faRecord, &pRecord, &pbData, pfContinue));

        // Clear UidlInfo
        ZeroMemory(&UidlInfo, sizeof(UIDLRECORD));

        // FILETIME - ftDownload
        CopyMemory(&UidlInfo.ftDownload, pbData, sizeof(UidlInfo.ftDownload));
        pbData += sizeof(UidlInfo.ftDownload);

        // BYTE - fDownloaded
        CopyMemory(&UidlInfo.fDownloaded, pbData, sizeof(UidlInfo.fDownloaded));
        pbData += sizeof(UidlInfo.fDownloaded);

        // BYTE - fDeleted
        CopyMemory(&UidlInfo.fDeleted, pbData, sizeof(UidlInfo.fDeleted));
        pbData += sizeof(UidlInfo.fDeleted);

        // LPSTR - pszUidl
        UidlInfo.pszUidl = (LPSTR)pbData;
        pbData += (lstrlen(UidlInfo.pszUidl) + 1);

        // LPSTR - pszServer
        UidlInfo.pszServer = (LPSTR)pbData;
        pbData += (lstrlen(UidlInfo.pszServer) + 1);

        // Insert the Record
        IF_FAILEXIT(hr = pDB->InsertRecord(&UidlInfo));

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);

        // Goto the Next Record
        faRecord = pRecord->faNext;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradeFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradeFileV5(IDatabaseSession *pSession, MIGRATETOTYPE tyMigrate, 
    LPFILEINFO pInfo, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    IDatabase     *pDB=NULL;

    // Trace
    TraceCall("UpgradeFileV5");

    // Local message file
    if (FILE_IS_LOCAL_MESSAGES == pInfo->tyFile)
    {
        // Create an ObjectDatabase (upgrade only runs when OE5 is installed)
        IF_FAILEXIT(hr = pSession->OpenDatabase(pInfo->szDstFile, 0, &g_MessageTableSchema, NULL, &pDB));

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradeLocalStoreFileV5
        IF_FAILEXIT(hr = UpgradeLocalStoreFileV5(pInfo, &File, pDB, pProgress, pfContinue));
    }

    // Old News or Imap file
    else if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
    {
        // Create an ObjectDatabase (upgrade only runs when OE5 is installed)
        IF_FAILEXIT(hr = pSession->OpenDatabase(pInfo->szDstFile, 0, &g_MessageTableSchema, NULL, &pDB));

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradePropTreeMessageFileV5
        IF_FAILEXIT(hr = UpgradePropTreeMessageFileV5(pInfo, &File, pDB, pProgress, pfContinue));
    }

    // pop3uidl file
    else if (FILE_IS_POP3UIDL == pInfo->tyFile)
    {
        // Create an ObjectDatabase (upgrade only runs when OE5 is installed)
        IF_FAILEXIT(hr = pSession->OpenDatabase(pInfo->szDstFile, 0, &g_UidlTableSchema, NULL, &pDB));

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradePop3UidlFileV5
        IF_FAILEXIT(hr = UpgradePop3UidlFileV5(pInfo, &File, pDB, pProgress, pfContinue));
    }

exit:
    // Cleanup
    SafeRelease(pDB);
    CloseMemoryFile(&File);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradeProcessFileListV5
// --------------------------------------------------------------------------------
HRESULT UpgradeProcessFileListV5(LPCSTR pszStoreSrc, LPCSTR pszStoreDst, 
    LPFILEINFO pHead, LPDWORD pcMax, LPDWORD pcbNeeded)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPFILEINFO          pCurrent;
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("UpgradeProcessFileListV5");

    // Init
    *pcMax = 0;
    *pcbNeeded = 0;

    // Loop
    for (pCurrent=pHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Get the File Header
        hr = OpenMemoryFile(pCurrent->szFilePath, &File);

        // Failure ?
        if (FAILED(hr) || 0 == File.cbSize)
        {
            // Don't Migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = (0 == File.cbSize ? S_OK : hr);

            // Reset hr
            hr = S_OK;

            // Get the LastError
            pCurrent->dwLastError = GetLastError();

            // Goto Next
            goto NextFile;
        }

        // Local message file
        if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
        {
            // Cast the Header
            LPMBXFILEHEADER pMbxHeader=(LPMBXFILEHEADER)File.pView;

            // Bad Version
            if (File.cbSize < sizeof(MBXFILEHEADER) || pMbxHeader->dwMagic != MSGFILE_MAGIC || pMbxHeader->ver != MSGFILE_VER)
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pMbxHeader->cMsg;
        }

        // Otherwise, if its a news group list
        else if (FILE_IS_NEWS_SUBLIST == pCurrent->tyFile)
        {
            // De-Ref the header
            LPSUBLISTHEADER pSubList = (LPSUBLISTHEADER)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(SUBLISTHEADER) || 
                (SUBFILE_VERSION5 != pSubList->dwVersion &&
                 SUBFILE_VERSION4 != pSubList->dwVersion &&
                 SUBFILE_VERSION3 != pSubList->dwVersion &&
                 SUBFILE_VERSION2 != pSubList->dwVersion))
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pSubList->cSubscribed;
        }

        // Otherwise, if its a news sub list
        else if (FILE_IS_NEWS_GRPLIST == pCurrent->tyFile)
        {
            // De-Ref the header
            LPGRPLISTHEADER pGrpList = (LPGRPLISTHEADER)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(GRPLISTHEADER) || GROUPLISTVERSION != pGrpList->dwVersion)
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pGrpList->cGroups;
        }

        // Otherwise, objectdb file
        else
        {
            // De-Ref the header
            pHeader = (LPTABLEHEADERV5B1)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(TABLEHEADERV5B1) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_PRE_V5 != pHeader->wMajorVersion)
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pHeader->cRecords;
        }

        // Special Case pop3uidl.dat
        if (FILE_IS_POP3UIDL == pCurrent->tyFile)
        {
            // Compute Real Destination File
            wsprintf(pCurrent->szDstFile, "%s\\pop3uidl.dbx", pszStoreDst);
        }

        // Otherwise, generate a unqiue message file name
        else
        {
            // Save the Folder Id
            pCurrent->idFolder = g_idFolderNext;

            // Build New Path
            wsprintf(pCurrent->szDstFile, "%s\\%08d.dbx", pszStoreDst, g_idFolderNext);

            // Increment id
            g_idFolderNext++;
        }

        // Initialize counters
        InitializeCounters(&File, pCurrent, pcMax, pcbNeeded, TRUE);

        // Yes, Migrate
        pCurrent->fMigrate = TRUE;

NextFile:
        // Close the File
        CloseMemoryFile(&File);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradeDeleteFilesV5
// --------------------------------------------------------------------------------
void UpgradeDeleteFilesV5(LPCSTR pszStoreDst)
{
    // Locals
    CHAR            szSearch[MAX_PATH + MAX_PATH];
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    HANDLE          hFind=INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;

    // Trace
    TraceCall("UpgradeDeleteFilesV5");

    // Do we have a sub dir
    wsprintf(szSearch, "%s\\*.dbx", pszStoreDst);

    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    while(1)
    {
        // Make File Path
        MakeFilePath(pszStoreDst, fd.cFileName, "", szFilePath, ARRAYSIZE(szFilePath));

        // Delete
        DeleteFile(szFilePath);

        // Find the Next File
        if (!FindNextFile(hFind, &fd))
            break;
    }

exit:
    // Cleanup
    if (hFind)
        FindClose(hFind);
}

// --------------------------------------------------------------------------------
// UpgradeDeleteIdxMbxNchDatFilesV5
// --------------------------------------------------------------------------------
void UpgradeDeleteIdxMbxNchDatFilesV5(LPFILEINFO pHeadFile)
{
    // Locals
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("UpgradeDeleteOdbFilesV5");

    // Delete all old files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Succeeded
        Assert(SUCCEEDED(pCurrent->hrMigrate));

        // Delete the file
        // DeleteFile(pCurrent->szFilePath);

        // If local message file, need to delete the idx file
        if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".idx", szDstFile);

            // Delete the file
            // DeleteFile(szDstFile);
        }
    }

    // Done
    return;
}

// --------------------------------------------------------------------------------
// GetSpecialFolderInfo
// --------------------------------------------------------------------------------
HRESULT GetSpecialFolderInfo(LPCSTR pszFilePath, LPSTR pszFolder, 
    DWORD cchFolder, DWORD *ptySpecial)
{
    // Locals
    CHAR    szPath[_MAX_PATH];
    CHAR    szDrive[_MAX_DRIVE];
    CHAR    szDir[_MAX_DIR];
    CHAR    szFile[_MAX_FNAME];
    CHAR    szExt[_MAX_EXT];
    CHAR    szRes[255];
    DWORD   i;

    // Trace
    TraceCall("ReplaceExtension");

    // Initialize
    *ptySpecial = 0xffffffff;

    // Split the Path
    _splitpath(pszFilePath, szDrive, szDir, szFile, szExt);

    // Set Folder Name
    lstrcpyn(pszFolder, szFile, cchFolder);

    // Loop through special folder
    for (i=FOLDER_INBOX; i<FOLDER_MAX; i++)
    {
        // Load the Special Folder Name
        LoadString(g_hInst, IDS_INBOX + (i - 1), szRes, ARRAYSIZE(szRes));

        // Compare with szFile
        if (lstrcmpi(szFile, szRes) == 0)
        {
            // Copy the Folder Name
            lstrcpyn(pszFolder, szRes, cchFolder);

            // Return special folder type
            *ptySpecial = (i - 1);

            // Success
            return(S_OK);
        }
    }

    // Done
    return(E_FAIL);
}

// --------------------------------------------------------------------------------
// FixupFolderUserData
// --------------------------------------------------------------------------------
HRESULT FixupFolderUserData(IDatabaseSession *pSession, FOLDERID idFolder, 
    LPCSTR pszName, SPECIALFOLDER tySpecial, LPFILEINFO pCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERUSERDATA  UserData;
    IDatabase *pDB=NULL;

    // Trace
    TraceCall("FixupFolderUserData");

    // Better not be in the store yet
    Assert(FALSE == pCurrent->fInStore);

    // Its in the store
    pCurrent->fInStore = TRUE;

    // Create an Ojbect Database
    IF_FAILEXIT(hr = pSession->OpenDatabase(pCurrent->szDstFile, 0, &g_MessageTableSchema, NULL, &pDB));

    // Store the User Data
    IF_FAILEXIT(hr = pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Its Initialized
    UserData.fInitialized = TRUE;

    // UserData.clsidType
    if (ISFLAGSET(pCurrent->dwServer, SRV_POP3))
        UserData.tyFolder = FOLDER_LOCAL;
    else if (ISFLAGSET(pCurrent->dwServer, SRV_NNTP))
        UserData.tyFolder = FOLDER_NEWS;
    else if (ISFLAGSET(pCurrent->dwServer, SRV_IMAP))
        UserData.tyFolder = FOLDER_IMAP;

    // Copy the Account Id
    lstrcpyn(UserData.szAcctId, pCurrent->szAcctId, ARRAYSIZE(UserData.szAcctId));

    // Save Folder Id
    UserData.idFolder = idFolder;

    // Save Special Folder Type
    UserData.tySpecial = tySpecial;

    // Copy the Folder name
    lstrcpyn(UserData.szFolder, pszName, ARRAYSIZE(UserData.szFolder));

    // Must be Subscribed
    UserData.fSubscribed = TRUE;

    // Set the Sort Index Information
    UserData.idSort = COLUMN_RECEIVED;

    // Not Ascending
    UserData.fAscending = FALSE;

    // Not threaded
    UserData.fThreaded = FALSE;

    // Basic Filter
    UserData.ridFilter = RULEID_VIEW_ALL;

    // Add Welcome Message Again
    UserData.fWelcomeAdded = FALSE;

    // Show Deleted
    UserData.fShowDeleted = TRUE;

    // New thread model
    UserData.fNewThreadModel = TRUE;
    UserData.fTotalWatched = TRUE;
    UserData.fWatchedCounts = TRUE;

    // Store the User Data
    IF_FAILEXIT(hr = pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));

exit:
    // Cleanup
    SafeRelease(pDB);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// SetIMAPSpecialFldrType
// --------------------------------------------------------------------------------
HRESULT SetIMAPSpecialFldrType(LPSTR pszAcctID, LPSTR pszFldrName, SPECIALFOLDER *psfType)
{
    char                szPath[MAX_PATH + 1];
    SPECIALFOLDER       sfResult = FOLDER_NOTSPECIAL;

    TraceCall("SetIMAPSpecialFldrType");
    Assert(NULL != psfType);
    Assert(FOLDER_NOTSPECIAL == *psfType);

    LoadString(g_hInst, IDS_SENTITEMS, szPath, sizeof(szPath));
    if (0 == lstrcmp(szPath, pszFldrName))
    {
        sfResult = FOLDER_SENT;
        goto exit;
    }

    LoadString(g_hInst, IDS_DRAFT, szPath, sizeof(szPath));
    if (0 == lstrcmp(szPath, pszFldrName))
    {
        sfResult = FOLDER_DRAFT;
        goto exit;
    }


exit:
    *psfType = sfResult;
    return S_OK;
}

// --------------------------------------------------------------------------------
// InsertFolderIntoStore
// --------------------------------------------------------------------------------
HRESULT InsertFolderIntoStore(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFLDINFO pThis, DWORD cFolders, LPFLDINFO prgFolder, FOLDERID idParentNew, 
    LPFILEINFO pInfo, LPFILEINFO pFileHead, LPFOLDERID pidNew)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    CHAR            szPath[_MAX_PATH];
    CHAR            szDrive[_MAX_DRIVE];
    CHAR            szDir[_MAX_DIR];
    CHAR            szFile[_MAX_FNAME];
    CHAR            szExt[_MAX_EXT];
    CHAR            szFilePath[MAX_PATH];
    CHAR            szInbox[MAX_PATH];
    BOOL            fFound=FALSE;
    LPFILEINFO      pCurrent=NULL;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("InsertFolderIntoStore");

    // Invalid Arg
    //Assert(FILE_IS_LOCAL_FOLDERS == pInfo->tyFile || FILE_IS_IMAP_FOLDERS == pInfo->tyFile);

    // Copy Stuff Over to Folder
    Folder.pszName = pThis->szFolder;
    Folder.idParent = idParentNew;
    Folder.bHierarchy = pThis->bHierarchy;
    Folder.dwFlags = FOLDER_SUBSCRIBED;    // $$TODO$$ May need to adjust and map to new flags
    Folder.tySpecial = (0xffffffff == pThis->tySpecial) ? FOLDER_NOTSPECIAL : (BYTE)(pThis->tySpecial + 1);
    Folder.cMessages = pThis->cMessages;
    Folder.cUnread = pThis->cUnread;
    Folder.pszFile = pThis->szFile;
    Folder.dwListStamp = pThis->bListStamp;

    // For IMAP folders, we have to set tySpecial based on registry folder paths
    if (pInfo && FILE_IS_IMAP_FOLDERS == pInfo->tyFile && NULL != pThis &&
        FOLDERID_ROOT == (FOLDERID)IntToPtr(pThis->idParent))
    {
        HRESULT hrTemp;

        if (FOLDER_NOTSPECIAL == Folder.tySpecial)
        {
            hrTemp = SetIMAPSpecialFldrType(pInfo->szAcctId, Folder.pszName, &Folder.tySpecial);
            TraceError(hrTemp);
            Assert(SUCCEEDED(hrTemp) || FOLDER_NOTSPECIAL == Folder.tySpecial);
        }
        else if (FOLDER_INBOX == Folder.tySpecial)
        {
            LoadString(g_hInst, IDS_INBOX, szInbox, ARRAYSIZE(szInbox));
            Folder.pszName = szInbox;
        }
    }

    // Look for Current
    if (pInfo && pFileHead)
    {
        // Locate the file...
        for (pCurrent=pFileHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
        {
            // Migrate
            if (pCurrent->fMigrate)
            {
                // Local Folder ?
                if (FILE_IS_LOCAL_FOLDERS == pInfo->tyFile && FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
                {
                    // Get the File Name
                    _splitpath(pCurrent->szFilePath, szDrive, szDir, szFile, szExt);

                    // Test For File Name
                    if (lstrcmpi(szFile, pThis->szFile) == 0)
                    {
                        // This is It
                        fFound = TRUE;

                        // Adjust the Flags
                        FLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED);
                    }
                }
            
                // IMAP Folders ?
                else if (FILE_IS_IMAP_FOLDERS == pInfo->tyFile && FILE_IS_IMAP_MESSAGES == pCurrent->tyFile)
                {
                    // Same Account
                    if (lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
                    {
                        // Get the File Name
                        _splitpath(pCurrent->szFilePath, szDrive, szDir, szFile, szExt);

                        // Build File
                        wsprintf(szFilePath, "%s.nch", szFile);

                        // Test For File Name
                        if (lstrcmpi(szFilePath, pThis->szFile) == 0)
                        {
                            // This is It
                            fFound = TRUE;
                        }
                    }
                }

                // Found
                if (fFound)
                {
                    // Get the File Name
                    _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);

                    // Build File
                    wsprintf(szFilePath, "%s.dbx", szFile);

                    // Local the File for this folder and set
                    Folder.pszFile = szFilePath;

                    // Set Folder Counts
                    Folder.cMessages = pCurrent->cMessages;
                    Folder.cUnread = pCurrent->cUnread;

                    // Done
                    break;
                }
            }
        }
    }

    // If this is a special folder, then lets try to see if it already exists...
    if (FOLDER_NOTSPECIAL != Folder.tySpecial)
    {
        // Locals
        FOLDERINFO Special;

        // pThis Parent should be invalid
        Assert(FOLDERID_ROOT == (FOLDERID)IntToPtr(pThis->idParent));

        // Try to get the special folder info
        if (FAILED(pStore->GetSpecialFolderInfo(idParentNew, Folder.tySpecial, &Special)))
        {
            // Create the Folder
            IF_FAILEXIT(hr = pStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK));

            // Update pThis->dwServerHigh with new folderid
            pThis->idNewFolderId = (DWORD_PTR)Folder.idFolder;
        }

        // Otherwise...
        else
        {
            // Update pThis->dwServerHigh with new folderid
            pThis->idNewFolderId = (DWORD_PTR)Special.idFolder;

            // Update the Special folder
            Folder.idFolder = Special.idFolder;

            // Update Special
            Special.bHierarchy = Folder.bHierarchy;
            Special.dwFlags = Folder.dwFlags;    // $$TODO$$ May need to adjust and map to new flags
            Special.cMessages = Folder.cMessages;
            Special.cUnread = Folder.cUnread;
            Special.pszFile = Folder.pszFile;
            Special.dwListStamp = Folder.dwListStamp;

            // Update the Record
            IF_FAILEXIT(hr = pStore->UpdateRecord(&Special));

            // Free Special
            pStore->FreeRecord(&Special);
        }
    }

    // Otherwise, just try to create the folder
    else
    {
        // Create the Folder
        IF_FAILEXIT(hr = pStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK));

        // Update pThis->dwServerHigh with new folderid
        pThis->idNewFolderId = (DWORD_PTR)Folder.idFolder;
    }

    // If We Found a folder...
    if (pCurrent)
    {
        // Update the Folder's UserData
        IF_FAILEXIT(hr = FixupFolderUserData(pSession, Folder.idFolder, pThis->szFolder, Folder.tySpecial, pCurrent));
    }

    // Walk Insert the children of pThis
    for (i=0; i<cFolders; i++)
    {
        // If Parent is equal to idParent, then lets insert this node under the new parent
        if (prgFolder[i].idParent == pThis->idFolder)
        {
            // Can't be null
            Assert(prgFolder[i].idFolder);

            // InsertFolderIntoStore
            IF_FAILEXIT(hr = InsertFolderIntoStore(pSession, pStore, &prgFolder[i], cFolders, prgFolder, Folder.idFolder, pInfo, pFileHead, NULL));
        }
    }

    // Return the New Folder
    if (pidNew)
        *pidNew = Folder.idFolder;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MergeFolderCacheIntoStore
// --------------------------------------------------------------------------------
HRESULT MergeFolderCacheIntoStore(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFILEINFO pInfo, LPFILEINFO pHeadFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    FOLDERID            idServer;
    DWORD               cFolders;
    DWORD               i;
    LPFLDINFO           prgFolder=NULL;
    LPFLDINFO           pFolder;
    HKEY                hKey=NULL;
    DWORD               cbLength;
    LPBYTE              pbChange=NULL;
    LPFOLDERIDCHANGE    prgidChange;
    IUserIdentityManager    *pManager = NULL;
    IUserIdentity           *pIdentity = NULL;
    HKEY                    hkeyID = NULL;

    // Trace
    TraceCall("MergeFolderCacheIntoStore");

    // Find the Server Id
    if (FAILED(pStore->FindServerId(pInfo->szAcctId, &idServer)))
        goto exit;

    // Open the File
    IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

    // Parse the file
    IF_FAILEXIT(hr = ParseFolderFileV5(&File, pInfo, pProgress, &cFolders, &prgFolder));

    // Loop through the folders
    for (i=0; i<cFolders; i++)
    {
        // If this is the root folder node (OE4), remember to migrate the root hierarchy char
        if ((FOLDERID)IntToPtr(prgFolder[i].idFolder) == FOLDERID_ROOT)
        {
            FOLDERINFO  fiFolderInfo;

            IF_FAILEXIT(hr = pStore->GetFolderInfo(idServer, &fiFolderInfo));

            fiFolderInfo.bHierarchy = prgFolder[i].bHierarchy;
            hr = pStore->UpdateRecord(&fiFolderInfo);
            pStore->FreeRecord(&fiFolderInfo);
            IF_FAILEXIT(hr);
        }
        // If Parent is equal to idParent, then lets insert this node under the new parent
        else if ((FOLDERID)IntToPtr(prgFolder[i].idParent) == FOLDERID_ROOT)
        {
            // InsertFolderIntoStore
            IF_FAILEXIT(hr = InsertFolderIntoStore(pSession, pStore, &prgFolder[i], cFolders, prgFolder, idServer, pInfo, pHeadFile, NULL));
        }
    }

    // Local Folders
    if (FILE_IS_LOCAL_FOLDERS == pInfo->tyFile)
    {
        // cbLength
        cbLength = (sizeof(DWORD) + (sizeof(FOLDERIDCHANGE) * cFolders));

        // Allocate a folderidchange array
        IF_NULLEXIT(pbChange = (LPBYTE)g_pMalloc->Alloc(cbLength));

        // Store cLocalFolders
        CopyMemory(pbChange, &cFolders, sizeof(DWORD));

        // Set prgidChange
        prgidChange = (LPFOLDERIDCHANGE)(pbChange + sizeof(DWORD));

        // Walk through the list of files and merge the folders, sublist, group lists into pFolder
        for (i=0; i<cFolders; i++)
        {
            prgidChange[i].idOld = (FOLDERID)IntToPtr(prgFolder[i].idFolder);
            prgidChange[i].idNew = (FOLDERID)prgFolder[i].idNewFolderId;
        }

        // Get a user manager    
        if (FAILED(CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IUserIdentityManager, (void **)&pManager)))
            goto exit;

        Assert(pManager);

        // Get Default Identity
        if (FAILED(pManager->GetIdentityByCookie((GUID*)&UID_GIBC_DEFAULT_USER, &pIdentity)))
            goto exit;

        Assert(pIdentity);

        // Ensure that we have an identity and can get to its registry
        if (FAILED(pIdentity->OpenIdentityRegKey(KEY_WRITE, &hkeyID)))
            goto exit;

        Assert(hkeyID);

        // Open the HKCU
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyID, "Software\\Microsoft\\Outlook Express\\5.0", 0, KEY_ALL_ACCESS, &hKey))
        {
            hr = TraceResult(MIGRATE_E_REGOPENKEY);
            goto exit;
        }

        // Write it to the registry
        if (ERROR_SUCCESS != RegSetValueEx(hKey, "FolderIdChange", 0, REG_BINARY, pbChange, cbLength))
        {
            hr = TraceResult(MIGRATE_E_REGSETVALUE);
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);
    if (hkeyID)
        RegCloseKey(hkeyID);
    SafeMemFree(pbChange);
    SafeMemFree(prgFolder);
    SafeRelease(pIdentity);
    SafeRelease(pManager);
 
    CloseMemoryFile(&File);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MergeNewsGroupList
// --------------------------------------------------------------------------------
HRESULT MergeNewsGroupList(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFILEINFO pInfo, LPFILEINFO pHeadFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERINFO      Folder={0};
    MEMORYFILE      File={0};
    FOLDERID        idServer;
    DWORD           cbRead;
    LPSTR           pszT;
    LPSTR           pszGroup;
    LPSTR           pszDescription;
    FOLDERID        idFolder;
    LPFILEINFO      pSubList=NULL;
    LPFILEINFO      pCurrent;
    LPSUBLISTHEADER pSubListHeader;
    IDatabase *pDB=NULL;
    CHAR            szPath[_MAX_PATH];
    CHAR            szDrive[_MAX_DRIVE];
    CHAR            szDir[_MAX_DIR];
    CHAR            szFile[_MAX_FNAME];
    CHAR            szExt[_MAX_EXT];
    LPGRPLISTHEADER pHeader;

    // Trace
    TraceCall("MergeNewsGroupList");

    // Find the Server Id
    if (FAILED(pStore->FindServerId(pInfo->szAcctId, &idServer)))
        goto exit;

    // Set Progress File
    SetProgressFile(pProgress, pInfo);

    // Open the Group List File
    IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

    // Get the Header
    pHeader = (LPGRPLISTHEADER)File.pView;

    // Initialize cb
    cbRead = sizeof(GRPLISTHEADER);

    // Loop
    for (i=0; i<pHeader->cGroups; i++)
    {
        // Set pszGroup
        pszT = pszGroup = (LPSTR)((LPBYTE)File.pView + cbRead);

        // Increment to end of pszGroup or end of file
        while (*pszT && cbRead < File.cbSize)
        {
            // Increment cb
            cbRead++;

            // End of String
            pszT = (LPSTR)((LPBYTE)File.pView + cbRead);
        }

        // Done
        if (cbRead >= File.cbSize)
            break;

        // Step Over the Null
        cbRead++;

        // Set pszDescription
        pszT = pszDescription = (LPSTR)((LPBYTE)File.pView + cbRead);

        // Increment to end of pszGroup or end of file
        while (*pszT && cbRead < File.cbSize)
        {
            // Increment cb
            cbRead++;

            // End of String
            pszT = (LPSTR)((LPBYTE)File.pView + cbRead);
        }

        // Done
        if (cbRead >= File.cbSize)
            break;

        // Increment over the null
        cbRead++;

        // Step over group type
        cbRead += sizeof(DWORD);

        // Not Empyt
        if ('\0' == *pszGroup)
            break;

        // Set the Folder Info
        Folder.pszName = pszGroup;
        Folder.pszDescription = pszDescription;
        Folder.idParent = idServer;
        Folder.tySpecial = FOLDER_NOTSPECIAL;

        // Create the Folder
        pStore->CreateFolder(0, &Folder, NOSTORECALLBACK);

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);
    }

    // Walk through news message files and create folders for them.
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Find the Sublist for this group
        if (FILE_IS_NEWS_SUBLIST == pCurrent->tyFile && lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
        {
            // Set pSubList
            pSubList = pCurrent;

            // Done
            break;
        }
    }

    // No Sub List
    if (NULL == pSubList)
        goto exit;

    // Close the File
    CloseMemoryFile(&File);

    // Set Progress File
    SetProgressFile(pProgress, pSubList);

    // Open the Group List File
    IF_FAILEXIT(hr = OpenMemoryFile(pSubList->szFilePath, &File));

    // De-Ref the header
    pSubListHeader = (LPSUBLISTHEADER)File.pView;

    // SUBFILE_VERSION5
    if (SUBFILE_VERSION5 == pSubListHeader->dwVersion)
    {
        // Locals
        PGROUPSTATUS5       pStatus;
        DWORD               cbRead;

        // Initialize cbRead
        cbRead = sizeof(SUBLISTHEADER) + sizeof(DWORD);

        // PGROUPSTATUS5
        for (i=0; i<pSubListHeader->cSubscribed; i++)
        {
            // De-Ref the Group Status
            pStatus = (PGROUPSTATUS5)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += sizeof(GROUPSTATUS5);

            // Read the Name
            pszGroup = (LPSTR)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += pStatus->cbName + pStatus->cbReadRange + pStatus->cbKnownRange + pStatus->cbMarkedRange + pStatus->cbRequestedRange;

            // Find The Folder...
            Folder.idParent = idServer;
            Folder.pszName = pszGroup;

            // Try to find this folder
            if (DB_S_FOUND == pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                // Locals
                CHAR szSrcFile[MAX_PATH];

                // Subscribe to It
                if (ISFLAGSET(pStatus->dwFlags, GSF_SUBSCRIBED))
                {
                    // Its SubScribed
                    FLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED);
                }

                // Format the original file name
                wsprintf(szSrcFile, "%08x", pStatus->dwCacheFileIndex);

                // Try to find the folder in the list of files
                for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
                {
                    // Find the Sublist for this group
                    if (pCurrent->fMigrate && FILE_IS_NEWS_MESSAGES == pCurrent->tyFile && lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
                    {
                        // Get the File Name
                        _splitpath(pCurrent->szFilePath, szDrive, szDir, szFile, szExt);

                        // Correct file name
                        if (lstrcmpi(szFile, szSrcFile) == 0)
                        {
                            // Get the File Name
                            _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);

                            // Format the original file name
                            wsprintf(szSrcFile, "%s%s", szFile, szExt);

                            // Set the File Path
                            Folder.pszFile = szSrcFile;

                            // Set Folder Counts
                            Folder.cMessages = pCurrent->cMessages;
                            Folder.cUnread = pCurrent->cUnread;

                            // FixupFolderUserData(
                            FixupFolderUserData(pSession, Folder.idFolder, pszGroup, FOLDER_NOTSPECIAL, pCurrent);

                            // Done
                            break;
                        }
                    }
                }

                // Update the Record
                pStore->UpdateRecord(&Folder);

                // Free This
                pStore->FreeRecord(&Folder);
            }

            // Bump Progress
            if(!g_fQuiet)
                IncrementProgress(pProgress, pSubList);
        }
    }

    // SUBFILE_VERSION4
    else if (SUBFILE_VERSION4 == pSubListHeader->dwVersion)
    {
        // Locals
        PGROUPSTATUS4       pStatus;
        DWORD               cbRead;

        // Initialize cbRead
        cbRead = sizeof(SUBLISTHEADER);

        // PGROUPSTATUS5
        for (i=0; i<pSubListHeader->cSubscribed; i++)
        {
            // De-Ref the Group Status
            pStatus = (PGROUPSTATUS4)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += sizeof(GROUPSTATUS4);

            // Read the Name
            pszGroup = (LPSTR)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += pStatus->cbName + pStatus->cbReadRange + pStatus->cbKnownRange + pStatus->cbMarkedRange + pStatus->cbRequestedRange;

            // Find The Folder...
            Folder.idParent = idServer;
            Folder.pszName = pszGroup;

            // Try to find this folder
            if (DB_S_FOUND == pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                // Locals
                CHAR szSrcFile[MAX_PATH];

                // Subscribe to It
                if (ISFLAGSET(pStatus->dwFlags, GSF_SUBSCRIBED))
                {
                    // Its SubScribed
                    FLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED);
                }

                // Try to find the folder in the list of files
                for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
                {
                    // Find the Sublist for this group
                    if (pCurrent->fMigrate && FILE_IS_NEWS_MESSAGES == pCurrent->tyFile && lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
                    {
                        // Correct file name
                        if (lstrcmpi(pszGroup, pCurrent->szFolder) == 0)
                        {
                            // Get the File Name
                            _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);

                            // Format the original file name
                            wsprintf(szSrcFile, "%s%s", szFile, szExt);

                            // Set the File Path
                            Folder.pszFile = szSrcFile;

                            // Set Folder Counts
                            Folder.cMessages = pCurrent->cMessages;
                            Folder.cUnread = pCurrent->cUnread;

                            // FixupFolderUserData(
                            FixupFolderUserData(pSession, Folder.idFolder, pszGroup, FOLDER_NOTSPECIAL, pCurrent);

                            // Done
                            break;
                        }
                    }
                }

                // Update the Record
                pStore->UpdateRecord(&Folder);

                // Free This
                pStore->FreeRecord(&Folder);
            }

            // Bump Progress
            if(!g_fQuiet)
                IncrementProgress(pProgress, pSubList);
        }
    }

    // SUBFILE_VERSION3
    else if (SUBFILE_VERSION3 == pSubListHeader->dwVersion)
    {
        Assert(FALSE);
    }

    // SUBFILE_VERSION2
    else if (SUBFILE_VERSION2 == pSubListHeader->dwVersion)
    {
        Assert(FALSE);
    }

exit:
    // Close the File
    CloseMemoryFile(&File);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// BuildUnifiedFolderManager
// --------------------------------------------------------------------------------
HRESULT BuildUnifiedFolderManager(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFILEINFO pHeadFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    LPFILEINFO          pCurrent;

    // Trace
    TraceCall("BuildUnifiedFolderManager");

    // Walk through the list of files and merge the folders, sublist, group lists into pFolder
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Handle Folders Type
        if (FILE_IS_LOCAL_FOLDERS == pCurrent->tyFile)
        {
            // Merge Local Folder Cache into new Folder Manager
            IF_FAILEXIT(hr = MergeFolderCacheIntoStore(pSession, pStore, pCurrent, pHeadFile, pProgress));
        }

        // IMAP Folder
        else if (FILE_IS_IMAP_FOLDERS == pCurrent->tyFile)
        {
            // Merge IMAP Folder Cache into new Folder Manager
            IF_FAILEXIT(hr = MergeFolderCacheIntoStore(pSession, pStore, pCurrent, pHeadFile, pProgress));
        }

        // News Group List
        else if (FILE_IS_NEWS_GRPLIST == pCurrent->tyFile)
        {
            // Merge IMAP Folder Cache into new Folder Manager
            IF_FAILEXIT(hr = MergeNewsGroupList(pSession, pStore, pCurrent, pHeadFile, pProgress));
        }
    }

    // Walk through any files that were not merged into the store
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Find the Sublist for this group
        if (TRUE == pCurrent->fMigrate && FALSE == pCurrent->fInStore)
        {
            // Local Message File...
            if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
            {
                // Locals
                FLDINFO         Folder={0};
                SPECIALFOLDER   tySpecial;
                CHAR            szFolder[255];
                CHAR            szPath[_MAX_PATH];
                CHAR            szDrive[_MAX_DRIVE];
                CHAR            szDir[_MAX_DIR];
                CHAR            szFile[_MAX_FNAME];
                CHAR            szExt[_MAX_EXT];

                // Get Special Folder Info
                GetSpecialFolderInfo(pCurrent->szFilePath, szFolder, ARRAYSIZE(szFolder), &Folder.tySpecial);

                // Special Case for News Special Folders from v1
                if (0xffffffff == Folder.tySpecial && strstr(szFolder, "special folders") != NULL)
                {
                    // Locals
                    CHAR szRes[255];

                    // News Outbox
                    LoadString(g_hInst, IDS_POSTEDITEMS, szRes, ARRAYSIZE(szRes));

                    // Contains "Posted Items"
                    if (strstr(szFolder, szRes) != NULL)
                        LoadString(g_hInst, IDS_NEWSPOSTED, szFolder, ARRAYSIZE(szFolder));

                    // Contains "Saved Items"
                    else
                    {
                        // News Saved Items
                        LoadString(g_hInst, IDS_SAVEDITEMS, szRes, ARRAYSIZE(szRes));

                        // Contains "Saved Items"
                        if (strstr(szFolder, szRes) != NULL)
                            LoadString(g_hInst, IDS_NEWSSAVED, szFolder, ARRAYSIZE(szFolder));

                        // Otherwise
                        else
                        {
                            // News Outbox
                            LoadString(g_hInst, IDS_OUTBOX, szRes, ARRAYSIZE(szRes));

                            // Contains Outbox
                            if (strstr(szFolder, szRes) != NULL)
                                LoadString(g_hInst, IDS_NEWSOUTBOX, szFolder, ARRAYSIZE(szFolder));
                        }
                    }
                }

                // Compute the File Name
                _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);
                wsprintf(Folder.szFile, "%s.dbx", szFile);

                // Set the Name
                if ('\0' != *pCurrent->szFolder)
                    lstrcpyn(Folder.szFolder, pCurrent->szFolder, ARRAYSIZE(Folder.szFolder));
                else if ('\0' != *szFolder)
                    lstrcpyn(Folder.szFolder, szFolder, ARRAYSIZE(Folder.szFolder));
                else
                    lstrcpyn(Folder.szFolder, szFile, ARRAYSIZE(Folder.szFolder));

                // Set Message and Unread Count
                Folder.cMessages = pCurrent->cMessages;
                Folder.cUnread = pCurrent->cUnread;

                // Insert into Local Store
                InsertFolderIntoStore(pSession, pStore, &Folder, 0, NULL, FOLDERID_LOCAL_STORE, NULL, NULL, (LPFOLDERID)&Folder.idFolder);

                // Fixup special
                tySpecial = (Folder.tySpecial == 0xffffffff) ? FOLDER_NOTSPECIAL : (BYTE)(Folder.tySpecial + 1);

                // Update the Folder's UserData
                FixupFolderUserData(pSession, (FOLDERID)IntToPtr(Folder.idFolder), Folder.szFolder, tySpecial, pCurrent);
            }

            // Otherwise, just delete the file
            else if (FILE_IS_POP3UIDL != pCurrent->tyFile)
                DeleteFile(pCurrent->szDstFile);
        }
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupMessageStore
// --------------------------------------------------------------------------------
HRESULT CleanupMessageStore(LPCSTR pszStoreRoot, IMessageStore *pStore)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    HROWSET         hRowset=NULL;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("CleanupMessageStore");

    // Create a Rowset
    IF_FAILEXIT(hr = pStore->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk the Rowset
    while(S_OK == pStore->QueryRowset(hRowset, 1, (LPVOID *)&Folder, NULL))
    {
        // If it has a file and no messags.
        if (Folder.pszFile && 0 == Folder.cMessages)
        {
            // Delete the file...
            IF_FAILEXIT(hr = MakeFilePath(pszStoreRoot, Folder.pszFile, "", szFilePath, ARRAYSIZE(szFilePath)));

            // Delete the File
            DeleteFile(szFilePath);

            // Reset the filename
            Folder.pszFile = NULL;

            // Update the Record
            IF_FAILEXIT(hr = pStore->UpdateRecord(&Folder));
        }

        // Otherwise, if there is a file, force a folder rename
        else if (Folder.pszFile)
        {
            // Rename the folder
            pStore->RenameFolder(Folder.idFolder, Folder.pszName, 0, NULL);
        }

        // Cleanup
        pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    pStore->FreeRecord(&Folder);
    pStore->CloseRowset(&hRowset);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// UpgradeV5
// --------------------------------------------------------------------------------
HRESULT UpgradeV5(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreSrc, LPCSTR pszStoreDst,
    LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    ENUMFILEINFO    EnumInfo;
    LPFILEINFO      pCurrent;
    DWORD           cbNeeded;
    DWORDLONG       dwlFree;
    BOOL            fContinue;
    CHAR            szFolders[MAX_PATH + MAX_PATH];
    CHAR            szMsg[512];
    IMessageStore  *pStore=NULL;
    IDatabaseSession *pSession=NULL;

    // Trace
    TraceCall("UpgradeV5");

    // Initialize
    *ppHeadFile = NULL;

    // Setup the EnumFile Info
    ZeroMemory(&EnumInfo, sizeof(ENUMFILEINFO));
    EnumInfo.pszExt = ".nch";
    EnumInfo.pszFoldFile = "folders.nch";
    EnumInfo.pszUidlFile = "pop3uidl.dat";
    EnumInfo.pszSubList = "sublist.dat";
    EnumInfo.pszGrpList = "grplist.dat";
    EnumInfo.fFindV1News = TRUE;

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreSrc, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Setup the EnumFile Info
    ZeroMemory(&EnumInfo, sizeof(ENUMFILEINFO));
    EnumInfo.pszExt = ".mbx";
    EnumInfo.pszFoldFile = NULL;
    EnumInfo.pszUidlFile = NULL;

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreSrc, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Nothing to upgrade
    if (NULL == *ppHeadFile)
        goto exit;

    // Compute some Counts, and validate that the files are valid to migrate...
    IF_FAILEXIT(hr = UpgradeProcessFileListV5(pszStoreSrc, pszStoreDst, *ppHeadFile, &pProgress->cMax, &cbNeeded));

    // Message
    LoadString(g_hInst, IDS_UPGRADEMESSAGE, szMsg, ARRAYSIZE(szMsg));

    // Message
    if(!g_fQuiet)           
        MigrateMessageBox(szMsg, MB_OK | MB_ICONINFORMATION | MB_SETFOREGROUND);

    // Delete fles
    UpgradeDeleteFilesV5(pszStoreDst);

    // Create an Ojbect Database
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&pSession));

    // Create an Ojbect Database
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_MigrateMessageStore, NULL, CLSCTX_INPROC_SERVER, IID_IMessageStore, (LPVOID *)&pStore));

    // Build the Folders.odb File Path
    wsprintf(szFolders, "%s\\folders.dbx", pszStoreDst);

    // Delete It First
    DeleteFile(szFolders);

    // Initialize the Store
    IF_FAILEXIT(hr = pStore->Initialize(pszStoreDst));

    // Initialize the Store
    IF_FAILEXIT(hr = pStore->Validate(0));

    // Enought DiskSpace ?
    IF_FAILEXIT(hr = GetAvailableDiskSpace(pszStoreDst, &dwlFree));

    // Not Enought Diskspace
    if (((DWORDLONG) cbNeeded) > dwlFree)
    {
        // cbNeeded is DWORD and in this case we can downgrade dwlFree to DWORD
        g_cbDiskNeeded = cbNeeded; g_cbDiskFree = ((DWORD) dwlFree);
        hr = TraceResult(MIGRATE_E_NOTENOUGHDISKSPACE);
        goto exit;
    }

    // Loop through the files and migrate each one
    for (pCurrent=*ppHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Migrate this file ?
        if (pCurrent->fMigrate)
        {
            // Set Progress File
            SetProgressFile(pProgress, pCurrent);

            // Assume we will continue
            fContinue = FALSE;

            // Downgrade the file
            hr = pCurrent->hrMigrate = UpgradeFileV5(pSession, tyMigrate, pCurrent, pProgress, &fContinue);

            // Failure ?
            if (FAILED(pCurrent->hrMigrate))
            {
                // Set Last Error
                pCurrent->dwLastError = GetLastError();

                // Stop 
                if (FALSE == fContinue)
                    break;

                if(!g_fQuiet) {
                    // Fixup the progress
                    while (pCurrent->cProgCur < pCurrent->cProgMax)
                    {
                        IncrementProgress(pProgress, pCurrent);
                    }
                }

                // We are ok
                hr = S_OK;
            }
        }
    }

    // Process Folder Lists
    hr = BuildUnifiedFolderManager(pSession, pStore, *ppHeadFile, pProgress);

    // Failure, delete all destination files
    if (FAILED(hr))
    {
        // Delete fles
        UpgradeDeleteFilesV5(pszStoreDst);
    }

    // Otherwise, lets force a folder rename to build friendly file names
    else
    {
        // Rename all the folders...
        CleanupMessageStore(pszStoreDst, pStore);
    }

#if 0
    // Otherwise, delete source files
    else
    {
        // Delete all source files
        UpgradeDeleteIdxMbxNchDatFilesV5(*ppHeadFile);
    }
#endif

exit:
    // Cleanup
    SafeRelease(pStore);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\utility.cpp ===
// --------------------------------------------------------------------------------
// Utility.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "migrate.h"
#include "migerror.h"
#include "utility.h"
#include "resource.h"
#include <shared.h>

extern BOOL g_fQuiet;

/*
 *  CenterDialog
 *
 *  Purpose:
 *      This function centers a dialog with respect to its parent
 *      dialog.
 *
 *  Parameters:
 *      hwndDlg     hwnd of the dialog to center
 */
VOID CenterDialog(HWND hwndDlg)
{
    HWND    hwndOwner;
    RECT    rc;
    RECT    rcDlg;
    RECT    rcOwner;
    RECT    rcWork;
    INT     x;
    INT     y;
    INT     nAdjust;

    // Get the working area rectangle
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

    // Get the owner window and dialog box rectangles.
    //  The window rect of the destop window is in trouble on multimonitored
    //  macs. GetWindow only gets the main screen.
    if (hwndOwner = GetParent(hwndDlg))
        GetWindowRect(hwndOwner, &rcOwner);
    else
        rcOwner = rcWork;

    GetWindowRect(hwndDlg, &rcDlg);
    rc = rcOwner;

    // Offset the owner and dialog box rectangles so that
    // right and bottom values represent the width and
    // height, and then offset the owner again to discard
    // space taken up by the dialog box.
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
    OffsetRect(&rc, -rc.left, -rc.top);
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

    // The new position is the sum of half the remaining
    // space and the owner's original position.
    // But not less than Zero - jefbai

    x= rcOwner.left + (rc.right / 2);
    y= rcOwner.top + (rc.bottom / 2);

    // Make sure the dialog doesn't go off the right edge of the screen
    nAdjust = rcWork.right - (x + rcDlg.right);
    if (nAdjust < 0)
        x += nAdjust;

    //$ Raid 5128: Make sure the left edge is visible
    if (x < rcWork.left)
        x = rcWork.left;

    // Make sure the dialog doesn't go off the bottom edge of the screen
    nAdjust = rcWork.bottom - (y + rcDlg.bottom);
    if (nAdjust < 0)
        y += nAdjust;

    //$ Raid 5128: Make sure the top edge is visible
    if (y < rcWork.top)
        y = rcWork.top;
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

// --------------------------------------------------------------------------------
// StrFormatByteSize64A
// --------------------------------------------------------------------------------
#define WHOLENUM_LEN 30
#define LODWORD(_qw)    (DWORD)(_qw)
const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, 
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

// takes a DWORD add commas etc to it and puts the result in the buffer
LPSTR CommifyString(DWORD dw, LPSTR pszResult, UINT cchBuf)
{
    char  szTemp[30];
    char  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits = 0;
    nfmt.LeadingZero = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = atoi(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder = 0;

    wsprintf(szTemp, TEXT("%lu"), dw);


    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt,pszResult, ARRAYSIZE(szTemp)) == 0)
        lstrcpyn(pszResult, szTemp, cchBuf);

    return pszResult;
}

LPSTR StrFormatByteSize64A(LONGLONG dw64, LPSTR pszBuf, UINT cchBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    char szWholeNum[WHOLENUM_LEN];  // To store the number.. "234"
    char szOrder[16];               // The resource string .."%s bytes"
    char szFormat[8];               // format for the decimal
    char szScratch[32];              // 32 should be plenty - for the whole string

    // If the size is less than 1024, then the order should be bytes we have nothing
    // more to figure out
    if (dw64 < 1024) {
        wsprintf(szWholeNum, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    // Find the right order
    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    CommifyString(wInt, szWholeNum, ARRAYSIZE(szWholeNum));
    wLen = lstrlen(szWholeNum);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = TEXT('0') + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                      szWholeNum+wLen, ARRAYSIZE(szWholeNum)-wLen);
        wLen = lstrlen(szWholeNum);
        wLen += wsprintf(szWholeNum+wLen, szFormat, wDec);
    }

AddOrder:

    LoadString(g_hInst, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szScratch, szOrder, szWholeNum);
    lstrcpyn(pszBuf, szScratch, cchBuf);
    return pszBuf;
}

// --------------------------------------------------------------------------------
// MapDataDirToAcctId
// --------------------------------------------------------------------------------
HRESULT MapDataDirToAcctId(DWORD dwServer, LPCSTR pszSubDir, LPSTR pszAcctId)
{
    // Locals
    LPACCOUNTINFO   pAccount;
    DWORD           i;

    // Trace
    TraceCall("MapDataDirToAcctId");

    // Set Account Id
    for (i=0; i<g_AcctTable.cAccounts; i++)
    {
        // Redability
        pAccount = &g_AcctTable.prgAccount[i];

        // Looking for News Servers
        if (ISFLAGSET(pAccount->dwServer, dwServer))
        {
            // Same Sub directory
            if (lstrcmpi(pAccount->szDataDir, pszSubDir) == 0)
            {
                // Set Account Id
                lstrcpy(pszAcctId, pAccount->szAcctId);

                // Done
                return(S_OK);
            }
        }
    }

    // Done
    return(E_FAIL);
}

// --------------------------------------------------------------------------------
// EnumerateStoreFiles
// --------------------------------------------------------------------------------
HRESULT EnumerateStoreFiles(LPCSTR pszPath, DIRTYPE tyDir, LPCSTR pszSubDir, 
    LPENUMFILEINFO pEnumInfo, LPFILEINFO *ppHead)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szFullPath[MAX_PATH + MAX_PATH];
    CHAR            szSearch[MAX_PATH + MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE          hFind=INVALID_HANDLE_VALUE;
    DWORD           i;
    LPACCOUNTINFO   pAccount;
    LPFILEINFO      pNew=NULL;

    // Trace
    TraceCall("EnumerateStoreFiles");

    // Invalid Args
    Assert(pszPath && pEnumInfo && pEnumInfo->pszExt && pEnumInfo->pszExt[0] == '.' && ppHead);

    // Build Base Path
    if (pszSubDir)
        wsprintf(szFullPath, "%s\\%s", pszPath, pszSubDir);
    else
        lstrcpyn(szFullPath, pszPath, ARRAYSIZE(szFullPath));

    // Do we have a sub dir
    wsprintf(szSearch, "%s\\*.*", szFullPath);

    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    while(1)
    {
        // If this is not a directory
        if (ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        {
            // Not . and not ..
            if (lstrcmpi(fd.cFileName, ".") != 0 && lstrcmpi(fd.cFileName, "..") != 0)
            {
                // Default Dirtype
                DIRTYPE tyDirNew=tyDir;

                // Decide new dir type
                if (lstrcmpi(fd.cFileName, "mail") == 0)
                    tyDirNew = DIR_IS_LOCAL;
                else if (lstrcmpi(fd.cFileName, "news") == 0)
                    tyDirNew = DIR_IS_NEWS;
                else if (lstrcmpi(fd.cFileName, "imap") == 0)
                    tyDirNew = DIR_IS_IMAP;

                // Recursive...
                IF_FAILEXIT(hr = EnumerateStoreFiles(szFullPath, tyDirNew, fd.cFileName, pEnumInfo, ppHead));
            }
        }

        // Otherwise... don't enumerate any files in the root directory...
        else if (DIR_IS_ROOT != tyDir)
        {
            // Locals
            BOOL    fIsFile=FALSE;
            CHAR    szPath[_MAX_PATH];
            CHAR    szDrive[_MAX_DRIVE];
            CHAR    szDir[_MAX_DIR];
            CHAR    szFile[_MAX_FNAME];
            CHAR    szExt[_MAX_EXT];

            // Split the Path
            _splitpath(fd.cFileName, szDrive, szDir, szFile, szExt);
   
            // Extension I'm looking for ?
            if ('\0' != *szExt)
            {
                // Ext1
                if (lstrcmpi(pEnumInfo->pszExt, szExt) == 0)
                    fIsFile = TRUE;

                // FoldFile
                if (pEnumInfo->pszFoldFile && lstrcmpi(pEnumInfo->pszFoldFile, fd.cFileName) == 0)
                    fIsFile = TRUE;

                // UidlFile
                if (pEnumInfo->pszUidlFile && lstrcmpi(pEnumInfo->pszUidlFile, fd.cFileName) == 0)
                    fIsFile = TRUE;

                // SubList
                if (pEnumInfo->pszSubList && lstrcmpi(pEnumInfo->pszSubList, fd.cFileName) == 0)
                    fIsFile = TRUE;

                // GrpList
                if (pEnumInfo->pszGrpList && lstrcmpi(pEnumInfo->pszGrpList, fd.cFileName) == 0)
                    fIsFile = TRUE;
            }

            // If Not is file, and caller wants to look for v1 news and I'm in the news directory
            if (FALSE == fIsFile && TRUE == pEnumInfo->fFindV1News && DIR_IS_NEWS == tyDir)
            {
                // If this is a .dat file or a .sub file
                if (lstrcmpi(szExt, ".dat") == 0)
                    fIsFile = TRUE;

                // .sub file
                else if (lstrcmpi(szExt, ".sub") == 0)
                    fIsFile = TRUE;
            }

            // Is File
            if (fIsFile)
            {
                // Allocate a FileInfo
                IF_NULLEXIT(pNew = (LPFILEINFO)g_pMalloc->Alloc(sizeof(FILEINFO)));

                // Zero alloc
                ZeroMemory(pNew, sizeof(FILEINFO));

                // Determine File Type
                if (DIR_IS_LOCAL == tyDir)
                {
                    // Default file type
                    pNew->tyFile = FILE_IS_LOCAL_MESSAGES;

                    // Set Server Type
                    pNew->dwServer = SRV_POP3;

                    // Set Account Id
                    lstrcpy(pNew->szAcctId, "LocalStore");

                    // Folders
                    if (pEnumInfo->pszFoldFile && lstrcmpi(pEnumInfo->pszFoldFile, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_LOCAL_FOLDERS;

                    // pop3uidl
                    else if (pEnumInfo->pszUidlFile && lstrcmpi(pEnumInfo->pszUidlFile, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_POP3UIDL;
                }
                
                // News
                else if (DIR_IS_NEWS == tyDir)
                {
                    // Default file type
                    pNew->tyFile = FILE_IS_NEWS_MESSAGES;

                    // Set Server Type
                    pNew->dwServer = SRV_NNTP;

                    // Map to An Account Id
                    MapDataDirToAcctId(SRV_NNTP, pszSubDir, pNew->szAcctId);

                    // sublist.dat
                    if (pEnumInfo->pszSubList && lstrcmpi(pEnumInfo->pszSubList, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_NEWS_SUBLIST;

                    // grplist.dat
                    else if (pEnumInfo->pszGrpList && lstrcmpi(pEnumInfo->pszGrpList, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_NEWS_GRPLIST;

                    // If this is a .dat file or a .sub file
                    else if (pEnumInfo->fFindV1News)
                    {
                        // Group List
                        if (lstrcmpi(szExt, ".dat") == 0)
                            pNew->tyFile = FILE_IS_NEWS_GRPLIST;
    
                        // .sub file
                        else if (lstrcmpi(szExt, ".sub") == 0)
                            pNew->tyFile = FILE_IS_NEWS_SUBLIST;

                        // Try to find the Account (szFile should equal the server name)
                        for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
                        {
                            // Is this the Account
                            if (lstrcmpi(g_AcctTable.prgAccount[i].szServer, szFile) == 0)
                            {
                                lstrcpy(pNew->szAcctId, g_AcctTable.prgAccount[i].szAcctId);
                                break;
                            }
                        }
                    }
                }

                // IMAP
                else if (DIR_IS_IMAP == tyDir)
                {
                    // Default file type
                    pNew->tyFile = FILE_IS_IMAP_MESSAGES;

                    // Set Server Type
                    pNew->dwServer = SRV_IMAP;

                    // Map to An Account Id
                    MapDataDirToAcctId(SRV_IMAP, pszSubDir, pNew->szAcctId);

                    // Folders
                    if (pEnumInfo->pszFoldFile && lstrcmpi(pEnumInfo->pszFoldFile, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_IMAP_FOLDERS;
                }

                // Format the filename
                wsprintf(pNew->szFilePath, "%s\\%s", szFullPath, fd.cFileName);

                // Trace This
                TraceInfo(_MSG("MigFile: %s", pNew->szFilePath));

                // Link It In
                pNew->pNext = (*ppHead);

                // Set ppHead
                *ppHead = pNew;

                // Don't Free pNew
                pNew = NULL;
            }
        }

        // Find the Next File
        if (!FindNextFile(hFind, &fd))
            break;
    }

exit:
    // Cleanup
    SafeMemFree(pNew);
    if (hFind)
        FindClose(hFind);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// FreeFileList
// --------------------------------------------------------------------------------
HRESULT FreeFileList(LPFILEINFO *ppHead)
{
    // Locals
    LPFILEINFO pCurrent=(*ppHead);
    LPFILEINFO pNext;

    // Loop
    while (pCurrent)
    {
        // Save Next
        pNext = pCurrent->pNext;

        // Free Current
        g_pMalloc->Free(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MigrageDlgProc
// --------------------------------------------------------------------------------
BOOL CALLBACK MigrageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Trace
    TraceCall("MigrageDlgProc");

    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return TRUE;
    }

    // Done
    return 0;
}

// --------------------------------------------------------------------------------
// InitializeCounters
// --------------------------------------------------------------------------------
void InitializeCounters(LPMEMORYFILE pFile, LPFILEINFO pInfo, LPDWORD pcMax, 
    LPDWORD pcbNeeded, BOOL fInflate)
{
    // Increment pcMax
    (*pcMax) += pFile->cbSize;

    // Save Size
    pInfo->cbFile = pFile->cbSize;

    // Set Progress Max
    pInfo->cProgMax = pFile->cbSize;

    // Set cProgInc
    pInfo->cProgInc = pInfo->cRecords > 0 ? (pFile->cbSize / pInfo->cRecords) : pFile->cbSize;

    // Increment pcbNeeded
    (*pcbNeeded) += pInfo->cbFile;

    // Assume the file will be 8% bigger
    if (fInflate)
        (*pcbNeeded) += ((pInfo->cbFile * 8) / 100);
}

// --------------------------------------------------------------------------------
// IncrementProgress
// --------------------------------------------------------------------------------
void IncrementProgress(LPPROGRESSINFO pProgress, LPFILEINFO pInfo)
{
    // Locals
    MSG                 msg;
    ULARGE_INTEGER      uliCurrent;
    ULARGE_INTEGER      uliMax;

    // Trace
    TraceCall("IncrementProgress");

    // Increment
    pProgress->cCurrent += pInfo->cProgInc;

    // Increment per-file progress
    pInfo->cProgCur += pInfo->cProgInc;

    // If cur is now larget than max ?
    if (pProgress->cCurrent > pProgress->cMax)
        pProgress->cCurrent = pProgress->cMax;

    // Set 64
    uliCurrent.QuadPart = pProgress->cCurrent;
    uliMax.QuadPart = pProgress->cMax;

    // Compute percent
    DWORD cPercent = (DWORD)((uliCurrent.QuadPart) * 100 / uliMax.QuadPart);

    // Change
    if (cPercent != pProgress->cPercent)
    {
        // Locals
        CHAR    szRes[50];
        CHAR    szProgress[50];

        // Save It
        pProgress->cPercent = cPercent;

        // Load the String
        LoadString(g_hInst, IDS_COMPLETE, szRes, ARRAYSIZE(szRes));

        // Update status
        if(!g_fQuiet)
            SendMessage(GetDlgItem(pProgress->hwndProgress, IDC_PROGRESS), PBM_SETPOS, pProgress->cPercent, 0);

        // Format
        wsprintf(szProgress, szRes, cPercent);

        // Update Description...
        if(!g_fQuiet)
            SetDlgItemText(pProgress->hwndProgress, IDS_STATUS, szProgress);
    }

    // Pump messages until current cycle is complete
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (!IsDialogMessage(pProgress->hwndProgress, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}

// --------------------------------------------------------------------------------
// SetProgressFile
// --------------------------------------------------------------------------------
void SetProgressFile(LPPROGRESSINFO pProgress, LPFILEINFO pInfo)
{
    // Locals
    CHAR            szRes[255];
    CHAR            szMsg[255 + MAX_PATH + MAX_PATH];
    CHAR            szScratch[50];

    // Load String
    LoadString(g_hInst, IDS_MIGRATING, szRes, ARRAYSIZE(szRes));

    // Format the String
    wsprintf(szMsg, szRes, pInfo->szFilePath, StrFormatByteSize64A(pInfo->cbFile, szScratch, ARRAYSIZE(szScratch)));

    // Update Description...
    if(!g_fQuiet)
        SetDlgItemText(pProgress->hwndProgress, IDS_DESCRIPT, szMsg);
}

// --------------------------------------------------------------------------------
// WriteMigrationLogFile
// --------------------------------------------------------------------------------
HRESULT WriteMigrationLogFile(HRESULT hrMigrate, DWORD dwLastError, 
    LPCSTR pszStoreRoot, LPCSTR pszMigrate, LPCSTR pszCmdLine, LPFILEINFO pHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    HANDLE          hFile=NULL;
    DWORD           cbFile;
    CHAR            szWrite[2024];
    DWORD           cbWrote;
    CHAR            szLogFile[MAX_PATH];
    SYSTEMTIME      st;
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("WriteMigrationLogFile");

    // Invalid Args
    Assert(pszStoreRoot && pszCmdLine);

    // File name too long....
    wsprintf(szLogFile, "%s\\%s.log", pszStoreRoot, pszMigrate);

    // Open the File
    hFile = CreateFile(szLogFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);

    // Failure
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hFile = NULL;
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Get the Size
    cbFile = ::GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbFile)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // If file is getting kind of large
    if (cbFile >=  102400)
    {
        // Seek to the end of the file...
        if (0xffffffff == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        {
            hr = TraceResult(MIGRATE_E_CANTSETFILEPOINTER);
            goto exit;
        }

        // Set End Of File
        if (0 == SetEndOfFile(hFile))
        {
            hr = TraceResult(MIGRATE_E_CANTSETENDOFFILE);
            goto exit;
        }
    }

    // Seek to the end of the file...
    if (0xffffffff == SetFilePointer(hFile, 0, NULL, FILE_END))
    {
        hr = TraceResult(MIGRATE_E_CANTSETFILEPOINTER);
        goto exit;
    }

    // add a new line
    if (!WriteFile(hFile, pszCmdLine, lstrlen(pszCmdLine), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // add a new line
    if (!WriteFile(hFile, "\r\n", lstrlen("\r\n"), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // Write the Date
    GetLocalTime(&st);

    // Build the string
    wsprintf(szWrite, "Date: %.2d/%.2d/%.4d %.2d:%.2d:%.2d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

    // add a new line
    if (!WriteFile(hFile, szWrite, lstrlen(szWrite), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // Set Text
    wsprintf(szWrite, "Store Root: %s\r\nGlobal Migrate Result: HRESULT = 0x%08X, GetLastError() = %d\r\n\r\n", pszStoreRoot, hrMigrate, dwLastError);

    // Write Store Root
    if (!WriteFile(hFile, szWrite, lstrlen(szWrite), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // Loop through the files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Format the string
        wsprintf(szWrite, "cbFile: %012d, cRecords: %08d, fMigrate: %d, hrMigrate: 0x%08X, GetLastError(): %05d, File: %s\r\n", 
            pCurrent->cbFile, pCurrent->cRecords, pCurrent->fMigrate, pCurrent->hrMigrate, pCurrent->dwLastError, pCurrent->szFilePath);

        // Write Store Root
        if (!WriteFile(hFile, szWrite, lstrlen(szWrite), &cbWrote, NULL))
        {
            hr = TraceResult(MIGRATE_E_WRITEFILE);
            goto exit;
        }
    }

    // Write Store Root
    if (!WriteFile(hFile, "\r\n\r\n", lstrlen("\r\n\r\n"), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

exit:
    // Close the file
    if (hFile)
        CloseHandle(hFile);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// BlobReadData
// --------------------------------------------------------------------------------
HRESULT BlobReadData(LPBYTE lpbBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData)
{
    // Check Parameters
    AssertSz(lpbBlob && cbBlob > 0 && pib && cbData > 0 && lpbData, "Bad Parameter");
    AssertReadWritePtr(lpbBlob, cbData);
    AssertReadWritePtr(lpbData, cbData);
    AssertSz(*pib + cbData <= cbBlob, "Blob overflow");

    // Copy Data Data
    CopyMemory (lpbData, lpbBlob + (*pib), cbData);
    *pib += cbData;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// ReplaceExtension
// --------------------------------------------------------------------------------
void ReplaceExtension(LPCSTR pszFilePath, LPCSTR pszExtNew, LPSTR pszFilePathNew)
{
    // Locals
    CHAR szPath[_MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szFile[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];

    // Trace
    TraceCall("ReplaceExtension");

    // Split the Path
    _splitpath(pszFilePath, szDrive, szDir, szFile, szExt);

    // Build New File Path
    wsprintf(pszFilePathNew, "%s%s%s%s", szDrive, szDir, szFile, pszExtNew);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// GetAvailableDiskSpace
// --------------------------------------------------------------------------------
HRESULT GetAvailableDiskSpace(LPCSTR pszFilePath, DWORDLONG *pdwlFree)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szDrive[5];
    DWORD       dwSectorsPerCluster;
    DWORD       dwBytesPerSector;
    DWORD       dwNumberOfFreeClusters;
    DWORD       dwTotalNumberOfClusters;

    // Trace
    TraceCall("GetAvailableDiskSpace");

    // Invalid Args
    Assert(pszFilePath && pszFilePath[1] == ':' && pdwlFree);

    // Split the path
    szDrive[0] = *pszFilePath;
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = '\0';
    
    // Get free disk space - if it fails, lets pray we have enought disk space
    if (!GetDiskFreeSpace(szDrive, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Return Amount of Free Disk Space
    *pdwlFree = (dwNumberOfFreeClusters * (dwSectorsPerCluster * dwBytesPerSector));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MyWriteFile
// --------------------------------------------------------------------------------
HRESULT MyWriteFile(HANDLE hFile, DWORD faAddress, LPVOID pData, DWORD cbData)
{  
    // Locals
    DWORD cbWrote;

    // Trace
    TraceCall("MyWriteFile");

    // Seek to the end of the file...
    if (0xffffffff == SetFilePointer(hFile, faAddress, NULL, FILE_BEGIN))
        return TraceResult(MIGRATE_E_CANTSETFILEPOINTER);

    // Write file
    if (0 == WriteFile(hFile, pData, cbData, &cbWrote, NULL))
        return TraceResult(MIGRATE_E_WRITEFILE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MigrateMessageBox
// --------------------------------------------------------------------------------
UINT MigrateMessageBox(LPCSTR pszMsg, UINT uType)
{
    // Locals
    CHAR        szTitle[100];

    // Load title
    LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));

    // MessageBox
    return MessageBox(NULL, pszMsg, szTitle, uType);
}

// --------------------------------------------------------------------------------
// CreateAccountDirectory
// --------------------------------------------------------------------------------
HRESULT CreateAccountDirectory(LPCSTR pszStoreRoot, LPCSTR pszBase, DWORD iAccount,
    LPSTR pszPath)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szDir[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("CreateAccountDirectory");

    // Loop
    while(1)
    {
        // Format the path
        wsprintf(pszPath, "Acct%04d", iAccount);

        // Format the Path
        wsprintf(szDir, "%s\\%s\\%s", pszStoreRoot, pszBase, pszPath);

        // Create the Directory
        if (CreateDirectory(szDir, NULL))
            break;

        // If not already exists, failure
        if (ERROR_ALREADY_EXISTS != GetLastError())
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Try Again
        iAccount++;
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// BuildAccountTable
// --------------------------------------------------------------------------------
HRESULT BuildAccountTable(HKEY hkeyBase, LPCSTR pszRegRoot, LPCSTR pszStoreRoot,
    LPACCOUNTTABLE pTable)
{
    // Locals
    HRESULT         hr=S_OK;
    HKEY            hkeyRoot=NULL;
    HKEY            hkeyAcct=NULL;
    DWORD           i;
    DWORD           cb;
    DWORD           cAccounts=0;
    DWORD           dwType;
    LONG            lResult;
    LPACCOUNTINFO   pAccount;

    // Trace
    TraceCall("BuildAccountTable");

    // Validate Args
    Assert(hkeyBase && pszRegRoot && pTable);

    // Initialize
    ZeroMemory(pTable, sizeof(ACCOUNTTABLE));

    // Open the Root Key
    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyBase, pszRegRoot, 0, KEY_ALL_ACCESS, &hkeyRoot))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Enumerate keys
    if (ERROR_SUCCESS != RegQueryInfoKey(hkeyRoot, NULL, NULL, 0, &pTable->cAccounts, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Allocate the Account Array
    IF_NULLEXIT(pTable->prgAccount = (LPACCOUNTINFO)ZeroAllocate(sizeof(ACCOUNTINFO) * pTable->cAccounts));

    // Start Enumerating the keys
    for (i=0; i<pTable->cAccounts; i++)
    {
        // Close Current hkeyAcct
        if (hkeyAcct)
        {
            RegCloseKey(hkeyAcct);
            hkeyAcct = NULL;
        }

        // Readability
        pAccount = &pTable->prgAccount[cAccounts];

        // Set the size of the account id field
        cb = sizeof(pAccount->szAcctId);

        // Enum the Key Info
        lResult = RegEnumKeyEx(hkeyRoot, i, pAccount->szAcctId, &cb, 0, NULL, NULL, NULL);

        // No more items
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error, lets move onto the next account
        if (lResult != ERROR_SUCCESS)
        {
            Assert(FALSE);
            continue;
        }

        // Open the Account Key
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyRoot, pAccount->szAcctId, 0, KEY_ALL_ACCESS, &hkeyAcct))
        {
            Assert(FALSE);
            continue;
        }

        // Set Length of Field
        cb = sizeof(pAccount->szAcctName);

        // Query the Account Name
        if (ERROR_SUCCESS != RegQueryValueEx(hkeyAcct, "Account Name", NULL, &dwType, (LPBYTE)pAccount->szAcctName, &cb))
        {
            Assert(FALSE);
            continue;
        }

        // Set Length of field
        cb = sizeof(pAccount->szServer);

        // Try to determine the account type
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyAcct, "POP3 Server", NULL, &dwType, (LPBYTE)pAccount->szServer, &cb))
        {
            // Its a pop3 server
            pAccount->dwServer = SRV_POP3;

            // Set the Directory
            wsprintf(pAccount->szDirectory, "%s\\Mail", pszStoreRoot);
        }

        // Otherwise - NNTP
        else if (ERROR_SUCCESS == RegQueryValueEx(hkeyAcct, "NNTP Server", NULL, &dwType, (LPBYTE)pAccount->szServer, &cb))
        {
            // Its an nntp account
            pAccount->dwServer = SRV_NNTP;

            // Set length of the field
            cb = sizeof(pAccount->szDataDir);

            // Query the Data Directory
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyAcct, "NNTP Data Directory", NULL, &dwType, (LPBYTE)pAccount->szDataDir, &cb))
            {
                // CreateAccountDirectory
                if (FAILED(CreateAccountDirectory(pszStoreRoot, "News", i, pAccount->szDataDir)))
                    continue;

                // Set the Data Directory
                if (ERROR_SUCCESS != RegSetValueEx(hkeyAcct, "NNTP Data Directory", 0, REG_SZ, (LPBYTE)pAccount->szDataDir, lstrlen(pAccount->szDataDir) + 1))
                    continue;
            }

            // Format the Directory
            wsprintf(pAccount->szDirectory, "%s\\News\\%s", pszStoreRoot, pAccount->szDataDir);
        }
        
        // Otherwise - IMAP
        else if (ERROR_SUCCESS == RegQueryValueEx(hkeyAcct, "IMAP Server", NULL, &dwType, (LPBYTE)pAccount->szServer, &cb))
        {
            // Its an IMAP Server
            pAccount->dwServer = SRV_IMAP;

            // Set length of the field
            cb = sizeof(pAccount->szDataDir);

            // Query the Data Directory
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyAcct, "IMAP Data Directory", NULL, &dwType, (LPBYTE)pAccount->szDataDir, &cb))
            {
                // CreateAccountDirectory
                if (FAILED(CreateAccountDirectory(pszStoreRoot, "IMAP", i, pAccount->szDataDir)))
                    continue;

                // Set the Data Directory
                if (ERROR_SUCCESS != RegSetValueEx(hkeyAcct, "IMAP Data Directory", 0, REG_SZ, (LPBYTE)pAccount->szDataDir, lstrlen(pAccount->szDataDir) + 1))
                    continue;
            }

            // Format the Directory
            wsprintf(pAccount->szDirectory, "%s\\IMAP\\%s", pszStoreRoot, pAccount->szDataDir);
        }

        // Othewise, skip the account
        else
            continue;

        // Make sure the directory exists
        if (0 == CreateDirectory(pAccount->szDirectory, NULL) && ERROR_ALREADY_EXISTS != GetLastError())
            continue;

        // Increment Valid Account Count
        cAccounts++;
    }

    // Set Actual Number of Accounts
    pTable->cAccounts = cAccounts;

exit:
    // Cleanup
    if (hkeyAcct)
        RegCloseKey(hkeyAcct);
    if (hkeyRoot)
        RegCloseKey(hkeyRoot);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\migrate\utility.h ===
// --------------------------------------------------------------------------------
// Utility.h
// --------------------------------------------------------------------------------
#ifndef __UTILITY_H
#define __UTILITY_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include <shared.h>

// --------------------------------------------------------------------------------
// DWORDALIGN
// --------------------------------------------------------------------------------
#define DWORDALIGN(_cb) ((_cb % 4 != 0) ? (_cb += (4 - (_cb % 4))) : _cb)

// --------------------------------------------------------------------------------
// DIRTYPE
// --------------------------------------------------------------------------------
typedef enum tagDIRTYPE {
    DIR_IS_ROOT,
    DIR_IS_LOCAL,
    DIR_IS_NEWS,
    DIR_IS_IMAP
} DIRTYPE;

// --------------------------------------------------------------------------------
// ACCOUNTINFO
// --------------------------------------------------------------------------------
typedef struct tagACCOUNTINFO *LPACCOUNTINFO;
typedef struct tagACCOUNTINFO {
    CHAR            szAcctId[CCHMAX_ACCOUNT_NAME];
    CHAR            szAcctName[CCHMAX_ACCOUNT_NAME];
    CHAR            szDirectory[MAX_PATH];
    CHAR            szDataDir[MAX_PATH];
    CHAR            szServer[CCHMAX_SERVER_NAME];
    DWORD           dwServer;
} ACCOUNTINFO;

// --------------------------------------------------------------------------------
// ACCOUNTTABLE
// --------------------------------------------------------------------------------
typedef struct tagACCOUNTTABLE {
    DWORD           cAccounts;
    LPACCOUNTINFO   prgAccount;
} ACCOUNTTABLE, *LPACCOUNTTABLE;

// --------------------------------------------------------------------------------
// FILETYPE
// --------------------------------------------------------------------------------
typedef enum tagFILETYPE {
    FILE_IS_LOCAL_MESSAGES,
    FILE_IS_NEWS_MESSAGES,
    FILE_IS_IMAP_MESSAGES,
    FILE_IS_POP3UIDL,
    FILE_IS_LOCAL_FOLDERS,
    FILE_IS_IMAP_FOLDERS,
    FILE_IS_NEWS_SUBLIST,
    FILE_IS_NEWS_GRPLIST
} FILETYPE;

// --------------------------------------------------------------------------------
// ENUMFILEINFO
// --------------------------------------------------------------------------------
typedef struct tagENUMFILEINFO {
    LPSTR           pszExt;
    LPSTR           pszFoldFile;
    LPSTR           pszUidlFile;
    LPSTR           pszSubList;
    LPSTR           pszGrpList;
    BOOL            fFindV1News;
} ENUMFILEINFO, *LPENUMFILEINFO;

// --------------------------------------------------------------------------------
// FILEINFO
// --------------------------------------------------------------------------------
typedef struct tagFILEINFO *LPFILEINFO;
typedef struct tagFILEINFO {
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    CHAR            szAcctId[CCHMAX_ACCOUNT_NAME];
    CHAR            szFolder[255];
    DWORD           fMigrate;
    HRESULT         hrMigrate;
    DWORD           dwLastError;
    DWORD           cbFile;
    DWORD           cRecords;
    DWORD           cProgInc;
    DWORD           cProgCur;
    DWORD           cProgMax;
    FILETYPE        tyFile;
    DWORD           dwServer;
    DWORD           idFolder;
    BOOL            fInStore;
    DWORD           cUnread;
    DWORD           cMessages;
    LPFILEINFO      pNext;
} FILEINFO;

// --------------------------------------------------------------------------------
// PROGRESSINFO
// --------------------------------------------------------------------------------
typedef struct tagPROGRESSINFO {
    HWND            hwndProgress;
    DWORD           cCurrent;
    DWORD           cMax;
    DWORD           cPercent;
} PROGRESSINFO, *LPPROGRESSINFO;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT EnumerateStoreFiles(LPCSTR pszPath, DIRTYPE tyDir, LPCSTR pszSubDir, LPENUMFILEINFO pEnumInfo, LPFILEINFO *ppHead);
HRESULT FreeFileList(LPFILEINFO *ppHead);
BOOL CALLBACK MigrageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void IncrementProgress(LPPROGRESSINFO pProgress, LPFILEINFO pInfo);
HRESULT WriteMigrationLogFile(HRESULT hrMigrate, DWORD dwLastError, LPCSTR pszStoreRoot, LPCSTR pszMigrate, LPCSTR pszCmdLine, LPFILEINFO pHeadFile);
HRESULT BlobReadData(LPBYTE lpbBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData);
HRESULT GetAvailableDiskSpace(LPCSTR pszFilePath, DWORDLONG *pdwlFree);
void ReplaceExtension(LPCSTR pszFilePath, LPCSTR pszExtNew, LPSTR pszFilePathNew);
HRESULT MyWriteFile(HANDLE hFile, DWORD faAddress, LPVOID pData, DWORD cbData);
void SetProgressFile(LPPROGRESSINFO pProgress, LPFILEINFO pInfo);
UINT MigrateMessageBox(LPCSTR pszMsg, UINT uType);
LPSTR StrFormatByteSize64A(LONGLONG dw64, LPSTR pszBuf, UINT cchBuf);
void InitializeCounters(LPMEMORYFILE pFile, LPFILEINFO pInfo, LPDWORD pcMax, LPDWORD pcbNeeded, BOOL fInflate);
HRESULT BuildAccountTable(HKEY hkeyBase, LPCSTR pszRegRoot,  LPCSTR pszStoreRoot, LPACCOUNTTABLE pAcctTbl);

#endif // __UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mirlib\mirport.h ===
/****************************** mirport.h **********************************\
* Module Name: mirport.h                                                   *
*                                                                          *
* This file contains imported definitions and function prototypes for      *
* the Right-To-Left (RTL) Mirroring support API (NT5 and BiDi memphis      *
*                                                                          *
* This is a temp file and should be removed when the build is picking      * 
* the latest winuser.h and wingdi.h from the NT5 tree                      *
*                                                                          *
* Created: 16-Feb-1998 02:10:11 am                                         *
* Author:  Mohamed Sadek [a-msadek]                                        *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/


//winuser.h

#ifndef WS_EX_NOINHERITLAYOUT
#define WS_EX_NOINHERITLAYOUT          0x00100000L // Disable inheritence of mirroring by children
#else 
#error "WS_EX_NOINHERITLAYOUT is already defined in winuser.h"
#endif // WS_EX_NOINHERITLAYOUT


#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#else
#error "WS_EX_LAYOUTRTL is already defined in winuser.h"
#endif // WS_EX_LAYOUTRTL

WINUSERAPI BOOL WINAPI GetProcessDefaultLayout(DWORD *pdwDefaultLayout);
WINUSERAPI BOOL WINAPI SetProcessDefaultLayout(DWORD dwDefaultLayout);


//wingdi.h
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP            (DWORD)0x80000000 /* Do not Mirror the bitmap in this call*/
#else
#error "NOMIRRORBITMAP is already defined in wingdi.h"
#endif // NOMIRRORBITMAP

WINGDIAPI DWORD WINAPI SetLayout(HDC, DWORD);
WINGDIAPI DWORD WINAPI GetLayout(HDC);


#ifndef LAYOUT_RTL
#define LAYOUT_RTL                       0x00000001 // Right to left
#else
#error "LAYOUT_RTL is already defined in wingdi.h"
#endif // LAYOUT_RTL

#ifndef LAYOUT_BTT
#define LAYOUT_BTT                        0x00000002 // Bottom to top
#else
#error "LAYOUT_BTT is already defined in wingdi.h"
#endif // LAYOUT_BTT

#ifndef LAYOUT_VBH
#define LAYOUT_VBH                        0x00000004 // Vertical before horizontal
#else
#error "LAYOUT_VBH is already defined in wingdi.h"
#endif // LAYOUT_VBH

#define LAYOUT_ORIENTATIONMASK             LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH


#ifndef LAYOUT_BITMAPORIENTATIONPRESERVED
#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008
#else
#error "LAYOUT_BITMAPORIENTATIONPRESERVED is already defined in wingdi.h"
#endif // LAYOUT_BITMAPORIENTATIONPRESERVED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\msoeacct\acctimp.h ===
#ifndef _INC_ACCTIMP
#define _INC_ACCTIMP

#include <ras.h>

typedef struct tagIMPACCOUNTINFO
    {
    DWORD_PTR dwCookie;
    DWORD dwReserved;
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } IMPACCOUNTINFO;

// {39981122-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(IID_IEnumIMPACCOUNTS, 0x39981122L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IEnumIMPACCOUNTS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };

// {39981123-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(IID_IAccountImport, 0x39981123L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IAccountImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct) = 0;
    };

// {6F5900A1-4683-11d1-83BB-00C04FBD7C09}
DEFINE_GUID(IID_INewsGroupImport, 0x6f5900a1, 0x4683, 0x11d1, 0x83, 0xbb, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

interface INewsGroupImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IImnAccount *pAccount) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportSubList(LPCSTR pListGroups) = 0;
    };

// {83782E60-39C6-11d1-83B8-00C04FBD7C09}
DEFINE_GUID(IID_IAccountImport2, 0x83782e60, 0x39c6, 0x11d1, 0x83, 0xb8, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

// IMPCONNINFO connect values
enum
    {
    CONN_NO_INFO = 0,
    CONN_USE_DEFAULT,
    CONN_USE_SETTINGS,
    CONN_CREATE_ENTRY
    };

typedef struct tagIMPCONNINFO
    {
    DWORD cbSize;
    DWORD dwConnect;
    DWORD flags;

    // if connect == CONN_USE_SETTINGS
    DWORD dwConnectType;                    // CONNECTION_TYPE_ value
    char szConnectoid[CCHMAX_CONNECTOID];   // if CONNECTION_TYPE_RAS

    // if connect == CONN_CREATE_ENTRY
    // values used to create new phonebook entry used to connect this account
    DWORD dwCountryID;
    DWORD dwCountryCode;
    char szAreaCode[RAS_MaxAreaCode + 1];
    char szLocalPhoneNumber[RAS_MaxPhoneNumber + 1];
    } IMPCONNINFO;

interface IAccountImport2 : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo) = 0;
};

#endif // _INC_ACCTIMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\msoeacct\accthelp.h ===
//Generic text for all groupbox labels:
#define IDH_INETCOMM_GROUPBOX                 505  

//Internet Accounts Dialog box
#define IDH_NEWS_SERV_SERVERS                 510 //Accounts list
#define IDH_NEWS_SERV_ADD                     515 //Add button
#define IDH_NEWS_SERV_REMOVE                  520 //Remove button
#define IDH_NEWS_SERV_PROPERTIES              525 //Properties button
#define IDH_INETCOMM_SETASDEFAULT             527 //Set as default button
#define IDH_INETCOM_DS_SETORDER               529 //Set Order button
#define IDH_NEWS_SERV_IMPORT			501 //Import button
#define IDH_NEWS_SERV_EXPORT			502 //Export button

//General Tab
#define IDH_MAIL_ACCOUNT                      530 //Mail Account/News Account
#define IDH_NEWS_SERV_NAME                    535 //Name
#define IDH_NEWS_SERV_ORG                     540 //Organization
#define IDH_NEWS_SERV_EMAIL_ADD               545 //e-mail address
#define IDH_MAIL_SERV_ADV_REPLY_TO            550 //reply address
#define IDH_MAKE_DEF_EMAIL_ACCT               555 //make this my default acccount
#define IDH_INCLUDEACCT_IN_SENDREC            560 //Include this account  (mail)
#define IDH_INCLUDE_NEWS_ACCOUNT              557 //Include this account (news)

//Security tab
#define IDH_GENERAL_USE_CERTIFICATE           561 //Use certificate
#define IDH_GENERAL_SELECT_CERTIFICATE        562 //Select certificate 
#define IDH_INETCOM_MORE_ON_CERTIFICATES      563 //More on certificates
#define IDH_INETCOM_GET_DIGITAL_ID            564 //Get digital ID 
#define IDH_SECURITY_SIGNING_CERT             780 //Certificate
#define IDH_SECURITY_ENCRYPTING_CERT          784 //Encrypting preferences certificate
#define IDH_SECURITY_SELECT_ENCRYPTCERT       788 //Select encrypting certificate
#define IDH_SECURITY_ADV_ENCRYPTION           790 //Algorithm


//Servers Tab
#define IDH_MAIL_SERV_OUTGOING                565 //Mail: Outgoing Mail
#define IDH_MAIL_SERV_INCOMING                570 //Mail: Incoming Mail
#define IDH_INETCOMM_MY_INCOMING_SERVER_IS    575 //Mail: My Incoming Mail Server is a
#define IDH_NEWS_SERV_INCOMING                576 //News: Server Name
#define IDH_INETCOMM_SERVER_REQ_LOGON         577 //News: This server requires me to logon
#define IDH_MAIL_LOGON_USING                  580 //Mail/News: Logon using radio button
#define IDH_MAIL_SERV_POP3_ACCT               585 //Mail/News: Account Name
#define IDH_MAIL_SERV_PWORD                   590 //Mail/News: Password
#define IDH_MAIL_LOGON_USING_SICILY           595 //Mail/News: Logon using Secure Password
#define IDH_MAIL_OUT_AUTH			596 //Mail/News: My server requires authentication
#define IDH_MAIL_OUT_SETTINGS			597 //Mail/News: Settings
#define IDH_MAIL_OUT_SERV_SAME			598 //Mail/News/Settings/Use same settings as my Incoming mail server
#define IDH_MAIL_REMEMBER_PWORD			503 //Mail/News: REmember password

//Connection Tab
#define IDH_NEWS_SERV_CNKT_LAN                600 //I use a LAN
#define IDH_NEWS_SERV_CNKT_MAN                605 //I connect manually
#define IDH_NEWS_SERV_CNKT_DIALUP             610 //I use a modem
#define IDH_NEWS_SERV_CNKT_DIALUP_CONNECT     615 //Use the following DUN listbox
#define IDH_NEWS_SERV_CNKT_PROPS              620 //Properties button
#define IDH_NEWS_SERV_CNKT_ADD                625 //Add button
#define IDH_MAIL_DISCONNECT_AFTER_SENDNREC    630 //Mail: Disconnect when finished
#define IDH_INETCOMM_AUTO_CONNECT             680 //News: Automatically connect to this server
#define IDH_CONNECTION_VIA_MODEM              683 //Connect via modem if the LAN is not available
#define IDH_INETCOMM_CONNECT_USING		601 //Always connect to the account using

//Advanced Tab
#define IDH_MAIL_SERV_ADV_OUT_PORT            635 //Mail:Outgoing Mail
#define IDH_MAIL_SERV_ADV_INC_PORT            640 //Mail:Incoming Mail
#define IDH_NEWS_PORT_NUMBER                  747 //News port number
#define IDH_NEWS_SERV_ADV_USE_DEFAULTS        645 //Mail/News: Use Defaults button
#define IDH_MAIL_ADV_REQ_SSL                  650 //Mail/News:This server requires
#define IDH_MAIL_SERV_ADV_TIMEOUT             655 //Mail: Server Timeouts
#define IDH_NEWS_SERV_ADV_TIMEOUT             685 //News: Server Timeouts
#define IDH_MAIL_SERV_ADV_LEAVE_SERVER_COPY   660 //Mail: Leave a copy of messages on server
#define IDH_MAIL_SERV_ADV_REMOVE_AFTER5       665 //Mail: Remove from server after xx days
#define IDH_MAIL_SERV_ADV_REMOVE_WHEN_DELETED 670 //Mail: Remove from server when deleted
#define IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP     675 //Mail: Break apart messages larger than
#define IDH_NEWS_SERV_ADV_DESC                690 //News: Use Newsgroup descriptions
#define IDH_INETCOMM_SHOW_SUBSCRIBED          759
#define IDH_NEWS_IGNORE_SEND_FORMAT                  691 //Ignore news sending format and post using
#define IDH_NEWS_USE_FORMAT                   692 //HTML or Plain Text

//IMAP tab
#define IDH_IMAP_BASE_ROOT                    757 //root folder path
#define IDH_IMAP_STORE_SPECIAL_FOLDERS        760 //store special folders on imap server
#define IDH_IMAP_SENT_ITEMS                   765 //sent items path
#define IDH_IMAP_DRAFTS	                      770 //drafts path
#define IDH_IMAP_NEW_MSGS                    775 //check for new msgs in all folders


//Directory Service Account Properties
//General Tab
#define IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME    700 //Directory Service Account: Label and textbox
#define IDH_WABLDAP_DIRSSERV_NAME             705 //Server Name
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS        715 //Logon using:
#define IDH_WABLDAP_DIRSSERV_AUTH_SICILY      720 //Logon using Secure Password
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME  725 //Account Name
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS   730 //Password
#define IDH_WABLDAP_DIRSSERV_CHECK_AGAINST    735 //Check names against this server

//Advanced Tab
#define IDH_LDAP_PORT_NUMBER                  737 //Directory Service (LDAP) label and text box
#define IDH_WABLDAP_SEARCH_TIMEOUT            740 //Search timeout label and slider
#define IDH_WABLDAP_SEARCH_LIMIT              745 //Max number of matches to return
#define IDH_LDAP_SEARCH_BASE                  750 //Search Base
#define IDH_WABLDAP_USE_SIMPLE_SEARCH         755 //Use simple search filter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\msoeacct\acctman.h ===
// -----------------------------------------------------------------------------
// A C C T M A N . H - Steven J. Bailey - 8/17/96
// -----------------------------------------------------------------------------
#ifndef __ACCTMAN_H
#define __ACCTMAN_H

// -----------------------------------------------------------------------------
// Depends On...
// -----------------------------------------------------------------------------
#include "ipropobj.h"
#include "imnact.h"

#define ACCT_UNDEFINED  ((ACCTTYPE)-1)

#define ICC_FLAGS (ICC_WIN95_CLASSES|ICC_NATIVEFNTCTL_CLASS)

class CAccountManager;

extern const int NUM_ACCT_PROPS;
extern const PROPINFO g_rgAcctPropSet[];

// -----------------------------------------------------------------------------
// CAccount
// -----------------------------------------------------------------------------
class CAccount : public IImnAccount
{
private:
    ULONG               m_cRef;
    CAccountManager    *m_pAcctMgr;
    BOOL                m_fAccountExist;
    DWORD               m_dwSrvTypes;
    ACCTTYPE            m_AcctType;
    TCHAR               m_szID[CCHMAX_ACCOUNT_NAME];
    TCHAR               m_szName[CCHMAX_ACCOUNT_NAME];
    CPropertyContainer *m_pContainer;
    BOOL                m_fNoModifyAccts;

    HKEY                m_hkey;
    char                m_szKey[MAX_PATH];

    HRESULT IDoWizard(HWND hwnd, CLSID *pclsid, DWORD dwFlags);

public:
    DWORD               m_dwDlgFlags;

    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CAccount(ACCTTYPE AcctType);
    ~CAccount(void);

    // -------------------------------------------------------------------------
    // IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    void SetAccountType(ACCTTYPE AcctType);
    HRESULT ValidProp(DWORD dwPropTag);

    // -------------------------------------------------------------------------
    // HrInit - initializes the container
    // -------------------------------------------------------------------------
    HRESULT Init(CAccountManager *pAcctMgr, CPropertySet *pPropertySet);

    // -------------------------------------------------------------------------
    // HrOpen - Read properties from the registry
    // -------------------------------------------------------------------------
    STDMETHODIMP Open(HKEY hkey, LPCSTR pszAcctKey, LPCSTR pszAccount);

    // -------------------------------------------------------------------------
    // Is this a new account or does it already exist?
    // -------------------------------------------------------------------------
    STDMETHODIMP Exist(VOID);

    // -------------------------------------------------------------------------
    // Make default account for support server types
    // -------------------------------------------------------------------------
    STDMETHODIMP SetAsDefault(VOID);

    // -------------------------------------------------------------------------
    // Delete this account
    // -------------------------------------------------------------------------
    STDMETHODIMP Delete(VOID);

    STDMETHODIMP GetAccountType(ACCTTYPE *pAcctType);

    STDMETHODIMP GetServerTypes(DWORD *pdwSrvTypes);

    // -------------------------------------------------------------------------
    // Save the container
    // -------------------------------------------------------------------------
    STDMETHODIMP SaveChanges();
    STDMETHODIMP SaveChanges(BOOL fSendMsg);

    // -------------------------------------------------------------------------
    // Write changes, without sending notifications message
    // -------------------------------------------------------------------------
    STDMETHODIMP WriteChanges();

    // -------------------------------------------------------------------------
    // IPropertyContainer Implementation (GetProperty)
    // -------------------------------------------------------------------------
    STDMETHODIMP GetProp(DWORD dwPropTag, LPBYTE pb, ULONG *pcb);
    STDMETHODIMP GetPropDw(DWORD dwPropTag, DWORD *pdw);
    STDMETHODIMP GetPropSz(DWORD dwPropTag, LPSTR psz, ULONG cchMax);
    STDMETHODIMP SetProp(DWORD dwPropTag, LPBYTE pb, ULONG cb);
    STDMETHODIMP SetPropDw(DWORD dwPropTag, DWORD dw);
    STDMETHODIMP SetPropSz(DWORD dwPropTag, LPSTR psz);

    STDMETHODIMP ShowProperties(HWND hwnd, DWORD dwFlags);

    STDMETHODIMP ValidateProperty(DWORD dwPropTag, BYTE *pb, ULONG cb);

    STDMETHODIMP DoWizard(HWND hwnd, DWORD dwFlags);
    STDMETHODIMP DoImportWizard(HWND hwnd, CLSID clsid, DWORD dwFlags);
};

// -----------------------------------------------------------------------------
// ACCOUNT
// -----------------------------------------------------------------------------
typedef struct tagACCOUNT {

    TCHAR               szID[CCHMAX_ACCOUNT_NAME];
    ACCTTYPE            AcctType;
    DWORD               dwSrvTypes;
    DWORD               dwServerId;     // for LDAP only
    IImnAccount        *pAccountObject;

} ACCOUNT, *LPACCOUNT;

#define ENUM_FLAG_SORT_BY_NAME      0x0001
#define ENUM_FLAG_RESOLVE_ONLY      0x0002
#define ENUM_FLAG_SORT_BY_LDAP_ID   0x0004
#define ENUM_FLAG_NO_IMAP           0x0008

// -----------------------------------------------------------------------------
// CEnumAccounts
// -----------------------------------------------------------------------------
class CEnumAccounts : public IImnEnumAccounts
{
private:
    ULONG               m_cRef;             // Reference Counting
    LPACCOUNT           m_pAccounts;        // Array of accounts and Account Objects
    ULONG               m_cAccounts;        // Number of accounts in m_pAccounts array
    LONG                m_iAccount;         // Index of current account (-1 if at beginning)
    DWORD               m_dwSrvTypes;       // Used for enumerating servers of a specific type
    DWORD               m_dwFlags;

private:
    VOID QSort(LONG left, LONG right);
    BOOL FEnumerateAccount(LPACCOUNT pAccount);

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CEnumAccounts(DWORD dwSrvTypes, DWORD dwFlags);
    ~CEnumAccounts();

    // -------------------------------------------------------------------------
    // IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // Init - Initialize the enumerator, i.e. duplicate the Accounts array
    // -------------------------------------------------------------------------
    HRESULT Init(LPACCOUNT pAccounts, ULONG cAccounts);

    // -------------------------------------------------------------------------
    // GetCount - Get the number of items that the enumerator will process
    // -------------------------------------------------------------------------
    STDMETHODIMP GetCount(ULONG *pcItems);

    // -------------------------------------------------------------------------
    // SortByAccountName - sorts the enumerated accounts by name
    // -------------------------------------------------------------------------
    STDMETHODIMP SortByAccountName(void);

    // -------------------------------------------------------------------------
    // GetNext - Get the first or next enumerated account
    // Returns hrEnumFinished (*ppAccount = NULL) when no more accounts to enumerate
    // -------------------------------------------------------------------------
    STDMETHODIMP GetNext(IImnAccount **ppAccount);

    // -------------------------------------------------------------------------
    // Reset - This is like rewinding the enumerator
    // -------------------------------------------------------------------------
    STDMETHODIMP Reset(void);
};

// -----------------------------------------------------------------------------
// ACCTINFO - Account Inforation
// -----------------------------------------------------------------------------
typedef struct tagACCTINFO {

    TCHAR               szDefaultID[CCHMAX_ACCOUNT_NAME];
    BOOL                fDefaultKnown;
    DWORD               cAccounts;
    LPTSTR              pszDefRegValue;
    LPTSTR              pszFirstAccount;

} ACCTINFO;

#define ADVISE_BLOCK_SIZE               (16)

#define ADVISE_COOKIE                   ((WORD)0xAD5E)
// Advise connections will be generated by masking in this cookie with the 
// index into the CAccountManager array where the advise is stored.
#define MAX_INDEX                       (INT)(0xFFFF)

#define INDEX_FROM_CONNECTION(conn)     (INT)(LOWORD(conn))
#define CONNECTION_FROM_INDEX(indx)     (MAKELONG(LOWORD(indx), ADVISE_COOKIE))
#define IS_VALID_CONNECTION(conn)       (ADVISE_COOKIE == HIWORD(conn))
#define IS_VALID_INDEX(indx)            (((indx)>=0)&&((indx)<=MAX_INDEX))


// -----------------------------------------------------------------------------
// CAccountManager
// -----------------------------------------------------------------------------
class CAccountManager : public IImnAccountManager2
{
private:
    ULONG               m_cRef;             // Reference Counting
    LPACCOUNT           m_pAccounts;        // Array of accounts and Account Objects
    ULONG               m_cAccounts;        // Number of accounts in m_pAccounts array
    CPropertySet       *m_pAcctPropSet;     // Base account property set used to create CAccount
    BOOL                m_fInit;            // Has the object been successfully initialized
    UINT                m_uMsgNotify;       // Account Manager global notification message (0 means not processing)
    ACCTINFO            m_rgAccountInfo[ACCT_LAST]; // Array of known account informtaion
    CRITICAL_SECTION    m_cs;               // Thread Safety
    IImnAdviseAccount **m_ppAdviseAccounts; // Client Account Advise Handlers
    INT                 m_cAdvisesAllocated;
    BOOL                m_fNoModifyAccts;
    BOOL                m_fInitCalled;      // Avoid duplicate initialization
    BOOL                m_fOutlook;

    HKEY                m_hkey;
    char                m_szRegRoot[MAX_PATH];
    char                m_szRegAccts[MAX_PATH];

    HRESULT IInit(IImnAdviseMigrateServer *pMigrateServerAdvise, HKEY hkey, LPCSTR pszSubKey, DWORD dwFlags);

    // -------------------------------------------------------------------------
    // Reloads accounts (m_pAccounts) array from the registry
    // -------------------------------------------------------------------------
    HRESULT LoadAccounts(VOID);

    // -------------------------------------------------------------------------
    // Loading Default Account Information
    // -------------------------------------------------------------------------
    VOID GetDefaultAccounts(VOID);

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CAccountManager();
    ~CAccountManager();

    // -------------------------------------------------------------------------
    // IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // Initialization of this object (only call it once)
    // -------------------------------------------------------------------------
    STDMETHODIMP Init(IImnAdviseMigrateServer *pAdviseMigrateServer);
    STDMETHODIMP InitEx(IImnAdviseMigrateServer *pAdviseMigrateServer, DWORD dwFlags);
    STDMETHODIMP InitUser(IImnAdviseMigrateServer *pAdviseMigrateServer, REFGUID rguidID, DWORD dwFlags);

    // -------------------------------------------------------------------------
    // FProcessNotification - returns TRUE if window message was
    // processed as a notification
    // -------------------------------------------------------------------------
    STDMETHODIMP ProcessNotification(UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID Advise(DWORD dwAction, ACTX* pactx);

    // -------------------------------------------------------------------------
    // Creating Account Objects
    // -------------------------------------------------------------------------
    STDMETHODIMP CreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount);
    HRESULT ICreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount);

    HRESULT DeleteAccount(LPSTR pszID, LPSTR pszName, ACCTTYPE AcctType, DWORD dwSrvTypes);

    // -------------------------------------------------------------------------
    // Enumerators - Always returns connected accounts first
    // -------------------------------------------------------------------------
    STDMETHODIMP Enumerate(DWORD dwSrvTypes, IImnEnumAccounts **ppEnumAccounts);
    HRESULT IEnumerate(DWORD dwSrvTypes, DWORD dwFlags, IImnEnumAccounts **ppEnumAccounts);

    // -------------------------------------------------------------------------
    // GetServerCount
    // -------------------------------------------------------------------------
    STDMETHODIMP GetAccountCount(ACCTTYPE AcctType, ULONG *pcServers);

    // -------------------------------------------------------------------------
    // FindAccount - used to find accounts by unique properties
    // -------------------------------------------------------------------------
    STDMETHODIMP FindAccount(DWORD dwPropTag, LPCTSTR pszSearchData, IImnAccount **ppAccount);

    // -------------------------------------------------------------------------
    // GetDefaultAccount - Opens the default account for the account type
    // -------------------------------------------------------------------------
    STDMETHODIMP GetDefaultAccount(ACCTTYPE AcctType, IImnAccount **ppAccount);
    STDMETHODIMP GetDefaultAccountName(ACCTTYPE AcctType, LPTSTR pszAccount, ULONG cchMax);
    HRESULT SetDefaultAccount(ACCTTYPE AcctType, LPSTR pszID, BOOL fNotify);

    STDMETHODIMP GetIncompleteAccount(ACCTTYPE AcctType, LPSTR pszAccountId, ULONG cchMax);
    STDMETHODIMP SetIncompleteAccount(ACCTTYPE AcctType, LPCSTR pszAccountId);

    // I wrote this function because I support accounts without an SMTP server. This
    // functions verifies that the default Send account truly contains an SMTP server,
    // and if it doesn't, resets the default Send Account to an account that does have
    // an SMTP server.
    STDMETHODIMP ValidateDefaultSendAccount(VOID);

    STDMETHODIMP AccountListDialog(HWND hwnd, ACCTLISTINFO *pinfo);

    STDMETHODIMP Advise(IImnAdviseAccount *pAdviseAccount, DWORD* pdwConnection);
    STDMETHODIMP Unadvise(DWORD dwConnection);

    STDMETHODIMP GetUniqueAccountName(LPTSTR szName, UINT cch);

    void UpgradeAccountProps(void);

    HRESULT GetNextLDAPServerID(DWORD dwSet, DWORD *pdwId);
    HRESULT GetNextAccountID(TCHAR *szID, int cch);
    
    HRESULT UniqueAccountName(char *szName, char *szID);

    inline LPCSTR   GetAcctRegKey(void)  {return(m_szRegAccts);};
    inline HKEY     GetAcctHKey(void)    {return(m_hkey);};
    inline BOOL     FNoModifyAccts(void) {return(m_fNoModifyAccts);}
    inline BOOL     FOutlook(void)       {return(m_fOutlook);}   

};

#define CCH_USERNAME_MAX_LENGTH         63

typedef struct tagOEUSERINFO {

    DWORD               dwUserId;
    TCHAR               szUsername[CCH_USERNAME_MAX_LENGTH+1];

} OEUSERINFO;

// -----------------------------------------------------------------------------
// AcctUtil Prototypes
// -----------------------------------------------------------------------------
HRESULT AcctUtil_ValidAccountName(LPTSTR pszAccount);
VOID    AcctUtil_FreeAccounts(LPACCOUNT *ppAccounts, ULONG *pcAccounts);
HRESULT AcctUtil_HrSetAsDefault(IImnAccount *pAccount, LPCTSTR pszRegRoot);
BOOL    AcctUtil_IsHTTPMailEnabled(void);
BOOL    AcctUtil_HideHotmail();

#endif // __ACCTMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mirlib\rtlmir.cpp ===
/****************************** Module*Header *****************************\
* Module Name: rtlmir.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines which are used across the whole IShell project. It abstracts    *
* platform-support routines of RTL mirroring (NT5 and Memphis) and removes *
* linkage depedenency with the Mirroring APIs.                             *
*                                                                          *
* Functions prefixed with Mirror, deal with the new Mirroring APIs         *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/


#include "pch.hxx"
#if WINVER < 0X0500
#include "mirport.h"
#endif
#include "mirror.h"

const DWORD dwNoMirrorBitmap = NOMIRRORBITMAP;
const DWORD dwExStyleRTLMirrorWnd = WS_EX_LAYOUTRTL;
const DWORD dwPreserveBitmap = LAYOUT_BITMAPORIENTATIONPRESERVED;

/*
 * Remove linkage dependecy for the RTL mirroring APIs, by retreiving
 * their addresses at runtime.
 */
typedef DWORD (*PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (*PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout
typedef BOOL  (*PFNSETPROCESSDEFLAYOUT)(DWORD);       // user32!SetProcessDefaultLayout
typedef BOOL  (*PFNGETPROCESSDEFLAYOUT)(DWORD*);      // user32!GetProcessDefaultLayout
typedef LANGID (*PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage

#define OS_WINDOWS      0           // windows vs. NT
#define OS_NT           1           // windows vs. NT
#define OS_WIN95        2
#define OS_NT4          3
#define OS_NT5          4
#define OS_MEMPHIS      5

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) MirLibIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_MEMPHIS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}   

/***************************************************************************\
* Mirror_GetUserDefaultUILanguage
*
* Reads the User UI language on NT5
*
* History:
* 22-June-1998 samera    Created
\***************************************************************************/
LANGID Mirror_GetUserDefaultUILanguage( void )
{
    LANGID langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnGetUserDefaultUILanguage = (PFNGETUSERDEFAULTUILANGUAGE)
                                          GetProcAddress(hmod, "GetUserDefaultUILanguage");
    }

    if( pfnGetUserDefaultUILanguage )
        langId = pfnGetUserDefaultUILanguage();

    return langId;
}

/***************************************************************************\
* Mirror_EnableWindowLayoutInheritance
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 14-April-1998 a-msadek    Created
\***************************************************************************/
LONG Mirror_EnableWindowLayoutInheritance( HWND hWnd )
{
    return SetWindowLongA(hWnd, GWL_EXSTYLE, GetWindowLongA( hWnd , GWL_EXSTYLE ) & ~WS_EX_NOINHERITLAYOUT );
}


/***************************************************************************\
* Mirror_DisableWindowLayoutInheritance
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 14-April-1998 a-msadek    Created
\***************************************************************************/
LONG Mirror_DisableWindowLayoutInheritance( HWND hWnd )
{
    return SetWindowLongA(hWnd, GWL_EXSTYLE, GetWindowLongA( hWnd , GWL_EXSTYLE ) | WS_EX_NOINHERITLAYOUT );
}

/***************************************************************************\
* ConvertHexStringToInt
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToInt( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}


/***************************************************************************\
* IsBiDiLocalizedSystem
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystem( void )
{
    HKEY        hKey;
    DWORD       dwType;
    CHAR        szResourceLocale[12];
    DWORD       dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    LANGID      langID;
    int         iLCID=0L;
    static BOOL bRet = (BOOL)(DWORD)-1;

    if (bRet != (BOOL)(DWORD)-1)
    {
        return bRet;
    }

    bRet = FALSE;
    if( MirLibIsOS( OS_NT5 ) )
    {
        /*
         * Need to use NT5 detection method (Multiligual UI ID)
         */
        langID = Mirror_GetUserDefaultUILanguage();

        if( langID )
        {
            WCHAR wchLCIDFontSignature[16];
            iLCID = MAKELCID( langID , SORT_DEFAULT );

            /*
             * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
             * convert to decimal value and call GetLocaleInfo afterwards.
             * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
             */

            if( GetLocaleInfoW( iLCID , 
                                LOCALE_FONTSIGNATURE , 
                                (WCHAR *) &wchLCIDFontSignature[0] ,
                                (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
            {
      
                /* Let's verify the bits we have a BiDi UI locale */
                if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
                {
                    bRet = TRUE;
                }
            }
        }
    } else {

        /*
         * Check if BiDi-Memphis is running with Lozalized Resources (
         * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
         */
        if( (MirLibIsOS(OS_MEMPHIS)) && (GetSystemMetrics(SM_MIDEASTENABLED)) )
        {

            if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                               "Control Panel\\Desktop\\ResourceLocale" , 
                               0, 
                               KEY_READ, &hKey) == ERROR_SUCCESS) 
            {
                RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
                szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                RegCloseKey(hKey);

                if( ConvertHexStringToInt( szResourceLocale , &iLCID ) )
                {
                    iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                    if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                    {
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    return bRet;
}



/***************************************************************************\
* Mirror_IsEnabledOS
*
* returns TRUE if the mirroring APIs are enabled on the current OS.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsEnabledOS( void )
{
    BOOL bRet = FALSE;

    if( MirLibIsOS(OS_NT5) )
    {
        bRet = TRUE;
    } else if( MirLibIsOS(OS_MEMPHIS) && GetSystemMetrics(SM_MIDEASTENABLED)) {
        bRet=TRUE;
    }

    return bRet;
}


/***************************************************************************\
* Mirror_IsWindowMirroredRTL
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsWindowMirroredRTL( HWND hWnd )
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}




/***************************************************************************\
* Mirror_GetLayout
*
* returns TRUE if the hdc is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;

    if( NULL == pfnGetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}

DWORD Mirror_IsDCMirroredRTL( HDC hdc )
{
    return (Mirror_GetLayout( hdc ) & LAYOUT_RTL);
}



/***************************************************************************\
* Mirror_SetLayout
*
* RTL Mirror the hdc
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;

    if( NULL == pfnSetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}

DWORD Mirror_MirrorDC( HDC hdc )
{
    return Mirror_SetLayout( hdc , LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_SetProcessDefaultLayout
*
* Set the process-default layout.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_SetProcessDefaultLayout( DWORD dwDefaultLayout )
{
    BOOL bRet=0;
    static PFNSETPROCESSDEFLAYOUT pfnSetProcessDefLayout=NULL;

    if( NULL == pfnSetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnSetProcessDefLayout = (PFNSETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "SetProcessDefaultLayout");
    }

    if( pfnSetProcessDefLayout )
        bRet = pfnSetProcessDefLayout( dwDefaultLayout );

    return bRet;
}

BOOL Mirror_MirrorProcessRTL( void )
{
    return Mirror_SetProcessDefaultLayout( LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_GetProcessDefaultLayout
*
* Get the process-default layout.
*
* History:
* 26-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout )
{
    BOOL bRet=0;
    static PFNGETPROCESSDEFLAYOUT pfnGetProcessDefLayout=NULL;

    if( NULL == pfnGetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnGetProcessDefLayout = (PFNGETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "GetProcessDefaultLayout");
    }

    if( pfnGetProcessDefLayout )
        bRet = pfnGetProcessDefLayout( pdwDefaultLayout );

    return bRet;
}

BOOL Mirror_IsProcessRTL( void )
{
    DWORD dwDefLayout=0;
    static BOOL bRet = (BOOL)(DWORD)-1;

    if (bRet != (BOOL)(DWORD)-1)
    {
        return bRet;
    }

    bRet = FALSE;

    bRet = (Mirror_GetProcessDefaultLayout(&dwDefLayout) && (dwDefLayout&LAYOUT_RTL));

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\msoeacct\acctui.h ===
#ifndef _ACCTUI_H
#define _ACCTUI_H

// max CCHMAX value from imnact.h
#define CCHMAX_ACCT_PROP_SZ     256

#define OPTION_OFF          0xffffffff
#define PORT_CCHMAX         8

#define DEF_NNTPPORT        119
#define DEF_SNNTPPORT       563
#define DEF_IMAPPORT        143
#define DEF_SIMAPPORT       993
#define DEF_SMTPPORT        25
#define DEF_SSMTPPORT       25

#define DEF_POP3PORT        110
#define DEF_SPOP3PORT       995
#define DEF_LDAPPORT        389
#define DEF_SLDAPPORT       636

// $TODO - These constants will be moved later
#define EXPIRE_MAX          100
#define EXPIRE_MIN          1
#define EXPIRE_DEFAULT      5
#define DEF_BREAKSIZE       60
#define BREAKSIZE_MIN       16
#define BREAKSIZE_MAX       16000
#define MATCHES_MAX         9999
#define MATCHES_MIN         1
#define MATCHES_DEFAULT     100

enum 
    {
    iNewsServer = 0,
    iMailServer,
    iLDAPServer
    };


// query sibling messages
#define MSM_GETSERVERTYPE   WM_USER
#define SM_INITIALIZED      (WM_USER + 2)
#define SM_SETDIRTY         (WM_USER + 3)
#define SM_SAVECHANGES      (WM_USER + 4)
#define MSM_GETEMAILADDRESS (WM_USER + 5)
#define MSM_GETCERTDATA     (WM_USER + 6)
#define MSM_GETDISPLAYNAME  (WM_USER + 7)
    
enum tagPages {
    PAGE_READ   = 0x0001,
    PAGE_SEND   = 0x0002,
    PAGE_SERVER = 0x0004,
    PAGE_FONTS  = 0x0008,
    PAGE_SPELL  = 0x0010,
    PAGE_SIG    = 0x0020,
    PAGE_ADV    = 0x0040,
    PAGE_RAS    = 0x0080,
    PAGE_SEC    = 0x0100,
    PAGE_ADVSEC = 0x0200,
    PAGE_GEN    = 0x0400,
    PAGE_IMAP   = 0x0800
    };

typedef struct tagACCTDLGINFO
    {
    ACCTTYPE AcctTypeInit;
    DWORD dwAcctFlags;
    DWORD dwFlags;
    ACCTTYPE AcctType; // used by the dialog in single-type mode
    } ACCTDLGINFO;

INT_PTR CALLBACK ManageAccountsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int AcctMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle);
void InitTimeoutSlider(HWND hwndSlider, HWND hwndText, DWORD dwTimeout);
void SetTimeoutString(HWND hwnd, UINT pos);
DWORD GetTimeoutFromSlider(HWND hwnd);
void InitCheckCounter(DWORD dw, HWND hwnd, int idcCheck, int idcEdit, int idcSpin, int min, int max, int def);
BOOL InvalidAcctProp(HWND hwndPage, HWND hwndEdit, int idsError, UINT idPage);
BOOL Server_FAddAccount(HWND hwndList, ACCTDLGINFO *pinfo, UINT iItem, IImnAccount *pAccount, BOOL fSelect);
BOOL Server_InitServerList(HWND hwnd, HWND hwndList, HWND hwndTab, ACCTDLGINFO *pinfo, TCHAR *szSelect);
void Server_ImportServer(HWND hwndDlg, ACCTDLGINFO *pinfo);
void Server_ExportServer(HWND hwndDlg);

typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);

#endif //_ACCTUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\msoeacct\acctman.cpp ===
// -----------------------------------------------------------------------------
// A C C T M A N . C P P - Steven J. Bailey - 8/17/96
// -----------------------------------------------------------------------------
#include "pch.hxx"
#include <prsht.h>
#include <tchar.h>
#include <ras.h>
#include "acctman.h"
#include "acctui.h"
#include "server.h"
#include <acctimp.h>
#include <icwacct.h>
#include "icwwiz.h"
#include "dllmain.h"
#include "resource.h"
#include <strconst.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <demand.h>     // must be last!

// -----------------------------------------------------------------------------
// Registry Keys
// -----------------------------------------------------------------------------
const static TCHAR c_szAccountsKey[] = _T("Accounts");

const static TCHAR c_szDefaultNewsAccount[] = _T("Default News Account");
const static TCHAR c_szDefaultMailAccount[] = _T("Default Mail Account");
const static TCHAR c_szDefaultLDAPAccount[] = _T("Default LDAP Account");
const static TCHAR c_szRegServerID[] = _T("Server ID");
const static TCHAR c_szRegAccountName[] = _T("Account Name");

// -----------------------------------------------------------------------------
// Accout Property Set
// -----------------------------------------------------------------------------
#define ACCTMAN_PROPERTY_VERSION    1

const PROPINFO g_rgAcctPropSet[] = {
    { AP_ACCOUNT_NAME, _T("Account Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_ACCOUNT_NAME}},
    { AP_TEMP_ACCOUNT, _T("Temporary Account"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_LAST_UPDATED, _T("Last Updated"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_RAS_CONNECTION_TYPE, _T("Connection Type"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_RAS_CONNECTOID, _T("Connectoid"), PF_MINMAX, {0, 0}, {0, CCHMAX_CONNECTOID}},
    { AP_RAS_CONNECTION_FLAGS, _T("Connection Flags"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_ACCOUNT_ID, _T("Account ID"), PF_NOPERSIST|PF_MINMAX, {0, 0}, {0, CCHMAX_ACCOUNT_NAME}},
    { AP_RAS_BACKUP_CONNECTOID, _T("Backup Connectoid"), PF_MINMAX, {0, 0}, {0, CCHMAX_CONNECTOID}},
    { AP_SERVICE, _T("Service"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVICE}},
    { AP_AVAIL_OFFLINE, _T("Make Available Offline"), PF_DEFAULT, {1, 0}, {0, 0}},
    { AP_UNIQUE_ID, _T("Unique ID"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_SERVER_READ_ONLY, _T("Server Read Only"), NOFLAGS, {0, 0}, {0, 0}},

    { AP_IMAP_SERVER, _T("IMAP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_IMAP_USERNAME, _T("IMAP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_IMAP_PASSWORD, _T("IMAP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_IMAP_USE_SICILY, _T("IMAP Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_IMAP_PORT, _T("IMAP Port"), PF_MINMAX|PF_DEFAULT, {DEF_IMAPPORT, 0}, {1, 0xffffffff}},
    { AP_IMAP_SSL, _T("IMAP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_IMAP_TIMEOUT, _T("IMAP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_IMAP_ROOT_FOLDER, _T("IMAP Root Folder"), PF_MINMAX, {0, 0}, {0, MAX_PATH}},
    { AP_IMAP_DATA_DIR, _T("IMAP Data Directory"), PF_MINMAX, {0, 0}, {0, MAX_PATH}},
    { AP_IMAP_USE_LSUB, _T("IMAP Use LSUB"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_IMAP_POLL, _T("IMAP Polling"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_IMAP_FULL_LIST, _T("IMAP Full List"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_IMAP_NOOP_INTERVAL, _T("IMAP NOOP Interval"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_IMAP_SVRSPECIALFLDRS, _T("IMAP Svr-side Special Folders"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_IMAP_SENTITEMSFLDR, _T("IMAP Sent Items Folder"), PF_MINMAX|PF_DEFAULT, {idsIMAPSentItemsFldr, 0}, {0, MAX_PATH}},
    { AP_IMAP_DRAFTSFLDR, _T("IMAP Drafts Folder"), PF_MINMAX|PF_DEFAULT, {idsIMAPDraftsFldr, 0}, {0, MAX_PATH}},
    { AP_IMAP_PROMPT_PASSWORD, _T("IMAP Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_IMAP_DIRTY, _T("IMAP Dirty"), PF_DEFAULT, {0, 0}, {0, 0}},
    { AP_IMAP_POLL_ALL_FOLDERS, _T("IMAP Poll All Folders"), PF_DEFAULT, {TRUE, 0}, {0, 0}},

    { AP_LDAP_SERVER, _T("LDAP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}}, // new
    { AP_LDAP_USERNAME, _T("LDAP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_LDAP_PASSWORD, _T("LDAP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_LDAP_AUTHENTICATION, _T("LDAP Authentication"), PF_MINMAX|PF_DEFAULT, {LDAP_AUTH_ANONYMOUS, 0}, {0, LDAP_AUTH_MAX}}, // new
    { AP_LDAP_TIMEOUT, _T("LDAP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_LDAP_SEARCH_RETURN, _T("LDAP Search Return"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_SEARCH_BASE, _T("LDAP Search Base"), PF_MINMAX, {0, 0}, {0, CCHMAX_SEARCH_BASE}}, // new
    { AP_LDAP_SERVER_ID, _T("LDAP Server ID"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_RESOLVE_FLAG, _T("LDAP Resolve Flag"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_URL, _T("LDAP URL"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}}, // new
    { AP_LDAP_PORT, _T("LDAP Port"), PF_MINMAX|PF_DEFAULT, {DEF_LDAPPORT, 0}, {1, 0xffffffff}}, // new
    { AP_LDAP_SSL, _T("LDAP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_LDAP_LOGO, _T("LDAP Logo"), PF_MINMAX, {0, 0}, {0, MAX_PATH}}, // new
    { AP_LDAP_USE_BIND_DN, _T("LDAP Bind DN"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_SIMPLE_SEARCH, _T("LDAP Simple Search"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_ADVANCED_SEARCH_ATTR, _T("LDAP Advanced Search Attributes"), PF_MINMAX, {0, 0}, {0, MAX_PATH}}, // new
    { AP_LDAP_PAGED_RESULTS, _T("LDAP Paged Result Support"), PF_MINMAX|PF_DEFAULT, {LDAP_PRESULT_UNKNOWN, 0}, {0, LDAP_PRESULT_MAX}}, // new
    { AP_LDAP_NTDS, _T("LDAP NTDS"), PF_MINMAX|PF_DEFAULT, {LDAP_NTDS_UNKNOWN, 0}, {0, LDAP_NTDS_MAX}}, // new

    { AP_NNTP_SERVER, _T("NNTP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_NNTP_USERNAME, _T("NNTP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_NNTP_PASSWORD, _T("NNTP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_NNTP_USE_SICILY, _T("NNTP Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_NNTP_PORT, _T("NNTP Port"), PF_MINMAX|PF_DEFAULT, {DEF_NNTPPORT, 0}, {1, 0xffffffff}},
    { AP_NNTP_SSL, _T("NNTP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_NNTP_TIMEOUT, _T("NNTP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_NNTP_DISPLAY_NAME, _T("NNTP Display Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_ORG_NAME, _T("NNTP Organization Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_EMAIL_ADDRESS, _T("NNTP Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_REPLY_EMAIL_ADDRESS, _T("NNTP Reply To Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_SPLIT_MESSAGES, _T("NNTP Split Messages"), PF_DEFAULT, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_SPLIT_SIZE, _T("NNTP Split Message Size"), PF_DEFAULT, {64, 0}, {0, 0}}, // new
    { AP_NNTP_USE_DESCRIPTIONS, _T("Use Group Descriptions"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_NNTP_DATA_DIR, _T("NNTP Data Directory"), PF_MINMAX, {0, 0}, {0, MAX_PATH}},
    { AP_NNTP_POLL, _T("NNTP Polling"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_NNTP_POST_FORMAT, _T("NNTP Posting"), PF_DEFAULT, {POST_USE_DEFAULT, 0}, {0, 0}}, // new
    { AP_NNTP_SIGNATURE, _T("NNTP Signature"), PF_MINMAX, {0, 0}, {0, CCHMAX_SIGNATURE}}, // new
    { AP_NNTP_PROMPT_PASSWORD, _T("NNTP Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},

    { AP_POP3_SERVER, _T("POP3 Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_POP3_USERNAME, _T("POP3 User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_POP3_PASSWORD, _T("POP3 Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_POP3_USE_SICILY, _T("POP3 Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_POP3_PORT, _T("POP3 Port"), PF_MINMAX|PF_DEFAULT, {DEF_POP3PORT, 0}, {1, 0xffffffff}},
    { AP_POP3_SSL, _T("POP3 Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_TIMEOUT, _T("POP3 Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_POP3_LEAVE_ON_SERVER, _T("Leave Mail On Server"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_REMOVE_DELETED, _T("Remove When Deleted"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_REMOVE_EXPIRED, _T("Remove When Expired"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_EXPIRE_DAYS, _T("Expire Days"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_SKIP, _T("POP3 Skip Account"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_POP3_OUTLOOK_CACHE_NAME, _T("Outlook Cache Name"), PF_MINMAX, {0, 0}, {0, MAX_PATH}}, // new
    { AP_POP3_PROMPT_PASSWORD, _T("POP3 Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    
    { AP_SMTP_SERVER, _T("SMTP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_SMTP_USERNAME, _T("SMTP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_SMTP_PASSWORD, _T("SMTP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_SMTP_USE_SICILY, _T("SMTP Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_SMTP_PORT, _T("SMTP Port"), PF_MINMAX|PF_DEFAULT, {DEF_SMTPPORT, 0}, {1, 0xffffffff}},
    { AP_SMTP_SSL, _T("SMTP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_SMTP_TIMEOUT, _T("SMTP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_SMTP_DISPLAY_NAME, _T("SMTP Display Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_ORG_NAME, _T("SMTP Organization Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_EMAIL_ADDRESS, _T("SMTP Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_REPLY_EMAIL_ADDRESS, _T("SMTP Reply To Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_SPLIT_MESSAGES, _T("SMTP Split Messages"), PF_DEFAULT, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_SPLIT_SIZE, _T("SMTP Split Message Size"), PF_DEFAULT, {64, 0}, {0, 0}}, // new
    { AP_SMTP_CERTIFICATE, _T("SMTP Certificate"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_SMTP_SIGNATURE, _T("SMTP Signature"), PF_MINMAX, {0, 0}, {0, CCHMAX_SIGNATURE}}, // new
    { AP_SMTP_PROMPT_PASSWORD, _T("SMTP Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_SMTP_ENCRYPT_CERT, _T("SMTP Encryption Certificate"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_SMTP_ENCRYPT_ALGTH, _T("SMTP Encryption Algorithm"), NOFLAGS, {0, 0}, {0, 0}}, // new

    { AP_HTTPMAIL_SERVER, _T("HTTPMail Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_HTTPMAIL_USERNAME, _T("HTTPMail User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}},
    { AP_HTTPMAIL_PASSWORD, _T("HTTPMail Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}},
    { AP_HTTPMAIL_PROMPT_PASSWORD, _T("HTTPMail Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},  
    { AP_HTTPMAIL_USE_SICILY, _T("HTTPMail Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, 
    { AP_HTTPMAIL_FRIENDLY_NAME, _T("HTTPMail Friendly Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_ACCOUNT_NAME}},
    { AP_HTTPMAIL_DOMAIN_MSN, _T("Domain is MSN.com"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_HTTPMAIL_POLL, _T("HTTPMail Polling"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_HTTPMAIL_ADURL, _T("AdBar Url"), NOFLAGS, {0, 0}, {0, INTERNET_MAX_URL_LENGTH}},
    { AP_HTTPMAIL_SHOW_ADBAR, _T("ShowAdBar"), PF_DEFAULT, {TRUE, 0}, {0, 1}},
    { AP_HTTPMAIL_MINPOLLINGINTERVAL, _T("MinPollingInterval"), PF_NOPERSIST | PF_DEFAULT, {0, sizeof(ULARGE_INTEGER)}, {0, 0}},
    { AP_HTTPMAIL_GOTPOLLINGINTERVAL, _T("GotPollingInterval"), PF_NOPERSIST | PF_DEFAULT, {FALSE, 0}, {0, 1}},
    { AP_HTTPMAIL_LASTPOLLEDTIME, _T("LastPolledTime"), PF_NOPERSIST | PF_DEFAULT, {0, sizeof(ULARGE_INTEGER)}, {0, 0}},
    { AP_HTTPMAIL_ROOTTIMESTAMP, _T("RootTimeStamp"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_HTTPMAIL_ROOTINBOXTIMESTAMP, _T("RootInboxTimeStamp"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_HTTPMAIL_INBOXTIMESTAMP, _T("InboxTimeStamp"), NOFLAGS, {0, 0}, {0, 0}},
};

// Number of properties
const int NUM_ACCT_PROPS = ARRAYSIZE(g_rgAcctPropSet);

// Use in RegisterWindowMessage
#define ACCTMAN_NOTIF_WMSZ _T("## Athena_Account_Manager_Notification_Message ##")
UINT g_uMsgAcctManNotify = 0;

// -----------------------------------------------------------------------------
// Prototypes
// -----------------------------------------------------------------------------
VOID    AcctUtil_PostNotification(DWORD dwAN, ACTX *pactx);
static  VOID DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb);
static  VOID EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb);

// -----------------------------------------------------------------------------
// Export account manager creation function
// -----------------------------------------------------------------------------
IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&g_csAcctMan);

    // Init
    *ppAccountManager = NULL;

    // If there is already a global account manager, lets use it
    if (NULL == g_pAcctMan)
    {
        // Create a new one
        g_pAcctMan = new CAccountManager();
        if (NULL == g_pAcctMan)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        // Set Return
        *ppAccountManager = g_pAcctMan;
    }

    // Otherwise, addref the global
    else
    {
        // Return Global
        *ppAccountManager = g_pAcctMan;
        (*ppAccountManager)->AddRef();
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csAcctMan);

    // Done
    return hr;
}


// -----------------------------------------------------------------------------
// CAccountManager::CAccountManager
// -----------------------------------------------------------------------------
CAccountManager::CAccountManager(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pAcctPropSet = NULL;
    m_ppAdviseAccounts = NULL;
    m_cAdvisesAllocated = 0;
    m_pAccounts = NULL;
    m_cAccounts = 0;
    m_uMsgNotify = 0;
    m_fInit = FALSE;
    m_fOutlook = FALSE;
    m_fInitCalled = FALSE;
    m_fNoModifyAccts = FALSE;
    m_hkey = HKEY_CURRENT_USER;
    ZeroMemory(&m_rgAccountInfo, sizeof(m_rgAccountInfo));
    InitializeCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CAccountManager::~CAccountManager
// -----------------------------------------------------------------------------
CAccountManager::~CAccountManager()
{
    EnterCriticalSection(&g_csAcctMan);
    if (this == g_pAcctMan)
        g_pAcctMan = NULL;
    LeaveCriticalSection(&g_csAcctMan);
    Assert(m_cRef == 0);
    EnterCriticalSection(&m_cs);

    // release all advises
    for(INT i=0; i<m_cAdvisesAllocated; i++)
        {
        SafeRelease(m_ppAdviseAccounts[i]);
        }
    SafeMemFree(m_ppAdviseAccounts);

    SafeRelease(m_pAcctPropSet);
    AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);
    if (m_hkey != HKEY_CURRENT_USER)
        RegCloseKey(m_hkey);
    
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// -----------------------------------------------------------------------------
// CAccountManager::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IImnAccountManager
    if (IID_IImnAccountManager == riid)
        *ppv = (IImnAccountManager *)this;

    // IID_IImnAccountManager
    else if (IID_IImnAccountManager2 == riid)
        *ppv = (IImnAccountManager2 *)this;

    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccountManager::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CAccountManager::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccountManager::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/*
    In addition to removing LDAP servers from the destination which have the same server as an account
    from the source, this code also assigns LDAP Server IDs to source accounts so that v4 will see
    them on uninstall.
*/
void ProcessLDAPs(HKEY hkeySrc, HKEY hkeyDestRoot, HKEY hkeyDestAccts)
{
    HKEY hkeySrcSub, hkeyDestSub;
    TCHAR szKeyName[MAX_PATH], szKeyName2[MAX_PATH];
    DWORD dwIndex = 0, dwIndex2;
    TCHAR szServer[CCHMAX_SERVER_NAME], szServer2[CCHMAX_SERVER_NAME];
    DWORD cb, dwServerID=0;
    BOOL fDelete;

    // Parameter Validation    
    Assert(hkeySrc);
    Assert(hkeyDestRoot);
    Assert(hkeyDestAccts);
    Assert(hkeyDestRoot != hkeyDestAccts);
    
    // Calculate the next available LDAP Server ID
    cb = sizeof(dwServerID);
    RegQueryValueEx(hkeyDestRoot, c_szServerID, 0, NULL, (LPBYTE)&dwServerID, &cb);

    // Enumerate all source accounts
    while (TRUE) 
    {
        if (ERROR_SUCCESS != RegEnumKey(hkeySrc, dwIndex++, szKeyName, ARRAYSIZE(szKeyName)))
            break;

        // Open the account
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeySrc, szKeyName, 0, KEY_READ, &hkeySrcSub)) 
        {
            // Get the server name
            cb = sizeof(szServer);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeySrcSub, c_szRegLDAPSrv, 0, NULL, (LPBYTE)szServer, &cb))
            {
                dwIndex2 = 0;
                
                // Scan the destination for conflicts
                while (TRUE)
                {
                    if (ERROR_SUCCESS != RegEnumKey(hkeyDestAccts, dwIndex2++, szKeyName2, ARRAYSIZE(szKeyName2)))
                        break;

                    // Open an account
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyDestAccts, szKeyName2, 0, KEY_READ, &hkeyDestSub))
                    {
                        // Does it conflict?
                        fDelete = FALSE;

                        cb = sizeof(szServer2);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeyDestSub, c_szRegLDAPSrv, 0, NULL, (LPBYTE)szServer2, &cb))
                        {
                            fDelete = !lstrcmpi(szServer, szServer2);
                        }

                        RegCloseKey(hkeyDestSub);
                        
                        if (fDelete)
                            SHDeleteKey(hkeyDestAccts, szKeyName2);
                    }
                }

                // Invent a server id for this account
                if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDestAccts, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                                    &hkeyDestSub, &cb))
                {
                    RegSetValueEx(hkeyDestSub, c_szLDAPSrvID, 0, REG_DWORD, (LPBYTE)&dwServerID, sizeof(dwServerID));
                    dwServerID++;
                    RegCloseKey(hkeyDestSub);
                }
            }
            RegCloseKey(hkeySrcSub);
        }
    }

    // Update the Server ID count
    RegSetValueEx(hkeyDestRoot, c_szServerID, 0, REG_DWORD, (LPBYTE)&dwServerID, sizeof(dwServerID));
}


void InitializeUser(HKEY hkey, LPCSTR pszUser)
{
    HKEY hkeySrc, hkeyDestRoot, hkeyDestAccts;
    DWORD dwDisp, dwVerMaster=1, dwVerIdentity = 0, cb;
    DWORD dwType, dwVerNTDSMaster=0, dwVerNTDSIdentity=0;
    
    // Open / Create IAM
    if (ERROR_SUCCESS == RegCreateKeyEx(hkey, c_szInetAcctMgrRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
                                        &hkeyDestRoot, &dwDisp))
    {
        // Open / Create accounts key
        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDestRoot, c_szAccounts, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
                                            &hkeyDestAccts, &dwDisp))
        {
            // Open Source key            
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegPreConfigAccts, 0, KEY_READ, &hkeySrc))
            {
                // Read the current user's version
                cb = sizeof(dwVerIdentity);
                RegQueryValueEx(hkeyDestAccts, c_szVerStamp, 0, &dwType, (LPBYTE)&dwVerIdentity, &cb);

                // Could accidentally be a string, if so, treat as 0
                if (REG_DWORD != dwType)
                    dwVerIdentity = 0;
            
                // Grab the master version (defaults to 1)
                cb = sizeof(dwVerMaster);
                RegQueryValueEx(hkeySrc, c_szVerStamp, 0, &dwType, (LPBYTE)&dwVerMaster, &cb);

                // Could accidentally be a string, if so, treat as 1
                if (REG_DWORD != dwType)
                    dwVerMaster = 1;

                // Grab the master NTDS version (defaults to 0)
                cb = sizeof(dwVerNTDSMaster);
                if ((ERROR_SUCCESS == RegQueryValueEx(hkeySrc, c_szVerStampNTDS, 0, &dwType, (LPBYTE)&dwVerNTDSMaster, &cb)) && dwVerNTDSMaster)
                {
                    // Read the current user's NTDS settings version
                    cb = sizeof(dwVerNTDSIdentity);
                    RegQueryValueEx(hkeyDestAccts, c_szVerStampNTDS, 0, &dwType, (LPBYTE)&dwVerNTDSIdentity, &cb);
                }

                // Update the Preconfig accounts if there are newer ones available
                if ((dwVerIdentity < dwVerMaster) || (dwVerNTDSIdentity < dwVerNTDSMaster))
                {
                    // Copy in preconfigured accounts, blowing away dest conflicts
                    // $$$Review: Could do with some optimization...
                    ProcessLDAPs(hkeySrc, hkeyDestRoot, hkeyDestAccts);
                    CopyRegistry(hkeySrc, hkeyDestAccts);

                    // Avoid doing this next run
                    RegSetValueEx(hkeyDestAccts, c_szVerStamp, 0, REG_DWORD, (LPBYTE)&dwVerMaster, cb);
                }
            
                RegCloseKey(hkeySrc);
            }

            // Apply Shared Accounts
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedAccts, 0, KEY_READ, &hkeySrc))
            {
                CopyRegistry(hkeySrc, hkeyDestAccts);
                RegCloseKey(hkeySrc);
            }

            RegCloseKey(hkeyDestAccts);
        }

        RegCloseKey(hkeyDestRoot);
    }
}


STDMETHODIMP CAccountManager::Init(IImnAdviseMigrateServer *pMigrateServerAdvise)
    {
    return(InitEx(pMigrateServerAdvise, ACCT_INIT_ATHENA));
    }

STDMETHODIMP CAccountManager::InitEx(IImnAdviseMigrateServer *pMigrateServerAdvise, DWORD dwFlags)
    {
    HRESULT hr;
    char sz[MAX_PATH];
    DWORD cb, type;

    if (!!(dwFlags & ACCT_INIT_OUTLOOK))
        {
        cb = sizeof(sz);
        if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szInetAcctMgrRegKey, c_szRegOutlook, &type, (LPVOID)sz, &cb))
            return(E_FAIL);
        m_fOutlook = TRUE;
        }
    else
        {
        lstrcpy(sz, c_szInetAcctMgrRegKey);
        
        // Perform OE maintenance
        InitializeUser(HKEY_CURRENT_USER, c_szInetAcctMgrRegKey);
        }

    EnterCriticalSection(&m_cs);
    m_fInitCalled = TRUE;

    if (m_fInit)
        hr = S_OK;
    else
        hr = IInit(pMigrateServerAdvise, HKEY_CURRENT_USER, sz, dwFlags);

    LeaveCriticalSection(&m_cs);

    return(hr);
    }


STDMETHODIMP CAccountManager::InitUser(IImnAdviseMigrateServer *pMigrateServerAdvise, REFGUID rguidID, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    HKEY hkey;
    DWORD cb;
    DWORD dwDisp;
    IUserIdentityManager *pIdentMan;
    IUserIdentity *pIdentity;
    IUserIdentity *pIdentity2;
    BOOL fInitCalled;
    GUID guid;
    LONG lErr;

    if (dwFlags)
        return TrapError(E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);
    // Raid 44928 - don't allow InitUser to blow away account settings if the account manager  
    // has already been initialized.  This should not be an issue when the single instance
    // problem is solved.
    fInitCalled = m_fInitCalled;
    LeaveCriticalSection(&m_cs);
    
    if (fInitCalled)
        return S_AlreadyInitialized;

    if (SUCCEEDED(CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pIdentMan)))
    {
        Assert(pIdentMan);
        
        if (SUCCEEDED(hr = pIdentMan->GetIdentityByCookie((GUID*)&rguidID, &pIdentity)))
        {
            Assert(pIdentity);
            
            // Use the cookie as reported by the Identity in case caller used a UID_GIBC_... value
            if (SUCCEEDED(hr = pIdentity->GetCookie(&guid)))
            {
                // Thread Safety - don't leave this function without Leaving the CS!
                EnterCriticalSection(&g_csAcctMan);

                // Have we already read the cached value at some point?
                if (!g_fCachedGUID)
                {
                    // Examine the value in the registry
                    lErr = RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegAccounts, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                                 KEY_READ | KEY_WRITE, NULL, &hkey, NULL);
                    hr = HRESULT_FROM_WIN32(lErr);
                    if (SUCCEEDED(hr))
                    {
                        cb = sizeof(g_guidCached);
                        if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szAssocID, 0, &dwDisp, (LPBYTE)&g_guidCached, &cb))
                        {
                            // Couldn't read it, need to create it from Default User GUID
                            if (IsEqualGUID(rguidID, UID_GIBC_DEFAULT_USER))
                                // Save the trip if we can
                            {
                                g_guidCached = guid;
                                g_fCachedGUID = TRUE;
                            }
                            else if (SUCCEEDED(hr = pIdentMan->GetIdentityByCookie((GUID*)&UID_GIBC_DEFAULT_USER, &pIdentity2)))
                            {
                                Assert(pIdentity2);

                                if (SUCCEEDED(hr = pIdentity2->GetCookie(&g_guidCached)))
                                    g_fCachedGUID = TRUE;

                                pIdentity2->Release();
                            }
                        }
                        else
                        {
                            AssertSz(REG_BINARY == dwDisp, "Account Manager: Cached GUID format is incorrect!");
                            g_fCachedGUID = TRUE;
                        }

                        // Write the value out if we have it
                        if (g_fCachedGUID)
                        {
                            lErr = RegSetValueEx(hkey, c_szAssocID, 0, REG_BINARY, (LPBYTE)&g_guidCached, sizeof(g_guidCached));
                            hr = HRESULT_FROM_WIN32(lErr);
                        }

                        RegCloseKey(hkey);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Safe to carry on with the comparison
                    if (IsEqualGUID(g_guidCached, guid))
                    {
                        // Redirect to old HKCU\SW\MS\IAM Place
                        hkey = HKEY_CURRENT_USER;
                    }
                    else
                    {
                        // Try to use the identity's hkey
                        hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, &hkey);
                    }
                }


                // Thread Safety
                LeaveCriticalSection(&g_csAcctMan);
            }

            pIdentity->Release();
        }

        pIdentMan->Release();
    }
    else
    {
        hr = S_OK; //TrapError(E_NoIdentities);
        hkey = HKEY_CURRENT_USER;
    }
    // Only continue if we have been successful so far
    if (SUCCEEDED(hr))
    {
        // Perform OE maintenance
        InitializeUser(hkey, c_szInetAcctMgrRegKey);

        EnterCriticalSection(&m_cs);

        // Note: AcctManager will free hkey as long as it is not HKCU
        hr = IInit(pMigrateServerAdvise, hkey, c_szInetAcctMgrRegKey, dwFlags);

        LeaveCriticalSection(&m_cs);
    }

    return(hr);
}

HRESULT CAccountManager::IInit(IImnAdviseMigrateServer *pMigrateServerAdvise, HKEY hkey, LPCSTR pszSubKey, DWORD dwFlags)
    {
    DWORD cb, type, dw;
    HRESULT hr = S_OK;

    Assert(pszSubKey != NULL);

    if (!m_fInit)
        {
        // These should be null
        Assert(m_pAcctPropSet == NULL && m_pAccounts == NULL && m_cAccounts == 0);

        cb = sizeof(DWORD);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegValNoModifyAccts, &type, &dw, &cb) &&
            dw != 0)
            m_fNoModifyAccts = TRUE;

        // Lets create the property set object used by account objects
        m_pAcctPropSet = new CPropertySet;
        if (m_pAcctPropSet == NULL)
            {
            hr = TRAPHR(E_OUTOFMEMORY);
            goto exit;
            }

        // Init the property set
        CHECKHR(hr = m_pAcctPropSet->HrInit(g_rgAcctPropSet, NUM_ACCT_PROPS));

        // Init the account information array structure
        m_rgAccountInfo[ACCT_NEWS].pszDefRegValue = (LPTSTR)c_szDefaultNewsAccount;
        m_rgAccountInfo[ACCT_MAIL].pszDefRegValue = (LPTSTR)c_szDefaultMailAccount;
        m_rgAccountInfo[ACCT_DIR_SERV].pszDefRegValue = (LPTSTR)c_szDefaultLDAPAccount;
        }

    if (m_hkey != HKEY_CURRENT_USER)
        RegCloseKey(m_hkey);

    m_hkey = hkey;
    lstrcpy(m_szRegRoot, pszSubKey);
    wsprintf(m_szRegAccts, c_szPathFileFmt, m_szRegRoot, c_szAccountsKey);

    // Load the account list
    CHECKHR(hr = LoadAccounts());

    if (!m_fInit)
        {
        Assert(m_uMsgNotify == 0);

        // Create notify message
        if (g_uMsgAcctManNotify == 0)
            g_uMsgAcctManNotify = RegisterWindowMessage(ACCTMAN_NOTIF_WMSZ);

        // We don't start watching for notifications until we'ev migrated and loaded the accounts
        m_uMsgNotify = g_uMsgAcctManNotify;
        }

    // Were inited
    m_fInit = TRUE;

exit:
    // If we failed, free some stuff
    if (FAILED(hr))
        {
        if (!m_fInit)
            SafeRelease(m_pAcctPropSet);
        }

    return hr;
    }

// -----------------------------------------------------------------------------
// CAccountManager::Advise - Internal way to notify of new/deleted/changed accts
// -----------------------------------------------------------------------------
VOID CAccountManager::Advise(DWORD dwAction, ACTX* pactx)
{
    // Locals
    CAccount        *pAccount=NULL;
    ULONG            i=0;
    HRESULT          hr;
    BOOL             fExist=FALSE,
                     fDefault=FALSE;
    LPACCOUNT        pAccountsOld;
    ACCTTYPE         AcctType, at;
    ACTX             actx;
    LPTSTR           pszID;

    // Critsect
    EnterCriticalSection(&m_cs);
    m_uMsgNotify = 0;
    Assert(dwAction);
    Assert(pactx);

    AcctType = ACCT_UNDEFINED;

    // Only if we have a pszAccount
    pszID = pactx->pszAccountID;
    if (pszID)
    {
        // Lets get the index of this account
        for (i=0; i<m_cAccounts; i++)
        {
            if (lstrcmpi(m_pAccounts[i].szID, pszID) == 0)
            {
                fExist = TRUE;
                break;
            }
        }

        // Is this a default account ???
        if (fExist)
        {
            at = m_pAccounts[i].AcctType;
            if (lstrcmpi(m_rgAccountInfo[at].szDefaultID, pszID) == 0)
                fDefault = TRUE;

            AcctType = m_pAccounts[i].AcctType;
            Assert(AcctType < ACCT_LAST);
        }
    }

    // Handle lParam
    switch(dwAction)
    {
    // ----------------------------------------------------------------------------
    case AN_DEFAULT_CHANGED:
        GetDefaultAccounts();
        break;

    // ----------------------------------------------------------------------------
    case AN_ACCOUNT_DELETED:
        Assert(pszID != NULL);

        // If we didn't find it, bail
        if (!fExist)
        {
            Assert(FALSE);
            break;
        }

        // Release current account object
        SafeRelease(m_pAccounts[i].pAccountObject);

        // Memalloc
        pAccountsOld = m_pAccounts;
        if (FAILED(HrAlloc((LPVOID *)&m_pAccounts, (m_cAccounts - 1) * sizeof(ACCOUNT))))
        {
            m_cAccounts++;
            Assert(FALSE);
            break;
        }

        // Copy everything but i
        CopyMemory(m_pAccounts, pAccountsOld, i * sizeof(ACCOUNT));
        CopyMemory(m_pAccounts + i, pAccountsOld + i + 1, (m_cAccounts - (i + 1)) * sizeof(ACCOUNT));

        // Delete old accounts array
        SafeMemFree(pAccountsOld);

        // Lets duplicate the array - 1
        m_cAccounts--;

        m_rgAccountInfo[AcctType].cAccounts--;

        // Reset Default ???
        if (fDefault)
        {
            // Lets find first SrvType and set it as the default
            for (i=0; i<m_cAccounts; i++)
            {
                if (m_pAccounts[i].AcctType == AcctType)
                {
                    Assert(m_pAccounts[i].pAccountObject);
                    if (m_pAccounts[i].pAccountObject)
                        m_pAccounts[i].pAccountObject->SetAsDefault();
                    break;
                }
            }
        }
        break;

    // ----------------------------------------------------------------------------
    case AN_ACCOUNT_CHANGED:
        Assert(pszID != NULL);

        // If we didn't find it, bail
        if (!fExist)
        {
            Assert(FALSE);
            break;
        }

        // Lets release the old account object
        SafeRelease(m_pAccounts[i].pAccountObject);

        // Create a new account object
        if (FAILED(CreateAccountObject(AcctType, (IImnAccount **)&pAccount)))
        {
            Assert(FALSE);
            break;
        }

        // Lets open the new account
        if (FAILED(pAccount->Open(m_hkey, m_szRegAccts, pszID)))
        {
            Assert(FALSE);
            break;
        }

        // Save the new account
        pAccount->GetServerTypes(&m_pAccounts[i].dwSrvTypes);
        m_pAccounts[i].dwServerId = 0;
        if (m_pAccounts[i].AcctType == ACCT_DIR_SERV)
            pAccount->GetPropDw(AP_LDAP_SERVER_ID, &m_pAccounts[i].dwServerId);
        m_pAccounts[i].pAccountObject = pAccount;
        m_pAccounts[i].pAccountObject->AddRef();

        // Reset Default ???
        if (fDefault)
            m_pAccounts[i].pAccountObject->SetAsDefault();
        break;

    // ----------------------------------------------------------------------------
    case AN_ACCOUNT_ADDED:
        Assert(pszID != NULL);

        // If we didn't find it, bail
        if (fExist)
        {
            AssertSz(FALSE, "An account was added with a duplicate name.");
            break;
        }

        // Lets Open the new account
        if (FAILED(ICreateAccountObject(ACCT_UNDEFINED, (IImnAccount **)&pAccount)))
        {
            Assert(FALSE);
            break;
        }

        // Lets open the new account
        if (FAILED(pAccount->Open(m_hkey, m_szRegAccts, pszID)))
        {
            Assert(FALSE);
            break;
        }

        // Realloc my array
        if (FAILED(HrRealloc((LPVOID *)&m_pAccounts, (m_cAccounts + 1) * sizeof(ACCOUNT))))
        {
            Assert(FALSE);
            break;
        }

        // Increment the number of accounts
        m_cAccounts++;

        // Add this account into m_cAccounts - 1
        lstrcpy(m_pAccounts[m_cAccounts-1].szID, pszID);
        pAccount->GetAccountType(&m_pAccounts[m_cAccounts-1].AcctType);
        pAccount->GetServerTypes(&m_pAccounts[m_cAccounts-1].dwSrvTypes);
        m_pAccounts[m_cAccounts-1].dwServerId = 0;
        if (m_pAccounts[m_cAccounts-1].AcctType == ACCT_DIR_SERV)
            pAccount->GetPropDw(AP_LDAP_SERVER_ID, &m_pAccounts[m_cAccounts-1].dwServerId);
        m_pAccounts[m_cAccounts-1].pAccountObject = pAccount;
        m_pAccounts[m_cAccounts-1].pAccountObject->AddRef();

        AcctType = m_pAccounts[m_cAccounts-1].AcctType;
        Assert(AcctType < ACCT_LAST);

        if (m_rgAccountInfo[AcctType].cAccounts == 0)
            {
            hr = SetDefaultAccount(AcctType, pszID, TRUE);
            Assert(SUCCEEDED(hr));
            }

        m_rgAccountInfo[AcctType].cAccounts++;
        break;
    }

    // Cleanup
    SafeRelease(pAccount);

    // Call client advises
    if(m_ppAdviseAccounts)
        {
        for(INT i=0; i<m_cAdvisesAllocated; i++)
            {
            if(NULL != m_ppAdviseAccounts[i])
                {
                m_ppAdviseAccounts[i]->AdviseAccount(dwAction, pactx);
                }
            }
        }

    // Critsect
    m_uMsgNotify = g_uMsgAcctManNotify;
    LeaveCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CAccountManager::FProcessNotification - returns TRUE if window message was
// processed as a notification
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::ProcessNotification(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr=S_OK;

    // [PaulHi] 5/3/99  Raid 77490.  Normally this would be the right thing to do but this
    // is causing a thread hanging bug under Win9X.  The real problem is the CAccountManager::Advise()
    // that calls SetAsDefault, which in turn recursively calls Notification again.  But sincce
    // this was an late code addition the safest fix is to undo it.
//    EnterCriticalSection(&m_cs);

    // If not my window message, return FALSE
    if (m_uMsgNotify != uMsg)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Disable notifications
    m_uMsgNotify = 0;

    // Handle lParam
    switch(wParam)
    {
    // Yes this may look bad, or slow, but it is the safest thing to do. This is the
    // best way to do this because we basically abandon all account objects and
    // refresh our list. If someone has an enumeror on the accounts or has addref
    // account objects, they will be safe. I can not modify internal account objects
    // because someone may have a copy of it and if the are setting properties on it,
    // and I reload the properties, we will have a problem.
    case AN_DEFAULT_CHANGED:
        if ((DWORD)lParam != GetCurrentProcessId())
            GetDefaultAccounts();
        break;

    case AN_ACCOUNT_DELETED:
    case AN_ACCOUNT_ADDED:
    case AN_ACCOUNT_CHANGED:
        if ((DWORD)lParam != GetCurrentProcessId())
            LoadAccounts();
        break;
    }

    // Re-enable notifications
    m_uMsgNotify = g_uMsgAcctManNotify;

    hr = S_OK;

exit:
    // Raid 77490.  See above comment.
//    LeaveCriticalSection(&m_cs);
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::GetDefaultAccounts
// -----------------------------------------------------------------------------
VOID CAccountManager::GetDefaultAccounts(VOID)
    {
    ACCTINFO *pInfo;
    ULONG   at, cb;
    HKEY    hReg;

    // Open or Create root server key
    if (RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hReg, NULL) == ERROR_SUCCESS)
        {
        for (at = 0, pInfo = m_rgAccountInfo; at < ACCT_LAST; at++, pInfo++)
            {
            *pInfo->szDefaultID = 0;
            pInfo->fDefaultKnown = FALSE;

            if (pInfo->pszDefRegValue != NULL)
                {
                cb = sizeof(pInfo->szDefaultID);
                if (RegQueryValueEx(hReg, pInfo->pszDefRegValue, 0, NULL, (LPBYTE)pInfo->szDefaultID, &cb) == ERROR_SUCCESS)
                    {
                    if (FIsEmptyA(pInfo->szDefaultID))
                        *pInfo->szDefaultID = 0;
                    else
                        pInfo->fDefaultKnown = TRUE;
                    }
                }
            }

        RegCloseKey(hReg);
        }
    }

STDMETHODIMP CAccountManager::GetIncompleteAccount(ACCTTYPE AcctType, LPSTR pszAccountId, ULONG cchMax)
{
    DWORD type;
    HRESULT hr = S_FALSE;
    
    Assert(AcctType == ACCT_MAIL || AcctType == ACCT_NEWS);
    Assert(pszAccountId != NULL);

    if (ERROR_SUCCESS == SHGetValue(m_hkey, m_szRegAccts,
                                    AcctType == ACCT_MAIL ? c_szIncompleteMailAcct : c_szIncompleteNewsAcct,
                                    &type, (LPBYTE)pszAccountId, &cchMax) &&
        cchMax > 0)
    {
        hr = S_OK;
    }

    return(hr);
}

STDMETHODIMP CAccountManager::SetIncompleteAccount(ACCTTYPE AcctType, LPCSTR pszAccountId)
{
    Assert(AcctType == ACCT_MAIL || AcctType == ACCT_NEWS);

    if (pszAccountId == NULL)
    {
        SHDeleteValue(m_hkey, m_szRegAccts, AcctType == ACCT_MAIL ? c_szIncompleteMailAcct : c_szIncompleteNewsAcct);
    }
    else
    {
        SHSetValue(m_hkey, m_szRegAccts,
                    AcctType == ACCT_MAIL ? c_szIncompleteMailAcct : c_szIncompleteNewsAcct,
                    REG_SZ, pszAccountId, lstrlen(pszAccountId) + 1);
    }

    return(S_OK);
}

// -----------------------------------------------------------------------------
// CAccountManager::CreateAccountObject
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::CreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount)
    {
    if (AcctType < 0 || AcctType >= ACCT_LAST)
        return(E_INVALIDARG);

    return(ICreateAccountObject(AcctType, ppAccount));
    }

HRESULT CAccountManager::ICreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount)
{
    // Locals
    HRESULT             hr=S_OK;
    CAccount           *pAccount=NULL;

    // Check some state
    Assert(ppAccount && m_pAcctPropSet);
    if (ppAccount == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Allocate the object
    pAccount = new CAccount(AcctType);
    if (pAccount == NULL)
    {
        hr = TRAPHR(E_OUTOFMEMORY);
        goto exit;
    }

    // Init it
    CHECKHR(hr = pAccount->Init(this, m_pAcctPropSet));

    // Success
    *ppAccount = (IImnAccount *)pAccount;

exit:
    // Failed
    if (FAILED(hr))
    {
        SafeRelease(pAccount);
        *ppAccount = NULL;
    }

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::LoadAccounts
// -----------------------------------------------------------------------------
HRESULT CAccountManager::LoadAccounts(VOID)
    {
    // Locals
    ACCOUNT         *pAcct;
    DWORD           cbMaxSubKeyLen, cb, i, at, dwMaxId, cAccounts;
    LONG            lResult;
    HRESULT         hr=S_OK;
    HKEY            hRegRoot, hReg=NULL;

    // Critsect
    EnterCriticalSection(&m_cs);

    // Free current account list and assume news and mail are not configured
    AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);
    dwMaxId = 0;

    // Init account info
    for (at=0; at<ACCT_LAST; at++)
        {
        m_rgAccountInfo[at].pszFirstAccount = NULL;
        m_rgAccountInfo[at].cAccounts = 0;
        }

    // Load Default account information
    GetDefaultAccounts();

    // Open or Create root server key
    if (RegCreateKeyEx(m_hkey, m_szRegAccts, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, NULL, &hReg, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        goto exit;
        }

    // Enumerate keys
    if (RegQueryInfoKey(hReg, NULL, NULL, 0, &cAccounts, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL,
                        NULL, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegQueryInfoKeyFailed);
        goto exit;
        }

    // No accounts ?
    if (cAccounts == 0)
        goto done;

    // quickcheck
    Assert(cbMaxSubKeyLen < CCHMAX_ACCOUNT_NAME);

    // Allocate the accounts array
    CHECKHR(hr = HrAlloc((LPVOID *)&m_pAccounts, sizeof(ACCOUNT) * cAccounts));

    // Zero init
    ZeroMemory(m_pAccounts, sizeof(ACCOUNT) * cAccounts);

    // Start Enumerating the keys
    for (i = 0; i < cAccounts; i++)
        {
        pAcct = &m_pAccounts[m_cAccounts];

        // Enumerate Friendly Names
        cb = sizeof(pAcct->szID);
        lResult = RegEnumKeyEx(hReg, i, pAcct->szID, &cb, 0, NULL, NULL, NULL);

        // No more items
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error, lets move onto the next account
        if (lResult != ERROR_SUCCESS)
            {
            Assert(FALSE);
            continue;
            }

        // Create the account object
        CHECKHR(hr = ICreateAccountObject(ACCT_UNDEFINED, &pAcct->pAccountObject));

        // Open the account
        if (FAILED(((CAccount *)pAcct->pAccountObject)->Open(m_hkey, m_szRegAccts, pAcct->szID)) ||
            FAILED(pAcct->pAccountObject->GetAccountType(&pAcct->AcctType)) ||
            FAILED(pAcct->pAccountObject->GetServerTypes(&pAcct->dwSrvTypes)))
            {
            pAcct->pAccountObject->Release();
            pAcct->pAccountObject = NULL;

            continue;
            }

        // Update account info
        at = pAcct->AcctType;
        Assert(at < ACCT_LAST);

        pAcct->dwServerId = 0;
        if (at == ACCT_DIR_SERV)
            {
            pAcct->pAccountObject->GetPropDw(AP_LDAP_SERVER_ID, &pAcct->dwServerId);

            if (pAcct->dwServerId > dwMaxId)
                dwMaxId = pAcct->dwServerId;
            }

        // Count servers
        m_rgAccountInfo[at].cAccounts++;

        // Have we found the first account yet ?
        if (!m_rgAccountInfo[at].pszFirstAccount)
            m_rgAccountInfo[at].pszFirstAccount = pAcct->szID;

        // Is this the default
        if (lstrcmpi(pAcct->szID, m_rgAccountInfo[at].szDefaultID) == 0)
            m_rgAccountInfo[at].fDefaultKnown = TRUE;

        m_cAccounts++;
        }

    // Update default accounts
    for (at=0; at<ACCT_LAST; at++)
        {
        // Doesn't have a default
        if (m_rgAccountInfo[at].pszDefRegValue == NULL)
            continue;

        // If default not found and we found a first account
        if (!m_rgAccountInfo[at].fDefaultKnown && m_rgAccountInfo[at].pszFirstAccount)
            {
            lstrcpyn(m_rgAccountInfo[at].szDefaultID, m_rgAccountInfo[at].pszFirstAccount, CCHMAX_ACCOUNT_NAME);

            if (SUCCEEDED(SetDefaultAccount((ACCTTYPE)at, m_rgAccountInfo[at].szDefaultID, FALSE)))
                m_rgAccountInfo[at].fDefaultKnown = TRUE;
            }
        }

done:
    dwMaxId++;
    // Open or Create root server key
    if (RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, NULL, &hRegRoot, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        }
    else
        {
        RegSetValueEx(hRegRoot, c_szRegServerID, 0, REG_DWORD, (LPBYTE)&dwMaxId, sizeof(DWORD));
        RegCloseKey(hRegRoot);
        }

exit:
    // Cleanup
    if (hReg)
        RegCloseKey(hReg);

    // If failed
    if (FAILED(hr))
        AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);

    // Critsect
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
    }

// -----------------------------------------------------------------------------
// CAccountManager::Enumerate
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::Enumerate(DWORD dwSrvTypes, IImnEnumAccounts **ppEnumAccounts)
    {
    return(IEnumerate(dwSrvTypes, 0, ppEnumAccounts));
    }

HRESULT CAccountManager::IEnumerate(DWORD dwSrvTypes, DWORD dwFlags, IImnEnumAccounts **ppEnumAccounts)
{
    // Locals
    HRESULT         hr=S_OK;
    CEnumAccounts  *pEnumAccounts=NULL;

    // Critsect
    EnterCriticalSection(&m_cs);

    // Check Parama
    if (ppEnumAccounts == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // No Accounts
    if (m_pAccounts == NULL || m_cAccounts == 0)
    {
        hr = TRAPHR(E_NoAccounts);
        goto exit;
    }

    // check that the flags make sense
    // can't have sorting by name and resolution id
    // can't have resolve flags with no ldap servers
    if ((!!(dwFlags & ENUM_FLAG_SORT_BY_NAME) &&
        !!(dwFlags & ENUM_FLAG_SORT_BY_LDAP_ID)) ||
        (!!(dwFlags & (ENUM_FLAG_RESOLVE_ONLY | ENUM_FLAG_SORT_BY_LDAP_ID)) &&
        dwSrvTypes != SRV_LDAP))
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Create the enumerator object
    pEnumAccounts = new CEnumAccounts(dwSrvTypes, dwFlags);
    if (pEnumAccounts == NULL)
    {
        hr = TRAPHR(E_OUTOFMEMORY);
        goto exit;
    }

    // Init the object
    CHECKHR(hr = pEnumAccounts->Init(m_pAccounts, m_cAccounts));

    // Set outbound point
    *ppEnumAccounts = (IImnEnumAccounts *)pEnumAccounts;

exit:
    // Failed
    if (FAILED(hr))
    {
        SafeRelease(pEnumAccounts);
        *ppEnumAccounts = NULL;
    }

    // Critsect
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::ValidateDefaultSendAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::ValidateDefaultSendAccount(VOID)
{
    // Locals
    IImnAccount     *pAccount=NULL;
    BOOL             fResetDefault=TRUE;
    ULONG            i;
    DWORD            dwSrvTypes;
    TCHAR            szServer[CCHMAX_SERVER_NAME];
    BOOL             fDefaultKnown=FALSE;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Open the default SMTP Account
    if (SUCCEEDED(GetDefaultAccount(ACCT_MAIL, &pAccount)))
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_SMTP_SERVER, szServer, ARRAYSIZE(szServer))) && !FIsEmptyA(szServer))
        {
            fResetDefault = FALSE;
            fDefaultKnown = TRUE;
        }
    }

    // Reset the default..
    if (fResetDefault)
    {
        // Loop Accounts until we find one that supports an smtp server
        for (i=0; i<m_cAccounts; i++)
        {
            if (m_pAccounts[i].pAccountObject != NULL &&
                m_pAccounts[i].AcctType == ACCT_MAIL &&
                SUCCEEDED(m_pAccounts[i].pAccountObject->GetServerTypes(&dwSrvTypes)))
            {
                // Supports SRV_SMTP
                if (dwSrvTypes & SRV_SMTP)
                {
                    // Lets make this dude the default
                    m_pAccounts[i].pAccountObject->SetAsDefault();

                    // We know the default
                    fDefaultKnown = TRUE;

                    // Were Done
                    break;
                }
            }
        }
    }

    // Unknown Default
    if (fDefaultKnown == FALSE)
    {
        m_rgAccountInfo[ACCT_MAIL].fDefaultKnown = FALSE;
        *m_rgAccountInfo[ACCT_MAIL].szDefaultID = _T('\0');
    }

    // Cleanup
    SafeRelease(pAccount);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// -----------------------------------------------------------------------------
// CAccountManager::GetDefaultAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::GetDefaultAccountName(ACCTTYPE AcctType, LPTSTR pszAccount, ULONG cchMax)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount     *pAcct = NULL;

    hr = GetDefaultAccount(AcctType, &pAcct);
    if (!FAILED(hr))
        {
        Assert(pAcct != NULL);
        hr = pAcct->GetPropSz(AP_ACCOUNT_NAME, pszAccount, cchMax);

        pAcct->Release();
        }

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::GetDefaultAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::GetDefaultAccount(ACCTTYPE AcctType, IImnAccount **ppAccount)
    {
    HRESULT         hr;
    ACCTINFO        *pinfo;
    ACCOUNT         *pAcct;
    ULONG           i;

    // Check Params
    Assert(AcctType >= 0 && AcctType < ACCT_LAST);
    if (ppAccount == NULL || AcctType >= ACCT_LAST)
        return(E_INVALIDARG);

    // Init
    *ppAccount = NULL;

    EnterCriticalSection(&m_cs);

    pinfo = &m_rgAccountInfo[AcctType];

    // Is default know for this account type
    if (!pinfo->fDefaultKnown)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Loop through accounts and try to find the default for AcctType
    for (i = 0, pAcct = m_pAccounts; i < m_cAccounts; i++, pAcct++)
        {
        // Match ?
        if (pAcct->AcctType == AcctType &&
            lstrcmpi(pAcct->szID, pinfo->szDefaultID) == 0)
            {
            // Better not be null
            Assert(pAcct->pAccountObject);

            // Copy and addref the account
            *ppAccount = pAcct->pAccountObject;
            (*ppAccount)->AddRef();
            hr = S_OK;
            goto exit;
            }
        }

    hr = E_FAIL;

exit:
    LeaveCriticalSection(&m_cs);
    return(hr);
    }

// -----------------------------------------------------------------------------
// CAccountManager::GetServerCount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::GetAccountCount(ACCTTYPE AcctType, ULONG *pcAccounts)
{
    // Check Params
    Assert(AcctType >= 0 && AcctType < ACCT_LAST);

    // Bad Param
    if (AcctType >= ACCT_LAST || !pcAccounts)
        return TRAPHR(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set
    *pcAccounts = m_rgAccountInfo[AcctType].cAccounts;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // return server count
    return S_OK;
}

// -----------------------------------------------------------------------------
// CAccountManager::FindAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::FindAccount(DWORD dwPropTag, LPCTSTR pszSearchData, IImnAccount **ppAccount)
{
    // Locals
    ACCOUNT         *pAcct;
    IImnAccount     *pAccount;
    HRESULT         hr=S_OK;
    LPTSTR          pszPropData=NULL;
    DWORD           cbAllocated=0,
                    cb;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check Params
    if (pszSearchData == NULL || ppAccount == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppAccount = NULL;

    // No Accounts
    if (m_pAccounts == NULL || m_cAccounts == 0)
    {
        hr = TRAPHR(E_NoAccounts);
        goto exit;
    }

    // Proptag better represent a string data type
    Assert(PROPTAG_TYPE(dwPropTag) == TYPE_STRING || PROPTAG_TYPE(dwPropTag) == TYPE_WSTRING);

    // Loop throug the servers
    for (i = 0, pAcct = m_pAccounts; i < m_cAccounts; i++, pAcct++)
    {
        // We should have an account object, but if not
        Assert(pAcct->pAccountObject != NULL);

        // Get the size of the property
        hr = pAcct->pAccountObject->GetProp(dwPropTag, NULL, &cb);
        if (FAILED(hr))
            continue;

        // Reallocate my data buffer ?
        if (cb > cbAllocated)
        {
            // Increment allocated
            cbAllocated = cb + 512;

            // Realloc
            CHECKHR(hr = HrRealloc((LPVOID *)&pszPropData, cbAllocated));
        }

        // Ok, get the data
        CHECKHR(hr = pAcct->pAccountObject->GetProp(dwPropTag, (LPBYTE)pszPropData, &cb));

        // Does this match
        if (lstrcmpi(pszPropData, pszSearchData) == 0)
        {
            m_pAccounts[i].pAccountObject->AddRef();
            *ppAccount = m_pAccounts[i].pAccountObject;

            goto exit;
        }
    }

    // We failed
    hr = TRAPHR(E_FAIL);

exit:
    // Clenaup
    SafeMemFree(pszPropData);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::AccountListDialog
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::AccountListDialog(HWND hwnd, ACCTLISTINFO *pinfo)
    {
    HRESULT hr;
    int iRet;
    ACCTDLGINFO adi;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    if (pinfo == NULL ||
        0 == pinfo->dwAcctFlags ||
        0 != (pinfo->dwAcctFlags & ~ACCT_FLAG_ALL) ||
        0 != (pinfo->dwFlags & ~(ACCTDLG_ALL)))
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    if (m_fNoModifyAccts)
        return(S_OK);

    InitCommonControlsEx(&icex);

    adi.AcctTypeInit = pinfo->AcctTypeInit;
    adi.dwAcctFlags = pinfo->dwAcctFlags;
    adi.dwFlags = pinfo->dwFlags;

    iRet = (int) DialogBoxParam(g_hInstRes, MAKEINTRESOURCE(iddManageAccounts), hwnd,
                    ManageAccountsDlgProc, (LPARAM)&adi);

    return((iRet == -1) ? E_FAIL : S_OK);
    }

// -----------------------------------------------------------------------------
// CAccountManager::Advise
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::Advise(
        IImnAdviseAccount *pAdviseAccount,
        DWORD* pdwConnection)
{
    Assert(pAdviseAccount);
    Assert(pdwConnection);

    INT                 nIndex = -1;
    HRESULT             hr = S_OK;

    // Critsect
    EnterCriticalSection(&m_cs);

    if(NULL != m_ppAdviseAccounts)
        {
        Assert(m_cAdvisesAllocated > 0);
        for(INT i=0; i<m_cAdvisesAllocated; ++i)
            {
            if(NULL == m_ppAdviseAccounts[i])
                {
                // unused slot - use this one.
                nIndex = i;
                break;
                }
            }
        }
    else
        {
        Assert(0 == m_cAdvisesAllocated);
        hr = HrAlloc((LPVOID *)&m_ppAdviseAccounts, 
                sizeof(IImnAdviseAccount*) * ADVISE_BLOCK_SIZE);
        if(FAILED(hr) || (NULL == m_ppAdviseAccounts))
            {
            goto Error;
            }

        ZeroMemory(m_ppAdviseAccounts, 
                sizeof(IImnAdviseAccount*) * ADVISE_BLOCK_SIZE);

        m_cAdvisesAllocated = ADVISE_BLOCK_SIZE;
        nIndex = 0;
        }

    if(nIndex < 0)  // array is not big enough...
        {
        INT nNewSize = m_cAdvisesAllocated + ADVISE_BLOCK_SIZE;

        // reality check - connection will only support 64K advises
        Assert(nNewSize <= MAX_INDEX);

        hr = HrRealloc((LPVOID *)&m_ppAdviseAccounts, 
                sizeof(IImnAdviseAccount*) * nNewSize);
        if(FAILED(hr))
            {
            goto Error;
            }

        ZeroMemory(&m_ppAdviseAccounts[m_cAdvisesAllocated], 
                sizeof(IImnAdviseAccount*) * ADVISE_BLOCK_SIZE);

        nIndex = m_cAdvisesAllocated;
        m_cAdvisesAllocated = nNewSize;
        }

    Assert(m_ppAdviseAccounts);
    pAdviseAccount->AddRef();
    Assert(IS_VALID_INDEX(nIndex));
    m_ppAdviseAccounts[nIndex] = pAdviseAccount;
    *pdwConnection = CONNECTION_FROM_INDEX(nIndex);

Out:
    // Critsect
    LeaveCriticalSection(&m_cs);
    return hr;

Error:
    *pdwConnection = 0;
    goto Out;
}


// -----------------------------------------------------------------------------
// CAccountManager::Unadvise
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::Unadvise(DWORD dwConnection)
{
    HRESULT hr = S_OK;
    INT nIndex = -1;

    // Critsect
    EnterCriticalSection(&m_cs);

    if(IS_VALID_CONNECTION(dwConnection))
        {
        nIndex = INDEX_FROM_CONNECTION(dwConnection);
        Assert(IS_VALID_INDEX(nIndex));
        }

    if((nIndex >= 0) && (nIndex < m_cAdvisesAllocated) &&
            (NULL != m_ppAdviseAccounts[nIndex]))
        {
        IImnAdviseAccount* paa = m_ppAdviseAccounts[nIndex];
        m_ppAdviseAccounts[nIndex] = NULL;
        paa->Release();
        }
    else
        {
        AssertSz(fFalse, "CAccountManager::Unadvise - Bad Connection!");
        hr = E_INVALIDARG;
        }

    // Critsect
    LeaveCriticalSection(&m_cs);
    return hr;
}

// -----------------------------------------------------------------------------
// CAccount::CAccount
// -----------------------------------------------------------------------------
CAccount::CAccount(ACCTTYPE AcctType)
{
    m_cRef = 1;
    m_pAcctMgr = NULL;
    m_fAccountExist = FALSE;
    m_AcctType = AcctType;
    m_dwSrvTypes = 0;
    *m_szID = 0;
    *m_szName = 0;
    m_hkey = NULL;
    *m_szKey = 0;
    m_fNoModifyAccts = FALSE;
}

// -----------------------------------------------------------------------------
// CAccount::~CAccount
// -----------------------------------------------------------------------------
CAccount::~CAccount(void)
{
    ReleaseObj(m_pContainer);
}

// -----------------------------------------------------------------------------
// CAccount::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_IPropertyContainer
    else if (IID_IPropertyContainer == riid)
        *ppv = (IPropertyContainer *)this;

    // IID_ImnAccount
    else if (IID_IImnAccount == riid)
        *ppv = (IImnAccount *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
    }
    else
    {
        // No Interface
        hr = TRAPHR(E_NOINTERFACE);
    }

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccount::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccount::AddRef(VOID)
{
    m_pAcctMgr->AddRef();
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CAccount::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccount::Release(VOID)
{
    ULONG   cRef = --m_cRef;
    
    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    m_pAcctMgr->Release();

    return cRef;
}

// -----------------------------------------------------------------------------
// CAccount::SetAsDefault
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::Exist(VOID)
{
    return m_fAccountExist ? S_OK : S_FALSE;
}

// -----------------------------------------------------------------------------
// CAccount::SetAsDefault
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetAsDefault(VOID)
    {
    HRESULT hr;
    
    if (m_fAccountExist)
        hr = m_pAcctMgr->SetDefaultAccount(m_AcctType, m_szID, TRUE);
    else
        hr = E_FAIL;

    return(hr);
    }

// -----------------------------------------------------------------------------
// CAccount::Delete
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::Delete(VOID)
    {
    DWORD           dwSrvTypes;
    HRESULT         hr;

    // Should already exist
    Assert(m_fAccountExist);

    if (SUCCEEDED(hr = GetServerTypes(&dwSrvTypes)) &&
        SUCCEEDED(hr = m_pAcctMgr->DeleteAccount(m_szID, m_szName, m_AcctType, dwSrvTypes)))
        {
        // Doesn't exist anymore
        m_fAccountExist = FALSE;
        }

    return(hr);
    }

STDMETHODIMP CAccount::GetAccountType(ACCTTYPE *pAcctType)
    {
    HRESULT hr;

    if (pAcctType == NULL)
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    Assert(m_AcctType >= 0 && m_AcctType < ACCT_LAST);
    *pAcctType = m_AcctType;

    return(S_OK);
    }

// -----------------------------------------------------------------------------
// CAccount::DwGetServerTypes
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetServerTypes(DWORD *pdwSrvTypes)
{
    // Locals
    DWORD           dwSrvTypes=0;
    TCHAR           szServer[CCHMAX_SERVER_NAME];
    HRESULT         hr=S_OK;

    if (pdwSrvTypes == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
    }

    if (m_AcctType == ACCT_NEWS || m_AcctType == ACCT_UNDEFINED)
        {
        // NNTP Lets compute the servers supported by this account
        hr = GetPropSz(AP_NNTP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_NNTP;
        }
    
    if (m_AcctType == ACCT_MAIL || m_AcctType == ACCT_UNDEFINED)
        {
        // SMTP Lets compute the servers supported by this account
        hr = GetPropSz(AP_SMTP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_SMTP;

        // POP3 Lets compute the servers supported by this account
        hr = GetPropSz(AP_POP3_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_POP3;

        // IMAP Lets compute the servers supported by this account
        hr = GetPropSz(AP_IMAP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_IMAP;

        // HTTPMail Lets compute the servers supported by this account
        hr = GetPropSz(AP_HTTPMAIL_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_HTTPMAIL;

        }
    
    if (m_AcctType == ACCT_DIR_SERV || m_AcctType == ACCT_UNDEFINED)
        {
        // LDAP Lets compute the servers supported by this account
        hr = GetPropSz(AP_LDAP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_LDAP;
        }

    if (m_AcctType == ACCT_UNDEFINED)
        {
        if (!!(dwSrvTypes & SRV_POP3))
            {
            m_AcctType = ACCT_MAIL;
            dwSrvTypes = (dwSrvTypes & (SRV_POP3 | SRV_SMTP));
            }
        else if (!!(dwSrvTypes & SRV_IMAP))
            {
            m_AcctType = ACCT_MAIL;
            dwSrvTypes = (dwSrvTypes & (SRV_IMAP | SRV_SMTP));
            }
        else if (!!(dwSrvTypes & SRV_HTTPMAIL))
            {
            m_AcctType = ACCT_MAIL;
            }
        else if (!!(dwSrvTypes & SRV_SMTP))
            {
            m_AcctType = ACCT_MAIL;
            dwSrvTypes = (dwSrvTypes & (SRV_POP3 | SRV_SMTP));
            }
        else if (!!(dwSrvTypes & SRV_NNTP))
            {
            m_AcctType = ACCT_NEWS;
            dwSrvTypes = SRV_NNTP;
            }
        else if (!!(dwSrvTypes & SRV_LDAP))
            {
            m_AcctType = ACCT_DIR_SERV;
            dwSrvTypes = SRV_LDAP;
            }
        else
            {
            return(E_FAIL);
            }
        }

    *pdwSrvTypes = dwSrvTypes;

    // Done
    return(S_OK);
}

// -----------------------------------------------------------------------------
// CAccount::Init
// -----------------------------------------------------------------------------
HRESULT CAccount::Init(CAccountManager *pAcctMgr, CPropertySet *pPropertySet)
    {
    HRESULT hr = S_OK;

    Assert(pAcctMgr != NULL);
    Assert(m_pAcctMgr == NULL);

    m_pAcctMgr = pAcctMgr;

    // Create the property container
    hr = HrCreatePropertyContainer(pPropertySet, &m_pContainer);

    m_fNoModifyAccts = pAcctMgr->FNoModifyAccts();

    return(hr);
    }

STDMETHODIMP CAccount::Open(HKEY hkey, LPCSTR pszAcctsKey, LPCSTR pszID)
    {
    DWORD               cb;
    HRESULT             hr;
    HKEY                hkeyAccount = NULL;

    Assert(pszAcctsKey != NULL);
    Assert(pszID != NULL);

    m_hkey = hkey;
    wsprintf(m_szKey, c_szPathFileFmt, pszAcctsKey, pszID);

    m_pContainer->EnterLoadContainer();

    if (RegOpenKeyEx(m_hkey, m_szKey, 0, KEY_ALL_ACCESS, &hkeyAccount) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegOpenKeyFailed);
        goto exit;
        }

    // Save friendly name
    lstrcpyn(m_szID, pszID, sizeof(m_szID));

    // Load properties from the registry
    CHECKHR(hr = PropUtil_HrLoadContainerFromRegistry(hkeyAccount, m_pContainer));

    // this is done to initialize m_AcctType
    // TODO: is there a better way to handle this????
    CHECKHR(hr = GetServerTypes(&m_dwSrvTypes));

    // Save ID
    m_pContainer->SetProp(AP_ACCOUNT_ID, (LPBYTE)pszID, lstrlen(pszID) + 1);

    hr = GetPropSz(AP_ACCOUNT_NAME, m_szName, ARRAYSIZE(m_szName));
    if (hr == E_NoPropData)
        {
        lstrcpy(m_szName, pszID);
        cb = lstrlen(pszID) + 1;
        RegSetValueEx(hkeyAccount, "Account Name", 0, REG_SZ, (LPBYTE)pszID, cb);
        hr = m_pContainer->SetProp(AP_ACCOUNT_NAME, (LPBYTE)pszID, cb);
        }

    // It exist
    m_fAccountExist = TRUE;

exit:
    if (hkeyAccount != NULL)
        RegCloseKey(hkeyAccount);

    m_pContainer->LeaveLoadContainer();

    return hr;
    }

HRESULT CAccount::ValidProp(DWORD dwPropTag)
    {
    HRESULT hr = E_INVALIDARG;

    if (m_AcctType == ACCT_UNDEFINED)
        return(S_OK);

    Assert(m_AcctType >= 0 && m_AcctType < ACCT_LAST);

    if (dwPropTag >= AP_ACCOUNT_FIRST && dwPropTag <= AP_ACCOUNT_LAST)
        {
        hr = S_OK;
        }
    else if (m_AcctType == ACCT_NEWS)
        {
        if (dwPropTag >= AP_NNTP_FIRST && dwPropTag <= AP_NNTP_LAST)
            hr = S_OK;
        }
    else if (m_AcctType == ACCT_MAIL)
        {
        if ((dwPropTag >= AP_IMAP_FIRST && dwPropTag <= AP_IMAP_LAST) ||
            (dwPropTag >= AP_SMTP_FIRST && dwPropTag <= AP_SMTP_LAST) ||
            (dwPropTag >= AP_POP3_FIRST && dwPropTag <= AP_POP3_LAST) ||
            (dwPropTag >= AP_HTTPMAIL_FIRST && dwPropTag <= AP_HTTPMAIL_LAST))
            hr = S_OK;
        }
    else if (m_AcctType == ACCT_DIR_SERV)
        {
        if (dwPropTag >= AP_LDAP_FIRST && dwPropTag <= AP_LDAP_LAST)
            hr = S_OK;
        }

    return(hr);
    }

// -----------------------------------------------------------------------------
// CAccount::GetProp (CPropertyContainer)
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetProp(DWORD dwPropTag, LPBYTE pb, ULONG *pcb)
{
    // Locals
    HRESULT             hr;

    // Default Property fetcher
    if (!FAILED(hr = ValidProp(dwPropTag)))
        hr = m_pContainer->GetProp(dwPropTag, pb, pcb);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccount::GetPropDw
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetPropDw(DWORD dwPropTag, DWORD *pdw)
{
    ULONG cb = sizeof(DWORD);
    return GetProp(dwPropTag, (LPBYTE)pdw, &cb);
}

// -----------------------------------------------------------------------------
// CAccount::GetPropSz
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetPropSz(DWORD dwPropTag, LPSTR psz, ULONG cchMax)
{
    return GetProp(dwPropTag, (LPBYTE)psz, &cchMax);
}

// -----------------------------------------------------------------------------
// CAccount::SetProp
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetProp(DWORD dwPropTag, LPBYTE pb, ULONG cb)
{
    HRESULT hr;

    if (dwPropTag == AP_ACCOUNT_ID)
        return(E_INVALIDARG);

    if (!FAILED(hr = ValidProp(dwPropTag)))
        hr = m_pContainer->SetProp(dwPropTag, pb, cb);

    return(hr);
}

// -----------------------------------------------------------------------------
// CAccount::SetPropDw
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetPropDw(DWORD dwPropTag, DWORD dw)
{
    return SetProp(dwPropTag, (LPBYTE)&dw, sizeof(DWORD));
}

// -----------------------------------------------------------------------------
// CAccount::SetPropSz
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetPropSz(DWORD dwPropTag, LPSTR psz)
{
    HRESULT hr;

    if (psz == NULL)
        hr = SetProp(dwPropTag, NULL, 0);
    else
        hr = SetProp(dwPropTag, (LPBYTE)psz, lstrlen(psz)+1);

    return(hr);
}

// -----------------------------------------------------------------------------
// CAccount::SaveChanges (IPersistPropertyContainer)
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SaveChanges()
{
    return(SaveChanges(TRUE));
}

STDMETHODIMP CAccount::WriteChanges()
{
    return(SaveChanges(FALSE));
}

STDMETHODIMP CAccount::SaveChanges(BOOL fSendNotify)
    {
    IImnAccount         *pAcct;
    TCHAR               szAccount[CCHMAX_ACCOUNT_NAME],
                        szID[CCHMAX_ACCOUNT_NAME];
    DWORD               dw, dwNotify, dwSrvTypes, dwLdapId;
    BOOL                fDup, fRename = FALSE;
    HRESULT             hr = S_OK;
    HKEY                hkeyAccount = NULL;
    ACTX                actx;
    BOOL                fPasswChanged = FALSE;
    
    if (!m_pContainer->FIsDirty())
        return(S_OK);

    dwSrvTypes = m_dwSrvTypes;
    dwLdapId = (DWORD)-1;
    fRename = FALSE;

    Assert(m_AcctType != ACCT_UNDEFINED);
    if (m_AcctType == ACCT_UNDEFINED)
        return(E_FAIL);

    // Lets get the friendly name
    hr = GetPropSz(AP_ACCOUNT_NAME, szAccount, sizeof(szAccount));
    if (FAILED(hr))
        {
        AssertSz(hr != E_NoPropData, "Someone forgot to set the friendly name.");
        return(E_FAIL);
        }

    if (m_AcctType == ACCT_DIR_SERV)
        {
        hr = GetPropDw(AP_LDAP_SERVER_ID, &dw);
        if (FAILED(hr) || dw == 0)
            CHECKHR(hr = m_pAcctMgr->GetNextLDAPServerID(0, &dwLdapId));
        }

    fRename = (m_fAccountExist && lstrcmpi(m_szName, szAccount) != 0);

    if (fRename || !m_fAccountExist)
        {
        // make sure that the name is unique
        hr = m_pAcctMgr->UniqueAccountName(szAccount, fRename ? m_szID : NULL);
        if (hr != S_OK)
            return(E_DuplicateAccountName);
        }

    // Determine notification type
    if (m_fAccountExist)
        {
        Assert(m_hkey != 0);
        Assert(*m_szKey != 0);

        dwNotify = AN_ACCOUNT_CHANGED;
        }
    else
        {
        Assert(m_hkey == 0);
        Assert(*m_szKey == 0);

        dwNotify = AN_ACCOUNT_ADDED;

        CHECKHR(hr = m_pAcctMgr->GetNextAccountID(szID, ARRAYSIZE(szID)));
        CHECKHR(hr = m_pContainer->SetProp(AP_ACCOUNT_ID, (LPBYTE)szID, lstrlen(szID) + 1));

        lstrcpy(m_szID, szID);

        m_hkey = m_pAcctMgr->GetAcctHKey();
        wsprintf(m_szKey, c_szPathFileFmt, m_pAcctMgr->GetAcctRegKey(), m_szID);
        }

    Assert(m_hkey != 0);
    Assert(*m_szKey != 0);

    if (RegCreateKeyEx(m_hkey, m_szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAccount, &dw) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        goto exit;
        }

    // If account hadn't existed, the key should not have already existed
    Assert(m_fAccountExist || dw != REG_OPENED_EXISTING_KEY);

    if (dwLdapId != (DWORD)-1)    
        SetPropDw(AP_LDAP_SERVER_ID, dwLdapId);

    // Save to registry
    CHECKHR(hr = PropUtil_HrPersistContainerToRegistry(hkeyAccount, m_pContainer, &fPasswChanged));

    CHECKHR(hr = GetServerTypes(&m_dwSrvTypes));

    if(fPasswChanged && m_pAcctMgr->FOutlook())
    {
        // Outlook98 & OE5 problem (bug OE:66724, O2K - 227741)
        if(m_dwSrvTypes & SRV_POP3)
            SetPropDw(AP_POP3_PROMPT_PASSWORD, 0);
        else if(m_dwSrvTypes & SRV_IMAP)
            SetPropDw(AP_IMAP_PROMPT_PASSWORD, 0);
        else if(m_dwSrvTypes & SRV_SMTP)
            SetPropDw(AP_SMTP_PROMPT_PASSWORD, 0);
        else if(m_dwSrvTypes & SRV_NNTP)
            SetPropDw(AP_NNTP_PROMPT_PASSWORD, 0);
        else
            goto tooStrange;

        CHECKHR(hr = PropUtil_HrPersistContainerToRegistry(hkeyAccount, m_pContainer, &fPasswChanged));
    }

tooStrange:
    RegCloseKey(hkeyAccount);
    hkeyAccount = NULL;

    // Send notification
    ZeroMemory(&actx, sizeof(actx));
    actx.AcctType = m_AcctType;
    actx.pszAccountID = m_szID;
    actx.dwServerType = m_dwSrvTypes;
    actx.pszOldName = fRename ? m_szName : NULL;
    if(fSendNotify)
        AcctUtil_PostNotification(dwNotify, &actx);

    if (dwNotify == AN_ACCOUNT_CHANGED)
        {
        Assert(m_dwSrvTypes != 0);
        Assert(dwSrvTypes != 0);
        // in all cases except httpmail, it is not legal for
        // server types to change. the legal case with httpmail
        // is the addition or removal of an smtp server
        Assert((m_dwSrvTypes == dwSrvTypes) ||
            (!!(m_dwSrvTypes & SRV_HTTPMAIL) && 
            ((m_dwSrvTypes & ~SRV_SMTP) == (dwSrvTypes & ~SRV_SMTP))));
        }

    lstrcpy(m_szName, szAccount);

    // The account exist now
    m_fAccountExist = TRUE;

exit:
    if (hkeyAccount != NULL)
        RegCloseKey(hkeyAccount);

    return(hr);
    }

// RETURNS:
// S_OK = valid value for the specified property
// S_NonStandardValue = won't break anything but value doesn't look kosher
// E_InvalidValue = invalid value
// S_FALSE = property not supported for validation
STDMETHODIMP CAccount::ValidateProperty(DWORD dwPropTag, LPBYTE pb, ULONG cb)
    {
    DWORD cbT;
    HRESULT hr;

    if (pb == NULL)
        return(E_INVALIDARG);

    if (FAILED(hr = ValidProp(dwPropTag)))
        return(hr);

    hr = E_InvalidValue;

    switch (dwPropTag)
        {
        case AP_ACCOUNT_NAME:
            hr = AcctUtil_ValidAccountName((TCHAR *)pb);
            break;

        case AP_IMAP_SERVER:
        case AP_LDAP_SERVER:
        case AP_NNTP_SERVER:
        case AP_POP3_SERVER:
        case AP_SMTP_SERVER:
            hr = ValidServerName((TCHAR *)pb);
            break;

        case AP_NNTP_EMAIL_ADDRESS:
        case AP_NNTP_REPLY_EMAIL_ADDRESS:
        case AP_SMTP_EMAIL_ADDRESS:
        case AP_SMTP_REPLY_EMAIL_ADDRESS:
            hr = ValidEmailAddress((TCHAR *)pb);
            break;

        default:
            hr = S_FALSE;
            break;
        }

    return(hr);
    }

STDMETHODIMP CAccount::DoWizard(HWND hwnd, DWORD dwFlags)
    {
    return(IDoWizard(hwnd, NULL, dwFlags));
    }

STDMETHODIMP CAccount::DoImportWizard(HWND hwnd, CLSID clsid, DWORD dwFlags)
    {
    return(IDoWizard(hwnd, &clsid, dwFlags));
    }

HRESULT CAccount::IDoWizard(HWND hwnd, CLSID *pclsid, DWORD dwFlags)
    {
    HRESULT hr;
    CICWApprentice *pApp;

    if (m_fNoModifyAccts)
        return(S_FALSE);

    pApp = new CICWApprentice;
    if (pApp == NULL)
        return(E_OUTOFMEMORY);

    hr = pApp->Initialize(m_pAcctMgr, this);
    if (SUCCEEDED(hr))
        hr = pApp->DoWizard(hwnd, pclsid, dwFlags);

    pApp->Release();

    return(hr);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::CEnumAccounts
// -----------------------------------------------------------------------------
CEnumAccounts::CEnumAccounts(DWORD dwSrvTypes, DWORD dwFlags)
{
    m_cRef = 1;
    m_pAccounts = NULL;
    m_cAccounts = 0;
    m_iAccount = -1;
    m_dwSrvTypes = dwSrvTypes;
    m_dwFlags = dwFlags;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::~CEnumAccounts
// -----------------------------------------------------------------------------
CEnumAccounts::~CEnumAccounts()
{
    AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);
}

// -----------------------------------------------------------------------------
// CEnumAccounts::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IImnAccountManager
    if (IID_IImnEnumAccounts == riid)
        *ppv = (IImnEnumAccounts *)this;

    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumAccounts::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumAccounts::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::Init
// -----------------------------------------------------------------------------
HRESULT CEnumAccounts::Init(LPACCOUNT pAccounts, ULONG cAccounts)
    {
    // Locals
    ULONG           i, cAcctNew;
    LPACCOUNT       pAcctNew;
    HRESULT         hr=S_OK;

    // Check Params
    Assert(m_pAccounts == NULL);
    Assert(m_cAccounts == 0);
    AssertReadPtr(pAccounts, cAccounts);

    // We should really have this stuff
    if (pAccounts && cAccounts)
        {
        CHECKHR(hr = HrAlloc((LPVOID *)&pAcctNew, sizeof(ACCOUNT) * cAccounts));

        // Zero init
        ZeroMemory(pAcctNew, sizeof(ACCOUNT) * cAccounts);

        // AddRef all of the account objects
        cAcctNew = 0;
        for (i = 0; i < cAccounts; i++)
            {
            Assert(pAccounts[i].pAccountObject != NULL);

            if (!FEnumerateAccount(&pAccounts[i]))
                {
                // we're not interested in this account
                continue;
                }

            // AddRef the account about object
            CopyMemory(&pAcctNew[cAcctNew], &pAccounts[i], sizeof(ACCOUNT));
            pAcctNew[cAcctNew].pAccountObject->AddRef();
            cAcctNew++;
            }

        if (cAcctNew == 0)
            {
            MemFree(pAcctNew);
            }
        else
            {
            m_pAccounts = pAcctNew;
            m_cAccounts = cAcctNew;
            AssertReadPtr(m_pAccounts, m_cAccounts);

            if (!!(m_dwFlags & (ENUM_FLAG_SORT_BY_NAME | ENUM_FLAG_SORT_BY_LDAP_ID)))
                QSort(0, m_cAccounts - 1);
            }
        }

exit:
    // Done
    return hr;
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::GetCount
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::GetCount(ULONG *pcItems)
    {
    HRESULT hr;

    // Check Params
    if (pcItems == NULL)
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    Assert((m_cAccounts == 0) ? (m_pAccounts == NULL) : (m_pAccounts != NULL));

    // Set Count
    *pcItems = m_cAccounts;

    return(S_OK);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::SortByAccountName
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::SortByAccountName(VOID)
{
    if (m_cAccounts > 0)
        {
        Assert(m_pAccounts != NULL);

        // qsort the list
        QSort(0, m_cAccounts-1);
        }

    // Done
    return(S_OK);
}

inline int CompareAccounts(ACCOUNT *pAcct1, ACCOUNT *pAcct2, DWORD dwFlags)
{
    TCHAR sz1[CCHMAX_ACCOUNT_NAME], sz2[CCHMAX_ACCOUNT_NAME];

    if (!!(dwFlags & ENUM_FLAG_SORT_BY_LDAP_ID))
    {
        Assert(pAcct1->AcctType == ACCT_DIR_SERV);
        Assert(pAcct2->AcctType == ACCT_DIR_SERV);
        if (pAcct1->dwServerId == pAcct2->dwServerId)
        {
            return(lstrcmp(pAcct1->szID, pAcct2->szID));
        }
        else
        {
            if (pAcct1->dwServerId == 0)
                return(1);
            else if (pAcct2->dwServerId == 0)
                return(-1);
            else
                return((int)(pAcct1->dwServerId) - (int)(pAcct2->dwServerId));
        }
    }
    else
    {
        pAcct1->pAccountObject->GetPropSz(AP_ACCOUNT_NAME, sz1, ARRAYSIZE(sz1));
        pAcct2->pAccountObject->GetPropSz(AP_ACCOUNT_NAME, sz2, ARRAYSIZE(sz2));

        return(lstrcmpi(sz1, sz2));
    }
}

// -----------------------------------------------------------------------------
// CEnumAccounts::QSort - used to sort the array of accounts
// -----------------------------------------------------------------------------
VOID CEnumAccounts::QSort(LONG left, LONG right)
{
    register    long i, j;
    ACCOUNT     *k, y;

    i = left;
    j = right;
    k = &m_pAccounts[(left + right) / 2];

    do
    {
        while (CompareAccounts(&m_pAccounts[i], k, m_dwFlags) < 0 && i < right) 
            i++;
        while (CompareAccounts(&m_pAccounts[j], k, m_dwFlags) > 0 && j > left) 
            j--;

        if (i <= j)
        {
            CopyMemory(&y, &m_pAccounts[i], sizeof(ACCOUNT));
            CopyMemory(&m_pAccounts[i], &m_pAccounts[j], sizeof(ACCOUNT));
            CopyMemory(&m_pAccounts[j], &y, sizeof(ACCOUNT));
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        QSort(left, j);
    if (i < right)
        QSort(i, right);
}

BOOL CEnumAccounts::FEnumerateAccount(LPACCOUNT pAccount)
    {
    HRESULT hr;
    DWORD dw;

    Assert(pAccount != NULL);

    if (pAccount->dwSrvTypes & m_dwSrvTypes)
        {                                         
        // I hope there is an object
        Assert(pAccount->pAccountObject != NULL);

        if (!!(m_dwFlags & ENUM_FLAG_NO_IMAP) &&
            !!(pAccount->dwSrvTypes & SRV_IMAP))
            return(FALSE);
        if (!!(m_dwFlags & ENUM_FLAG_RESOLVE_ONLY) &&
            pAccount->AcctType == ACCT_DIR_SERV)
            {
            hr = pAccount->pAccountObject->GetPropDw(AP_LDAP_RESOLVE_FLAG, &dw);
            if (FAILED(hr))
                return(FALSE);
            if (dw == 0)
                return(FALSE);
            }

        if (SUCCEEDED(pAccount->pAccountObject->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
		{
			if(AcctUtil_HideHotmail())
				return(FALSE);
		}
        return(TRUE);
        }

    return(FALSE);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::GetNext
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::GetNext(IImnAccount **ppAccount)
    {
    HRESULT hr;

    // Bad Param
    if (ppAccount == NULL)
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    // No Data ?
    while (1)
        {
        m_iAccount++;

        // Are we done yet ?
        if (m_iAccount >= (LONG)m_cAccounts)
            return(E_EnumFinished);
                    
        m_pAccounts[m_iAccount].pAccountObject->AddRef();

        // Set return account - Could be NULL
        *ppAccount = m_pAccounts[m_iAccount].pAccountObject;

        // Done
        break;
        }

    return(S_OK);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::Reset
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::Reset(void)
{
    m_iAccount = -1;
    return S_OK;
}

// -----------------------------------------------------------------------------
// AcctUtil_ValidAccountName
// -----------------------------------------------------------------------------
HRESULT AcctUtil_ValidAccountName(LPTSTR pszAccount)
    {
    int         cbT;

    cbT = lstrlen(pszAccount);
    if (cbT == 0 ||
        cbT >= CCHMAX_ACCOUNT_NAME ||
        FIsEmptyA(pszAccount))
        {
        return(E_InvalidValue);
        }

    return(S_OK);
    }

VOID AcctUtil_FreeAccounts(LPACCOUNT *ppAccounts, ULONG *pcAccounts)
    {
    ULONG           i;

    Assert(ppAccounts && pcAccounts);

    // If there are accounts
    if (*ppAccounts != NULL)
        {
        // The counter better be positive
        for (i = 0; i < *pcAccounts; i++)
            {
            SafeRelease((*ppAccounts)[i].pAccountObject);
            }

        // Free the account array
        MemFree(*ppAccounts);
        *ppAccounts = NULL;
        }

    *pcAccounts = 0;
    }

HRESULT CAccountManager::SetDefaultAccount(ACCTTYPE AcctType, LPSTR szID, BOOL fNotify)
    {
    LPCSTR              psz;
    HRESULT             hr;
    ACTX                actx;
    HKEY                hReg;

    Assert(szID != NULL);

    hr = S_OK;

    switch (AcctType)
        {
        case ACCT_MAIL:
            psz = c_szDefaultMailAccount;
            break;

        case ACCT_NEWS:
            psz = c_szDefaultNewsAccount;
            break;

        case ACCT_DIR_SERV:
            psz = c_szDefaultLDAPAccount;
            break;

        default:
            Assert(FALSE);
            break;
        }

    if (RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hReg, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        }
    else
        {
        if (RegSetValueEx(hReg, psz, 0, REG_SZ, (LPBYTE)szID, lstrlen(szID) + 1) != ERROR_SUCCESS)
            {
            hr = TRAPHR(E_RegSetValueFailed);
            }
        else if (fNotify)
            {
            ZeroMemory(&actx, sizeof(actx));
            actx.AcctType = AcctType;
            actx.pszAccountID = szID;// the new default accountID
            AcctUtil_PostNotification(AN_DEFAULT_CHANGED, &actx);
            }

        RegCloseKey(hReg);
        }

    return(hr);
    }

HRESULT CAccountManager::DeleteAccount(LPSTR pszID, LPSTR pszName, ACCTTYPE AcctType, DWORD dwSrvTypes)
    {
    HKEY            hkeyReg;
    HRESULT         hr = S_OK;
    ACTX            actx;

    Assert(pszID != NULL);
    Assert(pszName != NULL);

    // Open / Create Reg Key
    if (RegOpenKeyEx(m_hkey, m_szRegAccts, 0, KEY_ALL_ACCESS, &hkeyReg) != ERROR_SUCCESS)
        return(E_RegOpenKeyFailed);

	ZeroMemory(&actx, sizeof(actx));
	actx.AcctType = AcctType;
	actx.pszAccountID = pszID;
    actx.pszOldName = pszName;
	actx.dwServerType = dwSrvTypes;
    AcctUtil_PostNotification(AN_ACCOUNT_PREDELETE, &actx);

    // Delete friendly name key
    if (RegDeleteKey(hkeyReg, pszID) != ERROR_SUCCESS)
        {
        AssertSz(FALSE, "Deleting an account that does not exist.");
        hr = TRAPHR(E_RegDeleteKeyFailed);
        }
    else
        {
		ZeroMemory(&actx, sizeof(actx));
		actx.AcctType = AcctType;
		actx.pszAccountID = pszID;
        actx.pszOldName = pszName;
		actx.dwServerType = dwSrvTypes;
        AcctUtil_PostNotification(AN_ACCOUNT_DELETED, &actx);
        }

    RegCloseKey(hkeyReg);

    return(hr);
    }

// -----------------------------------------------------------------------------
// AcctUtil_PostNotification
// -----------------------------------------------------------------------------
VOID AcctUtil_PostNotification(DWORD dwAN, ACTX* pactx)
{
    // Thread Safety
    EnterCriticalSection(&g_csAcctMan);

    // Immediately update global pAcctMan
    if (g_pAcctMan)
        g_pAcctMan->Advise(dwAN, pactx);

    // Thread Safety
    LeaveCriticalSection(&g_csAcctMan);

    // Post a notification to other processes
    if (g_uMsgAcctManNotify)
    {
        // Tell other processes
        PostMessage(HWND_BROADCAST, g_uMsgAcctManNotify, dwAN, GetCurrentProcessId());
    }
}

HRESULT CAccountManager::GetNextLDAPServerID(DWORD dwSet, DWORD *pdwId)
    {
    DWORD dwNextID, dwType, cb;
    HKEY hKey;
    HRESULT hr;

    Assert(pdwId != NULL);

    hr = E_FAIL;

    // Open the WAB's reg key
    if (ERROR_SUCCESS == RegOpenKeyEx(m_hkey, m_szRegRoot, 0, KEY_ALL_ACCESS, &hKey))
        {
        dwNextID = 0;   // init in case registry gives < 4 bytes.

        if (dwSet)
            {
            dwNextID = dwSet;
            }
        else
            {
            // Read the next available server id
            cb = sizeof(DWORD);
            if (ERROR_SUCCESS != RegQueryValueEx(hKey, c_szRegServerID, NULL, &dwType, (LPBYTE)&dwNextID, &cb))
                {
                RegCloseKey(hKey);
                return(E_FAIL);
                }
            }

        *pdwId = dwNextID++;

        // Update the ID in the registry
        if (ERROR_SUCCESS == RegSetValueEx(hKey, c_szRegServerID, 0, REG_DWORD, (LPBYTE)&dwNextID, sizeof(DWORD)))
            hr = S_OK;

        RegCloseKey(hKey);
        }

    return(hr);
    }

HRESULT CAccountManager::GetNextAccountID(LPTSTR szAccount, int cch)
    {
    DWORD dwID, dwNextID, dwType, cb;
    HKEY hKey;
    HRESULT hr;

    Assert(szAccount != NULL);

    hr = E_FAIL;

    if (ERROR_SUCCESS == RegOpenKeyEx(m_hkey, m_szRegRoot, 0, KEY_ALL_ACCESS, &hKey))
        {
        // Read the next available server id
        cb = sizeof(DWORD);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, c_szRegAccountName, NULL, &dwType, (LPBYTE)&dwNextID, &cb))
            dwNextID = 1;

        dwID = dwNextID++;

        // Update the ID in the registry
        if (ERROR_SUCCESS == RegSetValueEx(hKey, c_szRegAccountName, 0, REG_DWORD, (LPBYTE)&dwNextID, sizeof(DWORD)))
            {
            wsprintf(szAccount, "%08lx", dwID);
            hr = S_OK;
            }

        RegCloseKey(hKey);
        }

    return(hr);
    }

HRESULT CAccountManager::UniqueAccountName(char *szName, char *szID)
    {
    HRESULT         hr=S_OK;
    char            szT[CCHMAX_ACCOUNT_NAME];
    ACCOUNT         *pAcct;
    ULONG           i;

    Assert(szName != NULL);

    EnterCriticalSection(&m_cs);

    for (i = 0, pAcct = m_pAccounts; i < m_cAccounts; i++, pAcct++)
        {
        // We should have an account object, but if not
        Assert(pAcct->pAccountObject != NULL);

        if (szID == NULL || (0 != lstrcmpi(pAcct->szID, szID)))
            {
            hr = pAcct->pAccountObject->GetPropSz(AP_ACCOUNT_NAME, szT, ARRAYSIZE(szT));
            Assert(!FAILED(hr));

            if (0 == lstrcmpi(szT, szName))
                {
                hr = S_FALSE;
                goto exit;
                }
            }
        }

    hr = S_OK;

exit:
    LeaveCriticalSection(&m_cs);
    return(hr);
    }

const static char c_szNumFmt[] = " (%d)";

HRESULT CAccountManager::GetUniqueAccountName(char *szName, UINT cchMax)
    {
    char *sz;
    HRESULT hr;
    char szAcct[CCHMAX_ACCOUNT_NAME + 8];
    UINT i, cch;

    Assert(szName != NULL);
    Assert(cchMax >= CCHMAX_ACCOUNT_NAME);

    hr = UniqueAccountName(szName, NULL);
    Assert(!FAILED(hr));
    if (hr == S_FALSE)
        {
        hr = E_FAIL;

        lstrcpy(szAcct, szName);
        cch = lstrlen(szAcct);
        sz = szAcct + cch;

        for (i = 1; i < 999; i++)
            {
            wsprintf(sz, c_szNumFmt, i);
            if (S_OK == UniqueAccountName(szAcct, NULL))
                {
                cch = lstrlen(szAcct);
                if (cch < cchMax)
                    {
                    lstrcpy(szName, szAcct);
                    hr = S_OK;
                    break;
                    }
                }
            }
        }

    return(hr);
    }


#define OBFUSCATOR              0x14151875;

#define PROT_SIZEOF_HEADER      0x02    // 2 bytes in the header
#define PROT_SIZEOF_XORHEADER   (PROT_SIZEOF_HEADER+sizeof(DWORD))

#define PROT_VERSION_1          0x01

#define PROT_PASS_XOR           0x01
#define PROT_PASS_PST           0x02

static BOOL FDataIsValidV1(BYTE *pb)
{ return pb && pb[0] == PROT_VERSION_1 && (pb[1] == PROT_PASS_XOR || pb[1] == PROT_PASS_PST); }

static BOOL FDataIsPST(BYTE *pb)
{ return pb && pb[1] == PROT_PASS_PST; }

///////////////////////////////////////////////////////////////////////////
// 
// NOTE - The functions for encoding the user passwords really should not 
//        be here.  Unfortunately, they are not anywhere else so for now,
//        this is where they will stay.  They are defined as static since
//        other code should not rely on them staying here, particularly the 
//        XOR stuff.
//
///////////////////////////////////////////////////////////////////////////
// 
// XOR functions
//
///////////////////////////////////////////////////////////////////////////

static HRESULT _XOREncodeProp(const BLOB *const pClear, BLOB *const pEncoded)
{
    DWORD       dwSize;
    DWORD       last, last2;
    UNALIGNED DWORD *pdwCypher;
    DWORD       dex;
#ifdef _WIN64
	UNALIGNED	DWORD * pSize = NULL;
#endif

    pEncoded->cbSize = pClear->cbSize+PROT_SIZEOF_XORHEADER;
    if (!MemAlloc((LPVOID *)&pEncoded->pBlobData, pEncoded->cbSize + 6))
        return E_OUTOFMEMORY;
    
    // set up header data
    Assert(2 == PROT_SIZEOF_HEADER);
    pEncoded->pBlobData[0] = PROT_VERSION_1;
    pEncoded->pBlobData[1] = PROT_PASS_XOR;
	
#ifdef _WIN64
	pSize = (DWORD *) &(pEncoded->pBlobData[2]);
	*pSize = pClear->cbSize;
#else //_WIN64
    *((DWORD *)&(pEncoded->pBlobData[2])) = pClear->cbSize;
#endif

    // nevermind that the pointer is offset by the header size, this is
    // where we start to write out the modified password
    pdwCypher = (DWORD *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;                              // 0' = 0 ^ ob
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            {
            last2 = ((UNALIGNED DWORD *)pClear->pBlobData)[dex];  // 1 
            pdwCypher[dex] = last2 ^ last;              // 1' = 1 ^ 0
            last = last2;                   // save 1 for the 2 round
            }
        }

    // if we have bits left over
    // note that dwSize is computed now in bits
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        pdwCypher[dex] &= ((DWORD)-1) << dwSize;
        pdwCypher[dex] |=
            ((((DWORD *)pClear->pBlobData)[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

static HRESULT _XORDecodeProp(const BLOB *const pEncoded, BLOB *const pClear)
{
    DWORD       dwSize;
    DWORD       last;
    UNALIGNED   DWORD     *pdwCypher;
    DWORD       dex;

    // we use CoTaskMemAlloc to be in line with the PST implementation
    pClear->cbSize = pEncoded->pBlobData[2];
    MemAlloc((void **)&pClear->pBlobData, pClear->cbSize);
    if (!pClear->pBlobData)
        return E_OUTOFMEMORY;
    
    // should have been tested by now
    Assert(FDataIsValidV1(pEncoded->pBlobData));
    Assert(!FDataIsPST(pEncoded->pBlobData));

    // nevermind that the pointer is offset by the header size, this is
    // where the password starts
    pdwCypher = (DWORD *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            last = ((UNALIGNED DWORD *)pClear->pBlobData)[dex] = pdwCypher[dex] ^ last;
        }

    // if we have bits left over
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        ((DWORD *)pClear->pBlobData)[dex] &= ((DWORD)-1) << dwSize;
        ((DWORD *)pClear->pBlobData)[dex] |=
                ((pdwCypher[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

/*
    EncodeUserPassword

    Encrypt the passed in password.  This encryption seems to
    add an extra 6 bytes on to the beginning of the data
    that it passes back, so we need to make sure that the 
    lpszPwd is large enough to hold a few extra characters.
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, a c string containing the password.
    on exit, it is the encrypted data, plus some header info.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would enter with *cb == 4.
*/
static void EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    HRESULT         hr;
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XOREncodeProp(&blobClient, &blobProp);
    
    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}

/*
    DecodeUserPassword

    Decrypt the passed in data and return a password.  This 
    encryption seems to add an extra 6 bytes on to the beginning 
    so decrupting will result in a using less of lpszPwd.
    .
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, the encrypted password plus some 
    header info. 
    on exit, a c string containing the password.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would leave with *cb == 4.
*/
static void DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    HRESULT         hr;
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XORDecodeProp(&blobClient, &blobProp);

    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        lpszPwd[blobProp.cbSize] = 0;
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}


const static DWORD c_mpAcctFlag[ACCT_LAST] = {ACCT_FLAG_NEWS, ACCT_FLAG_MAIL, ACCT_FLAG_DIR_SERV};
static TCHAR    g_pszDir[MAX_PATH] = "";

const DWORD     g_dwFileVersion = 0x00050000;
const DWORD     g_dwFileIndicator = 'IAMf';
#define WRITEDATA(pbData, cSize)    (WriteFile(hFile, pbData, cSize, &dwWritten, NULL))
#define READDATA(pbData, cSize)    (ReadFile(hFile, pbData, cSize, &dwRead, NULL))
void Server_ExportServer(HWND hwndDlg)
{
    ACCTTYPE    type;
    BOOL        fDefault;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME],
        szRes[255],
        szMsg[255 + CCHMAX_ACCOUNT_NAME];
    TCHAR       rgch[MAX_PATH] = {0};
    LV_ITEM     lvi;
    LV_FINDINFO lvfi;
    int         iItemToExport;
    IImnAccount *pAccount = NULL;
    HWND        hwndFocus;
    BYTE        pbBuffer[MAX_PATH];
    HWND        hwndList = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    HANDLE      hFile = NULL;
    
    LoadString(g_hInstRes, idsImportFileFilter, rgch, MAX_PATH);
    ReplaceChars (rgch, _T('|'), _T('\0'));
    
    // Get the selected item to know which server the user wants to export
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVIS_SELECTED);
    lvi.iSubItem = 0;
    lvi.pszText = szAccount;
    lvi.cchTextMax = ARRAYSIZE(szAccount);
    if (ListView_GetItem(hwndList, &lvi))
    {    
        // Remember item to export
        iItemToExport = lvi.iItem;
        type = (ACCTTYPE)LOWORD(lvi.lParam);
        
        // Open the account
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            fDefault = (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szMsg, ARRAYSIZE(szMsg))) &&
                0 == lstrcmpi(szMsg, szAccount));
            
            hwndFocus = GetFocus();
            
            OPENFILENAME    ofn;
            TCHAR           szFile[MAX_PATH];
            TCHAR           szTitle[MAX_PATH];
            TCHAR           szDefExt[30];
            ULONG           nExtLen = 0;
            ULONG           nExtStart = 0;

            nExtLen = 1 + LoadString(g_hInstRes, idsExportFileExt, szDefExt, ARRAYSIZE(szDefExt)); // 1 for NULL
            LoadString(g_hInstRes, idsExport, szTitle, ARRAYSIZE(szTitle));
            
            // Try to suggest a reasonable name
            lstrcpyn(szFile, szAccount, ARRAYSIZE(szFile));
            nExtStart = CleanupFileNameInPlaceA(CP_ACP, szFile);
            // Always cram the extension on the end
            Assert(ARRAYSIZE(szFile) >= ARRAYSIZE(szDefExt));
            lstrcpy(&szFile[(nExtStart < (ARRAYSIZE(szFile) - nExtLen)) ? nExtStart : (ARRAYSIZE(szFile) - nExtLen)], szDefExt);

            ZeroMemory (&ofn, sizeof (ofn));
            ofn.lStructSize = sizeof (ofn);
            ofn.hwndOwner = hwndDlg;
            ofn.lpstrFilter = rgch;
            ofn.nFilterIndex = 1;
            ofn.lpstrFile = szFile;
            ofn.lpstrInitialDir = (*g_pszDir ? g_pszDir : NULL);
            ofn.nMaxFile = sizeof (szFile);
            ofn.lpstrTitle = szTitle;
            ofn.lpstrDefExt = szDefExt;
            ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;
            
            if (*szFile==NULL)
                goto exit;
            
            // Show OpenFile Dialog
            if (!GetSaveFileName(&ofn))
                goto exit;
            
            hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, 
                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
            
            if (INVALID_HANDLE_VALUE == hFile)
                goto exit;
            
            *g_pszDir = 0;

            // store the last path
            lstrcpy(g_pszDir, ofn.lpstrFile);
            if (!PathIsDirectoryA(g_pszDir))
                PathRemoveFileSpecA(g_pszDir);


            DWORD   dwIndex, dwWritten;
            
            WRITEDATA(&g_dwFileIndicator, sizeof(DWORD));
            WRITEDATA(&g_dwFileVersion, sizeof(DWORD));
            WRITEDATA(&type, sizeof(ACCTTYPE));
            
            for (dwIndex = 0; dwIndex < NUM_ACCT_PROPS; dwIndex++)
            {
                ULONG   cb = MAX_PATH;
                
                if (SUCCEEDED(pAccount->GetProp(g_rgAcctPropSet[dwIndex].dwPropTag, pbBuffer, &cb)))
                {
                    switch (g_rgAcctPropSet[dwIndex].dwPropTag)
                    {
                        case AP_SMTP_PASSWORD:
                        case AP_LDAP_PASSWORD:
                        case AP_NNTP_PASSWORD:
                        case AP_IMAP_PASSWORD:
                        case AP_POP3_PASSWORD:
                        case AP_HTTPMAIL_PASSWORD:
                            EncodeUserPassword((TCHAR *)pbBuffer, &cb);
                            break;
                    }
                    //write out the id, the size and the data
                    WRITEDATA(&g_rgAcctPropSet[dwIndex].dwPropTag, sizeof(DWORD));
                    WRITEDATA(&cb, sizeof(DWORD));
                    WRITEDATA(pbBuffer, cb);
                }
            }
        }        
    }
    
exit:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    
    if (pAccount)
        pAccount->Release();
}


void Server_ImportServer(HWND hwndDlg, ACCTDLGINFO *pinfo)
{
    OPENFILENAME    ofn;
    TCHAR           szOpenFileName[MAX_PATH]    = {0};
    TCHAR           rgch[MAX_PATH]              = {0};
    TCHAR           szDir[MAX_PATH]             = {0};
    TCHAR           szTitle[MAX_PATH]           = {0};
    HRESULT         hr                          = S_FALSE;
    HANDLE          hFile                       = INVALID_HANDLE_VALUE;
    IImnAccount    *pAccount                    = NULL;
    DWORD           dwVersion, dwRead;
    BOOL            fOK;
    ACCTTYPE        type;
    BYTE            pbBuffer[MAX_PATH];
    TC_ITEM         tci;
    int             nIndex;
    DWORD           dwAcctFlags, dw;
    HWND            hwndTab                     = GetDlgItem(hwndDlg, IDB_MACCT_TAB);
    HWND            hwndList                    = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    
    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    LoadString(g_hInstRes, idsImportFileFilter, rgch, MAX_PATH);
    ReplaceChars (rgch, _T('|'), _T('\0'));
    *szOpenFileName ='\0';
    
    LoadString(g_hInstRes, idsImport, szTitle, MAX_PATH);
    
    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = hwndDlg;
    ofn.hInstance       = g_hInst;
    ofn.lpstrFilter     = rgch;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = szOpenFileName;
    ofn.nMaxFile        = MAX_PATH;
    ofn.lpstrInitialDir = (*g_pszDir ? g_pszDir : NULL);
    ofn.lpstrTitle      = szTitle;
    ofn.Flags           = OFN_EXPLORER |
        OFN_HIDEREADONLY |
        OFN_FILEMUSTEXIST |
        OFN_NODEREFERENCELINKS|
        OFN_NOCHANGEDIR;
    
    if(GetOpenFileName(&ofn))
    {
        hFile = CreateFile(szOpenFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        
        *g_pszDir = 0;

        // store the last path
        lstrcpy(g_pszDir, ofn.lpstrFile);
        if (!PathIsDirectoryA(g_pszDir))
            PathRemoveFileSpecA(g_pszDir);

        if (INVALID_HANDLE_VALUE == hFile)
            goto exit;
        
        // make sure its the right file type by checking the 
        // DWORD at the start of the file
        fOK = READDATA(&dwVersion, sizeof(DWORD));
        
        Assert(fOK);
        if (!fOK || g_dwFileIndicator != dwVersion)
            goto error;
        
        // Now check the version to see if the major version has changed
        fOK = READDATA(&dwVersion, sizeof(DWORD));
        Assert(fOK);
        if (!fOK || g_dwFileVersion < (dwVersion & 0xffff0000))
            goto error;
        
        // read the account type
        fOK = READDATA(&type, sizeof(ACCTTYPE));
        Assert(fOK);
        
        if (!fOK)
            goto error;
        
        if (FAILED(hr = g_pAcctMan->CreateAccountObject(type, &pAccount)) || (NULL == pAccount))
        {
            Assert(SUCCEEDED(hr) && (NULL != pAccount));
            goto error;
        }
        
        while (TRUE)
        {
            DWORD   dwPropId, dwSize;
            
            fOK = READDATA(&dwPropId, sizeof(DWORD));
            if (!fOK || dwRead != sizeof(DWORD))
                break;
            
            fOK = READDATA(&dwSize, sizeof(DWORD));
            if (!fOK || dwRead != sizeof(DWORD))
                break;
            
            if (dwSize > sizeof(pbBuffer)/sizeof(pbBuffer[0]))
                goto error;
            fOK = READDATA(pbBuffer, dwSize);
            Assert(fOK && dwRead == dwSize);
            if (!fOK || dwRead != dwSize)
                goto error;
            
            // don't write the old account id in
            if (dwPropId == AP_ACCOUNT_ID)
                continue;

            switch (dwPropId)
            {
                case AP_SMTP_PASSWORD:
                case AP_LDAP_PASSWORD:
                case AP_NNTP_PASSWORD:
                case AP_IMAP_PASSWORD:
                case AP_POP3_PASSWORD:
                case AP_HTTPMAIL_PASSWORD:
                    DecodeUserPassword((TCHAR *)pbBuffer, &dwSize);
                    break;
            }

            if (FAILED(hr = pAccount->SetProp(dwPropId, pbBuffer, dwSize)))
            {
                Assert(FALSE);
                goto error;
            }  
        }
        
        hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, rgch, ARRAYSIZE(rgch));
        Assert(!FAILED(hr));
        
        if (FAILED(hr = pAccount->SaveChanges()))
            goto error;
        
        nIndex = TabCtrl_GetCurSel(hwndTab);
        tci.mask = TCIF_PARAM;
        if (nIndex >= 0 && TabCtrl_GetItem(hwndTab, nIndex, &tci))
        {
            dwAcctFlags = (DWORD)tci.lParam;
            if (0 == (dwAcctFlags & c_mpAcctFlag[type]))
            {
                // the current page doesn't show this type of account,
                // so we need to force a switch to the all tab
#ifdef DEBUG
                tci.mask = TCIF_PARAM;
                Assert(TabCtrl_GetItem(hwndTab, 0, &tci));
                Assert(!!((DWORD)(tci.lParam) & c_mpAcctFlag[type]));
#endif // DEBUG
                
                TabCtrl_SetCurSel(hwndTab, 0);
                Server_InitServerList(hwndDlg, hwndList, hwndTab, pinfo, rgch);
            }
            else
            {
                Server_FAddAccount(hwndList, pinfo, 0, pAccount, TRUE);
            }
        }
        
    }
    
    goto exit;
error:
    if (hr == E_DuplicateAccountName)
        AcctMessageBox(hwndDlg, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrAccountExists), NULL, MB_OK | MB_ICONEXCLAMATION);    
    else
        AcctMessageBox(hwndDlg, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrImportFailed), NULL, MB_OK | MB_ICONEXCLAMATION);    
    
exit:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    
    if (pAccount)
        pAccount->Release();
}



// -----------------------------------------------------------------------------
// AcctUtil_IsHTTPMailEnabled
// HTTPMail accounts can only be created and accessed when a special
// registry value exists. This limitation exists during development of
// OE 5.0, and will probably be removed for release.
// -----------------------------------------------------------------------------
BOOL AcctUtil_IsHTTPMailEnabled(void)
{
#ifdef NOHTTPMAIL
    return FALSE;
#else
    DWORD   cb, bEnabled = FALSE;
    HKEY    hkey = NULL;

    // open the OE5.0 key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(bEnabled);
        RegQueryValueEx(hkey, c_szEnableHTTPMail, 0, NULL, (LPBYTE)&bEnabled, &cb);

        RegCloseKey(hkey);
    }

    return bEnabled;
#endif
}

// -----------------------------------------------------------------------------
// AcctUtil_HideHotmail
// The IEAK can be configured to hide all evidence of the MSN brand. When
// this is the case, we don't populate the ISP combo boxes with MSN domains.
// -----------------------------------------------------------------------------
BOOL AcctUtil_HideHotmail()
{
    int cch;
    DWORD dw, cb, type;
    char sz[8];

    cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegDisableHotmail, &type, &dw, &cb) &&
        dw == 2)
        return(FALSE);

    cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegFlat, c_szRegDisableHotmail, &type, &dw, &cb) &&
        dw == 2)
        return(FALSE);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\msoeacct\acctui.cpp ===
#include "pch.hxx"
#include <tchar.h>
#include <commctrl.h>
#include <ras.h>
#include "acctman.h"
#include "server.h"
#include "connect.h"
#include "acctui.h"
#include "strconst.h"
#include "dllmain.h"
#include "resource.h"
#include "accthelp.h"
#include "shared.h"
#include <demand.h>
ASSERTDATA

INT_PTR CALLBACK SetOrderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp);
void SetUpDownButtons(HWND hDlg, HWND hWndLV);
BOOL InitSetOrderList(HWND hwndList);
void SaveLDAPResolveOrder(HWND hwnd, HWND hwndList);
void DrawAddButton(HWND hwnd, LPDRAWITEMSTRUCT pdi, ACCTDLGINFO *pinfo);
void EnableAcctButtons(HWND hwnd, HWND hwndList, UINT iItem);

const static DWORD c_mpAcctFlag[ACCT_LAST] = {ACCT_FLAG_NEWS, ACCT_FLAG_MAIL, ACCT_FLAG_DIR_SERV};

void GetTypeString(TCHAR *sz, int cch, ACCTTYPE AcctType, BOOL fDefault)
{
    int cb;
    ULONG uType;
    
    if (AcctType == ACCT_NEWS)
        uType = idsNews;
    else if (AcctType == ACCT_MAIL)
        uType = idsMail;
    else
    {
        Assert(AcctType == ACCT_DIR_SERV);
        uType = idsDirectoryService;
    }
    
    cb = LoadString(g_hInstRes, uType, sz, cch);
    if (fDefault)
        LoadString(g_hInstRes, idsDefault, &sz[cb], cch - (cb + 1));
}

BOOL Server_FAddAccount(HWND hwndList, ACCTDLGINFO *pinfo, UINT iItem, IImnAccount *pAccount, BOOL fSelect)
{
    // Locals
    TCHAR   szAccount[CCHMAX_ACCOUNT_NAME],
            szT[CCHMAX_ACCOUNT_NAME],
            szConnectoid[CCHMAX_CONNECTOID],
            szConnection[CCHMAX_CONNECTOID + 255],
            szRes[CCHMAX_STRINGRES];
    DWORD       iConnectType;
    ACCTTYPE    AcctType;
    LV_ITEM     lvi;
    UINT        nIndex, uType;
    int         cb;
    BOOL        fDefault;
    
    if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount))) ||
        FAILED(pAccount->GetAccountType(&AcctType)))
    {   
        Assert(FALSE);
        return FALSE;
    }
    
    fDefault = FALSE;
    if (AcctType != ACCT_DIR_SERV &&
        SUCCEEDED(g_pAcctMan->GetDefaultAccountName(AcctType, szT, ARRAYSIZE(szT))))
        fDefault = (0 == lstrcmpi(szAccount, szT));
    
    // Setup listview item
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.pszText = szAccount;
    lvi.iImage = (int)AcctType;
    lvi.lParam = MAKELPARAM(AcctType, fDefault);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    nIndex = ListView_InsertItem(hwndList, &lvi);
    if (nIndex == -1)
        return FALSE;
    
    // Insert account type
    GetTypeString(szRes, ARRAYSIZE(szRes), AcctType, fDefault);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = nIndex;
    lvi.iSubItem = 1;
    lvi.pszText = szRes;
    ListView_SetItem(hwndList, &lvi);
    
    // Get Connect Type
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &iConnectType)))
        iConnectType = CONNECTION_TYPE_LAN;
    
    // If RAS, get the connect oid
    if (iConnectType == CONNECTION_TYPE_RAS)
    {
        if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnectoid, ARRAYSIZE(szConnectoid))))
            iConnectType = CONNECTION_TYPE_LAN;
    }
    
    // Build Connection String
    if (iConnectType == CONNECTION_TYPE_RAS)
    {
        LoadString(g_hInstRes, idsConnectionRAS, szRes, ARRAYSIZE(szRes));
        wsprintf(szConnection, szRes, szConnectoid);
    }
    else if (iConnectType == CONNECTION_TYPE_MANUAL)
    {
        LoadString(g_hInstRes, idsConnectionManual, szConnection, ARRAYSIZE(szConnection));
    }
    else if (iConnectType == CONNECTION_TYPE_INETSETTINGS)
    {
        LoadString(g_hInstRes, idsConnectionInetSettings, szConnection, ARRAYSIZE(szConnection));
    }
    else  
    {
        if (!!(pinfo->dwFlags & ACCTDLG_BACKUP_CONNECT) &&
            SUCCEEDED(pAccount->GetPropSz(AP_RAS_BACKUP_CONNECTOID, szConnectoid, ARRAYSIZE(szConnectoid))))
        {
            LoadString(g_hInstRes, idsConnectionLANBackup, szRes, ARRAYSIZE(szRes));
            wsprintf(szConnection, szRes, szConnectoid);
        }
        else
        {
            LoadString(g_hInstRes, idsConnectionLAN, szConnection, ARRAYSIZE(szConnection));
        }
    }
    
    // Insert connection type
    lvi.mask = LVIF_TEXT;
    lvi.iItem = nIndex;
    lvi.iSubItem = 2;
    lvi.pszText = szConnection;
    ListView_SetItem(hwndList, &lvi);
    
    // Select It
    if (fSelect)
    {
        ListView_UnSelectAll(hwndList);
        ListView_SetItemState(hwndList, nIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
    }
    
    // Done
    return TRUE;
}

BOOL Server_InitServerList(HWND hwnd, HWND hwndList, HWND hwndTab, ACCTDLGINFO *pinfo, TCHAR *szSelect)
{
    // Locals
    TC_ITEM             tci;
    int                 nIndex, iSel;
    TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
    HRESULT             hr;
    ACCTTYPE            AcctType;
    DWORD               dwSrvTypes, dwAcctFlags;
    DWORD               dwIndex=0;
    IImnEnumAccounts   *pEnumAccounts=NULL;
    IImnAccount        *pAccount=NULL;
    
    Assert(hwndList != NULL);
    Assert(hwndTab != NULL);
    Assert(pinfo != NULL);
    
    iSel = -1;
    
    nIndex = TabCtrl_GetCurSel(hwndTab);
    tci.mask = TCIF_PARAM;
    if (nIndex == -1 || !TabCtrl_GetItem(hwndTab, nIndex, &tci))
        return(FALSE);
    dwAcctFlags = (DWORD)tci.lParam;
    
    // Delete all the current items
    ListView_DeleteAllItems(hwndList);
    
    dwSrvTypes = 0;
    if (!!(dwAcctFlags & ACCT_FLAG_NEWS))
        dwSrvTypes |= SRV_NNTP;
    if (!!(dwAcctFlags & ACCT_FLAG_MAIL))
        dwSrvTypes |= SRV_MAIL;
    if (!!(dwAcctFlags & ACCT_FLAG_DIR_SERV))
        dwSrvTypes |= SRV_LDAP;
    
    if (SUCCEEDED(g_pAcctMan->IEnumerate(dwSrvTypes,
        !!(pinfo->dwFlags & ACCTDLG_NO_IMAP) ? ENUM_FLAG_NO_IMAP : 0,
        &pEnumAccounts)))
    {
        // Enumerate accounts
        while (SUCCEEDED(pEnumAccounts->GetNext(&pAccount)))
        {
            // Get Account Name
            if (szSelect != NULL && iSel == -1)
            {
                if (!FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAcct, ARRAYSIZE(szAcct))) && 
                    0 == lstrcmpi(szAcct, szSelect))
                    iSel = dwIndex;
            }
            
            if (Server_FAddAccount(hwndList, pinfo, dwIndex, pAccount, iSel == (int)dwIndex))
                dwIndex++;       
            
            // Release current account
            SafeRelease(pAccount);
        }
        
        pEnumAccounts->Release();
        
        if (iSel == -1)
        {
            // Select the first item if we haven't selected anything   
            ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
        }
    }
    
    iSel = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVIS_SELECTED);
    EnableAcctButtons(hwnd, hwndList, iSel);
    
    if (!!(pinfo->dwAcctFlags & ACCT_FLAG_DIR_SERV))
        EnableWindow(GetDlgItem(hwnd, IDB_MACCT_ORDER), !!(dwAcctFlags & ACCT_FLAG_DIR_SERV));
    
    // Done
    return TRUE;
}



void Server_RemoveServer(HWND hwndDlg)
{
    ACCTTYPE    type;
    BOOL        fDefault;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME],
        szRes[255],
        szMsg[255 + CCHMAX_ACCOUNT_NAME];
    LV_ITEM     lvi;
    LV_FINDINFO lvfi;
    int         iItemToDelete;
    IImnAccount *pAccount;
    HWND        hwndFocus;
    HWND        hwndList = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    
    // Get the selected item to know which server the user want's to kill
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVIS_SELECTED);
    lvi.iSubItem = 0;
    lvi.pszText = szAccount;
    lvi.cchTextMax = ARRAYSIZE(szAccount);
    if (ListView_GetItem(hwndList, &lvi))
    {    
        // Remember item to delete
        iItemToDelete = lvi.iItem;
        type = (ACCTTYPE)LOWORD(lvi.lParam);
        
        // Open the account
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            fDefault = (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szMsg, ARRAYSIZE(szMsg))) &&
                0 == lstrcmpi(szMsg, szAccount));
            
            hwndFocus = GetFocus();
            
            // Prompt
            LoadString(g_hInstRes, idsWarnDeleteAccount, szRes, ARRAYSIZE(szRes));
            wsprintf(szMsg, szRes, szAccount);
            if (AcctMessageBox(hwndDlg, MAKEINTRESOURCE(idsAccountManager), szMsg, NULL, MB_ICONEXCLAMATION |MB_YESNO) == IDYES)
            {
                // Delete it
                pAccount->Delete();
                
                // Remove the item
                ListView_DeleteItem(hwndList, iItemToDelete);
                
                if (fDefault &&
                    SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szMsg, ARRAYSIZE(szMsg))))
                {
                    lvfi.flags = LVFI_STRING;
                    lvfi.psz = szMsg;
                    lvi.iItem = ListView_FindItem(hwndList, -1, &lvfi);
                    if (lvi.iItem != -1)
                    {
                        lvi.mask = LVIF_PARAM;
                        lvi.iSubItem = 0;
                        lvi.lParam = MAKELPARAM(type, fDefault);
                        ListView_SetItem(hwndList, &lvi);
                        
                        GetTypeString(szMsg, ARRAYSIZE(szMsg), type, TRUE);
                        lvi.mask = LVIF_TEXT;
                        lvi.iSubItem = 1;
                        lvi.pszText = szMsg;
                        ListView_SetItem(hwndList, &lvi);
                    }
                }
                
                // Bug #21299 - Make sure something is selected when we delete.
                iItemToDelete--;
                if (iItemToDelete < 0)
                    iItemToDelete = 0;
                ListView_SetItemState(hwndList, iItemToDelete, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                
                SetFocus(hwndFocus);
            }
            
            pAccount->Release();
        }
    }
}

HRESULT  GetConnectInfoForOE(IImnAccount    *pAcct)
{
    if (pAcct)
    {
        pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_INETSETTINGS);
    }
    return S_OK;
}

static const TCHAR c_szInetGetAutodial[] = TEXT("InetGetAutodial");

typedef HRESULT (WINAPI *PFNGETAUTODIAL)(LPBOOL, LPSTR, DWORD);

HRESULT GetIEConnectInfo(IImnAccount *pAcct)
{
    HINSTANCE hlib;
    PFNGETAUTODIAL pfn;
    HRESULT hr;
    BOOL fEnable;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    
    hr = E_FAIL;
    
    hlib = LoadLibrary(c_szInetcfgDll);
    if (hlib != NULL)
    {
        pfn = (PFNGETAUTODIAL)GetProcAddress(hlib, c_szInetGetAutodial);
        if (pfn != NULL)
        {
            *sz = 0;
            hr = pfn(&fEnable, sz, sizeof(sz));
            if (SUCCEEDED(hr))
            {
                if (fEnable && *sz != 0)
                {
                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_RAS);
                    pAcct->SetPropSz(AP_RAS_CONNECTOID, sz);
                }
                else
                {
                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_LAN);
                }
            }
        }
        
        FreeLibrary(hlib);
    }
    
    return(hr);
}


BOOL Server_Create(HWND hwndParent, ACCTTYPE AcctType, ACCTDLGINFO *pinfo)
{
    HRESULT hr;
    BOOL fMail;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    TC_ITEM tci;
    int nIndex;
    DWORD dwAcctFlags, dw;
    IImnAccount *pAcctDef, *pAcct = NULL;
    HWND hwndTab = GetDlgItem(hwndParent, IDB_MACCT_TAB);
    HWND hwndList = GetDlgItem(hwndParent, IDLV_MAIL_ACCOUNTS);
    
    Assert(IsWindow(hwndParent));
    
    hr = g_pAcctMan->CreateAccountObject(AcctType, &pAcct);
    if (SUCCEEDED(hr))
    {
        if (AcctType != ACCT_DIR_SERV)
        {
            hr = g_pAcctMan->GetDefaultAccount(AcctType, &pAcctDef);
            fMail = AcctType == ACCT_MAIL;
            if (FAILED(hr))
            {
                hr = g_pAcctMan->GetDefaultAccount(fMail ? ACCT_NEWS : ACCT_MAIL, &pAcctDef);
                fMail = !fMail;
            }
            
            if (SUCCEEDED(hr))
            {
                hr = pAcctDef->GetPropSz(fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, sz, ARRAYSIZE(sz));
                if (SUCCEEDED(hr))
                    pAcct->SetPropSz(AcctType == ACCT_MAIL ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, sz);
                
                hr = pAcctDef->GetPropSz(fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, sz, ARRAYSIZE(sz));
                if (SUCCEEDED(hr))
                    pAcct->SetPropSz(AcctType == ACCT_MAIL ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, sz);
                
                hr = pAcctDef->GetPropDw(AP_RAS_CONNECTION_TYPE, &dw);
                if (SUCCEEDED(hr))
                {
                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dw);
//                    if (dw == CONNECTION_TYPE_RAS || dw == CONNECTION_TYPE_INETSETTINGS)
                    if (dw == CONNECTION_TYPE_RAS)
                    {
                        hr = pAcctDef->GetPropSz(AP_RAS_CONNECTOID, sz, ARRAYSIZE(sz));
                        if (SUCCEEDED(hr))
                            pAcct->SetPropSz(AP_RAS_CONNECTOID, sz);
                    }
                }
                
                pAcctDef->Release();
            }
            else
            {
                GetIEConnectInfo(pAcct);
            }
        }
        
        DWORD  dwFlags = 0;
        if (pinfo->dwFlags & ACCTDLG_INTERNETCONNECTION)
            dwFlags |= ACCT_WIZ_INTERNETCONNECTION;
        if (pinfo->dwFlags & ACCTDLG_HTTPMAIL)
            dwFlags |= ACCT_WIZ_HTTPMAIL;
        if (pinfo->dwFlags & ACCTDLG_OE)
            dwFlags |= ACCT_WIZ_OE;
        
        (pinfo->dwFlags & ACCTDLG_NO_NEW_POP) ? (dwFlags | ACCT_WIZ_NO_NEW_POP) : dwFlags;
        
        hr = pAcct->DoWizard(hwndParent, dwFlags);
        if (hr == S_OK)
        {
            hr = pAcct->GetPropSz(AP_ACCOUNT_NAME, sz, ARRAYSIZE(sz));
            
            if (SUCCEEDED(hr))
            {
                nIndex = TabCtrl_GetCurSel(hwndTab);
                tci.mask = TCIF_PARAM;
                if (nIndex >= 0 && TabCtrl_GetItem(hwndTab, nIndex, &tci))
                {
                    dwAcctFlags = (DWORD)tci.lParam;
                    if (0 == (dwAcctFlags & c_mpAcctFlag[AcctType]))
                    {
                        // the current page doesn't show this type of account,
                        // so we need to force a switch to the all tab
#ifdef DEBUG
                        tci.mask = TCIF_PARAM;
                        Assert(TabCtrl_GetItem(hwndTab, 0, &tci));
                        Assert(!!((DWORD)(tci.lParam) & c_mpAcctFlag[AcctType]));
#endif // DEBUG
                    
                        TabCtrl_SetCurSel(hwndTab, 0);
                        Server_InitServerList(hwndParent, hwndList, hwndTab, pinfo, sz);
                    }
                    else
                    {
                        Server_FAddAccount(hwndList, pinfo, 0, pAcct, TRUE);
                    }
                }
            }
        }
        
        pAcct->Release();    
    }
    
    return(TRUE);
}

BOOL Server_Properties(HWND hwndDlg, ACCTDLGINFO *pinfo)
{
    HWND        hwndFocus;
    LV_ITEM     lvi;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME];
    HWND        hwndList = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    IImnAccount   *pAccount;
    
    hwndFocus = GetFocus();
    
    // Find out which item is selected
    lvi.mask = LVIF_TEXT;
    lvi.pszText = szAccount;
    lvi.cchTextMax = ARRAYSIZE(szAccount);
    lvi.iSubItem = 0;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_SELECTED);
    if (lvi.iItem == -1 ||
        !ListView_GetItem(hwndList, &lvi))
        return FALSE;
    
    // Display the property sheet
    if (ServerProp_Create(hwndDlg, pinfo->dwFlags, szAccount, &pAccount))
    {
        Assert(pAccount);
        
        ListView_DeleteItem(hwndList, lvi.iItem);
        Server_FAddAccount(hwndList, pinfo, 0, pAccount, TRUE);
        
        pAccount->Release();
    }
    
    SetFocus(hwndFocus);
    
    // Done
    return TRUE;
}

#if WINVER < 0X0500
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif

void DoAddAccountMenu(HWND hwnd, ACCTDLGINFO *pinfo)
{
    RECT rc;
    HMENU hmenu, hmenuParent;
    
    hmenu = NULL;
    hmenuParent = LoadMenu(g_hInstRes, MAKEINTRESOURCE(idmrAddAccount));
    
    if (hmenuParent != NULL)
    {
        hmenu = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
    }
    
    if (hmenu != NULL)
    {
        if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_NEWS))
            DeleteMenu(hmenu, idmAddNews, MF_BYCOMMAND);
        if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_MAIL))
            DeleteMenu(hmenu, idmAddMail, MF_BYCOMMAND);
        if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_DIR_SERV))
            DeleteMenu(hmenu, idmAddDirServ, MF_BYCOMMAND);
        
        GetWindowRect(GetDlgItem(hwnd, IDB_MACCT_ADD), &rc);
        
        TrackPopupMenuEx(hmenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
        (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)? rc.left : rc.right, rc.top, hwnd, NULL);
        DestroyMenu(hmenu);
    }
}

BOOL SetDefaultAccount(HWND hwnd, HWND hwndList)
{
    LV_ITEM         lvi;
    int             iSel, index;
    IImnAccount     *pAccount;
    BOOL            fRet;
    ACCTTYPE        AcctType;
    TCHAR           szRes[CCHMAX_ACCOUNT_NAME];
    
    fRet = FALSE;
    iSel = ListView_GetFirstSel(hwndList);
    
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = iSel;
    lvi.iSubItem = 0;
    lvi.pszText = szRes;
    lvi.cchTextMax = ARRAYSIZE(szRes);
    if (ListView_GetItem(hwndList, &lvi))
    {
        AcctType = (ACCTTYPE)LOWORD(lvi.lParam);
        Assert(0 == HIWORD(lvi.lParam));
        
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szRes, &pAccount)))
        {
            if (SUCCEEDED(pAccount->SetAsDefault()))
            {
                index = -1;
                lvi.mask = LVIF_PARAM;
                while (-1 != (index = ListView_GetNextItem(hwndList, index, LVNI_ALL)))
                {
                    lvi.iItem = index;
                    if (ListView_GetItem(hwndList, &lvi) &&
                        (ACCTTYPE)(LOWORD(lvi.lParam)) == AcctType &&
                        !!HIWORD(lvi.lParam))
                    {
                        lvi.lParam = MAKELPARAM(AcctType, FALSE);
                        ListView_SetItem(hwndList, &lvi);
                        
                        GetTypeString(szRes, ARRAYSIZE(szRes), AcctType, FALSE);
                        lvi.mask = LVIF_TEXT;
                        lvi.iSubItem = 1;
                        lvi.pszText = szRes;
                        ListView_SetItem(hwndList, &lvi);
                        break;
                    }
                }
                
                lvi.mask = LVIF_PARAM;
                lvi.iItem = iSel;
                lvi.iSubItem = 0;
                lvi.lParam = MAKELPARAM(AcctType, TRUE);
                ListView_SetItem(hwndList, &lvi);
                
                GetTypeString(szRes, ARRAYSIZE(szRes), AcctType, TRUE);
                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 1;
                lvi.pszText = szRes;
                ListView_SetItem(hwndList, &lvi);
                
                fRet = TRUE;
            }
            
            pAccount->Release();
        }
    }                    
    
    return(fRet);
}

void EnableAcctButtons(HWND hwnd, HWND hwndList, UINT iItem)
{
    BOOL fEnable;
    LV_ITEM lvi;
    
    fEnable = ListView_GetSelectedCount(hwndList);
    
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_REMOVE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_PROP), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_EXPORT), fEnable);
    
    if (fEnable)
    {
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        fEnable = (
            ListView_GetItem(hwndList, &lvi) &&
            (ACCTTYPE)(LOWORD(lvi.lParam)) != ACCT_DIR_SERV &&
            0 == HIWORD(lvi.lParam));
    }
    
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_DEFAULT), fEnable);
}

typedef struct tagACCTTAB
{
    ACCTTYPE type;
    DWORD dwAcctFlag;
    UINT iText;
} ACCTTAB;

const static ACCTTAB c_rgAcctTab[ACCT_LAST] = {
    {ACCT_MAIL, ACCT_FLAG_MAIL, idsMailCap},
    {ACCT_NEWS, ACCT_FLAG_NEWS, idsNewsCap},
    {ACCT_DIR_SERV, ACCT_FLAG_DIR_SERV, idsDirectoryServiceCap}
};

const static c_rgAcctListHdrs[] = {idsAccount, idsType, idsConnection};

void InitAccountListDialog(HWND hwnd, HWND hwndList, ACCTDLGINFO *pinfo)
{
    int             i, cTab, nIndex, iTabInit;
    BOOL            fEnable;
    HFONT           hfont, hfontOld;
    POINT           point;
    TC_ITEM         tci;
    IImnAccount     *pAccount;
    LV_HITTESTINFO  lvh;
    LV_COLUMN       lvc;
    RECT            rc;
    TCHAR           szRes[CCHMAX_STRINGRES];
    HIMAGELIST      himl;    
    HWND            hwndTab;
    
    // this button is only interesting when LDAP servers are shown
    if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_DIR_SERV))
        DestroyWindow(GetDlgItem(hwnd, IDB_MACCT_ORDER));
    
    // initialize the tabs
    hwndTab = GetDlgItem(hwnd, IDB_MACCT_TAB);
    cTab = 0;
    iTabInit = -1;
    tci.mask = TCIF_TEXT | TCIF_PARAM;
    tci.pszText = szRes;
    for (i = 0; i < ACCT_LAST; i++)
    {
        if (!!(pinfo->dwAcctFlags & c_rgAcctTab[i].dwAcctFlag))
        {
            LoadString(g_hInstRes, c_rgAcctTab[i].iText, szRes, ARRAYSIZE(szRes));
            tci.lParam = (LPARAM)(c_rgAcctTab[i].dwAcctFlag);
            nIndex = TabCtrl_InsertItem(hwndTab, cTab, &tci);
            Assert(nIndex == cTab);
            
            pinfo->AcctType = c_rgAcctTab[i].type;
            if (pinfo->AcctTypeInit == pinfo->AcctType)
                iTabInit = cTab;
            
            cTab++;
        }
    }
    
    Assert(cTab > 0);
    Assert(iTabInit < cTab);
    
    if (cTab > 1)
    {
        LoadString(g_hInstRes, idsAll, szRes, ARRAYSIZE(szRes));
        tci.lParam = (LPARAM)(pinfo->dwAcctFlags);
        // insert the all tab first
        nIndex = TabCtrl_InsertItem(hwndTab, 0, &tci);
        Assert(nIndex == 0);
        
        TabCtrl_SetCurSel(hwndTab, iTabInit + 1);
    }
    
    DestroyWindow(GetDlgItem(hwnd, cTab == 1 ? IDB_MACCT_ADD : IDB_MACCT_ADD_NOMENU));
    
    // Get client rect
    GetClientRect(hwndList, &rc);
    rc.right = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    
    for (i = 0; i < ARRAYSIZE(c_rgAcctListHdrs); i++)
    {
        LoadString(g_hInstRes, c_rgAcctListHdrs[i], szRes, ARRAYSIZE(szRes));
        lvc.mask = LVCF_WIDTH | LVCF_TEXT;
        lvc.cx = (rc.right / ARRAYSIZE(c_rgAcctListHdrs));
        lvc.pszText = szRes;
        lvc.cchTextMax = lstrlen(szRes);
        ListView_InsertColumn(hwndList, i, &lvc);
    }
    
    // Remove Import Export if not OE
    if (!!(pinfo->dwFlags & ACCT_WIZ_OUTLOOK))
    {
        ShowWindow(GetDlgItem(hwnd, IDB_MACCT_EXPORT), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDB_MACCT_IMPORT), SW_HIDE);
    }
    
    // Add Folders Imagelist
    himl = ImageList_LoadBitmap(g_hInstRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL); 
    
    // Fill The list view with servers
    Server_InitServerList(hwnd, hwndList, hwndTab, pinfo, NULL);
}

const static HELPMAP g_rgCtxMapAccounts[] = {
    {IDLV_MAIL_ACCOUNTS, IDH_NEWS_SERV_SERVERS},
    {IDB_MACCT_ADD, IDH_NEWS_SERV_ADD},
    {IDB_MACCT_ADD_NOMENU, IDH_NEWS_SERV_ADD},
    {IDB_MACCT_REMOVE, IDH_NEWS_SERV_REMOVE},
    {IDB_MACCT_PROP, IDH_NEWS_SERV_PROPERTIES},
    {IDB_MACCT_DEFAULT, IDH_INETCOMM_SETASDEFAULT},
    {IDB_MACCT_ORDER, IDH_INETCOM_DS_SETORDER},
    {IDB_MACCT_EXPORT, 502},
    {IDB_MACCT_IMPORT, 501},
    {0, 0}};
    
    // This is a standalone dialog box now, it is not in the options property sheet
    INT_PTR CALLBACK ManageAccountsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        int             i, nIndex;
        BOOL            fEnable;
        LV_ITEM         lvi;
        POINT           point;
        LV_HITTESTINFO  lvh;
        ACCTDLGINFO     *pinfo;
        HWND            hwndList = GetDlgItem(hwnd, IDLV_MAIL_ACCOUNTS);
        
        pinfo = (ACCTDLGINFO *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
        
        switch (uMsg)
        {
        case WM_INITDIALOG:
            pinfo = (ACCTDLGINFO *)lParam;
            Assert(pinfo != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pinfo);
            
            SetIntlFont(hwndList);
            
            InitAccountListDialog(hwnd, hwndList, pinfo);
            return(TRUE);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapAccounts));
            
        case WM_DRAWITEM:
            if (wParam == IDB_MACCT_ADD)
            {
                DrawAddButton(hwnd, (LPDRAWITEMSTRUCT)lParam, pinfo);
                return(TRUE);
            }
            break;
            
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
            case IDOK:
            case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;
                
            case IDB_MACCT_ADD:
                DoAddAccountMenu(hwnd, pinfo);
                break;
                
            case IDB_MACCT_ADD_NOMENU:
                // this should only get hit if we have only
                // one type of account in the dialog
                Server_Create(hwnd, pinfo->AcctType, pinfo);
                break;
                
            case IDB_MACCT_PROP:
                Server_Properties(hwnd, pinfo);
                break;
                
            case IDB_MACCT_ORDER:
                DialogBox(g_hInstRes, MAKEINTRESOURCE(iddSetOrder), hwnd, SetOrderDlgProc);
                break;
                
            case idmAddNews:
                Server_Create(hwnd, ACCT_NEWS, pinfo);
                break;
                
            case idmAddMail:
                Server_Create(hwnd, ACCT_MAIL, pinfo);
                break;
                
            case idmAddDirServ:
                Server_Create(hwnd, ACCT_DIR_SERV, pinfo);
                break;
                
            case IDB_MACCT_REMOVE:
                Server_RemoveServer(hwnd);
                break;
                
            case IDB_MACCT_EXPORT:
                Server_ExportServer(hwnd);
                break;
                
            case IDB_MACCT_IMPORT:
                Server_ImportServer(hwnd, pinfo);
                break;
                
            case IDB_MACCT_DEFAULT:
                if (SetDefaultAccount(hwnd, hwndList))
                {
                    SetFocus(hwndList);
                    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_DEFAULT), FALSE);
                }
                else
                {
                    AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrSetDefNoSmtp), NULL, MB_OK | MB_ICONEXCLAMATION);
                }
                break;
            }              
            break;
            
            case WM_NOTIFY:
                LPNMHDR pnmhdr = (LPNMHDR) lParam;
                
                switch (((NMHDR *)lParam)->code)
                {
                case NM_DBLCLK:
                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hwndList, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hwndList, &lvh);
                    if (nIndex >= 0 && lvh.flags & LVHT_ONITEMLABEL)
                        SendMessage(hwnd, WM_COMMAND, IDB_MACCT_PROP, 0L);
                    break;
                    
                case LVN_ITEMCHANGED:
                    EnableAcctButtons(hwnd, hwndList, ((NM_LISTVIEW *)pnmhdr)->iItem);
                    break;    
                    
                case TCN_SELCHANGE:
                    Server_InitServerList(hwnd, hwndList, pnmhdr->hwndFrom, pinfo, NULL);
                    break;
                }
                break;
        }
        return (FALSE);
    }
    
    void DrawArrow(HDC hdc, int x, int y, int dx, int dy, BOOL fPrev)
    {
        int i, iCount, sign, inc;
        HBRUSH hbrush;
        HGDIOBJ hbrushOld;
        
        hbrush = GetSysColorBrush(COLOR_BTNTEXT);
        hbrushOld = SelectObject(hdc, hbrush);
        
        iCount = (dy + 1) / 2;
        
        // draw arrow body
        // PatBlt(hdc, (fPrev ? x + iCount : x), y + 4, dx - iCount, dy - 8, PATCOPY); 
        
        if (fPrev)
        {
            sign = -1;
            dy = (dy % 2) ? 1 : 2;
            y += iCount - 1;
        }
        else
        {
            sign = 1;
        }
        inc = 2 * sign;
        
        if (!fPrev)
            x += dx - iCount;
        
        // draw arrow head
        for (i = 0; i < iCount; i++, dy -= inc, y += sign)
            PatBlt(hdc, x++, y, 1, dy, PATCOPY);
        
        SelectObject(hdc, hbrushOld);
    }
    
    void DrawAddButton(HWND hwnd, LPDRAWITEMSTRUCT pdi, ACCTDLGINFO *pinfo)
    {
        BOOL fPushed;
        TCHAR sz[32];
        RECT rcArrow, rcText, rcFocus;
        int d, cch;
        
        Assert(pdi->CtlType == ODT_BUTTON);
        Assert(pdi->CtlID == IDB_MACCT_ADD);
        
        fPushed = !!(pdi->itemState & ODS_SELECTED);
        
        rcArrow = pdi->rcItem;
        rcFocus = pdi->rcItem;
        if (fPushed)
        {
            rcArrow.left++;
            rcArrow.right++;
            rcArrow.top++;
            rcArrow.bottom++;
        }
        rcText = rcArrow;
        rcArrow.left = rcArrow.right - (rcArrow.bottom - rcArrow.top);
        rcText.right = rcArrow.left;
        d = GetSystemMetrics(SM_CXEDGE);
        rcText.left += d;
        rcArrow.right -= d;
        rcFocus.left += d;
        rcFocus.right -= d;
        d = GetSystemMetrics(SM_CYEDGE);
        rcArrow.top += d;
        rcArrow.bottom -= d;
        rcText.top = rcArrow.top;
        rcText.bottom  = rcArrow.bottom;
        rcFocus.top = rcArrow.top;
        rcFocus.bottom  = rcArrow.bottom;
        
        if (!!(pdi->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
        {
            cch = GetWindowText(pdi->hwndItem, sz, ARRAYSIZE(sz));
            
            DrawFrameControl(pdi->hDC, &pdi->rcItem, DFC_BUTTON, DFCS_BUTTONPUSH | (fPushed ? DFCS_PUSHED : 0));
            
            d = min(rcArrow.bottom - rcArrow.top - 4, 9);
            d = ((rcArrow.bottom - rcArrow.top) - d) / 2;
            rcArrow.top += d;
            rcArrow.bottom -= d;
            rcArrow.right -= d;
            DrawArrow(pdi->hDC, rcArrow.left, rcArrow.top, rcArrow.right - rcArrow.left, rcArrow.bottom - rcArrow.top, FALSE);
            
            DrawText(pdi->hDC, sz, cch, &rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }
        
        if (!!(pdi->itemAction & ODA_FOCUS) || !!(pdi->itemState & ODS_FOCUS))
        {
            rcFocus.left++;
            rcFocus.right--;
            rcFocus.top++;
            rcFocus.bottom--;
            DrawFocusRect(pdi->hDC, &rcFocus);
        }
    }
    
    int AcctMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle)
    {
        TCHAR rgchTitle[CCHMAX_STRINGRES];
        TCHAR rgchText[2 * CCHMAX_STRINGRES + 2];
        LPTSTR szText;
        int cch;
        
        Assert(sz1);
        Assert(szTitle != NULL);
        
        if (IS_INTRESOURCE(szTitle))
        {
            // its a string resource id
            cch = LoadString(g_hInstRes, PtrToUlong(szTitle), rgchTitle, CCHMAX_STRINGRES);
            if (cch == 0)
                return(0);
            
            szTitle = rgchTitle;
        }
        
        if (!(IS_INTRESOURCE(sz1)))
        {
            // its a pointer to a string
            Assert(lstrlen(sz1) < CCHMAX_STRINGRES);
            if (NULL == lstrcpy(rgchText, sz1))
                return(0);
            
            cch = lstrlen(rgchText);
        }
        else
        {
            // its a string resource id
            cch = LoadString(g_hInstRes, PtrToUlong(sz1), rgchText, 2 * CCHMAX_STRINGRES);
            if (cch == 0)
                return(0);
        }
        
        if (sz2)
        {
            //$$REVIEW is this right??
            //$$REVIEW will this work with both ANSI/UNICODE?
            
            // there's another string that we need to append to the
            // first string...
            szText = &rgchText[cch];
            *szText = '\n';
            
            szText++;
            *szText = '\n';
            szText++;
            
            if (!(IS_INTRESOURCE(sz2)))
            {
                // its a pointer to a string
                Assert(lstrlen(sz2) < CCHMAX_STRINGRES);
                if (NULL == lstrcpy(szText, sz2))
                    return(0);
            }
            else
            {
                Assert((2 * CCHMAX_STRINGRES - (szText - rgchText)) > 0);
                if (0 == LoadString(g_hInstRes, PtrToUlong(sz2), szText, (int) (2 * CCHMAX_STRINGRES - (szText - rgchText))))
                    return(0);
            }
        }
        
        return(MessageBox(hwndOwner, rgchText, szTitle, MB_SETFOREGROUND | fuStyle));
    }
    
#define OPTION_OFF  0xffffffff
    
    void InitCheckCounter(DWORD dw, HWND hwnd, int idcCheck, int idcEdit, int idcSpin, int min, int max, int def)
    {
        BOOL f;
        int digit;
        
        f = (dw != OPTION_OFF);
        CheckDlgButton(hwnd, idcCheck, f ? BST_CHECKED : BST_UNCHECKED);            
        SendDlgItemMessage(hwnd, idcSpin, UDM_SETRANGE, 0, MAKELONG(max, min));
        
        if (!f)
            dw = def;
        
        Assert(min <= (int)dw);
        Assert(max >= (int)dw);
        
        digit = 1;
        while (max >= 10)
        {
            max = max / 10;
            digit++;
        }
        SendDlgItemMessage(hwnd, idcEdit, EM_LIMITTEXT, (WPARAM)digit, 0);
        
        SetDlgItemInt(hwnd, idcEdit, dw, FALSE);
        EnableWindow(GetDlgItem(hwnd, idcEdit), f);
    }
    
    INT_PTR CALLBACK SetOrderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        NMHDR *pnmhdr;
        BOOL fRet;
        WORD id;
        HIMAGELIST himl;
        HWND hwndList;
        
        fRet = TRUE;
        
        switch (msg)
        {
        case WM_INITDIALOG:
            hwndList = GetDlgItem(hwnd, IDC_ORDER_LIST);
            SetIntlFont(hwndList);
            
            himl = ImageList_LoadBitmap(g_hInstRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
            ListView_SetImageList(hwndList, himl, LVSIL_SMALL); 
            
            InitSetOrderList(hwndList);
            
            SetUpDownButtons(hwnd, hwndList);
            break;
            
        case WM_COMMAND:
            id = LOWORD(wParam);
            
            switch (id)
            {
            case IDOK:
                SaveLDAPResolveOrder(hwnd, GetDlgItem(hwnd, IDC_ORDER_LIST));
                
            case IDCANCEL:
                EndDialog(hwnd, id);
                break;
                
            case IDC_UP_BUTTON:
            case IDC_DOWN_BUTTON:
                MoveLDAPItemUpDown(hwnd, id == IDC_UP_BUTTON);
                break;
            }
            break;
            
            case WM_NOTIFY:
                pnmhdr = (NMHDR *)lParam;
                switch (pnmhdr->code)
                {
                case LVN_ITEMCHANGED:
                    SetUpDownButtons(hwnd, GetDlgItem(hwnd, IDC_ORDER_LIST));
                    break;
                }
                break;
                
                default:
                    fRet = FALSE;
                    break;
        }
        
        return(fRet);
    }
    
    void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp)
    {
        int iMoveToIndex;
        TCHAR szBufItem[CCHMAX_ACCOUNT_NAME];
        TCHAR szBufOtherItem[CCHMAX_ACCOUNT_NAME];
        HWND hWndLV = GetDlgItem(hDlg, IDC_ORDER_LIST);
        int iItemIndex = ListView_GetSelectedCount(hWndLV);
        int iListCount = ListView_GetItemCount(hWndLV);
        
        Assert(1 == ListView_GetSelectedCount(hWndLV));
        
        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
        
        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        
        Assert(bMoveUp ? (iItemIndex != 0) : (iItemIndex != (iListCount - 1)));
        
        iMoveToIndex = (bMoveUp) ? (iItemIndex - 1) : (iItemIndex + 1);
        
        // Basically since these list view items have no parameters of interest
        // other than the text, we can swap the text (looks cleaner)
        
        // Get the selected item text
        ListView_GetItemText(hWndLV, iItemIndex, 0,szBufItem, ARRAYSIZE(szBufItem));
        ListView_GetItemText(hWndLV, iMoveToIndex, 0, szBufOtherItem, ARRAYSIZE(szBufOtherItem));
        
        ListView_SetItemText(hWndLV, iMoveToIndex, 0, szBufItem);
        ListView_SetItemText(hWndLV, iItemIndex, 0, szBufOtherItem);
        
        ListView_SetItemState(hWndLV, iMoveToIndex,	LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        ListView_EnsureVisible (hWndLV, iMoveToIndex, FALSE);
       