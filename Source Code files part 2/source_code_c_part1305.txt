         MyFree(pPrevious->pInfo);
            MyFree(pPrevious);
        }
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

ULONG       s_KeyrEnumerateProviderTypes(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcProviderCount,
/* [in, out][size_is(,*pcProviderCount)] */
                PKEYSVC_PROVIDER_INFO           *ppProviders)
{
    PTMP_LIST_INFO          pStart = NULL;
    PTMP_LIST_INFO          pTmpList = NULL;
    PTMP_LIST_INFO          pPrevious = NULL;
    PKEYSVC_PROVIDER_INFO   pProvInfo;
    DWORD                   dwProvType;
    DWORD                   cbName = 0;;
    DWORD                   cbTotal = 0;
    DWORD                   cTypes = 0;
    DWORD                   i;
    DWORD                   j;
    BYTE                    *pb;
    KEYSVC_CONTEXT          *pContext = NULL;
    BOOL                    fImpersonated = FALSE;
    DWORD                   dwErr = 0;

    __try
    {
        *pcProviderCount = 0;
        *ppProviders = NULL;

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        // CryptoAPI enumerates one at a time
        // so we must accumulate for total enumeration
        for (i=0;;i++)
        {
            if (!CryptEnumProviderTypesW(i, NULL, 0, &dwProvType,
                                         NULL, &cbName))
            {
                if (ERROR_NO_MORE_ITEMS != GetLastError())
                {
                    dwErr = NTE_FAIL; 
                    goto Ret;
                }
                break;
            }
            if (NULL == (pTmpList = (PTMP_LIST_INFO)MyAlloc(sizeof(TMP_LIST_INFO))))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }

            if (NULL == (pTmpList->pInfo = MyAlloc(sizeof(KEYSVC_PROVIDER_INFO) +
                                                   cbName)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            pProvInfo = (PKEYSVC_PROVIDER_INFO)pTmpList->pInfo;
            pProvInfo->Name.Length = (USHORT)cbName;
            pProvInfo->Name.MaximumLength = (USHORT)cbName;

            if (0 != cbName)
            {
                pProvInfo->Name.Buffer = (USHORT*)((BYTE*)(pProvInfo) +
                                                   sizeof(KEYSVC_PROVIDER_INFO));
            }
            if (!CryptEnumProviderTypesW(i, NULL, 0, &pProvInfo->ProviderType,
                                         pProvInfo->Name.Buffer, &cbName))
            {
                if (ERROR_NO_MORE_ITEMS != GetLastError())
                {
                    MyFree(pProvInfo);
                    dwErr = NTE_FAIL;  
                    goto Ret;
                }
                break;
            }
            cbTotal += cbName;

            if (0 == i)
            {
                pStart = pTmpList;
            }
            else
            {
                pPrevious->pNext = pTmpList;
            }
            pPrevious = pTmpList;
            pTmpList = NULL;
        }

        // now copy into one big structure
        pPrevious = pStart;
        if (0 != i)
        {
            *pcProviderCount = i;
            if (NULL == (*ppProviders =
                (PKEYSVC_PROVIDER_INFO)MyAlloc((i * sizeof(KEYSVC_PROVIDER_INFO)) +
                                               cbTotal)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            pb = (BYTE*)(*ppProviders) + i * sizeof(KEYSVC_PROVIDER_INFO);

            // copy the provider information over
            for (j=0;j<i;j++)
            {
                pProvInfo = (PKEYSVC_PROVIDER_INFO)pPrevious->pInfo;
                (*ppProviders)[j].ProviderType = pProvInfo->ProviderType;
                (*ppProviders)[j].Name.Length = pProvInfo->Name.Length;
                (*ppProviders)[j].Name.MaximumLength = pProvInfo->Name.MaximumLength;
                if (0 != (*ppProviders)[j].Name.Length)
                {
                    memcpy(pb, (BYTE*)(pProvInfo->Name.Buffer),
                           (*ppProviders)[j].Name.Length);
                    (*ppProviders)[j].Name.Buffer = (USHORT*)pb;
                }
                pb += (*ppProviders)[j].Name.Length;
                pPrevious = pPrevious->pNext;
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (pTmpList)
            MyFree(pTmpList);
        // free the list
        for (i=0;;i++)
        {
            if (NULL == pStart)
                break;
            pPrevious = pStart;
            pStart = pPrevious->pNext;
            if (pPrevious->pInfo)
                MyFree(pPrevious->pInfo);
            MyFree(pPrevious);
        }
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

DWORD GetKeyIDs(
                KEYSVC_PROVIDER_INFO *pProvider,
                LPWSTR pszContainerName,
                DWORD *pcKeyIDs,
                PKEY_ID *ppKeyIDs,
                DWORD dwFlags)
{
    HCRYPTPROV  hProv = 0;
    HCRYPTKEY   hKey = 0;
    KEY_ID      rgKeyIDs[2];
    DWORD       cbData;
    DWORD       dwKeySpec;
    DWORD       i;
    DWORD       dwErr = 0;

    *pcKeyIDs = 0;
    memset(rgKeyIDs, 0, sizeof(rgKeyIDs));

    // acquire the context
    if (!CryptAcquireContextU(&hProv, pszContainerName, pProvider->Name.Buffer,
                              pProvider->ProviderType, dwFlags))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // try and get the AT_SIGNATURE key
    for (i=0;i<2;i++)
    {
        // probably need to enumerate all key specs
        if (0 == i)
            dwKeySpec = AT_SIGNATURE;
        else
            dwKeySpec = AT_KEYEXCHANGE;

        if (CryptGetUserKey(hProv, dwKeySpec, &hKey))
        {
            rgKeyIDs[*pcKeyIDs].dwKeySpec = dwKeySpec;
            cbData = sizeof(ALG_ID);
            if (!CryptGetKeyParam(hKey, KP_ALGID,
                                  (BYTE*)(&rgKeyIDs[*pcKeyIDs].Algid),
                                  &cbData, 0))
            {
                dwErr = GetLastError();
                goto Ret;
            }
            (*pcKeyIDs)++;
            CryptDestroyKey(hKey);
            hKey = 0;
        }
    }

    // allocate the final structure to hold the key ids and copy them in
    if (*pcKeyIDs)
    {
        if (NULL == (*ppKeyIDs = (PKEY_ID)MyAlloc(*pcKeyIDs * sizeof(KEY_ID))))
        {
            goto Ret;
        }
        for (i=0;i<*pcKeyIDs;i++)
        {
            memcpy((BYTE*)(&(*ppKeyIDs)[i]), (BYTE*)(&rgKeyIDs[i]), sizeof(KEY_ID));
        }
    }
Ret:
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    return dwErr;
}

ULONG       s_KeyrEnumerateProvContainers(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      KEYSVC_PROVIDER_INFO            Provider,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcContainerCount,
/* [in, out][size_is(,*pcContainerCount)] */
                PKEYSVC_UNICODE_STRING          *ppContainers)
{
    HCRYPTPROV              hProv = 0;
    PTMP_LIST_INFO          pStart = NULL;
    PTMP_LIST_INFO          pTmpList = NULL;
    PTMP_LIST_INFO          pPrevious = NULL;
    PKEYSVC_UNICODE_STRING  pContainer;
    DWORD                   i;
    DWORD                   j;
    BYTE                    *pb;
    DWORD                   cbContainerName;
    DWORD                   cbMaxContainerName = 0;
    LPSTR                   pszContainerName = NULL;
    DWORD                   cbContainerTotal = 0;
    KEYSVC_CONTEXT          *pContext = NULL;
    DWORD                   dwFlags = 0;
    DWORD                   dwMachineFlag = 0;
    BOOL                    fImpersonated = FALSE;
    BYTE                    *pbJunk = NULL;
    DWORD                   cch;
    DWORD                   dwErr = 0;

    __try
    {
        *pcContainerCount = 0;
        *ppContainers = NULL;

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        if (KeySvcMachine == pContext->dwType)
        {
            dwMachineFlag = CRYPT_MACHINE_KEYSET;
        }

        if (!CryptAcquireContextU(&hProv, NULL, Provider.Name.Buffer,
                                  Provider.ProviderType,
                                  dwMachineFlag | CRYPT_VERIFYCONTEXT))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        // CryptoAPI enumerates one at a time
        // so we must accumulate for total enumeration
        CryptGetProvParam(hProv, PP_ENUMCONTAINERS, NULL, &cbMaxContainerName,
                          CRYPT_FIRST);
        if (cbMaxContainerName > 0)
        {
            if (NULL == (pszContainerName = (LPSTR)MyAlloc(cbMaxContainerName)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
        }

        for (i=0;;i++)
        {
            if (0 == i)
                dwFlags = CRYPT_FIRST;
            else
                dwFlags = CRYPT_NEXT;
            if (NULL == (pTmpList = (PTMP_LIST_INFO)MyAlloc(sizeof(TMP_LIST_INFO))))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }

            cbContainerName = cbMaxContainerName;
            if (!CryptGetProvParam(hProv, PP_ENUMCONTAINERS, (BYTE*)pszContainerName,
                                   &cbContainerName, dwFlags))
            {
                // BUG in rsabase - doesn't return correct error code
//                if (ERROR_NO_MORE_ITEMS != GetLastError())
//                {
//                    dwErr = NTE_FAIL; 
//                    goto Ret;
//                }
                break;
            }

            // convert from ansi to unicode
            if (0 == (cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                                pszContainerName,
                                                -1, NULL, cch)))
            {
                dwErr = GetLastError();
                goto Ret;
            }

            if (NULL == (pTmpList->pInfo = MyAlloc(sizeof(KEYSVC_UNICODE_STRING) +
                                                   (cch + 1) * sizeof(WCHAR))))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            pContainer = (PKEYSVC_UNICODE_STRING)pTmpList->pInfo;
            pContainer->Length = (USHORT)(cch * sizeof(WCHAR));
            pContainer->MaximumLength = (USHORT)((cch + 1) * sizeof(WCHAR));

            pContainer->Buffer = (USHORT*)((BYTE*)(pContainer) +
                                           sizeof(KEYSVC_UNICODE_STRING));
            if (0 == (cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                         pszContainerName,
                                         -1, pContainer->Buffer, cch)))
            {
                 goto Ret;
            }

            cbContainerTotal += pContainer->Length + sizeof(WCHAR);

            if (0 == i)
            {
                pStart = pTmpList;
            }
            else
            {
                pPrevious->pNext = pTmpList;
            }
            pPrevious = pTmpList;
            pTmpList = NULL;
        }

        // now copy into one big structure
        pPrevious = pStart;
        if (0 != i)
        {
            *pcContainerCount = i;
            if (NULL == (*ppContainers =
                (PKEYSVC_UNICODE_STRING)MyAlloc((i * sizeof(KEYSVC_UNICODE_STRING)) +
                                                cbContainerTotal)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            pb = (BYTE*)(*ppContainers) + i * sizeof(KEYSVC_UNICODE_STRING);

            // copy the provider information over
            for (j=0;j<i;j++)
            {
                pContainer = (PKEYSVC_UNICODE_STRING)pPrevious->pInfo;
                (*ppContainers)[j].Length = pContainer->Length;
                (*ppContainers)[j].MaximumLength = pContainer->MaximumLength;
                if (0 != (*ppContainers)[j].Length)
                {
                    memcpy(pb, (BYTE*)(pContainer->Buffer),
                           (*ppContainers)[j].Length + sizeof(WCHAR));
                    (*ppContainers)[j].Buffer = (USHORT*)pb;
                }

                pb += (*ppContainers)[j].Length + sizeof(WCHAR);
                pPrevious = pPrevious->pNext;
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (pszContainerName)
            MyFree(pszContainerName);
        if (hProv)
            CryptReleaseContext(hProv, 0);
        if (pTmpList)
            MyFree(pTmpList);
        // free the list
        for (i=0;;i++)
        {
            if (NULL == pStart)
                break;
            pPrevious = pStart;
            pStart = pPrevious->pNext;
            if (pPrevious->pInfo)
                MyFree(pPrevious->pInfo);
            MyFree(pPrevious);
        }
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}


ULONG       s_KeyrCloseKeyService(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved)
{
    DWORD           dwErr = 0;

    __try
    {
        dwErr = RemoveKeySvcHandle(hKeySvc);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    return dwErr;
}

ULONG       s_KeyrGetDefaultProvider(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      ULONG                           ulProvType,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [out] */     ULONG                           *pulDefType,
/* [out] */     PKEYSVC_PROVIDER_INFO           *ppProvider)
{
    KEYSVC_CONTEXT          *pContext = NULL;
    BYTE                    *pb = NULL;
    DWORD                   cbProvName;
    DWORD                   dwFlags = CRYPT_USER_DEFAULT;
    PKEYSVC_PROVIDER_INFO   pProvInfo = NULL;
    BOOL                    fImpersonated = FALSE;
    DWORD                   dwErr = 0;

    __try
    {
        *ppProvider = NULL;

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
            goto Ret;

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        // set flag for MACHINE_KEYSET if necessary
        if (KeySvcMachine != pContext->dwType)
        {
            if (!CryptGetDefaultProviderW(ulProvType, NULL, dwFlags,
                                          NULL, &cbProvName))
            {
                dwFlags = CRYPT_MACHINE_DEFAULT;
            }
        }
        else
        {
            dwFlags = CRYPT_MACHINE_DEFAULT;
        }

        if (CRYPT_MACHINE_DEFAULT == dwFlags)
        {
            if (!CryptGetDefaultProviderW(ulProvType, NULL, dwFlags,
                                          NULL, &cbProvName))
            {
                dwErr = GetLastError();
                goto Ret;
            }
        }

        // alloc space for and place info into the ppProvider structure
        if (NULL == (*ppProvider =
            (PKEYSVC_PROVIDER_INFO)MyAlloc(sizeof(KEYSVC_PROVIDER_INFO) +
                                           cbProvName)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        pb = (BYTE*)(*ppProvider) + sizeof(KEYSVC_PROVIDER_INFO);

        (*ppProvider)->ProviderType = ulProvType;
        (*ppProvider)->Name.Length = (USHORT)cbProvName;
        (*ppProvider)->Name.MaximumLength = (USHORT)cbProvName;

        if (!CryptGetDefaultProviderW(ulProvType, NULL, dwFlags,
                                      (USHORT*)pb, &cbProvName))
        {
            dwErr = GetLastError();
            goto Ret;
        }
        (*ppProvider)->Name.Buffer = (USHORT*)pb;

        if (CRYPT_MACHINE_DEFAULT == dwFlags)
        {
            *pulDefType =  DefMachineProv;
        }
        else
        {
            *pulDefType =  DefUserProv;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (dwErr && *ppProvider)
        {
            MyFree(*ppProvider);
            *ppProvider = NULL;
        }
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

ULONG       s_KeyrSetDefaultProvider(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in] */      KEYSVC_PROVIDER_INFO            Provider)
{
    KEYSVC_CONTEXT  *pContext = NULL;
    DWORD           dwFlags = CRYPT_USER_DEFAULT;
    BOOL            fImpersonated = FALSE;
    LPWSTR          pwszProvName = NULL;
    DWORD           dwErr = 0;

    __try
    {
        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
            goto Ret;

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        // set flag for MACHINE_KEYSET if necessary
        if (KeySvcMachine == pContext->dwType)
            dwFlags = CRYPT_MACHINE_DEFAULT;

        if (0 != (dwErr = AllocAndAssignString(&(Provider.Name),
                                               &pwszProvName)))
        {
            goto Ret;
        }

        if (!CryptSetProviderExW(pwszProvName, Provider.ProviderType,
                                 NULL, dwFlags))
        {
            dwErr = GetLastError();
            goto Ret;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (pwszProvName)
            MyFree(pwszProvName);
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}


ULONG s_KeyrEnroll(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      BOOL                            fKeyService,
/* [in] */      ULONG                           ulPurpose,
/* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
/* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
/* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
/* [in] */      BOOL                            fNewKey,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    pKeyNew,
/* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    pRenewKey,
/* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
/* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
/* [in] */      ULONG                           ulStoreFlags,
/* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
/* [in] */      ULONG                           ulFlags,
/* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppReserved,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
/* [out] */     ULONG __RPC_FAR                 *pulStatus)
{
    CERT_REQUEST_PVK_NEW    KeyNew;
    CERT_REQUEST_PVK_NEW    RenewKey;
    DWORD                   cbExtensions; 
    PBYTE                   pbExtensions = NULL; 
    PCERT_REQUEST_PVK_NEW   pTmpRenewKey = NULL;
    PCERT_REQUEST_PVK_NEW   pTmpKeyNew = NULL;
    LPWSTR                  pwszAcctName = NULL;
    LPWSTR                  pwszProv = NULL;
    LPWSTR                  pwszCont = NULL;
    LPWSTR                  pwszRenewProv = NULL;
    LPWSTR                  pwszRenewCont = NULL;
    LPWSTR                  pwszDesStore = NULL;
    LPWSTR                  pwszAttributes = NULL;
    LPWSTR                  pwszFriendly = NULL;
    LPWSTR                  pwszDescription = NULL;
    LPWSTR                  pwszUsage = NULL;
    LPWSTR                  pwszCALocation = NULL;
    LPWSTR                  pwszCertDNName = NULL;
    LPWSTR                  pwszCAName = NULL;
    LPWSTR                  pwszHashAlg = NULL;
    HANDLE                  hLogonToken = 0;
    HANDLE                  hProfile = 0;
    CERT_BLOB               CertBlob;
    CERT_BLOB               *pCertBlob = NULL;
    CERT_BLOB               PKCS7Blob;
    CERT_BLOB               HashBlob;
    CERT_ENROLL_INFO        EnrollInfo;
    DWORD                   dwErr = 0;

    __try
    {
        memset(&KeyNew, 0, sizeof(KeyNew));
        memset(&RenewKey, 0, sizeof(RenewKey));
        memset(&EnrollInfo, 0, sizeof(EnrollInfo));
        memset(&PKCS7Blob, 0, sizeof(PKCS7Blob));
        memset(&HashBlob, 0, sizeof(HashBlob));
        memset(&CertBlob, 0, sizeof(CertBlob));

        *ppPKCS7Blob = NULL;
        *ppHashBlob = NULL;

        // check if the client is an admin
        if (0 != (dwErr = CheckIfAdmin(hRPCBinding)))
            goto Ret;

        // if enrolling for a service account then need to logon and load profile
        if (0 != pAcctName->Length)
        {
            if (0 != (dwErr = AllocAndAssignString(pAcctName, &pwszAcctName)))
                goto Ret;
            if (0 != (dwErr = LogonToService(pwszAcctName, &hLogonToken,
                                             &hProfile)))
                goto Ret;
        }

        // assign all the values in the passed in structure to the
        // temporary structure
        KeyNew.dwSize = sizeof(CERT_REQUEST_PVK_NEW);
        KeyNew.dwProvType = pKeyNew->ulProvType;
        if (0 != (dwErr = AllocAndAssignString(&pKeyNew->Provider,
                                               &pwszProv)))
            goto Ret;
        KeyNew.pwszProvider = pwszProv;
        KeyNew.dwProviderFlags = pKeyNew->ulProviderFlags;
        if (0 != (dwErr = AllocAndAssignString(&pKeyNew->KeyContainer,
                                               &pwszCont)))
            goto Ret;
        KeyNew.pwszKeyContainer = pwszCont;
        KeyNew.dwKeySpec = pKeyNew->ulKeySpec;
        KeyNew.dwGenKeyFlags = pKeyNew->ulGenKeyFlags;

        pTmpKeyNew = &KeyNew;

        if (pCert->cb)
        {
            // if necessary assign the cert to be renewed values
            // temporary structure
            CertBlob.cbData = pCert->cb;
            CertBlob.pbData = pCert->pb;

            pCertBlob = &CertBlob;
        }

        if (CRYPTUI_WIZ_CERT_RENEW == ulPurpose)
        {
            // assign all the values in the passed in structure to the
            // temporary structure
            RenewKey.dwSize = sizeof(CERT_REQUEST_PVK_NEW);
            RenewKey.dwProvType = pRenewKey->ulProvType;
            if (0 != (dwErr = AllocAndAssignString(&pRenewKey->Provider,
                                                   &pwszRenewProv)))
                goto Ret;
            RenewKey.pwszProvider = pwszRenewProv;
            RenewKey.dwProviderFlags = pRenewKey->ulProviderFlags;
            if (0 != (dwErr = AllocAndAssignString(&pRenewKey->KeyContainer,
                                                   &pwszRenewCont)))
                goto Ret;
            RenewKey.pwszKeyContainer = pwszRenewCont;
            RenewKey.dwKeySpec = pRenewKey->ulKeySpec;
            RenewKey.dwGenKeyFlags = pRenewKey->ulGenKeyFlags;

            pTmpRenewKey = &RenewKey;
        }

        // check if the destination cert store was passed in
        if (0 != (dwErr = AllocAndAssignString(pDesStore, &pwszDesStore)))
            goto Ret;

        // copy over the request info
        EnrollInfo.dwSize = sizeof(EnrollInfo);
        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->UsageOID,
                                               &pwszUsage)))
            goto Ret;
        EnrollInfo.pwszUsageOID = pwszUsage;

        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->CertDNName,
                                               &pwszCertDNName)))
            goto Ret;
        EnrollInfo.pwszCertDNName = pwszCertDNName;

        // cast the cert extensions
        EnrollInfo.dwExtensions = pRequestInfo->cExtensions;
        cbExtensions = (sizeof(CERT_EXTENSIONS)+sizeof(PCERT_EXTENSIONS)) * pRequestInfo->cExtensions; 
        for (DWORD dwIndex = 0; dwIndex < pRequestInfo->cExtensions; dwIndex++)
        {
            cbExtensions += sizeof(CERT_EXTENSION) * 
                pRequestInfo->prgExtensions[dwIndex]->cExtension;
        }

        EnrollInfo.prgExtensions = (PCERT_EXTENSIONS *)MyAlloc(cbExtensions);
        if (NULL == EnrollInfo.prgExtensions)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY; 
            goto Ret; 
        }

        pbExtensions = (PBYTE)(EnrollInfo.prgExtensions + EnrollInfo.dwExtensions);
        for (DWORD dwIndex = 0; dwIndex < EnrollInfo.dwExtensions; dwIndex++)
        {
            EnrollInfo.prgExtensions[dwIndex] = (PCERT_EXTENSIONS)pbExtensions; 
            pbExtensions += sizeof(CERT_EXTENSIONS); 
            EnrollInfo.prgExtensions[dwIndex]->cExtension = pRequestInfo->prgExtensions[dwIndex]->cExtension; 
            EnrollInfo.prgExtensions[dwIndex]->rgExtension = (PCERT_EXTENSION)pbExtensions; 
            pbExtensions += sizeof(CERT_EXTENSION) * EnrollInfo.prgExtensions[dwIndex]->cExtension; 
            
            for (DWORD dwSubIndex = 0; dwSubIndex < EnrollInfo.prgExtensions[dwIndex]->cExtension; dwSubIndex++) 
            {
                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].pszObjId = 
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].pszObjId; 
                
                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].fCritical =
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].fCritical;

                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].Value.cbData = 
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].cbData; 

                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].Value.pbData = 
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].pbData; 
            }                
        }

        EnrollInfo.dwPostOption = pRequestInfo->ulPostOption;
        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->FriendlyName,
                                               &pwszFriendly)))
            goto Ret;
        EnrollInfo.pwszFriendlyName = pwszFriendly;
        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->Description,
                                               &pwszDescription)))
            goto Ret;
        EnrollInfo.pwszDescription = pwszDescription;

        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->Attributes,
                                               &pwszAttributes)))
            goto Ret;

        if (0 != (dwErr = AllocAndAssignString(pHashAlg,
                                               &pwszHashAlg)))
            goto Ret;
        if (0 != (dwErr = AllocAndAssignString(pCALocation,
                                               &pwszCALocation)))
            goto Ret;
        if (0 != (dwErr = AllocAndAssignString(pCAName,
                                               &pwszCAName)))
            goto Ret;

        // call the local enrollment API

        __try {
            dwErr = LocalEnroll(0, pwszAttributes, NULL, fKeyService,
				ulPurpose, FALSE, 0, NULL, 0, pwszCALocation,
				pwszCAName, pCertBlob, pTmpRenewKey, fNewKey,
				pTmpKeyNew, pwszHashAlg, pwszDesStore, ulStoreFlags,
				&EnrollInfo, &PKCS7Blob, &HashBlob, pulStatus, NULL);
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            // TODO: convert to Winerror
            dwErr = GetExceptionCode();
        }

        if( dwErr != 0 )
            goto Ret;

	
	// alloc and copy for the RPC out parameters
	if (NULL == (*ppPKCS7Blob = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB) +
							  PKCS7Blob.cbData)))
	{
	    dwErr = ERROR_NOT_ENOUGH_MEMORY;
	    goto Ret;
	}
	(*ppPKCS7Blob)->cb = PKCS7Blob.cbData;
	(*ppPKCS7Blob)->pb = (BYTE*)(*ppPKCS7Blob) + sizeof(KEYSVC_BLOB);
	memcpy((*ppPKCS7Blob)->pb, PKCS7Blob.pbData, (*ppPKCS7Blob)->cb);
	
	if (NULL == (*ppHashBlob = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB) +
							 HashBlob.cbData)))
	{
	    dwErr = ERROR_NOT_ENOUGH_MEMORY;
	    goto Ret;
	}
	(*ppHashBlob)->cb = HashBlob.cbData;
	(*ppHashBlob)->pb = (BYTE*)(*ppHashBlob) + sizeof(KEYSVC_BLOB);
	memcpy((*ppHashBlob)->pb, HashBlob.pbData, (*ppHashBlob)->cb);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (pwszAcctName)
            MyFree(pwszAcctName);
        if (pwszProv)
            MyFree(pwszProv);
        if (pwszCont)
            MyFree(pwszCont);
        if (pwszRenewProv)
            MyFree(pwszRenewProv);
        if (pwszRenewCont)
            MyFree(pwszRenewCont);
        if (pwszDesStore)
            MyFree(pwszDesStore);
        if (pwszAttributes)
            MyFree(pwszAttributes);
        if (pwszFriendly)
            MyFree(pwszFriendly);
        if (pwszDescription)
            MyFree(pwszDescription);
        if (pwszUsage)
            MyFree(pwszUsage);
        if (pwszCertDNName)
            MyFree(pwszCertDNName);
        if (pwszCAName)
            MyFree(pwszCAName);
        if (pwszCALocation)
            MyFree(pwszCALocation);
        if (pwszHashAlg)
            MyFree(pwszHashAlg);
        if (PKCS7Blob.pbData)
        {
            MyFree(PKCS7Blob.pbData);
        }
        if (HashBlob.pbData)
        {
            MyFree(HashBlob.pbData);
        }
        if (hLogonToken || hProfile)
        {
            LogoffService(&hLogonToken, &hProfile);
        }
        if (EnrollInfo.prgExtensions)
            MyFree(EnrollInfo.prgExtensions);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

DWORD MoveCertsFromSystemToMemStore(
                                    PKEYSVC_UNICODE_STRING pCertStore,
                                    DWORD dwStoreFlags,
                                    ULONG cHashCount,
                                    KEYSVC_CERT_HASH *pHashes,
                                    HCERTSTORE *phMemStore
                                    )
{
    DWORD           i;
    HCERTSTORE      hStore = 0;
    PCCERT_CONTEXT  pCertContext = NULL;
    CRYPT_HASH_BLOB HashBlob;
    DWORD           dwErr = 0;

    if (NULL == (hStore = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W,
                                        0, 0, dwStoreFlags,
                                        pCertStore->Buffer)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (NULL == (*phMemStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                             0, 0, 0, NULL)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // get the certs out of the system store and put them in the mem store
    for(i=0;i<cHashCount;i++)
    {
        HashBlob.cbData = 20;
        HashBlob.pbData = pHashes[i].rgb;
        if (NULL == (pCertContext = CertFindCertificateInStore(hStore,
                                        X509_ASN_ENCODING, CERT_FIND_SHA1_HASH,
                                        0, &HashBlob, NULL)))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        if (!CertAddCertificateContextToStore(*phMemStore, pCertContext,
                CERT_STORE_ADD_USE_EXISTING, NULL))
        {
            dwErr = GetLastError();
            goto Ret;
        }
        if (!CertFreeCertificateContext(pCertContext))
        {
            pCertContext = NULL;
            dwErr = GetLastError();
            goto Ret;
        }
        pCertContext = NULL;
    }
Ret:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);
    if (hStore)
        CertCloseStore(hStore, 0);
    return dwErr;
}

ULONG s_KeyrExportCert(
/* [in] */      handle_t hRPCBinding,
/* [in] */      KEYSVC_HANDLE hKeySvc,
/* [in] */      PKEYSVC_UNICODE_STRING pPassword,
/* [in] */      PKEYSVC_UNICODE_STRING pCertStore,
/* [in] */      ULONG cHashCount,
/* [size_is][in] */
                KEYSVC_CERT_HASH *pHashes,
/* [in] */      ULONG ulFlags,
/* [in, out] */ PKEYSVC_BLOB *ppReserved,
/* [out] */     PKEYSVC_BLOB *ppPFXBlob)
{
    HCERTSTORE          hMemStore = 0;
    KEYSVC_CONTEXT      *pContext = NULL;
    BOOL                fImpersonated = FALSE;
    CRYPT_DATA_BLOB     PFXBlob;
    DWORD               dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    DWORD               dwErr = 0;

    __try
    {
        memset(&PFXBlob, 0, sizeof(PFXBlob));

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
            goto Ret;

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        // set the cert store information
        if (KeySvcMachine == pContext->dwType)
        {
            dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        }

        // move the requested certs from the system store to a memory store
        if (0 != (dwErr = MoveCertsFromSystemToMemStore(pCertStore, dwStoreFlags,
                                cHashCount, pHashes, &hMemStore)))
            goto Ret;

        if (!PFXExportCertStore(hMemStore, &PFXBlob, pPassword->Buffer, ulFlags))
        {
            dwErr = GetLastError();
            goto Ret;
        }
        if (NULL == (PFXBlob.pbData = (BYTE*)MyAlloc(PFXBlob.cbData)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        if (!PFXExportCertStore(hMemStore, &PFXBlob, pPassword->Buffer, ulFlags))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        // set up the blob for return through RPC
        if (NULL == (*ppPFXBlob = (PKEYSVC_BLOB)MyAlloc(sizeof(KEYSVC_BLOB) +
                        PFXBlob.cbData)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        (*ppPFXBlob)->cb = PFXBlob.cbData;
        (*ppPFXBlob)->pb = (BYTE*)*ppPFXBlob + sizeof(KEYSVC_BLOB);
        memcpy((*ppPFXBlob)->pb, PFXBlob.pbData, (*ppPFXBlob)->cb);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (PFXBlob.pbData)
            LocalFree(PFXBlob.pbData);
        if (hMemStore)
            CertCloseStore(hMemStore, 0);
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

DWORD MoveCertsFromMemToSystemStore(
                                    PKEYSVC_UNICODE_STRING pCertStore,
                                    DWORD dwStoreFlags,
                                    HCERTSTORE hMemStore
                                    )
{
    DWORD           i;
    HCERTSTORE      hStore = 0;
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT  pPrevCertContext = NULL;
    DWORD           dwErr = 0;

    if (NULL == (hStore = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W,
                                        0, 0, dwStoreFlags,
                                        pCertStore->Buffer)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // get the certs out of the system store and put them in the mem store
    for(i=0;;i++)
    {
        if (NULL == (pCertContext = CertEnumCertificatesInStore(hMemStore,
                                        pPrevCertContext)))
        {
            pPrevCertContext = NULL;
            if (CRYPT_E_NOT_FOUND != GetLastError())
            {
                dwErr = GetLastError();
                goto Ret;
            }
            break;
        }
        pPrevCertContext = NULL;

        if (!CertAddCertificateContextToStore(hStore, pCertContext,
                CERT_STORE_ADD_USE_EXISTING, NULL))
        {
            dwErr = GetLastError();
            goto Ret;
        }
        pPrevCertContext = pCertContext;
    }
Ret:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);
    if (hStore)
        CertCloseStore(hStore, 0);
    return dwErr;
}

ULONG       s_KeyrImportCert(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      PKEYSVC_UNICODE_STRING          pPassword,
/* [in] */      KEYSVC_UNICODE_STRING           *pCertStore,
/* [in] */      PKEYSVC_BLOB                    pPFXBlob,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved)
{
    HCERTSTORE          hMemStore = 0;
    KEYSVC_CONTEXT      *pContext = NULL;
    BOOL                fImpersonated = FALSE;
    CRYPT_DATA_BLOB     PFXBlob;
    DWORD               dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    DWORD               dwErr = 0;

    __try
    {
        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
            goto Ret;

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        // set the cert store information
        if (KeySvcMachine == pContext->dwType)
        {
            dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        }

        PFXBlob.cbData = pPFXBlob->cb;
        PFXBlob.pbData = pPFXBlob->pb;

        if (NULL == (hMemStore = PFXImportCertStore(&PFXBlob, pPassword->Buffer,
                                                 ulFlags)))
        {
            dwErr = GetLastError();
            goto Ret;
        }

        // open the specified store and transfer all the certs into it
        dwErr = MoveCertsFromMemToSystemStore(pCertStore, dwStoreFlags, hMemStore);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (hMemStore)
            CertCloseStore(hMemStore, 0);
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

ULONG s_KeyrEnumerateAvailableCertTypes(

    /* [in] */      handle_t                        hRPCBinding,
    /* [in] */      KEYSVC_HANDLE                   hKeySvc,
    /* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
                     PKEYSVC_UNICODE_STRING *ppCertTypes)

{
    KEYSVC_CONTEXT          *pContext = NULL;
    BOOL                    fImpersonated = FALSE;
    DWORD                   dwErr = E_UNEXPECTED;
    HCERTTYPE               hType = NULL;
    DWORD                   cTypes = 0;
    DWORD                   cTrustedTypes = 0;
    DWORD                   i;
    LPWSTR                  *awszTrustedTypes = NULL;
    DWORD                   cbTrustedTypes = 0;
    PKEYSVC_UNICODE_STRING  awszResult = NULL;
    LPWSTR                  wszCurrentName;

    __try
    {
        *pcCertTypeCount = 0;
        *ppCertTypes = NULL;

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
            goto Ret;

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        dwErr = CAEnumCertTypes(CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES, &hType);
        if(dwErr != S_OK)
        {
            goto Ret;
        }
        cTypes = CACountCertTypes(hType);

        awszTrustedTypes = (LPWSTR *)MyAlloc(sizeof(LPWSTR)*cTypes);
        if(awszTrustedTypes == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        while(hType)
        {
            HCERTTYPE hNextType = NULL;
            LPWSTR *awszTypeName = NULL;
            dwErr = CAGetCertTypeProperty(hType, CERTTYPE_PROP_DN, &awszTypeName);
            if((dwErr == S_OK) && (awszTypeName))
            {
                if(awszTypeName[0])
                {
                    dwErr = CACertTypeAccessCheck(hType, NULL);
                    if(dwErr == S_OK)
                    {
                        awszTrustedTypes[cTrustedTypes] = (LPWSTR)MyAlloc((wcslen(awszTypeName[0])+1)*sizeof(WCHAR));
                        if(awszTrustedTypes[cTrustedTypes])
                        {
                            wcscpy(awszTrustedTypes[cTrustedTypes], awszTypeName[0]);
                            cbTrustedTypes += (wcslen(awszTypeName[0])+1)*sizeof(WCHAR);
                            cTrustedTypes++;
                        }
                    }

                }
                CAFreeCertTypeProperty(hType, awszTypeName);
            }
            dwErr = CAEnumNextCertType(hType, &hNextType);
            if(dwErr != S_OK)
            {
                break;
            }
            CACloseCertType(hType);
            hType = hNextType;
        }

        cbTrustedTypes += sizeof(KEYSVC_UNICODE_STRING)*cTrustedTypes;
        awszResult = (PKEYSVC_UNICODE_STRING)MyAlloc(cbTrustedTypes);
        if(awszResult == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        
        wszCurrentName = (LPWSTR)(&awszResult[cTrustedTypes]);
        for(i=0; i < cTrustedTypes; i++)
        {
            wcscpy(wszCurrentName, awszTrustedTypes[i]);
            awszResult[i].Length = (wcslen(awszTrustedTypes[i]) + 1)*sizeof(WCHAR);
            awszResult[i].MaximumLength = awszResult[i].Length;
            awszResult[i].Buffer = wszCurrentName;
            wszCurrentName += wcslen(awszTrustedTypes[i]) + 1;
        }

        *pcCertTypeCount = cTrustedTypes;
        *ppCertTypes = awszResult;
        awszResult = NULL;
        dwErr = ERROR_SUCCESS;

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr    = _exception_code();
    }
Ret:
    __try
    {

        // free the list
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if(awszTrustedTypes)
        {
            for(i=0; i < cTrustedTypes; i++)
            {
                if(awszTrustedTypes[i])
                {
                    MyFree(awszTrustedTypes[i]);
                }
            }
            MyFree(awszTrustedTypes);
        }
        if(awszResult)
        {
            MyFree(awszResult);
        }
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}




ULONG s_KeyrEnumerateCAs(

    /* [in] */      handle_t                        hRPCBinding,
    /* [in] */      KEYSVC_HANDLE                   hKeySvc,
    /* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
    /* [in] */      ULONG                           ulFlags,
    /* [out][in] */ ULONG                           *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING               *ppCAs)

{
    KEYSVC_CONTEXT          *pContext = NULL;
    BOOL                    fImpersonated = FALSE;
    DWORD                   dwErr = E_UNEXPECTED;
    HCAINFO                 hCA = NULL;
    DWORD                   cCAs = 0;
    DWORD                   cTrustedCAs = 0;
    DWORD                   i;
    LPWSTR                  *awszTrustedCAs = NULL;
    DWORD                   cbTrustedCAs = 0;
    PKEYSVC_UNICODE_STRING  awszResult = NULL;
    LPWSTR                  wszCurrentName;

    __try
    {
        *pcCACount = 0;
        *ppCAs = NULL;

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
            goto Ret;

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        dwErr = CAEnumFirstCA(NULL, ulFlags, &hCA);

        if(dwErr != S_OK)
        {
            goto Ret;
        }
        cCAs = CACountCAs(hCA);

        awszTrustedCAs = (LPWSTR *)MyAlloc(sizeof(LPWSTR)*cCAs);
        if(awszTrustedCAs == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        while(hCA)
        {
            HCAINFO hNextCA = NULL;
            LPWSTR *awszCAName = NULL;
            dwErr = CAGetCAProperty(hCA, CA_PROP_NAME, &awszCAName);
            if((dwErr == S_OK) && (awszCAName))
            {
                if(awszCAName[0])
                {
                    dwErr = CAAccessCheck(hCA, NULL);
                    if(dwErr == S_OK)
                    {
                        awszTrustedCAs[cTrustedCAs] = (LPWSTR)MyAlloc((wcslen(awszCAName[0])+1)*sizeof(WCHAR));
                        if(awszTrustedCAs[cTrustedCAs])
                        {
                            wcscpy(awszTrustedCAs[cTrustedCAs], awszCAName[0]);
                            cbTrustedCAs += (wcslen(awszCAName[0])+1)*sizeof(WCHAR);
                            cTrustedCAs++;
                        }
                    }

                }
                CAFreeCAProperty(hCA, awszCAName);
            }
            dwErr = CAEnumNextCA(hCA, &hNextCA);
            if(dwErr != S_OK)
            {
                break;
            }
            CACloseCA(hCA);
            hCA = hNextCA;
        }

        cbTrustedCAs += sizeof(KEYSVC_UNICODE_STRING)*cTrustedCAs;
        awszResult = (PKEYSVC_UNICODE_STRING)MyAlloc(cbTrustedCAs);
        if(awszResult == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        
        wszCurrentName = (LPWSTR)(&awszResult[cTrustedCAs]);
        for(i=0; i < cTrustedCAs; i++)
        {
            wcscpy(wszCurrentName, awszTrustedCAs[i]);
            awszResult[i].Length = (wcslen(awszTrustedCAs[i]) + 1)*sizeof(WCHAR);
            awszResult[i].MaximumLength = awszResult[i].Length;
            awszResult[i].Buffer = wszCurrentName;
            wszCurrentName += wcslen(awszTrustedCAs[i]) + 1;
        }


        *pcCACount = cTrustedCAs;
        *ppCAs = awszResult;
        awszResult = NULL;
        dwErr = ERROR_SUCCESS;

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr    = _exception_code();
    }
Ret:
    __try
    {

        // free the list
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);
        if(awszTrustedCAs)
        {
            for(i=0; i < cTrustedCAs; i++)
            {
                if(awszTrustedCAs[i])
                {
                    MyFree(awszTrustedCAs[i]);
                }
            }
            MyFree(awszTrustedCAs);
        }
        if(awszResult)
        {
            MyFree(awszResult);
        }
        if (pContext)
            ReleaseContext(pContext);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

BOOL
GetTokenUserSid(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
/*++

    This function queries the access token specified by the
    hToken parameter, and returns an allocated copy of the
    TokenUser information on success.

    The access token specified by hToken must be opened for
    TOKEN_QUERY access.

    On success, the return value is TRUE.  The caller is
    responsible for freeing the resultant UserSid via a call
    to MyFree().

    On failure, the return value is FALSE.  The caller does
    not need to free any buffer.

--*/
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;

    *ppUserSid = NULL;

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            //
            // try again with the specified buffer size
            //

            SlowBuffer = (LPBYTE)MyAlloc(cbBuffer);

            if(SlowBuffer != NULL) {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hToken,    // identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) {

        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = MyAlloc( cbSid );

        if(*ppUserSid != NULL) {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
    }

    if(!fSuccess) {
        if(*ppUserSid) {
            MyFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
        MyFree(SlowBuffer);

    return fSuccess;
}


BOOL
GetUserTextualSid(
    IN  OUT LPWSTR  lpBuffer,
    IN  OUT LPDWORD nSize
    )
{
    HANDLE hToken;
    PSID pSidUser = NULL;
    BOOL fSuccess = FALSE;

    if(!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hToken
                ))
    {
        return FALSE;
    }

    fSuccess = GetTokenUserSid(hToken, &pSidUser);

    if(fSuccess) {

        //
        // obtain the textual representaion of the Sid
        //

        fSuccess = GetTextualSid(
                        pSidUser,   // user binary Sid
                        lpBuffer,   // buffer for TextualSid
                        nSize       // required/result buffer size in chars (including NULL)
                        );
    }

    if(pSidUser)
        MyFree(pSidUser);

    CloseHandle(hToken);

    return fSuccess;
}

BOOL
GetTextualSid(
    IN      PSID    pSid,          // binary Sid
    IN  OUT LPWSTR  TextualSid,  // buffer for Textual representaion of Sid
    IN  OUT LPDWORD dwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*dwBufferLen < dwSidSize) {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    dwSidSize = wsprintfW(TextualSid, L"S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
                    L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
                    L"%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
            L"-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)

    return TRUE;
}

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if(String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

ULONG s_KeyrEnroll_V2
(/* [in] */      handle_t                        hRPCBinding,
/* [in] */      BOOL                            fKeyService,
/* [in] */      ULONG                           ulPurpose,
/* [in] */      ULONG                           ulFlags, 
/* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
/* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
/* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
/* [in] */      BOOL                            fNewKey,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pKeyNew,
/* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pRenewKey,
/* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
/* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
/* [in] */      ULONG                           ulStoreFlags,
/* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
/* [in] */      ULONG                           ulReservedFlags,
/* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppReserved,
/* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppRequest, 
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
/* [out] */     ULONG __RPC_FAR                 *pulStatus)
{
    CERT_REQUEST_PVK_NEW    KeyNew;
    CERT_REQUEST_PVK_NEW    RenewKey;
    DWORD                   cbExtensions; 
    PBYTE                   pbExtensions = NULL; 
    PCERT_REQUEST_PVK_NEW   pTmpRenewKey = NULL;
    PCERT_REQUEST_PVK_NEW   pTmpKeyNew = NULL;
    LPWSTR                  pwszAcctName = NULL;
    LPWSTR                  pwszProv = NULL;
    LPWSTR                  pwszCont = NULL;
    LPWSTR                  pwszRenewProv = NULL;
    LPWSTR                  pwszRenewCont = NULL;
    LPWSTR                  pwszDesStore = NULL;
    LPWSTR                  pwszAttributes = NULL;
    LPWSTR                  pwszFriendly = NULL;
    LPWSTR                  pwszDescription = NULL;
    LPWSTR                  pwszUsage = NULL;
    LPWSTR                  pwszCALocation = NULL;
    LPWSTR                  pwszCertDNName = NULL;
    LPWSTR                  pwszCAName = NULL;
    LPWSTR                  pwszHashAlg = NULL;
    HANDLE                  hLogonToken = 0;
    HANDLE                  hProfile = 0;
    CERT_BLOB               CertBlob;
    CERT_BLOB               *pCertBlob = NULL;
    CERT_BLOB               PKCS7Blob;
    CERT_BLOB               HashBlob;
    CERT_ENROLL_INFO        EnrollInfo;
    DWORD                   dwErr = 0;
    HANDLE                  hRequest = *ppRequest;
    KEYSVC_BLOB             ReservedBlob; 
    BOOL                    fCreateRequest   = 0 == (ulFlags & (CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    BOOL                    fFreeRequest     = 0 == (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY)); 
    BOOL                    fSubmitRequest   = 0 == (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 

    __try
    {
        //////////////////////////////////////////////////////////////
        // 
        // INITIALIZATION:
        //
        //////////////////////////////////////////////////////////////

        memset(&KeyNew, 0, sizeof(KeyNew));
        memset(&RenewKey, 0, sizeof(RenewKey));
        memset(&EnrollInfo, 0, sizeof(EnrollInfo));
        memset(&PKCS7Blob, 0, sizeof(PKCS7Blob));
        memset(&HashBlob, 0, sizeof(HashBlob));
        memset(&CertBlob, 0, sizeof(CertBlob));
	memset(&ReservedBlob, 0, sizeof(ReservedBlob)); 

        *ppPKCS7Blob = NULL;
        *ppHashBlob = NULL;

        //////////////////////////////////////////////////////////////
        //
        // INPUT VALIDATION:
        //
        //////////////////////////////////////////////////////////////

        BOOL fValidInput = TRUE; 

        fValidInput &= fCreateRequest || fSubmitRequest || fFreeRequest; 

        switch (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY))
        {
        case CRYPTUI_WIZ_CREATE_ONLY:  
            fValidInput &= NULL == *ppRequest;  
            break;

        case CRYPTUI_WIZ_SUBMIT_ONLY: 
        case CRYPTUI_WIZ_FREE_ONLY: 
            fValidInput &= NULL != *ppRequest; 
            break; 
            
        case 0:
        default:
            ;
        }       

        if (FALSE == fValidInput)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret; 
        }

        //////////////////////////////////////////////////////////////
        //
        // PROCEDURE BODY:
        //
        //////////////////////////////////////////////////////////////

        // check if the client is an admin
        if (0 != (dwErr = CheckIfAdmin(hRPCBinding)))
            goto Ret;

        // if enrolling for a service account then need to logon and load profile
        if (0 != pAcctName->Length)
        {
            if (0 != (dwErr = AllocAndAssignString(pAcctName, &pwszAcctName)))
                goto Ret;
            if (0 != (dwErr = LogonToService(pwszAcctName, &hLogonToken,
                                             &hProfile)))
                goto Ret;
        }

        // assign all the values in the passed in structure to the
        // temporary structure
        KeyNew.dwSize = sizeof(CERT_REQUEST_PVK_NEW);
        KeyNew.dwProvType = pKeyNew->ulProvType;
        if (0 != (dwErr = AllocAndAssignString(&pKeyNew->Provider,
                                               &pwszProv)))
            goto Ret;
        KeyNew.pwszProvider = pwszProv;
        KeyNew.dwProviderFlags = pKeyNew->ulProviderFlags;
        if (0 != (dwErr = AllocAndAssignString(&pKeyNew->KeyContainer,
                                               &pwszCont)))
            goto Ret;
        KeyNew.pwszKeyContainer = pwszCont;
        KeyNew.dwKeySpec = pKeyNew->ulKeySpec;
        KeyNew.dwGenKeyFlags = pKeyNew->ulGenKeyFlags;
	KeyNew.dwEnrollmentFlags = pKeyNew->ulEnrollmentFlags; 
	KeyNew.dwSubjectNameFlags = pKeyNew->ulSubjectNameFlags;
	KeyNew.dwPrivateKeyFlags = pKeyNew->ulPrivateKeyFlags;
	KeyNew.dwGeneralFlags = pKeyNew->ulGeneralFlags; 

        pTmpKeyNew = &KeyNew;

        if (pCert->cb)
        {
            // if necessary assign the cert to be renewed values
            // temporary structure
            CertBlob.cbData = pCert->cb;
            CertBlob.pbData = pCert->pb;

            pCertBlob = &CertBlob;
        }

        if (CRYPTUI_WIZ_CERT_RENEW == ulPurpose)
        {
            // assign all the values in the passed in structure to the
            // temporary structure
            RenewKey.dwSize = sizeof(CERT_REQUEST_PVK_NEW);
            RenewKey.dwProvType = pRenewKey->ulProvType;
            if (0 != (dwErr = AllocAndAssignString(&pRenewKey->Provider,
                                                   &pwszRenewProv)))
                goto Ret;
            RenewKey.pwszProvider = pwszRenewProv;
            RenewKey.dwProviderFlags = pRenewKey->ulProviderFlags;
            if (0 != (dwErr = AllocAndAssignString(&pRenewKey->KeyContainer,
                                                   &pwszRenewCont)))
                goto Ret;
            RenewKey.pwszKeyContainer = pwszRenewCont;
            RenewKey.dwKeySpec = pRenewKey->ulKeySpec;
            RenewKey.dwGenKeyFlags = pRenewKey->ulGenKeyFlags;
	    RenewKey.dwEnrollmentFlags = pRenewKey->ulEnrollmentFlags;
	    RenewKey.dwSubjectNameFlags = pRenewKey->ulSubjectNameFlags;
	    RenewKey.dwPrivateKeyFlags = pRenewKey->ulPrivateKeyFlags;
	    RenewKey.dwGeneralFlags = pRenewKey->ulGeneralFlags;

            pTmpRenewKey = &RenewKey;
        }

	// For SUBMIT and FREE operations, hRequest is an IN parameter. 
	if (0 != ((CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY) & ulFlags))
	{
	    memcpy(&hRequest, (*ppRequest)->pb, sizeof(hRequest)); 
	}

        // check if the destination cert store was passed in
        if (0 != (dwErr = AllocAndAssignString(pDesStore, &pwszDesStore)))
            goto Ret;

        // copy over the request info
        EnrollInfo.dwSize = sizeof(EnrollInfo);
        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->UsageOID,
                                               &pwszUsage)))
            goto Ret;
        EnrollInfo.pwszUsageOID = pwszUsage;

        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->CertDNName,
                                               &pwszCertDNName)))
            goto Ret;
        EnrollInfo.pwszCertDNName = pwszCertDNName;

        // cast the cert extensions
        EnrollInfo.dwExtensions = pRequestInfo->cExtensions;
        cbExtensions = (sizeof(CERT_EXTENSIONS)+sizeof(PCERT_EXTENSIONS)) * pRequestInfo->cExtensions; 
        for (DWORD dwIndex = 0; dwIndex < pRequestInfo->cExtensions; dwIndex++)
        {
            cbExtensions += sizeof(CERT_EXTENSION) * 
                pRequestInfo->prgExtensions[dwIndex]->cExtension;
        }

        EnrollInfo.prgExtensions = (PCERT_EXTENSIONS *)MyAlloc(cbExtensions);
        if (NULL == EnrollInfo.prgExtensions)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY; 
            goto Ret; 
        }

        pbExtensions = (PBYTE)(EnrollInfo.prgExtensions + EnrollInfo.dwExtensions);
        for (DWORD dwIndex = 0; dwIndex < EnrollInfo.dwExtensions; dwIndex++)
        {
            EnrollInfo.prgExtensions[dwIndex] = (PCERT_EXTENSIONS)pbExtensions; 
            pbExtensions += sizeof(CERT_EXTENSIONS); 
            EnrollInfo.prgExtensions[dwIndex]->cExtension = pRequestInfo->prgExtensions[dwIndex]->cExtension; 
            EnrollInfo.prgExtensions[dwIndex]->rgExtension = (PCERT_EXTENSION)pbExtensions; 
            pbExtensions += sizeof(CERT_EXTENSION) * EnrollInfo.prgExtensions[dwIndex]->cExtension; 
            
            for (DWORD dwSubIndex = 0; dwSubIndex < EnrollInfo.prgExtensions[dwIndex]->cExtension; dwSubIndex++) 
            {
                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].pszObjId = 
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].pszObjId; 
                
                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].fCritical =
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].fCritical;

                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].Value.cbData = 
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].cbData; 

                EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].Value.pbData = 
                    pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].pbData; 
            }                
        }

        EnrollInfo.dwPostOption = pRequestInfo->ulPostOption;
        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->FriendlyName,
                                               &pwszFriendly)))
            goto Ret;
        EnrollInfo.pwszFriendlyName = pwszFriendly;
        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->Description,
                                               &pwszDescription)))
            goto Ret;
        EnrollInfo.pwszDescription = pwszDescription;

        if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->Attributes,
                                               &pwszAttributes)))
            goto Ret;

        if (0 != (dwErr = AllocAndAssignString(pHashAlg,
                                               &pwszHashAlg)))
            goto Ret;
        if (0 != (dwErr = AllocAndAssignString(pCALocation,
                                               &pwszCALocation)))
            goto Ret;
        if (0 != (dwErr = AllocAndAssignString(pCAName,
                                               &pwszCAName)))
            goto Ret;

        // call the local enrollment API

        __try {
            dwErr = LocalEnrollNoDS(ulFlags, pwszAttributes, NULL, fKeyService,
                                    ulPurpose, FALSE, 0, NULL, 0, pwszCALocation,
                                    pwszCAName, pCertBlob, pTmpRenewKey, fNewKey,
                                    pTmpKeyNew, pwszHashAlg, pwszDesStore, ulStoreFlags,
                                    &EnrollInfo, &PKCS7Blob, &HashBlob, pulStatus, &hRequest);
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            // TODO: convert to Winerror
            dwErr = GetExceptionCode();
        }

        if( dwErr != 0 )
            goto Ret;

	// Assign OUT parameters based on what kind of request we've just made.  
	// Possible requests are:
	// 
	// 1)  CREATE only        // Assign "ppRequest" to contain a HANDLE to the cert request. 
	// 2)  SUBMIT only        // Assign "ppPKCS7Blob" and "ppHashBlob" to the values returned from LocalEnrollNoDS()
	// 3)  FREE   only        // No need to assign OUT params. 
	// 4)  Complete (all 3).
	switch (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY))
	{
	case CRYPTUI_WIZ_CREATE_ONLY:
	    // We've done the request creation portion of a 3-stage request, 
	    // assign the "request" out parameter now: 
	    if (NULL == (*ppRequest = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB)+
							     sizeof(hRequest))))
	    {
		dwErr = ERROR_NOT_ENOUGH_MEMORY; 
		goto Ret; 
	    }
	    
	    (*ppRequest)->cb = sizeof(hRequest); 
	    (*ppRequest)->pb = (BYTE*)(*ppRequest) + sizeof(KEYSVC_BLOB); 
	    memcpy((*ppRequest)->pb, &hRequest, sizeof(hRequest)); 

	    break; 

	case CRYPTUI_WIZ_SUBMIT_ONLY:
	case 0:
	    // We've done the request submittal portion of a 3-stage request, 
	    // or we've done a 1-stage request.  Assign the "certificate" out parameters now:

	    // alloc and copy for the RPC out parameters
	    if (NULL == (*ppPKCS7Blob = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB) +
							      PKCS7Blob.cbData)))
	    {
		dwErr = ERROR_NOT_ENOUGH_MEMORY;
		goto Ret;
	    }
	    (*ppPKCS7Blob)->cb = PKCS7Blob.cbData;
	    (*ppPKCS7Blob)->pb = (BYTE*)(*ppPKCS7Blob) + sizeof(KEYSVC_BLOB);
	    memcpy((*ppPKCS7Blob)->pb, PKCS7Blob.pbData, (*ppPKCS7Blob)->cb);
	    
	    if (NULL == (*ppHashBlob = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB) +
							     HashBlob.cbData)))
	    {
		dwErr = ERROR_NOT_ENOUGH_MEMORY;
		goto Ret;
	    }
	    (*ppHashBlob)->cb = HashBlob.cbData;
	    (*ppHashBlob)->pb = (BYTE*)(*ppHashBlob) + sizeof(KEYSVC_BLOB);
	    memcpy((*ppHashBlob)->pb, HashBlob.pbData, (*ppHashBlob)->cb);

	    break;

	case CRYPTUI_WIZ_FREE_ONLY:
	default:
            *ppRequest = NULL; 
	    break; 
	}
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (pwszAcctName)
            MyFree(pwszAcctName);
        if (pwszProv)
            MyFree(pwszProv);
        if (pwszCont)
            MyFree(pwszCont);
        if (pwszRenewProv)
            MyFree(pwszRenewProv);
        if (pwszRenewCont)
            MyFree(pwszRenewCont);
        if (pwszDesStore)
            MyFree(pwszDesStore);
        if (pwszAttributes)
            MyFree(pwszAttributes);
        if (pwszFriendly)
            MyFree(pwszFriendly);
        if (pwszDescription)
            MyFree(pwszDescription);
        if (pwszUsage)
            MyFree(pwszUsage);
        if (pwszCertDNName)
            MyFree(pwszCertDNName);
        if (pwszCAName)
            MyFree(pwszCAName);
        if (pwszCALocation)
            MyFree(pwszCALocation);
        if (pwszHashAlg)
            MyFree(pwszHashAlg);
        if (PKCS7Blob.pbData)
        {
            MyFree(PKCS7Blob.pbData);
        }
        if (HashBlob.pbData)
        {
            MyFree(HashBlob.pbData);
        }
        if (hLogonToken || hProfile)
        {
            LogoffService(&hLogonToken, &hProfile);
        }
        if (EnrollInfo.prgExtensions)
            MyFree(EnrollInfo.prgExtensions);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

ULONG s_KeyrQueryRequestStatus
(/* [in] */        handle_t                         hRPCBinding, 
 /* [in] */        unsigned __int64                 u64Request, 
 /* [out, ref] */  KEYSVC_QUERY_CERT_REQUEST_INFO  *pQueryInfo)
                   
{
    CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO  QueryInfo; 
    DWORD                                dwErr      = 0; 
    HANDLE                               hRequest   = (HANDLE)u64Request; 

    __try 
    { 
        // check if the client is an admin
        if (0 != (dwErr = CheckIfAdmin(hRPCBinding)))
            goto Ret;

        // We have the permission necessary to query the request.  Proceed. 
        ZeroMemory(&QueryInfo, sizeof(QueryInfo)); 

        // Query the request. 
        dwErr = LocalEnrollNoDS(CRYPTUI_WIZ_QUERY_ONLY, NULL, &QueryInfo, FALSE, 0, FALSE, NULL, NULL,
                                0, NULL, NULL, NULL, NULL, FALSE, NULL, NULL, NULL,
                                0, NULL, NULL, NULL, NULL, &hRequest); 
        if (ERROR_SUCCESS != dwErr)
            goto Ret; 
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
    
    pQueryInfo->ulSize    = QueryInfo.dwSize; 
    pQueryInfo->ulStatus  = QueryInfo.dwStatus; 
 Ret:
    return dwErr; 
}


ULONG s_RKeyrPFXInstall
(/* [in] */        handle_t                        hRPCBinding,
 /* [in] */        PKEYSVC_BLOB                    pPFX,
 /* [in] */        PKEYSVC_UNICODE_STRING          pPassword,
 /* [in] */        ULONG                           ulFlags)

{
    BOOL             fIsImpersonatingClient  = FALSE; 
    CRYPT_DATA_BLOB  PFXBlob; 
    DWORD            dwCertOpenStoreFlags;
    DWORD            dwData; 
    DWORD            dwResult; 
    HCERTSTORE       hSrcStore               = NULL; 
    HCERTSTORE       hCAStore                = NULL; 
    HCERTSTORE       hMyStore                = NULL; 
    HCERTSTORE       hRootStore              = NULL; 
    LPWSTR           pwszPassword            = NULL; 
    PCCERT_CONTEXT   pCertContext            = NULL; 

    struct Stores { 
        HANDLE  *phStore;
        LPCWSTR  pwszStoreName; 
    } rgStores[] = { 
        { &hMyStore,   L"my" }, 
        { &hCAStore,   L"ca" }, 
        { &hRootStore, L"root" }
    }; 

    __try 
    { 
        // Initialize locals: 
        PFXBlob.cbData = pPFX->cb; 
        PFXBlob.pbData = pPFX->pb; 

        switch (ulFlags & (CRYPT_MACHINE_KEYSET | CRYPT_USER_KEYSET)) 
        { 
            case CRYPT_MACHINE_KEYSET: 
                dwCertOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE; 
                break; 

            case CRYPT_USER_KEYSET: // not supported
            default:
                dwResult = ERROR_INVALID_PARAMETER; 
                goto error; 
        }

        dwResult = RpcImpersonateClient(hRPCBinding); 
        if (RPC_S_OK != dwResult) 
            goto error; 
        fIsImpersonatingClient = TRUE; 

        if (ERROR_SUCCESS != (dwResult = AllocAndAssignString((PKEYSVC_UNICODE_STRING)pPassword, &pwszPassword)))
            goto error; 

        // Get an in-memory store which contains all of the certs in the PFX
        // blob.  
        if (NULL == (hSrcStore = PFXImportCertStore(&PFXBlob, pwszPassword, ulFlags)))
        {
            dwResult = GetLastError(); 
            goto error; 
        }

        // Open the stores we'll need: 
        for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStores); dwIndex++) 
        {
            *(rgStores[dwIndex].phStore) = CertOpenStore
                (CERT_STORE_PROV_SYSTEM_W,                 // store provider type
                 PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,  // cert encoding type
                 NULL,                                     // hCryptProv
                 dwCertOpenStoreFlags,                     // open store flags
                 rgStores[dwIndex].pwszStoreName           // store name
                 ); 
            if (NULL == *(rgStores[dwIndex].phStore))
            {
                dwResult = GetLastError();
                goto error; 
            }
        }

        // Enumerate the certs in the in-memory store, and add them to the local machine's
        // "my" store.  NOTE: CertEnumCertificatesInStore frees the previous cert context
        // before returning the new context.  
        while (NULL != (pCertContext = CertEnumCertificatesInStore(hSrcStore, pCertContext)))
        { 
            HCERTSTORE hCertStore; 

            // check if the certificate has the property on it
            // make sure the private key matches the certificate
            // search for both machine key and user keys
            if (CertGetCertificateContextProperty
                (pCertContext,
                 CERT_KEY_PROV_INFO_PROP_ID,
                 NULL,
                 &dwData) &&
                CryptFindCertificateKeyProvInfo
                (pCertContext,
                 0,
                 NULL))
            {
                hCertStore = hMyStore; 
            }
            else if (TrustIsCertificateSelfSigned
                     (pCertContext,
                      pCertContext->dwCertEncodingType,
                      0))
            {
                hCertStore = hRootStore; 
            }
            else
            {
                hCertStore = hCAStore; 
            }
            
            if (!CertAddCertificateContextToStore
                (hCertStore, 
                 pCertContext, 
                 CERT_STORE_ADD_NEW, 
                 NULL))
            {
                dwResult = GetLastError(); 
                goto error; 
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwResult = GetExceptionCode(); 
        goto error;
    }

    // We're done!
    dwResult = ERROR_SUCCESS; 
 error:
    if (fIsImpersonatingClient) { RpcRevertToSelfEx(hRPCBinding); }
    if (NULL != hSrcStore)      { CertCloseStore(hSrcStore, 0); }  
    
    // Close all of the destination stores we've opened. 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStores); dwIndex++)
        if (NULL != *(rgStores[dwIndex].phStore))   
            CertCloseStore(*(rgStores[dwIndex].phStore), 0); 

    if (NULL != pwszPassword)   { MyFree(pwszPassword); } 
    if (NULL != pCertContext)   { CertFreeCertificateContext(pCertContext); }
    return dwResult; 
}

ULONG       s_RKeyrOpenKeyService(
/* [in]  */     handle_t                       hRPCBinding,
/* [in]  */     KEYSVC_TYPE                    OwnerType,
/* [in]  */     PKEYSVC_UNICODE_STRING         pOwnerName,
/* [in]  */     ULONG                          ulDesiredAccess,
/* [in]  */     PKEYSVC_BLOB                   pAuthentication,
/* [in, out] */ PKEYSVC_BLOB                  *ppReserved,
/* [out] */     KEYSVC_HANDLE                 *phKeySvc)
{
    return s_KeyrOpenKeyService
        (hRPCBinding,
         OwnerType,
         pOwnerName,
         ulDesiredAccess,
         pAuthentication,
         ppReserved,
         phKeySvc);
}

ULONG       s_RKeyrCloseKeyService(
/* [in] */      handle_t         hRPCBinding,
/* [in] */      KEYSVC_HANDLE    hKeySvc,
/* [in, out] */ PKEYSVC_BLOB    *ppReserved)
{
    return s_KeyrCloseKeyService
        (hRPCBinding,
         hKeySvc,
         ppReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\forwardr\mssip32\mssip32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mssip32.cpp
//
//--------------------------------------------------------------------------

#ifdef _M_IX86

#include <windows.h>
#include <wincrypt.h>
#include <mssip.h>

STDAPI mssip32DllRegisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllRegisterServer()
{
    __asm {
        jmp mssip32DllRegisterServer
    }
}

STDAPI mssip32DllUnregisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllUnregisterServer()
{
    __asm {
        jmp mssip32DllUnregisterServer
    }
}


EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPGetSignedDataMsg(   
                                IN      SIP_SUBJECTINFO *pSubjectInfo,
                                OUT     DWORD           *pdwEncodingType,
                                IN      DWORD           dwIndex,
                                IN OUT  DWORD           *pcbSignedDataMsg,
                                OUT     BYTE            *pbSignedDataMsg)
{
    __asm {
        jmp CryptSIPGetSignedDataMsg
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPPutSignedDataMsg(   
                                IN      SIP_SUBJECTINFO *pSubjectInfo,
                                IN      DWORD           dwEncodingType,
                                OUT     DWORD           *pdwIndex,
                                IN      DWORD           cbSignedDataMsg,
                                IN      BYTE            *pbSignedDataMsg)
{
    __asm {
        jmp CryptSIPPutSignedDataMsg
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPRemoveSignedDataMsg(
                                IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN      DWORD               dwIndex)
{
    __asm {
        jmp CryptSIPRemoveSignedDataMsg
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPVerifyIndirectData(
                                IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN      SIP_INDIRECT_DATA   *pIndirectData)
{
    __asm {
        jmp CryptSIPVerifyIndirectData
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPCreateIndirectData(
                                IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN OUT  DWORD               *pcbIndirectData,
                                OUT     SIP_INDIRECT_DATA   *pIndirectData)
{
    __asm {
        jmp CryptSIPCreateIndirectData
    }
}

void CryptSIPGetRegWorkingFlags(DWORD *pdwState);
__declspec(naked)
void ForwardrCryptSIPGetRegWorkingFlags(DWORD *pdwState) 
{
    __asm {
        jmp CryptSIPGetRegWorkingFlags
    }
}

//
//  support for Auth2 release
//
typedef struct _SIP_INFORMATION
{
    DWORD       cbSize;         // sizeof(SIP_INFORMATION)
    DWORD       cgSubjects;     // number of guids in array
    const GUID  *pgSubjects;    // array of supported guids/subjects
} SIP_INFORMATION, *PSIP_INFORMATION;

BOOL CryptSIPGetInfo(IN OUT SIP_INFORMATION    *pSIPInit);
__declspec(naked)
BOOL ForwardrCryptSIPGetInfo(IN OUT SIP_INFORMATION    *pSIPInit)
{
    __asm {
        jmp CryptSIPGetInfo
    }
}

#else

static void Dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\forwardr\softpub\softpub.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       softpub.cpp
//
//--------------------------------------------------------------------------

#ifdef _M_IX86

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <prsht.h>

STDAPI SoftpubDllRegisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllRegisterServer()
{
    __asm {
        jmp SoftpubDllRegisterServer
    }
}

STDAPI SoftpubDllUnregisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllUnregisterServer()
{
    __asm {
        jmp SoftpubDllUnregisterServer
    }
}

EXTERN_C
HRESULT WINAPI SoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubAuthenticode
    }
}

EXTERN_C
HRESULT WINAPI SoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubDumpStructure
    }
}


EXTERN_C
HRESULT WINAPI SoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubInitialize
    }
}

EXTERN_C
HRESULT WINAPI SoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubLoadMessage
    }
}

EXTERN_C
HRESULT SoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT ForwardrSoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubLoadSignature
    }
}

EXTERN_C
BOOL WINAPI SoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner,
                             BOOL fCounterSignerChain, DWORD idxCounterSigner);

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrSoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner,
                             BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
    __asm {
        jmp SoftpubCheckCert
    }
}

EXTERN_C
HRESULT WINAPI SoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubCleanup
    }
}


HRESULT WINAPI SoftpubDefCertInit(CRYPT_PROVIDER_DATA *pProvData);

__declspec(naked)
HRESULT WINAPI ForwardrSoftpubDefCertInit(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubDefCertInit
    }
}


HRESULT WINAPI HTTPSCertificateTrust(CRYPT_PROVIDER_DATA *pProvData);

__declspec(naked)
HRESULT WINAPI ForwardrHTTPSCertificateTrust(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp HTTPSCertificateTrust
    }
}

EXTERN_C
HRESULT WINAPI HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrHTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp HTTPSFinalProv
    }
}

EXTERN_C
HRESULT WINAPI OfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrOfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp OfficeInitializePolicy
    }
}

EXTERN_C
HRESULT WINAPI OfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrOfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp OfficeCleanupPolicy
    }
}


EXTERN_C
HRESULT WINAPI DriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrDriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp DriverInitializePolicy
    }
}

EXTERN_C
HRESULT WINAPI DriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrDriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp DriverFinalPolicy
    }
}

EXTERN_C
HRESULT WINAPI DriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrDriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp DriverCleanupPolicy
    }
}


EXTERN_C
BOOL WINAPI OpenPersonalTrustDBDialog(HWND hwndParent);

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrOpenPersonalTrustDBDialog(HWND hwndParent)
{
    __asm {
        jmp OpenPersonalTrustDBDialog
    }
}

EXTERN_C
BOOL CALLBACK AddPersonalTrustDBPages(
    LPVOID lpv,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
   );

EXTERN_C
__declspec(naked)
BOOL CALLBACK ForwardrAddPersonalTrustDBPages(
    LPVOID lpv,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
   )
{
    __asm {
        jmp AddPersonalTrustDBPages
    }
}


EXTERN_C
__declspec(naked)
HRESULT
WINAPI
ForwardrFindCertsByIssuer(
    OUT PCERT_CHAIN pCertChains,
    IN OUT DWORD *pcbCertChains,
    OUT DWORD *pcCertChains,        // count of certificates chains returned
    IN BYTE* pbEncodedIssuerName,   // DER encoded issuer name
    IN DWORD cbEncodedIssuerName,   // count in bytes of encoded issuer name
    IN LPCWSTR pwszPurpose,         // "ClientAuth" or "CodeSigning"
    IN DWORD dwKeySpec              // only return signers supporting this
    // keyspec
    )
{
    __asm {
        jmp FindCertsByIssuer
    }
}

BOOL WINAPI SoftpubLoadDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

__declspec(naked)
BOOL WINAPI ForwardrSoftpubLoadDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    __asm {
        jmp SoftpubLoadDefUsageCallData
    }
}

BOOL WINAPI SoftpubFreeDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

__declspec(naked)
BOOL WINAPI ForwardrSoftpubFreeDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    __asm {
        jmp SoftpubFreeDefUsageCallData
    }
}

HRESULT
WINAPI
GenericChainCertificateTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    );

__declspec(naked)
HRESULT
WINAPI
ForwardrGenericChainCertificateTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    __asm {
        jmp GenericChainCertificateTrust
    }
}


HRESULT
WINAPI
GenericChainFinalProv(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    );

__declspec(naked)
HRESULT
WINAPI
ForwardrGenericChainFinalProv(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    __asm {
        jmp GenericChainFinalProv
    }
}

#else

static void Dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\dll\mincryptdll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mincryptdll.cpp
//
//  Functions:  DllMain
//
//  History:    26-Jan-01    philh    created
//
//--------------------------------------------------------------------------

#include "windows.h"

// unreferenced formal parameter
#pragma warning (disable: 4100)


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\asn1parse.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       asn1parse.cpp
//
//  Contents:   Minimal ASN.1 parse functions.
//
//  Functions:  MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//  History:    15-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

const BYTE rgbSeqTag[] = {MINASN1_TAG_SEQ, 0};
const BYTE rgbSetTag[] = {MINASN1_TAG_SET, 0};
const BYTE rgbOIDTag[] = {MINASN1_TAG_OID, 0};
const BYTE rgbIntegerTag[] = {MINASN1_TAG_INTEGER, 0};
const BYTE rgbBooleanTag[] = {MINASN1_TAG_BOOLEAN, 0};
const BYTE rgbBitStringTag[] = {MINASN1_TAG_BITSTRING, 0};
const BYTE rgbOctetStringTag[] = {MINASN1_TAG_OCTETSTRING, 0};
const BYTE rgbConstructedContext0Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_0, 0};
const BYTE rgbConstructedContext1Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_1, 0};
const BYTE rgbConstructedContext3Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_3, 0};
const BYTE rgbContext1Tag[] = {MINASN1_TAG_CONTEXT_1, 0};
const BYTE rgbContext2Tag[] = {MINASN1_TAG_CONTEXT_2, 0};
const BYTE rgbChoiceOfTimeTag[] =
    {MINASN1_TAG_UTC_TIME, MINASN1_TAG_GENERALIZED_TIME, 0};


const MINASN1_EXTRACT_VALUE_PARA rgParseCertPara[] = {
    // 0 - SignedContent ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CERT_ENCODED_IDX, rgbSeqTag,

    // 0.1 - toBeSigned ::== SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_CERT_TO_BE_SIGNED_IDX, rgbSeqTag,

    // 0.1.0 - version                 [0] EXPLICIT CertificateVersion DEFAULT v1,
    MINASN1_OPTIONAL_STEP_INTO_VALUE_OP, 0, rgbConstructedContext0Tag,

    // 0.1.0.0 - version number (INTEGER)
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.1
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.1 - serialNumber            CertificateSerialNumber,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SERIAL_NUMBER_IDX, rgbIntegerTag,
    // 0.1.2 - signature               AlgorithmIdentifier,
    MINASN1_STEP_OVER_VALUE_OP, 0, rgbSeqTag,
    // 0.1.3 - issuer                  NOCOPYANY, -- really Name
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_ISSUER_IDX, rgbSeqTag,
    // 0.1.4 - validity                Validity,
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.4.0 - notBefore           ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_NOT_BEFORE_IDX, rgbChoiceOfTimeTag,
    // 0.1.4.1 - notAfter            ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_NOT_AFTER_IDX, rgbChoiceOfTimeTag,
    // 0.1.4.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.5 - subject                 NOCOPYANY, -- really Name
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SUBJECT_IDX, rgbSeqTag,
    // 0.1.6 - subjectPublicKeyInfo    SubjectPublicKeyInfo,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_PUBKEY_INFO_IDX, rgbSeqTag,
    // 0.1.7 - issuerUniqueIdentifier  [1] IMPLICIT BITSTRING OPTIONAL,
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_ISSUER_UNIQUE_ID_IDX, rgbContext1Tag,
    // 0.1.8 - subjectUniqueIdentifier [2] IMPLICIT BITSTRING OPTIONAL,
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX, rgbContext2Tag,
    // 0.1.9 - extensions              [3] EXPLICIT Extensions OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_EXTS_IDX, rgbConstructedContext3Tag,

    // 0.1.10
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.2 - signatureAlgorithm  AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SIGN_ALGID_IDX, rgbSeqTag,
    // 0.3 - signature           BITSTRING
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SIGNATURE_IDX, rgbBitStringTag,
};
#define PARSE_CERT_PARA_CNT         \
    (sizeof(rgParseCertPara) / sizeof(rgParseCertPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CERT_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseCertPara,
        MINASN1_CERT_BLOB_CNT,
        rgCertBlob
        );

    if (0 < lSkipped) {
        lSkipped = rgCertBlob[MINASN1_CERT_ENCODED_IDX].cbData;

        // If present, fixup the ISSUER_UNIQUE_ID and SUBJECT_UNIQUE_ID bit
        // fields to advance past the first contents octet containing the
        // number of unused bits
        if (0 != rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData) {
            rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].pbData += 1;
            rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData -= 1;
        }

        if (0 != rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData) {
            rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].pbData += 1;
            rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData -= 1;
        }
    }

    return lSkipped;
}

const MINASN1_EXTRACT_VALUE_PARA rgParseAlgIdPara[] = {
    // 0 - AlgorithmIdentifier    ::=    SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_ALGID_ENCODED_IDX, rgbSeqTag,

    // 0.0 - algorithm  ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_ALGID_OID_IDX, rgbOIDTag,
    // 0.1 parameters ANY OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_ALGID_PARA_IDX, NULL,
};
#define PARSE_ALGID_PARA_CNT        \
    (sizeof(rgParseAlgIdPara) / sizeof(rgParseAlgIdPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_ALGID_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pAlgIdValueBlob->pbData,
        pAlgIdValueBlob->cbData,
        &cValuePara,
        rgParseAlgIdPara,
        MINASN1_ALGID_BLOB_CNT,
        rgAlgIdBlob
        );

    if (0 < lSkipped)
        lSkipped = rgAlgIdBlob[MINASN1_ALGID_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParsePubKeyInfoPara[] = {
    // 0 - PublicKeyInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_PUBKEY_INFO_ENCODED_IDX, rgbSeqTag,

    // 0.0 - algorithm  AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_PUBKEY_INFO_ALGID_IDX, rgbSeqTag,

    // 0.1 - PublicKey  BITSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_PUBKEY_INFO_PUBKEY_IDX, rgbBitStringTag,
};
#define PARSE_PUBKEY_INFO_PARA_CNT      \
    (sizeof(rgParsePubKeyInfoPara) / sizeof(rgParsePubKeyInfoPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_PUBKEY_INFO_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pPubKeyInfoValueBlob->pbData,
        pPubKeyInfoValueBlob->cbData,
        &cValuePara,
        rgParsePubKeyInfoPara,
        MINASN1_PUBKEY_INFO_BLOB_CNT,
        rgPubKeyInfoBlob
        );

    if (0 < lSkipped)
        lSkipped = rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseRSAPubKeyPara[] = {
    // 0 - RSAPublicKey ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_RSA_PUBKEY_ENCODED_IDX, rgbSeqTag,

    // 0.0 - modulus         HUGEINTEGER,    -- n
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_RSA_PUBKEY_MODULUS_IDX, rgbIntegerTag,
    // 0.1 - publicExponent  INTEGER (0..4294967295)         -- e
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_RSA_PUBKEY_EXPONENT_IDX, rgbIntegerTag,
};
#define PARSE_RSA_PUBKEY_PARA_CNT       \
    (sizeof(rgParseRSAPubKeyPara) / sizeof(rgParseRSAPubKeyPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_RSA_PUBKEY_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pPubKeyContentBlob->pbData,
        pPubKeyContentBlob->cbData,
        &cValuePara,
        rgParseRSAPubKeyPara,
        MINASN1_RSA_PUBKEY_BLOB_CNT,
        rgRSAPubKeyBlob
        );

    if (0 < lSkipped)
        lSkipped = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_ENCODED_IDX].cbData;

    return lSkipped;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseExtPara[] = {
    // 0 - Extension ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_EXT_ENCODED_IDX, rgbSeqTag,

    // 0.0 - extnId              EncodedObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_EXT_OID_IDX, rgbOIDTag,
    // 0.1 - critical            BOOLEAN DEFAULT FALSE,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_EXT_CRITICAL_IDX, rgbBooleanTag,
    // 0.2 - extnValue           OCTETSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_EXT_VALUE_IDX, rgbOctetStringTag,
};

#define PARSE_EXT_PARA_CNT          \
    (sizeof(rgParseExtPara) / sizeof(rgParseExtPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pExtsValueBlob->pbData;
    DWORD cbEncoded = pExtsValueBlob->cbData;
    DWORD cExt = *pcExt;
    DWORD iExt = 0;
    LONG lAllExts = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No extensions
        goto CommonReturn;

    // Step into the SEQUENCE
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllExts = -1;
        goto CommonReturn;
    }

    for (iExt = 0; 0 < cb && iExt < cExt; iExt++) {
        LONG lExt;
        DWORD cbExt;
        DWORD cValuePara = PARSE_EXT_PARA_CNT;

        lExt = MinAsn1ExtractValues(
            pb,
            cb,
            &cValuePara,
            rgParseExtPara,
            MINASN1_EXT_BLOB_CNT,
            rgrgExtBlob[iExt]
            );

        if (0 >= lExt) {
            if (0 == lExt)
                lExt = -1;
            lAllExts = -((LONG)(pb - pbEncoded)) + lExt;
            goto CommonReturn;
        }

        cbExt = rgrgExtBlob[iExt][MINASN1_EXT_ENCODED_IDX].cbData;
        pb += cbExt;
        cb -= cbExt;
    }

    lAllExts = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllExts <= cbEncoded);

CommonReturn:
    *pcExt = iExt;
    return lAllExts;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseSignedDataPara[] = {
    // 0 - ContentInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_SIGNED_DATA_ENCODED_IDX, rgbSeqTag,

    // 0.0 - contentType ContentType,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_OUTER_OID_IDX, rgbOIDTag,
    // 0.1 - content  [0] EXPLICIT ANY -- OPTIONAL
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbConstructedContext0Tag,

    // 0.1.0 - SignedData ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.0 - version             INTEGER,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.1 - digestAlgorithms    DigestAlgorithmIdentifiers,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX, rgbSetTag,
    // 0.1.0.2 - ContentInfo ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.2.0 - contentType ContentType,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CONTENT_OID_IDX, rgbOIDTag,
    // 0.1.0.2.1 - content  [0] EXPLICIT ANY -- OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CONTENT_DATA_IDX, rgbConstructedContext0Tag,
    // 0.1.0.2.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.0.3 - certificates        [0] IMPLICIT Certificates OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CERTS_IDX, rgbConstructedContext0Tag,
    // 0.1.0.4 - crls                [1] IMPLICIT CertificateRevocationLists OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CRLS_IDX, rgbConstructedContext1Tag,
    // 0.1.0.5 - signerInfos :: = SET OF
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX, rgbSetTag,

    // 0.1.0.5.0 - SignerInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_INTO_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX, rgbSeqTag,

    // 0.1.0.5.0.0 - version                     INTEGER,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.5.0.1 - issuerAndSerialNumber       IssuerAndSerialNumber
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.5.0.1.0 - issuer          ANY,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX, rgbSeqTag,
    // 0.1.0.5.0.1.1 - serialNumber    INTEGER
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX, rgbIntegerTag,
    // 0.1.0.5.0.1.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.0.5.0.2 - digestAlgorithm             DigestAlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.0.5.0.3 - authenticatedAttributes     [0] IMPLICIT Attributes OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX, rgbConstructedContext0Tag,
    // 0.1.0.5.0.4 - digestEncryptionAlgorithm   DigestEncryptionAlgId,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.0.5.0.5 - encryptedDigest             EncryptedDigest,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX, rgbOctetStringTag,
    // 0.1.0.5.0.6 - unauthenticatedAttributes   [1] IMPLICIT Attributes OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX, rgbConstructedContext1Tag,
};
#define PARSE_SIGNED_DATA_PARA_CNT      \
    (sizeof(rgParseSignedDataPara) / sizeof(rgParseSignedDataPara[0]))


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_SIGNED_DATA_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseSignedDataPara,
        MINASN1_SIGNED_DATA_BLOB_CNT,
        rgSignedDataBlob
        );

    if (0 < lSkipped)
        lSkipped = rgSignedDataBlob[MINASN1_SIGNED_DATA_ENCODED_IDX].cbData;

    return lSkipped;
}


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pCertsValueBlob->pbData;
    DWORD cbEncoded = pCertsValueBlob->cbData;
    DWORD cCert = *pcCert;
    DWORD iCert = 0;
    LONG lAllCerts = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No certificates
        goto CommonReturn;

    // Skip outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllCerts = -1;
        goto CommonReturn;
    }

    for (iCert = 0; 0 < cb && iCert < cCert; iCert++) {
        LONG lCert;

        lCert = MinAsn1ParseCertificate(
            pb,
            cb,
            rgrgCertBlob[iCert]
            );

        if (0 >= lCert) {
            if (0 == lCert)
                lCert = -1;
            lAllCerts = -((LONG)(pb - pbEncoded)) + lCert;
            goto CommonReturn;
        }

        pb += lCert;
        cb -= lCert;
    }

    lAllCerts = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllCerts <= cbEncoded);

CommonReturn:
    *pcCert = iCert;
    return lAllCerts;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_ATTR_ENCODED_IDX, rgbSeqTag,

    // 0.0 - attributeType       ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_ATTR_OID_IDX, rgbOIDTag,
    // 0.1 - attributeValue      SET OF
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_ATTR_VALUES_IDX, rgbSetTag,

    // 0.1.0 - Value        ANY -- OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_ATTR_VALUE_IDX, NULL,
};
#define PARSE_ATTR_PARA_CNT         \
    (sizeof(rgParseAttrPara) / sizeof(rgParseAttrPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pAttrsValueBlob->pbData;
    DWORD cbEncoded = pAttrsValueBlob->cbData;
    DWORD cAttr = *pcAttr;
    DWORD iAttr = 0;
    LONG lAllAttrs = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No attributes
        goto CommonReturn;

    // Skip the outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllAttrs = -1;
        goto CommonReturn;
    }

    for (iAttr = 0; 0 < cb && iAttr < cAttr; iAttr++) {
        LONG lAttr;
        DWORD cbAttr;
        DWORD cValuePara = PARSE_ATTR_PARA_CNT;

        lAttr = MinAsn1ExtractValues(
            pb,
            cb,
            &cValuePara,
            rgParseAttrPara,
            MINASN1_ATTR_BLOB_CNT,
            rgrgAttrBlob[iAttr]
            );

        if (0 >= lAttr) {
            if (0 == lAttr)
                lAttr = -1;
            lAllAttrs = -((LONG)(pb - pbEncoded)) + lAttr;
            goto CommonReturn;
        }

        cbAttr = rgrgAttrBlob[iAttr][MINASN1_ATTR_ENCODED_IDX].cbData;
        pb += cbAttr;
        cb -= cbAttr;
    }

    lAllAttrs = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllAttrs <= cbEncoded);

CommonReturn:
    *pcAttr = iAttr;
    return lAllAttrs;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseCTLPara[] = {
    // 0 - CertificateTrustList ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CTL_ENCODED_IDX, rgbSeqTag,

    // 0.0 - version                 CTLVersion DEFAULT v1,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_VERSION_IDX, rgbIntegerTag,
    // 0.1 - subjectUsage            SubjectUsage,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_USAGE_IDX, rgbSeqTag,
    // 0.2 - listIdentifier          ListIdentifier OPTIONAL,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_LIST_ID_IDX, rgbOctetStringTag,
    // 0.3 - sequenceNumber          HUGEINTEGER OPTIONAL,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SEQUENCE_NUMBER_IDX, rgbIntegerTag,
    // 0.4 - ctlThisUpdate           ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_THIS_UPDATE_IDX, rgbChoiceOfTimeTag,
    // 0.5 - ctlNextUpdate           ChoiceOfTime OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_NEXT_UPDATE_IDX, rgbChoiceOfTimeTag,
    // 0.6 - subjectAlgorithm        AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ALGID_IDX, rgbSeqTag,
    // 0.7 - trustedSubjects         TrustedSubjects OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECTS_IDX, rgbSeqTag,
    // 0.8 - ctlExtensions           [0] EXPLICIT Extensions OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_EXTS_IDX, rgbConstructedContext0Tag,
};
#define PARSE_CTL_PARA_CNT          \
    (sizeof(rgParseCTLPara) / sizeof(rgParseCTLPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CTL_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pEncodedContentBlob->pbData,
        pEncodedContentBlob->cbData,
        &cValuePara,
        rgParseCTLPara,
        MINASN1_CTL_BLOB_CNT,
        rgCTLBlob
        );

    if (0 < lSkipped)
        lSkipped = rgCTLBlob[MINASN1_CTL_ENCODED_IDX].cbData;

    return lSkipped;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseCTLSubjectPara[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CTL_SUBJECT_ENCODED_IDX, rgbSeqTag,

    // 0.0 - subjectIdentifier       SubjectIdentifier,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ID_IDX, rgbOctetStringTag,
    // 0.1 - subjectAttributes	    Attributes OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ATTRS_IDX, rgbSetTag,
};
#define PARSE_CTL_SUBJECT_PARA_CNT      \
    (sizeof(rgParseCTLSubjectPara) / sizeof(rgParseCTLSubjectPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CTL_SUBJECT_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseCTLSubjectPara,
        MINASN1_CTL_SUBJECT_BLOB_CNT,
        rgCTLSubjectBlob
        );

    if (0 < lSkipped)
        lSkipped = rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseIndirectDataPara[] = {
    // 0 - SpcIndirectDataContent ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_INDIRECT_DATA_ENCODED_IDX, rgbSeqTag,

    // 0.0 - data                    SpcAttributeTypeAndOptionalValue,
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.0.0 - type                    ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_ATTR_OID_IDX, rgbOIDTag,
    // 0.0.1 - value                   NOCOPYANY OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX, NULL,
    // 0.0.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1 - messageDigest           DigestInfo
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0 - digestAlgorithm     AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.1 - digest              OCTETSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_DIGEST_IDX, rgbOctetStringTag,
};
#define PARSE_INDIRECT_DATA_PARA_CNT    \
    (sizeof(rgParseIndirectDataPara) / sizeof(rgParseIndirectDataPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_INDIRECT_DATA_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pEncodedContentBlob->pbData,
        pEncodedContentBlob->cbData,
        &cValuePara,
        rgParseIndirectDataPara,
        MINASN1_INDIRECT_DATA_BLOB_CNT,
        rgIndirectDataBlob
        );

    if (0 < lSkipped)
        lSkipped = rgIndirectDataBlob[MINASN1_INDIRECT_DATA_ENCODED_IDX].cbData;

    return lSkipped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\fileutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       fileutil.cpp
//
//  Contents:   File utility functions used by the minimal cryptographic
//              APIs.
//
//  Functions:  I_MinCryptMapFile
//
//  History:    21-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#ifdef _M_IX86

//+=========================================================================
//  The following is taken from the following file:
//      \nt\ds\security\cryptoapi\common\unicode\reg.cpp
//-=========================================================================

BOOL WINAPI I_FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}


// make MBCS from Unicode string
//
// Include parameters specifying the length of the input wide character
// string and return number of bytes converted. An input length of -1 indicates
// null terminated.
//
// This extended version was added to handle REG_MULTI_SZ which contains
// multiple null terminated strings.
BOOL WINAPI I_MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW,
    char ** pszMB, int *pcbConverted) {

    int   cbConverted;

    // sfield: don't bring in crt for assert.  you get free assert via
    // an exception if these are null
//    assert(pszMB != NULL);
    *pszMB = NULL;
//    assert(pcbConverted != NULL);
    *pcbConverted = 0;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        cchW,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
    if (cbConverted <= 0)
        return(FALSE);

    // get a buffer long enough
    if(pbBuff != NULL  &&  (DWORD) cbConverted <= cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) I_MemAlloc(cbConverted);

    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    *pcbConverted = WideCharToMultiByte(0,
                        0,
                        wsz,
                        cchW,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

// make MBCS from Unicode string
BOOL WINAPI I_MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {
    int cbConverted;
    return I_MkMBStrEx(pbBuff, cbBuff, wsz, -1, pszMB, &cbConverted);
}

void WINAPI I_FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        I_MemFree(szMB);
}


//+=========================================================================
//  The following was taken from the following file:
//      \nt\ds\security\cryptoapi\common\unicode\file.cpp
//-=========================================================================

HANDLE WINAPI I_CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    HANDLE  hFile;

    if(I_FIsWinNT())
        return( CreateFileW (
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            ));

    hFile = INVALID_HANDLE_VALUE;
    if(I_MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        hFile = CreateFileA (
            szFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            );

    I_FreeMBStr(rgb, szFileName);

    return(hFile);
}

#else

#define I_CreateFileU             CreateFileW

#endif // _M_IX86



//+-------------------------------------------------------------------------
//  Maps the file into memory.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only READ access is required.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  *pFileBlob is updated with pointer to and length of the mapped file. For
//  MINCRYPT_FILE_NAME and MINCRYPT_FILE_HANDLE, UnmapViewOfFile() must
//  be called to free pFileBlob->pbData.
//
//  All accesses to this mapped memory must be within __try / __except's.
//--------------------------------------------------------------------------
LONG
WINAPI
I_MinCryptMapFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    OUT PCRYPT_DATA_BLOB pFileBlob
    )
{
    LONG lErr = ERROR_SUCCESS;

    switch (dwFileType) {
        case MINCRYPT_FILE_NAME:
            {
                LPCWSTR pwszInFilename = (LPCWSTR) pvFile;
                HANDLE hFile;

                hFile = I_CreateFileU(
                    pwszInFilename,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,                   // lpsa
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL                    // hTemplateFile
                    );
                if (INVALID_HANDLE_VALUE == hFile)
                    goto CreateFileError;

                lErr = I_MinCryptMapFile(
                    MINCRYPT_FILE_HANDLE,
                    (const VOID *) hFile,
                    pFileBlob
                    );
                CloseHandle(hFile);
            }
            break;

        case MINCRYPT_FILE_HANDLE:
            {
                HANDLE hInFile = (HANDLE) pvFile;
                HANDLE hMappedFile;
                DWORD cbHighSize = 0;;
                DWORD cbLowSize;

                cbLowSize = GetFileSize(hInFile, &cbHighSize);
                if (INVALID_FILE_SIZE == cbLowSize)
                    goto GetFileSizeError;
                if (0 != cbHighSize)
                    goto Exceeded32BitFileSize;

                hMappedFile = CreateFileMappingA(
                    hInFile,
                    NULL,           // lpFileMappingAttributes,
                    PAGE_READONLY,
                    0,              // dwMaximumSizeHigh
                    0,              // dwMaximumSizeLow
                    NULL            // lpName
                    );
                if (NULL == hMappedFile)
                    goto CreateFileMappingError;

                pFileBlob->pbData = (BYTE *) MapViewOfFile(
                    hMappedFile,
                    FILE_MAP_READ,
                    0,              // dwFileOffsetHigh
                    0,              // dwFileOffsetLow
                    0               // dwNumberOfBytesToMap, 0 => entire file
                    );
                CloseHandle(hMappedFile);
                if (NULL == pFileBlob->pbData)
                    goto MapViewOfFileError;

                pFileBlob->cbData = cbLowSize;
            }
            break;

        case MINCRYPT_FILE_BLOB:
            {
                PCRYPT_DATA_BLOB pInFileBlob = (PCRYPT_DATA_BLOB) pvFile;
                *pFileBlob = *pInFileBlob;
            }
            break;

        default:
            goto InvalidParameter;
    }

CommonReturn:
    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    pFileBlob->pbData = NULL;
    pFileBlob->cbData = 0;
    goto CommonReturn;

InvalidParameter:
    lErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;

Exceeded32BitFileSize:
    lErr = ERROR_FILE_INVALID;
    goto ErrorReturn;

CreateFileError:
GetFileSizeError:
CreateFileMappingError:
MapViewOfFileError:
    lErr = GetLastError();
    if (ERROR_SUCCESS == lErr)
        lErr = ERROR_OPEN_FAILED;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\asn1util.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       asn1util.cpp
//
//  Contents:   Minimal ASN.1 utility helper functions.
//
//  Functions:  MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//  History:    15-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbBER)
{
    long        i;
    BYTE        cbLength;
    const BYTE  *pb;

    if (cbBER < 1)
        goto TooLittleData;

    if (0x80 == *pbLength)
        goto IndefiniteLength;

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbBER)
            goto TooLittleData;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (const DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

LengthTooLargeError:
    i = MINASN1_LENGTH_TOO_LARGE;
    goto CommonReturn;

IndefiniteLength:
    i = MINASN1_UNSUPPORTED_INDEFINITE_LENGTH;
    goto CommonReturn;

TooLittleData:
    i = MINASN1_INSUFFICIENT_DATA;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent)
{
#define TAG_MASK 0x1f
    DWORD       cbIdentifier;
    DWORD       cbContent;
    LONG        cbLength;
    LONG        lHeader;
    const BYTE  *pb = pbBER;

    if (0 == cbBER--)
        goto TooLittleData;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        cbIdentifier = 2;
        while (TRUE) {
            if (0 == cbBER--)
                goto TooLittleData;
            if (0 == (*pb++ & 0x80))
                break;
            cbIdentifier++;
        }
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = MinAsn1DecodeLength( &cbContent, pb, cbBER))) {
        lHeader = cbLength;
        goto CommonReturn;
    }

    if (cbContent > (cbBER - cbLength))
        goto TooLittleData;

    pb += cbLength;

    *pcbContent = cbContent;
    *ppbContent = pb;

    lHeader = cbLength + cbIdentifier;
CommonReturn:
    return lHeader;

TooLittleData:
    lHeader = MINASN1_INSUFFICIENT_DATA;
    goto CommonReturn;
}


typedef struct _STEP_INTO_STACK_ENTRY {
    const BYTE      *pb;
    DWORD           cb;
    BOOL            fSkipIntoValues;
} STEP_INTO_STACK_ENTRY, *PSTEP_INTO_STACK_ENTRY;

#define MAX_STEP_INTO_DEPTH     8

//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    )
{
    DWORD cValue = *pcValuePara;
    const BYTE *pb = pbEncoded;
    DWORD cb = cbEncoded;
    BOOL fSkipIntoValues = FALSE;

    DWORD iValue;
    LONG lAllValues;

    STEP_INTO_STACK_ENTRY rgStepIntoStack[MAX_STEP_INTO_DEPTH];
    DWORD dwStepIntoDepth = 0;

    for (iValue = 0; iValue < cValue; iValue++) {
        DWORD dwParaFlags = rgValuePara[iValue].dwFlags;
        DWORD dwOp = dwParaFlags & MINASN1_MASK_VALUE_OP;
        const BYTE *pbParaTag = rgValuePara[iValue].rgbTag;
        DWORD dwIndex = rgValuePara[iValue].dwIndex;
        BOOL fValueBlob = (dwParaFlags & (MINASN1_RETURN_VALUE_BLOB_FLAG |
                MINASN1_RETURN_CONTENT_BLOB_FLAG)) && rgValueBlob &&
                (dwIndex < cValueBlob);
        BOOL fSkipValue = FALSE;

        LONG lTagLength;
        DWORD cbContent;
        const BYTE *pbContent;
        DWORD cbValue;

        if (MINASN1_STEP_OUT_VALUE_OP == dwOp) {
            // Unstack and advance past the last STEP_INTO

            if (0 == dwStepIntoDepth)
                goto InvalidStepOutOp;

            dwStepIntoDepth--;
            pb = rgStepIntoStack[dwStepIntoDepth].pb;
            cb = rgStepIntoStack[dwStepIntoDepth].cb;
            fSkipIntoValues = rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues;

            continue;
        }

        if (fSkipIntoValues) {
            // For an omitted OPTIONAL_STEP_INTO, all of its included values
            // are also omitted.
            fSkipValue = TRUE;
        } else if (0 == cb) {
            if (!(MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp ||
                    MINASN1_OPTIONAL_STEP_OVER_VALUE_OP == dwOp))
                goto TooLittleData;
            fSkipValue = TRUE;
        } else if (pbParaTag) {
            // Assumption: single byte tag for doing comparison

            // Check if the encoded tag matches one of the expected tags

            BYTE bEncodedTag;
            BYTE bParaTag;

            bEncodedTag = *pb;
            while ((bParaTag = *pbParaTag) && bParaTag != bEncodedTag)
                pbParaTag++;

            if (0 == bParaTag) {
                if (!(MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp ||
                        MINASN1_OPTIONAL_STEP_OVER_VALUE_OP == dwOp))
                    goto InvalidTag;
                fSkipValue = TRUE;
            }
        }

        if (fSkipValue) {
            if (fValueBlob) {
                rgValueBlob[dwIndex].pbData = NULL;
                rgValueBlob[dwIndex].cbData = 0;
            }

            if (MINASN1_STEP_INTO_VALUE_OP == dwOp ||
                    MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp) {
                // Stack this skipped STEP_INTO
                if (MAX_STEP_INTO_DEPTH <= dwStepIntoDepth)
                    goto ExceededStepIntoDepth;
                rgStepIntoStack[dwStepIntoDepth].pb = pb;
                rgStepIntoStack[dwStepIntoDepth].cb = cb;
                rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues =
                    fSkipIntoValues;
                dwStepIntoDepth++;

                fSkipIntoValues = TRUE;
            }
            continue;
        }

        lTagLength = MinAsn1ExtractContent(
            pb,
            cb,
            &cbContent,
            &pbContent
            );
        if (0 >= lTagLength)
            goto InvalidTagOrLength;

        cbValue = cbContent + lTagLength;

        if (fValueBlob) {
            if (dwParaFlags & MINASN1_RETURN_CONTENT_BLOB_FLAG) {
                rgValueBlob[dwIndex].pbData = (BYTE *) pbContent;
                rgValueBlob[dwIndex].cbData = cbContent;

                if (MINASN1_TAG_BITSTRING == *pb) {
                    if (0 < cbContent) {
                        // Advance past the first contents octet containing
                        // the number of unused bits
                        rgValueBlob[dwIndex].pbData += 1;
                        rgValueBlob[dwIndex].cbData -= 1;
                    }
                }
            } else if (dwParaFlags & MINASN1_RETURN_VALUE_BLOB_FLAG) {
                rgValueBlob[dwIndex].pbData = (BYTE *) pb;
                rgValueBlob[dwIndex].cbData = cbValue;
            }
        }

        switch (dwOp) {
            case MINASN1_STEP_INTO_VALUE_OP:
            case MINASN1_OPTIONAL_STEP_INTO_VALUE_OP:
                // Stack this STEP_INTO
                if (MAX_STEP_INTO_DEPTH <= dwStepIntoDepth)
                    goto ExceededStepIntoDepth;
                rgStepIntoStack[dwStepIntoDepth].pb = pb + cbValue;
                rgStepIntoStack[dwStepIntoDepth].cb = cb - cbValue;
                assert(!fSkipIntoValues);
                rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues = FALSE;
                dwStepIntoDepth++;
                pb = pbContent;
                cb = cbContent;
                break;
            case MINASN1_STEP_OVER_VALUE_OP:
            case MINASN1_OPTIONAL_STEP_OVER_VALUE_OP:
                pb += cbValue;
                cb -= cbValue;
                break;
            default:
                goto InvalidArg;
        }
    }

    lAllValues = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllValues <= cbEncoded);

CommonReturn:
    *pcValuePara = iValue;
    return lAllValues;

InvalidStepOutOp:
TooLittleData:
InvalidTag:
ExceededStepIntoDepth:
InvalidTagOrLength:
InvalidArg:
    lAllValues = -((LONG)(pb - pbEncoded)) - 1;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;

    for (i = 0; i < cExt; i++) {
        if (cbOID == rgrgExtBlob[i][MINASN1_EXT_OID_IDX].cbData
                            &&
                0 == memcmp(pbOID, rgrgExtBlob[i][MINASN1_EXT_OID_IDX].pbData,
                                cbOID))
            return rgrgExtBlob[i];
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;

    for (i = 0; i < cAttr; i++) {
        if (cbOID == rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX].cbData
                            &&
                0 == memcmp(pbOID, rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX].pbData,
                                cbOID))
            return rgrgAttrBlob[i];
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    LONG lSkipped;
    CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT];

    lSkipped = MinAsn1ParseSignedData(
        pbEncoded,
        cbEncoded,
        rgSignedDataBlob
        );
    if (0 >= lSkipped)
        goto ParseError;

    lSkipped = MinAsn1ParseSignedDataCertificates(
            &rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX],
            pcCert,
            rgrgCertBlob
            );

    if (0 > lSkipped) {
        assert(rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX].pbData >
            pbEncoded);
        lSkipped -= rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX].pbData -
            pbEncoded;

        goto ParseError;
    }

CommonReturn:
    return lSkipped;

ParseError:
    *pcCert = 0;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\inc\minasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       minasn1.h
//
//  Contents:   Minimal ASN.1 Utility and Parsing API Prototypes
//              and Definitions
//
//              Contains functions to parse X.509 certificates, PKCS #7
//              Signed Data messages, Certificate Trusts Lists (CTLs),
//              hash catalogs, Authenticode Indirect Data and
//              RSA public keys.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//              These parsing functions don't depend on more heavy wait
//              ASN.1 runtimes, such as, msoss.dll or msasn1.dll.
//
//              These functions will only use stack memory. No heap
//              allocations. No calls to APIs in other DLLs.
//
//  APIs: 
//              MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//----------------------------------------------------------------------------

#ifndef __MINASN1_H__
#define __MINASN1_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define MINASN1_TAG_NULL                    0x00
#define MINASN1_TAG_BOOLEAN                 0x01
#define MINASN1_TAG_INTEGER                 0x02
#define MINASN1_TAG_BITSTRING               0x03
#define MINASN1_TAG_OCTETSTRING             0x04
#define MINASN1_TAG_OID                     0x06
#define MINASN1_TAG_UTC_TIME                0x17
#define MINASN1_TAG_GENERALIZED_TIME        0x18
#define MINASN1_TAG_CONSTRUCTED             0x20
#define MINASN1_TAG_SEQ                     0x30
#define MINASN1_TAG_SET                     0x31
#define MINASN1_TAG_CONTEXT_0               0x80
#define MINASN1_TAG_CONTEXT_1               0x81
#define MINASN1_TAG_CONTEXT_2               0x82
#define MINASN1_TAG_CONTEXT_3               0x83

#define MINASN1_TAG_CONSTRUCTED_CONTEXT_0   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_0)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_1   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_1)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_3   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_3)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define MINASN1_LENGTH_INDEFINITE               0x80
#define MINASN1_LENGTH_NULL                     0x00

#define MINASN1_LENGTH_TOO_LARGE                -1
#define MINASN1_INSUFFICIENT_DATA               -2
#define MINASN1_UNSUPPORTED_INDEFINITE_LENGTH   -3

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD cbBER
    );

//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );


typedef struct _MINASN1_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // Index into rgValueBlob of the returned value. Ignored if none of
    // the ASN1_PARSE_RETURN_*_BLOB_FLAG's is set in the above dwFlags.
    DWORD           dwIndex;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag.
    const BYTE      *rgbTag;
} MINASN1_EXTRACT_VALUE_PARA, *PMINASN1_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define MINASN1_MASK_VALUE_OP                   0xFF
#define MINASN1_STEP_OVER_VALUE_OP              1
#define MINASN1_OPTIONAL_STEP_OVER_VALUE_OP     2
#define MINASN1_STEP_INTO_VALUE_OP              3
#define MINASN1_OPTIONAL_STEP_INTO_VALUE_OP     4
#define MINASN1_STEP_OUT_VALUE_OP               5

#define MINASN1_RETURN_VALUE_BLOB_FLAG          0x80000000
#define MINASN1_RETURN_CONTENT_BLOB_FLAG        0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCertBlob[] is updated with pointer to and length of the following
//  fields in the encoded X.509 certificate.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including To Be Signed and Signature
#define MINASN1_CERT_ENCODED_IDX                1

// To Be Signed bytes
#define MINASN1_CERT_TO_BE_SIGNED_IDX           2

// Signature Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CERT_SIGN_ALGID_IDX             3

// Signature content bytes (BITSTRING)
#define MINASN1_CERT_SIGNATURE_IDX              4

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CERT_VERSION_IDX                5

// Serial Number content bytes (INTEGER)
#define MINASN1_CERT_SERIAL_NUMBER_IDX          6

// Issuer Name value bytes (ANY)
#define MINASN1_CERT_ISSUER_IDX                 7

// Not Before value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_BEFORE_IDX             8

// Not After value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_AFTER_IDX              9

// Subject Name value bytes (ANY)
#define MINASN1_CERT_SUBJECT_IDX                10

// Public Key Info value bytes (MinAsn1ParsePublicKeyInfo)
#define MINASN1_CERT_PUBKEY_INFO_IDX            11

// Issuer Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_ISSUER_UNIQUE_ID_IDX       12

// Subject Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX      13

// Extensions value bytes skipping "[3] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseExtensions)
#define MINASN1_CERT_EXTS_IDX                   14

#define MINASN1_CERT_BLOB_CNT                   15

LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgAlgIdBlob[] is updated with pointer to and length of the following
//  fields in the encoded Algorithm Identifier
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ALGID_ENCODED_IDX               1

// Object Identifier content bytes (OID)
#define MINASN1_ALGID_OID_IDX                   2

// Encoded parameters value bytes (OPTIONAL ANY)
#define MINASN1_ALGID_PARA_IDX                  3

#define MINASN1_ALGID_BLOB_CNT                  4


LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgPubKeyInfoBlob[] is updated with pointer to and length of the
//  following fields in the encoded Public Key Info.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_PUBKEY_INFO_ENCODED_IDX         1

// Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_PUBKEY_INFO_ALGID_IDX           2

// Public Key content bytes (BITSTRING, MinAsn1ParseRSAPublicKey)
#define MINASN1_PUBKEY_INFO_PUBKEY_IDX          3

#define MINASN1_PUBKEY_INFO_BLOB_CNT            4


LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgRSAPubKeyBlob[] is updated with pointer to and length of the
//  following fields in the encoded RSA Public Key.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_RSA_PUBKEY_ENCODED_IDX          1

// Modulus content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_MODULUS_IDX          2

// Exponent content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_EXPONENT_IDX         3

#define MINASN1_RSA_PUBKEY_BLOB_CNT             4

LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgExtBlob[][] is updated with pointer to and length of the
//  following fields in the encoded extension.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_EXT_ENCODED_IDX                 1

// Object Identifier content bytes (OID)
#define MINASN1_EXT_OID_IDX                     2

// Critical content bytes (OPTIONAL BOOLEAN, DEFAULT FALSE)
#define MINASN1_EXT_CRITICAL_IDX                3

// Value content bytes (OCTETSTRING)
#define MINASN1_EXT_VALUE_IDX                   4

#define MINASN1_EXT_BLOB_CNT                    5

LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_ENCODED_IDX                             1

// Outer Object Identfier content bytes (OID, should be "1.2.840.113549.1.7.2")
#define MINASN1_SIGNED_DATA_OUTER_OID_IDX                           2

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_VERSION_IDX                             3

// Set of Digest Algorithms value bytes (SET OF)
#define MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX                       4

// Inner Object Identifier content bytes (OID)
#define MINASN1_SIGNED_DATA_CONTENT_OID_IDX                         5

// Signed content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL ANY, MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINASN1_SIGNED_DATA_CONTENT_DATA_IDX                        6

// Certificates value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseSignedDataCertificates)
#define MINASN1_SIGNED_DATA_CERTS_IDX                               7

// CRL value bytes including "[2] IMPLICIT" tag (OPTIONAL)
#define MINASN1_SIGNED_DATA_CRLS_IDX                                8

// Encoded bytes including outer SET tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX                        9

// The following point to the first Signer Info fields (OPTIONAL)

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX                 10

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX                 11

// Issuer Name value bytes (ANY)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX                  12

// Serial Number content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX           13

// Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX            14

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX              15

// Encrypted Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX    16

// Encrypted digest content bytes (OCTET STRING)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX          17

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX            18

#define MINASN1_SIGNED_DATA_BLOB_CNT                                19

LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------

LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgAttrBlob[][] is updated with pointer to and length of the
//  following fields in the encoded attribute.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ATTR_ENCODED_IDX                1

// Object Identifier content bytes (OID)
#define MINASN1_ATTR_OID_IDX                    2

// Values value bytes (SET OF)
#define MINASN1_ATTR_VALUES_IDX                 3

// First Value's value bytes (OPTIONAL ANY)
#define MINASN1_ATTR_VALUE_IDX                  4

#define MINASN1_ATTR_BLOB_CNT                   5

LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLBlob[] is updated with pointer to and length of the following
//  fields in the encoded CTL.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_ENCODED_IDX                 1

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_VERSION_IDX                 2

// Subject usage value bytes (SEQUENCE OF OID)
#define MINASN1_CTL_SUBJECT_USAGE_IDX           3

// List Identifier content bytes (OPTIONAL OCTETSTRING)
#define MINASN1_CTL_LIST_ID_IDX                 4

// Sequence number content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_SEQUENCE_NUMBER_IDX         5

// This Update value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_THIS_UPDATE_IDX             6

// Next Update value bytes (OPTIONAL UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_NEXT_UPDATE_IDX             7

// Subject Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CTL_SUBJECT_ALGID_IDX           8

// Subjects value bytes (OPTIONAL, iterative MinAsn1ParseCTLSubject)
#define MINASN1_CTL_SUBJECTS_IDX                9

// Extensions value bytes skipping "[0] EXPLICIT" tag
// (OPTIONAL, MinAsn1ParseExtensions)
#define MINASN1_CTL_EXTS_IDX                    10

#define MINASN1_CTL_BLOB_CNT                    11

LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLSubjectBlob[][] is updated with pointer to and length of the
//  following fields in the encoded subject.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_SUBJECT_ENCODED_IDX         1

// Subject Identifier content bytes (OCTETSTRING)
#define MINASN1_CTL_SUBJECT_ID_IDX              2

// Attributes value bytes (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_CTL_SUBJECT_ATTRS_IDX           3

#define MINASN1_CTL_SUBJECT_BLOB_CNT            4

LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgIndirectDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded Indirect Data.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_INDIRECT_DATA_ENCODED_IDX       1

// Attribute Object Identifier content bytes (OID)
#define MINASN1_INDIRECT_DATA_ATTR_OID_IDX      2

// Attribute value bytes (OPTIONAL ANY)
#define MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX    3

// Digest Algorithm Identifier (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX  4

// Digest content bytes (OCTETSTRING)
#define MINASN1_INDIRECT_DATA_DIGEST_IDX        5

#define MINASN1_INDIRECT_DATA_BLOB_CNT          6

LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\fileutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       fileutil.h
//
//  Contents:   File utility functions used by the minimal cryptographic
//              APIs.
//
//  APIs: 
//              I_MinCryptMapFile
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_FILEUTIL_H__
#define __MINCRYPT_FILEUTIL_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <mincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  Maps the file into memory.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only READ access is required.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  *pFileBlob is updated with pointer to and length of the mapped file. For
//  MINCRYPT_FILE_NAME and MINCRYPT_FILE_HANDLE, UnmapViewOfFile() must
//  be called to free pFileBlob->pbData.
//
//  All accesses to this mapped memory must be within __try / __except's.
//--------------------------------------------------------------------------
LONG
WINAPI
I_MinCryptMapFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    OUT PCRYPT_DATA_BLOB pFileBlob
    );




#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_FILEUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\inc\mincrypt.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       mincrypt.h
//
//  Contents:   Minimal Cryptographic API Prototypes and Definitions
//
//              Contains cryptographic functions to verify PKCS #7 Signed Data
//              messages, X.509 certificate chains, Authenticode signed
//              files and file hashes in system catalogs.
//
//              These APIs rely on the APIs defined in minasn1.h for doing
//              the low level ASN.1 parsing.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              If the file name or file handle option is selected,
//              the following APIs will need to call the kernel32.dll APIs
//              to open, map and unmap files:
//                  MinCryptHashFile
//                  MinCryptVerifySignedFile
//              The following API will need to call kernel32.dll and
//              wintrust.dll APIs to find, open, map and unmap files:
//                  MinCryptVerifyHashInSystemCatalogs
//              Except for the calls in the above APIs,
//              no calls to APIs in other DLLs.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//  APIs: 
//              MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//              MinCryptVerifyCertificate
//              MinCryptVerifySignedData
//              MinCryptHashFile
//              MinCryptVerifySignedFile
//              MinCryptVerifyHashInSystemCatalogs
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_H__
#define __MINCRYPT_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <minasn1.h>

#ifdef __cplusplus
extern "C" {
#endif



#define MINCRYPT_MAX_HASH_LEN               20
#define MINCRYPT_SHA1_HASH_LEN              20
#define MINCRYPT_MD5_HASH_LEN               16
#define MINCRYPT_MD2_HASH_LEN               16


//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    );

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signatures are supported.
//
//  Only MD2, MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    );



//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Content Object Identifier content bytes (OID)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX                    0

// Content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX                   1

// Signer certificate's encoded bytes (MinAsn1ParseCertificate)
#define MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX                    2

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX                     3

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX                   4

#define MINCRYPT_VER_SIGNED_DATA_BLOB_CNT                           5

LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  File Type Definitions
//
//  Specifies the type of the "const VOID *pvFile" parameter
//--------------------------------------------------------------------------

// pvFile - LPCWSTR pwszFilename
#define MINCRYPT_FILE_NAME          1

// pvFile - HANDLE hFile
#define MINCRYPT_FILE_HANDLE        2

// pvFile - PCRYPT_DATA_BLOB pFileBlob
#define MINCRYPT_FILE_BLOB          3


//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgAttrBlob[cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );

//+-------------------------------------------------------------------------
//  Verifies the hashes in the system catalogs.
//
//  Iterates through the hashes and attempts to find the system catalog
//  containing it. If found, the system catalog file is verified as a
//  PKCS #7 Signed Data message with its signer cert verified up to a baked
//  in root.
//
//  The following mscat32.dll APIs are called to find the system catalog file:
//      CryptCATAdminAcquireContext
//      CryptCATAdminReleaseContext
//      CryptCATAdminEnumCatalogFromHash
//      CryptCATAdminReleaseCatalogContext
//      CryptCATCatalogInfoFromContext
//
//  If the hash was successfully verified, rglErr[] is set to ERROR_SUCCESS.
//  Otherwise, rglErr[] is set to a nonzero error code.
//
//  The caller can request one or more catalog subject attribute,
//  extension or signer authenticated attribute values to be returned for
//  each hash.  The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to a 2 dimensional array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cHash * cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. This may
//  be returned for unsuccessful rglErr[] values. Otherwise,
//  a nonzero error code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyHashInSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglErr[],

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgrgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );
    



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\vercat.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       vercat.cpp
//
//  Contents:   Minimal Cryptographic functions to verify hashes in the
//              system catalogs.
//
//  Functions:  MinCryptVerifyHashInSystemCatalogs
//
//  History:    23-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <softpub.h>
#include <mscat.h>

// #define szOID_CTL               "1.3.6.1.4.1.311.10.1"
const BYTE rgbOID_CTL[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01};

// #define SPC_INDIRECT_DATA_OBJID "1.3.6.1.4.1.311.2.1.4"
static const BYTE rgbSPC_INDIRECT_DATA_OBJID[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04};
const CRYPT_DER_BLOB IndirectDataEncodedOIDBlob = {
        sizeof(rgbSPC_INDIRECT_DATA_OBJID), 
        (BYTE *) rgbSPC_INDIRECT_DATA_OBJID
};

#define MAX_CAT_FILE_CNT            10
#define MAX_CAT_ATTR_CNT            10
#define MAX_CAT_EXT_CNT             10

typedef struct _MAP_CAT_INFO {
    LONG                lErr;
    CRYPT_DATA_BLOB     FileBlob;
    CRYPT_DER_BLOB      CTLSubjectsValueBlob;
    CRYPT_DER_BLOB      CTLExtsValueBlob;
    CRYPT_DER_BLOB      SignerAuthAttrsValueBlob;
} MAP_CAT_INFO, *PMAP_CAT_INFO;

#define MAP_CAT_IDX_MASK        0x0000FFFF
#define MAP_CAT_MULTIPLE_FLAG   0x00010000


LONG
WINAPI
I_GetAndMapSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglHashMapCatIdx[],
    OUT DWORD *pcMapCatInfo,
    OUT MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT]
    )
{
    LONG lErr;
    HCATADMIN hCatAdmin = NULL;
    const GUID guidCatRoot = DRIVER_ACTION_VERIFY;
    DWORD cMapCatInfo = 0;
    DWORD cCatInfo = 0;
    CATALOG_INFO rgCatInfo[MAX_CAT_FILE_CNT];
    LONG rglMapCatIdx[MAX_CAT_FILE_CNT];
    DWORD iHash;

    if (!(CryptCATAdminAcquireContext(&hCatAdmin, &guidCatRoot, 0)))
        goto CryptCATAdminAcquireContextError;

    for (iHash = 0; iHash < cHash; iHash++) {
        HCATINFO hCatInfo = NULL;

        // Set index to indicate no catalog file
        rglHashMapCatIdx[iHash] = -1;

        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin,
                    rgHashBlob[iHash].pbData, rgHashBlob[iHash].cbData,
                    0, &hCatInfo)) {
            CATALOG_INFO CatInfo;
            LONG lMapCatIdx;
            DWORD iCatInfo;

            memset(&CatInfo, 0, sizeof(CATALOG_INFO));
            CatInfo.cbStruct = sizeof(CATALOG_INFO);

            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)))
                continue;

            // Ensure we have a NULL terminated string
            CatInfo.wszCatalogFile[
                sizeof(CatInfo.wszCatalogFile)/sizeof(WCHAR) - 1] = L'\0';

            // Check if we already encountered this catalog file
            for (iCatInfo = 0; iCatInfo < cCatInfo; iCatInfo++) {
                if (0 == _wcsicmp(CatInfo.wszCatalogFile,
                        rgCatInfo[iCatInfo].wszCatalogFile))
                    break;
            }

            if (iCatInfo >= cCatInfo) {
                // Attempt to map this new catalog file

                if (cCatInfo >= MAX_CAT_FILE_CNT)
                    continue;

                wcscpy(rgCatInfo[cCatInfo].wszCatalogFile,
                    CatInfo.wszCatalogFile);

                memset(&rgMapCatInfo[cMapCatInfo], 0, sizeof(MAP_CAT_INFO));

                if (ERROR_SUCCESS == I_MinCryptMapFile(
                        MINCRYPT_FILE_NAME,
                        (const VOID *) CatInfo.wszCatalogFile,
                        &rgMapCatInfo[cMapCatInfo].FileBlob
                        ))
                    rglMapCatIdx[cCatInfo] = cMapCatInfo++;
                else
                    rglMapCatIdx[cCatInfo] = -1;

                cCatInfo++;
                assert(iCatInfo < cCatInfo);
            }

            lMapCatIdx = rglMapCatIdx[iCatInfo];

            if (0 > rglHashMapCatIdx[iHash])
                rglHashMapCatIdx[iHash] = lMapCatIdx;
            else if (0 <= lMapCatIdx)
                rglHashMapCatIdx[iHash] |= MAP_CAT_MULTIPLE_FLAG;
        }
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    *pcMapCatInfo = cMapCatInfo;
    if (hCatAdmin)
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    return lErr;

CryptCATAdminAcquireContextError:
    lErr = GetLastError();
    if (ERROR_SUCCESS == lErr)
        lErr = E_UNEXPECTED;
    goto CommonReturn;
}


VOID
WINAPI
I_VerifyMappedCatalog(
    IN OUT PMAP_CAT_INFO pMapCatInfo
    )
{
    LONG lErr;
    CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
    CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT];

    __try {
        lErr = MinCryptVerifySignedData(
            pMapCatInfo->FileBlob.pbData,
            pMapCatInfo->FileBlob.cbData,
            rgVerSignedDataBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // The data content should be a CTL
        if (sizeof(rgbOID_CTL) !=
                rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
                0 != memcmp(rgbOID_CTL,
                        rgVerSignedDataBlob[
                            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].pbData,
                        sizeof(rgbOID_CTL)))
            goto NotCTLOID;

        if (0 >= MinAsn1ParseCTL(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX],
                rgCTLBlob
                ))
            goto ParseCTLError;

    
        pMapCatInfo->CTLSubjectsValueBlob =
            rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX];
        pMapCatInfo->CTLExtsValueBlob =
            rgCTLBlob[MINASN1_CTL_EXTS_IDX];
        pMapCatInfo->SignerAuthAttrsValueBlob =
            rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX];

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    pMapCatInfo->lErr = lErr;
    return;

ErrorReturn:
    goto CommonReturn;

NotCTLOID:
ParseCTLError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

}

VOID
WINAPI
I_VerifyMappedSystemCatalogs(
    IN DWORD cMapCatInfo,
    IN OUT MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT]
    )
{
    DWORD i;

    for (i = 0; i < cMapCatInfo; i++)
        I_VerifyMappedCatalog(&rgMapCatInfo[i]);
}


LONG
WINAPI
I_FindHashInCTLSubjects(
    IN ALG_ID HashAlgId,
    IN PCRYPT_HASH_BLOB pHashBlob,
    IN PCRYPT_DER_BLOB pCTLSubjectsValueBlob,
    OUT PCRYPT_DER_BLOB pCTLSubjectAttrsValueBlob
    )
{
    DWORD cbEncoded;
    const BYTE *pbEncoded;

    // Advance past the outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pCTLSubjectsValueBlob->pbData,
            pCTLSubjectsValueBlob->cbData,
            &cbEncoded,
            &pbEncoded
            ))
        goto NoOrInvalidSubjects;

    while (cbEncoded) {
        // Loop through the encoded subjects until we have a hash match
        // with the digest octets in the IndirectData attribute.

        LONG cbSubject;
        CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT];
        DWORD cAttr;
        CRYPT_DER_BLOB rgrgAttrBlob[MAX_CAT_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];

        cbSubject = MinAsn1ParseCTLSubject(
            pbEncoded,
            cbEncoded,
            rgCTLSubjectBlob
            );
        if (0 >= cbSubject)
            goto InvalidSubject;
        
        cAttr = MAX_CAT_ATTR_CNT;
        if (0 < MinAsn1ParseAttributes(
                    &rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ATTRS_IDX],
                    &cAttr,
                    rgrgAttrBlob
                    )) {
            PCRYPT_DER_BLOB rgIndirectDataAttrBlob;
            CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT];

            rgIndirectDataAttrBlob = MinAsn1FindAttribute(
                (PCRYPT_DER_BLOB) &IndirectDataEncodedOIDBlob,
                cAttr,
                rgrgAttrBlob
                );

            if (rgIndirectDataAttrBlob &&
                    0 < MinAsn1ParseIndirectData(
                            &rgIndirectDataAttrBlob[MINASN1_ATTR_VALUE_IDX],
                            rgIndirectDataBlob)) {
                if (pHashBlob->cbData ==
                        rgIndirectDataBlob[
                            MINASN1_INDIRECT_DATA_DIGEST_IDX].cbData
                                    &&
                        0 == memcmp(pHashBlob->pbData,
                                rgIndirectDataBlob[
                                    MINASN1_INDIRECT_DATA_DIGEST_IDX].pbData,
                                pHashBlob->cbData)) {

                    *pCTLSubjectAttrsValueBlob =
                        rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ATTRS_IDX];
                    return ERROR_SUCCESS;
                }
            }
        }

        pbEncoded += cbSubject;
        cbEncoded -= cbSubject;
    }

NoOrInvalidSubjects:
InvalidSubject:
    pCTLSubjectAttrsValueBlob->pbData = NULL;
    pCTLSubjectAttrsValueBlob->cbData = 0;

    return ERROR_FILE_NOT_FOUND;
}


LONG
WINAPI
I_FindHashInMappedSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN PCRYPT_HASH_BLOB pHashBlob,
    IN DWORD cMapCatInfo,
    IN MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT],
    IN OUT LONG *plMapCatIdx,
    OUT PCRYPT_DER_BLOB pCTLSubjectAttrsValueBlob
    )
{
    LONG lErr;
    LONG lMapCatIdx = *plMapCatIdx;
    BOOL fMultiple = FALSE;

    if (0 > lMapCatIdx)
        goto NotInCatalog;
    if (lMapCatIdx & MAP_CAT_MULTIPLE_FLAG)
        fMultiple = TRUE;
    else
        fMultiple = FALSE;
    lMapCatIdx &= MAP_CAT_IDX_MASK;

    assert((DWORD) lMapCatIdx < cMapCatInfo);

    if (ERROR_SUCCESS == rgMapCatInfo[lMapCatIdx].lErr
                        &&
        ERROR_SUCCESS == I_FindHashInCTLSubjects(
            HashAlgId,
            pHashBlob,
            &rgMapCatInfo[lMapCatIdx].CTLSubjectsValueBlob,
            pCTLSubjectAttrsValueBlob
            ))
        goto SuccessReturn;

    if (fMultiple) {
        DWORD i;
        for (i = 0; i < cMapCatInfo; i++) {
            if ((DWORD) lMapCatIdx == i)
                continue;

            if (ERROR_SUCCESS == rgMapCatInfo[i].lErr
                                &&
                ERROR_SUCCESS == I_FindHashInCTLSubjects(
                    HashAlgId,
                    pHashBlob,
                    &rgMapCatInfo[i].CTLSubjectsValueBlob,
                    pCTLSubjectAttrsValueBlob
                    )) {
                lMapCatIdx = i;
                goto SuccessReturn;
            }
        }
    }

NotInCatalog:
    lErr = ERROR_FILE_NOT_FOUND;
    lMapCatIdx = -1;
    pCTLSubjectAttrsValueBlob->pbData = NULL;
    pCTLSubjectAttrsValueBlob->cbData = 0;
    goto CommonReturn;

SuccessReturn:
    lErr = ERROR_SUCCESS;
CommonReturn:
    *plMapCatIdx = lMapCatIdx;
    return lErr;
}


VOID
WINAPI
I_GetHashAttributes(
    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],

    IN PCRYPT_DER_BLOB pCTLSubjectAttrsValueBlob,
    IN PCRYPT_DER_BLOB pCTLExtsValueBlob,
    IN PCRYPT_DER_BLOB pSignerAuthAttrsValueBlob,

    IN OUT OPTIONAL CRYPT_DER_BLOB rgAttrValueBlob[],
    IN OUT LONG *plRemainExtra,
    IN OUT BYTE **ppbExtra
    )
{
    DWORD cSubjectAttr;
    CRYPT_DER_BLOB rgrgSubjectAttrBlob[MAX_CAT_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    DWORD cExt;
    CRYPT_DER_BLOB rgrgExtBlob[MAX_CAT_EXT_CNT][MINASN1_EXT_BLOB_CNT];
    DWORD cSignerAttr;
    CRYPT_DER_BLOB rgrgSignerAttrBlob[MAX_CAT_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];

    DWORD i;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;

    // Parse the attributes and extensions
    cSubjectAttr = MAX_CAT_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pCTLSubjectAttrsValueBlob,
            &cSubjectAttr,
            rgrgSubjectAttrBlob))
        cSubjectAttr = 0;

    cExt = MAX_CAT_EXT_CNT;
    if (0 >= MinAsn1ParseExtensions(
            pCTLExtsValueBlob,
            &cExt,
            rgrgExtBlob))
        cExt = 0;

    cSignerAttr = MAX_CAT_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pSignerAuthAttrsValueBlob,
            &cSignerAttr,
            rgrgSignerAttrBlob))
        cSignerAttr = 0;

    for (i = 0; i < cAttrOID; i++) {
        PCRYPT_DER_BLOB rgFindAttrBlob;
        PCRYPT_DER_BLOB rgFindExtBlob;
        PCRYPT_DER_BLOB pFindAttrValue; 

        if (rgFindAttrBlob = MinAsn1FindAttribute(
                &rgAttrEncodedOIDBlob[i],
                cSubjectAttr,
                rgrgSubjectAttrBlob
                ))
            pFindAttrValue = &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
        else if (rgFindExtBlob = MinAsn1FindExtension(
                &rgAttrEncodedOIDBlob[i],
                cExt,
                rgrgExtBlob
                ))
            pFindAttrValue = &rgFindExtBlob[MINASN1_EXT_VALUE_IDX];
        else if (rgFindAttrBlob = MinAsn1FindAttribute(
                &rgAttrEncodedOIDBlob[i],
                cSignerAttr,
                rgrgSignerAttrBlob
                ))
            pFindAttrValue = &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
        else
            pFindAttrValue = NULL;

        if (pFindAttrValue && 0 != pFindAttrValue->cbData) {
            const BYTE *pbFindValue = pFindAttrValue->pbData;
            DWORD cbFindValue = pFindAttrValue->cbData;

            lRemainExtra -= cbFindValue;
            if (0 <= lRemainExtra) {
                rgAttrValueBlob[i].pbData = pbExtra;
                rgAttrValueBlob[i].cbData = cbFindValue;

                memcpy(pbExtra, pbFindValue, cbFindValue);
                pbExtra += cbFindValue;
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}




//+-------------------------------------------------------------------------
//  Verifies the hashes in the system catalogs.
//
//  Iterates through the hashes and attempts to find the system catalog
//  containing it. If found, the system catalog file is verified as a
//  PKCS #7 Signed Data message with its signer cert verified up to a baked
//  in root.
//
//  The following mscat32.dll APIs are called to find the system catalog file:
//      CryptCATAdminAcquireContext
//      CryptCATAdminReleaseContext
//      CryptCATAdminEnumCatalogFromHash
//      CryptCATAdminReleaseCatalogContext
//      CryptCATCatalogInfoFromContext
//
//  If the hash was successfully verified, rglErr[] is set to ERROR_SUCCESS.
//  Otherwise, rglErr[] is set to a nonzero error code.
//
//  The caller can request one or more catalog subject attribute,
//  extension or signer authenticated attribute values to be returned for
//  each hash.  The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to a 2 dimensional array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID]).
//  The caller should make every attempt to allow for a
//  single pass call. The necessary memory size is:
//      (cHash * cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. This may
//  be returned for unsuccessful rglErr[] values. Otherwise,
//  a nonzero error code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyHashInSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglErr[],

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgrgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    )
{
    LONG lErr;
    DWORD cMapCatInfo = 0;
    MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT];
    DWORD iMapCat;

    //**********************************************************************
    //  WARNING!!!!
    //
    //  The following function calls into other DLLs such as, kernel32.dll
    //  and wintrust.dll to find and map the system catalog files. The input
    //  array of hashes must be protected!!
    //
    //  After returning we won't be calling into other DLLs until
    //  UnmapViewOfFile is called in CommonReturn.
    //  
    //**********************************************************************

    // Note, rglErr[] is overloaded and also used to contain the indices
    // into rgMapCatInfo for each corresponding hash.
    lErr = I_GetAndMapSystemCatalogs(
            HashAlgId,
            cHash,
            rgHashBlob,
            rglErr,
            &cMapCatInfo,
            rgMapCatInfo
            );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;

    __try {
        DWORD cbAttr = 0;
        LONG lRemainExtra = 0;
        BYTE *pbExtra = NULL;
        DWORD iHash;

        if (0 != cAttrOID && 0 != cHash) {
            if (rgrgAttrValueBlob)
                cbAttr = *pcbAttr;

            lRemainExtra = cbAttr - sizeof(CRYPT_DER_BLOB) * cAttrOID * cHash;
            if (0 <= lRemainExtra) {
                memset(rgrgAttrValueBlob, 0,
                    sizeof(CRYPT_DER_BLOB) * cAttrOID * cHash);
                pbExtra = (BYTE *) &rgrgAttrValueBlob[cAttrOID * cHash];
            }
        }

        I_VerifyMappedSystemCatalogs(
            cMapCatInfo,
            rgMapCatInfo
            );

        for (iHash = 0; iHash < cHash; iHash++) {
            LONG lMapCatIdx = rglErr[iHash];
            CRYPT_DER_BLOB CTLSubjectAttrsValueBlob;

            rglErr[iHash] = I_FindHashInMappedSystemCatalogs(
                HashAlgId,
                &rgHashBlob[iHash],
                cMapCatInfo,
                rgMapCatInfo,
                &lMapCatIdx,
                &CTLSubjectAttrsValueBlob
                );

            if (0 != cAttrOID && ERROR_SUCCESS == rglErr[iHash]) {
                assert(0 <= lMapCatIdx && (DWORD) lMapCatIdx < cMapCatInfo);
                I_GetHashAttributes(
                    cAttrOID,
                    rgAttrEncodedOIDBlob,
                    &CTLSubjectAttrsValueBlob,
                    &rgMapCatInfo[lMapCatIdx].CTLExtsValueBlob,
                    &rgMapCatInfo[lMapCatIdx].SignerAuthAttrsValueBlob,
                    0 <= lRemainExtra ?
                        &rgrgAttrValueBlob[cAttrOID * iHash] : NULL,
                    &lRemainExtra,
                    &pbExtra
                    );
            }
        }

        if (0 != cAttrOID && 0 != cHash) {
            if (0 <= lRemainExtra)
                *pcbAttr = cbAttr - (DWORD) lRemainExtra;
            else {
                *pcbAttr = cbAttr + (DWORD) -lRemainExtra;
                goto InsufficientBuffer;
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }
    lErr = ERROR_SUCCESS;

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr and the return error for each hash in rglErr[] must be protected.
    //  
    //**********************************************************************
    for (iMapCat = 0; iMapCat < cMapCatInfo; iMapCat++)
        UnmapViewOfFile(rgMapCatInfo[iMapCat].FileBlob.pbData);

    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    if (ERROR_INSUFFICIENT_BUFFER == lErr)
        // This error can only be set when we determine that the attribute
        // buffer isn't big enough.
        lErr = E_UNEXPECTED;
    goto CommonReturn;

InsufficientBuffer:
    lErr = ERROR_INSUFFICIENT_BUFFER;
    // Don't goto ErrorReturn. It explicitly checks that noone else can
    // set this error
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\imagehack.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       imagehack.h
//
//  Contents:   "Hacked" version of the imagehlp APIs
//
//              Contains a "stripped" down subset of the imagehlp functionality
//              necessary to hash a PE file and to extract the 
//              PKCS #7 Signed Data message.
//
//  APIs:       imagehack_ImageGetDigestStream
//              imagehack_ImageGetCertificateData
//
//----------------------------------------------------------------------------

#ifndef __IMAGEHACK_H__
#define __IMAGEHACK_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <imagehlp.h>
#include <wintrust.h>

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
imagehack_ImageGetDigestStream(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   DigestLevel,                    // ignored
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    );

BOOL
WINAPI
imagehack_ImageGetCertificateData(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   CertificateIndex,               // should be 0
    OUT     LPWIN_CERTIFICATE * Certificate
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __IMAGEHACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\verfile.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verfile.cpp
//
//  Contents:   Minimal Cryptographic functions to hash files and verify
//              Authenticode signed files.
//              message
//
//  Functions:  MinCryptHashFile
//              MinCryptVerifySignedFile
//
//  History:    21-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <md5.h>
#include <sha.h>

#define PE_EXE_HEADER_TAG       "MZ"
#define MIN_PE_FILE_LEN         4

#define MAX_SIGNED_FILE_AUTH_ATTR_CNT   10

typedef struct _DIGEST_DATA {
    ALG_ID      AlgId;
    void        *pvSHA1orMD5Ctx;
} DIGEST_DATA, *PDIGEST_DATA;

// #define SPC_INDIRECT_DATA_OBJID "1.3.6.1.4.1.311.2.1.4"
const BYTE rgbSPC_INDIRECT_DATA_OBJID[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04};

BOOL
WINAPI
I_DigestFunction(
    DIGEST_HANDLE refdata,
    PBYTE pbData,
    DWORD cbData
    )
{
    PDIGEST_DATA pDigestData = (PDIGEST_DATA) refdata;

    switch (pDigestData->AlgId)
    {
        case CALG_MD5:
            MD5Update((MD5_CTX *)pDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);

        case CALG_SHA1:
            A_SHAUpdate((A_SHA_CTX *)pDigestData->pvSHA1orMD5Ctx, pbData,
                cbData);
            return(TRUE);
    }
    return FALSE;
}

BOOL
WINAPI
I_IsNtPe32File(
    IN PCRYPT_DATA_BLOB pFileBlob
    )
{
    const BYTE *pbFile = pFileBlob->pbData;
    DWORD cbFile = pFileBlob->cbData;

    if (MIN_PE_FILE_LEN > cbFile)
        return FALSE;

    if (0 != memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)))
        return FALSE;

    //  Make sure it is a 32 bit PE
    if (sizeof(IMAGE_DOS_HEADER) > cbFile)
        return FALSE;
    else {
        IMAGE_DOS_HEADER *pDosHead = (IMAGE_DOS_HEADER *) pbFile;

        if (pDosHead->e_magic != IMAGE_DOS_SIGNATURE)
            return FALSE;

        if (cbFile < (sizeof(IMAGE_DOS_HEADER) + pDosHead->e_lfanew))
            return FALSE;
        else {
            IMAGE_NT_HEADERS *pNTHead =
                (IMAGE_NT_HEADERS *)((ULONG_PTR)pDosHead + pDosHead->e_lfanew);

            if (pNTHead->Signature != IMAGE_NT_SIGNATURE)
                return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    )
{
    LONG lErr;
    CRYPT_DATA_BLOB FileBlob = {0, NULL};
    DIGEST_DATA DigestData;
    A_SHA_CTX ShaCtx;
    MD5_CTX Md5Ctx;

    __try {
        lErr = I_MinCryptMapFile(
            dwFileType,
            pvFile,
            &FileBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!I_IsNtPe32File(&FileBlob)) {
            // Hash the entire file
            lErr = MinCryptHashMemory(
                HashAlgId,
                1,              // cBlob
                &FileBlob,
                rgbHash,
                pcbHash
                );
            goto CommonReturn;
        }

        DigestData.AlgId = HashAlgId;
        switch (HashAlgId) {
            case CALG_MD5:
                DigestData.pvSHA1orMD5Ctx = &Md5Ctx;
                MD5Init(&Md5Ctx);
                break;

            case CALG_SHA1:
                DigestData.pvSHA1orMD5Ctx = &ShaCtx;
                A_SHAInit(&ShaCtx);
                break;

            default:
                goto InvalidHashAlgId;
        }

        if (!imagehack_ImageGetDigestStream(
                &FileBlob,
                0,                  // DigestLevel, ignored
                I_DigestFunction,
                &DigestData
                ))
            goto DigestStreamError;
        else {
            DWORD dwPadBeforeCerts;

            dwPadBeforeCerts = (FileBlob.cbData + 7) & ~7;
            dwPadBeforeCerts -= FileBlob.cbData;

            if (0 < dwPadBeforeCerts) {
                BYTE rgb[8];
                // imagehlp put nulls before the signature!
                memset(rgb, 0x00, dwPadBeforeCerts);

                if (!I_DigestFunction(&DigestData, rgb, dwPadBeforeCerts))
                    goto DigestFunctionError;
            }
        }

        switch (HashAlgId) {
            case CALG_MD5:
                MD5Final(&Md5Ctx);
                memcpy(rgbHash, Md5Ctx.digest, MD5DIGESTLEN);
                *pcbHash = MINCRYPT_MD5_HASH_LEN;
                break;

            case CALG_SHA1:
                A_SHAFinal(&ShaCtx, rgbHash);
                *pcbHash = MINCRYPT_SHA1_HASH_LEN;
                break;

            default:
                goto InvalidHashAlgId;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr and the return hash in rgbHash[] must be protected.
    //  
    //**********************************************************************
    if (MINCRYPT_FILE_BLOB != dwFileType && NULL != FileBlob.pbData)
        UnmapViewOfFile(FileBlob.pbData);
    return lErr;

ErrorReturn:
    *pcbHash = 0;
    goto CommonReturn;

InvalidHashAlgId:
    lErr = NTE_BAD_ALGID;
    goto ErrorReturn;

DigestStreamError:
DigestFunctionError:
    lErr = NTE_BAD_HASH;
    goto ErrorReturn;
}


// Only called when cAttrOID != 0
LONG
WINAPI
I_GetAuthAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN DWORD cAttrOID,
    IN CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT DWORD *pcbAttr
    )
{
    LONG lErr;
    DWORD i;
    LONG lRemainExtra;
    BYTE *pbExtra;
    DWORD cbAttr;

    CRYPT_DER_BLOB rgrgAttrBlob[MAX_SIGNED_FILE_AUTH_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    DWORD cAttr;

    assert(0 != cAttrOID);

    if (rgAttrValueBlob)
        cbAttr = *pcbAttr;
    else
        cbAttr = 0;

    lRemainExtra = cbAttr - sizeof(CRYPT_DER_BLOB) * cAttrOID;
    if (0 <= lRemainExtra) {
        memset(rgAttrValueBlob, 0, sizeof(CRYPT_DER_BLOB) * cAttrOID);
        pbExtra = (BYTE *) &rgAttrValueBlob[cAttrOID];
    } else
        pbExtra = NULL;

    // Parse the authenticated attributes
    cAttr = MAX_SIGNED_FILE_AUTH_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob))
        cAttr = 0;

    for (i = 0; i < cAttrOID; i++) {
        PCRYPT_DER_BLOB rgFindAttrBlob;

        rgFindAttrBlob = MinAsn1FindAttribute(
            &rgAttrEncodedOIDBlob[i],
            cAttr,
            rgrgAttrBlob
            );
        if (rgFindAttrBlob) {
            PCRYPT_DER_BLOB pFindAttrValue =
                &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
            const BYTE *pbFindValue = pFindAttrValue->pbData;
            DWORD cbFindValue = pFindAttrValue->cbData;

            if (0 < cbFindValue) {
                lRemainExtra -= cbFindValue;
                if (0 <= lRemainExtra) {
                    rgAttrValueBlob[i].pbData = pbExtra;
                    rgAttrValueBlob[i].cbData = cbFindValue;

                    memcpy(pbExtra, pbFindValue, cbFindValue);
                    pbExtra += cbFindValue;
                }
            }
        }
    }

    if (0 <= lRemainExtra) {
        *pcbAttr = cbAttr - (DWORD) lRemainExtra;
        lErr = ERROR_SUCCESS;
    } else {
        *pcbAttr = cbAttr + (DWORD) -lRemainExtra;
        lErr = ERROR_INSUFFICIENT_BUFFER;
    }

    return lErr;
}

//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values. The caller should make every attempt to allow for a
//  single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For the multi-valued attributes, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    )
{
    LONG lErr;
    CRYPT_DATA_BLOB FileBlob = {0, NULL};

    __try {
        LPWIN_CERTIFICATE pCertHdr = NULL;
        const BYTE *pbEncodedSignedData;
        DWORD cbEncodedSignedData;
        CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
        CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT];
        ALG_ID HashAlgId;
        BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
        DWORD cbHash;

        lErr = I_MinCryptMapFile(
            dwFileType,
            pvFile,
            &FileBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!I_IsNtPe32File(&FileBlob))
            goto NotNtPe32File;

        if (!imagehack_ImageGetCertificateData(
                &FileBlob,
                0,              // CertificateIndex
                &pCertHdr
                ))
            goto NoSignature;

        if (WIN_CERT_REVISION_2_0 != pCertHdr->wRevision ||
                WIN_CERT_TYPE_PKCS_SIGNED_DATA != pCertHdr->wCertificateType)
            goto UnsupportedSignature;

        if (offsetof(WIN_CERTIFICATE, bCertificate) > pCertHdr->dwLength)
            goto InvalidSignature;

        cbEncodedSignedData = pCertHdr->dwLength -
            offsetof(WIN_CERTIFICATE, bCertificate);
        pbEncodedSignedData = pCertHdr->bCertificate;

        lErr = MinCryptVerifySignedData(
            pbEncodedSignedData,
            cbEncodedSignedData,
            rgVerSignedDataBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // The data content should be Indirect Data
        if (sizeof(rgbSPC_INDIRECT_DATA_OBJID) !=
                rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
                0 != memcmp(rgbSPC_INDIRECT_DATA_OBJID,
                        rgVerSignedDataBlob[
                            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].pbData,
                        sizeof(rgbSPC_INDIRECT_DATA_OBJID)))
            goto NotIndirectDataOID;

        if (0 >= MinAsn1ParseIndirectData(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX],
                rgIndirectDataBlob
                ))
            goto ParseIndirectDataError;

        HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
            &rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX]
            );
        if (0 == HashAlgId)
            goto UnknownHashAlgId;

        lErr = MinCryptHashFile(
            MINCRYPT_FILE_BLOB,
            (const VOID *) &FileBlob,
            HashAlgId,
            rgbHash,
            &cbHash
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // Check that the hash in the indirect data matches the file hash
        if (cbHash !=
                rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_IDX].cbData
                        ||
                0 != memcmp(rgbHash,
                    rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_IDX].pbData,
                    cbHash))
            goto InvalidFileHash;

        if (cAttrOID)
            lErr = I_GetAuthAttributes(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX],
                cAttrOID,
                rgAttrEncodedOIDBlob,
                rgAttrValueBlob,
                pcbAttr
                );
        else
            lErr = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr must be protected.
    //  
    //**********************************************************************
    if (MINCRYPT_FILE_BLOB != dwFileType && NULL != FileBlob.pbData)
        UnmapViewOfFile(FileBlob.pbData);
    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    if (ERROR_INSUFFICIENT_BUFFER == lErr)
        // This error can only be set when we determine that the attribute
        // buffer isn't big enough.
        lErr = E_UNEXPECTED;
    goto CommonReturn;

NotNtPe32File:
    lErr = ERROR_NOT_SUPPORTED;
    goto ErrorReturn;

NoSignature:
UnsupportedSignature:
InvalidSignature:
    lErr = TRUST_E_NOSIGNATURE;
    goto ErrorReturn;

NotIndirectDataOID:
ParseIndirectDataError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto ErrorReturn;

InvalidFileHash:
    lErr = CRYPT_E_HASH_VALUE;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\imagehack.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       imagehack.cpp
//
//  Contents:   "Hacked" version of the imagehlp APIs
//
//              Contains a "stripped" down subset of the imagehlp functionality
//              necessary to hash a PE file and to extract the 
//              PKCS #7 Signed Data message.
//
//              Most of this file is derived from the following 2 files:
//                  \nt\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp
//                  \nt\sdktools\debuggers\imagehlp\dice.cxx
//
//  Functions:  imagehack_ImageGetDigestStream
//              imagehack_ImageGetCertificateData
//
//  History:    20-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

//+=========================================================================
//  The following was taken from the following file:
//      \nt\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp
//-=========================================================================

__inline DWORD AlignIt (DWORD Value, DWORD Alignment) { return (Value + (Alignment - 1)) & ~(Alignment -1); }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

BOOL
I_CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    BOOL fRC = FALSE;

    // Everything is mapped. Now check the image and find nt image headers

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            __leave;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                __leave;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)LoadedImage->FileHeader <
                    (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                __leave;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)DosHeader;
        }

        if ( LoadedImage->FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            __leave;
        } else {
            LoadedImage->fDOSImage = FALSE;
        }

        // No optional header indicates an object...

        if ( !LoadedImage->FileHeader->FileHeader.SizeOfOptionalHeader ) {
            __leave;
        }

        // Check for versions < 2.50

        if ( LoadedImage->FileHeader->OptionalHeader.MajorLinkerVersion < 3 &&
             LoadedImage->FileHeader->OptionalHeader.MinorLinkerVersion < 5 ) {
            __leave;
        }

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->NumberOfSections = LoadedImage->FileHeader->FileHeader.NumberOfSections;
        LoadedImage->Sections = IMAGE_FIRST_SECTION(LoadedImage->FileHeader);
        fRC = TRUE;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) { }

    return fRC;
}

BOOL
I_MapIt(
    PCRYPT_DATA_BLOB pFileBlob,
    PLOADED_IMAGE LoadedImage
    )
{

    LoadedImage->hFile = INVALID_HANDLE_VALUE;
    LoadedImage->MappedAddress = pFileBlob->pbData;
    LoadedImage->SizeOfImage = pFileBlob->cbData;

    if (!LoadedImage->MappedAddress) {
        return (FALSE);
    }

    if (!I_CalculateImagePtrs(LoadedImage)) {
        return(FALSE);
    }


    return(TRUE);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = (EXCLUDE_RANGE *)I_MemAlloc(sizeof(EXCLUDE_RANGE));

            if(m_ExRange)
                memset(m_ExRange, 0x00, sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp)
            {
                I_MemFree(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            I_MemFree(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size
    )
{
    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = (EXCLUDE_RANGE *) I_MemAlloc(sizeof(EXCLUDE_RANGE));

    if(pTmp)
    {
        pTmp->Next = pExRange->Next;
        pTmp->Offset = (PBYTE)Offset;
        pTmp->Size = Size;
        pExRange->Next = pTmp;
    }

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc = FALSE;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


#pragma warning (push)
// error C4509: nonstandard extension used: 'imagehack_ImageGetDigestStream'
//              uses SEH and 'ExList' has destructor
#pragma warning (disable: 4509)


BOOL
WINAPI
imagehack_ImageGetDigestStream(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )

/*++

Routine Description:
    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_ALL_BUT_CERTS - Include data outside the PE image itself
                                                              (may include non-mapped debug symbolic)

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    DWORD           ErrorCode;
    EXCLUDE_LIST    ExList;

    if (I_MapIt(pFileBlob, &LoadedImage) == FALSE) {
        // Unable to map the image or invalid digest level.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {

        if ((LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &&
            (LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC))
        {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.CheckSum),
                       sizeof(NtHeader32->OptionalHeader.CheckSum));

            // Exclude the Security directory.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]),
                       sizeof(NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]));

            // Exclude the certs.
            ExList.Add((DWORD_PTR)NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress +
                                (DWORD_PTR)LoadedImage.MappedAddress,
                       NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
        } else {
            PIMAGE_NT_HEADERS64 NtHeader64 = (PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.CheckSum),
                       sizeof(NtHeader64->OptionalHeader.CheckSum));

            // Exclude the Security directory.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]),
                       sizeof(NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]));

            // Exclude the certs.
            ExList.Add((DWORD_PTR)NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress +
                                (DWORD_PTR)LoadedImage.MappedAddress,
                       NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
        }

        ExList.Emit((PBYTE) (LoadedImage.MappedAddress), LoadedImage.SizeOfImage);
        ErrorCode = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }


    SetLastError(ErrorCode);

    return(ErrorCode == ERROR_SUCCESS ? TRUE : FALSE);
}

#pragma warning (pop)


//+=========================================================================
//  The following was taken from the following file:
//      \nt\sdktools\debuggers\imagehlp\dice.cxx
//-=========================================================================


BOOL
I_FindCertificate(
    IN PLOADED_IMAGE    LoadedImage,
    IN DWORD            Index,
    OUT LPWIN_CERTIFICATE * Certificate
    )
{
    PIMAGE_DATA_DIRECTORY pDataDir;
    DWORD_PTR CurrentCert = NULL;
    BOOL rc;

    if (LoadedImage->fDOSImage) {
        // No way this could have a certificate;
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;     // Not an interesting file type.
        }

        // Check if the cert pointer is at least reasonable.
        if (!pDataDir->VirtualAddress ||
            !pDataDir->Size ||
            (pDataDir->VirtualAddress + pDataDir->Size > LoadedImage->SizeOfImage))
        {
            __leave;
        }

        // We're not looking at an empty security slot or an invalid (past the image boundary) value.
        // Let's see if we can find it.

        DWORD CurrentIdx = 0;
        DWORD_PTR LastCert;

        CurrentCert = (DWORD_PTR)(LoadedImage->MappedAddress) + pDataDir->VirtualAddress;
        LastCert = CurrentCert + pDataDir->Size;

        while (CurrentCert < LastCert ) {
            if (CurrentIdx == Index) {
                rc = TRUE;
                __leave;
            }
            CurrentIdx++;
            CurrentCert += ((LPWIN_CERTIFICATE)CurrentCert)->dwLength;
            CurrentCert = (CurrentCert + 7) & ~7;   // align it.
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (rc == TRUE) {
        *Certificate = (LPWIN_CERTIFICATE)CurrentCert;
    }

    return(rc);
}

BOOL
WINAPI
imagehack_ImageGetCertificateData(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   CertificateIndex,
    OUT     LPWIN_CERTIFICATE * Certificate
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve

    Certificate         -   Output buffer where the certificate is to be stored.

    RequiredLength      -   Size of the certificate buffer (input).  On return, is
                            set to the actual certificate length.  NULL can be used
                            to determine the size of a certificate.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    DWORD   ErrorCode;

    LPWIN_CERTIFICATE ImageCert;

    *Certificate = NULL;

    // if (I_MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
    if (I_MapIt(pFileBlob, &LoadedImage) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        if (I_FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
            __leave;
        }
        
        *Certificate = ImageCert;
        ErrorCode = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    // I_UnMapIt(&LoadedImage);

    SetLastError(ErrorCode);
    return(ErrorCode == ERROR_SUCCESS ? TRUE: FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\vercert.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       vercert.cpp
//
//  Contents:   Minimal Cryptographic functions to verify ASN.1 encoded
//              X.509 certificates
//
//
//  Functions:  MinCryptVerifyCertificate
//
//  History:    17-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_CHAIN_DEPTH             10

// #define USE_TEST_ROOTS_FOR_TESTING  1


//+=========================================================================
//  Microsoft Roots
//-=========================================================================

// Name:: <CN=Microsoft Authenticode(tm) Root Authority, O=MSFT, C=US>
const BYTE rgbMicrosoftRoot0_Name[] = {
    0x30, 0x50, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03,
    0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x13, 0x04, 0x4D, 0x53, 0x46, 0x54, 0x31, 0x32,
    0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
    0x29, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F,
    0x66, 0x74, 0x20, 0x41, 0x75, 0x74, 0x68, 0x65,
    0x6E, 0x74, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x28,
    0x74, 0x6D, 0x29, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69,
    0x74, 0x79
};
const BYTE rgbMicrosoftRoot0_PubKeyInfo[]= {
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
    0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xDF, 0x08, 0xBA, 0xE3, 0x3F, 0x6E, 0x64,
    0x9B, 0xF5, 0x89, 0xAF, 0x28, 0x96, 0x4A, 0x07,
    0x8F, 0x1B, 0x2E, 0x8B, 0x3E, 0x1D, 0xFC, 0xB8,
    0x80, 0x69, 0xA3, 0xA1, 0xCE, 0xDB, 0xDF, 0xB0,
    0x8E, 0x6C, 0x89, 0x76, 0x29, 0x4F, 0xCA, 0x60,
    0x35, 0x39, 0xAD, 0x72, 0x32, 0xE0, 0x0B, 0xAE,
    0x29, 0x3D, 0x4C, 0x16, 0xD9, 0x4B, 0x3C, 0x9D,
    0xDA, 0xC5, 0xD3, 0xD1, 0x09, 0xC9, 0x2C, 0x6F,
    0xA6, 0xC2, 0x60, 0x53, 0x45, 0xDD, 0x4B, 0xD1,
    0x55, 0xCD, 0x03, 0x1C, 0xD2, 0x59, 0x56, 0x24,
    0xF3, 0xE5, 0x78, 0xD8, 0x07, 0xCC, 0xD8, 0xB3,
    0x1F, 0x90, 0x3F, 0xC0, 0x1A, 0x71, 0x50, 0x1D,
    0x2D, 0xA7, 0x12, 0x08, 0x6D, 0x7C, 0xB0, 0x86,
    0x6C, 0xC7, 0xBA, 0x85, 0x32, 0x07, 0xE1, 0x61,
    0x6F, 0xAF, 0x03, 0xC5, 0x6D, 0xE5, 0xD6, 0xA1,
    0x8F, 0x36, 0xF6, 0xC1, 0x0B, 0xD1, 0x3E, 0x69,
    0x97, 0x48, 0x72, 0xC9, 0x7F, 0xA4, 0xC8, 0xC2,
    0x4A, 0x4C, 0x7E, 0xA1, 0xD1, 0x94, 0xA6, 0xD7,
    0xDC, 0xEB, 0x05, 0x46, 0x2E, 0xB8, 0x18, 0xB4,
    0x57, 0x1D, 0x86, 0x49, 0xDB, 0x69, 0x4A, 0x2C,
    0x21, 0xF5, 0x5E, 0x0F, 0x54, 0x2D, 0x5A, 0x43,
    0xA9, 0x7A, 0x7E, 0x6A, 0x8E, 0x50, 0x4D, 0x25,
    0x57, 0xA1, 0xBF, 0x1B, 0x15, 0x05, 0x43, 0x7B,
    0x2C, 0x05, 0x8D, 0xBD, 0x3D, 0x03, 0x8C, 0x93,
    0x22, 0x7D, 0x63, 0xEA, 0x0A, 0x57, 0x05, 0x06,
    0x0A, 0xDB, 0x61, 0x98, 0x65, 0x2D, 0x47, 0x49,
    0xA8, 0xE7, 0xE6, 0x56, 0x75, 0x5C, 0xB8, 0x64,
    0x08, 0x63, 0xA9, 0x30, 0x40, 0x66, 0xB2, 0xF9,
    0xB6, 0xE3, 0x34, 0xE8, 0x67, 0x30, 0xE1, 0x43,
    0x0B, 0x87, 0xFF, 0xC9, 0xBE, 0x72, 0x10, 0x5E,
    0x23, 0xF0, 0x9B, 0xA7, 0x48, 0x65, 0xBF, 0x09,
    0x88, 0x7B, 0xCD, 0x72, 0xBC, 0x2E, 0x79, 0x9B,
    0x7B, 0x02, 0x03, 0x01, 0x00, 0x01
};


// Name:: <CN=Microsoft Root Authority, OU=Microsoft Corporation,
//         OU=Copyright (c) 1997 Microsoft Corp.>
const BYTE rgbMicrosoftRoot1_Name[]= {
    0x30, 0x70, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x22, 0x43, 0x6F, 0x70,
    0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28,
    0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x37, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
    0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x2E, 0x31,
    0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70,
    0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x18, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69,
    0x74, 0x79
};

const BYTE rgbMicrosoftRoot1_PubKeyInfo[]= {
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
    0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xA9, 0x02, 0xBD, 0xC1, 0x70, 0xE6, 0x3B,
    0xF2, 0x4E, 0x1B, 0x28, 0x9F, 0x97, 0x78, 0x5E,
    0x30, 0xEA, 0xA2, 0xA9, 0x8D, 0x25, 0x5F, 0xF8,
    0xFE, 0x95, 0x4C, 0xA3, 0xB7, 0xFE, 0x9D, 0xA2,
    0x20, 0x3E, 0x7C, 0x51, 0xA2, 0x9B, 0xA2, 0x8F,
    0x60, 0x32, 0x6B, 0xD1, 0x42, 0x64, 0x79, 0xEE,
    0xAC, 0x76, 0xC9, 0x54, 0xDA, 0xF2, 0xEB, 0x9C,
    0x86, 0x1C, 0x8F, 0x9F, 0x84, 0x66, 0xB3, 0xC5,
    0x6B, 0x7A, 0x62, 0x23, 0xD6, 0x1D, 0x3C, 0xDE,
    0x0F, 0x01, 0x92, 0xE8, 0x96, 0xC4, 0xBF, 0x2D,
    0x66, 0x9A, 0x9A, 0x68, 0x26, 0x99, 0xD0, 0x3A,
    0x2C, 0xBF, 0x0C, 0xB5, 0x58, 0x26, 0xC1, 0x46,
    0xE7, 0x0A, 0x3E, 0x38, 0x96, 0x2C, 0xA9, 0x28,
    0x39, 0xA8, 0xEC, 0x49, 0x83, 0x42, 0xE3, 0x84,
    0x0F, 0xBB, 0x9A, 0x6C, 0x55, 0x61, 0xAC, 0x82,
    0x7C, 0xA1, 0x60, 0x2D, 0x77, 0x4C, 0xE9, 0x99,
    0xB4, 0x64, 0x3B, 0x9A, 0x50, 0x1C, 0x31, 0x08,
    0x24, 0x14, 0x9F, 0xA9, 0xE7, 0x91, 0x2B, 0x18,
    0xE6, 0x3D, 0x98, 0x63, 0x14, 0x60, 0x58, 0x05,
    0x65, 0x9F, 0x1D, 0x37, 0x52, 0x87, 0xF7, 0xA7,
    0xEF, 0x94, 0x02, 0xC6, 0x1B, 0xD3, 0xBF, 0x55,
    0x45, 0xB3, 0x89, 0x80, 0xBF, 0x3A, 0xEC, 0x54,
    0x94, 0x4E, 0xAE, 0xFD, 0xA7, 0x7A, 0x6D, 0x74,
    0x4E, 0xAF, 0x18, 0xCC, 0x96, 0x09, 0x28, 0x21,
    0x00, 0x57, 0x90, 0x60, 0x69, 0x37, 0xBB, 0x4B,
    0x12, 0x07, 0x3C, 0x56, 0xFF, 0x5B, 0xFB, 0xA4,
    0x66, 0x0A, 0x08, 0xA6, 0xD2, 0x81, 0x56, 0x57,
    0xEF, 0xB6, 0x3B, 0x5E, 0x16, 0x81, 0x77, 0x04,
    0xDA, 0xF6, 0xBE, 0xAE, 0x80, 0x95, 0xFE, 0xB0,
    0xCD, 0x7F, 0xD6, 0xA7, 0x1A, 0x72, 0x5C, 0x3C,
    0xCA, 0xBC, 0xF0, 0x08, 0xA3, 0x22, 0x30, 0xB3,
    0x06, 0x85, 0xC9, 0xB3, 0x20, 0x77, 0x13, 0x85,
    0xDF, 0x02, 0x03, 0x01, 0x00, 0x01
};


// 4096 bit key generated in 2001
//
// Name:: <CN=Microsoft Root Certificate Authority, DC=microsoft, DC=com>
const BYTE rgbMicrosoftRoot2_Name[]= {
    0x30, 0x5F, 0x31, 0x13, 0x30, 0x11, 0x06, 0x0A,
    0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64,
    0x01, 0x19, 0x16, 0x03, 0x63, 0x6F, 0x6D, 0x31,
    0x19, 0x30, 0x17, 0x06, 0x0A, 0x09, 0x92, 0x26,
    0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01, 0x19, 0x16,
    0x09, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F,
    0x66, 0x74, 0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x13, 0x24, 0x4D, 0x69, 0x63,
    0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x52,
    0x6F, 0x6F, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20,
    0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74,
    0x79
};
const BYTE rgbMicrosoftRoot2_PubKeyInfo[]= {
    0x30, 0x82, 0x02, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0F, 0x00,
    0x30, 0x82, 0x02, 0x0A, 0x02, 0x82, 0x02, 0x01,
    0x00, 0xF3, 0x5D, 0xFA, 0x80, 0x67, 0xD4, 0x5A,
    0xA7, 0xA9, 0x0C, 0x2C, 0x90, 0x20, 0xD0, 0x35,
    0x08, 0x3C, 0x75, 0x84, 0xCD, 0xB7, 0x07, 0x89,
    0x9C, 0x89, 0xDA, 0xDE, 0xCE, 0xC3, 0x60, 0xFA,
    0x91, 0x68, 0x5A, 0x9E, 0x94, 0x71, 0x29, 0x18,
    0x76, 0x7C, 0xC2, 0xE0, 0xC8, 0x25, 0x76, 0x94,
    0x0E, 0x58, 0xFA, 0x04, 0x34, 0x36, 0xE6, 0xDF,
    0xAF, 0xF7, 0x80, 0xBA, 0xE9, 0x58, 0x0B, 0x2B,
    0x93, 0xE5, 0x9D, 0x05, 0xE3, 0x77, 0x22, 0x91,
    0xF7, 0x34, 0x64, 0x3C, 0x22, 0x91, 0x1D, 0x5E,
    0xE1, 0x09, 0x90, 0xBC, 0x14, 0xFE, 0xFC, 0x75,
    0x58, 0x19, 0xE1, 0x79, 0xB7, 0x07, 0x92, 0xA3,
    0xAE, 0x88, 0x59, 0x08, 0xD8, 0x9F, 0x07, 0xCA,
    0x03, 0x58, 0xFC, 0x68, 0x29, 0x6D, 0x32, 0xD7,
    0xD2, 0xA8, 0xCB, 0x4B, 0xFC, 0xE1, 0x0B, 0x48,
    0x32, 0x4F, 0xE6, 0xEB, 0xB8, 0xAD, 0x4F, 0xE4,
    0x5C, 0x6F, 0x13, 0x94, 0x99, 0xDB, 0x95, 0xD5,
    0x75, 0xDB, 0xA8, 0x1A, 0xB7, 0x94, 0x91, 0xB4,
    0x77, 0x5B, 0xF5, 0x48, 0x0C, 0x8F, 0x6A, 0x79,
    0x7D, 0x14, 0x70, 0x04, 0x7D, 0x6D, 0xAF, 0x90,
    0xF5, 0xDA, 0x70, 0xD8, 0x47, 0xB7, 0xBF, 0x9B,
    0x2F, 0x6C, 0xE7, 0x05, 0xB7, 0xE1, 0x11, 0x60,
    0xAC, 0x79, 0x91, 0x14, 0x7C, 0xC5, 0xD6, 0xA6,
    0xE4, 0xE1, 0x7E, 0xD5, 0xC3, 0x7E, 0xE5, 0x92,
    0xD2, 0x3C, 0x00, 0xB5, 0x36, 0x82, 0xDE, 0x79,
    0xE1, 0x6D, 0xF3, 0xB5, 0x6E, 0xF8, 0x9F, 0x33,
    0xC9, 0xCB, 0x52, 0x7D, 0x73, 0x98, 0x36, 0xDB,
    0x8B, 0xA1, 0x6B, 0xA2, 0x95, 0x97, 0x9B, 0xA3,
    0xDE, 0xC2, 0x4D, 0x26, 0xFF, 0x06, 0x96, 0x67,
    0x25, 0x06, 0xC8, 0xE7, 0xAC, 0xE4, 0xEE, 0x12,
    0x33, 0x95, 0x31, 0x99, 0xC8, 0x35, 0x08, 0x4E,
    0x34, 0xCA, 0x79, 0x53, 0xD5, 0xB5, 0xBE, 0x63,
    0x32, 0x59, 0x40, 0x36, 0xC0, 0xA5, 0x4E, 0x04,
    0x4D, 0x3D, 0xDB, 0x5B, 0x07, 0x33, 0xE4, 0x58,
    0xBF, 0xEF, 0x3F, 0x53, 0x64, 0xD8, 0x42, 0x59,
    0x35, 0x57, 0xFD, 0x0F, 0x45, 0x7C, 0x24, 0x04,
    0x4D, 0x9E, 0xD6, 0x38, 0x74, 0x11, 0x97, 0x22,
    0x90, 0xCE, 0x68, 0x44, 0x74, 0x92, 0x6F, 0xD5,
    0x4B, 0x6F, 0xB0, 0x86, 0xE3, 0xC7, 0x36, 0x42,
    0xA0, 0xD0, 0xFC, 0xC1, 0xC0, 0x5A, 0xF9, 0xA3,
    0x61, 0xB9, 0x30, 0x47, 0x71, 0x96, 0x0A, 0x16,
    0xB0, 0x91, 0xC0, 0x42, 0x95, 0xEF, 0x10, 0x7F,
    0x28, 0x6A, 0xE3, 0x2A, 0x1F, 0xB1, 0xE4, 0xCD,
    0x03, 0x3F, 0x77, 0x71, 0x04, 0xC7, 0x20, 0xFC,
    0x49, 0x0F, 0x1D, 0x45, 0x88, 0xA4, 0xD7, 0xCB,
    0x7E, 0x88, 0xAD, 0x8E, 0x2D, 0xEC, 0x45, 0xDB,
    0xC4, 0x51, 0x04, 0xC9, 0x2A, 0xFC, 0xEC, 0x86,
    0x9E, 0x9A, 0x11, 0x97, 0x5B, 0xDE, 0xCE, 0x53,
    0x88, 0xE6, 0xE2, 0xB7, 0xFD, 0xAC, 0x95, 0xC2,
    0x28, 0x40, 0xDB, 0xEF, 0x04, 0x90, 0xDF, 0x81,
    0x33, 0x39, 0xD9, 0xB2, 0x45, 0xA5, 0x23, 0x87,
    0x06, 0xA5, 0x55, 0x89, 0x31, 0xBB, 0x06, 0x2D,
    0x60, 0x0E, 0x41, 0x18, 0x7D, 0x1F, 0x2E, 0xB5,
    0x97, 0xCB, 0x11, 0xEB, 0x15, 0xD5, 0x24, 0xA5,
    0x94, 0xEF, 0x15, 0x14, 0x89, 0xFD, 0x4B, 0x73,
    0xFA, 0x32, 0x5B, 0xFC, 0xD1, 0x33, 0x00, 0xF9,
    0x59, 0x62, 0x70, 0x07, 0x32, 0xEA, 0x2E, 0xAB,
    0x40, 0x2D, 0x7B, 0xCA, 0xDD, 0x21, 0x67, 0x1B,
    0x30, 0x99, 0x8F, 0x16, 0xAA, 0x23, 0xA8, 0x41,
    0xD1, 0xB0, 0x6E, 0x11, 0x9B, 0x36, 0xC4, 0xDE,
    0x40, 0x74, 0x9C, 0xE1, 0x58, 0x65, 0xC1, 0x60,
    0x1E, 0x7A, 0x5B, 0x38, 0xC8, 0x8F, 0xBB, 0x04,
    0x26, 0x7C, 0xD4, 0x16, 0x40, 0xE5, 0xB6, 0x6B,
    0x6C, 0xAA, 0x86, 0xFD, 0x00, 0xBF, 0xCE, 0xC1,
    0x35, 0x02, 0x03, 0x01, 0x00, 0x01
};



#ifdef USE_TEST_ROOTS_FOR_TESTING

//+=========================================================================
//  Test Roots
//-=========================================================================

// Name:: <CN=Microsoft Test Root Authority, OU=Microsoft Corporation, OU=Copyright (c) 1999 Microsoft Corp.>
const BYTE rgbTestRoot0_Name[] = {
    0x30, 0x75, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x22, 0x43, 0x6F, 0x70,
    0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28,
    0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x39, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
    0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x2E, 0x31,
    0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70,
    0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x1D, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74,
    0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x41, 0x75,
    0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79
};

const BYTE rgbTestRoot0_PubKeyInfo[]= {
    0x30, 0x81, 0xDF, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01,
    0x05, 0x00, 0x03, 0x81, 0xCD, 0x00, 0x30, 0x81,
    0xC9, 0x02, 0x81, 0xC1, 0x00, 0xA9, 0xAA, 0x83,
    0x58, 0x6D, 0xB5, 0xD3, 0x0C, 0x4B, 0x5B, 0x80,
    0x90, 0xE5, 0xC3, 0x0F, 0x28, 0x0C, 0x7E, 0x3D,
    0x3C, 0x24, 0xC5, 0x29, 0x56, 0x63, 0x8C, 0xEE,
    0xC7, 0x83, 0x4A, 0xD8, 0x8C, 0x25, 0xD3, 0x0E,
    0xD3, 0x12, 0xB7, 0xE1, 0x86, 0x72, 0x74, 0xA7,
    0x8B, 0xFB, 0x0F, 0x05, 0xE9, 0x65, 0xC1, 0x9B,
    0xD8, 0x56, 0xC2, 0x93, 0xF0, 0xFB, 0xE9, 0x5A,
    0x48, 0x85, 0x7D, 0x95, 0xAA, 0xDF, 0x01, 0x86,
    0xB7, 0x33, 0x33, 0x46, 0x56, 0xCB, 0x5B, 0x7A,
    0xC4, 0xAF, 0xA0, 0x96, 0x53, 0x3A, 0xE9, 0xFB,
    0x3B, 0x78, 0xC1, 0x43, 0x0C, 0xC7, 0x6E, 0x1C,
    0x2F, 0xD1, 0x55, 0xF1, 0x19, 0xB2, 0x3F, 0xF8,
    0xD6, 0xA0, 0xC7, 0x24, 0x95, 0x3B, 0xC8, 0x45,
    0x25, 0x6F, 0x45, 0x3A, 0x46, 0x4F, 0xD2, 0x27,
    0x8B, 0xC7, 0x50, 0x75, 0xC6, 0x80, 0x5E, 0x0D,
    0x99, 0x78, 0x61, 0x77, 0x39, 0xC1, 0xB3, 0x0F,
    0x9D, 0x12, 0x9C, 0xC4, 0xBB, 0x32, 0x7B, 0xB2,
    0x4B, 0x26, 0xAA, 0x4E, 0xC0, 0x32, 0xB0, 0x2A,
    0x13, 0x21, 0xBE, 0xED, 0x24, 0xF4, 0x7D, 0x0D,
    0xEA, 0xAA, 0x8A, 0x7A, 0xD2, 0x8B, 0x4D, 0x97,
    0xB5, 0x4D, 0x64, 0xBA, 0xFB, 0x46, 0xDD, 0x69,
    0x6F, 0x9A, 0x0E, 0xCC, 0x53, 0x77, 0xAA, 0x6E,
    0xAE, 0x20, 0xD6, 0x21, 0x98, 0x69, 0xD9, 0x46,
    0xB9, 0x64, 0x32, 0xD4, 0x17, 0x02, 0x03, 0x01,
    0x00, 0x01
};

//+=========================================================================
//  VeriSign Roots
//-=========================================================================


// Name:: <OU=VeriSign Commercial Software Publishers CA, O="VeriSign, Inc.", L=Internet>
const BYTE rgbVeriSignRoot0_Name[] = {
    0x30, 0x61, 0x31, 0x11, 0x30, 0x0F, 0x06, 0x03,
    0x55, 0x04, 0x07, 0x13, 0x08, 0x49, 0x6E, 0x74,
    0x65, 0x72, 0x6E, 0x65, 0x74, 0x31, 0x17, 0x30,
    0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E,
    0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E,
    0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x33,
    0x30, 0x31, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13,
    0x2A, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67,
    0x6E, 0x20, 0x43, 0x6F, 0x6D, 0x6D, 0x65, 0x72,
    0x63, 0x69, 0x61, 0x6C, 0x20, 0x53, 0x6F, 0x66,
    0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x50, 0x75,
    0x62, 0x6C, 0x69, 0x73, 0x68, 0x65, 0x72, 0x73,
    0x20, 0x43, 0x41
};

const BYTE rgbVeriSignRoot0_PubKeyInfo[]= {
    0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01,
    0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81,
    0x89, 0x02, 0x81, 0x81, 0x00, 0xC3, 0xD3, 0x69,
    0x65, 0x52, 0x01, 0x94, 0x54, 0xAB, 0x28, 0xC6,
    0x62, 0x18, 0xB3, 0x54, 0x55, 0xC5, 0x44, 0x87,
    0x45, 0x4A, 0x3B, 0xC2, 0x7E, 0xD8, 0xD3, 0xD7,
    0xC8, 0x80, 0x86, 0x8D, 0xD8, 0x0C, 0xF1, 0x16,
    0x9C, 0xCC, 0x6B, 0xA9, 0x29, 0xB2, 0x8F, 0x76,
    0x73, 0x92, 0xC8, 0xC5, 0x62, 0xA6, 0x3C, 0xED,
    0x1E, 0x05, 0x75, 0xF0, 0x13, 0x00, 0x6C, 0x14,
    0x4D, 0xD4, 0x98, 0x90, 0x07, 0xBE, 0x69, 0x73,
    0x81, 0xB8, 0x62, 0x4E, 0x31, 0x1E, 0xD1, 0xFC,
    0xC9, 0x0C, 0xEB, 0x7D, 0x90, 0xBF, 0xAE, 0xB4,
    0x47, 0x51, 0xEC, 0x6F, 0xCE, 0x64, 0x35, 0x02,
    0xD6, 0x7D, 0x67, 0x05, 0x77, 0xE2, 0x8F, 0xD9,
    0x51, 0xD7, 0xFB, 0x97, 0x19, 0xBC, 0x3E, 0xD7,
    0x77, 0x81, 0xC6, 0x43, 0xDD, 0xF2, 0xDD, 0xDF,
    0xCA, 0xA3, 0x83, 0x8B, 0xCB, 0x41, 0xC1, 0x3D,
    0x22, 0x48, 0x48, 0xA6, 0x19, 0x02, 0x03, 0x01,
    0x00, 0x01
};

#endif


typedef struct _ROOT_INFO {
    CRYPT_DER_BLOB  EncodedName;
    CRYPT_DER_BLOB  EncodedPubKeyInfo;
} ROOT_INFO, *PROOT_INFO;

const ROOT_INFO RootTable[] = {
    sizeof(rgbMicrosoftRoot0_Name), (BYTE *) rgbMicrosoftRoot0_Name,
    sizeof(rgbMicrosoftRoot0_PubKeyInfo), (BYTE *) rgbMicrosoftRoot0_PubKeyInfo,

    sizeof(rgbMicrosoftRoot1_Name), (BYTE *) rgbMicrosoftRoot1_Name,
    sizeof(rgbMicrosoftRoot1_PubKeyInfo), (BYTE *) rgbMicrosoftRoot1_PubKeyInfo,

    sizeof(rgbMicrosoftRoot2_Name), (BYTE *) rgbMicrosoftRoot2_Name,
    sizeof(rgbMicrosoftRoot2_PubKeyInfo), (BYTE *) rgbMicrosoftRoot2_PubKeyInfo,

#ifdef USE_TEST_ROOTS_FOR_TESTING
    sizeof(rgbTestRoot0_Name), (BYTE *) rgbTestRoot0_Name,
    sizeof(rgbTestRoot0_PubKeyInfo), (BYTE *) rgbTestRoot0_PubKeyInfo,

    sizeof(rgbVeriSignRoot0_Name), (BYTE *) rgbVeriSignRoot0_Name,
    sizeof(rgbVeriSignRoot0_PubKeyInfo), (BYTE *) rgbVeriSignRoot0_PubKeyInfo,
#endif
};
#define ROOT_CNT (sizeof(RootTable) / sizeof(RootTable[0]))



// If found, returns pointer to the PubKeyInfo blob. Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindRootByName(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob
    )
{
    DWORD i;
    
    for (i = 0; i < ROOT_CNT; i++) {
        if (pIssuerNameValueBlob->cbData == RootTable[i].EncodedName.cbData &&
                0 == memcmp(pIssuerNameValueBlob->pbData,
                        RootTable[i].EncodedName.pbData,
                        pIssuerNameValueBlob->cbData))
            return (PCRYPT_DER_BLOB) &RootTable[i].EncodedPubKeyInfo;
    }

    return NULL;
}

// If found, returns pointer to the PubKeyInfo blob. Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindRootByKey(
    IN PCRYPT_DER_BLOB pSubjectPubKeyInfoBlob
    )
{
    DWORD i;
    
    for (i = 0; i < ROOT_CNT; i++) {
        if (pSubjectPubKeyInfoBlob->cbData ==
                RootTable[i].EncodedPubKeyInfo.cbData
                                &&
                0 == memcmp(pSubjectPubKeyInfoBlob->pbData,
                        RootTable[i].EncodedPubKeyInfo.pbData,
                        pSubjectPubKeyInfoBlob->cbData))
            return (PCRYPT_DER_BLOB) &RootTable[i].EncodedPubKeyInfo;
    }

    return NULL;
}



// If found, returns pointer to rgCertBlob[MINASN1_CERT_BLOB_CNT].
// Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindIssuerCertificateByName(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    IN DWORD cCert,
    IN CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbName = pIssuerNameValueBlob->cbData;
    const BYTE *pbName = pIssuerNameValueBlob->pbData;

    if (0 == cbName)
        return NULL;
    
    for (i = 0; i < cCert; i++) {
        if (cbName == rgrgCertBlob[i][MINASN1_CERT_SUBJECT_IDX].cbData &&
                0 == memcmp(pbName,
                        rgrgCertBlob[i][MINASN1_CERT_SUBJECT_IDX].pbData,
                        cbName))
            return rgrgCertBlob[i];
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    LONG lErr;
    DWORD dwChainDepth = 0;
    PCRYPT_DER_BLOB rgSubject;
    BOOL fRoot = FALSE;

    rgSubject = rgSubjectCertBlob;
    while (!fRoot) {
        ALG_ID HashAlgId;
        BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
        DWORD cbHash;

        PCRYPT_DER_BLOB rgIssuer = NULL;
        PCRYPT_DER_BLOB pIssuerPubKeyInfo = NULL;

        // Hash the Subject's ToBeSigned bytes
        HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
            &rgSubject[MINASN1_CERT_SIGN_ALGID_IDX]);
        if (0 == HashAlgId)
            goto UnknownHashAlgId;
        lErr = MinCryptHashMemory(
            HashAlgId,
            1,                  // cBlob,
            &rgSubject[MINASN1_CERT_TO_BE_SIGNED_IDX],
            rgbHash,
            &cbHash
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // Get the public key to decrypt the signature

        // Check if SelfSigned
        if (rgSubject[MINASN1_CERT_ISSUER_IDX].cbData ==
                rgSubject[MINASN1_CERT_SUBJECT_IDX].cbData
                                &&
                0 == memcmp(rgSubject[MINASN1_CERT_ISSUER_IDX].pbData,
                        rgSubject[MINASN1_CERT_SUBJECT_IDX].pbData,
                        rgSubject[MINASN1_CERT_ISSUER_IDX].cbData)) {
            pIssuerPubKeyInfo = I_MinCryptFindRootByKey(
                &rgSubject[MINASN1_CERT_PUBKEY_INFO_IDX]);
            if (NULL == pIssuerPubKeyInfo)
                goto UntrustedRoot;
            fRoot = TRUE;
        } else {
            // Check if the issuer is a root
            pIssuerPubKeyInfo = I_MinCryptFindRootByName(
                &rgSubject[MINASN1_CERT_ISSUER_IDX]);
            if (pIssuerPubKeyInfo)
                fRoot = TRUE;
            else {
                // Try to find the issuer from the input set of
                // certificates
                rgIssuer = I_MinCryptFindIssuerCertificateByName(
                    &rgSubject[MINASN1_CERT_ISSUER_IDX],
                    cIssuerCert,
                    rgrgIssuerCertBlob
                    );
                if (NULL == rgIssuer)
                    goto PartialChain;

                pIssuerPubKeyInfo = &rgIssuer[MINASN1_CERT_PUBKEY_INFO_IDX];
            }
        }

        // Use the issuer or root's public key to decrypt and verify
        // the signature.
        lErr = MinCryptVerifySignedHash(
            HashAlgId,
            rgbHash,
            cbHash,
            &rgSubject[MINASN1_CERT_SIGNATURE_IDX],
            pIssuerPubKeyInfo
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!fRoot) {
            assert(rgIssuer);
            dwChainDepth++;
            if (MAX_CHAIN_DEPTH < dwChainDepth)
                goto CyclicChain;
            rgSubject = rgIssuer;
        }
    }


    lErr = ERROR_SUCCESS;

ErrorReturn:
CommonReturn:
    return lErr;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto CommonReturn;
UntrustedRoot:
    lErr = CERT_E_UNTRUSTEDROOT;
    goto CommonReturn;
CyclicChain:
PartialChain:
    lErr = CERT_E_CHAINING;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\verdata.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verdata.cpp
//
//  Contents:   Minimal Cryptographic functions to verify PKCS #7 Signed Data
//              message
//
//
//  Functions:  MinCryptVerifySignedData
//
//  History:    19-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_SIGNED_DATA_CERT_CNT        10
#define MAX_SIGNED_DATA_AUTH_ATTR_CNT   10

// #define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
const BYTE rgbOID_RSA_signedData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

// #define szOID_RSA_messageDigest "1.2.840.113549.1.9.4"
const BYTE rgbOID_RSA_messageDigest[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04};
const CRYPT_DER_BLOB RSA_messageDigestEncodedOIDBlob = {
        sizeof(rgbOID_RSA_messageDigest), 
        (BYTE *) rgbOID_RSA_messageDigest
};

PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindSignerCertificateByIssuerAndSerialNumber(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    IN PCRYPT_DER_BLOB pIssuerSerialNumberContentBlob,
    IN DWORD cCert,
    IN CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    DWORD i;
    const BYTE *pbName = pIssuerNameValueBlob->pbData;
    DWORD cbName = pIssuerNameValueBlob->cbData;
    const BYTE *pbSerial = pIssuerSerialNumberContentBlob->pbData;
    DWORD cbSerial = pIssuerSerialNumberContentBlob->cbData;
    
    if (0 == cbName || 0 == cbSerial)
        return NULL;

    for (i = 0; i < cCert; i++) {
        PCRYPT_DER_BLOB rgCert = rgrgCertBlob[i];

        if (cbName == rgCert[MINASN1_CERT_ISSUER_IDX].cbData &&
                cbSerial == rgCert[MINASN1_CERT_SERIAL_NUMBER_IDX].cbData
                        &&
                0 == memcmp(pbSerial,
                        rgCert[MINASN1_CERT_SERIAL_NUMBER_IDX].pbData,
                        cbSerial)
                        &&
                0 == memcmp(pbName,
                        rgCert[MINASN1_CERT_ISSUER_IDX].pbData,
                        cbName))
            return rgCert;
    }

    return NULL;
}

//  Verifies that the input hash matches the
//  szOID_RSA_messageDigest ("1.2.840.113549.1.9.4") authenticated attribute.
//
//  Replaces the input hash with a hash of the authenticated attributes.
LONG
WINAPI
I_MinCryptVerifySignerAuthenticatedAttributes(
    IN ALG_ID HashAlgId,
    IN OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    IN OUT DWORD *pcbHash,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    )
{
    LONG lErr;
    DWORD cAttr;
    CRYPT_DER_BLOB rgrgAttrBlob[MAX_SIGNED_DATA_AUTH_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    PCRYPT_DER_BLOB rgDigestAuthAttr;

    const BYTE *pbDigestAuthValue;
    DWORD cbDigestAuthValue;

    CRYPT_DER_BLOB rgAuthHashBlob[2];
    const BYTE bTagSet = MINASN1_TAG_SET;

    // Parse the authenticated attributes
    cAttr = MAX_SIGNED_DATA_AUTH_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob) || 0 == cAttr)
        goto MissingAuthAttrs;

    // Find the szOID_RSA_messageDigest ("1.2.840.113549.1.9.4")
    // attribute value
    rgDigestAuthAttr = MinAsn1FindAttribute(
        (PCRYPT_DER_BLOB) &RSA_messageDigestEncodedOIDBlob,
        cAttr,
        rgrgAttrBlob
        );
    if (NULL == rgDigestAuthAttr)
        goto MissingDigestAuthAttr;

    // Skip past the digest's outer OCTET tag and length octets
    if (0 >= MinAsn1ExtractContent(
            rgDigestAuthAttr[MINASN1_ATTR_VALUE_IDX].pbData,
            rgDigestAuthAttr[MINASN1_ATTR_VALUE_IDX].cbData,
            &cbDigestAuthValue,
            &pbDigestAuthValue
            ))
        goto InvalidDigestAuthAttr;

    // Check that the authenticated digest bytes match the input
    // content hash.
    if (*pcbHash != cbDigestAuthValue ||
            0 != memcmp(rgbHash, pbDigestAuthValue, cbDigestAuthValue))
        goto InvalidContentHash;

    // Hash the authenticated attributes. This hash will be compared against
    // the decrypted signature.

    // Note, the authenticated attributes "[0] Implicit" tag needs to be changed
    // to a "SET OF" tag before doing the hash.
    rgAuthHashBlob[0].pbData = (BYTE *) &bTagSet;
    rgAuthHashBlob[0].cbData = 1;
    assert(0 < pAttrsValueBlob->cbData);
    rgAuthHashBlob[1].pbData = pAttrsValueBlob->pbData + 1;
    rgAuthHashBlob[1].cbData = pAttrsValueBlob->cbData - 1;
    
    lErr = MinCryptHashMemory(
        HashAlgId,
        2,                      // cBlob
        rgAuthHashBlob,
        rgbHash,
        pcbHash
        );

CommonReturn:
    return lErr;

MissingAuthAttrs:
MissingDigestAuthAttr:
InvalidDigestAuthAttr:
    lErr = CRYPT_E_AUTH_ATTR_MISSING;
    goto CommonReturn;

InvalidContentHash:
    lErr = CRYPT_E_HASH_VALUE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    )
{
    LONG lErr;
    CRYPT_DER_BLOB rgParseSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT];
    DWORD cCert;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_SIGNED_DATA_CERT_CNT][MINASN1_CERT_BLOB_CNT];
    PCRYPT_DER_BLOB rgSignerCert;
    ALG_ID HashAlgId;
    BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
    DWORD cbHash;
    CRYPT_DER_BLOB ContentBlob;

    memset(rgVerSignedDataBlob, 0,
        sizeof(CRYPT_DER_BLOB) * MINCRYPT_VER_SIGNED_DATA_BLOB_CNT);

    // Parse the message and verify that it's ASN.1 PKCS #7 SignedData
    if (0 >= MinAsn1ParseSignedData(
            pbEncoded,
            cbEncoded,
            rgParseSignedDataBlob
            ))
        goto ParseSignedDataError;

    // Only support szOID_RSA_signedData - "1.2.840.113549.1.7.2"
    if (sizeof(rgbOID_RSA_signedData) !=
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_OUTER_OID_IDX].cbData
                        ||
            0 != memcmp(rgbOID_RSA_signedData,
                    rgParseSignedDataBlob[MINASN1_SIGNED_DATA_OUTER_OID_IDX].pbData,
                    sizeof(rgbOID_RSA_signedData)))
        goto NotSignedDataOID;

    // Verify this isn't an empty SignedData message
    if (0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
            0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].cbData)
        goto NoContent;

    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_OID_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX];

    // Check that the message has a signer
    if (0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX].cbData)
        goto NoSigner;

    // Get the message's bag of certs
    cCert = MAX_SIGNED_DATA_CERT_CNT;
    if (0 >= MinAsn1ParseSignedDataCertificates(
            &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX],
            &cCert,
            rgrgCertBlob
            ) || 0 == cCert)
        goto NoCerts;

    // Get the signer certificate
    rgSignerCert = I_MinCryptFindSignerCertificateByIssuerAndSerialNumber(
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX],
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX],
        cCert,
        rgrgCertBlob
        );
    if (NULL == rgSignerCert)
        goto NoSignerCert;

    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX] =
        rgSignerCert[MINASN1_CERT_ENCODED_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX];


    // Verify the signer certificate up to a baked in, trusted root
    lErr = MinCryptVerifyCertificate(
        rgSignerCert,
        cCert,
        rgrgCertBlob
        );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;


    // Hash the message's content octets according to the signer's hash
    // algorithm
    HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX]
        );
    if (0 == HashAlgId)
        goto UnknownHashAlgId;

    // Note, the content's tag and length octets aren't included in the hash
    if (0 >= MinAsn1ExtractContent(
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].pbData,
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].cbData,
            &ContentBlob.cbData,
            (const BYTE **) &ContentBlob.pbData
            ))
        goto InvalidContent;

    lErr = MinCryptHashMemory(
        HashAlgId,
        1,                      // cBlob
        &ContentBlob,
        rgbHash,
        &cbHash
        );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;

    // If we have authenticated attributes, then, need to compare the
    // above hash with the szOID_RSA_messageDigest ("1.2.840.113549.1.9.4")
    // attribute value. After a successful comparison, the above hash
    // is replaced with a hash of the authenticated attributes.
    if (0 != rgParseSignedDataBlob[
            MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX].cbData) {
        lErr = I_MinCryptVerifySignerAuthenticatedAttributes(
            HashAlgId,
            rgbHash,
            &cbHash,
            &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX]
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;
    }

    // Verify the signature using either the authenticated attributes hash
    // or the content hash
    lErr = MinCryptVerifySignedHash(
        HashAlgId,
        rgbHash,
        cbHash,
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX],
        &rgSignerCert[MINASN1_CERT_PUBKEY_INFO_IDX]
        );


ErrorReturn:
CommonReturn:
    return lErr;

ParseSignedDataError:
NotSignedDataOID:
InvalidContent:
    lErr = CRYPT_E_BAD_MSG;
    goto CommonReturn;

NoContent:
    lErr = ERROR_NO_DATA;
    goto CommonReturn;

NoSigner:
NoCerts:
NoSignerCert:
    lErr = CRYPT_E_NO_SIGNER;
    goto CommonReturn;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\lib\verhash.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verhash.cpp
//
//  Contents:   Minimal Cryptographic functions to verify ASN.1 encoded
//              signed hashes. Signed hashes are used in X.509 certificates
//              and PKCS #7 signed data.
//
//              Also contains md5 or sha1 memory hash function.
//              
//
//  Functions:  MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//
//  History:    17-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <md5.h>
#include <md2.h>
#include <sha.h>
#include <rsa.h>

#define MAX_RSA_PUB_KEY_BIT_LEN             4096
#define MAX_RSA_PUB_KEY_BYTE_LEN            (MAX_RSA_PUB_KEY_BIT_LEN / 8 )
#define MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN  \
    (MAX_RSA_PUB_KEY_BYTE_LEN +  sizeof(DWORD) * 4)

typedef struct _BSAFE_PUB_KEY_CONTENT {
    BSAFE_PUB_KEY   Header;
    BYTE            rgbModulus[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];
} BSAFE_PUB_KEY_CONTENT, *PBSAFE_PUB_KEY_CONTENT;


#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

// from \nt\ds\win32\ntcrypto\scp\nt_sign.c

//
// Reverse ASN.1 Encodings of possible hash identifiers.  The leading byte is
// the length of the remaining byte string.
//

static const BYTE
    *md2Encodings[]
//                        1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *md5Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *shaEncodings[]
    = { (CONST BYTE *)"\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
        (CONST BYTE *)"\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
        (CONST BYTE *)"\x00"};



typedef struct _ENCODED_OID_INFO {
    DWORD           cbEncodedOID;
    const BYTE      *pbEncodedOID;
    ALG_ID          AlgId;
} ENCODED_OID_INFO, *PENCODED_OID_INFO;

//
// SHA1/MD5/MD2 HASH OIDS
//

// #define szOID_OIWSEC_sha1       "1.3.14.3.2.26"
const BYTE rgbOIWSEC_sha1[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x1A};

// #define szOID_OIWSEC_sha        "1.3.14.3.2.18"
const BYTE rgbOID_OIWSEC_sha[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x12};

// #define szOID_RSA_MD5           "1.2.840.113549.2.5"
const BYTE rgbOID_RSA_MD5[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05};

// #define szOID_RSA_MD2           "1.2.840.113549.2.2"
const BYTE rgbOID_RSA_MD2[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x02};

//
// RSA SHA1/MD5/MD2 SIGNATURE OIDS
//

// #define szOID_RSA_SHA1RSA       "1.2.840.113549.1.1.5"
const BYTE rgbOID_RSA_SHA1RSA[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05};

// #define szOID_RSA_MD5RSA        "1.2.840.113549.1.1.4"
const BYTE rgbOID_RSA_MD5RSA[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x04};

// #define szOID_OIWSEC_sha1RSASign "1.3.14.3.2.29"
const BYTE rgbOID_OIWSEC_sha1RSASign[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x1D};

// #define szOID_OIWSEC_shaRSA     "1.3.14.3.2.15"
const BYTE rgbOID_OIWSEC_shaRSA[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x0F};

// #define szOID_OIWSEC_md5RSA     "1.3.14.3.2.3"
const BYTE rgbOID_OIWSEC_md5RSA[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x03};

// #define szOID_RSA_MD2RSA        "1.2.840.113549.1.1.2"
const BYTE rgbOID_RSA_MD2RSA[] =
   {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x02}; 

// #define szOID_OIWDIR_md2RSA     "1.3.14.7.2.3.1"
const BYTE rgbOID_OIWDIR_md2RSA[] =
    {0x2B, 0x0E, 0x07, 0x02, 0x03, 0x01};


const ENCODED_OID_INFO HashAlgTable[] = {
    // Hash OIDs
    sizeof(rgbOIWSEC_sha1), rgbOIWSEC_sha1, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_sha), rgbOID_OIWSEC_sha, CALG_SHA1,
    sizeof(rgbOID_RSA_MD5), rgbOID_RSA_MD5, CALG_MD5,
    sizeof(rgbOID_RSA_MD2), rgbOID_RSA_MD2, CALG_MD2,

    // Signature OIDs
    sizeof(rgbOID_RSA_SHA1RSA), rgbOID_RSA_SHA1RSA, CALG_SHA1,
    sizeof(rgbOID_RSA_MD5RSA), rgbOID_RSA_MD5RSA, CALG_MD5,
    sizeof(rgbOID_OIWSEC_sha1RSASign), rgbOID_OIWSEC_sha1RSASign, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_shaRSA), rgbOID_OIWSEC_shaRSA, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_md5RSA), rgbOID_OIWSEC_md5RSA, CALG_MD5,
    sizeof(rgbOID_RSA_MD2RSA), rgbOID_RSA_MD2RSA, CALG_MD2,
    sizeof(rgbOID_OIWDIR_md2RSA), rgbOID_OIWDIR_md2RSA, CALG_MD2,
};
#define HASH_ALG_CNT (sizeof(HashAlgTable) / sizeof(HashAlgTable[0]))



//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    )
{
    ALG_ID HashAlgId = 0;
    LONG lSkipped;
    CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT];
    DWORD cbEncodedOID;
    const BYTE *pbEncodedOID;
    DWORD i;

    lSkipped = MinAsn1ParseAlgorithmIdentifier(
        pAlgIdValueBlob,
        rgAlgIdBlob
        );
    if (0 >= lSkipped)
        goto CommonReturn;

    cbEncodedOID = rgAlgIdBlob[MINASN1_ALGID_OID_IDX].cbData;
    pbEncodedOID = rgAlgIdBlob[MINASN1_ALGID_OID_IDX].pbData;

    for (i = 0; i < HASH_ALG_CNT; i++) {
        if (cbEncodedOID == HashAlgTable[i].cbEncodedOID &&
                0 == memcmp(pbEncodedOID, HashAlgTable[i].pbEncodedOID,
                                cbEncodedOID)) {
            HashAlgId = HashAlgTable[i].AlgId;
            break;
        }
    }

CommonReturn:
    return HashAlgId;
}


#pragma warning (push)
// local variable 'Md5Ctx' may be used without having been initialized
#pragma warning (disable: 4701)

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    )
{
    A_SHA_CTX ShaCtx;
    MD5_CTX Md5Ctx;
    MD2_CTX Md2Ctx;
    DWORD iBlob;

    switch (HashAlgId) {
        case CALG_MD2:
            memset(&Md2Ctx, 0, sizeof(Md2Ctx));
            *pcbHash = MINCRYPT_MD2_HASH_LEN;
            break;

        case CALG_MD5:
            MD5Init(&Md5Ctx);
            *pcbHash = MINCRYPT_MD5_HASH_LEN;
            break;

        case CALG_SHA1:
            A_SHAInit(&ShaCtx);
            *pcbHash = MINCRYPT_SHA1_HASH_LEN;
            break;

        default:
            *pcbHash = 0;
            return NTE_BAD_ALGID;
    }

    for (iBlob = 0; iBlob < cBlob; iBlob++) {
        BYTE *pb = rgBlob[iBlob].pbData;
        DWORD cb = rgBlob[iBlob].cbData;

        if (0 == cb)
            continue;

        switch (HashAlgId) {
            case CALG_MD2:
                MD2Update(&Md2Ctx, pb, cb);
                break;

            case CALG_MD5:
                MD5Update(&Md5Ctx, pb, cb);
                break;

            case CALG_SHA1:
                A_SHAUpdate(&ShaCtx, pb, cb);
                break;
        }

    }

    switch (HashAlgId) {
        case CALG_MD2:
            MD2Final(&Md2Ctx);
            memcpy(rgbHash, Md2Ctx.state, MINCRYPT_MD2_HASH_LEN);
            break;

        case CALG_MD5:
            MD5Final(&Md5Ctx);
            assert(MD5DIGESTLEN == MINCRYPT_MD5_HASH_LEN);
            memcpy(rgbHash, Md5Ctx.digest, MD5DIGESTLEN);
            break;

        case CALG_SHA1:
            A_SHAFinal(&ShaCtx, rgbHash);
            break;
    }

    return ERROR_SUCCESS;

}

#pragma warning (pop)

//+=========================================================================
//  MinCryptVerifySignedHash Support Functions
//-=========================================================================

VOID
WINAPI
I_ReverseAndCopyBytes(
    OUT BYTE *pbDst,
    IN const BYTE *pbSrc,
    IN DWORD cb
    )
{
    if (0 == cb)
        return;
    for (pbDst += cb - 1; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
}



//  The basis for much of the code in this function can be found in
//  \nt\ds\win32\ntcrypto\scp\nt_key.c
LONG
WINAPI
I_ConvertParsedRSAPubKeyToBSafePubKey(
    IN CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT],
    OUT PBSAFE_PUB_KEY_CONTENT pBSafePubKeyContent
    )
{
    LONG lErr;
    DWORD cbModulus;
    const BYTE *pbAsn1Modulus;
    DWORD cbExp;
    const BYTE *pbAsn1Exp;
    DWORD cbTmpLen;
    LPBSAFE_PUB_KEY pBSafePubKey;

    // Get the ASN.1 public key modulus (BIG ENDIAN). The modulus length
    // is the public key byte length.
    cbModulus = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].cbData;
    pbAsn1Modulus = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].pbData;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbModulus > 1 && *pbAsn1Modulus == 0) {
        pbAsn1Modulus++;
        cbModulus--;
    }
    if (MAX_RSA_PUB_KEY_BYTE_LEN < cbModulus)
        goto ExceededMaxPubKeyModulusLen;

    // Get the ASN.1 public exponent (BIG ENDIAN).
    cbExp = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX].cbData;
    pbAsn1Exp = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX].pbData;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbExp > 1 && *pbAsn1Exp == 0) {
        pbAsn1Exp++;
        cbExp--;
    }
    if (sizeof(DWORD) < cbExp)
        goto ExceededMaxPubKeyExpLen;

    if (0 == cbModulus || 0 == cbExp)
        goto InvalidPubKey;

    // Update the BSAFE data structure from the parsed and length validated
    // ASN.1 public key modulus and exponent components.

    cbTmpLen = (sizeof(DWORD) * 2) - (cbModulus % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;

    memset(pBSafePubKeyContent, 0, sizeof(*pBSafePubKeyContent));
    pBSafePubKey = &pBSafePubKeyContent->Header;
    pBSafePubKey->magic = RSA1;
    pBSafePubKey->keylen = cbModulus + cbTmpLen;
    pBSafePubKey->bitlen = cbModulus * 8;
    pBSafePubKey->datalen = cbModulus - 1;

    I_ReverseAndCopyBytes((BYTE *) &pBSafePubKey->pubexp, pbAsn1Exp, cbExp);
    I_ReverseAndCopyBytes(pBSafePubKeyContent->rgbModulus, pbAsn1Modulus,
        cbModulus);

    lErr = ERROR_SUCCESS;
CommonReturn:
    return lErr;

ExceededMaxPubKeyModulusLen:
ExceededMaxPubKeyExpLen:
InvalidPubKey:
    lErr = NTE_BAD_PUBLIC_KEY;
    goto CommonReturn;
}


//  The basis for much of the code in this function can be found in
//  \nt\ds\win32\ntcrypto\scp\nt_sign.c
LONG
WINAPI
I_VerifyPKCS1SigningFormat(
    IN BSAFE_PUB_KEY *pKey,
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN BYTE *pbPKCS1Format
    )
{
    LONG lErr = ERROR_INTERNAL_ERROR;
    const BYTE **rgEncOptions;
    BYTE rgbTmpHash[MINCRYPT_MAX_HASH_LEN];
    DWORD i;
    DWORD cb;
    BYTE *pbStart;
    DWORD cbTmp;

    switch (HashAlgId)
    {
    case CALG_MD2:
        rgEncOptions = md2Encodings;
        break;

    case CALG_MD5:
        rgEncOptions = md5Encodings;
        break;

    case CALG_SHA:
        rgEncOptions = shaEncodings;
        break;

    default:
        goto UnsupportedHash;
    }

    // Reverse the hash to match the signature.
    for (i = 0; i < cbHash; i++)
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];

    // See if it matches.
    if (0 != memcmp(rgbTmpHash, pbPKCS1Format, cbHash))
    {
        goto BadSignature;
    }

    cb = cbHash;
    for (i = 0; 0 != *rgEncOptions[i]; i += 1)
    {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp))
        {
            cb += cbTmp;   // Adjust the end of the hash data.
            break;
        }
    }

    // check to make sure the rest of the PKCS #1 padding is correct
    if ((0x00 != pbPKCS1Format[cb])
        || (0x00 != pbPKCS1Format[pKey->datalen])
        || (0x1 != pbPKCS1Format[pKey->datalen - 1]))
    {
        goto BadSignature;
    }

    for (i = cb + 1; i < pKey->datalen - 1; i++)
    {
        if (0xff != pbPKCS1Format[i])
        {
            goto BadSignature;
        }
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    return lErr;

UnsupportedHash:
    lErr = NTE_BAD_ALGID;
    goto CommonReturn;

BadSignature:
    lErr = NTE_BAD_SIGNATURE;
    goto CommonReturn;
}
    

//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signed hashes are supported.
//
//  Only MD2, MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    )
{
    LONG lErr;
    LONG lSkipped;
    
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT];
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT];
    BSAFE_PUB_KEY_CONTENT BSafePubKeyContent;
    LPBSAFE_PUB_KEY pBSafePubKey;

    DWORD cbSignature;
    const BYTE *pbAsn1Signature;

    BYTE rgbBSafeIn[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];
    BYTE rgbBSafeOut[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];


    // Attempt to parse and convert the ASN.1 encoded public key into
    // an RSA BSAFE formatted key.
    lSkipped = MinAsn1ParsePublicKeyInfo(
        pPubKeyInfoValueBlob,
        rgPubKeyInfoBlob
        );
    if (0 >= lSkipped)
        goto ParsePubKeyInfoError;

    lSkipped = MinAsn1ParseRSAPublicKey(
        &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX],
        rgRSAPubKeyBlob
        );
    if (0 >= lSkipped)
        goto ParseRSAPubKeyError;

    lErr = I_ConvertParsedRSAPubKeyToBSafePubKey(
        rgRSAPubKeyBlob,
        &BSafePubKeyContent
        );
    if (ERROR_SUCCESS != lErr)
        goto CommonReturn;

    pBSafePubKey = &BSafePubKeyContent.Header;
    
    // Get the ASN.1 signature (BIG ENDIAN).
    //
    // It must be the same length as the public key
    cbSignature = pSignedHashContentBlob->cbData;
    pbAsn1Signature = pSignedHashContentBlob->pbData;
    if (cbSignature != pBSafePubKey->bitlen / 8)
        goto InvalidSignatureLen;

    // Decrypt the signature (LITTLE ENDIAN)
    assert(sizeof(rgbBSafeIn) >= cbSignature);
    I_ReverseAndCopyBytes(rgbBSafeIn, pbAsn1Signature, cbSignature);
    memset(&rgbBSafeIn[cbSignature], 0, sizeof(rgbBSafeIn) - cbSignature);
    memset(rgbBSafeOut, 0, sizeof(rgbBSafeOut));

    if (!BSafeEncPublic(pBSafePubKey, rgbBSafeIn, rgbBSafeOut))
        goto BSafeEncPublicError;


    lErr = I_VerifyPKCS1SigningFormat(
        pBSafePubKey,
        HashAlgId,
        pbHash,
        cbHash,
        rgbBSafeOut
        );

CommonReturn:
    return lErr;

ParsePubKeyInfoError:
ParseRSAPubKeyError:
    lErr = NTE_BAD_PUBLIC_KEY;
    goto CommonReturn;

InvalidSignatureLen:
BSafeEncPublicError:
    lErr = NTE_BAD_SIGNATURE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\test\tminver\licexample.cpp ===
//+-------------------------------------------------------------------------
//  File:       licexample.cpp
//
//  Contents:   An example calling the minasn1 and mincrypt APIs to parse
//              the certificates in a PKCS #7 Signed Data, find a certificate
//              having the license extension and validate this certificate
//              up to a baked in and trusted root. Returns a pointer
//              to the license data within the verified certificate.
//--------------------------------------------------------------------------

#include <windows.h>
#include "minasn1.h"
#include "mincrypt.h"

#define MAX_LICENSE_CERT_CNT    20
#define MAX_LICENSE_EXT_CNT     20

// #define szOID_ESL_LICENSE_EXT "1.3.6.1.4.1.311.41.3"
const BYTE rgbOID_ESL_LICENSE_EXT[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x29, 0x03};
const CRYPT_DER_BLOB ESL_LICENSE_EXTEncodedOIDBlob = {
    sizeof(rgbOID_ESL_LICENSE_EXT), 
    (BYTE *) rgbOID_ESL_LICENSE_EXT
};


// Returns ERROR_SUCCESS if able to find and successfully verify the
// certificate containing the license data. Returns pointer to the
// license data bytes in the encoded data.
LONG
GetAndVerifyLicenseDataFromPKCS7SignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT const BYTE **ppbLicenseData,
    OUT DWORD *pcbLicenseData
    )
{
    LONG lErr;
    const BYTE *pbLicenseData;
    DWORD cbLicenseData;
    DWORD cCert;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_LICENSE_CERT_CNT][MINASN1_CERT_BLOB_CNT];
    PCRYPT_DER_BLOB rgLicenseCertBlob;
    DWORD iCert;

    // Parse the PKCS #7 to get the bag of certs.
    cCert = MAX_LICENSE_CERT_CNT;
    if (0 >= MinAsn1ExtractParsedCertificatesFromSignedData(
            pbEncoded,
            cbEncoded,
            &cCert,
            rgrgCertBlob
            ))
        goto ParseError;

    // Loop through the certs. Parse the cert's extensions. Attempt to
    // find the license extension.
    rgLicenseCertBlob = NULL;
    for (iCert = 0; iCert < cCert; iCert++) {
        DWORD cExt;
        CRYPT_DER_BLOB rgrgExtBlob[MAX_LICENSE_EXT_CNT][MINASN1_EXT_BLOB_CNT];
        PCRYPT_DER_BLOB rgLicenseExtBlob;

        cExt = MAX_LICENSE_EXT_CNT;
        if (0 >= MinAsn1ParseExtensions(
                &rgrgCertBlob[iCert][MINASN1_CERT_EXTS_IDX],
                &cExt,
                rgrgExtBlob
                ))
            continue;

        rgLicenseExtBlob = MinAsn1FindExtension(
            (PCRYPT_DER_BLOB) &ESL_LICENSE_EXTEncodedOIDBlob,
            cExt,
            rgrgExtBlob
            );

        if (NULL != rgLicenseExtBlob) {
            pbLicenseData = rgLicenseExtBlob[MINASN1_EXT_VALUE_IDX].pbData;
            cbLicenseData = rgLicenseExtBlob[MINASN1_EXT_VALUE_IDX].cbData;
            rgLicenseCertBlob = rgrgCertBlob[iCert];

            break;
        }
    }

    if (NULL == rgLicenseCertBlob)
        goto NoLicenseCert;

    // Verify the License certificate chain to a baked in trusted root.
    lErr = MinCryptVerifyCertificate(
        rgLicenseCertBlob,
        cCert,
        rgrgCertBlob
        );

CommonReturn:
    *ppbLicenseData = pbLicenseData;
    *pcbLicenseData = cbLicenseData;
    return lErr;

ErrorReturn:
    pbLicenseData = NULL;
    cbLicenseData = 0;
    goto CommonReturn;

ParseError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

NoLicenseCert:
    lErr = ERROR_NOT_FOUND;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\test\tminver\tminver.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tminver.cpp
//
//  Contents:   Minimal ASN.1 Parsing and Cryptographic API Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    29-Jan-01   philh   created
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include "testutil.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define MAX_FILENAME_CNT    100
#define DEFAULT_ATTR_LEN    1000
#define MAX_ATTR_CNT        20

//+-------------------------------------------------------------------------
// Global Test Parameters
//--------------------------------------------------------------------------
BOOL fVerbose = FALSE;
BOOL fContent = FALSE;
BOOL fQuiet = FALSE;
LONG lQuietErr = 0;
DWORD cbFirstAttrLen = DEFAULT_ATTR_LEN;
ALG_ID HashAlgId = CALG_SHA1;



static void Usage(void)
{
    printf("Usage: ttrust [options] <TestName> <Filename>\n");
    printf("TestNames are:\n");
    printf("  Data                  - PKCS #7 SignedData\n");
    printf("  Cert                  - X.509 encoded certifcate\n");
    printf("  Certs                 - Certs in PKCS #7 SignedData\n");
    printf("  File                  - Authenticode Signed File\n");
    printf("  Cat                   - File(s) in System Catalogs\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -Content              - Display content\n");
    printf("  -MD5                  - MD5 File hash default of SHA1\n");
    printf("\n");
    printf("  -h                    - This message\n");
    printf("  -v                    - Verbose\n");
    printf("  -q[<Number>]          - Quiet, expected error\n");
    printf("  -a<OID String>        - Attribute OID string\n");
    printf("  -A<Number>            - Attribute length, default of %d\n",
                                            DEFAULT_ATTR_LEN);
    printf("\n");
}

BOOL
TestData(
    IN LPCSTR pszFilename
    )
{
    BOOL fResult;
    LONG lErr;
    DWORD cbEncoded;
    PBYTE pbEncoded = NULL;
    CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
    BOOL fCTL = FALSE;

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    lErr = MinCryptVerifySignedData(
        pbEncoded,
        cbEncoded,
        rgVerSignedDataBlob
        );

    if (fQuiet) {
        if (lErr != lQuietErr) {
            printf("Expected => 0x%x, ", lQuietErr);
            PrintErr("MinCryptVerifySignedData", lErr);
            goto ErrorReturn;
        } else
            goto SuccessReturn;
    }

    if (ERROR_SUCCESS != lErr)
        PrintErr("MinCryptVerifySignedData", lErr);

    if (0 == rgVerSignedDataBlob[
            MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX].cbData)
        printf("No Signer\n");
    else {
        LONG lSkipped;
        CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT];

        printf("====  Signer  ====\n");

        lSkipped = MinAsn1ParseCertificate(
            rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX].pbData,
            rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX].cbData,
            rgCertBlob
            );

        if (0 > lSkipped)
            printf("MinAsn1ParseCertificate failed at offset: %d\n",
                -lSkipped - 1);
        else
            DisplayCert(rgCertBlob, fVerbose);

        if (fVerbose) {
            DisplayAttrs("Authenticated",
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX]);
            DisplayAttrs("Unauthenticated",
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX]);
        }

        printf("\n");
    }

    if (0 == rgVerSignedDataBlob[
            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData)
        printf("No Content OID\n");
    else {
        CHAR rgszOID[MAX_OID_STRING_LEN];

        EncodedOIDToDot(&rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX],
            rgszOID
            );

        if (0 == strcmp(rgszOID, szOID_CTL))
            fCTL = TRUE;

        printf("Content OID:: %s\n", rgszOID);
    }

    if (0 == rgVerSignedDataBlob[
            MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX].cbData)
        printf("No Content Data\n");
    else {
        if (fCTL)
            printf("CTL ");
        printf("Content Data:: %d bytes\n",
            rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX].cbData);

        if (fContent) {
            if (fCTL) {
                printf("\n====  CTL  ====\n");
                DisplayCTL(&rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX], fVerbose);
            } else
                PrintMultiLineBytes("    ", &rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX]);
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    TestFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL
TestCert(
    IN LPCSTR pszFilename
    )
{
    BOOL fResult;
    DWORD cbEncoded;
    PBYTE pbEncoded = NULL;
    LONG lSkipped;
    CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT];

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    printf("====  Cert  ====\n");

    lSkipped = MinAsn1ParseCertificate(
        pbEncoded,
        cbEncoded,
        rgCertBlob
        );

    if (0 > lSkipped) {
        printf("MinAsn1ParseCertificate failed at offset: %d\n",
            -lSkipped - 1);
        fResult = FALSE;
    } else {
        DisplayCert(rgCertBlob, fVerbose);
        fResult = TRUE;
    }

    printf("\n");

    fResult = TRUE;
CommonReturn:
    TestFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

#define MAX_CERTS_CNT   256

BOOL
TestCerts(
    IN LPCSTR pszFilename
    )
{
    BOOL fResult;
    LONG lSkipped;
    DWORD cbEncoded;
    PBYTE pbEncoded = NULL;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_CERTS_CNT][MINASN1_CERT_BLOB_CNT];
    DWORD cCert = MAX_CERTS_CNT;

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    lSkipped = MinAsn1ExtractParsedCertificatesFromSignedData(
        pbEncoded,
        cbEncoded,
        &cCert,
        rgrgCertBlob
        );
    if (0 > lSkipped) {
        printf("MinAsn1ExtractParsedCertificatesFromSignedData failed at offset: %d\n",
            -lSkipped - 1);
        goto ErrorReturn;
    }

    if (0 == cCert)
        printf("No Certs\n");
    else {
        DWORD i;
        LONG lErr;

        for (i = 0; i < cCert; i++) {
            printf("====  Cert[%d]  ====\n", i);
            lErr = MinCryptVerifyCertificate(
                rgrgCertBlob[i],
                cCert,
                rgrgCertBlob
                );
            
            printf("Verify: ");
            if (ERROR_SUCCESS == lErr)
                printf("Success\n");
            else
                printf("0x%x (%d) \n", lErr, lErr);

            DisplayCert(rgrgCertBlob[i], fVerbose);

            printf("\n");
        }
    }

    fResult = TRUE;
CommonReturn:
    TestFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL
TestFile(
    IN LPCSTR pszFilename,
    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL LPCSTR rgpszAttrOID[MAX_ATTR_CNT],
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[MAX_ATTR_CNT]
    )
{
    BOOL fResult;
    LONG lErr;
    DWORD cbAttr = 0;
    LPWSTR pwszFilename = NULL;
    PCRYPT_DER_BLOB pAttrValueBlob = NULL;

    pwszFilename = AllocAndSzToWsz(pszFilename);

    if (0 != cAttrOID && 0 != cbFirstAttrLen) {
        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbFirstAttrLen)))
            goto ErrorReturn;
        cbAttr = cbFirstAttrLen;
    }

    lErr = MinCryptVerifySignedFile(
        MINCRYPT_FILE_NAME,
        (const VOID *) pwszFilename,
        cAttrOID,
        rgAttrEncodedOIDBlob,
        pAttrValueBlob,
        &cbAttr
        );

    if (fQuiet) {
        if (lErr != lQuietErr) {
            printf("Expected => 0x%x, ", lQuietErr);
            PrintErr("MinCryptVerifySignedFile", lErr);
            goto ErrorReturn;
        } else
            goto SuccessReturn;
    }

    if (ERROR_INSUFFICIENT_BUFFER == lErr) {
        printf("Insufficient Buffer, require: %d input: %d\n",
            cbAttr, cbFirstAttrLen);

        TestFree(pAttrValueBlob);

        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbAttr)))
            goto ErrorReturn;

        lErr = MinCryptVerifySignedFile(
            MINCRYPT_FILE_NAME,
            (const VOID *) pwszFilename,
            cAttrOID,
            rgAttrEncodedOIDBlob,
            pAttrValueBlob,
            &cbAttr
            );
    }

    if (ERROR_SUCCESS != lErr)
        PrintErr("MinVerifySignedFile", lErr);
    else {
        DWORD i;

        printf("MinVerifySignedFile succeeded\n");

        for (i = 0; i < cAttrOID; i++) {
            printf("====  Attr[%d]  ====\n", i);
            printf("OID: %s ", rgpszAttrOID[i]);
            PrintBytes(&rgAttrEncodedOIDBlob[i]);
            printf("Value:\n");
            PrintMultiLineBytes("    ", &pAttrValueBlob[i]);
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    TestFree(pwszFilename);
    TestFree(pAttrValueBlob);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL
TestCat(
    IN DWORD cFilename,
    IN LPCSTR rgpszFilename[MAX_FILENAME_CNT],
    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL LPCSTR rgpszAttrOID[MAX_ATTR_CNT],
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[MAX_ATTR_CNT]
    )
{
    BOOL fResult;
    LONG lErr;
    DWORD cbAttr = 0;
    LPWSTR rgpwszFilename[MAX_FILENAME_CNT];
    CRYPT_HASH_BLOB rgHashBlob[MAX_FILENAME_CNT];
    BYTE rgrgbHash[MAX_FILENAME_CNT][MINCRYPT_MAX_HASH_LEN];
    LONG rglErr[MAX_FILENAME_CNT];
    PCRYPT_DER_BLOB pAttrValueBlob = NULL;
    DWORD i;


    for (i = 0; i < cFilename; i++)
        rgpwszFilename[i] = AllocAndSzToWsz(rgpszFilename[i]);

    fResult = TRUE;
    for (i = 0; i < cFilename; i++) {
        rgHashBlob[i].pbData = rgrgbHash[i];
        rgHashBlob[i].cbData = 0;
        lErr = MinCryptHashFile(
            MINCRYPT_FILE_NAME,
            (const VOID *) rgpwszFilename[i],
            HashAlgId,
            rgHashBlob[i].pbData,
            &rgHashBlob[i].cbData
            );

        if (ERROR_SUCCESS != lErr) {
            printf("<%S> ", rgpwszFilename[i]);
            PrintErr("MinCryptHashFile", lErr);
            fResult = FALSE;
        }
    }

    if (!fResult)
        goto ErrorReturn;

    if (0 != cAttrOID && 0 != cbFirstAttrLen) {
        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbFirstAttrLen)))
            goto ErrorReturn;
        cbAttr = cbFirstAttrLen;
    }

    lErr = MinCryptVerifyHashInSystemCatalogs(
        HashAlgId,
        cFilename,
        rgHashBlob,
        rglErr,
        cAttrOID,
        rgAttrEncodedOIDBlob,
        pAttrValueBlob,
        &cbAttr
        );


    if (ERROR_INSUFFICIENT_BUFFER == lErr) {
        printf("Insufficient Buffer, require: %d input: %d\n",
            cbAttr, cbFirstAttrLen);

        TestFree(pAttrValueBlob);

        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbAttr)))
            goto ErrorReturn;

        lErr = MinCryptVerifyHashInSystemCatalogs(
            HashAlgId,
            cFilename,
            rgHashBlob,
            rglErr,
            cAttrOID,
            rgAttrEncodedOIDBlob,
            pAttrValueBlob,
            &cbAttr
            );
    }

    if (ERROR_SUCCESS != lErr) {
        PrintErr("MinCryptVerifyHashInSystemCatalogs", lErr);
        goto ErrorReturn;
    }

    if (fQuiet) {
        fResult = TRUE;

        for (i = 0; i < cFilename; i++) {
            if (rglErr[i] != lQuietErr) {
                printf("<%S> ", rgpwszFilename[i]);
                printf("Expected => 0x%x, ", lQuietErr);
                PrintErr("MinCryptVerifyHashInSystemCatalogs", rglErr[i]);
                fResult = FALSE;
            }
        }

        if (fResult)
            goto SuccessReturn;
        else
            goto ErrorReturn;
    }


    printf("MinCryptVerifyHashInSystemCatalogs succeeded\n");
    for (i = 0; i < cFilename; i++) {
        DWORD j;

        printf("#####  [%d] <%S>  #####\n", i, rgpwszFilename[i]);
        if (ERROR_SUCCESS == rglErr[i])
            printf("Verify: SUCCESS\n");
        else {
            printf("%S ",  rgpwszFilename[i]);
            PrintErr("Verify", rglErr[i]);
        }

        printf("Hash:");
        PrintBytes(&rgHashBlob[i]);

        for (j = 0; j < cAttrOID; j++) {
            printf("====  Attr[%d]  ====\n", j);
            printf("OID: %s ", rgpszAttrOID[j]);
            PrintBytes(&rgAttrEncodedOIDBlob[j]);
            printf("Value:\n");
            PrintMultiLineBytes("    ", &pAttrValueBlob[i*cAttrOID + j]);
        }

        printf("\n");
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    for (i = 0; i < cFilename; i++)
        TestFree(rgpwszFilename[i]);
    TestFree(pAttrValueBlob);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    DWORD cFilename = 0;
    LPCSTR rgpszFilename[MAX_FILENAME_CNT];
    LPCSTR pszTestName = NULL;
    DWORD cAttrOID = 0;
    LPCSTR rgpszAttrOID[MAX_ATTR_CNT];
    CRYPT_DER_BLOB rgAttrEncodedOIDBlob[MAX_ATTR_CNT];
    BYTE rgbEncodedOID[MAX_ATTR_CNT][MAX_ENCODED_OID_LEN];


    int iStatus = 0;


    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "Content")) {
                fContent = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "MD5")) {
                HashAlgId = CALG_MD5;
            } else {
                switch(argv[0][1])
                {
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'q':
                    fQuiet = TRUE;
                    if (argv[0][2])
                        lQuietErr = (LONG) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'a':
                    if (MAX_ATTR_CNT <= cAttrOID) {
                        printf("Too many Attribute OIDs\n");
                        goto BadUsage;
                    }
                    rgpszAttrOID[cAttrOID] = argv[0]+2;
                    rgAttrEncodedOIDBlob[cAttrOID].cbData = MAX_ENCODED_OID_LEN;
                    rgAttrEncodedOIDBlob[cAttrOID].pbData =
                        rgbEncodedOID[cAttrOID];
                    if (!DotToEncodedOID(
                            rgpszAttrOID[cAttrOID],
                            rgAttrEncodedOIDBlob[cAttrOID].pbData,
                            &rgAttrEncodedOIDBlob[cAttrOID].cbData
                            )) {
                        printf("Invalid OID: %s\n", rgpszAttrOID[cAttrOID]);
                        goto BadUsage;
                    }

                    cAttrOID++;
                    break;
                case 'A':
                    cbFirstAttrLen = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszTestName == NULL)
                pszTestName = argv[0];
            else if (cFilename < MAX_FILENAME_CNT)
                rgpszFilename[cFilename++] = argv[0];
            else {
                printf("Too many Filenames\n");
                goto BadUsage;
            }
        }
    }

    if (NULL == pszTestName) {
        printf("Missing TestName\n");
        goto BadUsage;
    }

    if (0 == cFilename) {
        printf("Missing Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (0 == _stricmp(pszTestName, "Data"))
        fResult = TestData(rgpszFilename[0]);
    else if (0 == _stricmp(pszTestName, "Cert"))
        fResult = TestCert(rgpszFilename[0]);
    else if (0 == _stricmp(pszTestName, "Certs"))
        fResult = TestCerts(rgpszFilename[0]);
    else if (0 == _stricmp(pszTestName, "File"))
        fResult = TestFile(
            rgpszFilename[0],
            cAttrOID,
            rgpszAttrOID,
            rgAttrEncodedOIDBlob
            );
            
    else if (0 == _stricmp(pszTestName, "Cat"))
        fResult = TestCat(
            cFilename,
            rgpszFilename,
            cAttrOID,
            rgpszAttrOID,
            rgAttrEncodedOIDBlob
            );
    else {
        printf("Invalid TestName\n");
        goto BadUsage;
    }

    if (!fResult)
        goto ErrorReturn;

    printf("Passed\n");
    iStatus = 0;

CommonReturn:
    return iStatus;

ErrorReturn:
    iStatus = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\test\tminver\testutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       testutil.h
//
//  Contents:   Test Utility API Prototypes and Definitions
//
//  History:    29-Jan-01   philh   created
//--------------------------------------------------------------------------

#ifndef __TEST_UTIL_H__
#define __TEST_UTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "wincrypt.h"
#include "minasn1.h"
#include "mincrypt.h"

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
VOID
PrintErr(
    IN LPCSTR pszMsg,
    IN LONG lErr
    );

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
TestAlloc(
    IN size_t cbBytes
    );

VOID
TestFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string. TestFree()
//  must be called to free the returned wide string.
//--------------------------------------------------------------------------
LPWSTR
AllocAndSzToWsz(
    IN LPCSTR psz
    );


//+-------------------------------------------------------------------------
//  Conversions functions between encoded OID and the dot string
//  representation
//--------------------------------------------------------------------------
#define MAX_OID_STRING_LEN          0x80
#define MAX_ENCODED_OID_LEN         0x80

BOOL
EncodedOIDToDot(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    OUT CHAR rgszOID[MAX_OID_STRING_LEN]
    );

BOOL
DotToEncodedOID(
    IN LPCSTR pszOID,
    OUT BYTE rgbEncodedOID[MAX_ENCODED_OID_LEN],
    OUT DWORD *pcbEncodedOID
    );

//+-------------------------------------------------------------------------
//  Functions to print bytes
//--------------------------------------------------------------------------
VOID
PrintBytes(
    IN PCRYPT_DER_BLOB pBlob
    );

VOID
PrintMultiLineBytes(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pBlob
    );

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
ReadDERFromFile(
    IN LPCSTR  pszFileName,
    OUT PBYTE   *ppbDER,
    OUT PDWORD  pcbDER
    );

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
WriteDERToFile(
    IN LPCSTR  pszFileName,
    IN PBYTE   pbDER,
    IN DWORD   cbDER
    );

//+-------------------------------------------------------------------------
//  Display functions
//--------------------------------------------------------------------------


VOID
DisplayCert(
    IN CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT],
    IN BOOL fVerbose = FALSE
    );

VOID
DisplayName(
    IN PCRYPT_DER_BLOB pNameValueBlob
    );

VOID
DisplayExts(
    IN PCRYPT_DER_BLOB pExtsValueBlob
    );

VOID
DisplayCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    IN BOOL fVerbose = FALSE
    );

VOID
DisplayAttrs(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\mincrypt\test\tminver\testutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       testutil.cpp

//  Contents:   Test Utility API Prototypes and Definitions
//
//  History:    29-Jan-01   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "testutil.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

#define TESTUTIL_MAX_EXT_CNT    30
#define TESTUTIL_MAX_ATTR_CNT   30


//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
VOID
PrintErr(
    IN LPCSTR pszMsg,
    IN LONG lErr
    )
{
    printf("%s failed => 0x%x (%d) \n", pszMsg, lErr, lErr);
}

VOID
PrintLastError(
    IN LPCSTR pszMsg
    )
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
TestAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        PrintErr("TestAlloc", (LONG) GetLastError());
    return pv;
}

VOID
TestFree(
    IN LPVOID pv
    )
{
    if (pv)
        free(pv);
}


CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string. TestFree()
//  must be called to free the returned wide string.
//--------------------------------------------------------------------------
LPWSTR
AllocAndSzToWsz(
    IN LPCSTR psz
    )
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR)TestAlloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    printf("failed => Bad AllocAndSzToWsz");
failed:
    if (pwsz) {
        TestFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}


//+-------------------------------------------------------------------------
//  Conversions functions between encoded OID and the dot string
//  representation
//--------------------------------------------------------------------------
#define MAX_OID_STRING_LEN          0x80
#define MAX_ENCODED_OID_LEN         0x80

//  Encoded Attribute
//
//  Attribute ::= SEQUENCE {
//      type       EncodedObjectID,
//      values     AttributeSetValue
//  } --#public--
//
//  AttributeSetValue ::= SET OF NOCOPYANY


BOOL
EncodedOIDToDot(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    OUT CHAR rgszOID[MAX_OID_STRING_LEN]
    )
{
    BOOL fResult;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;
    BYTE rgbEncodedAttr[MAX_ENCODED_OID_LEN];
    PCRYPT_ATTRIBUTE pAttr = NULL;
    DWORD cbAttr;

    // Convert the OID into an encoded Attribute that we can
    // decode to get the OID string.
    if (0 == cbOID || MAX_OID_STRING_LEN  - 6 < cbOID) {
        strcpy(rgszOID, "Invalid OID length");
        return FALSE;
    }

    rgbEncodedAttr[0] = MINASN1_TAG_SEQ;
    rgbEncodedAttr[1] = (BYTE) (2 + cbOID + 2);
    rgbEncodedAttr[2] = MINASN1_TAG_OID;
    rgbEncodedAttr[3] = (BYTE) cbOID;
    memcpy(&rgbEncodedAttr[4], pbOID, cbOID);
    rgbEncodedAttr[4 + cbOID + 0] = MINASN1_TAG_SET;
    rgbEncodedAttr[4 + cbOID + 1] = 0;

    if (!CryptDecodeObjectEx(
            X509_ASN_ENCODING,
            PKCS_ATTRIBUTE,
            rgbEncodedAttr,
            2 + 2 + cbOID + 2,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pAttr,
            &cbAttr
            )) {
        strcpy(rgszOID, "Decode OID failed");
        return FALSE;
    }

    if (strlen(pAttr->pszObjId) >= MAX_OID_STRING_LEN) {
        strcpy(rgszOID, "Invalid OID length");
        fResult = FALSE;
    } else {
        strcpy(rgszOID, pAttr->pszObjId);
        fResult = TRUE;
    }

    TestFree(pAttr);
    return fResult;
}

const BYTE rgbSeqTag[] = {MINASN1_TAG_SEQ, 0};
const BYTE rgbOIDTag[] = {MINASN1_TAG_OID, 0};

const MINASN1_EXTRACT_VALUE_PARA rgExtractAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,
    //   1 - type EncodedObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        0, rgbOIDTag,
};

#define ATTR_VALUE_COUNT            \
    (sizeof(rgExtractAttrPara) / sizeof(rgExtractAttrPara[0]))

BOOL
DotToEncodedOID(
    IN LPCSTR pszOID,
    OUT BYTE rgbEncodedOID[MAX_ENCODED_OID_LEN],
    OUT DWORD *pcbEncodedOID
    )
{
    BOOL fResult;
    CRYPT_ATTRIBUTE Attr;
    BYTE rgbEncoded[512];
    DWORD cbEncoded;
    CRYPT_DER_BLOB rgValueBlob[1];
    DWORD cValue;
    DWORD i;
    BYTE *pb;
    DWORD cb;

    // Encode an Attribute that only has the OID.
    Attr.pszObjId = (LPSTR) pszOID;
    Attr.cValue = 0;
    Attr.rgValue = NULL;

    cbEncoded = sizeof(rgbEncoded);
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            PKCS_ATTRIBUTE,
            &Attr,
            rgbEncoded,
            &cbEncoded
            )) {
        printf("\n");
        printf("Asn1Encode(%s)", pszOID);
        PrintLastError("");
        goto ErrorReturn;
    }

    cValue = ATTR_VALUE_COUNT;
    if (0 >= MinAsn1ExtractValues(
            rgbEncoded,
            cbEncoded,
            &cValue,
            rgExtractAttrPara,
            1,
            rgValueBlob
            )) {
        printf("Unable to encode OID: %s\n", pszOID);
        goto ErrorReturn;
    }

    pb = rgValueBlob[0].pbData;
    cb = rgValueBlob[0].cbData;

    if (0 == cb || MAX_ENCODED_OID_LEN < cb) {
        printf("Invalid length for OID: %s\n", pszOID);
        goto ErrorReturn;
    }
    memcpy(rgbEncodedOID, pb, cb);
    *pcbEncodedOID = cb;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbEncodedOID = 0;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Functions to print bytes
//--------------------------------------------------------------------------
VOID
PrintBytes(
    IN PCRYPT_DER_BLOB pBlob
    )
{
    DWORD cb = pBlob->cbData;
    BYTE *pb = pBlob->pbData;

    if (0 == cb) {
        printf(" No Bytes\n");
        return;
    }

    for (; 0 < cb; cb--, pb++)
        printf(" %02X", *pb);

    printf("\n");
}


#define CROW 16
VOID
PrintMultiLineBytes(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pBlob
    )
{
    DWORD cbSize = pBlob->cbData;
    BYTE *pb = pBlob->pbData;
    DWORD cb, i;

    if (cbSize == 0) {
        printf("%s No Bytes\n", pszHdr);
        return;
    }

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
ReadDERFromFile(
    IN LPCSTR  pszFileName,
    OUT PBYTE   *ppbDER,
    OUT PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = 0;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
WriteDERToFile(
    IN LPCSTR  pszFileName,
    IN PBYTE   pbDER,
    IN DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Display functions
//--------------------------------------------------------------------------


VOID
DisplayCert(
    IN CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT],
    IN BOOL fVerbose
    )
{
    if (0 != rgCertBlob[MINASN1_CERT_VERSION_IDX].cbData) {
        printf("Version:");
        PrintBytes(&rgCertBlob[MINASN1_CERT_VERSION_IDX]);
    }

    printf("Subject:");
    DisplayName(&rgCertBlob[MINASN1_CERT_SUBJECT_IDX]);

    printf("Issuer:");
    DisplayName(&rgCertBlob[MINASN1_CERT_ISSUER_IDX]);
    printf("SerialNumber:");
    PrintBytes(&rgCertBlob[MINASN1_CERT_SERIAL_NUMBER_IDX]);


    printf("NotBefore:\n");
    PrintMultiLineBytes("    ", &rgCertBlob[MINASN1_CERT_NOT_BEFORE_IDX]);
    printf("NotAfter:\n");
    PrintMultiLineBytes("    ", &rgCertBlob[MINASN1_CERT_NOT_AFTER_IDX]);


    if (0 != rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData) {
        printf("IssuerUniqueId:\n");
        PrintMultiLineBytes("    ",
            &rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX]);
    }

    if (0 != rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData) {
        printf("SubjectUniqueId:\n");
        PrintMultiLineBytes("    ",
            &rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX]);
    }

    if (fVerbose) {
        CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT];
        CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT];
        CRYPT_DER_BLOB rgPubKeyAlgIdBlob[MINASN1_ALGID_BLOB_CNT];
        CRYPT_DER_BLOB rgSignAlgIdBlob[MINASN1_ALGID_BLOB_CNT];


        if (0 >= MinAsn1ParsePublicKeyInfo(
                    &rgCertBlob[MINASN1_CERT_PUBKEY_INFO_IDX],
                    rgPubKeyInfoBlob
                    ) ||
            0 >= MinAsn1ParseAlgorithmIdentifier(
                    &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_ALGID_IDX],
                    rgPubKeyAlgIdBlob
                    ))
            printf("PublicKeyInfo: parse failed\n");
        else {
            CHAR rgszOID[MAX_OID_STRING_LEN];
            CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT];

            EncodedOIDToDot(&rgPubKeyAlgIdBlob[MINASN1_ALGID_OID_IDX],
                rgszOID);

            printf("PublicKeyInfo.Algorithm: %s\n", rgszOID);

            if (0 != rgPubKeyAlgIdBlob[MINASN1_ALGID_PARA_IDX].cbData) {
                printf("PublicKeyInfo.Algorithm.Parameters:\n");
                PrintMultiLineBytes("    ",
                    &rgPubKeyAlgIdBlob[MINASN1_ALGID_PARA_IDX]);
            }

            if (0 >= MinAsn1ParseRSAPublicKey(
                    &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX],
                    rgRSAPubKeyBlob
                    )) {
                printf("PublicKeyInfo.PublicKey:\n");
                PrintMultiLineBytes("    ",
                    &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX]);
            } else {
                DWORD dwByteLen;

                dwByteLen =
                    rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].cbData;
                if (0 < dwByteLen && 0 == rgRSAPubKeyBlob[
                            MINASN1_RSA_PUBKEY_MODULUS_IDX].pbData[0])
                    dwByteLen--;
                printf("PublicKeyInfo.RSAPublicKey.BitLength: %d\n",
                    dwByteLen * 8);

                printf("PublicKeyInfo.RSAPublicKey.Modulus:\n");
                PrintMultiLineBytes("    ",
                    &rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX]);
                printf("PublicKeyInfo.RSAPublicKey.Exponent:");
                PrintBytes(&rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX]);
            }
        }

        if ( 0 >= MinAsn1ParseAlgorithmIdentifier(
                    &rgCertBlob[MINASN1_CERT_SIGN_ALGID_IDX],
                    rgSignAlgIdBlob
                    ))
            printf("SignatureAlgorithm: parse failed\n");
        else {
            CHAR rgszOID[MAX_OID_STRING_LEN];
            EncodedOIDToDot(&rgSignAlgIdBlob[MINASN1_ALGID_OID_IDX],
                rgszOID);

            printf("Signature.Algorithm: %s\n", rgszOID);
            if (0 != rgSignAlgIdBlob[MINASN1_ALGID_PARA_IDX].cbData) {
                printf("Signature.Algorithm.Parameters:\n");
                PrintMultiLineBytes("    ",
                    &rgSignAlgIdBlob[MINASN1_ALGID_PARA_IDX]);
            }
        }

        printf("Signature.Content\n");
        PrintMultiLineBytes("    ", &rgCertBlob[MINASN1_CERT_SIGNATURE_IDX]);

        DisplayExts(&rgCertBlob[MINASN1_CERT_EXTS_IDX]);
    }
}

VOID
DisplayName(
    IN PCRYPT_DER_BLOB pNameValueBlob
    )
{
    WCHAR wszName[512];

    CertNameToStrW(
        X509_ASN_ENCODING,
        pNameValueBlob,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        wszName,
        512
        );

    printf(" <%S>\n", wszName);
}

VOID
DisplayExts(
    IN PCRYPT_DER_BLOB pExtsValueBlob
    )
{
    DWORD cExt;
    DWORD i;
    CRYPT_DER_BLOB rgrgExtBlob[TESTUTIL_MAX_EXT_CNT][MINASN1_EXT_BLOB_CNT];

    if (0 == pExtsValueBlob->cbData)
        return;

    cExt = TESTUTIL_MAX_EXT_CNT;
    if (0 >= MinAsn1ParseExtensions(
            pExtsValueBlob,
            &cExt,
            rgrgExtBlob
            )) {
        printf("Extensions: parse failed\n");
        return;
    }

    for (i = 0; i < cExt; i++) {
        CHAR rgszOID[MAX_OID_STRING_LEN];

        EncodedOIDToDot(&rgrgExtBlob[i][MINASN1_EXT_OID_IDX], rgszOID);
        printf("Extension[%d] %s  Critical: ", i, rgszOID);
        if (0 != rgrgExtBlob[i][MINASN1_EXT_CRITICAL_IDX].cbData &&
                0 != rgrgExtBlob[i][MINASN1_EXT_CRITICAL_IDX].pbData[0])
            printf("TRUE\n");
        else
            printf("FALSE\n");

        PrintMultiLineBytes("    ", &rgrgExtBlob[i][MINASN1_EXT_VALUE_IDX]);
    }
}

VOID
DisplayCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    IN BOOL fVerbose
    )
{
    CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT];

    if (0 >= MinAsn1ParseCTL(
            pEncodedContentBlob,
            rgCTLBlob
            )) {
        printf("CTL: parse failed\n");
        return;
    }

    if (0 != rgCTLBlob[MINASN1_CTL_VERSION_IDX].cbData) {
        printf("Version:");
        PrintBytes(&rgCTLBlob[MINASN1_CTL_VERSION_IDX]);
    }

    printf("SubjectUsage:\n");
    PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_SUBJECT_USAGE_IDX]);

    if (0 != rgCTLBlob[MINASN1_CTL_LIST_ID_IDX].cbData) {
        printf("ListIdentifier:\n");
        PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_LIST_ID_IDX]);
    }

    if (0 != rgCTLBlob[MINASN1_CTL_SEQUENCE_NUMBER_IDX].cbData) {
        printf("SequenceNumber:");
        PrintBytes(&rgCTLBlob[MINASN1_CTL_SEQUENCE_NUMBER_IDX]);
    }

    printf("ThisUpdate:\n");
    PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_THIS_UPDATE_IDX]);
    if (0 != rgCTLBlob[MINASN1_CTL_NEXT_UPDATE_IDX].cbData) {
        printf("NextUpdate:\n");
        PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_NEXT_UPDATE_IDX]);
    }

    printf("SubjectAlgorithmIdentifier:\n");
    PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_SUBJECT_ALGID_IDX]);

    if (fVerbose)
        DisplayExts(&rgCTLBlob[MINASN1_CTL_EXTS_IDX]);

    if (0 != rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX].cbData) {
        DWORD cbEncoded;
        const BYTE *pbEncoded;
        DWORD i;

        printf("\n");

        // Advance past the Subjects' outer tag and length
        if (0 >= MinAsn1ExtractContent(
                rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX].pbData,
                rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX].cbData,
                &cbEncoded,
                &pbEncoded
                )) {
            printf("Subjects: parse failed\n");
            return;
        }



        // Loop through the encoded subjects
        for (i = 0; 0 != cbEncoded; i++) {
            LONG cbSubject;
            CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT];

            printf("----  Subject[%d]  ----\n", i);

            cbSubject = MinAsn1ParseCTLSubject(
                pbEncoded,
                cbEncoded,
                rgCTLSubjectBlob
                );
            if (0 >= cbSubject) {
                printf("Subject: parse failed\n");
                return;
            }

            printf("Identifier:\n");
            PrintMultiLineBytes("    ",
                &rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ID_IDX]);

            if (fVerbose) {
                DisplayAttrs("",
                    &rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ATTRS_IDX]);
                printf("\n");
            }

            pbEncoded += cbSubject;
            cbEncoded -= cbSubject;
        }
    }
}

VOID
DisplayAttrs(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    )
{
    DWORD cAttr;
    DWORD i;
    CRYPT_DER_BLOB rgrgAttrBlob[TESTUTIL_MAX_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];

    if (0 == pAttrsValueBlob->cbData)
        return;

    cAttr = TESTUTIL_MAX_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob
            )) {
        printf("%sAttributes: parse failed\n", pszHdr);
        return;
    }

    for (i = 0; i < cAttr; i++) {
        CHAR rgszOID[MAX_OID_STRING_LEN];

        EncodedOIDToDot(&rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX], rgszOID);
        printf("%sAttribute[%d] %s:\n", pszHdr, i, rgszOID);
        PrintMultiLineBytes("    ", &rgrgAttrBlob[i][MINASN1_ATTR_VALUE_IDX]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\adhelpers.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ADHelpers.cpp

  Content: Implementation of helper routines for accessing Active Directory.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "resource.h"
#include <activeds.h>


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadFromDirectory

  Synopsis : Load all certificates from the userCertificate attribute of users
             specified through the filter.

  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.
                                     
             BSTR bstrFilter - Filter (See Store::Open() for more info).

  Remark   : 

------------------------------------------------------------------------------*/

HRESULT LoadFromDirectory (HCERTSTORE hCertStore, 
                           BSTR       bstrFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\algorithm.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Algorithm.cpp

  Content: Implementation of CAlgorithm.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Algorithm.h"
#include "Common.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAlgorithmObject

  Synopsis : Create an IAlgorithm object.

  Parameter: IAlgorithm ** ppIAlgorithm - Pointer to pointer to IAlgorithm 
                                          to receive the interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAlgorithmObject (IAlgorithm ** ppIAlgorithm)
{
    HRESULT hr = S_OK;
    CComObject<CAlgorithm> * pCAlgorithm = NULL;

    DebugTrace("Entering CreateAlgorithmObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIAlgorithm);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CAlgorithm>::CreateInstance(&pCAlgorithm)))
        {
            DebugTrace("Error [%#x]: CComObject<CAlgorithm>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCAlgorithm->QueryInterface(ppIAlgorithm)))
        {
            DebugTrace("Error [%#x]: pCAlgorithm->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateAlgorithmObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCAlgorithm)
    {
        delete pCAlgorithm;
    }

    goto CommonExit;
}


///////////////////////////////////////////////////////////////////////////////
//
// CAlgorithm
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::get_Name

  Synopsis : Return the enum name of the algorithm.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM * pVal - Pointer to 
                                                   CAPICOM_ENCRYPTION_ALGORITHM 
                                                   to receive result.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::get_Name (CAPICOM_ENCRYPTION_ALGORITHM * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_Name;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm:get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::put_Name

  Synopsis : Set algorithm enum name.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM newVal - Algorithm enum name.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::put_Name (CAPICOM_ENCRYPTION_ALGORITHM newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::put_Name().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure algo is valid.
    //
    switch (newVal)
    {
        case CAPICOM_ENCRYPTION_ALGORITHM_RC2:
        case CAPICOM_ENCRYPTION_ALGORITHM_RC4:
        case CAPICOM_ENCRYPTION_ALGORITHM_DES:
        {
            //
            // These do not require Enhanced or Strong provider,
            // so no need to check present of high encryption pack.
            //
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_3DES:
        {
            HCRYPTPROV hCryptProv = NULL;

            //
            // For 3DES, need either Enhanced or Strong provider.
            //
            if (FAILED(::AcquireContext(MS_ENHANCED_PROV_A, 
                                        NULL, 
                                        CRYPT_VERIFYCONTEXT, 
                                        &hCryptProv)) &&
                FAILED(::AcquireContext(MS_STRONG_PROV_A, 
                                        NULL, 
                                        CRYPT_VERIFYCONTEXT, 
                                        &hCryptProv)))
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 3DES encryption is not available.\n");
                goto ErrorExit;
            }

            ::ReleaseContext(hCryptProv);
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;

            DebugTrace("Error: invalid parameter, unknown algorithm enum name.\n");
            goto ErrorExit;
        }
    }

    //
    // Store name.
    //
    m_Name = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm::put_Name().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::get_KeyLength

  Synopsis : Return the enum name of the key length.

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH * pVal - Pointer to 
                                                    CAPICOM_ENCRYPTION_KEY_LENGTH 
                                                    to receive result.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::get_KeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::get_KeyLength().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_KeyLength;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm:get_KeyLength().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::put_KeyLength

  Synopsis : Set key length enum name.

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH newVal - Key length enum name.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::put_KeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::put_KeyLength().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Determine key length requested.
    //
    switch (newVal)
    {
        case CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM:
        case CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS:
        case CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS:
        {
            //
            // These do not require Enhanced or Strong provider,
            // so no need to check present of high encryption pack.
            //
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS:
        {
            HCRYPTPROV hCryptProv = NULL;

            //
            // For 128-bits, need either Enhanced or Strong provider.
            //
            if (FAILED(::AcquireContext(MS_ENHANCED_PROV_A, 
                                        NULL, 
                                        CRYPT_VERIFYCONTEXT, 
                                        &hCryptProv)) &&
                FAILED(::AcquireContext(MS_STRONG_PROV_A, 
                                        NULL, 
                                        CRYPT_VERIFYCONTEXT, 
                                        &hCryptProv)))
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 128-bits encryption is not available.\n");
                goto ErrorExit;
            }

            ::ReleaseContext(hCryptProv);

            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_KEY_LENGTH;

            DebugTrace("Error: invalid parameter, unknown key length enum name.\n");
            goto ErrorExit;
        }
    }

    //
    // Store name.
    //
    m_KeyLength = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm::put_KeyLength().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\adhelpers.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ADHelpers.cpp

  Content: Implementation of helper routines for accessing Active Directory.
           Functions in this module require DSClient installed for down level
           clients.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "ADHelpers.h"
#include "Settings.h"


////////////////////
//
// Local typedefs
//

typedef HRESULT (*PADSOPENOBJECT)(LPWSTR lpszPathName, 
                                  LPWSTR lpszUserName, 
                                  LPWSTR lpszPassword, 
                                  DWORD dwReserved, 
                                  REFIID riid, 
                                  VOID FAR * FAR *ppObject);

typedef HRESULT (* PADSBUILDENUMERATOR)(IADsContainer *pADsContainer, 
                                        IEnumVARIANT **ppEnumVariant);

typedef HRESULT (* PADSENUMERATENEXT)(IEnumVARIANT *pEnumVariant, 
                                      ULONG cElements, 
                                      VARIANT FAR *pvar, 
                                      ULONG FAR *pcElementsFetched);

typedef HRESULT (* PADSFREEENUMERATOR)(IEnumVARIANT *pEnumVariant);


////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsUserCertificateInGC

  Synopsis : Determine if the userCertificate attribute is replicated in the GC.

  Parameter: HMODULE hDLL - ActiveDS.DLL handle.
  
             BOOL * pbResult - Pointer to BOOL to receive result.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT IsUserCertificateInGC (HMODULE hDLL, 
                                      BOOL  * pbResult)
{
    HRESULT             hr         = S_OK;
    IADs              * pIADs      = NULL;
    IDirectorySearch  * pISchema   = NULL;  
    CComBSTR            bstrPath   = L"LDAP://";
    LPOLESTR            pszList[]  = {L"lDAPDisplayName", L"isMemberOfPartialAttributeSet"};
    LPOLESTR            pszFilter  = L"(&(objectCategory=attributeSchema)(lDAPDisplayName=userCertificate))";
    ADS_SEARCH_HANDLE   hSearch    = NULL;
    DWORD               dwNumPrefs = 1;
    ADS_SEARCHPREF_INFO SearchPrefs;
    CComVariant         var;
    PADSOPENOBJECT      pADsOpenObject;

    static BOOL bResult  = FALSE;
    static BOOL bChecked = FALSE;

    DebugTrace("Entering IsUserCertificateInGC().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hDLL);
    ATLASSERT(pbResult);

    //
    // If we had already checked once, use the cached result.
    //
    if (bChecked)
    {
        *pbResult = bResult;
        goto CommonExit;
    }

    //
    // Get ADsOpenObject address pointer.
    //
    if (!(pADsOpenObject = (PADSOPENOBJECT) ::GetProcAddress(hDLL, "ADsOpenObject")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsOpenObject().\n", hr);
        goto ErrorExit;
    }

    //
    // Bind to rootDSE to get the schemaNamingContext property.
    //
    if (FAILED(hr = pADsOpenObject(L"LDAP://rootDSE",
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IADs,
                                   (void **) &pIADs)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IADs.\n", hr);
        goto ErrorExit;
    }

    //
    // Get schema container path.
    //
	if (FAILED(hr = pIADs->Get(L"schemaNamingContext", &var)))
	{
        DebugTrace("Error [%#x]: pIADs->Get() failed.\n", hr);
        goto ErrorExit;
    }
    //
    // Build path to the schema container.
    //
    bstrPath.AppendBSTR(var.bstrVal);

    //
    // Bind to the actual schema container.
    //
    if (FAILED(hr = pADsOpenObject(bstrPath, 
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IDirectorySearch, 
                                   (void **) &pISchema)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IDirectorySearch.\n", hr);
        goto ErrorExit;
    }

    //
    // Attributes are one-level deep in the Schema container so only 
    // need to search one level.
    //
	SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
	SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
	SearchPrefs.vValue.Integer = ADS_SCOPE_ONELEVEL;

    //
    // Set the search preference.
    //
    if (FAILED(hr = pISchema->SetSearchPreference(&SearchPrefs, dwNumPrefs)))
    {
        DebugTrace("Error [%#x]: pISchema->SetSearchPreference() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Execute search.
    //
    if (FAILED(hr = pISchema->ExecuteSearch(pszFilter,
	                                        pszList,
							                sizeof(pszList) / sizeof(LPOLESTR),
							                &hSearch)))
    {
        DebugTrace("Error [%#x]: pISchema->ExecuteSearch() failed.\n", hr);
        goto ErrorExit;
    }
                                            
    //
    // Retrieve first row of data.
    //
	if (FAILED(hr = pISchema->GetFirstRow(hSearch)))
    {
        DebugTrace("Error [%#x]: pISchema->GetFirstRow() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Loop until no more row.
    //
    while (S_ADS_NOMORE_ROWS != hr)
    {
    	ADS_SEARCH_COLUMN Column;

        //
        // Get the lDAPDisplayName column.
        //
        if (FAILED(hr = pISchema->GetColumn(hSearch, 
                                            L"lDAPDisplayName", 
                                            &Column)))
        {

            DebugTrace("Error [%#x]: pISchema->GetColumn() failed.\n", hr);
            goto ErrorExit;
        }

        DebugTrace("%ls = %ls\n", Column.pszAttrName, Column.pADsValues->CaseIgnoreString);

        //
        // Is this attributeSchema for userCertificate?
        //
        if (0 == ::lstrcmpW(L"userCertificate", Column.pADsValues->CaseIgnoreString))
        {
            pISchema->FreeColumn(&Column);

            //
            // Get the isMemberOfPartialAttributeSet column.
            //
            if (FAILED(hr = pISchema->GetColumn(hSearch, 
                                                L"isMemberOfPartialAttributeSet", 
                                                &Column)))
            {

                DebugTrace("Error [%#x]: pISchema->GetColumn() failed.\n", hr);
                goto ErrorExit;
            }

 	        bResult = Column.pADsValues->Boolean;

            //
            // Should only have one row, so we don't really have to
            // break here, but is a little more effiecit to break,
            // since we don't need to ask for the next row to terminate
            // the loop.
            //
            pISchema->FreeColumn(&Column);

            break;
        }

        pISchema->FreeColumn(&Column);

        //
        // Get next row.
        //
        hr = pISchema->GetNextRow(hSearch);
    }

    //
    // Reset hr.
    //
    hr = S_OK;

    //
    // Return result to caller.
    //
    *pbResult = bResult;

CommonExit:
    //
    // Free resource.
    //
    if (hSearch)
    {
        pISchema->CloseSearchHandle(hSearch);
    }

    if (pISchema)
    {
        pISchema->Release();
    }
    if (pIADs)
    {
        pIADs->Release();
    }

    DebugTrace("Leaving IsUserCertificateInGC().\n");
    
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildRootDSESearch

  Synopsis : Build a search container of the rootDSE.

  Parameter: HMODULE hDLL - ActiveDS.DLL handle.
  
             IDirectorySearch ** ppISearch - To receive container to search.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT BuildRootDSESearch (HMODULE             hDLL, 
                                   IDirectorySearch ** ppISearch)
{
    HRESULT  hr       = S_OK;
    IADs   * pIADs    = NULL;
    CComBSTR bstrPath = L"LDAP://";

    PADSOPENOBJECT pADsOpenObject;
    CComVariant    var;

    DebugTrace("Entering BuildRootDSESearch().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hDLL);
    ATLASSERT(ppISearch);

    //
    // Get ADsOpenObject address pointer.
    //
    if (!(pADsOpenObject = (PADSOPENOBJECT) ::GetProcAddress(hDLL, "ADsOpenObject")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsOpenObject().\n", hr);
        goto ErrorExit;
    }

    //
    // Get rootDSE.
    //
    if (FAILED(hr = pADsOpenObject(L"LDAP://rootDSE",
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IADs,
                                   (void **) &pIADs)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IADs.\n", hr);
        goto ErrorExit;
    }

    //
    // Get current user's domain container DN.
    //
	if (FAILED(hr = pIADs->Get(L"defaultNamingContext", &var)))
	{
        DebugTrace("Error [%#x]: pIADs->Get() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Build path to the domain container.
    //
    bstrPath.AppendBSTR(var.bstrVal);

    //
    // Get IDerictorySearch interface pointer.
    //
    if (FAILED(hr = pADsOpenObject(bstrPath,
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IDirectorySearch,
                                   (void **) ppISearch)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IDirectorySearch.\n", hr);
        goto ErrorExit;
	}

CommonExit:
    //
    // Free resource.
    //
    if (pIADs)
    {
        pIADs->Release();
    }

    DebugTrace("Leaving BuildRootDSESearch().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildGlobalCatalogSearch

  Synopsis : Build a search container of the GC.

  Parameter: HMODULE hDLL - ActiveDS.DLL handle.
  
             IDirectorySearch ** ppISearch - To receive container to search.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT BuildGlobalCatalogSearch (HMODULE             hDLL, 
                                         IDirectorySearch ** ppISearch)
{
    HRESULT         hr          = S_OK;
    IEnumVARIANT  * pIEnum      = NULL;
    IADsContainer * pIContainer = NULL;
    IDispatch     * pIDispatch  = NULL;
    ULONG           lFetched    = 0;

    PADSOPENOBJECT      pADsOpenObject      = NULL;
    PADSBUILDENUMERATOR pADsBuildEnumerator = NULL;
    PADSENUMERATENEXT   pADsEnumerateNext   = NULL;
    PADSFREEENUMERATOR  pADsFreeEnumerator  = NULL;
    CComVariant         var;

    DebugTrace("Entering BuildGlobalCatalogSearch().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hDLL);
    ATLASSERT(ppISearch);

    //
    // Initialize.
    //
    *ppISearch = NULL;
    ::VariantInit(&var);

    //
    // Get ADs function address pointers.
    //
    if (!(pADsOpenObject = (PADSOPENOBJECT) ::GetProcAddress(hDLL, "ADsOpenObject")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsOpenObject().\n", hr);
        goto ErrorExit;
    }
    if (!(pADsBuildEnumerator = (PADSBUILDENUMERATOR) ::GetProcAddress(hDLL, "ADsBuildEnumerator")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsBuildEnumerator().\n", hr);
        goto ErrorExit;
    }
    if (!(pADsEnumerateNext = (PADSENUMERATENEXT) ::GetProcAddress(hDLL, "ADsEnumerateNext")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsEnumerateNext().\n", hr);
        goto ErrorExit;
    }
    if (!(pADsFreeEnumerator = (PADSFREEENUMERATOR) ::GetProcAddress(hDLL, "ADsFreeEnumerator")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsFreeEnumerator().\n", hr);
        goto ErrorExit;
    }

    //
    // First, bind to the GC: namespace container object. The "real" GC DN 
    // is a single immediate child of the GC: namespace, which must be
    // obtained using enumeration.
    //
    if (FAILED(hr = pADsOpenObject(L"GC:",
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IADsContainer,
                                   (void **) &pIContainer)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IADsContainer.\n", hr);
        goto ErrorExit;
    } 

    //
    // Fetch an enumeration interface for the GC container. 
    //
    if (FAILED(hr = pADsBuildEnumerator(pIContainer, &pIEnum)))
    {
        DebugTrace("Error [%#x]: ADsBuildEnumerator() failed.\n", hr);
        goto ErrorExit;
    } 

    //
    // Now enumerate.
    //
    if (FAILED(hr = pADsEnumerateNext(pIEnum, 1, &var, &lFetched)))
    {
        DebugTrace("Error [%#x]: ADsEnumerateNext() failed.\n", hr);
        goto ErrorExit;
    } 

    //
    // There should only be one child in the GC object.
    //
    if ((S_OK != hr) || (1 != lFetched))
    {
        hr = E_UNEXPECTED;

        DebugTrace("Unexpected error: ADsEnumerateNext() failed to return the expected child object.\n");
        goto ErrorExit;
    }

    //
    // Obtain the IDispatch pointer.
    //
    pIDispatch = V_DISPATCH(&var);

    //
    // Return IDirectorySearch interface pointer to caller.
    //
    if (FAILED(hr = pIDispatch->QueryInterface(IID_IDirectorySearch, 
                                               (void **) ppISearch)))
    {
        DebugTrace("Error [%#x]: pIDispatch->QueryInterface() failed for IID_IDirectorySearch.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pADsFreeEnumerator && pIEnum)
    {
        pADsFreeEnumerator(pIEnum);
    }
    if (pIContainer)
    {
        pIContainer->Release();
    }
    
    DebugTrace("Leaving BuildGlobalCatalogSearch().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildADSearch

  Synopsis : Build a search container. We will first check to see if the
             userCertificate attribute is replicated in the global catalog.
             If so, we will bind the search to the GC, otherwise, will bind
             to default domain.

  Parameter: IDirectorySearch ** ppISearch - To receive container to search.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT BuildADSearch (IDirectorySearch ** ppISearch)
{
    HRESULT hr      = S_OK;
    BOOL    bResult = FALSE;
    HMODULE hDLL    = NULL;
    CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION SearchLocation = ActiveDirectorySearchLocation();

    DebugTrace("Entering BuildADSearch().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppISearch);

    //
    // Initialize.
    //
    *ppISearch = NULL;

    //
    // Load ActiveDS.DLL.
    //
    if (!(hDLL = ::LoadLibrary("ActiveDS.DLL")))
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: DSClient not installed.\n");
        goto ErrorExit;
    }

    //
    // Did user specify a search location?
    //
    if (CAPICOM_SEARCH_ANY == SearchLocation)
    {
        //
        // No, so determine if userCerticate is replicated in the GC.
        //
        if (FAILED(hr = ::IsUserCertificateInGC(hDLL, &bResult)))
        {
            DebugTrace("Error [%#x]: IsUserCertificateInGC() failed.\n", hr);
            goto ErrorExit;
        } 

        //
        // Search GC or default domain.
        //
        SearchLocation = bResult ? CAPICOM_SEARCH_GLOBAL_CATALOG : CAPICOM_SEARCH_DEFAULT_DOMAIN;
    }

    //
    // Check to see where to search.
    //
    if (CAPICOM_SEARCH_GLOBAL_CATALOG == SearchLocation)
    {
        //
        // GC.
        //
        hr = ::BuildGlobalCatalogSearch(hDLL, ppISearch);
    } 
    else
    {
        //
        // rootDSE (default domain).
        //
        hr = ::BuildRootDSESearch(hDLL, ppISearch);
    }

CommonExit:
    //
    // Free resource.
    //
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    DebugTrace("Leaving BuildADSearch().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadUserCertificates

  Synopsis : Load all certificates from the userCertificate attribute of the
             specified search container for users specified through the filter.

  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.

             IDirectorySearch * pIContainer - Container to search.

             BSTR bstrFilter - Filter (See Store::Open() for more info).

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT LoadUserCertificates (HCERTSTORE         hCertStore,
                                     IDirectorySearch * pIContainer, 
                                     LPOLESTR           pszFilter)
{
    HRESULT           hr               = S_OK;
    ADS_SEARCH_HANDLE hSearch          = NULL;
	LPOLESTR          pszSearchList[]  = {L"userCertificate"};
    CComBSTR          bstrSearchFilter = L"(&(objectClass=user)(objectCategory=person)";
    ADS_SEARCHPREF_INFO SearchPrefs;

    DebugTrace("Entering LoadUserCertificates().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    ATLASSERT(pIContainer);
    ATLASSERT(pszFilter);

    try
    {
        //
        // Specify subtree search.
        //
        SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
        SearchPrefs.vValue.Integer = ADS_SCOPE_SUBTREE;
 
        //
        // Set the search preference.
        //
        if (FAILED(hr = pIContainer->SetSearchPreference(&SearchPrefs, 1)))
        {
            DebugTrace("Error [%#x]: pIContainer->SetSearchPreference() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Format the filter (use CComBSTR += operator to avoid
        // buffer overrun, abeit it is slower).
        //
        bstrSearchFilter += pszFilter;
        bstrSearchFilter += L")";

        //
        // Execute the search.
        //
        if (FAILED(hr = pIContainer->ExecuteSearch(bstrSearchFilter,
                                                   pszSearchList,
                                                   sizeof(pszSearchList)/sizeof(LPOLESTR),
                                                   &hSearch)))
        {
            DebugTrace("Error [%#x]: pIContainer->ExecuteSearch() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve first row of data.
        //
	    if (FAILED(hr = pIContainer->GetFirstRow(hSearch)))
        {
            DebugTrace("Error [%#x]: pIContainer->GetFirstRow() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Loop until no more row.
        //
        while (S_ADS_NOMORE_ROWS != hr)
        {
            DWORD dwValue;
        	ADS_SEARCH_COLUMN Column;

            //
            // Try to get the userCertificate attribute.
            //
            if (FAILED(hr = pIContainer->GetColumn(hSearch, L"userCertificate", &Column)))
            {
                if (E_ADS_COLUMN_NOT_SET == hr)
                {
                    //
                    // Get next row.
                    //
                    hr = pIContainer->GetNextRow(hSearch);
                    continue;
                }

                DebugTrace("Error [%#x]: pIContainer->GetColumn() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Import all the certificate values.
            //
            for (dwValue = 0; dwValue < Column.dwNumValues; dwValue++)
            {
                BOOL bResult;
                PCCERT_CONTEXT pCertContext = NULL;

                //
                // Create a context for the cert.
                //
                pCertContext = ::CertCreateCertificateContext(CAPICOM_ASN_ENCODING,
                                                              (const PBYTE) Column.pADsValues->OctetString.lpValue,
                                                              Column.pADsValues->OctetString.dwLength);
                if (!pCertContext)
                {
                    pIContainer->FreeColumn(&Column);

                    DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Add to the store.
                //
                bResult = ::CertAddCertificateContextToStore(hCertStore,
                                                             pCertContext,
                                                             CERT_STORE_ADD_USE_EXISTING,
                                                             NULL);
                //
                // Free context before checking for result.
                //
                ::CertFreeCertificateContext(pCertContext);

                if (!bResult)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    pIContainer->FreeColumn(&Column);

                    DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
                    goto ErrorExit;
                }
            }

            pIContainer->FreeColumn(&Column);

            //
            // Get next row.
            //
            hr = pIContainer->GetNextRow(hSearch);
        }

        //
        // Reset return code.
        //
        hr = S_OK;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (hSearch)
    {
        pIContainer->CloseSearchHandle(hSearch);
    }

    DebugTrace("Leaving LoadUserCertificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadFromDirectory

  Synopsis : Load all certificates from the userCertificate attribute of users
             specified through the filter.

  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.
                                     
             BSTR bstrFilter - Filter (See Store::Open() for more info).

  Remark   : 

------------------------------------------------------------------------------*/

HRESULT LoadFromDirectory (HCERTSTORE hCertStore, 
                           BSTR       bstrFilter)
{
    HRESULT hr   = S_OK;
    IDirectorySearch * pIContainerToSearch = NULL;

    DebugTrace("Entering LoadFromDirectory().\n");
    
    //
    // Sanity check.
    //
    ATLASSERT(bstrFilter);
    ATLASSERT(hCertStore);

    //
    // Build the AD search container.
    //   
    if (FAILED(hr = ::BuildADSearch(&pIContainerToSearch)))
    {
        DebugTrace("Error [%#x]: BuildADSearch() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Load all userCertificate of the specified filter.
    //
    if (FAILED(hr = ::LoadUserCertificates(hCertStore,
                                           pIContainerToSearch,
                                           bstrFilter)))
    {
        DebugTrace("Error [%#x]: LoadUserCertificates() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pIContainerToSearch)
    {
        pIContainerToSearch->Release();
    }

    DebugTrace("Leaving LoadFromDirectory().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\algorithm.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Algorithm.h

  Content: Declaration of the CAlgorithm.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
	
#ifndef __ALGORITHM_H_
#define __ALGORITHM_H_

#include "resource.h"       // main symbols
#include "Lock.h"
#include "Error.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAlgorithmObject

  Synopsis : Create an IAlgorithm object.

  Parameter: IAlgorithm ** ppIAlgorithm - Pointer to pointer to IAlgorithm 
                                          to receive the interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAlgorithmObject (IAlgorithm ** ppIAlgorithm);


////////////////////////////////////////////////////////////////////////////////
//
// CAlgorithm
//

class ATL_NO_VTABLE CAlgorithm : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAlgorithm, &CLSID_Algorithm>,
    public ICAPICOMError<CAlgorithm, &IID_IAlgorithm>,
	public IDispatchImpl<IAlgorithm, &IID_IAlgorithm, &LIBID_CAPICOM>
{
public:
	CAlgorithm()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAlgorithm)
	COM_INTERFACE_ENTRY(IAlgorithm)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CAlgorithm)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Algorithm object.\n", hr);
            return hr;
        }

        m_Name = CAPICOM_ENCRYPTION_ALGORITHM_RC2;
        m_KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IAlgorithm
//
public:
	STDMETHOD(get_KeyLength)
        (/*[out, retval]*/ CAPICOM_ENCRYPTION_KEY_LENGTH * pVal);

	STDMETHOD(put_KeyLength)
        (/*[in]*/ CAPICOM_ENCRYPTION_KEY_LENGTH newVal);

	STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_ENCRYPTION_ALGORITHM * pVal);

	STDMETHOD(put_Name)
        (/*[in]*/ CAPICOM_ENCRYPTION_ALGORITHM newVal);

private:
    CLock                         m_Lock;
    CAPICOM_ENCRYPTION_ALGORITHM  m_Name;
    CAPICOM_ENCRYPTION_KEY_LENGTH m_KeyLength;
};

#endif //__ALGORITHM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\attributes.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000.

  File:    Attributes.cpp

  Content: Implementation of CAttributes.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Attribute.h"
#include "Attributes.h"

#include <wincrypt.h>


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributesObject

  Synopsis : Create and initialize an IAttributes collection object.

  Parameter: CRYPT_ATTRIBUTES * pAttrbibutes - Pointer to attributes to be 
                                               added to the collection object.
  
             IAttributes ** ppIAttributes - Pointer to pointer to IAttributes 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributesObject (CRYPT_ATTRIBUTES * pAttributes,
                                IAttributes     ** ppIAttributes)
{
    HRESULT hr = S_OK;
    CComObject<CAttributes> * pCAttributes = NULL;

    DebugTrace("Entering CreateAttributesObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAttributes);
    ATLASSERT(ppIAttributes);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CAttributes>::CreateInstance(&pCAttributes)))
        {
            DebugTrace("Error [%#x]: CComObject<CAttributes>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCAttributes->Init(pAttributes)))
        {
            DebugTrace("Error [%#x]: pCAttributes->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IAttributes pointer to caller.
        //
        if (FAILED(hr = pCAttributes->QueryInterface(ppIAttributes)))
        {
            DebugTrace("Error [%#x]: pCAttributes->QueryInterface().\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateAttributesObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCAttributes)
    {
        delete pCAttributes;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CAttributes
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Add

  Synopsis : Add an Attribute to the collection.

  Parameter: IAttribute * pVal - Attribute to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Add (IAttribute * pVal)
{
    HRESULT           hr       = S_OK;

    DebugTrace("Entering CAttributes::Add().\n");

    try
    {
        char     szIndex[32];
        CComBSTR bstrIndex;

        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure we have a valid attribute object.
        //
        if (FAILED(hr = ::AttributeIsValid(pVal)))
        {
            DebugTrace("Error [%#x]: AttributeIsValid() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfA(szIndex, "%06u", m_coll.size() + 1);
        bstrIndex = szIndex;

        DebugTrace("Before adding to map: CAttributes.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pVal;

        DebugTrace("After adding to map: CAttributes.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttributes::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Remove

  Synopsis : Remove a Attribute from the collection.

  Parameter: long Val - Attribute index (1-based).

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Remove (long Val)
{
	HRESULT  hr = S_OK;
    WCHAR    wszIndex[32];
    CComBSTR bstrIndex;

    DebugTrace("Entering CAttributes::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if (Val > (long) m_coll.size())
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, Val is out of range.\n");
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfW(wszIndex, L"%06u", Val);
        bstrIndex = wszIndex;

        //
        // Remove object from map.
        //
        if (!m_coll.erase(bstrIndex))
        {
            hr = E_UNEXPECTED;

            DebugTrace("Unexpected error: m_coll.erase() failed.\n");
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttributes::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Clear

  Synopsis : Remove all attributes from the collection.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Clear (void)
{
	HRESULT hr = S_OK;

    DebugTrace("Entering CAttributes::Clear().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Clear it.
        //
        m_coll.clear();
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttributes::Clear().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Init

  Synopsis : Initialize the attributes collection object by adding all 
             individual attribute object to the collection.

  Parameter: CRYPT_ATTRIBUTES * pAttributes - Attribute to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Init (CRYPT_ATTRIBUTES * pAttributes)
{
    HRESULT  hr = S_OK;

    DebugTrace("Entering CAttributes::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAttributes);

    try
    {
        //
        // Create the IAttribute object for each of the supported attribute. 
        //
        for (DWORD cAttr= 0; cAttr < pAttributes->cAttr; cAttr++)
        {
            CComPtr<IAttribute> pIAttribute = NULL;

            //
            // Add only supported attribute.
            //
            if (::AttributeIsSupported(pAttributes->rgAttr[cAttr].pszObjId))
            {
                if (FAILED(hr = ::CreateAttributeObject(&pAttributes->rgAttr[cAttr], &pIAttribute)))
                {
                    DebugTrace("Error [%#x]: CreateAttributeObject() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = Add(pIAttribute)))
                {
                    DebugTrace("Error [%#x]: CAttributes::Add() failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CAttributes::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\base64.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Base64.cpp

  Contents:   Implementation of Base64 routines.

  Functions:  Encode
              Decode

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "Base64.h"
#include "Common.h"

#include <wincrypt.h>

#ifdef CAPICOM_BASE64_STRICT
#define BASE64_STRICT		// enforce syntax check on input data
#else
#undef BASE64_STRICT		// enforce syntax check on input data
#endif

// The following table translates an ascii subset to 6 bit values as follows
// (see RFC 1421 and/or RFC 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};

const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";

#define MOD4(x) ((x) & 3)

__inline BOOL _IsBase64WhiteSpace(IN TCHAR const ch)
{
    return(ch == TEXT(' ') ||
           ch == TEXT('\t') ||
           ch == TEXT('\r') ||
           ch == TEXT('\n'));
}

DWORD Base64DecodeA(IN TCHAR const    * pchIn,
                    IN DWORD            cchIn,
                    OPTIONAL OUT BYTE * pbOut,
                    IN OUT DWORD      * pcbOut)
{
    DWORD dwErr;
    DWORD cchInDecode, cbOutDecode;
    TCHAR const *pchInEnd;
    TCHAR const *pchInT;
    BYTE *pbOutT;

    //
    // Count the translatable characters, skipping whitespace & CR-LF chars.
    //
    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    dwErr = ERROR_INVALID_DATA;
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	    if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	    {
            //
	        // Found a non-base64 character.  Decide what to do.
            //
	        DWORD cch;

	        if (_IsBase64WhiteSpace(*pchInT))
	        {
		        continue;		// skip all whitespace
	        }

	        // The length calculation may stop in the middle of the last
	        // translation quantum, because the equal sign padding characters
	        // are treated as invalid input.  If the last translation quantum
	        // is not 4 bytes long, there must be 3, 2 or 1 equal sign(s).

	        if (0 != cchInDecode)
	        {
		        cch = MOD4(cchInDecode);
		        if (0 != cch)
		        {
		            cch = 4 - cch;
		            while (0 != cch && pchInT < pchInEnd && '=' == *pchInT)
		            {
			            pchInT++;
			            cch--;
		            }
		        }

                if (0 == cch)
		        {
		            break;
		        }
	        }

            DebugTrace("Error: %c is an invlaid base64 data.\n", *pchInT);
	        
            goto ErrorExit;
	    }
	    
        cchInDecode++;			// only count valid base64 chars
    }

    ATLASSERT(pchInT <= pchInEnd);

#ifdef BASE64_STRICT
    if (pchInT < pchInEnd)
    {
	    TCHAR const *pch;
	    DWORD cchEqual = 0;

	    for (pch = pchInT; pch < pchInEnd; pch++)
	    {
	        if (!_IsBase64WhiteSpace(*pch))
	        {
		        // Allow up to 3 extra trailing equal signs.
		        if (TEXT('=') == *pch && 3 > cchEqual)
		        {
		            cchEqual++;
		            continue;
		        }
    
                DebugTrace("Error: %c is an invalid trailing base64 data.\n", pch);

                goto ErrorExit;
	        }
	    }

#if _DEBUG
	    if (0 != cchEqual)
	    {
	        DebugTrace("Info: Ignoring trailing base64 data ===.\n");
	    }
#endif // _DEBUG
    }
#endif // BASE64_STRICT

    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.  Compensate for a fractional translation quantum.

    cbOutDecode = ((cchInDecode + 3) >> 2) * 3;
    switch (cchInDecode % 4)
    {
	    case 1:
	    case 2:
	        cbOutDecode -= 2;
	        break;

	    case 3:
	        cbOutDecode--;
	        break;
    }

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	    pbOutT += cbOutDecode;
    }
    else
    {
	    // Decode one quantum at a time: 4 bytes ==> 3 bytes
        if (cbOutDecode > *pcbOut)
        {
            *pcbOut = cbOutDecode;
            dwErr = ERROR_MORE_DATA;
            goto ErrorExit;
        }

	    pchInT = pchIn;
	    while (cchInDecode > 0)
	    {
	        DWORD i;
	        BYTE ab4[4];

	        ZeroMemory(ab4, sizeof(ab4));
	        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	        {
		        while (sizeof(abDecode) > (unsigned) *pchInT && 
                       63 < abDecode[*pchInT])
		        {
		            pchInT++;
		        }
		        
                ATLASSERT(pchInT < pchInEnd);
		        ab4[i] = (BYTE) *pchInT++;
	        }

	        // Translate 4 input characters into 6 bits each, and deposit the
	        // resulting 24 bits into 3 output bytes by shifting as appropriate.

	        // out[0] = in[0]:in[1] 6:2
	        // out[1] = in[1]:in[2] 4:4
	        // out[2] = in[2]:in[3] 2:6

	        *pbOutT++ = (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	        if (i > 2)
	        {
		        *pbOutT++ = (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	        }
	        if (i > 3)
	        {
		        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	        }
	        cchInDecode -= i;
	    }

	    ATLASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }

    *pcbOut = SAFE_SUBTRACT_POINTERS(pbOutT, pbOut);

    dwErr = ERROR_SUCCESS;

CommonExit:
    return dwErr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(ERROR_SUCCESS != dwErr);

    goto CommonExit;
}

// Encode a BYTE array into a Base64 text string.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.
// Do not add -----BEGIN/END headers -- that's also handled by the caller.

DWORD Base64EncodeA(IN BYTE const      * pbIn,
                    IN DWORD             cbIn,
                    IN DWORD             Flags,
                    OPTIONAL OUT TCHAR * pchOut,
                    IN OUT DWORD       * pcchOut)
{
    DWORD dwErr;
    TCHAR *pchOutT;
    DWORD cchOutEncode;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=	(fNoCR? 1 : 2) * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
    	pchOutT += cchOutEncode;
    }
    else
    {
    	DWORD cCol;

	    if (cchOutEncode > *pcchOut)
	    {
            *pcchOut = cchOutEncode;
	        dwErr = ERROR_MORE_DATA;
	        goto ErrorExit;
    	}

    	cCol = 0;
	    while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
    	{
	        BYTE ab3[3];

	        if (cCol == CB_BASE64LINEMAX/4)
	        {
		        cCol = 0;
		    
                if (!fNoCR)
		        {
		            *pchOutT++ = '\r';
		        }
		        *pchOutT++ = '\n';
	        }

	        cCol++;
	        ZeroMemory(ab3, sizeof(ab3));

	        ab3[0] = *pbIn++;
	        if (cbIn > 1)
	        {
		        ab3[1] = *pbIn++;
		        if (cbIn > 2)
		        {
		            ab3[2] = *pbIn++;
		        }
	        }

	        *pchOutT++ = abEncode[ab3[0] >> 2];
	        *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	        *pchOutT++ = (cbIn > 1)? abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	        *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	        cbIn -= 3;
	    }

	    // Append CR-LF only if there was input data

	    if (pchOutT != pchOut)
	    {
	        if (!fNoCR)
	        {
		        *pchOutT++ = '\r';
	        }
	        *pchOutT++ = '\n';
	    }

        ATLASSERT((DWORD) (pchOutT - pchOut) == cchOutEncode);
    }
    *pcchOut = SAFE_SUBTRACT_POINTERS(pchOutT, pchOut);

    dwErr = ERROR_SUCCESS;

CommonExit:
    return dwErr;

ErrorExit:
    ATLASSERT(ERROR_SUCCESS != dwErr);

    goto CommonExit;
}

DWORD Base64EncodeW(IN BYTE const * pbIn,
                    IN DWORD        cbIn,
                    IN DWORD        Flags,
                    OUT WCHAR     * wszOut,
                    OUT DWORD     * pcchOut)
{

    DWORD   cchOut;
    CHAR   *pch = NULL;
    DWORD   cch;
    DWORD   dwErr;

    ATLASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if (wszOut == NULL)
    {
        // get the number of characters
        *pcchOut = 0;
        dwErr = Base64EncodeA(pbIn, cbIn, Flags, NULL, pcchOut);
    }
    else // otherwise we have an output buffer
    {
        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        dwErr = ERROR_OUTOFMEMORY;
        pch = (CHAR *) malloc(cchOut);
        if (NULL != pch)
	    {
            dwErr = Base64EncodeA(pbIn, cbIn, Flags, pch, &cchOut);
	        if (ERROR_SUCCESS == dwErr)
	        {
    		    // should not fail!
        		cch = MultiByteToWideChar(0, 0, pch, cchOut, wszOut, *pcchOut);

		        // check to make sure we did not fail
		        ATLASSERT(*pcchOut == 0 || cch != 0);
	        }
	    }
    }

    if(pch != NULL)
    {
        free(pch);
    }

    return(dwErr);
}

DWORD Base64DecodeW(IN const WCHAR * wszIn,
                    IN DWORD         cch,
                    OUT BYTE       * pbOut,
                    OUT DWORD      * pcbOut)
{
    CHAR *pch;
    DWORD dwErr = ERROR_SUCCESS;

    // in all cases we need to convert to an ascii string
    // we know the ascii string is less
    if ((pch = (CHAR *) malloc(cch)) == NULL)
    {
        dwErr = ERROR_OUTOFMEMORY;
    }
    // we know no base64 wide char map to more than 1 ascii char
    else if (WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, NULL, NULL) == 0)
    {
        dwErr = ERROR_NO_DATA;
    }
    // get the length of the buffer
    else if (pbOut == NULL)
    {
        *pcbOut = 0;
        dwErr = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    // otherwise fill in the buffer
    else 
    {
        dwErr = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }

    if(pch != NULL)
    {
        free(pch);
    }

    return(dwErr);
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Encode

  Synopsis : Base64 encode the blob.

  Parameter: DATA_BLOB DataBlob  - DATA_BLOB to be base64 encoded.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the base64 
                                   encoded blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Encode (DATA_BLOB DataBlob, 
                      BSTR    * pbstrEncoded)
{
    HRESULT hr            = S_OK;
    DWORD   dwEncodedSize = 0;
    BSTR    bstrEncoded   = NULL;

    DebugTrace("Entering Base64Encode()\n");

    //
    // Sanity check.
    //
    ATLASSERT(pbstrEncoded);

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (!DataBlob.cbData || !DataBlob.pbData)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: base64 encoding of empty data not allowed.\n");
            goto ErrorExit;
        }

        //
        // Find encoded length required.
        //
#if (1)
        DWORD dwError = ::Base64EncodeW(DataBlob.pbData, 
                                        DataBlob.cbData,
                                        0,
                                        NULL,
                                        &dwEncodedSize);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);

            DebugTrace("Error [%#x]: Base64EncodeW() failed.\n", hr);
            goto ErrorExit;
        }
#else
        if (!::CryptBinaryToStringW(DataBlob.pbData, 
                                    DataBlob.cbData,
                                    CRYPT_STRING_BASE64,
                                    NULL,
                                    &dwEncodedSize))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptBinaryToStringW() failed.\n", hr);
            goto ErrorExit;
        }
#endif

        //
        // Allocate memory.
        //
        if (!(bstrEncoded = ::SysAllocStringLen(NULL, dwEncodedSize)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now base64 encode it.
        //
#if (1)
        dwError = ::Base64EncodeW(DataBlob.pbData,
                                  DataBlob.cbData,
                                  0,
                                  bstrEncoded,
                                  &dwEncodedSize);
        if (ERROR_SUCCESS != dwError)
        {

            hr = HRESULT_FROM_WIN32(dwError);

            DebugTrace("Error [%#x]: Base64EncodeW() failed.\n", hr);
            goto ErrorExit;
        }
#else
        if (!::CryptBinaryToStringW(DataBlob.pbData, 
                                    DataBlob.cbData,
                                    CRYPT_STRING_BASE64,
                                    bstrEncoded,
                                    &dwEncodedSize))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptBinaryToStringW() failed.\n", hr);
            goto ErrorExit;
        }
#endif

        //
        // Return base64 encoded BSTR to caller.
        //
        *pbstrEncoded = bstrEncoded;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving Base64Encode()\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (bstrEncoded)
    {
        ::SysFreeString(bstrEncoded);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Decode

  Synopsis : Decode the base64 encoded blob.

  Parameter: BSTR bstrEncoded      - BSTR of base64 encoded blob to decode.

             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive decoded 
                                     data blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Decode (BSTR        bstrEncoded, 
                      DATA_BLOB * pDataBlob)
{
    HRESULT   hr            = S_OK;
    DWORD     dwEncodedSize = 0;
    DATA_BLOB DataBlob      = {0, NULL};

    DebugTrace("Entering Base64Decode()\n");

    //
    // Sanity check.
    //
    ATLASSERT(bstrEncoded);
    ATLASSERT(pDataBlob);

    try
    {
        //
        // Make sure parameters are valid.
        //
        dwEncodedSize = ::SysStringLen(bstrEncoded);
        if (0 == dwEncodedSize)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, empty base64 encoded data not allowed.\n");
            goto ErrorExit;
        }

        //
        // Find decoded length required.
        //
#if (1)
        DWORD dwError = ::Base64DecodeW(bstrEncoded, 
                                        dwEncodedSize,
                                        NULL,
                                        &DataBlob.cbData);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);

            DebugTrace("Error [%#x]: Base64DecodeW() failed.\n", hr);
            goto ErrorExit;
        }
#else
        if (!::CryptStringToBinaryW(bstrEncoded,
                                    dwEncodedSize,
                                    CRYPT_STRING_BASE64,
                                    NULL,
                                    &DataBlob.cbData,
                                    NULL,
                                    NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptStringToBinaryW() failed.\n", hr);
            goto ErrorExit;
        }
#endif

        //
        // Allocate memory.
        //
        if (!(DataBlob.pbData = (BYTE *) ::CoTaskMemAlloc(DataBlob.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now base64 decode it.
        //
#if (1)
        dwError = ::Base64DecodeW(bstrEncoded, 
                                  dwEncodedSize,
                                  DataBlob.pbData,
                                  &DataBlob.cbData);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);

            DebugTrace("Error [%#x]: Base64DecodeW() failed.\n", hr);
            goto ErrorExit;
        }
#else
        if (!::CryptStringToBinaryW(bstrEncoded,
                                    dwEncodedSize,
                                    CRYPT_STRING_BASE64,
                                    DataBlob.pbData,
                                    &DataBlob.cbData,
                                    NULL,
                                    NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptStringToBinaryW() failed.\n", hr);
            goto ErrorExit;
        }
#endif

        //
        // Return base64 decoded blob to caller.
        //
        *pDataBlob = DataBlob;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving Base64Decode()\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\attributes.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    Attributes.h

  Content: Declaration of CAttributes.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ATTRIBUTES_H_
#define __ATTRIBUTES_H_

#include "resource.h"       // main symbols
#include "Attribute.h"
#include "Lock.h"
#include "CopyItem.h"

#include <wincrypt.h>

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IAttribute> > AttributeMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IAttribute>, AttributeMap> AttributeEnum;
typedef ICollectionOnSTLImpl<IAttributes, AttributeMap, VARIANT, _CopyMapItem<IAttribute>, AttributeEnum> IAttributesCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributesObject

  Synopsis : Create and initialize an IAttributes collection object.

  Parameter: CRYPT_ATTRIBUTES * pAttrbibutes - Pointer to attributes to be 
                                               added to the collection object.
  
             IAttributes ** ppIAttributes - Pointer to pointer to IAttributes 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributesObject (CRYPT_ATTRIBUTES * pAttributes,
                                IAttributes     ** ppIAttributes);


////////////////////////////////////////////////////////////////////////////////
//
// CAttributes
//

class ATL_NO_VTABLE CAttributes : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAttributes, &CLSID_Attributes>,
    public ICAPICOMError<CAttributes, &IID_IAttributes>,
	public IDispatchImpl<IAttributesCollection, &IID_IAttributes, &LIBID_CAPICOM>
{
public:
	CAttributes()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAttributes)
	COM_INTERFACE_ENTRY(IAttributes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CAttributes)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Attributes object.\n", hr);
            return hr;
        }

        return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IAttributes
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
	STDMETHOD(Clear)
        (void);

	STDMETHOD(Remove)
        (/*[in]*/ long Val);

	STDMETHOD(Add)
        (/*[in]*/ IAttribute * pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (CRYPT_ATTRIBUTES * pAttributes);

private:
    CLock   m_Lock;
};
#endif //__ATTRIBUTES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\base64.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Base64.h

  Content:    Declaration of Base64 routines.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __BASE64_H_
#define __BASE64_H_

#include <wincrypt.h>
#include "resource.h"           // main symbols

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Encode

  Synopsis : Base64 encode the blob.

  Parameter: DATA_BLOB DataBlob  - DATA_BLOB to be base64 encoded.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the base64 
                                   encoded blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Encode (DATA_BLOB DataBlob, 
                      BSTR    * pbstrEncoded);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Decode

  Synopsis : Decode the base64 encoded blob.

  Parameter: BSTR bstrEncoded      - BSTR of base64 encoded blob to decode.

             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive decoded 
                                     data blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Decode (BSTR        bstrEncoded, 
                      DATA_BLOB * pDataBlob);

#if (0)
///////////////////////////////////////////////////////////////////////////////
//
// Copied from \NT\ds\security\cryptoapi\common\pkifmt\pkifmt.h.
//

#ifdef __cplusplus
extern "C" {
#endif

DWORD __stdcall			// ERROR_*
Base64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD __stdcall			// ERROR_*
Base64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD __stdcall		// ERROR_*
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD __stdcall			// ERROR_*
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);
    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // #if (0)

#endif //__BASE64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\attribute.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    Attribute.h

  Content: Declaration of CAttribute.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ATTRIBUTE_H_
#define __ATTRIBUTE_H_

#include "resource.h"       // main symbols
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributebject

  Synopsis : Create an IAttribute object and initialize the object with data
             from the specified attribute.

  Parameter: CRYPT_ATTRIBUTE * pAttribute - Pointer to CRYPT_ATTRIBUTE.
 
             IAttribute ** ppIAttribute - Pointer to pointer IAttribute object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributeObject (CRYPT_ATTRIBUTE * pAttribute,
                               IAttribute     ** ppIAttribute);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsValid

  Synopsis : Check to see if an attribute is valid.

  Parameter: IAttribute * pVal - Attribute to be checked.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AttributeIsValid (IAttribute * pAttribute);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsSupported

  Synopsis : Check to see if an attribute is supported.

  Parameter: LPSTR pszObjID - Pointer to attribute OID.

  Remark   :

------------------------------------------------------------------------------*/

BOOL AttributeIsSupported (LPSTR pszObjId);


///////////////////////////////////////////////////////////////////////////////
//
// CAttribute
//
class ATL_NO_VTABLE CAttribute : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAttribute, &CLSID_Attribute>,
    public ICAPICOMError<CAttribute, &IID_IAttribute>,
	public IDispatchImpl<IAttribute, &IID_IAttribute, &LIBID_CAPICOM>
{
public:
	CAttribute()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ATTRIBUTE)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAttribute)
	COM_INTERFACE_ENTRY(IAttribute)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Attribute object.\n", hr);
            return hr;
        }

        m_bInitialized = FALSE;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IAttribute
//
public:
	STDMETHOD(get_Value)
        (/*[out, retval]*/ VARIANT *pVal);

	STDMETHOD(put_Value)
        (/*[in]*/ VARIANT newVal);

	STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_ATTRIBUTE *pVal);

	STDMETHOD(put_Name)
        (/*[in]*/ CAPICOM_ATTRIBUTE newVal);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (CAPICOM_ATTRIBUTE AttributeName, 
         LPSTR             lpszOID, 
         VARIANT           varValue);

private:
    CLock               m_Lock;
    BOOL                m_bInitialized;
    CAPICOM_ATTRIBUTE   m_AttrName;
    CComBSTR            m_bstrOID;
    CComVariant         m_varValue;
};

#endif //__ATTRIBUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\attribute.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Attribute.cpp

  Content: Implementation of CAttribute.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Convert.h"
#include "Common.h"
#include "Attribute.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributebject

  Synopsis : Create an IAttribute object and initialize the object with data
             from the specified attribute.

  Parameter: CRYPT_ATTRIBUTE * pAttribute - Pointer to CRYPT_ATTRIBUTE.
 
             IAttribute ** ppIAttribute - Pointer to pointer IAttribute object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributeObject (CRYPT_ATTRIBUTE * pAttribute,
                               IAttribute **     ppIAttribute)
{
    HRESULT hr = S_OK;
    CAPICOM_ATTRIBUTE AttrName;
    CComVariant varValue;
    CComObject<CAttribute> * pCAttribute = NULL;

    DebugTrace("Entering CreateAttributeObject().\n");

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CAttribute>::CreateInstance(&pCAttribute)))
        {
            DebugTrace("Error [%#x]: CComObject<CAttribute>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine OID value.
        //
        if (0 == ::lstrcmpA(pAttribute->pszObjId, szOID_RSA_signingTime))
        {
            DATE       SigningTime;
            SYSTEMTIME st;
            CRYPT_DATA_BLOB FileTimeBlob = {0, NULL};
           
            if (FAILED(hr = ::DecodeObject(szOID_RSA_signingTime,
                                           pAttribute->rgValue->pbData,
                                           pAttribute->rgValue->cbData,
                                           &FileTimeBlob)))
            {
                DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (!::FileTimeToSystemTime((FILETIME *) FileTimeBlob.pbData, &st) ||
                !::SystemTimeToVariantTime(&st, &SigningTime))
	        {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                ::CoTaskMemFree(FileTimeBlob.pbData);

		        DebugTrace("Error [%#x]: unable to convert FILETIME to DATE.\n", hr);
                goto ErrorExit;
            }

            ::CoTaskMemFree(FileTimeBlob.pbData);

            AttrName = CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME;
            varValue = SigningTime;
            varValue.ChangeType(VT_DATE, NULL);
        }
        else if (0 == ::lstrcmpA(pAttribute->pszObjId, szOID_CAPICOM_DOCUMENT_NAME))
        {
            CComBSTR bstrName;
            CRYPT_DATA_BLOB NameBlob = {0, NULL};

            if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                           pAttribute->rgValue->pbData,
                                           pAttribute->rgValue->cbData,
                                           &NameBlob)))
            {
                DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = ::BlobToBstr((DATA_BLOB *) NameBlob.pbData, &bstrName)))
            {
                ::CoTaskMemFree(NameBlob.pbData);

                DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
                goto ErrorExit;
            }

            ::CoTaskMemFree(NameBlob.pbData);

            AttrName = CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME;
            varValue = bstrName;
        }
        else if (0 == ::lstrcmpA(pAttribute->pszObjId, szOID_CAPICOM_DOCUMENT_DESCRIPTION))
        {
            CComBSTR bstrDesc;
            CRYPT_DATA_BLOB DescBlob = {0, NULL};

            if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                           pAttribute->rgValue->pbData,
                                           pAttribute->rgValue->cbData,
                                           &DescBlob)))
            {
                DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = ::BlobToBstr((DATA_BLOB *) DescBlob.pbData, &bstrDesc)))
            {
                ::CoTaskMemFree(DescBlob.pbData);

                DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
                goto ErrorExit;
            }

            ::CoTaskMemFree(DescBlob.pbData);

            AttrName = CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION;
            varValue = bstrDesc;
        }
        else
        {
            hr = CAPICOM_E_ATTRIBUTE_INVALID_NAME;

            DebugTrace("Error [%#x]: invalid attribute OID.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCAttribute->Init(AttrName, pAttribute->pszObjId, varValue)))
        {
            DebugTrace("Error [%#x]: pCAttribute->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCAttribute->QueryInterface(ppIAttribute)))
        {
            DebugTrace("Error [%#x]: pCAttribute->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateAttributeObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCAttribute)
    {
        delete pCAttribute;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributePairIsValid

  Synopsis : Check to see if an attribute name and value pair is valid.

  Parameter: CAPICOM_ATTRIBUTE AttrName - Attribute name.

             VARIANT varValue - Attribute value.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AttributePairIsValid (CAPICOM_ATTRIBUTE AttrName, 
                              VARIANT           varValue)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AttributePairIsValid()");

    //
    // Check attribute name and value pair validity.
    //
    switch (AttrName)
    {
        case CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME:
        {
            if (VT_DATE != varValue.vt)
            {
                hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                DebugTrace("Error [%#x]: attribute name and value type does not match.\n", hr);
            }

            break;
        }

        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME:
        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION:
        {
            if (VT_BSTR != varValue.vt)
            {
                hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                DebugTrace("Error [%#x]: attribute data type does not match attribute name type, expecting a BSTR variant.\n", hr);
            }
        
            break;
        }

        default:
        {
            hr = CAPICOM_E_ATTRIBUTE_INVALID_NAME;

            DebugTrace("Error [%#x]: unknown attribute name.\n", hr);
            break;
        }
    }

    DebugTrace("Leaving AttributePairIsValid().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsValid

  Synopsis : Check to see if an attribute is valid.

  Parameter: IAttribute * pVal - Attribute to be checked.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AttributeIsValid (IAttribute * pAttribute)
{
    HRESULT hr = S_OK;

    CAPICOM_ATTRIBUTE AttrName;
    CComVariant       varValue;

    DebugTrace("Entering AttributeIsValid()");

    //
    // Sanity check.
    //
    ATLASSERT(pAttribute);

    //
    // Get attribute name.
    //
    if (FAILED(hr = pAttribute->get_Name(&AttrName)))
    {
        DebugTrace("Error [%#x]: pVal->get_Name() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get attribute value.
    //
    if (FAILED(hr = pAttribute->get_Value(&varValue)))
    {
        DebugTrace("Error [%#x]: pVal->get_Value() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Check attribute name and value pair validity.
    //
    if (FAILED(hr = AttributePairIsValid(AttrName, varValue)))
    {

        DebugTrace("Error [%#x]: AttributePairIsValid() failed.\n", hr);
        goto ErrorExit;
   }

CommonExit:

    DebugTrace("Leaving AttributeIsValid().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsSupported

  Synopsis : Check to see if an attribute is supported.

  Parameter: LPSTR pszObjId - Pointer to attribute OID.

  Remark   :

------------------------------------------------------------------------------*/

BOOL AttributeIsSupported (LPSTR pszObjId)
{
    return (0 == ::lstrcmpA(pszObjId, szOID_RSA_signingTime) ||
            0 == ::lstrcmpA(pszObjId, szOID_CAPICOM_DOCUMENT_NAME) ||
            0 == ::lstrcmpA(pszObjId, szOID_CAPICOM_DOCUMENT_DESCRIPTION));
}

///////////////////////////////////////////////////////////////////////////////
//
// CAttribute
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::get_Name

  Synopsis : Return the name of the attribute.

  Parameter: CAPICOM_ATTRIBUTE * pVal - Pointer to CAPICOM_ATTRIBUTE to receive 
                                        result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::get_Name (CAPICOM_ATTRIBUTE * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is initialized.
        //
        if (!m_bInitialized)
        {
            hr = CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: attribute name has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
  	    *pVal = m_AttrName;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::put_Name

  Synopsis : Set attribute enum name.

  Parameter: CAPICOM_ATTRIBUTE newVal - attribute enum name.
  
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::put_Name (CAPICOM_ATTRIBUTE newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::put_Name().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Reset value based on EKU name.
    //
    switch (newVal)
    {
        case CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME:
        {
            m_bstrOID = szOID_RSA_signingTime;
            break;
        }

        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME:
        {
            m_bstrOID = szOID_CAPICOM_DOCUMENT_NAME;
            break;
        }

        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION:
        {
            m_bstrOID = szOID_CAPICOM_DOCUMENT_DESCRIPTION;
            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, unknown attribute name.\n");
            goto ErrorExit;
        }
    }

    //
    // Store name.
    //
    m_AttrName = newVal;
    m_varValue.Clear();
    m_bInitialized = TRUE;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::put_Name().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::get_Value

  Synopsis : Return the actual value of the attribute.

  Parameter: VARIANT * pVal - Pointer to VARIANT to receive value.

  Remark   : Note: value type varies depending on the attribute type. For
             example, szOID_RSA_SigningTime would have a DATE value.

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::get_Value (VARIANT * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::get_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it was set.
        //
        if (VT_EMPTY == m_varValue.vt)
        {
            hr = CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: attribute value has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        ::VariantCopy(pVal, &m_varValue);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::get_Value().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;

	return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::put_Value

  Synopsis : Set attribute value.

  Parameter: VARIANT newVal - attribute value.

  Remark   : Note: value type varies depending on the attribute type. For
             example, szOID_RSA_SigningTime would have a DATE value.

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::put_Value (VARIANT newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::put_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is initialized.
        //
        if (!m_bInitialized)
        {
            hr = CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: attribute name has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure data type matches attribute type.
        //
        if (FAILED(hr = AttributePairIsValid(m_AttrName, newVal)))
        {

            DebugTrace("Error [%#x]: AttributePairIsValid() failed.\n", hr);
            goto ErrorExit;
       }

        //
        // Store value.
        //
  	    m_varValue = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::put_Value().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::Init

  Synopsis : Initialize the object.

  Parameter: DWORD AttrName - Enum name of Attribute.

             LPSTR lpszOID - Attribute OID string.

             VARIANT varValue - Value of attribute (data type depends on
                                the type of attribute).

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::Init (CAPICOM_ATTRIBUTE AttrName, 
                               LPSTR             lpszOID, 
                               VARIANT           varValue)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::Init().\n");

    //
    // Init private members.
    //
    m_bInitialized = TRUE;
    m_AttrName     = AttrName;
    m_bstrOID      = lpszOID;
    m_varValue     = varValue;

    DebugTrace("Leaving CAttribute::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\basicconstraints.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    BasicConstrain.cpp

  Content: Implementation of CBasicConstraints.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "BasicConstraints.h"



////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateBasicConstraintsObject

  Synopsis : Create a IBasicConstraints object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             IBasicConstraints ** ppIBasicConstraints - Pointer to pointer 
                                                        IBasicConstraints 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateBasicConstraintsObject (PCCERT_CONTEXT       pCertContext,
                                      IBasicConstraints ** ppIBasicConstraints)
{
    HRESULT hr = S_OK;
    CComObject<CBasicConstraints> * pCBasicConstraints = NULL;

    DebugTrace("Entering CreateBasicConstraintsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIBasicConstraints);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CBasicConstraints>::CreateInstance(&pCBasicConstraints)))
        {
            DebugTrace("Error [%#x]: CComObject<CBasicConstraints>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCBasicConstraints->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCBasicConstraints::Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCBasicConstraints->QueryInterface(ppIBasicConstraints)))
        {
            DebugTrace("Error [%#x]: pCBasicConstraints->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Entering CreateBasicConstraintsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCBasicConstraints)
    {
        delete pCBasicConstraints;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

static HRESULT DecodeGenericBlob (PCERT_EXTENSION pCertExtension,
			                      LPCSTR          lpszStructType,
                                  void         ** ppStructInfo)
{
    HRESULT hr           = S_OK;
	DWORD   cbStructInfo = 0;

    //
    // Sanity check.
    //
    ATLASSERT(pCertExtension);
    ATLASSERT(lpszStructType);
    ATLASSERT(ppStructInfo);

    //
    // Determine decoded length.
    //
    if(!::CryptDecodeObject(X509_ASN_ENCODING,
                            lpszStructType,
                            pCertExtension->Value.pbData, 
                            pCertExtension->Value.cbData,
		                    0,
                            NULL,
                            &cbStructInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptDecodeObject() failed.\n", hr);
        return hr;
    }

    //
    // Allocate memory.
    //
    if (!(*ppStructInfo = ::CoTaskMemAlloc(cbStructInfo)))
	{
		hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
		return hr;
	}

    //
    // Decode data.
    //
    if(!::CryptDecodeObject(X509_ASN_ENCODING,
                            lpszStructType,
                            pCertExtension->Value.pbData, 
                            pCertExtension->Value.cbData,
		                    0,
                            *ppStructInfo,
                            &cbStructInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        ::CoTaskMemFree(*ppStructInfo);

        DebugTrace("Error [%#x]: CryptDecodeObject() failed.\n", hr);
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// CBasicConstrain
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsPresent

  Synopsis : Check to see if the basic constraints extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsPresent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsPresent().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsCritical

  Synopsis : Check to see if the basic constraints extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsCritical().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsCritical().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsCertificateAuthority

  Synopsis : Check to see if the basic constraints extension contains the CA
             value.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsCertificateAuthority (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsCertificateAuthority().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_bIsCertificateAuthority;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsCertificateAuthority().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsPathLenConstraintPresent

  Synopsis : Check to see if the basic constraints extension contains path
             lenght constraints.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsPathLenConstraintPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsPathLenConstraintPresent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_bIsPathLenConstraintPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsPathLenConstraintPresent().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_PathLenConstraint

  Synopsis : Return the path lenght constraints value.

  Parameter: long * pVal - Pointer to long to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_PathLenConstraint (long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_PathLenConstraint().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_lPathLenConstraint;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_PathLenConstraint().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo = NULL;
    PCERT_EXTENSION pBasicConstraints   = NULL;
    
    DebugTrace("Entering CBasicConstraints::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    try
    {
        //
        // Find the basic constraints extension.
        //
        if (pBasicConstraints = ::CertFindExtension(szOID_BASIC_CONSTRAINTS2,
                                                    pCertContext->pCertInfo->cExtension,
                                                    pCertContext->pCertInfo->rgExtension))
        {
            //
            // Decode the basic constraints extension.
            //
            if (FAILED(hr = ::DecodeGenericBlob(pBasicConstraints, 
                                                X509_BASIC_CONSTRAINTS2,
                                                (void **) &pInfo)))
            {
                DebugTrace("Error [%#x]: DecodeGenericBlob() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Set values.
            //
            m_bIsPresent = VARIANT_TRUE;

            if (pBasicConstraints->fCritical)
            {
                m_bIsCritical = VARIANT_TRUE;
            }

            if (pInfo->fCA)
            {
                m_bIsCertificateAuthority = VARIANT_TRUE;
            }

            if (pInfo->fPathLenConstraint)
            {
                m_bIsPathLenConstraintPresent = VARIANT_TRUE;
                m_lPathLenConstraint = (long) pInfo->dwPathLenConstraint;
            }
        }
        else
        {
            //
            // Reset.
            //
            m_bIsPresent = VARIANT_FALSE;
            m_bIsCritical = VARIANT_FALSE;
            m_bIsCertificateAuthority = VARIANT_FALSE;
            m_bIsPathLenConstraintPresent = VARIANT_FALSE;
            m_lPathLenConstraint = 0;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CBasicConstraints::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\capicom.cpp ===
// CAPICOM.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CAPICOMps.mk in the project directory.

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "CAPICOM.h"

#include "CAPICOM_i.c"
#include "Settings.h"
#include "EKU.h"
#include "EKUs.h"
#include "KeyUsage.h"
#include "ExtendedKeyUsage.h"
#include "BasicConstraints.h"
#include "CertificateStatus.h"
#include "Certificate.h"
#include "Certificates.h"
#include "Store.h"
#include "Chain.h"
#include "Attribute.h"
#include "Signer.h"
#include "Signers.h"
#include "SignedData.h"
#include "Algorithm.h"
#include "Recipients.h"
#include "EnvelopedData.h"
#include "EncryptedData.h"
#include "Attributes.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY_NON_CREATEABLE(CEKU)
OBJECT_ENTRY_NON_CREATEABLE(CEKUs)
OBJECT_ENTRY_NON_CREATEABLE(CKeyUsage)
OBJECT_ENTRY_NON_CREATEABLE(CExtendedKeyUsage)
OBJECT_ENTRY_NON_CREATEABLE(CBasicConstraints)
OBJECT_ENTRY_NON_CREATEABLE(CCertificateStatus)
OBJECT_ENTRY_NON_CREATEABLE(CCertificates)
OBJECT_ENTRY_NON_CREATEABLE(CAttributes)
OBJECT_ENTRY_NON_CREATEABLE(CSigners)
OBJECT_ENTRY_NON_CREATEABLE(CAlgorithm)
OBJECT_ENTRY_NON_CREATEABLE(CRecipients)
OBJECT_ENTRY(CLSID_Settings, CSettings)
OBJECT_ENTRY(CLSID_Certificate, CCertificate)
OBJECT_ENTRY(CLSID_Store, CStore)
OBJECT_ENTRY(CLSID_Chain, CChain)
OBJECT_ENTRY(CLSID_Attribute, CAttribute)
OBJECT_ENTRY(CLSID_Signer, CSigner)
OBJECT_ENTRY(CLSID_SignedData, CSignedData)
OBJECT_ENTRY(CLSID_EnvelopedData, CEnvelopedData)
OBJECT_ENTRY(CLSID_EncryptedData, CEncryptedData)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CAPICOM);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\certificate.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Certificate.h

  Content: Declaration of CCertificate.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CERTIFICATE_H_
#define __CERTIFICATE_H_

#include <atlctl.h>
#include "resource.h"
#include "KeyUsage.h"
#include "ExtendedKeyUsage.h"
#include "BasicConstraints.h"
#include "CertificateStatus.h"
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateObject

  Synopsis : Create an ICertificate object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the ICertificate 
                                           object.

             ICertificate ** ppICertificate  - Pointer to pointer ICertificate
                                               object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateObject (PCCERT_CONTEXT  pCertContext, 
                                 ICertificate ** ppICertificate);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetCertContext

  Synopsis : Return the certificate's PCERT_CONTEXT.

  Parameter: ICertificate * pICertificate - Pointer to ICertificate for which
                                            the PCERT_CONTEXT is to be returned.
  
             PCCERT_CONTEXT * ppCertContext - Pointer to PCERT_CONTEXT.

  Remark   :
 
------------------------------------------------------------------------------*/

HRESULT GetCertContext (ICertificate   * pICertificate, 
                        PCCERT_CONTEXT * ppCertContext);


////////////////////////////////////////////////////////////////////////////////
//
// CCertificate
//

class ATL_NO_VTABLE CCertificate : ICCertificate,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCertificate, &CLSID_Certificate>,
    public ICAPICOMError<CCertificate, &IID_ICertificate>,
	public IDispatchImpl<ICertificate, &IID_ICertificate, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CCertificate, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                           INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CCertificate()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CERTIFICATE)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificate)
	COM_INTERFACE_ENTRY(ICertificate)
	COM_INTERFACE_ENTRY(ICCertificate)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificate)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Certificate object.\n", hr);
            return hr;
        }

        m_pCertContext        = NULL;
        m_pIKeyUsage          = NULL;
        m_pIExtendedKeyUsage  = NULL;
        m_pIBasicConstraints  = NULL;
        m_pICertificateStatus = NULL;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        m_pIKeyUsage.Release();
        m_pIExtendedKeyUsage.Release();
        m_pIBasicConstraints.Release();
        m_pICertificateStatus.Release();
        if (m_pCertContext)
        {
            ::CertFreeCertificateContext(m_pCertContext);
        }

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// ICertificate
//
public:
	STDMETHOD(Display)();

	STDMETHOD(Import)
        (/*[in]*/ BSTR EncodedCertificate);

	STDMETHOD(Export)
        (/*[in, defaultvalue(CAPICOM_ENCODE_BASE64)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

	STDMETHOD(BasicConstraints)
        (/*[out, retval]*/ IBasicConstraints ** pVal);

	STDMETHOD(ExtendedKeyUsage)
        (/*[out, retval]*/ IExtendedKeyUsage ** pVal);

	STDMETHOD(KeyUsage)
        (/*[out, retval]*/ IKeyUsage ** pVal);

    STDMETHOD(IsValid)
        (/*[out, retval]*/ ICertificateStatus ** pVal);

    STDMETHOD(GetInfo)
        (/*[in]*/ CAPICOM_CERT_INFO_TYPE InfoType, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(HasPrivateKey)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_Thumbprint)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(get_ValidToDate)
        (/*[out, retval]*/ DATE * pVal);

	STDMETHOD(get_ValidFromDate)
        (/*[out, retval]*/ DATE * pVal);

	STDMETHOD(get_IssuerName)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(get_SubjectName)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(get_SerialNumber)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(get_Version)
        (/*[out, retval]*/ long * pVal);

    //
    // ICCertficate custom interface.
    //
    STDMETHOD(GetContext)
        (/*[out]*/ PCCERT_CONTEXT * ppCertContext);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(PutContext)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock                       m_Lock;
    PCCERT_CONTEXT              m_pCertContext;
    CComPtr<IKeyUsage>          m_pIKeyUsage;
    CComPtr<IExtendedKeyUsage>  m_pIExtendedKeyUsage;
    CComPtr<IBasicConstraints>  m_pIBasicConstraints;
    CComPtr<ICertificateStatus> m_pICertificateStatus;
};

#endif //__CERTIFICATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\certificates.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Certificates.h

  Content: Declaration of CCertificates.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CERTIFICATES_H_
#define __CERTIFICATES_H_

#include "resource.h"       // main symbols
#include "Certificate.h"


////////////////////
//
// Locals
//


//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<ICertificate> > CertificateMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<ICertificate>, CertificateMap> CertificateEnum;
typedef ICollectionOnSTLImpl<ICertificates, CertificateMap, VARIANT, _CopyMapItem<ICertificate>, CertificateEnum> ICertificatesCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

#define CAPICOM_CERTIFICATES_LOAD_FROM_STORE      0
#define CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN      1
#define CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE    2

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificatesObject

  Synopsis : Create an ICertificates collection object, and load the object with 
             certificates from the specified location.

  Parameter: DWORD dwLocation - Location where to load the certificates:
                                
                   CAPICOM_CERTIFICATES_LOAD_FROM_STORE   = 0
                   CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN   = 1
                   CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE = 2

             LPARAM lParam - Parameter to pass internally to the appropriate 
                             loading functions:
        
                   HCERTSTORE            - for LoadFromStore()
                   PCCERT_CHAIN_CONTEXT  - for LoadFromChain()
                   HCRYPTMSG             - for LoadFromMessage()

             ICertificates ** ppICertificates - Pointer to pointer ICertificates
                                                object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificatesObject (DWORD            dwLocation,
                                  LPARAM           lParam,
                                  ICertificates ** ppICertificates);

                                
////////////////////////////////////////////////////////////////////////////////
//
// CCertificates
//
class ATL_NO_VTABLE CCertificates : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCertificates, &CLSID_Certificates>,
    public IDispatchImpl<ICertificatesCollection, &IID_ICertificates, &LIBID_CAPICOM>
{
public:
	CCertificates()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificates)
	COM_INTERFACE_ENTRY(ICertificates)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificates)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// ICertificates
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Add)
        (PCCERT_CONTEXT pCertContext);

    STDMETHOD(LoadFromStore)
        (HCERTSTORE hCertStore);

    STDMETHOD(LoadFromChain)
        (PCCERT_CHAIN_CONTEXT pChainContext);

    STDMETHOD(LoadFromMessage)
        (HCRYPTMSG hMsg);
};

#endif //__CERTIFICATES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\certificatestatus.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      CertificateStatus.cpp

  Contents:  Implementation of CCertificateStatus

  Remarks:   This object is not creatable by user directly. It can only be
             created via property/method of other CAPICOM objects.

  History:   11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "CertificateStatus.h"
#include "Chain.h"


///////////////
//
// Local
//

#define DEFAULT_CHECK_FLAGS ((CAPICOM_CHECK_FLAG) (CAPICOM_CHECK_SIGNATURE_VALIDITY | \
                                                   CAPICOM_CHECK_TIME_VALIDITY | \
                                                   CAPICOM_CHECK_TRUSTED_ROOT))


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateStatusObject

  Synopsis : Create an ICertificateStatus object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus ** ppICertificateStatus - Pointer to pointer 
                                                          ICertificateStatus
                                                          object.        
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateStatusObject (PCCERT_CONTEXT        pCertContext,
                                       ICertificateStatus ** ppICertificateStatus)
{
    HRESULT hr = S_OK;
    CComObject<CCertificateStatus> * pCCertificateStatus = NULL;

    DebugTrace("Entering CreateCertificateStatusObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppICertificateStatus);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificateStatus>::CreateInstance(&pCCertificateStatus)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificateStatus>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize the object.
        //
        if (FAILED(hr = pCCertificateStatus->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCCertificateStatus->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return ICertificateStatus pointer to caller.
        //
        if (FAILED(hr = pCCertificateStatus->QueryInterface(ppICertificateStatus)))
        {
            DebugTrace("Error [%#x]: pCCertificateStatus->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCertificateStatusObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCCertificateStatus)
    {
        delete pCCertificateStatus;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CCertificateStatus
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_Result

  Synopsis : Return the overall validity result of the cert, based on the
             currently set check flags and EKU.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::get_Result (VARIANT_BOOL * pVal)
{
    HRESULT         hr      = S_OK;
    CComPtr<IChain> pIChain = NULL;

    DebugTrace("Entering CCertificateStatus::get_Result().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pCertContext);

        //
        // Build the chain and return the result.
        //
        if (FAILED(hr = ::CreateChainObject(m_pCertContext, this, pVal, &pIChain)))
        {
            DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_Result().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_CheckFlag

  Synopsis : Return the currently set validity check flag.

  Parameter: CAPICOM_CHECK_FLAG * pVal - Pointer to CAPICOM_CHECK_FLAG to 
                                         receive check flag.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::get_CheckFlag (CAPICOM_CHECK_FLAG * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::get_CheckFlag().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return flag to user.
        //
        *pVal = m_CheckFlag;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_CheckFlag().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::put_CheckFlag

  Synopsis : Set validity check flag.

  Parameter: CAPICOM_CHECK_FLAG newVal - Check flag.

  Remark   : Note that CHECK_ONLINE_REVOCATION_STATUS and 
             CHECK_OFFLINE_REVOCATION_STATUS is mutually exclusive.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::put_CheckFlag (CAPICOM_CHECK_FLAG newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::put_CheckFlag().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure flag is valid (maximum is 0x1f).
    //
    if ((0x0000001f < (DWORD) newVal) ||
        ((CAPICOM_CHECK_ONLINE_REVOCATION_STATUS & newVal) && (CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS & newVal)))
    {
        hr = E_INVALIDARG;

        DebugTrace("Error: invalid parameter, unknown check flag.\n");
        goto ErrorExit;
    }
    
    //
    // Store check flag.
    //
    m_CheckFlag = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::put_CheckFlag().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_EKU

  Synopsis : Return the EKU object.

  Parameter: IEKU ** pVal - Pointer to pointer to IEKU to receive the
                            interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::EKU (IEKU ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::get_EKU().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pIEKU);

        //
        // Return interface pointer to user.
        //
  	    if (FAILED(hr = m_pIEKU->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEKU->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_EKU().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Set default check flags.
    //
    m_CheckFlag = DEFAULT_CHECK_FLAGS;

    //
    // Create the EKU object (default no EKU check).
    //
    if (FAILED(hr = ::CreateEKUObject(NULL, &m_pIEKU)))
    {
        DebugTrace("Error [%#x]: CreateEKUObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Save cert context.
    //
    if (!(m_pCertContext = ::CertDuplicateCertificateContext(pCertContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
    }

CommonExit:

    DebugTrace("Leaving CCertificateStatus::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\certificates.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      Certificates.cpp

  Contents:  Implementation of CCertificates class for collection of 
             ICertificate objects.

  Remarks:   This object is not creatable by user directly. It can only be
             created via property/method of other CAPICOM objects.

             The collection container is implemented usign STL::map of 
             STL::pair of BSTR and ICertificate..

             See Chapter 9 of "BEGINNING ATL 3 COM Programming" for algorithm
             adopted in here.

  History:   11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Certificates.h"
#include "Common.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificatesObject

  Synopsis : Create an ICertificates collection object, and load the object with 
             certificates from the specified location.

  Parameter: DWORD dwLocation - Location where to load the certificates:
                                
                   CAPICOM_CERTIFICATES_LOAD_FROM_STORE   = 0
                   CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN   = 1
                   CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE = 2

             LPARAM lParam - Parameter to pass internally to the appropriate 
                             loading functions:
        
                   HCERTSTORE            - for LoadFromStore()
                   PCCERT_CHAIN_CONTEXT  - for LoadFromChain()
                   HCRYPTMSG             - for LoadFromMessage()

             ICertificates ** ppICertificates - Pointer to pointer ICertificates
                                                object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificatesObject (DWORD            dwLocation,
                                  LPARAM           lParam,
                                  ICertificates ** ppICertificates)
{
    HRESULT hr = S_OK;
    CComObject<CCertificates> * pCCertificates = NULL;

    DebugTrace("Entering CreateCertificatesObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppICertificates);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificates>::CreateInstance(&pCCertificates)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificates>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        switch (dwLocation)
        {
            case CAPICOM_CERTIFICATES_LOAD_FROM_STORE:
            {
                if (FAILED(hr = pCCertificates->LoadFromStore((HCERTSTORE) lParam)))
                {
                    DebugTrace("Error [%#x]: CCertificates::LoadFromStore() failed.\n", hr);
                    goto ErrorExit;
                }
                break;
            }

            case CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN:
            {
                if (FAILED(hr = pCCertificates->LoadFromChain((PCCERT_CHAIN_CONTEXT) lParam)))
                {
                    DebugTrace("Error [%#x]: CCertificates::LoadFromChain() failed.\n", hr);
                    goto ErrorExit;
                }
                break;
            }

            case CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE:
            {
                if (FAILED(hr = pCCertificates->LoadFromMessage((HCRYPTMSG) lParam)))
                {
                    DebugTrace("Error [%#x]: CCertificates::LoadFromMessage() failed.\n", hr);
                    goto ErrorExit;
                }
                break;
            }

            default:
            {
                hr = CAPICOM_E_INTERNAL;

                DebugTrace("Internal error: unknown store load from location.\n");
                goto ErrorExit;
            }
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCCertificates->QueryInterface(ppICertificates)))
        {
            DebugTrace("Error [%#x]:  pCCertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCertificatesObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCCertificates)
    {
        delete pCCertificates;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CCertificates
//


////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Add

  Synopsis : Add a cert to the collection.

  Parameter: PCCERT_CONTEXT pCertContext - Cert to be added.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Add (PCCERT_CONTEXT pCertContext)
{
    HRESULT  hr = S_OK;
    CComPtr<ICertificate> pICertificate = NULL;

    DebugTrace("Entering CCertificates::Add().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    try
    {
        char     szIndex[32];
        CComBSTR bstrIndex;

        //
        // Create the ICertificate object from CERT_CONTEXT.
        //
        if (FAILED(hr = ::CreateCertificateObject(pCertContext, &pICertificate)))
        {
            DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfA(szIndex, "%06u", m_coll.size() + 1);
        bstrIndex = szIndex;

        DebugTrace("Before adding to map: CCertificates.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pICertificate;

        DebugTrace("After adding to map: CCertificates.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CCertificates::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::LoadFromStore

  Synopsis : Load all certificates from a store.

  Parameter: HCERTSTORE hCertStore - Store where all certificates are to be
                                     loaded from.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromStore (HCERTSTORE hCertStore)
{
    HRESULT hr = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CCertificates::LoadFromStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Now transfer all certificates from the store to the collection map.
    //
    while (pCertContext = ::CertEnumCertificatesInStore(hCertStore, pCertContext))
    {
        //
        // Add the cert.
        //
        if (FAILED(hr = Add(pCertContext)))
        {
            DebugTrace("Error [%#x]: CCertificates::Add() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Don'f free cert context here, as CertEnumCertificatesInStore()
        // will do that automatically!!!
        //
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    if (FAILED(hr))
    {
       m_coll.clear();
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::LoadFromChain

  Synopsis : Load all certificates from a chain.

  Parameter: PCCERT_CHAIN_CONTEXT pChainContext - Pointer to a chain context.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromChain (PCCERT_CHAIN_CONTEXT pChainContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificates::LoadFromChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainContext);

    //
    // Process only the simple chain.
    //
    PCERT_SIMPLE_CHAIN pSimpleChain = *pChainContext->rgpChain;

    //
    // Now loop through all certs in the chain.
    //
    for (DWORD i = 0; i < pSimpleChain->cElement; i++)
    {
        //
        // Add the cert.
        //
        if (FAILED(hr = Add(pSimpleChain->rgpElement[i]->pCertContext)))
        {
            DebugTrace("Error [%#x]: CCertificates::Add() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromChain().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::LoadFromMessage

  Synopsis : Load all certificates from a message.

  Parameter: HCRYPTMSG hMsg - Message handle.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromMessage (HCRYPTMSG hMsg)
{
    HRESULT hr          = S_OK;
    DWORD   dwCertCount = 0;
    DWORD   cbCertCount = sizeof(dwCertCount);

    DebugTrace("Entering CCertificates::LoadFromMessage().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);

    //
    // Get number of certs in message.
    //
    if (!::CryptMsgGetParam(hMsg, 
                            CMSG_CERT_COUNT_PARAM,
                            0,
                            (void **) &dwCertCount,
                            &cbCertCount))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Loop thru all certs in the message.
    //
    while (dwCertCount--)
    {
        PCCERT_CONTEXT pCertContext = NULL;
        CRYPT_DATA_BLOB EncodedCertBlob = {0, NULL};

        //
        // Get a cert from the bag of certs.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_CERT_PARAM,
                                      dwCertCount,
                                      (void **) &EncodedCertBlob.pbData,
                                      &EncodedCertBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create a context for the cert.
        //
        pCertContext = ::CertCreateCertificateContext(CAPICOM_ASN_ENCODING,
                                                      (const PBYTE) EncodedCertBlob.pbData,
                                                      EncodedCertBlob.cbData);

        //
        // Free encoded cert blob memory before checking result.
        //
        ::CoTaskMemFree((LPVOID) EncodedCertBlob.pbData);
 
        if (!pCertContext)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add the cert.
        //
        hr = Add(pCertContext);

        //
        // Free cert context before checking result.
        //
        ::CertFreeCertificateContext(pCertContext);

        if (FAILED(hr))
        {
            DebugTrace("Error [%#x]: CCertificates::Add() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromMessage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\certificatestatus.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    CertificateStatus.h

  Content: Declaration of CCertificateStatus.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
	
#ifndef __CERTIFICATESTATUS_H_
#define __CERTIFICATESTATUS_H_

#include "resource.h"       // main symbols
#include "EKU.h"
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateStatusObject

  Synopsis : Create an ICertificateStatus object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus ** ppICertificateStatus - Pointer to pointer 
                                                          ICertificateStatus
                                                          object.        
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateStatusObject (PCCERT_CONTEXT        pCertContext,
                                       ICertificateStatus ** ppICertificateStatus);


////////////////////////////////////////////////////////////////////////////////
//
// CCertificateStatus
//

class ATL_NO_VTABLE CCertificateStatus : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCertificateStatus, &CLSID_CertificateStatus>,
    public ICAPICOMError<CCertificateStatus, &IID_ICertificateStatus>,
	public IDispatchImpl<ICertificateStatus, &IID_ICertificateStatus, &LIBID_CAPICOM>
{
public:
	CCertificateStatus()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificateStatus)
	COM_INTERFACE_ENTRY(ICertificateStatus)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificateStatus)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for CertificateStatus object.\n", hr);
            return hr;
        }

        m_pIEKU = NULL;
        m_CheckFlag = CAPICOM_CHECK_NONE;
        m_pCertContext = NULL;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        m_pIEKU.Release();
        if (m_pCertContext)
        {
            ::CertFreeCertificateContext(m_pCertContext);
        }

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// ICertificateStatus
//
public:
	STDMETHOD(EKU)
        (/*[out, retval]*/ IEKU ** pVal);

	STDMETHOD(get_CheckFlag)
        (/*[out, retval]*/ CAPICOM_CHECK_FLAG * pVal);

	STDMETHOD(put_CheckFlag)
        (/*[in]*/ CAPICOM_CHECK_FLAG newVal);

	STDMETHOD(get_Result)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)(PCCERT_CONTEXT pCertContext);

private:
    CLock               m_Lock;
    CComPtr<IEKU>       m_pIEKU;
    PCCERT_CONTEXT      m_pCertContext;
    CAPICOM_CHECK_FLAG  m_CheckFlag;
};

#endif //__CERTIFICATESTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\certificate.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Certificate.cpp

  Content: Implementation of CCertificate.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Certificate.h"
#include "Convert.h"

#include "cryptui.h"
#include <wincrypt.h>


////////////////////////////////////////////////////////////////////////////////
//
// typedefs.
//

typedef BOOL (WINAPI * PCRYPTUIDLGVIEWCERTIFICATEW) 
             (IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW  pCertViewInfo,
              OUT BOOL                              *pfPropertiesChanged);


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateObject

  Synopsis : Create an ICertificate object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the ICertificate 
                                           object.

             ICertificate ** ppICertificate  - Pointer to pointer ICertificate
                                               object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateObject (PCCERT_CONTEXT     pCertContext, 
                                 ICertificate **    ppICertificate)
{
    HRESULT hr = S_OK;
    CComObject<CCertificate> * pCCertificate = NULL;

    DebugTrace("Entering CreateCertificateObject().\n", hr);

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppICertificate);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificate>::CreateInstance(&pCCertificate)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificate>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCCertificate->PutContext(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCCertificate->PutContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCCertificate->QueryInterface(ppICertificate)))
        {
            DebugTrace("Error [%#x]: pCCertificate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCertificateObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCCertificate)
    {
        delete pCCertificate;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetCertContext

  Synopsis : Return the certificate's PCERT_CONTEXT.

  Parameter: ICertificate * pICertificate - Pointer to ICertificate for which
                                            the PCERT_CONTEXT is to be returned.
  
             PCCERT_CONTEXT * ppCertContext - Pointer to PCERT_CONTEXT.

  Remark   :
 
------------------------------------------------------------------------------*/

HRESULT GetCertContext (ICertificate   * pICertificate, 
                        PCCERT_CONTEXT * ppCertContext)
{
	HRESULT        hr           = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;
    CComPtr<ICCertificate> pICCertificate = NULL;

    DebugTrace("Entering GetCertContext().\n");

    try
    {
        //
        // Get ICCertificate interface pointer.
        //
        if (FAILED(hr = pICertificate->QueryInterface(IID_ICCertificate, (void **) &pICCertificate)))
        {
            DebugTrace("Error [%#x]: pICertificate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get the CERT_CONTEXT.
        //
        if (FAILED(hr = pICCertificate->GetContext(&pCertContext)))
        {
            DebugTrace("Error [%#x]: pICCertificate->GetContext() failed.\n", hr);
            goto ErrorExit;
        }

        *ppCertContext = pCertContext;
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving GetCertContext().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

static ULONG Byte2Hex (BYTE	byte)
{
    ULONG   uValue = 0;
    WCHAR * pwsz0  = L"0";
    WCHAR * pwszA  = L"A";

    if(((ULONG) byte) <= 9)
	{
        uValue = ((ULONG) byte) + ULONG (*pwsz0);	
    }
    else
    {
        uValue = (ULONG) byte - 10 + ULONG (*pwszA);
    }

    return uValue;
}

static HRESULT IntegerBlob2BSTR (CRYPT_INTEGER_BLOB * pBlob, BSTR * pbstrHex)
{
    HRESULT hr        = S_OK;
    BSTR    bstrWchar = NULL;
    BSTR    bstrTemp  = NULL;
    DWORD   cbData    = 0;

    DebugTrace("Entering IntegerBlob2BSTR().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pBlob);
    ATLASSERT(pbstrHex);

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (!pBlob->cbData || !pBlob->pbData)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, empty integer blob.\n");
            goto ErrorExit;
        }

        //
        // Allocate memory (Need 2 wchars for each byte, plus a NULL character).
        //
        if (!(bstrWchar = ::SysAllocStringLen(NULL, pBlob->cbData * 2 + 1)))
        {
            hr = E_OUTOFMEMORY;
            
            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now convert it to hex string (Remember data is stored in little-endian).
        //
        bstrTemp = bstrWchar;
        cbData = pBlob->cbData;

        while (cbData--)
        {
            //
            // Get the byte.
            //
            BYTE byte = pBlob->pbData[cbData];
    
            //
            // Convert upper nibble.
            //
            *bstrTemp++ = (WCHAR) ::Byte2Hex((BYTE)((byte & 0xf0) >> 4));

            //
            // Conver lower nibble.
            //
            *bstrTemp++ = (WCHAR) ::Byte2Hex((BYTE) (byte & 0x0f));
        }

        //
        // Don't forget to NULL terminate it.
        //
        *bstrTemp = L'\0';

        //
        // Return BSTR to caller.
        //
        *pbstrHex = bstrWchar;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving IntegerBlob2BSTR().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (bstrWchar)
    {
        ::SysFreeString(bstrWchar);
    }

    goto CommonExit;
}

static HRESULT Bytes2BSTR (BYTE * pBytes, DWORD cbBytes, BSTR * pBstr)
{
    HRESULT hr = S_OK;
    BSTR    bstrWchar = NULL;
    BSTR    bstrTemp  = NULL;

    DebugTrace("Entering Bytes2BSTR().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pBytes);
    ATLASSERT(pBstr);

    try
    {
        //
        // Allocate memory. (Need 2 wchars for each byte, plus a NULL character).
        //
        if (!(bstrWchar = ::SysAllocStringLen(NULL, cbBytes * 2 + 1)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now convert it to hex string (Remember data is stored in little-endian).
        //
        bstrTemp = bstrWchar;

        while (cbBytes--)
        {
            //
            // Get the byte.
            //
            BYTE byte = *pBytes++;
        
            //
            // Convert upper nibble.
            //
            *bstrTemp++ = (WCHAR) ::Byte2Hex((BYTE) ((byte & 0xf0) >> 4));

            //
            // Conver lower nibble.
            //
            *bstrTemp++ = (WCHAR) ::Byte2Hex((BYTE) (byte & 0x0f));
        }

        //
        // NULL terminate it.
        //
        *bstrTemp = L'\0';

        //
        // Return BSTR to caller.
        //
        *pBstr = bstrWchar;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving Bytes2BSTR().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (bstrWchar)
    {
        ::SysFreeString(bstrWchar);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetCertNameInfo

  Synopsis : Return the name for the subject or issuer field.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             DWORD dwNameType    - 0 for subject name or CERT_NAME_ISSUER_FLAG
                                   for issuer name.

             DWORD dwDisplayType - Can be:
             
                                   CERT_NAME_EMAIL_TYPE
                                   CERT_NAME_RDN_TYPE
                                   CERT_NAME_SIMPLE_DISPLAY_TYPE.

             BSTR * pbstrName    - Pointer to BSTR to receive resulting name
                                   string.

  Remark   : It is the caller's responsibility to free the BSTR.
             No checking of any of the flags is done, so be sure to call
             with the right flags.

------------------------------------------------------------------------------*/

static HRESULT GetCertNameInfo (PCCERT_CONTEXT pCertContext, 
                                DWORD          dwNameType, 
                                DWORD          dwDisplayType, 
                                BSTR         * pbstrName)
{
    HRESULT hr        = S_OK;
    DWORD   cbNameLen = 0;
    LPWSTR  pwszName  = NULL;
    DWORD   dwStrType = CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG;

    DebugTrace("Entering GetCertNameInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pbstrName);

    try
    {
	    //
        // Get the length needed.
        //
        if (!(cbNameLen = ::CertGetNameStringW(pCertContext,   
                                               dwDisplayType,
                                               dwNameType,
                                               dwDisplayType == CERT_NAME_RDN_TYPE ? (LPVOID) &dwStrType : NULL,
                                               NULL,   
                                               0)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertGetNameStringW() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create returned BSTR.
        //
        if (!(pwszName = (LPWSTR) ::CoTaskMemAlloc(cbNameLen * sizeof(WCHAR))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now actually get the name string.
        //
        if (!::CertGetNameStringW(pCertContext,
                                  dwDisplayType,
                                  dwNameType,
                                  dwDisplayType == CERT_NAME_RDN_TYPE ? (LPVOID) &dwStrType : NULL,
                                  (LPWSTR) pwszName,
                                  cbNameLen))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DebugTrace("Error [%#x]: CertGetNameStringW() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return BSTR to caller.
        //
        if (!(*pbstrName = ::SysAllocString(pwszName)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pwszName)
    {
        ::CoTaskMemFree(pwszName);
    }

    DebugTrace("Leaving GetCertNameInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CCertificate
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_Version

  Synopsis : Return the cert version number.

  Parameter: long * pVersion - Pointer to long to receive version number.

  Remark   : The returned value is 1 for V1, 2 for V2, 3 for V3, and so on.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_Version (long * pVal)
{
	HRESULT hr = S_OK;

	DebugTrace("Entering CCertificate::get_Version().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        *pVal = (long) m_pCertContext->pCertInfo->dwVersion + 1;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

	DebugTrace("Leaving CCertificate::get_Version().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_SerialNumber

  Synopsis : Return the Serial Number field as HEX string in BSTR.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the serial number.

  Remark   : Upper case 'A' - 'F' is used for the returned HEX string with 
             no embeded space (i.e. 46A2FC01).

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_SerialNumber (BSTR * pVal)
{
    HRESULT hr = S_OK;

	DebugTrace("Entering CCertificate::get_SerialNumber().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Convert integer blob to BSTR.
        //
        if (FAILED(hr = ::IntegerBlob2BSTR(&m_pCertContext->pCertInfo->SerialNumber, pVal)))
        {
            DebugTrace("Error [%#x]: IntegerBlob2BSTR() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

	DebugTrace("Leaving CCertificate::get_SerialNumber().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_SubjectName

  Synopsis : Return the Subject field.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the subject's name.

  Remark   : This method returns the full DN in the SubjectName field in the 
             form of "CN = Daniel Sie OU = Outlook O = Microsoft L = Redmond 
             S = WA C = US"

             The returned name has the same format as specifying 
             CERT_NAME_RDN_TYPE for the CertGetNameString() API..

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_SubjectName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_SubjectName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Return requested name string.
        //
        if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                          0, 
                                          CERT_NAME_RDN_TYPE, 
                                          pVal)))
        {
            DebugTrace("Error [%#x]: GetCertNameInfo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_SubjectName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_IssuerName

  Synopsis : Return the Issuer field.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the issuer's name.

  Remark   : This method returns the full DN in the IssuerName field in the 
             form of "CN = Daniel Sie OU = Outlook O = Microsoft L = Redmond 
             S = WA C = US"

             The returned name has the same format as specifying 
             CERT_NAME_RDN_TYPE for the CertGetNameString() API.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_IssuerName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_IssuerName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Return requested name string.
        //
        if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                          CERT_NAME_ISSUER_FLAG, 
                                          CERT_NAME_RDN_TYPE, 
                                          pVal)))
        {
            DebugTrace("Error [%#x]: GetCertNameInfo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_IssuerName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_ValidFromDate

  Synopsis : Return the NotBefore field.

  Parameter: DATE * pDate - Pointer to DATE to receive the valid from date.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_ValidFromDate (DATE * pVal)
{
    HRESULT hr = S_OK;
    FILETIME   ftLocal;
    SYSTEMTIME stLocal;

    DebugTrace("Entering CCertificate::get_ValidFromDate().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Convert to local time.
        //
        if (!(::FileTimeToLocalFileTime(&m_pCertContext->pCertInfo->NotBefore, &ftLocal) && 
              ::FileTimeToSystemTime(&ftLocal, &stLocal) &&
              ::SystemTimeToVariantTime(&stLocal, pVal)))
	    {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: unable to convert FILETIME to DATE.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_ValidFromDate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_ValidToDate

  Synopsis : Return the NotAfter field.

  Parameter: DATE * pDate - Pointer to DATE to receive valid to date.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_ValidToDate (DATE * pVal)
{
	HRESULT hr = S_OK;
    FILETIME   ftLocal;
    SYSTEMTIME stLocal;

    DebugTrace("Entering CCertificate::get_ValidToDate().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Convert to local time.
        //
        if (!(::FileTimeToLocalFileTime(&m_pCertContext->pCertInfo->NotAfter, &ftLocal) && 
              ::FileTimeToSystemTime(&ftLocal, &stLocal) &&
              ::SystemTimeToVariantTime(&stLocal, pVal)))
	    {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: unable to convert FILETIME to DATE.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_ValidToDate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_Thumbprint

  Synopsis : Return the SHA1 hash as HEX string.

  Parameter: BSTR * pVal - Pointer to BSTR to receive hash.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_Thumbprint (BSTR * pVal)
{
    HRESULT hr     = S_OK;
    BYTE *  pbHash = NULL;
    DWORD   cbHash = 0;

    DebugTrace("Entering CCertificate::get_Thumbprint().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Calculate length needed.
        //
        if (!::CertGetCertificateContextProperty(m_pCertContext,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 NULL,
                                                 &cbHash))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

		    DebugTrace("Error [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
		    goto ErrorExit;
        }

        //
        // Allocate memory.
        //
        if (!(pbHash = (BYTE *) ::CoTaskMemAlloc(cbHash)))
        {
            hr = E_OUTOFMEMORY;

		    DebugTrace("Error: out of memory.\n");
		    goto ErrorExit;
        }

        //
        // Now get the hash.
        //
        if (!::CertGetCertificateContextProperty(m_pCertContext,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 (LPVOID) pbHash,
                                                 &cbHash))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

		    DebugTrace("Error [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
		    goto ErrorExit;
	    }

        //
        // Conver to BSTR.
        //
        if (FAILED(hr = ::Bytes2BSTR(pbHash, cbHash, pVal)))
        {
		    DebugTrace("Error [%#x]: Bytes2BSTR() failed.\n", hr);
		    goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pbHash)
    {
        ::CoTaskMemFree((LPVOID) pbHash);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_Thumbprint().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::HasPrivateKey

  Synopsis : Check to see if the cert has the associated private key.

  Parameter: VARIANT_BOOL * pVal - Pointer to BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::HasPrivateKey (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;
    DWORD   cb = 0;

    DebugTrace("Entering CCertificate::HasPrivateKey().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = ::CertGetCertificateContextProperty(m_pCertContext, 
                                                    CERT_KEY_PROV_INFO_PROP_ID, 
                                                    NULL, 
                                                    &cb) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::HasPrivateKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::GetInfo

  Synopsis : Get other simple info from the certificate.

             
  Parameter: CAPICOM_CERT_INFO_TYPE InfoType - Info type

             BSTR * pVal - Pointer to BSTR to receive the result.

  Remark   : Note that an empty string "" is returned if the requested info is
             not available in the certificate.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::GetInfo (CAPICOM_CERT_INFO_TYPE InfoType, 
                                    BSTR                 * pVal)
{
    HRESULT hr = S_OK;
    DWORD   dwFlags = 0;

    DebugTrace("Entering CCertificate::GetInfo().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Process request.
        //
        switch (InfoType)
        {
            case CAPICOM_CERT_INFO_ISSUER_SIMPLE_NAME:
            {
                dwFlags = CERT_NAME_ISSUER_FLAG;

                //
                // Warning: dropping thru.
                //
            }

            case CAPICOM_CERT_INFO_SUBJECT_SIMPLE_NAME:
            {
                //
                // Get requested simple name string.
                //
                if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                                  dwFlags, 
                                                  CERT_NAME_SIMPLE_DISPLAY_TYPE, 
                                                  pVal)))
                {
                    DebugTrace("Error [%#x]: GetCertNameInfo() failed for CERT_NAME_SIMPLE_DISPLAY_TYPE.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            case CAPICOM_CERT_INFO_ISSUER_EMAIL_NAME:
            {
                dwFlags = CERT_NAME_ISSUER_FLAG;

                //
                // Warning: dropping thru.
                //
            }

            case CAPICOM_CERT_INFO_SUBJECT_EMAIL_NAME:
            {
                //
                // Get requested email name string.
                //
                if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                                  0, 
                                                  CERT_NAME_EMAIL_TYPE, 
                                                  pVal)))
                {
                    DebugTrace("Error [%#x]: GetCertNameInfo() failed for CERT_NAME_EMAIL_TYPE.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Invalid parameter: unknown info type.\n");
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::GetInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::IsValid

  Synopsis : Return an ICertificateStatus object for certificate validity check.

  Parameter: ICertificateStatus ** pVal - Pointer to pointer to 
                                          ICertificateStatus object to receive
                                          the interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::IsValid (ICertificateStatus ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::IsValid().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pICertificateStatus);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pICertificateStatus->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pICertificateStatus->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::IsValid().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::KeyUsage

  Synopsis : Return the Key Usage extension as an IKeyUsage object.

  Parameter: IKeyUsage ** pVal - Pointer to pointer to IKeyUsage to receive the 
                                 interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::KeyUsage (IKeyUsage ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::KeyUsage().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIKeyUsage);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIKeyUsage->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::KeyUsage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::ExtendedKeyUsage

  Synopsis : Return the EKU extension as an IExtendedKeyUsage object.

  Parameter: IExtendedKeyUsage ** pVal - Pointer to pointer to IExtendedKeyUsage
                                         to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::ExtendedKeyUsage (IExtendedKeyUsage ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::ExtendedKeyUsage().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIExtendedKeyUsage);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIExtendedKeyUsage->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIExtendedKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::ExtendedKeyUsage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::BasicConstraints

  Synopsis : Return the BasicConstraints extension as an IBasicConstraints
             object.

  Parameter: IBasicConstraints ** pVal - Pointer to pointer to IBasicConstraints
                                         to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::BasicConstraints (IBasicConstraints ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::BasicConstraints().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIBasicConstraints);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIBasicConstraints->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIBasicConstraints->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::BasicConstraints().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Export

  Synopsis : Export the certificate.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type which can be:
  
             BSTR * pVal - Pointer to BSTR to receive the certificate blob.
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Export (CAPICOM_ENCODING_TYPE EncodingType, 
                                   BSTR                * pVal)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB CertBlob = {0, NULL};

    DebugTrace("Entering CCertificate::Export().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Determine encoding type.
        //
        CertBlob.cbData = m_pCertContext->cbCertEncoded;
        CertBlob.pbData = m_pCertContext->pbCertEncoded;

        //
        // Export certificate.
        //
        if (FAILED(hr = ::ExportData(CertBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Export().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Import

  Synopsis : Imoprt a certificate.

  Parameter: BSTR EncodedCertificate - BSTR containing the encoded certificate
                                       blob.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Import (BSTR EncodedCertificate)
{
    HRESULT        hr           = S_OK;
    DATA_BLOB      CertBlob     = {0, NULL};
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CCertificate::Import().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(EncodedCertificate))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, EncodedCertificate is empty.\n");
            goto ErrorExit;
        }

        //
        // Import the data.
        //
        if (FAILED(hr = ::ImportData(EncodedCertificate, &CertBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the CERT_CONTEXT.
        //
        if (!(pCertContext = ::CertCreateCertificateContext(CAPICOM_ASN_ENCODING,
                                                            CertBlob.pbData,
                                                            CertBlob.cbData)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = PutContext(pCertContext)))
        {
            DebugTrace("Error [%#x]: Certificate::PutContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (CertBlob.pbData)
    {
        ::CoTaskMemFree(CertBlob.pbData);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Entering CCertificate::Import().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Display

  Synopsis : Display the certificate using CryptUIDlgViewCertificateW() API.

  Parameter: None

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Display()
{
    HRESULT   hr    = S_OK;
    HINSTANCE hDLL  = NULL;

    PCRYPTUIDLGVIEWCERTIFICATEW     pCryptUIDlgViewCertificateW = NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW ViewInfo;

    DebugTrace("Entering CCertificate::Display().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure cert is already initialized.
    //
    if (!m_pCertContext)
    {
        hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		goto ErrorExit;
    }

    //
    // Get pointer to CryptUIDlgViewCertificateW().
    //
    if (hDLL = ::LoadLibrary("CryptUI.dll"))
    {
        pCryptUIDlgViewCertificateW = (PCRYPTUIDLGVIEWCERTIFICATEW) ::GetProcAddress(hDLL, "CryptUIDlgViewCertificateW");
    }

    //
    // Is CryptUIDlgSelectCertificateW() available?
    //
    if (!pCryptUIDlgViewCertificateW)
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: CryptUIDlgViewCertificateW() API not available.\n");
        goto ErrorExit;
    }

    //
    // Initialize view structure.
    //
    ::ZeroMemory((void *) &ViewInfo, sizeof(ViewInfo));
    ViewInfo.dwSize = sizeof(ViewInfo);
    ViewInfo.pCertContext = m_pCertContext;

    //
    // View it.
    //
    if (!pCryptUIDlgViewCertificateW(&ViewInfo, 0))
    {
        //
        // CryptUIDlgViewCertificateW() returns ERROR_CANCELLED if user closed
        // the window through the x button!!!
        //
        DWORD dwWinError = ::GetLastError();
        if (ERROR_CANCELLED != dwWinError)
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CryptUIDlgViewCertificateW() failed.\n", hr);
            goto ErrorExit;
        }
    }

UnlockExit:
    //
    // Release resources.
    //
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Display().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::GetContext

  Synopsis : Return the certificate's PCCERT_CONTEXT.

  Parameter: PCCERT_CONTEXT * ppCertContext - Pointer to PCCERT_CONTEXT.

  Remark   : This method is designed for internal use only, and therefore,
             should not be exposed to user.

             Note that this is a custom interface, not a dispinterface.

             Note that the cert context ref count is incremented by
             CertDuplicateCertificateContext(), so it is the caller's
             responsibility to free the context.
 
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::GetContext (PCCERT_CONTEXT * ppCertContext)
{
	HRESULT        hr           = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CCertificate::GetContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

		    DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
		    goto ErrorExit;
        }

        //
        // Duplicate the cert context.
        //
        if (!(pCertContext = ::CertDuplicateCertificateContext(m_pCertContext)))
        {
		    hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n");
            goto ErrorExit;
        }
 
        //
        // and return to caller.
        //
        *ppCertContext = pCertContext;
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::GetContext().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::PutContext

  Synopsis : Initialize the object with a CERT_CONTEXT.

  Parameter: PCERT_CONTEXT pCertContext - Poiner to CERT_CONTEXT used to 
                                          initialize this object.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::PutContext (PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::PutContext().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Reset.
    //
    m_pIKeyUsage.Release();
    m_pIExtendedKeyUsage.Release();
    m_pIBasicConstraints.Release();
    m_pICertificateStatus.Release();

    if (m_pCertContext)
    {
        ::CertFreeCertificateContext(m_pCertContext);
        m_pCertContext = NULL;
    }

    //
    // Create the embeded IKeyUsage object.
    //
    if (FAILED(hr = ::CreateKeyUsageObject(pCertContext, &m_pIKeyUsage)))
    {
        DebugTrace("Error [%#x]: CreateKeyUsageObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded IExtendedKeyUsage object.
    //
    if (FAILED(hr = ::CreateExtendedKeyUsageObject(pCertContext, &m_pIExtendedKeyUsage)))
    {
        DebugTrace("Error [%#x]: CreateExtendedKeyUsageObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded IBasicConstraints object.
    //
    if (FAILED(hr = ::CreateBasicConstraintsObject(pCertContext, &m_pIBasicConstraints)))
    {
        DebugTrace("Error [%#x]: CreateBasicConstraintsObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded ICertificateStatus object.
    //
    if (FAILED(hr = ::CreateCertificateStatusObject(pCertContext, &m_pICertificateStatus)))
    {
        DebugTrace("Error [%#x]: CreateCertificateStatusObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Duplicate the cert context.
    //
    if (!(m_pCertContext = ::CertDuplicateCertificateContext(pCertContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertDupliacteCertificateContext() failed.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::PutContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\basicconstraints.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    BasicConstraints.h.

  Content: Declaration of the CBasicConstraints.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __BasicConstraints_H_
#define __BasicConstraints_H_

#include "resource.h"       // main symbols
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateBasicConstraintsObject

  Synopsis : Create a IBasicConstraints object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext            - Pointer to CERT_CONTEXT.

             IBasicConstraints ** ppIBasicConstraints - Pointer to pointer 
                                                        IBasicConstraints 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateBasicConstraintsObject (PCCERT_CONTEXT       pCertContext,
                                      IBasicConstraints ** ppIBasicConstraints);


////////////////////////////////////////////////////////////////////////////////
//
// CBasicConstraints
//
class ATL_NO_VTABLE CBasicConstraints : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CBasicConstraints, &CLSID_BasicConstraints>,
    public ICAPICOMError<CBasicConstraints, &IID_IBasicConstraints>,
	public IDispatchImpl<IBasicConstraints, &IID_IBasicConstraints, &LIBID_CAPICOM>
{
public:
	CBasicConstraints()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBasicConstraints)
	COM_INTERFACE_ENTRY(IBasicConstraints)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CBasicConstraints)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for BasicConstraints object.\n", hr);
            return hr;
        }

        m_bIsPresent  = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;
        m_bIsCertificateAuthority = VARIANT_FALSE;
        m_bIsPathLenConstraintPresent = VARIANT_FALSE;
        m_lPathLenConstraint = 0;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IBasicConstraints
//
public:
	STDMETHOD(get_IsPathLenConstraintPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_PathLenConstraint)
        (/*[out, retval]*/ long * pVal);

	STDMETHOD(get_IsCertificateAuthority)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    //
    // Non COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock        m_Lock;
    VARIANT_BOOL m_bIsPresent;
    VARIANT_BOOL m_bIsCritical;
    VARIANT_BOOL m_bIsCertificateAuthority;
    VARIANT_BOOL m_bIsPathLenConstraintPresent;
    long         m_lPathLenConstraint;
};

#endif //__BasicConstraints_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\chain.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Chain.cpp

  Content: Implementation of CChain.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Chain.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus * pIStatus - Pointer to ICertificateStatus
                                             object.

             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (PCCERT_CONTEXT      pCertContext, 
                          ICertificateStatus * pIStatus,
                          VARIANT_BOOL       * pbResult,
                          IChain            ** ppIChain)
{
    HRESULT hr = S_OK;
    CComObject<CChain> * pCChain = NULL;

    DebugTrace("Entering CreateChainObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pIStatus);
    ATLASSERT(pbResult);
    ATLASSERT(ppIChain);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CChain>::CreateInstance(&pCChain)))
        {
            DebugTrace("Error [%#x]: CComObject<CChain>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCChain->Init(pCertContext, pIStatus, pbResult)))
        {
            DebugTrace("Error [%#x]: pCChain->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IChain pointer to caller.
        //
        if (FAILED(hr = pCChain->QueryInterface(ppIChain)))
        {
            DebugTrace("Error [%#x]: pCChain->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateChainObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCChain)
    {
        delete pCChain;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetChainContext

  Synopsis : Return an array of PCCERT_CONTEXT from the chain.

  Parameter: IChain * pIChain - Pointer to IChain.
  
             CRYPT_DATA_BLOB * pChainBlob - Pointer to blob to recevie the
                                            size and array of PCERT_CONTEXT
                                            for the chain.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP GetChainContext (IChain          * pIChain, 
                              CRYPT_DATA_BLOB * pChainBlob)
{
    HRESULT              hr            = S_OK;
    DWORD                dwCerts       = 0;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    PCERT_SIMPLE_CHAIN   pSimpleChain  = NULL;
    PCCERT_CONTEXT     * rgCertContext = NULL;
    CComPtr<ICChain>     pICChain      = NULL;
    
    DebugTrace("Entering GetChainContext().\n");

    try
    {
        //
        // Get ICCertificate interface pointer.
        //
        if (FAILED(hr = pIChain->QueryInterface(IID_ICChain, (void **) &pICChain)))
        {
            DebugTrace("Error [%#x]: pIChain->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get the CHAIN_CONTEXT.
        //
        if (FAILED(hr = pICChain->GetContext(&pChainContext)))
        {
            DebugTrace("Error [%#x]: pICCertificate->GetContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Process only the simple chain.
        //
        pSimpleChain = *pChainContext->rgpChain;

        //
        // Make sure there is cert in the chain.
        //
        if (!pSimpleChain->cElement)
        {
            //
            // This should not happen. There should always be at least
            // one cert in the chain.
            //
            hr = E_UNEXPECTED;

            DebugTrace("Unexpected error: no cert found in the chain.\n");
            goto ErrorExit;
        }

        //
        // Allocate memory for array of PCERT_CONTEXT to return.
        //
        if (!(rgCertContext = (PCCERT_CONTEXT *) ::CoTaskMemAlloc(pSimpleChain->cElement * sizeof(PCCERT_CONTEXT))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now loop through all certs in the chain.
        //
        for (dwCerts = 0; dwCerts < pSimpleChain->cElement; dwCerts++)
        {
            //
            // Add the cert.
            //
            if (!(rgCertContext[dwCerts] = ::CertDuplicateCertificateContext(pSimpleChain->rgpElement[dwCerts]->pCertContext)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Return PCCERT_CONTEXT array.
        //
        pChainBlob->cbData = dwCerts;
        pChainBlob->pbData = (BYTE *) rgCertContext;
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    DebugTrace("Leaving GetChainContext().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (rgCertContext)
    {
        while (dwCerts--)
        {
            if (rgCertContext[dwCerts])
            {
                ::CertFreeCertificateContext(rgCertContext[dwCerts]);
            }
        }

        ::CoTaskMemFree((LPVOID) rgCertContext);
    }

    goto CommonExit;
}


///////////////////////////////////////////////////////////////////////////////
//
// CChain
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::get_Certificates

  Synopsis : Return the certificate chain in the form of ICertificates 
             collection object.

  Parameter: ICertificates ** pVal - Pointer to pointer to ICertificates 
                                     collection object.

  Remark   : This collection is ordered with index 1 being the end certificate 
             and Certificates.Count() being the root certificate.

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::get_Certificates (ICertificates ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::get_Certificates().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure chain has not been previously built.
        //
        if (!m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

		    DebugTrace("Error: chain object does not represent a certificate chain.\n");
		    goto ErrorExit;
        }

        //
        // Return collection object to user.
        //
        if (FAILED(hr = ::CreateCertificatesObject(CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN, 
                                                   (LPARAM) m_pChainContext, 
                                                   pVal)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::get_Status

  Synopsis : Return validity status for the chain or a specific certificate in
             the chain.

  Parameter: long Index  - 0 to specify chain status, 1 for the end cert 
                           status, or Certificates.Count() for the root cert 
                           status.

             long * pVal - Pointer to a long integer to receive the status,
                           which can be ORed with the following flags:

                    //
                    // These can be applied to certificates and chains.
                    //
                    CAPICOM_TRUST_IS_NOT_TIME_VALID          = 0x00000001
                    CAPICOM_TRUST_IS_NOT_TIME_NESTED         = 0x00000002
                    CAPICOM_TRUST_IS_REVOKED                 = 0x00000004
                    CAPICOM_TRUST_IS_NOT_SIGNATURE_VALID     = 0x00000008
                    CAPICOM_TRUST_IS_NOT_VALID_FOR_USAGE     = 0x00000010
                    CAPICOM_TRUST_IS_UNTRUSTED_ROOT          = 0x00000020
                    CAPICOM_TRUST_REVOCATION_STATUS_UNKNOWN  = 0x00000040
                    CAPICOM_TRUST_IS_CYCLIC                  = 0x00000080

                    //
                    // These can be applied to chains only.
                    //
                    CAPICOM_TRUST_IS_PARTIAL_CHAIN           = 0x00010000
                    CAPICOM_TRUST_CTL_IS_NOT_TIME_VALID      = 0x00020000
                    CAPICOM_TRUST_CTL_IS_NOT_SIGNATURE_VALID = 0x00040000
                    CAPICOM_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = 0x00080000

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::get_Status (long   Index, 
                                 long * pVal)
{
    HRESULT hr      = S_OK;
    DWORD   dwIndex = (DWORD) Index;

    DebugTrace("Entering CChain::get_Status().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure chain has been built.
        //
        if (NULL == m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

		    DebugTrace("Error: chain object was not initialized.\n");
            goto ErrorExit;
        }

        //
        // Return requested status.
        //
        if (0 == dwIndex)
        {
            *pVal = (long) m_dwStatus;
        }
        else
        {
            //
            // We only look at the first simple chain.
            //
            PCERT_SIMPLE_CHAIN pChain = m_pChainContext->rgpChain[0];

            //
            // Make sure index is not out of range.
            //
            if (dwIndex-- > pChain->cElement)
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, certificate index out of range.\n");
                goto ErrorExit;
            }

            *pVal = (long) pChain->rgpElement[dwIndex]->TrustStatus.dwErrorStatus;
        }
    }
    
    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::Build

  Synopsis : Build the chain.

  Parameter: ICertificate * pICertificate - Pointer to certificate for which
                                            the chain is to build.
  
             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::Build (ICertificate * pICertificate, 
                            VARIANT_BOOL * pVal)
{
    HRESULT                     hr           = S_OK;
    PCCERT_CONTEXT              pCertContext = NULL;
    CComPtr<ICertificateStatus> pIStatus     = NULL;
    VARIANT_BOOL                bResult;

    DebugTrace("Entering CChain::Build().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Get CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get status check object.
        //
        if (FAILED(hr = pICertificate->IsValid(&pIStatus)))
        {
            DebugTrace("Error [%#x]: pICertificate->IsValid() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Build the chain.
        //
        if (FAILED(hr = Init(pCertContext, pIStatus, &bResult)))
        {
            DebugTrace("Error [%#x]: CChain::Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result to caller.
        //
        *pVal = bResult;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::GetContext

  Synopsis : Return an array of PCCERT_CONTEXT from the chain.

  Parameter: CRYPT_DATA_BLOB * pVal - Pointer to blob to recevie the
                                      size and array of PCERT_CONTEXT
                                      for the chain.

  Remark   : This restricted method is designed for internal use only, and 
             therefore, should not be exposed to user.

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::GetContext (PCCERT_CHAIN_CONTEXT * ppChainContext)
{
    HRESULT              hr            = S_OK;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    DebugTrace("Entering CChain::GetContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure chain has been built.
        //
        if (!m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

		    DebugTrace("Error: chain object was not initialized.\n");
            goto ErrorExit;
        }

        //
        // Duplicate the chain context.
        //
        if (!(pChainContext = ::CertDuplicateCertificateChain(m_pChainContext)))
        {
		    hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateCertificateChain() failed.\n");
            goto ErrorExit;
        }
 
        //
        // and return to caller.
        //
        *ppChainContext = pChainContext;
   }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::GetContext().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             ICertificateStatus * pIStatus - Pointer to ICertificateStus object
                                             used to build the chain.

             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.
             
  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CChain::Init (PCCERT_CONTEXT       pCertContext, 
                           ICertificateStatus * pIStatus,
                           VARIANT_BOOL       * pbResult)
{
    HRESULT              hr            = S_OK;
    CAPICOM_CHECK_FLAG   UserFlags     = CAPICOM_CHECK_NONE;
    DWORD                dwCheckFlags  = 0;
    CComPtr<IEKU>        pIEku         = NULL;
    CComBSTR             bstrEkuOid    = NULL;
    LPSTR                lpszEkuOid    = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_CHAIN_PARA      ChainPara     = {sizeof(CERT_CHAIN_PARA), {USAGE_MATCH_TYPE_AND, {0, NULL}}};

    //
    // For OLE2A macro.
    //
    USES_CONVERSION;

    DebugTrace("Entering CChain::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pIStatus);
    ATLASSERT(pbResult);

    //
    // Get the user's requested check flag.
    //
    if (FAILED(hr = pIStatus->get_CheckFlag(&UserFlags)))
    {
        DebugTrace("Error [%#x]: pIStatus->CheckFlag() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set check flags.
    //
    if (CAPICOM_CHECK_ONLINE_REVOCATION_STATUS & UserFlags)
    {
        dwCheckFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    }
    if (CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS & UserFlags)
    {
        dwCheckFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN | CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    }

    //
    // Get EKU object.
    //
    if (FAILED(hr = pIStatus->EKU(&pIEku)))
    {
        DebugTrace("Error [%#x]: pIStatus->EKU() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get EKU OID value.
    //
    if (FAILED(hr = pIEku->get_OID(&bstrEkuOid)))
    {
        if (CAPICOM_E_EKU_OID_NOT_INITIALIZED == hr)
        {
            //
            // Don't care if no OID is set.
            //
            hr = S_OK;
        }
        else
        {
            DebugTrace("Error [%#x]: pIEku->get_OID() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // If not empty, then set EKU.
    //
    if (bstrEkuOid && bstrEkuOid.Length())
    {
        //
        // Use OLE2A which will allocate LPSTR off the stack, and
        // avoid having to free it explicitly, as it will be freed
        // automatically when the function exits.
        //
        if (!(lpszEkuOid = OLE2A(bstrEkuOid)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &lpszEkuOid;
    }

    //
    // Build the chain.
    //
    if (!::CertGetCertificateChain(NULL,                // in optional 
                                   pCertContext,        // in 
                                   NULL,                // in optional
                                   NULL,                // in optional 
                                   &ChainPara,          // in 
                                   dwCheckFlags,        // in 
                                   NULL,                // in 
                                   &pChainContext))     // out 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertGetCertificateChain() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Update member variables.
    //
    if (m_pChainContext)
    {
        ::CertFreeCertificateChain(m_pChainContext);
    }

    m_pChainContext = pChainContext;
    m_dwStatus = pChainContext->TrustStatus.dwErrorStatus;

    //
    // Check results.
    //          
    if (((ChainPara.RequestedUsage.Usage.cUsageIdentifier) && 
         ((CERT_TRUST_IS_NOT_VALID_FOR_USAGE | CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) & m_dwStatus)) ||
        ((UserFlags & CAPICOM_CHECK_SIGNATURE_VALIDITY) &&
         ((CERT_TRUST_IS_NOT_SIGNATURE_VALID | CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) & m_dwStatus)) ||
        ((UserFlags & CAPICOM_CHECK_TIME_VALIDITY) &&
         ((CERT_TRUST_IS_NOT_TIME_VALID | CERT_TRUST_CTL_IS_NOT_TIME_VALID) & m_dwStatus)) ||
        ((UserFlags & CAPICOM_CHECK_TRUSTED_ROOT) &&
         (CERT_TRUST_IS_UNTRUSTED_ROOT & m_dwStatus)) ||
        ((UserFlags & CAPICOM_CHECK_ONLINE_REVOCATION_STATUS || UserFlags & CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS) &&
         (CERT_TRUST_IS_REVOKED & m_dwStatus)) ||
        (CERT_TRUST_IS_PARTIAL_CHAIN & m_dwStatus))
    {      
        *pbResult = VARIANT_FALSE;

        DebugTrace("Info: invalid chain (status = %#x).\n", m_dwStatus);
        goto CommonExit;
    }

    //
    // If requested to check revocation status, then we need to walk the
    // chain for CERT_TRUST_REVOCATION_STATUS_UNKNOWN to see if there is
    // really any revocation error.
    //
    if ((UserFlags & CAPICOM_CHECK_ONLINE_REVOCATION_STATUS || UserFlags & CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS) &&
        (CERT_TRUST_REVOCATION_STATUS_UNKNOWN & pChainContext->TrustStatus.dwErrorStatus))
    {
        //
        // Walk thru every chain.
        //
        for (DWORD i = 0; i < pChainContext->cChain; i++)
        {
            PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

            //
            // Walk thru every element of each chain.
            //
            for (DWORD j = 0; j < pChain->cElement; j++)
            {
                PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[j];

                //
                // Is this element with unknown status?
                //
                if (CERT_TRUST_REVOCATION_STATUS_UNKNOWN & pElement->TrustStatus.dwErrorStatus)
                {
                    //
                    // Consider an error (CRL server is offline) if the revocation
                    // status is not CRYPT_E_NO_REVOCATION_CHECK.
                    //
                    if (CRYPT_E_NO_REVOCATION_CHECK != pElement->pRevocationInfo->dwRevocationResult)
                    {
                        *pbResult = VARIANT_FALSE;

                        DebugTrace("Info: invalid chain (CRYPT_E_REVOCATION_OFFLINE).\n");
                        goto CommonExit;
                    }
                }
            }
        }

#if (0)
        //
        // If we get to here, then we need to throw away 
        // CERT_TRUST_REVOCATION_STATUS_UNKNOWN in the status, and thus 
        // treat it as no error.
        //
        m_dwStatus &= ~CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
#endif
    }

    //
    // Everything checks out OK.
    //
    *pbResult = VARIANT_TRUE;

CommonExit:

    DebugTrace("Leaving CChain::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resouce.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\chain.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Chain.h

  Content:    Declaration of CChain.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CHAIN_H_
#define __CHAIN_H_

#include "resource.h"
#include "Certificates.h"
#include "CertificateStatus.h"
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus * pIStatus - Pointer to ICertificateStatus
                                             object.

             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (PCCERT_CONTEXT       pCertContext, 
                           ICertificateStatus * pIStatus,
                           VARIANT_BOOL       * pbResult,
                           IChain            ** ppIChain);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetChainContext

  Synopsis : Return an array of PCCERT_CONTEXT from the chain.

  Parameter: IChain * pIChain - Pointer to IChain.
  
             CRYPT_DATA_BLOB * pChainBlob - Pointer to blob to recevie the
                                            size and array of PCERT_CONTEXT
                                            for the chain.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP GetChainContext (IChain          * pIChain, 
                              CRYPT_DATA_BLOB * pChainBlob);


////////////////////////////////////////////////////////////////////////////////
//
// CChain
//

class ATL_NO_VTABLE CChain : ICChain,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CChain, &CLSID_Chain>,
    public ICAPICOMError<CChain, &IID_IChain>,
	public IDispatchImpl<IChain, &IID_IChain, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CChain, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                     INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CChain()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHAIN)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CChain)
	COM_INTERFACE_ENTRY(IChain)
	COM_INTERFACE_ENTRY(ICChain)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CChain)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Chain object.\n", hr);
            return hr;
        }

        m_dwStatus      = 0;
        m_pChainContext = NULL;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        if (m_pChainContext)
        {
            ::CertFreeCertificateChain(m_pChainContext);
        }

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IChain
//
public:
	STDMETHOD(Build)
        (/*[in]*/ ICertificate * pICertificate, 
         /*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_Status)
        (/*[in, defaultvalue(0)]*/ long Index, 
         /*[out,retval]*/ long * pVal);

    STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates ** pVal);

    //
    // Custom interfaces. 
    //
    STDMETHOD(GetContext)
        (PCCERT_CHAIN_CONTEXT * ppChainContext);

    //
    // Non COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT       pCertContext, 
         ICertificateStatus * pIStatus,
         VARIANT_BOOL       * pbResult);

private:
    CLock                m_Lock;
    DWORD                m_dwStatus;
    PCCERT_CHAIN_CONTEXT m_pChainContext;
};

#endif //__CHAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\common.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Common.cpp

  Content: Common routines.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Common.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetOSVersion

  Synopsis : Get the current OS platform/version.

  Parameter: POSVERSION pOSVersion - Pointer to OSVERSION to receive result.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetOSVersion (POSVERSION pOSVersion)
{
    HRESULT       hr = S_OK;
    OSVERSIONINFO OSVersionInfo;

    DebugTrace("Entering GetOSVersion().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pOSVersion);

    //
    // Initialize OSVERSIONINFO struct.
    //
    OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); 

    //
    // GetVersionEx() will fail on Windows 3.x or below NT 3.5 systems.
    //
    if (!::GetVersionEx(&OSVersionInfo))
    {
        hr = ::GetLastError();

        DebugTrace("Error [%#x]: GetVersionEx() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Check platform ID.
    //
    switch (OSVersionInfo.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
        {
            //
            // Win9x.
            //
            *pOSVersion = WIN_9X;
            break;
        }

        case VER_PLATFORM_WIN32_NT:
        {
            if (4 == OSVersionInfo.dwMajorVersion)
            {
                //
                // NT 4.
                //
                *pOSVersion = WIN_NT4;
                break;
            }
            else if (5 <= OSVersionInfo.dwMajorVersion)
            {
                //
                // Win2K and above.
                //
                *pOSVersion = WIN_NT5;
                break;
            }

            //
            // Must be NT 3.5.
            //

            //
            // !!! WARNING !!! Dropping thru to default case.
            //
        }
        
        default:
        {
            hr = CAPICOM_E_NOT_SUPPORTED;

            DebugTrace("Error: unsupported OS (Platform = %d, Major = %d, Minor = %d).\n", 
                        OSVersionInfo.dwPlatformId, OSVersionInfo.dwMajorVersion, OSVersionInfo.dwMinorVersion);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving GetOSVersion().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EncodeObject

  Synopsis : Allocate memory and encode an ASN.1 object using CAPI
             CryptEncodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible 
                                              types.
             LPVOID pbData                  - Pointer to data to be encoded 
                                              (data type must match 
                                              pszStrucType).
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the encoded length and 
                                              data.

  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT EncodeObject (LPCSTR            pszStructType, 
                      LPVOID            pbData, 
                      CRYPT_DATA_BLOB * pEncodedBlob)
{
    HRESULT hr = S_OK;
    DWORD cbEncoded = 0;
    BYTE * pbEncoded = NULL;

    DebugTrace("Entering EncodeObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != pszStructType);
    ATLASSERT(NULL != pbData);
    ATLASSERT(NULL != pEncodedBlob);

    //
    // Intialize return value.
    //
    pEncodedBlob->cbData = 0;
    pEncodedBlob->pbData = NULL;

    //
    // Determine encoded length required.
    //
    if (!::CryptEncodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const void *) pbData,
                             NULL,
                             &cbEncoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Unable to determine object encoded length [0x%x]: CryptEncodeObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Allocate memory for encoded blob.
    //
    if (!(pbEncoded = (BYTE *) ::CoTaskMemAlloc(cbEncoded)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Out of memory: CoTaskMemAlloc(cbEncoded) failed.\n");
        goto CommonExit;
    }

    //
    // Encode.
    //
    if (!::CryptEncodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const void *) pbData,
                             pbEncoded,
                             &cbEncoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Unable to encode object [0x%x]: CryptEncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return value.
    //
    pEncodedBlob->cbData = cbEncoded;
    pEncodedBlob->pbData = pbEncoded;

CommonExit:

    DebugTrace("Leaving EncodeObject().\n");
    
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbEncoded)
    {
        ::CoTaskMemFree((LPVOID) pbEncoded);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DecodeObject

  Synopsis : Allocate memory and decode an ASN.1 object using CAPI
             CryptDecodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible
                                              types.
             BYTE * pbEncoded               - Pointer to data to be decoded 
                                              (data type must match 
                                              pszStrucType).
             DWORD cbEncoded                - Size of encoded data.
             CRYPT_DATA_BLOB * pDecodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the decoded length and 
                                              data.
  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT DecodeObject (LPCSTR            pszStructType, 
                      BYTE            * pbEncoded,
                      DWORD             cbEncoded,
                      CRYPT_DATA_BLOB * pDecodedBlob)
{
    HRESULT hr = S_OK;
    DWORD   cbDecoded = 0;
    BYTE *  pbDecoded = NULL;

    DebugTrace("Entering DecodeObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszStructType);
    ATLASSERT(pbEncoded);
    ATLASSERT(pDecodedBlob);

    //
    // Intialize return value.
    //
    pDecodedBlob->cbData = 0;
    pDecodedBlob->pbData = NULL;

    //
    // Determine encoded length required.
    //
    if (!::CryptDecodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const BYTE *) pbEncoded,
                             cbEncoded,
                             0,
                             NULL,
                             &cbDecoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptDecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for decoded blob.
    //
    if (!(pbDecoded = (BYTE *) ::CoTaskMemAlloc(cbDecoded)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Decode.
    //
    if (!::CryptDecodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const BYTE *) pbEncoded,
                             cbEncoded,
                             0,
                             pbDecoded,
                             &cbDecoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptDecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return value.
    //
    pDecodedBlob->cbData = cbDecoded;
    pDecodedBlob->pbData = pbDecoded;

CommonExit:

    DebugTrace("Leaving DecodeObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbDecoded)
    {
        ::CoTaskMemFree((LPVOID) pbDecoded);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetMsgParam

  Synopsis : Allocate memory and retrieve requested message parameter using 
             CryptGetMsgParam() API.

  Parameter: HCRYPTMSG hMsg  - Message handler.
             DWORD dwMsgType - Message param type to retrieve.
             DWORD dwIndex   - Index (should be 0 most of the time).
             void ** ppvData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetMsgParam (HCRYPTMSG hMsg,
                     DWORD     dwMsgType,
                     DWORD     dwIndex,
                     void   ** ppvData,
                     DWORD   * pcbData)
{
    HRESULT hr     = S_OK;
    DWORD   cbData = 0;
    void *  pvData = NULL;

    DebugTrace("Entering GetMsgParam().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppvData);
    ATLASSERT(pcbData);
    
    //
    // Determine data buffer size.
    //
    if (!::CryptMsgGetParam(hMsg,
                            dwMsgType,
                            dwIndex,
                            NULL,
                            &cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for buffer.
    //
    if (!(pvData = (void *) ::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now get the data.
    //
    if (!::CryptMsgGetParam(hMsg,
                            dwMsgType,
                            dwIndex,
                            pvData,
                            &cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return msg param to caller.
    //
    *ppvData = pvData;
    *pcbData = cbData;

CommonExit:

    DebugTrace("Leaving GetMsgParam().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pvData)
    {
        ::CoTaskMemFree(pvData);
    }
    
    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetKeyParam

  Synopsis : Allocate memory and retrieve requested key parameter using 
             CryptGetKeyParam() API.

  Parameter: HCRYPTKEY hKey  - Key handler.
             DWORD dwParam   - Key parameter query.
             BYTE ** ppbData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetKeyParam (HCRYPTKEY hKey,
                     DWORD     dwParam,
                     BYTE   ** ppbData,
                     DWORD   * pcbData)
{
    HRESULT hr     = S_OK;
    DWORD   cbData = 0;
    BYTE  * pbData = NULL;

    DebugTrace("Entering GetKeyParam().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppbData);
    ATLASSERT(pcbData);
    
    //
    // Determine data buffer size.
    //
    if (!::CryptGetKeyParam(hKey,
                            dwParam,
                            NULL,
                            &cbData,
                            0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetKeyParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for buffer.
    //
    if (!(pbData = (BYTE *) ::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now get the data.
    //
    if (!::CryptGetKeyParam(hKey,
                            dwParam,
                            pbData,
                            &cbData,
                            0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetKeyParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return key param to caller.
    //
    *ppbData = pbData;
    *pcbData = cbData;

CommonExit:

    DebugTrace("Leaving GetKeyParam().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbData)
    {
        ::CoTaskMemFree(pbData);
    }
    
    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindSignerCertInMessage

  Synopsis : Find the signer's cert in the bag of certs of the message for the
             specified signer.

  Parameter: HCRYPTMSG hMsg                          - Message handle.
             CERT_NAME_BLOB * pIssuerNameBlob        - Pointer to issuer' name
                                                       blob of signer's cert.
             CRYPT_INTEGERT_BLOB * pSerialNumberBlob - Pointer to serial number
                                                       blob of signer's cert.
             PCERT_CONTEXT * ppCertContext           - Pointer to PCERT_CONTEXT
                                                       to receive the found 
                                                       cert, or NULL to only
                                                       know the result.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT FindSignerCertInMessage (HCRYPTMSG            hMsg, 
                                 CERT_NAME_BLOB     * pIssuerNameBlob,
                                 CRYPT_INTEGER_BLOB * pSerialNumberBlob,
                                 PCERT_CONTEXT      * ppCertContext)
{
    HRESULT hr = S_OK;
    DWORD dwCertCount = 0;
    DWORD cbCertCount = sizeof(dwCertCount);

    DebugTrace("Entering FindSignerCertInMessage().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != hMsg);
    ATLASSERT(NULL != pIssuerNameBlob);
    ATLASSERT(NULL != pSerialNumberBlob);
    ATLASSERT(0 < pIssuerNameBlob->cbData);
    ATLASSERT(NULL != pIssuerNameBlob->pbData);
    ATLASSERT(0 < pSerialNumberBlob->cbData);
    ATLASSERT(NULL != pSerialNumberBlob->pbData);

    //
    // Get count of certs in message.
    //
    if (!::CryptMsgGetParam(hMsg,
                            CMSG_CERT_COUNT_PARAM,
                            0,
                            &dwCertCount,
                            &cbCertCount))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        return hr;
    }

    //
    // See if the signer's cert is in the bag of certs.
    //
    while (dwCertCount--)
    {
        PCCERT_CONTEXT pCertContext = NULL;
        CRYPT_DATA_BLOB EncodedCertBlob = {0, NULL};

        //
        // Get a cert from the bag of certs.
        //
        hr = ::GetMsgParam(hMsg, 
                           CMSG_CERT_PARAM,
                           dwCertCount,
                           (void **) &EncodedCertBlob.pbData,
                           &EncodedCertBlob.cbData);
        if (FAILED(hr))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed.\n", hr);
            return hr;
        }

        //
        // Create a context for the cert.
        //
        pCertContext = ::CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                      (const BYTE *) EncodedCertBlob.pbData,
                                                      EncodedCertBlob.cbData);

        //
        // Free encoded cert blob memory before checking result.
        //
        ::CoTaskMemFree((LPVOID) EncodedCertBlob.pbData);
 
        if (NULL == pCertContext)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
            return hr;
        }

        //
        // Compare.
        //
        if (::CertCompareCertificateName(CAPICOM_ASN_ENCODING,
                                         pIssuerNameBlob,
                                         &pCertContext->pCertInfo->Issuer) &&
            ::CertCompareIntegerBlob(pSerialNumberBlob,
                                     &pCertContext->pCertInfo->SerialNumber))
        {
            if (NULL != ppCertContext)
            {
                *ppCertContext = (PCERT_CONTEXT) pCertContext;
            }
            else
            {
                ::CertFreeCertificateContext(pCertContext);
            }
        
            return S_OK;
        }
        else
        {
            //
            // No, keep looking.
            //
            ::CertFreeCertificateContext(pCertContext);
        }
    }

    //
    // If we get here, that means we never found the cert.
    //
    return CAPICOM_E_SIGNER_NOT_FOUND;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsAlgSupported

  Synopsis : Check to see if the algo is supported by the CSP.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             ALG_ID AlgID - Algorithm ID.

             PROV_ENUMALGS_EX * pPeex - Pointer to PROV_ENUMALGS_EX to receive
                                        the found structure.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsAlgSupported (HCRYPTPROV         hCryptProv, 
                        ALG_ID             AlgID, 
                        PROV_ENUMALGS_EX * pPeex)
{
    HRESULT hr       = CAPICOM_E_NOT_SUPPORTED;
    DWORD   EnumFlag = CRYPT_FIRST;
    DWORD   cbPeex   = sizeof(PROV_ENUMALGS_EX);
    
    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(pPeex);

    //
    // Initialize.
    //
    ::ZeroMemory(pPeex, sizeof(PROV_ENUMALGS_EX));

    //
    // Get algorithm capability from CSP.
    //
    while (::CryptGetProvParam(hCryptProv,
                               PP_ENUMALGS_EX,          
                               (BYTE *) pPeex,
                               &cbPeex,
                               EnumFlag))
    {
        EnumFlag = 0;

        if (pPeex->aiAlgid == AlgID)
        {
            hr = S_OK;
            break;
        }
    }

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context for the specified CSP and keyset container.
  
  Parameter: LPSTR pszProvider - CSP provider name or NULL.
  
             LPSTR pszContainer - Keyset container name or NULL.

             DWORD dwFlags - Same as dwFlags of CryptAcquireConext.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext(LPSTR        pszProvider, 
                       LPSTR        pszContainer,
                       DWORD        dwFlags,
                       HCRYPTPROV * phCryptProv)
{
    HRESULT    hr         = S_OK;
    HCRYPTPROV hCryptProv = NULL;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Get handle to the default provider.
    //
    if(!::CryptAcquireContextA(&hCryptProv, 
                               pszContainer, 
                               pszProvider, 
                               PROV_RSA_FULL, 
                               dwFlags)) 
    {
        DWORD dwWinError = ::GetLastError();

        if (NTE_BAD_KEYSET != dwWinError)
	    {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CryptAcquireContextA() failed.\n", hr);
            goto CommonExit;
	    }

        //
        // Keyset container not found, so create it.
        //
        if(!::CryptAcquireContextA(&hCryptProv, 
                                   pszContainer, 
                                   pszProvider, 
                                   PROV_RSA_FULL, 
                                   CRYPT_NEWKEYSET | dwFlags)) 
	    {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptAcquireContextA() failed.\n", hr);
            goto CommonExit;
        }
    }

    //
    // Return handle to caller.
    //
    *phCryptProv = hCryptProv;

CommonExit:

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: ALG_ID AlgOID - Algorithm ID.

             DWORD dwKeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.
  
------------------------------------------------------------------------------*/

HRESULT AcquireContext(ALG_ID       AlgID,
                       DWORD        dwKeyLength,
                       HCRYPTPROV * phCryptProv)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // First try default provider.
    //
    if (SUCCEEDED(::AcquireContext(NULL,   // Default provider
                                   NULL, 
                                   CRYPT_VERIFYCONTEXT, 
                                   phCryptProv)))
    {
        PROV_ENUMALGS_EX peex;

        //
        // See if AlgID and key length supported.
        //
        if (SUCCEEDED(::IsAlgSupported(*phCryptProv, AlgID, &peex)) &&
            (peex.dwMinLen <= dwKeyLength && dwKeyLength <= peex.dwMaxLen))
        {
            goto CommonExit;
        }
        else
        {
            ::CryptReleaseContext(*phCryptProv, 0);
        }
    }

    //
    // Next try MS Enhanced provider, and then MS Strong provider.
    //
    if (FAILED(::AcquireContext(MS_ENHANCED_PROV_A, 
                                NULL, 
                                CRYPT_VERIFYCONTEXT, 
                                phCryptProv)) &&
        FAILED(::AcquireContext(MS_STRONG_PROV_A, 
                                NULL, 
                                CRYPT_VERIFYCONTEXT, 
                                phCryptProv)))
    {
        //
        // For 3DES, must have either Enhanced or Strong.
        //
        if (CALG_3DES == AlgID)
        {
            hr = CAPICOM_E_NOT_SUPPORTED;

            DebugTrace("Error: 3DES is not available.\n");
            goto CommonExit;
        }

        //
        // Finally, try MS Base provider if user requested for DES, or 
        // 56-bits or less for others.
        //
        if ((CALG_DES != AlgID) && (128 <= dwKeyLength))
        {
            hr = CAPICOM_E_NOT_SUPPORTED;

            DebugTrace("Error: 128-bits (or more) encryption is not available.\n");
            goto CommonExit;
        }

        if (FAILED(hr = ::AcquireContext(MS_DEF_PROV_A, 
                                         NULL, 
                                         CRYPT_VERIFYCONTEXT, 
                                         phCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto CommonExit;
        }
    }

CommonExit:

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algorithm name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.

             Note also the the returned handle cannot be used to access private 
             key, and should NOT be used to store assymetric key, as it refers 
             to the default container, which can be easily destroy any existing 
             assymetric key pair.

------------------------------------------------------------------------------*/

HRESULT AcquireContext (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                        HCRYPTPROV                  * phCryptProv)
{
    HRESULT hr          = S_OK;
    ALG_ID  AlgID       = 0;
    DWORD   dwKeyLength = 0;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Convert enum name to ALG_ID.
    //
    if (FAILED(hr = ::EnumNameToAlgID(AlgoName, &AlgID)))
    {
        DebugTrace("Error [%#x]: EnumNameToAlgID() failed.\n");
        goto CommonExit;
    }

    //
    // Convert enum name to key length.
    //
    if (FAILED(hr = ::EnumNameToKeyLength(KeyLength, &dwKeyLength)))
    {
        DebugTrace("Error [%#x]: EnumNameToKeyLength() failed.\n");
        goto CommonExit;
    }

    //
    // Pass on to overloaded version.
    //
    hr = ::AcquireContext(AlgID, dwKeyLength, phCryptProv);

CommonExit:

    DebugTrace("Leaving AcquireContext().\n");
    
    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire the proper CSP and access to the private key for 
             the specified cert.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert.

             HCRYPTPROV * phCryptProv    - Pointer to HCRYPTPROV to recevice
                                           CSP context.

             DWORD * pdwKeySpec          - Pointer to DWORD to receive key
                                           spec, AT_KEYEXCHANGE or AT_SIGNATURE.

             BOOL * pbReleaseContext     - Upon successful and if this is set
                                           to TRUE, then the caller must
                                           free the CSP context by calling
                                           CryptReleaseContext(), otherwise
                                           the caller must not free the CSP
                                           context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext (PCCERT_CONTEXT pCertContext, 
                        HCRYPTPROV   * phCryptProv, 
                        DWORD        * pdwKeySpec, 
                        BOOL         * pbReleaseContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(phCryptProv);
    ATLASSERT(pdwKeySpec);
    ATLASSERT(pbReleaseContext);

    //
    // Acquire CSP context and access to the private key associated 
    // with this cert.
    //
    if (!::CryptAcquireCertificatePrivateKey(pCertContext,
                                             CRYPT_ACQUIRE_USE_PROV_INFO_FLAG,
                                             NULL,
                                             phCryptProv,
                                             pdwKeySpec,
                                             pbReleaseContext))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptAcquireCertificatePrivateKey() failed.\n", hr);
    }

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ReleaseContext

  Synopsis : Release CSP context.
  
  Parameter: HCRYPTPROV hProv - CSP handle.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT ReleaseContext (HCRYPTPROV hProv)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering ReleaseContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hProv);

    //
    // Release the context.
    //
    if (!::CryptReleaseContext(hProv, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptReleaseContext() failed.\n", hr);
    }

    DebugTrace("Leaving ReleaseContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : OIDToAlgID

  Synopsis : Convert algorithm OID to the corresponding ALG_ID value.

  Parameter: LPSTR pszAlgoOID - Algorithm OID string.
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT OIDToAlgID (LPSTR    pszAlgoOID, 
                    ALG_ID * pAlgID)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering OIDToAlgID().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszAlgoOID);
    ATLASSERT(pAlgID);

    //
    // Determine ALG_ID.
    //
    if (0 == ::lstrcmpA(szOID_RSA_RC2CBC, pszAlgoOID))
    {
        *pAlgID = CALG_RC2;
    }
    else if (0 == ::lstrcmpA(szOID_RSA_RC4, pszAlgoOID))
    {
        *pAlgID = CALG_RC4;
    }
    else if (0 == ::lstrcmpA(szOID_OIWSEC_desCBC, pszAlgoOID))
    {
        *pAlgID = CALG_DES;
    }
    else if (0 == ::lstrcmpA(szOID_RSA_DES_EDE3_CBC, pszAlgoOID))
    {
        *pAlgID = CALG_3DES;
    }
    else
    {
        hr = CAPICOM_E_INVALID_ALGORITHM;
        DebugTrace("Error: invalid parameter, unknown algorithm OID.\n");
    }

    DebugTrace("Leaving OIDToAlgID().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToOID

  Synopsis : Convert ALG_ID value to the corresponding algorithm OID.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.

             LPSTR * ppszAlgoOID - Pointer to LPSTR to receive the OID string.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToOID (ALG_ID  AlgID, 
                    LPSTR * ppszAlgoOID)
{
    HRESULT hr = S_OK;
    LPSTR   pszAlgoOID = NULL;

    DebugTrace("Entering AlgIDToOID().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppszAlgoOID);

    //
    // Determine ALG_ID.
    //
    switch (AlgID)
    {
        case CALG_RC2:
        {
            pszAlgoOID = szOID_RSA_RC2CBC;
            break;
        }

        case CALG_RC4:
        {
            pszAlgoOID = szOID_RSA_RC4;
            break;
        }

        case CALG_DES:
        {
            pszAlgoOID = szOID_OIWSEC_desCBC;
            break;
        }

        case CALG_3DES:
        {
            pszAlgoOID = szOID_RSA_DES_EDE3_CBC;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;
            DebugTrace("Error: invalid parameter, unknown algorithm OID.\n");
            goto CommonExit;
        }
    }

    //
    // Allocate memory.
    //
    if (!(*ppszAlgoOID = (LPSTR) ::CoTaskMemAlloc(::lstrlen(pszAlgoOID) + 1)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto CommonExit;
    }

    //
    // Copy OID string to caller.
    //
    ::lstrcpy(*ppszAlgoOID, pszAlgoOID);

CommonExit:

    DebugTrace("Leaving AlgIDToOID().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToEnumName

  Synopsis : Convert ALG_ID value to the corresponding algorithm enum name.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.
  
             CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName - Receive algo enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToEnumName (ALG_ID                         AlgID, 
                         CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AlgIDToEnumName().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAlgoName);

    switch (AlgID)
    {
        case CALG_RC2:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_RC2;
            break;
        }

        case CALG_RC4:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_RC4;
            break;
        }

        case CALG_DES:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_DES;
            break;
        }

        case CALG_3DES:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_3DES;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;
            DebugTrace("Error: invalid parameter, unknown ALG_ID.\n");
        }
    }

    DebugTrace("Leaving AlgIDToEnumName().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToAlgID

  Synopsis : Convert algorithm enum name to the corresponding ALG_ID value.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algo enum name
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.  

  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToAlgID (CAPICOM_ENCRYPTION_ALGORITHM AlgoName, 
                         ALG_ID                     * pAlgID)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering EnumNameToAlgID().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAlgID);

    switch (AlgoName)
    {
        case CAPICOM_ENCRYPTION_ALGORITHM_RC2:
        {
            *pAlgID = CALG_RC2;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_RC4:
        {
            *pAlgID = CALG_RC4;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_DES:
        {
            *pAlgID = CALG_DES;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_3DES:
        {
            *pAlgID = CALG_3DES;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;
            DebugTrace("Error: invalid parameter, unknown CAPICOM_ENCRYPTION_ALGORITHM.\n");
        }
    }

    DebugTrace("Leaving EnumNameToAlgID().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : KeyLengthToEnumName

  Synopsis : Convert actual key length value to the corresponding key length
             enum name.

  Parameter: DWORD dwKeyLength - Key length.
  
             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName - Receive key length
                                                           enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT KeyLengthToEnumName (DWORD                           dwKeyLength, 
                             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering KeyLengthToEnumName().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pKeyLengthName);

    switch (dwKeyLength)
    {
        case 40:
        {
            *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS;
            break;
        }
    
        case 56:
        {
            *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS;
            break;
        }

        case 128:
        {
            *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_KEY_LENGTH;
            DebugTrace("Error: invalid parameter, unknown key length.\n");
        }
    }
 
    DebugTrace("Leaving KeyLengthToEnumName().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToKeyLength

  Synopsis : Convert key length enum name to the corresponding actual key length 
             value .

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName - Key length enum name.
                                                          
             DWORD * pdwKeyLength - Pointer to DWORD to receive value.
             
  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToKeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName,
                             DWORD                       * pdwKeyLength)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering EnumNameToKeyLength().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pdwKeyLength);

    switch (KeyLengthName)
    {
        case CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS:
        {
            *pdwKeyLength = 40;
            break;
        }
    
        case CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS:
        {
            *pdwKeyLength = 56;
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS:
        {
            *pdwKeyLength = 128;
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM:
        {
            HCRYPTPROV hCryptProv = NULL;

            //
            // For 128-bits, need either Enhanced or Strong provider.
            //
            if (FAILED(::AcquireContext(MS_ENHANCED_PROV_A, 
                                        NULL, 
                                        CRYPT_VERIFYCONTEXT, 
                                        &hCryptProv)) &&
                FAILED(::AcquireContext(MS_STRONG_PROV_A, 
                                        NULL, 
                                        CRYPT_VERIFYCONTEXT, 
                                        &hCryptProv)))
            {
                //
                // Only 56-bits maximum for MS Base provider.
                //
                *pdwKeyLength = 56;
            }
            else
            {
                *pdwKeyLength = 128;

                ::ReleaseContext(hCryptProv);
            }

            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_KEY_LENGTH;
            DebugTrace("Error: invalid parameter, unknown CAPICOM_ENCRYPTION_KEY_LENGTH.\n");
        }
    }
 
    DebugTrace("Leaving EnumNameToKeyLength().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\common.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Common.h

  Content: Declaration of Common.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef __COMMON_H_
#define __COMMON_H_

#include <wincrypt.h>

#include "capicom.h"
#include "resource.h"       // main symbols


////////////////////
//
// typedefs
//

typedef enum osVersion
{
    WIN_9X  = 0,
    WIN_NT4 = 1,
    WIN_NT5 = 2,
} OSVERSION, * POSVERSION;


#ifndef SAFE_SUBTRACT_POINTERS
#define SAFE_SUBTRACT_POINTERS(__x__, __y__) ( DW_PtrDiffc(__x__, sizeof(*(__x__)), __y__, sizeof(*(__y__))) )

__inline DWORD
DW_PtrDiffc(
    IN void const *pb1,
    IN DWORD dwPtrEltSize1,
    IN void const *pb2,
    IN DWORD dwPtrEltSize2)
{
    // pb1 should be greater
    ATLASSERT((ULONG_PTR)pb1 >= (ULONG_PTR)pb2);

    // both should have same elt size
    ATLASSERT(dwPtrEltSize1 == dwPtrEltSize2);

    // assert that the result doesn't overflow 32-bits
    ATLASSERT((DWORD)((ULONG_PTR)pb1 - (ULONG_PTR)pb2) == (ULONG_PTR)((ULONG_PTR)pb1 - (ULONG_PTR)pb2));

    // return number of objects between these pointers
    return (DWORD) ( ((ULONG_PTR)pb1 - (ULONG_PTR)pb2) / dwPtrEltSize1 );
}
#endif SAFE_SUBTRACT_POINTERS

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetOSVersion

  Synopsis : Get the current OS platform/version.

  Parameter: POSVERSION pOSVersion - Pointer to OSVERSION to receive result.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetOSVersion (POSVERSION pOSVersion);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EncodeObject

  Synopsis : Allocate memory and encode an ASN.1 object using CAPI
             CryptEncodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible 
                                              types.
             LPVOID pbData                  - Pointer to data to be encoded 
                                              (data type must match 
                                              pszStrucType).
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the encoded length and 
                                              data.

  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT EncodeObject (LPCSTR            pszStructType, 
                      LPVOID            pbData, 
                      CRYPT_DATA_BLOB * pEncodedBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DecodeObject

  Synopsis : Allocate memory and decode an ASN.1 object using CAPI
             CryptDecodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible
                                              types.
             BYTE * pbEncoded               - Pointer to data to be decoded 
                                              (data type must match 
                                              pszStrucType).
             DWORD cbEncoded                - Size of encoded data.
             CRYPT_DATA_BLOB * pDecodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the decoded length and 
                                              data.
  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT DecodeObject (LPCSTR            pszStructType, 
                      BYTE            * pbEncoded,
                      DWORD             cbEncoded,
                      CRYPT_DATA_BLOB * pDecodedBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetMsgParam

  Synopsis : Allocate memory and retrieve requested message parameter from 
             the signed message using CryptGetMsgParam() API.
             select a signing cert.

  Parameter: HCRYPTMSG hMsg  - Message handler.
             DWORD dwMsgType - Message param type to retrieve.
             DWORD dwIndex   - Index (should be 0 most of the time).
             void ** ppvData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetMsgParam (HCRYPTMSG hMsg,
                     DWORD     dwMsgType,
                     DWORD     dwIndex,
                     void   ** ppvData,
                     DWORD   * pcbData);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetKeyParam

  Synopsis : Allocate memory and retrieve requested key parameter using 
             CryptGetKeyParam() API.

  Parameter: HCRYPTKEY hKey  - Key handler.
             DWORD dwParam   - Key parameter query.
             BYTE ** ppbData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetKeyParam (HCRYPTKEY hKey,
                     DWORD     dwParam,
                     BYTE   ** ppbData,
                     DWORD   * pcbData);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindSignerCertInMessage

  Synopsis : Find the signer's cert in the bag of certs of the message for the
             specified signer.

  Parameter: HCRYPTMSG hMsg                          - Message handle.
             CERT_NAME_BLOB * pIssuerNameBlob        - Pointer to issuer' name
                                                       blob of signer's cert.
             CRYPT_INTEGERT_BLOB * pSerialNumberBlob - Pointer to serial number
                                                       blob of signer's cert.
             PCERT_CONTEXT * ppCertContext           - Pointer to PCERT_CONTEXT
                                                       to receive the found 
                                                       cert, or NULL to only
                                                       know the result.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT FindSignerCertInMessage (HCRYPTMSG            hMsg, 
                                 CERT_NAME_BLOB     * pIssuerNameBlob,
                                 CRYPT_INTEGER_BLOB * pSerialNumberBlob,
                                 PCERT_CONTEXT      * ppCertContext);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsAlgSupported

  Synopsis : Check to see if the algo is supported by the CSP.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             ALG_ID AlgID - Algorithm ID.

             PROV_ENUMALGS_EX * pPeex - Pointer to PROV_ENUMALGS_EX to receive
                                        the found structure.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsAlgSupported (HCRYPTPROV         hCryptProv, 
                        ALG_ID             AlgID, 
                        PROV_ENUMALGS_EX * pPeex);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context for the specified CSP and keyset container.
  
  Parameter: LPSTR pszProvider - CSP provider name or NULL.
  
             LPSTR pszContainer - Keyset container name or NULL.

             DWORD dwFlags - Same as dwFlags of CryptAcquireConext.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext (LPSTR        pszProvider, 
                        LPSTR        pszContainer,
                        DWORD        dwFlags,
                        HCRYPTPROV * phCryptProv);
                      
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: ALG_ID AlgOID - Algorithm ID.

             DWORD dwKeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.
  
------------------------------------------------------------------------------*/

HRESULT AcquireContext (ALG_ID       AlgID,
                        DWORD        dwKeyLength,
                        HCRYPTPROV * phCryptProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algorithm name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.

             Note also the the returned handle cannot be used to access private 
             key, and should NOT be used to store assymetric key, as it refers 
             to the default container, which can be easily destroy any existing 
             assymetric key pair.

------------------------------------------------------------------------------*/

HRESULT AcquireContext (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                        HCRYPTPROV                  * phCryptProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire the proper CSP and access to the private key for 
             the specified cert.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert.

             HCRYPTPROV * phCryptProv    - Pointer to HCRYPTPROV to recevice
                                           CSP context.

             DWORD * pdwKeySpec          - Pointer to DWORD to receive key
                                           spec, AT_KEYEXCHANGE or AT_SIGNATURE.

             BOOL * pbReleaseContext     - Upon successful and if this is set
                                           to TRUE, then the caller must
                                           free the CSP context by calling
                                           CryptReleaseContext(), otherwise
                                           the caller must not free the CSP
                                           context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext (PCCERT_CONTEXT pCertContext, 
                        HCRYPTPROV   * phCryptProv, 
                        DWORD        * pdwKeySpec, 
                        BOOL         * pbReleaseContext);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ReleaseContext

  Synopsis : Release CSP context.
  
  Parameter: HCRYPTPROV hProv - CSP handle.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT ReleaseContext (HCRYPTPROV hProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : OIDToAlgID

  Synopsis : Convert algorithm OID to the corresponding ALG_ID value.

  Parameter: LPSTR pszAlgoOID - Algorithm OID string.
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT OIDToAlgID (LPSTR    pszAlgoOID, 
                    ALG_ID * pAlgID);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToOID

  Synopsis : Convert ALG_ID value to the corresponding algorithm OID.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.

             LPSTR * ppszAlgoOID - Pointer to LPSTR to receive the OID string.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToOID (ALG_ID  AlgID, 
                    LPSTR * ppszAlgoOID);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToEnumName

  Synopsis : Convert ALG_ID value to the corresponding algorithm enum name.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.
  
             CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName - Receive algo enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToEnumName (ALG_ID                         AlgID, 
                         CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToAlgID

  Synopsis : Convert algorithm enum name to the corresponding ALG_ID value.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algo enum name
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.  

  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToAlgID (CAPICOM_ENCRYPTION_ALGORITHM AlgoName, 
                         ALG_ID                     * pAlgID);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : KeyLengthToEnumName

  Synopsis : Convert actual key length value to the corresponding key length
             enum name.

  Parameter: DWORD dwKeyLength - Key length.
  
             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName - Receive key length
                                                           enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT KeyLengthToEnumName (DWORD                           dwKeyLength, 
                             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToKeyLength

  Synopsis : Convert key length enum name to the corresponding actual key length 
             value .

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName - Key length enum name.
                                                          
             DWORD * pdwKeyLength - Pointer to DWORD to receive value.
             
  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToKeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName, 
                             DWORD                       * pdwKeyLength);

#endif //__COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\convert.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Convert.h

  Content:    Declaration of convertion routines.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CONVERT_H_
#define __CONVERT_H_

#include "stdafx.h"
#include "capicom.h"
#include "resource.h"           // main symbols

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UnicodeToAnsi

  Synopsis : Convert a Unicode string to ANSI.

  Parameter: WCHAR * lpwszUnicodeString - Pointer to Unicode string to be
                                          converted to ANSI string.

  Return   : NULL if error, otherwise, pointer to converted ANSI string.

  Remark   : Caller free allocated memory for the returned ANSI string.

------------------------------------------------------------------------------*/

char * UnicodeToAnsi (WCHAR * lpwszUnicodeString);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BlobToBstr

  Synopsis : Convert a blob to BSTR.

  Parameter: DATA_BLOB * lpBlob - Pointer to blob to be converted to BSTR.

             BSTR * lpBstr - Pointer to BSTR to receive the converted BSTR.

  Remark   : Caller free allocated memory for the returned BSTR.

------------------------------------------------------------------------------*/

HRESULT BlobToBstr (DATA_BLOB * lpBlob, 
                    BSTR *      lpBstr);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BstrToBlob

  Synopsis : Convert a BSTR to blob.

  Parameter: BSTR bstr - BSTR to be converted to blob.
  
             DATA_BLOB * lpBlob - Pointer to DATA_BLOB to receive converted blob.

  Remark   : Caller free allocated memory for the returned BLOB.

------------------------------------------------------------------------------*/

HRESULT BstrToBlob (BSTR        bstr, 
                    DATA_BLOB * lpBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ExportData

  Synopsis : Export binary data to a BSTR with specified encoding type.

  Parameter: DATA_BLOB DataBlob - Binary data blob.
    
             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the encoded data.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT ExportData (DATA_BLOB             DataBlob, 
                    CAPICOM_ENCODING_TYPE EncodingType, 
                    BSTR *                pbstrEncoded);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ImportData

  Synopsis : Import encoded data.

  Parameter: BSTR bstrEncoded - BSTR containing the data to be imported.

             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive the
                                     decoded data.
  
  Remark   : There is no need for encoding type parameter, as the encoding type
             will be determined automatically by this routine.

------------------------------------------------------------------------------*/

HRESULT ImportData (BSTR        bstrEncoded, 
                    DATA_BLOB * pDataBlob);

#endif //__CONVERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\debug.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Envelop.cpp

  Content: Implementation of debugging facilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Debug.h"

#ifdef _DEBUG

#define CAPICOM_DUMP_DIR_ENV_VAR   "CAPICOM_DUMP_DIR"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DumpToFile

  Synopsis : Dump data to file for debug analysis.

  Parameter: char * szFileName - File name (just the file name without any
                                 directory path).
  
             BYTE * pbData - Pointer to data.
             
             DWORD cbData - Size of data.

  Remark   : No action is taken if the environment variable, CAPICOM_DUMP_DIR,
             is not defined. If defined, the value should be the directory
             where the file would be created (i.e. C:\Test).

------------------------------------------------------------------------------*/

void DumpToFile (char * szFileName, BYTE * pbData, DWORD cbData)
{ 
    DWORD  dwSize = 0;
    char * szPath = NULL;
    HANDLE hFile  = NULL;

    //
    // No dump, if CAPICOM_DUMP_DIR environment is not found.
    //
    if (0 == (dwSize = ::GetEnvironmentVariableA(CAPICOM_DUMP_DIR_ENV_VAR, NULL, 0)))
    {
        goto CommonExit;
    }

    //
    // Allocate memory for the entire path (dir + filename).
    //
    if (!(szPath = (char *) ::CoTaskMemAlloc(dwSize + ::lstrlenA(szFileName) + 1)))
    {
        goto CommonExit;
    }

    //
    // Get the dir.
    //
    if (dwSize != ::GetEnvironmentVariableA(CAPICOM_DUMP_DIR_ENV_VAR, szPath, dwSize) + 1)
    {
        goto CommonExit;
    }

    //
    // Append \ if not the last char.
    //
    if (szPath[dwSize - 1] != '\\')
    {
        ::lstrcatA(szPath, "\\");
    }

    //
    // Form full path.
    //
    ::lstrcatA(szPath, szFileName);

    //
    // Open the file.
    //
    if (hFile = ::CreateFileA(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL))
    {
        DWORD cbWritten = 0;

        ::WriteFile(hFile,        // handle to file
                    pbData,       // data buffer
                    cbData,       // number of bytes to write
                    &cbWritten,   // number of bytes written
                    NULL);        // overlapped buffer

        ATLASSERT(cbData == cbWritten);
    }

CommonExit:
    //
    // Free resource.
    //
    if (hFile)
    {
        ::CloseHandle(hFile);
    }
    if (szPath)
    {
        ::CoTaskMemFree(szPath);
    }

    return;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\copyitem.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999

  File:    CopyItem.h

  Content: Declaration of _CopyXXXItem template class.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef __CopyItem_H_
#define __CopyItem_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <map>
#pragma warning(disable:4786) // Disable symbol names > 256 character warning.


//
// _CopyMapItem class. 
//
template <class T>
class _CopyMapItem
{
public:
    //
    // copy method.
    //
    static HRESULT copy(VARIANT * p1, std::pair<const CComBSTR, CComPtr<T> > * p2)
    {
        CComPtr<T> p = p2->second;
        CComVariant var = p;
        return VariantCopy(p1, &var);
    }

    //
    // init method.
    //
	static void init(VARIANT * p)
    {
        p->vt = VT_EMPTY;
    }

    //
    // destroy method.
    //
	static void destroy(VARIANT * p)
    {
        VariantClear(p);
    }
};

#if (0) //DSIE
template <class DestinationType, class SourceType = DestinationType>
class GenericCopy
{
public :
	typedef DestinationType	destination_type;
	typedef SourceType		source_type;

	static void init(destination_type* p)
	{
		_Copy<destination_type>::init(p);
	}
	static void destroy(destination_type* p)
	{
		_Copy<destination_type>::destroy(p);
	}
	static HRESULT copy(destination_type* pTo, const source_type* pFrom)
	{
		return _Copy<destination_type>::copy(pTo, const_cast<source_type*>(pFrom));
	}

}; // class GenericCopy

template <>
class GenericCopy<VARIANT, std::string>
{
public :
	typedef VARIANT		destination_type;
	typedef std::string	source_type;

	static void init(destination_type* p)
	{
		GenericCopy<destination_type>::init(p);
	}
	static void destroy(destination_type* p)
	{
		GenericCopy<destination_type>::destroy(p);
	}
	static HRESULT copy(destination_type* pTo, const source_type* pFrom)
	{
		return CComVariant(pFrom->c_str()).Detach(pTo);
	}

}; // class GenericCopy<VARIANT, std::string>

template <>
class GenericCopy<BSTR, std::string>
{
public :
	typedef BSTR		destination_type;
	typedef std::string	source_type;

	static void init(destination_type* p)
	{
		GenericCopy<destination_type>::init(p);
	}
	static void destroy(destination_type* p)
	{
		GenericCopy<destination_type>::destroy(p);
	}
	static HRESULT copy(destination_type* pTo, const source_type* pFrom)
	{
		*pTo = CComBSTR(pFrom->c_str()).Detach();
		if (*pTo)
			return S_OK;
		else
			return E_OUTOFMEMORY;
	}

}; // class GenericCopy<BSTR, std::string>
#endif //DSIE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\convert.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Convert.cpp

  Contents:   Implementation of encoding conversion routines.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "capicom.h"
#include "base64.h"
#include "convert.h"

#include <wincrypt.h>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UnicodeToAnsi

  Synopsis : Convert a Unicode string to ANSI.

  Parameter: WCHAR * lpwszUnicodeString - Pointer to Unicode string to be
                                          converted to ANSI string.

  Return   : NULL if error, otherwise, pointer to converted ANSI string.

  Remark   : Caller free allocated memory for the returned ANSI string.

------------------------------------------------------------------------------*/

char * UnicodeToAnsi (WCHAR * lpwszUnicodeString)
{
    DWORD dwSize = 0;
    char * lpszAnsiString = NULL;

    //
    // Return NULL if requested.
    //
    if (NULL == lpwszUnicodeString)
    {
        return (char *) NULL;
    }

    //
    // Determine ANSI length.
    //
    dwSize = WideCharToMultiByte(CP_ACP,                // code page
                                 0,                     // performance and mapping flags
                                 lpwszUnicodeString,    // wide-character string
                                 -1,                    // number of chars in string
                                 NULL,                  // buffer for new string
                                 0,                     // size of buffer
                                 NULL,                  // default for unmappable chars
                                 NULL);                 // set when default char used
    if (0 == dwSize)
    {
        DebugTrace("Error [%#x]: WideCharToMultiByte() failed.\n");
        return (char *) NULL;
    }

    //
    // Allocate memory for ANSI string.
    //
    if (!(lpszAnsiString = (char *) ::CoTaskMemAlloc(dwSize)))
    {
        DebugTrace("Error: out of memory.\n");
        return (char *) NULL;
    }

    //
    // Conver to ANSI.
    //
    dwSize = WideCharToMultiByte(CP_ACP,
                                 0,
                                 lpwszUnicodeString,
                                 -1,
                                 lpszAnsiString,
                                 dwSize,
                                 NULL,
                                 NULL);
    if (0 == dwSize)
    {
        ::CoTaskMemFree((LPVOID) lpszAnsiString);

        DebugTrace("Error [%#x]: WideCharToMultiByte() failed.\n");
        return (char *) NULL;
    }

    //
    // Successful, so return ANSI string to caller.
    //
    return lpszAnsiString;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BlobToBstr

  Synopsis : Convert a blob to BSTR.

  Parameter: DATA_BLOB * lpBlob - Pointer to blob to be converted to BSTR.

             BSTR * lpBstr - Pointer to BSTR to receive the converted BSTR.

  Remark   : Caller free allocated memory for the returned BSTR.

------------------------------------------------------------------------------*/

HRESULT BlobToBstr (DATA_BLOB * lpBlob, 
                    BSTR *      lpBstr)
{
    //
    // Return NULL if requested.
    //
    if (!lpBstr)
    {
        DebugTrace("Error: invalid parameter, lpBstr is NULL.\n");
        return E_POINTER;
    }

    //
    // Make sure parameter is valid.
    //
    if (!lpBlob || !lpBlob->cbData || !lpBlob->pbData)
    {
        *lpBstr = NULL;
        return S_OK;
    }

    //
    // Convert to BSTR without code page conversion
    //
    if (!(*lpBstr = ::SysAllocStringByteLen((LPCSTR) lpBlob->pbData, lpBlob->cbData)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BstrToBlob

  Synopsis : Convert a BSTR to blob.

  Parameter: BSTR bstr - BSTR to be converted to blob.
  
             DATA_BLOB * lpBlob - Pointer to DATA_BLOB to receive converted blob.

  Remark   : Caller free allocated memory for the returned BLOB.

------------------------------------------------------------------------------*/

HRESULT BstrToBlob (BSTR        bstr, 
                    DATA_BLOB * lpBlob)
{
    //
    // Make sure parameter is valid.
    //
    if (NULL == lpBlob)
    {
        DebugTrace("Error: invalid parameter, lpBlob is NULL.\n");
        return E_POINTER;
    }

    //
    // Return NULL if requested.
    //
    if (NULL == bstr || 0 == ::SysStringByteLen(bstr))
    {
        lpBlob->cbData = 0;
        lpBlob->pbData = NULL;
        return S_OK;
    }

    //
    // Allocate memory.
    //
    lpBlob->cbData = ::SysStringByteLen(bstr);
    if (!(lpBlob->pbData = (LPBYTE) ::CoTaskMemAlloc(lpBlob->cbData)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    //
    // Convert to blob without code page conversion.
    //
    ::CopyMemory(lpBlob->pbData, (LPBYTE) bstr, lpBlob->cbData);

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ExportData

  Synopsis : Export binary data to a BSTR with specified encoding type.

  Parameter: DATA_BLOB DataBlob - Binary data blob.
    
             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the encoded data.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT ExportData (DATA_BLOB             DataBlob, 
                    CAPICOM_ENCODING_TYPE EncodingType, 
                    BSTR *                pbstrEncoded)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering ExportData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(DataBlob.cbData);
    ATLASSERT(DataBlob.pbData);
    ATLASSERT(pbstrEncoded);
    
    //
    // Intialize.
    //
    *pbstrEncoded = NULL;

    //
    // Determine encoding type.
    //
    switch (EncodingType)
    {
        case CAPICOM_ENCODE_BINARY:
        {
            //
            // No encoding needed, simply convert blob to bstr.
            //
            if (FAILED(hr = ::BlobToBstr(&DataBlob, pbstrEncoded)))
            {
                DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
                goto ErrorExit;
            }

            break;
        }

        case CAPICOM_ENCODE_BASE64:
        {
            //
            // Base64 encode.
            //
            if (FAILED(hr = ::Base64Encode(DataBlob, pbstrEncoded)))
            {
                DebugTrace("Error [%#x]: Base64Encode() failed.\n", hr);
                goto ErrorExit;
            }

            break;
        }

        default:
        {
            hr = CAPICOM_E_ENCODE_INVALID_TYPE;

            DebugTrace("Error [%#x]: invalid CAPICOM_ENCODING_TYPE.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving ExportData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ImportData

  Synopsis : Import encoded data.

  Parameter: BSTR bstrEncoded - BSTR containing the data to be imported.

             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive the
                                     decoded data.
  
  Remark   : There is no need for encoding type parameter, as the encoding type
             will be determined automatically by this routine.

------------------------------------------------------------------------------*/

HRESULT ImportData (BSTR        bstrEncoded, 
                    DATA_BLOB * pDataBlob)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering ImportData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pDataBlob);
    ATLASSERT(bstrEncoded);

    //
    // Initialize.
    //
    ::ZeroMemory((void *) pDataBlob, sizeof(DATA_BLOB));

    //
    // Decode data.
    //
    if (FAILED(hr = ::Base64Decode(bstrEncoded, pDataBlob)))
    {
        //
        // Try binary.
        //
        hr = S_OK;
        DebugTrace("Info [%#x]: Base64Decode() failed, assume binary.\n", hr);

        if (FAILED(hr = ::BstrToBlob(bstrEncoded, pDataBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving ImportData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\dialogui.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    DialogUI.CPP

  Content: UI dialogs.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "cryptui.h"
#include "Certificate.h"
#include "Store.h"
#include "Settings.h"

#include <wincrypt.h>


////////////////////////////////////////////////////////////////////////////////
//
// typedefs.
//

typedef PCCERT_CONTEXT (WINAPI * PCRYPTUIDLGSELECTCERTIFICATEW) 
                       (IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CenterWindow 

  Synopsis : Certer the window to the screen.

  Parameter: HWND hwnd - Window handle.

  Remark   :

------------------------------------------------------------------------------*/

static void CenterWindow (HWND hwnd)
{
    RECT  rect;

    //
    // Sanity check.
    //
    ATLASSERT(hwnd);

    //
    // Get dimension of window.
    //
    if (::GetWindowRect(hwnd, &rect))
    {
        //
        // Calculate center point.
        //
	    int wx = (::GetSystemMetrics(SM_CXSCREEN) - (rect.right - rect.left)) / 2;
	    int wy = (::GetSystemMetrics(SM_CYSCREEN) - (rect.bottom - rect.top)) / 2;
	    
        //
        // Position it.
        //
        if (wx > 0 && wy > 0)
        {
            ::SetWindowPos(hwnd, NULL, wx, wy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        }
    }

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsValidCert

  Synopsis : Check if a cert is valid.

  Parameter: PCCERT_CONTEXT pCertContext

  Remark   :

------------------------------------------------------------------------------*/

static BOOL IsValidCert (PCCERT_CONTEXT pCertContext)
{
    BOOL bResult = FALSE;

    //
    // Sanity check.
    //
    ATLASSERT(NULL != pCertContext);

#ifdef CAPICOM_USE_FULL_CHAIN_CHECK //DSIE: Do we want to build the chain???
    DWORD                dwStatus      = 0;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_CHAIN_PARA      ChainPara     = {sizeof(CERT_CHAIN_PARA), {USAGE_MATCH_TYPE_AND, {0, NULL}}};
    DWORD                dwCheckFlags  = CERT_CHAIN_REVOCATION_CHECK_CHAIN | CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;

    //
    // Build the chain.
    //
    if (!::CertGetCertificateChain(NULL,                // in optional 
                                   pCertContext,        // in 
                                   NULL,                // in optional
                                   NULL,                // in optional 
                                   &ChainPara,          // in 
                                   dwCheckFlags,        // in 
                                   NULL,                // in 
                                   &pChainContext))     // out 
    {
        DebugTrace("Error [%#x]: CertGetCertificateChain() failed.\n", HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    //
    // Filter out invalid cert.
    //
    dwStatus = pChainContext->TrustStatus.dwErrorStatus;

    if (((CERT_TRUST_IS_NOT_SIGNATURE_VALID | CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) & dwStatus) ||
        ((CERT_TRUST_IS_NOT_TIME_VALID | CERT_TRUST_CTL_IS_NOT_TIME_VALID) & dwStatus) ||
        (CERT_TRUST_IS_UNTRUSTED_ROOT & dwStatus) ||
        (CERT_TRUST_IS_REVOKED & dwStatus) ||
        (CERT_TRUST_IS_PARTIAL_CHAIN & dwStatus))
    {      
        DebugTrace("Info: invalid chain (status = %#x).\n", dwStatus);
        goto CommonExit;
    }
#else // or simply check time validity only???
    int nValidity = 0;

    if (0 != (nValidity = CertVerifyTimeValidity(NULL, pCertContext->pCertInfo)))
    {
        DebugTrace("Info: invalid time (%s).\n", nValidity < 0 ? "not yet valid" : "expired");
        goto CommonExit;
    }
#endif

    bResult = TRUE;

CommonExit:

#ifdef CAPICOM_USE_FULL_CHAIN_CHECK
    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }
#endif

    return bResult;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectSignerCertCallback 

  Synopsis : Callback routine for CryptUIDlgSelectCertificateW() API for
             signer's cert selection.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not valid and has no associated 
             private key. In the future we should also consider filtering out 
             certs that do not have signing capability.

------------------------------------------------------------------------------*/

static BOOL WINAPI SelectSignerCertCallback (PCCERT_CONTEXT pCertContext,
                                             BOOL *         pfInitialSelectedCert,
                                             void *         pvCallbackData)
{
    BOOL bResult = FALSE;

    //
    // Check cert validity.
    //
    if (IsValidCert(pCertContext))
    {
        DWORD cb = 0;

        //
        // Return TRUE if the cert has a private key, else return FALSE to filter
        // out the cert so that it would not be displayed for selection.
        //
        bResult = ::CertGetCertificateContextProperty(pCertContext, 
                                                      CERT_KEY_PROV_INFO_PROP_ID, 
                                                      NULL, 
                                                      &cb);
    }

    return bResult;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectRecipientCertCallback 

  Synopsis : Callback routine for CryptUIDlgSelectCertificateW() API for
             recipient's cert selection.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not valid.

------------------------------------------------------------------------------*/

static BOOL WINAPI SelectRecipientCertCallback (PCCERT_CONTEXT pCertContext,
                                                BOOL *         pfInitialSelectedCert,
                                                void *         pvCallbackData)
{
    //
    // Check cert validity.
    //
    return IsValidCert(pCertContext);
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectSignerCert

  Synopsis : Pop UI to prompt user to select a signer's certificate.

  Parameter: ICertificate ** ppICertificate - Pointer to pointer to 
                                              ICertificate to receive interface
                                              pointer.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT SelectSignerCert (ICertificate ** ppICertificate)
{
    HRESULT        hr           = S_OK;
    HINSTANCE      hDLL         = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CONTEXT pEnumContext = NULL;
    HCERTSTORE     hCertStore   = NULL;
    DWORD          dwValidCerts = 0;

    PCRYPTUIDLGSELECTCERTIFICATEW pCryptUIDlgSelectCertificateW = NULL;
    CRYPTUI_SELECTCERTIFICATE_STRUCTW csc;

    DebugTrace("Entering SelectSignerCert().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppICertificate);

    //
    // Get pointer to CryptUIDlgSelectCertificateW().
    //
    if (hDLL = ::LoadLibrary("CryptUI.dll"))
    {
        pCryptUIDlgSelectCertificateW = (PCRYPTUIDLGSELECTCERTIFICATEW) ::GetProcAddress(hDLL, "CryptUIDlgSelectCertificateW");
    }

    //
    // Is CryptUIDlgSelectCertificateW() available?
    //
    if (!pCryptUIDlgSelectCertificateW)
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: CryptUIDlgSelectCertificateW() API not available.\n");
        goto ErrorExit;
    }

    //
    // Open "My" store for signer's cert selection dialog.
    //
    if (!(hCertStore = ::CertOpenStore((LPCSTR) CERT_STORE_PROV_SYSTEM,
                                       CAPICOM_ASN_ENCODING,
                                       NULL,
                                       CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER,
                                       (void *) (LPCWSTR) L"My")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertOpenStore() failed to open current user MY store.\n", hr);
        goto ErrorExit; 
    }
 
    //
    // Count number of certs in store.
    //
    while (pEnumContext = ::CertEnumCertificatesInStore(hCertStore, pEnumContext))
    {
        //
        // Count only if it will not be filtered out.
        //
        if (::SelectSignerCertCallback(pEnumContext, NULL, NULL))
        {
            if (pCertContext)
            {
                ::CertFreeCertificateContext(pCertContext);
            }

            if (!(pCertContext = ::CertDuplicateCertificateContext(pEnumContext)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
                goto ErrorExit;
            }

            dwValidCerts++;
        }
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

    //
    // If only 1 cert available, don't pop UI (just use it).
    //
    if (0 == dwValidCerts)
    {
        hr = CAPICOM_E_STORE_EMPTY;

        DebugTrace("Error: empty current user MY store.\n");
        goto ErrorExit;
    }
    else if (1 < dwValidCerts)
    {
        //
        // Make sure we are allowed to pop UI.
        //
        if (!PromptForCertificateEnabled())
        {
            hr = CAPICOM_E_UI_DISABLED;

            DebugTrace("Error: UI is disabled.\n");
            goto ErrorExit;
        }

        //
        // Pop UI to prompt user to select cert.
        // 
        ::ZeroMemory(&csc, sizeof(csc));
#if (0) //DSIE: Bug in older version of CRYPTUI does not check size correctly,
        //      so always force it to the oldest version of structure.
        csc.dwSize = sizeof(csc);
#else
        csc.dwSize = offsetof(CRYPTUI_SELECTCERTIFICATE_STRUCTW, hSelectedCertStore);
#endif
        csc.cDisplayStores = 1;
        csc.rghDisplayStores = &hCertStore;
        csc.pFilterCallback = ::SelectSignerCertCallback;

        //
        // First free the CERT_CONTEXT we duplicated above.
        //
        ::CertFreeCertificateContext(pCertContext);

        if (!(pCertContext = (PCERT_CONTEXT) pCryptUIDlgSelectCertificateW(&csc)))
        {
            hr = CAPICOM_E_CANCELLED;
        
            DebugTrace("Error: user cancelled signer cert selection dialog box.\n");
            goto ErrorExit;
        }
    }

    //
    // Create an ICertificate object from the CERT_CONTEXT.
    //
    if (FAILED(hr = ::CreateCertificateObject(pCertContext, ppICertificate)))
    {
        DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n");
        goto ErrorExit;
    }
  
CommonExit:
    //
    // Release resources.
    //
    if (pEnumContext)
    {
        ::CertFreeCertificateContext(pEnumContext);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    DebugTrace("Leaving SelectSignerCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectRecipientCert

  Synopsis : Pop UI to prompt user to select a recipient's certificate.

  Parameter: ICertificate ** ppICertificate - Pointer to pointer to 
                                              ICertificate to receive interface
                                              pointer.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT SelectRecipientCert (ICertificate ** ppICertificate)
{
    HRESULT        hr           = S_OK;
    HINSTANCE      hDLL         = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CONTEXT pEnumContext = NULL;
    HCERTSTORE     hCertStore   = NULL;
    DWORD          dwValidCerts = 0;

    PCRYPTUIDLGSELECTCERTIFICATEW pCryptUIDlgSelectCertificateW = NULL;
    CRYPTUI_SELECTCERTIFICATE_STRUCTW csc;

    DebugTrace("Entering SelectRecipientCert().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppICertificate);

    //
    // Get pointer to CryptUIDlgSelectCertificateW().
    //
    if (hDLL = ::LoadLibrary("CryptUI.dll"))
    {
        pCryptUIDlgSelectCertificateW = (PCRYPTUIDLGSELECTCERTIFICATEW) ::GetProcAddress(hDLL, "CryptUIDlgSelectCertificateW");
    }

    //
    // Is CryptUIDlgSelectCertificateW() available?
    //
    if (!pCryptUIDlgSelectCertificateW)
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: CryptUIDlgSelectCertificateW() API not available.\n");
        goto ErrorExit;
    }

    //
    // Open "AddressBook" store for recipient's cert selection dialog.
    //
    if (!(hCertStore = ::CertOpenStore((LPCSTR) CERT_STORE_PROV_SYSTEM,
                                       CAPICOM_ASN_ENCODING,
                                       NULL,
                                       CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER,
                                       (void *) (LPCWSTR) L"AddressBook")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertOpenStore() failed to open current user AddressBook store.\n", hr);
        goto ErrorExit; 
    }
 
    //
    // Count number of certs in store.
    //
    while (pEnumContext = ::CertEnumCertificatesInStore(hCertStore, pEnumContext))
    {
        //
        // Count only if it will not be filtered out.
        //
        if (::SelectRecipientCertCallback(pEnumContext, NULL, NULL))
        {
            if (pCertContext)
            {
                ::CertFreeCertificateContext(pCertContext);
            }

            if (!(pCertContext = ::CertDuplicateCertificateContext(pEnumContext)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
                goto ErrorExit;
            }

            dwValidCerts++;
        }
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

    //
    // If only 1 cert available, don't pop UI (just use it).
    //
    if (0 == dwValidCerts)
    {
        hr = CAPICOM_E_STORE_EMPTY;

        DebugTrace("Error: empty current user AddressBook store.\n");
        goto ErrorExit;
    }
    else if (1 < dwValidCerts)
    {
        //
        // Make sure we are allowed to pop UI.
        //
        if (!PromptForCertificateEnabled())
        {
            hr = CAPICOM_E_UI_DISABLED;

            DebugTrace("Error: UI is disabled.\n");
            goto ErrorExit;
        }

        //
        // Pop UI to prompt user to select cert.
        // 
        ::ZeroMemory(&csc, sizeof(csc));
#if (0) //DSIE: Bug in older version of CRYPTUI does not check size correctly,
        //      so always force it to the oldest version of structure.
        csc.dwSize = sizeof(csc);
#else
        csc.dwSize = offsetof(CRYPTUI_SELECTCERTIFICATE_STRUCTW, hSelectedCertStore);
#endif
        csc.cDisplayStores = 1;
        csc.rghDisplayStores = &hCertStore;
        csc.pFilterCallback = ::SelectRecipientCertCallback;

        //
        // First free the CERT_CONTEXT we duplicated above.
        //
        ::CertFreeCertificateContext(pCertContext);

        if (!(pCertContext = (PCERT_CONTEXT) pCryptUIDlgSelectCertificateW(&csc)))
        {
            hr = CAPICOM_E_CANCELLED;
        
            DebugTrace("Error: user cancelled recipient cert selection dialog box.\n");
            goto ErrorExit;
        }
    }

    //
    // Create an ICertificate object from the CERT_CONTEXT.
    //
    if (FAILED(hr = ::CreateCertificateObject(pCertContext, ppICertificate)))
    {
        DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n");
        goto ErrorExit;
    }
  
CommonExit:
    //
    // Release resources.
    //
    if (pEnumContext)
    {
        ::CertFreeCertificateContext(pEnumContext);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    DebugTrace("Leaving SelectRecipientCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UserApprovedOperationDlgProc

  Synopsis : UserApprovedOperation dialog proc.

  Remark   :

------------------------------------------------------------------------------*/

INT_PTR CALLBACK UserApprovedOperationDlgProc (HWND hDlg,     // Handle to dialog box
                                               UINT uMsg,     // Message
                                               WPARAM wParam, // First message parameter
                                               LPARAM lParam) // Second message parameter
{
    static BOOL * pbNoShowAgain = NULL;

    switch (uMsg)
    {
        case WM_CLOSE:
        {
            EndDialog(hDlg, IDNO);
            return 0;
        }

        case WM_INITDIALOG:
        {
            pbNoShowAgain = lParam ? (BOOL *) lParam : NULL;

            CenterWindow(hDlg);

            SetFocus(GetDlgItem(hDlg, IDNO));

            return TRUE;
        }
      
        case WM_COMMAND:
        {
            if (BN_CLICKED == HIWORD(wParam)) 
            {
                switch(LOWORD(wParam)) 
                {
                    case IDYES:
                    case IDNO:
                    case IDCANCEL:
                    {
                        EndDialog(hDlg, LOWORD(wParam));
                        return TRUE;
                    }

                    case IDC_DLG_NO_SHOW_AGAIN:
                    {
                        if (pbNoShowAgain)
                        {
                            *pbNoShowAgain = (BST_CHECKED == ::IsDlgButtonChecked(hDlg, IDC_DLG_NO_SHOW_AGAIN));
                        }

                        return TRUE;
                    }
                }
            }

            break;
        }
    }

    return FALSE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UserApprovedOperation

  Synopsis : Pop UI to prompt user to approve an operation.

  Parameter: DWORD iddDialog - ID of dialog to display.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT UserApprovedOperation (DWORD iddDialog)
{
    HRESULT hr      = S_OK;
    INT_PTR iDlgRet = 0;
    BOOL    bDialogNoShowAgain = FALSE;

    DebugTrace("Entering UserApprovedOperation().\n");

    //
    // Pop UI to prompt user for permission.
    //
    if (-1 == (iDlgRet = ::DialogBoxParam(_Module.GetResourceInstance(),
                                          (LPSTR) MAKEINTRESOURCE(iddDialog),
                                          NULL,
                                          UserApprovedOperationDlgProc,
                                          (LPARAM) &bDialogNoShowAgain)))
                         
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: DialogBoxParam() failed.\n");
        goto CommonExit;
    }

    //
    // If user requested not to show this dialog again, then disable it.
    //
    if (bDialogNoShowAgain)
    {
        ::EnableSecurityAlertDialog(iddDialog, FALSE);

        DebugTrace("Info: %s security dialog box has been disabled by user.\n", 
                    iddDialog == IDD_STORE_SECURITY_ALERT_DLG ? "Store" : 
                    iddDialog == IDD_SIGN_SECURITY_ALERT_DLG ? "Signing" :
                    iddDialog == IDD_DECRYPT_SECURITY_ALERT_DLG ? "Decrypt" : "");
    }

    //
    // Check result.
    //
    if (IDYES != iDlgRet)
    {
        hr = CAPICOM_E_CANCELLED;
        DebugTrace("Info: operation has been cancelled by user.\n");
    }

CommonExit:

    DebugTrace("Leaving UserApprovedOperation().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\debug.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Debug.h

  Content: Global debug facilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef _INCLUDE_DEBUG_H
#define _INCLUDE_DEBUG_H

#ifdef CAPICOM_USE_PRINTF_FOR_DEBUG_TRACE
#ifdef _DEBUG
#define DebugTrace  printf
#else
inline void DebugTrace(LPSTR pszFormat, ...) {};
#endif
#else
#define DebugTrace  ATLTRACE
#endif


#ifdef _DEBUG
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DumpToFile

  Synopsis : Dump data to file for debug analysis.

  Parameter: char * szFileName - File name (just the file name without any
                                 directory path).
  
             BYTE * pbData - Pointer to data.
             
             DWORD cbData - Size of data.

  Remark   : No action is taken if the environment variable, "CAPICOM_DUMP_DIR"
             is not defined. If defined, the value should be the directory
             where the file would be created (i.e. C:\Test).

------------------------------------------------------------------------------*/

void DumpToFile (char * szFileName, 
                 BYTE * pbData, 
                 DWORD  cbData);

#else

#define DumpToFile(f,p,c)

#endif // _DEBUG

#endif // __INCLUDE_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\dialogui.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    DialogUI.h

  Content: Declaration of DialogUI.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef __DIALOGUI_H_
#define __DIALOGUI_H_

#include <wincrypt.h>

#include "resource.h"       // main symbols


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectSignerCert

  Synopsis : Pop UI to prompt user to select a signer's certificate.

  Parameter: ICertificate ** ppICertificate - Pointer to pointer to 
                                              ICertificate to receive interface
                                              pointer.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT SelectSignerCert (ICertificate ** ppICertificate);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectRecipientCert

  Synopsis : Pop UI to prompt user to select a recipient's certificate.

  Parameter: ICertificate ** ppICertificate - Pointer to pointer to 
                                              ICertificate to receive interface
                                              pointer.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT SelectRecipientCert (ICertificate ** ppICertificate);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UserApprovedOperation

  Synopsis : Pop UI to prompt user to approve an operation.

  Parameter: DWORD iddDialog - ID of dialog to display.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT UserApprovedOperation (DWORD iddDialog);

#endif //__DIALOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\eku.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EKU.cpp

  Content: Implementation of CEKU.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "EKU.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUObject

  Synopsis : Create an IEKU object and initialize the object with data
             from the specified OID.

  Parameter: LPTSTR * lpszOID - Pointer to EKU OID string.
  
             IEKU ** ppIEKU - Pointer to pointer IEKU object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUObject (LPSTR   lpszOID, 
                         IEKU ** ppIEKU)
{
    HRESULT            hr    = S_OK;
    CComObject<CEKU> * pCEKU = NULL;
    CAPICOM_EKU           EkuName;
    CComBSTR           bstrValue;

    DebugTrace("Entering CreateEKUObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIEKU);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CEKU>::CreateInstance(&pCEKU)))
        {
            DebugTrace("Error [%#x]: CComObject<CEKU>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine EKU enum name.
        //
        if (NULL == lpszOID)
        {
            EkuName = CAPICOM_EKU_OTHER;
        }
        if (0 == ::lstrcmpA(CAPICOM_OID_SERVER_AUTH, lpszOID))
        {
            EkuName = CAPICOM_EKU_SERVER_AUTH;
        }
        else if (0 == ::lstrcmpA(CAPICOM_OID_CLIENT_AUTH, lpszOID))
        {
            EkuName = CAPICOM_EKU_CLIENT_AUTH;
        }
        else if (0 == ::lstrcmpA(CAPICOM_OID_CODE_SIGNING, lpszOID))
        {
            EkuName = CAPICOM_EKU_CODE_SIGNING;
        }
        else if (0 == ::lstrcmpA(CAPICOM_OID_EMAIL_PROTECTION, lpszOID))
        {
            EkuName = CAPICOM_EKU_EMAIL_PROTECTION;
        }
        else
        {
            EkuName = CAPICOM_EKU_OTHER;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCEKU->Init(EkuName, lpszOID)))
        {
            DebugTrace("Error [%#x]: pCEKU->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCEKU->QueryInterface(ppIEKU)))
        {
            DebugTrace("Error [%#x]: pCEKU->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateEKUObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCEKU)
    {
        delete pCEKU;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CEKU
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::get_Name

  Synopsis : Return the enum name of the EKU.

  Parameter: CAPICOM_EKU * pVal - Pointer to CAPICOM_EKU to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::get_Name (CAPICOM_EKU * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return result.
        //
  	    *pVal = m_Name;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::put_Name

  Synopsis : Set EKU enum name.

  Parameter: CAPICOM_EKU newVal - EKU enum name.
  
  Remark   : The corresponding EKU value will be set for all except EKU_OTHER,
             in which case the user must make another explicit call to 
             put_Value to set it.

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::put_Name (CAPICOM_EKU newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::put_Name().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Reset value based on EKU name.
    //
    switch (newVal)
    {
        case CAPICOM_EKU_OTHER:
        {
            m_bstrOID.Empty();
            break;
        }

        case CAPICOM_EKU_SERVER_AUTH:
        {
            m_bstrOID = CAPICOM_OID_SERVER_AUTH;
            break;
        }

        case CAPICOM_EKU_CLIENT_AUTH:
        {
            m_bstrOID = CAPICOM_OID_CLIENT_AUTH;
            break;
        }

        case CAPICOM_EKU_CODE_SIGNING:
        {
            m_bstrOID = CAPICOM_OID_CODE_SIGNING;
            break;
        }

        case CAPICOM_EKU_EMAIL_PROTECTION:
        {
            m_bstrOID = CAPICOM_OID_EMAIL_PROTECTION;
            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, unknown EKU name.\n");
            goto ErrorExit;
        }
    }

    //
    // Store name.
    //
    m_Name = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::put_Name().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::get_OID

  Synopsis : Return the actual OID string of the EKU.

  Parameter: BSTR * pVal - Pointer to BSTR to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::get_OID (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::get_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it was set.
        //
        if (!m_bstrOID)
        {
            hr = CAPICOM_E_EKU_OID_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: EKU value is not set.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
  	    if (FAILED(hr = m_bstrOID.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrOID.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::get_OID().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::put_OID

  Synopsis : Set EKU actual OID string value.

  Parameter: BSTR newVal - EKU OID string.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::put_OID (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::put_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure Name property is CAPICOM_EKU_OTHER.
        //
        if (CAPICOM_EKU_OTHER != m_Name)
        {
            hr = CAPICOM_E_EKU_INVALID_OID;

            DebugTrace("Error [%#x]: attemp to set EKU OID, when EKU name is not CAPICOM_EKU_OTHER.\n", hr);
            goto ErrorExit;
        }

        //
        // Store value.
        //
  	    m_bstrOID = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::put_OID().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::Init

  Synopsis : Initialize the object.

  Parameter: CAPICOM_EKU EkuName - Enum name of EKU.

             LPSTR lpszOID - EKU OID string.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::Init (CAPICOM_EKU EkuName, 
                         LPSTR       lpszOID)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::Init().\n");

    //
    // Init private members.
    //
    m_Name = EkuName;

#if (0) // DSIE: Bug 322258
    m_bstrOID = lpszOID;
#else
    // Work around ATL's bug where it calls SysAllocStringLen() with -1, and caused
    // OLEAUT32.DLL to assert in checked build. Note: ATL fixed this problem in VC 7.
    if (NULL == lpszOID)
    {
        m_bstrOID.Empty();
    }
    else
    {
        if (!(m_bstrOID = lpszOID))
        {
            hr = E_OUTOFMEMORY;
            DebugTrace("Error: out of memory.\n");
        }
    }
#endif

    DebugTrace("Leaving CEKU::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\eku.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    EKU.h

  Content: Declaration of CEKU.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EKU_H_
#define __EKU_H_

#include "resource.h"       // main symbols
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUObject

  Synopsis : Create an IEKU object and initialize the object with data
             from the specified OID.

  Parameter: LPTSTR * lpszOID - Pointer to EKU OID string.
  
             IEKU ** ppIEKU - Pointer to pointer IEKU 
                                              object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUObject (LPSTR   lpszOID, 
                         IEKU ** ppIEKU);


////////////////////////////////////////////////////////////////////////////////
//
// CEKU
//

class ATL_NO_VTABLE CEKU : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEKU, &CLSID_EKU>,
    public ICAPICOMError<CEKU, &IID_IEKU>,
	public IDispatchImpl<IEKU, &IID_IEKU, &LIBID_CAPICOM>
{
public:
	CEKU()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEKU)
	COM_INTERFACE_ENTRY(IEKU)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEKU)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for EKU object.\n", hr);
            return hr;
        }

        m_Name = CAPICOM_EKU_OTHER;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IEKU
//
public:
	STDMETHOD(get_OID)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(put_OID)
        (/*[out, retval]*/ BSTR newVal);

	STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_EKU * pVal);

	STDMETHOD(put_Name)
        (/*[out, retval]*/ CAPICOM_EKU newVal);
    
    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (CAPICOM_EKU EkuName, LPSTR lpszValue);

private:
    CLock       m_Lock;
    CAPICOM_EKU m_Name;
    CComBSTR    m_bstrOID;
};

#endif //__EKU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\ekus.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    EKUs.h

  Content: Declaration of CEKUs.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EKUs_H_
#define __EKUs_H_

#include "resource.h"       // main symbols
#include "EKU.h"
#include "CopyItem.h"


//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IEKU> > EKUMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IEKU>, EKUMap> EKUEnum;
typedef ICollectionOnSTLImpl<IEKUs, EKUMap, VARIANT, _CopyMapItem<IEKU>, EKUEnum> IEKUsCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUsObject

  Synopsis : Create a IEKUs collection object and populate the collection with
             EKUs from the specified certificate.

  Parameter: PCERT_ENHKEY_USAGE pUsage - Pointer to CERT_ENHKEY_USAGE.

             IEKUs ** ppIEKUs - Pointer to pointer IEKUs object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUsObject (PCERT_ENHKEY_USAGE    pUsage,
                          IEKUs              ** ppIEKUs);


////////////////////////////////////////////////////////////////////////////////
//
// CEKUs
//

class ATL_NO_VTABLE CEKUs : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEKUs, &CLSID_EKUs>,
	public IDispatchImpl<IEKUsCollection, &IID_IEKUs, &LIBID_CAPICOM>
{
public:
	CEKUs()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEKUs)
	COM_INTERFACE_ENTRY(IEKUs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEKUs)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IEKUs
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Init) 
        (PCERT_ENHKEY_USAGE pUsage);
};

#endif //__EKUs_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\ekus.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EKUs.cpp

  Content: Implementation of CEKUs.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "EKUs.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUsObject

  Synopsis : Create a IEKUs collection object and populate the collection with
             EKUs from the specified certificate.

  Parameter: PCERT_ENHKEY_USAGE pUsage - Pointer to CERT_ENHKEY_USAGE.

             IEKUs ** ppIEKUs - Pointer to pointer IEKUs object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUsObject (PCERT_ENHKEY_USAGE    pUsage,
                          IEKUs              ** ppIEKUs)
{
    HRESULT hr = S_OK;
    CComObject<CEKUs> * pCEKUs = NULL;

    DebugTrace("Entering CreateEKUsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pUsage);
    ATLASSERT(ppIEKUs);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CEKUs>::CreateInstance(&pCEKUs)))
        {
            DebugTrace("Error [%#x]: CComObject<CEKUs>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCEKUs->Init(pUsage)))
        {
            DebugTrace("Error [%#x]: pCEKUs->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCEKUs->QueryInterface(ppIEKUs)))
        {
            DebugTrace("Unexpected error [%#x]:  pCEKUs->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateEKUsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCEKUs)
    {
        delete pCEKUs;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CEKUs
//

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKUs::Init

  Synopsis : Initialize the EKUs collection object by adding all individual
             EKU object to the collection.

  Parameter: PCERT_ENHKEY_USAGE pUsage - Pointer to CERT_ENHKEY_USAGE.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEKUs::Init (PCERT_ENHKEY_USAGE pUsage)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKUs::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pUsage);

    try
    {
        //
        // Debug Log.
        //
        DebugTrace("Creating %d EKU object(s) for the EKUs collection.\n", pUsage->cUsageIdentifier);

        //
        // Add all EKU OIDs to the map.
        //
        for (DWORD i = 0; i < pUsage->cUsageIdentifier; i++)
        {
            //
            // Create the IEKU object for each of the EKU found in the certificate.
            //
            char     szIndex[32];
            CComBSTR bstrIndex;
            CComPtr<IEKU> pIEKU = NULL;

            if (FAILED(hr = ::CreateEKUObject(pUsage->rgpszUsageIdentifier[i], &pIEKU)))
            {
                DebugTrace("Error [%#x]: CreateEKUObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // BSTR index of numeric value.
            //
            wsprintfA(szIndex, "%06u", m_coll.size() + 1);
            bstrIndex = szIndex;

            DebugTrace("Before adding to map: CEKUs.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);

            //
            // Now add object to collection map.
            //
            // Note that the overloaded = operator for CComPtr will
            // automatically AddRef to the object. Also, when the CComPtr
            // is deleted (happens when the Remove or map destructor is called), 
            // the CComPtr destructor will automatically Release the object.
            //
            m_coll[bstrIndex] = pIEKU;

            DebugTrace("After adding to map: CEKUs.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);
        }
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CEKUs::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\encrypteddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EncryptedData.cpp

  Content: Implementation of CEncryptedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "EncryptedData.h"
#include "Convert.h"
#include "Common.h"

///////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DeriveKey

  Synopsis : Derive a session key.

  Parameter: HCRYPTPROV hCryptProv - CSP handler.

             ALG_ID AlgID - Encryption algorithm ID.

             DWORD dwKeyLength - Key length.

             DATA_BLOB SecretBlob - Secret blob.

             DATA_BLOB SaltBlob - Salt blob.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT DeriveKey (HCRYPTPROV  hCryptProv,
                          ALG_ID      AlgID,
                          DWORD       dwKeyLength,
                          DATA_BLOB   SecretBlob,
                          DATA_BLOB   SaltBlob,
                          HCRYPTKEY * phKey)
{
    HRESULT    hr    = S_OK;
    HCRYPTHASH hHash = NULL;
    HCRYPTKEY  hKey  = NULL;
    DWORD      dwFlags = CRYPT_EXPORTABLE | CRYPT_NO_SALT;

    DebugTrace("Entering DeriveKey().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(AlgID);
    ATLASSERT(SecretBlob.cbData);
    ATLASSERT(SecretBlob.pbData);
    ATLASSERT(SaltBlob.cbData);
    ATLASSERT(SaltBlob.pbData);
    ATLASSERT(phKey);

    //
    // Create a hash object.
    //
    if (!::CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ::CryptCreateHash() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Hash in the password data.
    //
    if(!::CryptHashData(hHash, 
                        SecretBlob.pbData,
                        SecretBlob.cbData, 
                        0)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ::CryptHashData() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Hash in the salt.
    //
    if(!::CryptHashData(hHash, 
                        SaltBlob.pbData,
                        SaltBlob.cbData, 
                        0)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ::CryptHashData() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set key length.
    //
    if (CALG_RC2 == AlgID || CALG_RC4 == AlgID)
    {
        dwFlags |= dwKeyLength << 16;
    }

    //
    // Derive a session key from the hash object.
    //
    if (!::CryptDeriveKey(hCryptProv, 
                          AlgID, 
                          hHash, 
                          dwFlags, 
                          &hKey)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ::CryptDeriveKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return session key to caller.
    //
    *phKey = hKey;

CommonExit:
    //
    // Free resource.
    //
    if (hHash)
    {
        ::CryptDestroyHash(hHash);
    }

    DebugTrace("Leaving DeriveKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EncodeEncryptedData

  Synopsis : ASN.1 encode the cipher blob.

  Parameter: HCRYPTKEY hKey - Session key used to encrypt the data.

             DATA_BLOB SaltBlob - Salt blob.

             DATA_BLOB CipherBlob - Cipher blob.

             DATA_BLOB * pEncodedBlob - Pointer to DATA_BLOB to receive the
                                        ASN.1 encoded blob.

  Remark   : The format is proprietory, and should not be documented. It is  
             right now encoded as a PKCS_CONTENT_INFO_SEQUENCE_OF_ANY with
             proprietory OID.

------------------------------------------------------------------------------*/

static HRESULT EncodeEncryptedData (HCRYPTKEY   hKey, 
                                    DATA_BLOB   SaltBlob,
                                    DATA_BLOB   CipherBlob, 
                                    DATA_BLOB * pEncodedBlob)
{
    HRESULT   hr = S_OK;
    DWORD     dwCAPICOMVersion = CAPICOM_VERSION;
    DATA_BLOB KeyParamBlob[3]  = {{0, NULL}, {0, NULL}, {0, NULL}};

    DWORD i;
    CAPICOM_ENCTYPTED_DATA_INFO        EncryptedDataInfo;
    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY EncryptedDataFormat;
    CRYPT_CONTENT_INFO                 ContentInfo;
    CRYPT_DER_BLOB                     ContentBlob = {0, NULL};

    DebugTrace("Entering EncodeEncryptedData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hKey);
    ATLASSERT(pEncodedBlob);

    //
    // Initialize.
    //
    ::ZeroMemory(pEncodedBlob, sizeof(DATA_BLOB));
    ::ZeroMemory(&ContentInfo, sizeof(ContentInfo));
    ::ZeroMemory(&EncryptedDataInfo, sizeof(EncryptedDataInfo));
    ::ZeroMemory(&EncryptedDataFormat, sizeof(EncryptedDataFormat));

    //
    // Encode the version number.
    //
    if (FAILED(hr = ::EncodeObject(X509_INTEGER, 
                                   &dwCAPICOMVersion, 
                                   &EncryptedDataInfo.VersionBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode ALG_ID.
    //
    if (FAILED(hr = ::GetKeyParam(hKey, 
                                  KP_ALGID, 
                                  &KeyParamBlob[0].pbData, 
                                  &KeyParamBlob[0].cbData)))
    {
        DebugTrace("Error [%#x]: GetKeyParam() failed for KP_ALGID.\n", hr);
        goto ErrorExit;
    }

    if (FAILED(hr = ::EncodeObject(X509_INTEGER, 
                                   KeyParamBlob[0].pbData, 
                                   &EncryptedDataInfo.AlgIDBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode key length.
    //
    if (FAILED(hr = ::GetKeyParam(hKey, 
                                  KP_KEYLEN, 
                                  &KeyParamBlob[1].pbData, 
                                  &KeyParamBlob[1].cbData)))
    {
        DebugTrace("Error [%#x]: GetKeyParam() failed for KP_KEYLEN.\n", hr);
        goto ErrorExit;
    }

    if (FAILED(hr = ::EncodeObject(X509_INTEGER, 
                                   KeyParamBlob[1].pbData, 
                                   &EncryptedDataInfo.KeyLengthBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode IV value.
    //
    if (FAILED(hr = ::GetKeyParam(hKey, 
                                  KP_IV, 
                                  &KeyParamBlob[2].pbData, 
                                  &KeyParamBlob[2].cbData)))
    {
        DebugTrace("Error [%#x]: GetKeyParam() failed for KP_IV.\n", hr);
        goto ErrorExit;
    }

    if (FAILED(hr = ::EncodeObject(X509_OCTET_STRING, 
                                   &KeyParamBlob[2], 
                                   &EncryptedDataInfo.IVBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode salt value.
    //
    if (FAILED(hr = ::EncodeObject(X509_OCTET_STRING, 
                                   &SaltBlob, 
                                   &EncryptedDataInfo.SaltBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode the cipher text.
    //
    if (FAILED(hr = ::EncodeObject(X509_OCTET_STRING, 
                                   &CipherBlob, 
                                   &EncryptedDataInfo.CipherBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode the entire content as PKCS_CONTENT_INFO_SEQUENCE_OF_ANY.
    //
    EncryptedDataFormat.pszObjId = szOID_CAPICOM_ENCRYPTED_CONTENT;
    EncryptedDataFormat.cValue = 6;
    EncryptedDataFormat.rgValue = (DATA_BLOB *) &EncryptedDataInfo;
    
    if (FAILED(hr = ::EncodeObject(PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
                                   &EncryptedDataFormat,
                                   &ContentBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Finally, wrap the entire encrypted content in CONTENT_INFO.
    //
    ContentInfo.pszObjId = szOID_CAPICOM_ENCRYPTED_DATA;
    ContentInfo.Content = ContentBlob;

    if (FAILED(hr = ::EncodeObject(PKCS_CONTENT_INFO,
                                   &ContentInfo,
                                   pEncodedBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    for (i = 0; i < 3; i++)
    {
        if (KeyParamBlob[i].pbData)
        {
            ::CoTaskMemFree(KeyParamBlob[i].pbData);
        }
    }
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }
    if (ContentBlob.pbData)
    {
        ::CoTaskMemFree(ContentBlob.pbData);
    }

    DebugTrace("Leaving EncodeEncryptedData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DecodeEncryptedData

  Synopsis : ASN.1 decode the cipher text blob.

  Parameter: DATA_BLOB EncodedBlob - Encoded cipher blob.

             CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo - Pointer to 
                                                                structure to
                                                                receive decoded
                                                                structure.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT DecodeEncryptedData (DATA_BLOB                     EncodedBlob, 
                                    CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo)
{
    HRESULT   hr              = S_OK;
    DATA_BLOB ContentInfoBlob = {0, NULL};
    DATA_BLOB EncryptedBlob   = {0, NULL};

    CRYPT_CONTENT_INFO                   ContentInfo;
    CAPICOM_ENCTYPTED_DATA_INFO          EncryptedDataInfo;
    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY * pEncryptedDataFormat = NULL;

    DebugTrace("Entering DecodeEncryptedData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pEncryptedDataInfo);

    //
    // Initialize.
    //
    ::ZeroMemory(&ContentInfo, sizeof(ContentInfo));
    ::ZeroMemory(&EncryptedDataInfo, sizeof(EncryptedDataInfo));

    //
    // Decode the CONTENT_INFO.
    //
    if (FAILED(hr = ::DecodeObject(PKCS_CONTENT_INFO,
                                   EncodedBlob.pbData,
                                   EncodedBlob.cbData,
                                   &ContentInfoBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }
    ContentInfo = * ((CRYPT_CONTENT_INFO *) ContentInfoBlob.pbData);

    //
    // Make sure this is our CONTENT_INFO.
    //
    if (0 != ::lstrcmpA(szOID_CAPICOM_ENCRYPTED_DATA, ContentInfo.pszObjId))
    {
        DebugTrace("Error [%#x]: not a CAPICOM encrypted data.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode the content blob.
    //
    if (FAILED(hr = ::DecodeObject(PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
                                   ContentInfo.Content.pbData,
                                   ContentInfo.Content.cbData,
                                   &EncryptedBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }
    pEncryptedDataFormat = (CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY *) EncryptedBlob.pbData;

    //
    // Make sure it is the right format.
    //
    if (0 != ::lstrcmpA(szOID_CAPICOM_ENCRYPTED_CONTENT, pEncryptedDataFormat->pszObjId))
    {
        hr = CAPICOM_E_ENCRYPT_INVALID_TYPE;

        DebugTrace("Error: not a CAPICOM encrypted content.\n");
        goto ErrorExit;
    }

    //
    // Sanity check.
    //
    ATLASSERT(6 == pEncryptedDataFormat->cValue);

    //
    // Decode version.
    //
    if (FAILED(hr = ::DecodeObject(X509_INTEGER,
                                   pEncryptedDataFormat->rgValue[0].pbData,
                                   pEncryptedDataFormat->rgValue[0].cbData,
                                   &EncryptedDataInfo.VersionBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode ALG_ID.
    //
    if (FAILED(hr = ::DecodeObject(X509_INTEGER,
                                   pEncryptedDataFormat->rgValue[1].pbData,
                                   pEncryptedDataFormat->rgValue[1].cbData,
                                   &EncryptedDataInfo.AlgIDBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode key length.
    //
    if (FAILED(hr = ::DecodeObject(X509_INTEGER,
                                   pEncryptedDataFormat->rgValue[2].pbData,
                                   pEncryptedDataFormat->rgValue[2].cbData,
                                   &EncryptedDataInfo.KeyLengthBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode IV value.
    //
    if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                   pEncryptedDataFormat->rgValue[3].pbData,
                                   pEncryptedDataFormat->rgValue[3].cbData,
                                   &EncryptedDataInfo.IVBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode salt value.
    //
    if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                   pEncryptedDataFormat->rgValue[4].pbData,
                                   pEncryptedDataFormat->rgValue[4].cbData,
                                   &EncryptedDataInfo.SaltBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode cipher text.
    //
    if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                   pEncryptedDataFormat->rgValue[5].pbData,
                                   pEncryptedDataFormat->rgValue[5].cbData,
                                   &EncryptedDataInfo.CipherBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return decoded encrypted data to caller.
    //
    *pEncryptedDataInfo = EncryptedDataInfo;

CommonExit:
    //
    // Free resource.
    //
    if (EncryptedBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedBlob.pbData);
    }
    if (ContentInfoBlob.pbData)
    {
        ::CoTaskMemFree(ContentInfoBlob.pbData);
    }

    DebugTrace("Leaving DecodeEncryptedData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }

    goto CommonExit;
}


///////////////////////////////////////////////////////////////////////////////
//
// CEncryptedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::get_Content

  Synopsis : Return the content.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the content.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::get_Content (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::get_Content().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

		    DebugTrace("Error: invalid parameter, pVal is NULL.\n");
		    goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENCRYPT_NOT_INITIALIZED;

		    DebugTrace("Error: encrypt object has not been initialized.\n");
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Return content.
        //
        if (FAILED(hr = ::BlobToBstr(&m_ContentBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::get_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::put_Content

  Synopsis : Initialize the object with content to be encrypted.

  Parameter: BSTR newVal - BSTR containing the content to be encrypted.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::put_Content (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::put_Content().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Reset member variables.
        //
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;

        //
        // Make sure parameters are valid.
        //
        if (NULL == newVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, newVal is NULL.\n");
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, newVal is empty.\n");
            goto ErrorExit;
        }

        //
        // Update content.
        //
        if (FAILED(hr = ::BstrToBlob(newVal, &m_ContentBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::put_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::get_Algorithm

  Synopsis : Property to return the algorithm object.

  Parameter: IAlgorithm ** pVal - Pointer to pointer to IAlgorithm to receive 
                                  the interfcae pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::get_Algorithm (IAlgorithm ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::get_Algorithm().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pIAlgorithm);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIAlgorithm->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIAlgorithm->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::get_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::SetSecret

  Synopsis : Set the encryption secret used to generated the session key.

  Parameter: BSTR newVal - The secret.

             CAPICOM_SECRET_TYPE SecretType - Secret type, which can be:

                    SECRET_PASSWORD = 0

  Remark   : For v1.0, we only support password secret. But, we really need
             to consider plain text session key (See Q228786), as this is one
             of the frequently asked question on the public list server.

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::SetSecret (BSTR                newVal, 
                                        CAPICOM_SECRET_TYPE SecretType)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::SetSecret().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        DWORD dwCharLen = ::SysStringLen(newVal);

        if (0 == dwCharLen || 256 < dwCharLen)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid secret length.\n");
            goto ErrorExit;
        }

        //
        // Determine secret type.
        //
        switch (SecretType)
        {
            case CAPICOM_SECRET_PASSWORD:
            {
                m_SecretType = SecretType;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, unknown secret type.\n");
                goto ErrorExit;
            }
        }

        //
        // Initialize secret.
        //
        m_bstrSecret = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::SetSecret().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::Encrypt

  Synopsis : Encrypt the content.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the encrypted message.

  Remark   : Note that since CAPI still does not support PKCS 7 EncryptedData
             type, therefore, the format of the encrypted data used here is 
             propriety, and should not be documented. 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::Encrypt (CAPICOM_ENCODING_TYPE EncodingType, 
                                      BSTR                * pVal)
{
    HRESULT    hr          = S_OK;
    HCRYPTPROV hCryptProv  = NULL;
    HCRYPTKEY  hSessionKey = NULL;
    DWORD      dwBufLength = 0;
    DATA_BLOB  SaltBlob    = {0, NULL};
    DATA_BLOB  CipherBlob  = {0, NULL};
    DATA_BLOB  MessageBlob = {0, NULL};

    DebugTrace("Entering CEncryptedData::Encrypt().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, pVal is NULL.\n");
            goto ErrorExit;
        }

        //
        // Make sure we do have content to encrypt.
        //
        if (!m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENCRYPT_NOT_INITIALIZED;

		    DebugTrace("Error: encrypt object has not been initialized.\n");
		    goto ErrorExit;
        }
        if (!m_bstrSecret)
        {
            hr = CAPICOM_E_ENCRYPT_NO_SECRET;

		    DebugTrace("Error: secret has not been set.\n");
		    goto ErrorExit;
        }

        //
        // Open a new message to encode.
        //
        if (FAILED(hr = OpenToEncode(&SaltBlob, &hCryptProv, &hSessionKey)))
        {
            DebugTrace("Error [%#x]: CEncryptedData::OpenToEncode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine buffer length.
        //
        dwBufLength = m_ContentBlob.cbData;
        if (!::CryptEncrypt(hSessionKey,
                            NULL,
                            TRUE,
                            0,
                            NULL,
                            &dwBufLength,
                            0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptEncrypt() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.cbData <= dwBufLength);

        //
        // Copy clear text to another buffer.
        //
        if (!(CipherBlob.pbData = (PBYTE) ::CoTaskMemAlloc(dwBufLength)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        CipherBlob.cbData = dwBufLength;

        ::CopyMemory(CipherBlob.pbData, 
                     m_ContentBlob.pbData, 
                     m_ContentBlob.cbData);

        //
        // Encrypt.
        //
        dwBufLength = m_ContentBlob.cbData;

        if (!::CryptEncrypt(hSessionKey,
                            NULL,
                            TRUE,
                            0,
                            CipherBlob.pbData,
                            &dwBufLength,
                            CipherBlob.cbData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptEncrypt() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Encode the cipher text.
        //
        if (FAILED(hr = ::EncodeEncryptedData(hSessionKey, 
                                              SaltBlob,
                                              CipherBlob, 
                                              &MessageBlob)))
        {
            DebugTrace("Error [%#x]: Encode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now export the encoded message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("Encrypted.asn", MessageBlob.pbData, MessageBlob.cbData);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }
    if (CipherBlob.pbData)
    {
        ::CoTaskMemFree(CipherBlob.pbData);
    }
    if (hSessionKey)
    {
        ::CryptDestroyKey(hSessionKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::Encrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::Decrypt

  Synopsis : Decrypt the encrypted content.

  Parameter: BSTR EncryptedMessage - BSTR containing the encrypted message.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::Decrypt (BSTR EncryptedMessage)
{
    HRESULT    hr          = S_OK;
    HCRYPTPROV hCryptProv  = NULL;
    HCRYPTKEY  hSessionKey = NULL;
    DATA_BLOB  ContentBlob = {0, NULL};

    CAPICOM_ENCTYPTED_DATA_INFO    EncryptedDataInfo;
    CAPICOM_ENCRYPTION_ALGORITHM   AlgoName;
    CAPICOM_ENCRYPTION_KEY_LENGTH  KeyLength;

    DebugTrace("Entering CEncryptedData::Decrypt().\n");

    //
    // Initialize.
    //
    ::ZeroMemory(&EncryptedDataInfo, sizeof(CAPICOM_ENCTYPTED_DATA_INFO));

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Reset member variables.
        //
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;

        //
        // Make sure parameters are valid.
        //
        if (NULL == EncryptedMessage )
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, EncryptedMessage is NULL.\n");
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(EncryptedMessage))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, EncryptedMessage is empty\n");
            goto ErrorExit;
        }
        if (!m_bstrSecret)
        {
            hr = CAPICOM_E_ENCRYPT_NO_SECRET;

		    DebugTrace("Error: secret has not been set.\n");
		    goto ErrorExit;
        }

        //
        // Open a new message to decode.
        //
        if (FAILED(hr = OpenToDecode(EncryptedMessage, 
                                     &hCryptProv, 
                                     &hSessionKey,
                                     &EncryptedDataInfo)))
        {
            DebugTrace("Error [%#x]: CEncryptedData::OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Point to content blob.
        //
        ContentBlob = *((DATA_BLOB *) EncryptedDataInfo.CipherBlob.pbData);

        //
        // Decrypt.
        //
        if (!::CryptDecrypt(hSessionKey,
                            NULL,
                            TRUE,
                            0,
                            ContentBlob.pbData,
                            &ContentBlob.cbData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptDecrypt() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert ALG_ID to CAPICOM_ENCRYPTION_ALGORITHM.
        //
        if (FAILED(::AlgIDToEnumName(*((ALG_ID *) EncryptedDataInfo.AlgIDBlob.pbData), &AlgoName)))
        {
            //
            // Default to RC2.
            //
            AlgoName = CAPICOM_ENCRYPTION_ALGORITHM_RC2;
        }

        //
        // Convert key length value to CAPICOM_ENCRYPTION_KEY_LENGTH.
        //
        if (FAILED(::KeyLengthToEnumName(*((DWORD *) EncryptedDataInfo.KeyLengthBlob.pbData), &KeyLength)))
        {
            //
            // Default to maximum.
            //
            KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;
        }

        //
        // Update member variables.
        //
        if (!(m_ContentBlob.pbData = (PBYTE) ::CoTaskMemAlloc(ContentBlob.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }
        m_ContentBlob.cbData = ContentBlob.cbData;
        ::CopyMemory(m_ContentBlob.pbData, ContentBlob.pbData, ContentBlob.cbData);
        m_pIAlgorithm->put_Name(AlgoName);
        m_pIAlgorithm->put_KeyLength(KeyLength);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hSessionKey)
    {
        ::CryptDestroyKey(hSessionKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::Decrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::Init

  Synopsis : Initialize the object.

  Parameter: None.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::Init()
{
    HRESULT hr = S_OK;
    CComPtr<IAlgorithm> pIAlgorithm = NULL;

    DebugTrace("Entering CEncryptedData::Init().\n");

    //
    // Create embeded IAlgorithm.
    //
    if (FAILED(hr = ::CreateAlgorithmObject(&pIAlgorithm)))
    {
        DebugTrace("Error [%#x]: CreateAlgorithmObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Update member variables.
    //
    m_ContentBlob.cbData = 0;
    m_ContentBlob.pbData = NULL;
    m_bstrSecret.Empty();
    m_pIAlgorithm = pIAlgorithm;

CommonExit:

    DebugTrace("Leaving CEncryptedData::Init().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::OpenToEncode

  Synopsis : Create and initialize an encrypt message for encoding.

  Parameter: DATA_BLOB * pSaltBlob - Pointer to DATA_BLOB to receive the
                                     salt value blob.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to receive CSP
                                        handler.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::OpenToEncode(DATA_BLOB  * pSaltBlob,
                                          HCRYPTPROV * phCryptProv,
                                          HCRYPTKEY  * phKey)
{
    HRESULT    hr         = S_OK;
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY  hKey       = NULL;
    DATA_BLOB  SaltBlob   = {16, NULL};

    CAPICOM_ENCRYPTION_ALGORITHM  AlgoName;
    CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength;

    DebugTrace("Entering CEncryptedData::OpenToEncode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSaltBlob);
    ATLASSERT(phCryptProv);
    ATLASSERT(phKey);
    ATLASSERT(m_ContentBlob.cbData && m_ContentBlob.pbData);
    ATLASSERT(m_bstrSecret);

    //
    // Get algorithm enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_Name(&AlgoName)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_Name() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get key length enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_KeyLength(&KeyLength)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_KeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get CSP context.
    //
    if (FAILED(hr = ::AcquireContext(AlgoName, 
                                     KeyLength, 
                                     &hCryptProv)))
    {
        DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Generate random salt.
    //
    if (!(SaltBlob.pbData = (BYTE *) ::CoTaskMemAlloc(SaltBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    if (!::CryptGenRandom(hCryptProv, SaltBlob.cbData, SaltBlob.pbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGenRandom() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Generate the session key.
    //
    if (FAILED(hr = GenerateKey(hCryptProv, 
                                AlgoName, 
                                KeyLength,
                                SaltBlob,
                                &hKey)))
    {
        DebugTrace("Error [%#x]: GenerateKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set CMSG_ENCRYPTED_ENCODE_INFO.
    //
    *pSaltBlob = SaltBlob;
    *phCryptProv = hCryptProv;
    *phKey = hKey;

CommonExit:

    DebugTrace("Leaving CEncryptedData::OpenToEncode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (SaltBlob.pbData)
    {
        ::CoTaskMemFree(SaltBlob.pbData);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::OpenToDecode

  Synopsis : Open an encrypt message for decoding.

  Parameter: BSTR EncryptedMessage - BSTR containing the encrypted message.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to receive CSP
                                        handler.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

             CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo;

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::OpenToDecode (
        BSTR                          EncryptedMessage,
        HCRYPTPROV                  * phCryptProv,
        HCRYPTKEY                   * phKey,
        CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo)
{
    HRESULT    hr          = S_OK;
    HCRYPTPROV hCryptProv  = NULL;
    HCRYPTKEY  hKey        = NULL;
    ALG_ID     AlgID       = 0;
    DWORD      dwKeyLength = 0;
    DATA_BLOB  MessageBlob = {0, NULL};
    DATA_BLOB  SecretBlob  = {m_bstrSecret.Length() * sizeof(WCHAR), 
                              (BYTE *) m_bstrSecret.m_str};
    DATA_BLOB SaltBlob;
    DATA_BLOB IVBlob;
    CAPICOM_ENCTYPTED_DATA_INFO EncryptedDataInfo;

    DebugTrace("Entering CEncryptedData::OpenToDecode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(EncryptedMessage);
    ATLASSERT(phCryptProv);
    ATLASSERT(phKey);
    ATLASSERT(pEncryptedDataInfo);

    try
    {
        //
        // Initialize.
        //
        ::ZeroMemory(&EncryptedDataInfo, sizeof(EncryptedDataInfo));

        //
        // Import the message.
        //
        if (FAILED(hr = ::ImportData(EncryptedMessage, &MessageBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Decode the blob.
        //
        if (FAILED(hr = ::DecodeEncryptedData(MessageBlob,
                                              &EncryptedDataInfo)))
        {
            DebugTrace("Error [%#x]: DecodeEncryptedData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve values.
        //
        AlgID = *((ALG_ID *) EncryptedDataInfo.AlgIDBlob.pbData);
        dwKeyLength = *((DWORD *) EncryptedDataInfo.KeyLengthBlob.pbData);
        SaltBlob = *((DATA_BLOB *) EncryptedDataInfo.SaltBlob.pbData);
        IVBlob = *((DATA_BLOB *)  EncryptedDataInfo.IVBlob.pbData);

        //
        // Get CSP context.
        //
        if (FAILED(hr = ::AcquireContext(AlgID,
                                         dwKeyLength, 
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Derive the key.
        //
        if (FAILED(hr = ::DeriveKey(hCryptProv, 
                                    AlgID,
                                    dwKeyLength,
                                    SecretBlob,
                                    SaltBlob,
                                    &hKey)))
        {
            DebugTrace("Error [%#x]: DeriveKey() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Set IV, if required.
        //
        if ((CALG_RC2 == AlgID) || (CALG_DES == AlgID) || (CALG_3DES == AlgID))
        {
            //
            // Set IV.
            //
            if(IVBlob.cbData && !::CryptSetKeyParam(hKey, KP_IV, IVBlob.pbData, 0))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptSetKeyParam() failed for KP_IV.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Return results to caller.
        //
        *phCryptProv = hCryptProv;
        *phKey = hKey;
        *pEncryptedDataInfo = EncryptedDataInfo;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    DebugTrace("Leaving CEncryptedData::OpenToDecode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }

    goto CommonExit;
}
    
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::GenerateKey

  Synopsis : Generate the session key.

  Parameter: HCRYPTPROV hCryptProv - CSP handler.

             CAPICOM_ENCRYPTION_ALGORITHM AlogName - Algo enum name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length enum name.

             DATA_BLOB SaltBlob - Salt blob.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::GenerateKey (
        HCRYPTPROV                    hCryptProv,
        CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
        DATA_BLOB                     SaltBlob,
        HCRYPTKEY                   * phKey)
{
    HRESULT    hr          = S_OK;
    HCRYPTKEY  hKey        = NULL;
    ALG_ID     AlgID       = 0;
    DWORD      dwKeyLength = 0;
    DATA_BLOB  SecretBlob  = {m_bstrSecret.Length() * sizeof(WCHAR), 
                              (BYTE *) m_bstrSecret.m_str};
    DWORD      dwBlockLen  = 0;
    DWORD      cbBlockLen  = sizeof(dwBlockLen);
    DATA_BLOB  IVBlob      = {0, NULL};

    DebugTrace("Entering CEncryptedData::GenerateKey().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(phKey);
    ATLASSERT(SaltBlob.cbData);
    ATLASSERT(SaltBlob.pbData);

    //
    // Conver to ALG_ID.
    //
    if (FAILED(hr = ::EnumNameToAlgID(AlgoName, &AlgID)))
    {
        DebugTrace("Error [%#x]: EnumNameToAlgID() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set key length for RC2 and RC4.
    //
    if ((CALG_RC2 == AlgID || CALG_RC4 == AlgID) &&
        FAILED(hr = ::EnumNameToKeyLength(KeyLength, &dwKeyLength)))
    {
        DebugTrace("Error [%#x]: EnumNameToKeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Derive a session key from the secret.
    //
    if (FAILED(hr = DeriveKey(hCryptProv, 
                              AlgID, 
                              dwKeyLength, 
                              SecretBlob,
                              SaltBlob,
                              &hKey)) )
    {
        DebugTrace("Error [%#x]: DeriveKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Generate random IV, if required.
    //
    if ((CALG_RC2 == AlgID) || (CALG_DES == AlgID) || (CALG_3DES == AlgID))
    {
        //
        // Get block size.
        //
        if (!::CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE *) &dwBlockLen, &cbBlockLen, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetKeyParam() failed for KP_BLOCKLEN.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure block length is valid.
        //
        if (IVBlob.cbData = dwBlockLen / 8)
        {
            //
            // Allocate memory.
            //
            if (!(IVBlob.pbData = (BYTE *) ::CoTaskMemAlloc(IVBlob.cbData)))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error: out of memory.\n");
                goto ErrorExit;
            }

            //
            // Generate random IV.
            //
            if(!::CryptGenRandom(hCryptProv, IVBlob.cbData, IVBlob.pbData)) 
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptGenRandom() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Set IV.
            //
            if(IVBlob.cbData && !::CryptSetKeyParam(hKey, KP_IV, IVBlob.pbData, 0))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptSetKeyParam() failed for KP_IV.\n", hr);
                goto ErrorExit;
            }
        }
    }

    //
    // Return session key to caller.
    //
    *phKey = hKey;

CommonExit:
    //
    // Free resource.
    //
    if (IVBlob.pbData)
    {
        ::CoTaskMemFree(IVBlob.pbData);
    }

    DebugTrace("Leaving EncryptedData::GenerateKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\encrypteddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EncryptedData.h

  Content: Declaration of the CEncryptedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
	
#ifndef __ENCRYPTEDDATA_H_
#define __ENCRYPTEDDATA_H_

#include <atlctl.h>
#include "resource.h"       // main symbols
#include "Algorithm.h"
#include "Lock.h"
#include "Error.h"


////////////////////
//
// Local defines.
//
typedef struct _EncryptedDataInfo
{
    DATA_BLOB VersionBlob;
    DATA_BLOB AlgIDBlob;
    DATA_BLOB KeyLengthBlob;
    DATA_BLOB IVBlob;
    DATA_BLOB SaltBlob;
    DATA_BLOB CipherBlob;
} CAPICOM_ENCTYPTED_DATA_INFO, * PCAPICOM_ENCRYPTED_DATA_INFO;


////////////////////////////////////////////////////////////////////////////////
//
// CEncryptedData
//

class ATL_NO_VTABLE CEncryptedData : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEncryptedData, &CLSID_EncryptedData>,
    public ICAPICOMError<CEncryptedData, &IID_IEncryptedData>,
	public IDispatchImpl<IEncryptedData, &IID_IEncryptedData, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CEncryptedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                             INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CEncryptedData()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ENCRYPTEDDATA)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEncryptedData)
	COM_INTERFACE_ENTRY(IEncryptedData)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEncryptedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for EncryptedData object.\n", hr);
            return hr;
        }

        if (FAILED(hr = Init()))
        {
            DebugTrace("Error [%#x]: CEncryptedData::Init() failed inside CEncryptedData::FinalConstruct().\n", hr);
            return hr;
        }

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        m_pIAlgorithm.Release();

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IEncryptedData
//
public:
	STDMETHOD(Decrypt)
        (/*[in]*/ BSTR EncryptedMessage);

    STDMETHOD(Encrypt)
        (/*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);
	
    STDMETHOD(SetSecret)
        (/*[in]*/ BSTR newVal,
         /*[in, defaultvalue(SECRET_PASSWORD)]*/ CAPICOM_SECRET_TYPE SecretType);

	STDMETHOD(get_Algorithm)
        (/*[out, retval]*/ IAlgorithm ** pVal);

	STDMETHOD(get_Content)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(put_Content)
        (/*[in]*/ BSTR newVal);

private:
    CLock               m_Lock;
    DATA_BLOB           m_ContentBlob;
    CComBSTR            m_bstrSecret;
    CAPICOM_SECRET_TYPE m_SecretType;
    CComPtr<IAlgorithm> m_pIAlgorithm;

    STDMETHOD(Init)();

    STDMETHOD(OpenToEncode)
        (DATA_BLOB * pSaltBlob,
         HCRYPTPROV * phCryptProv,
         HCRYPTKEY * phKey);

    STDMETHOD(OpenToDecode)
        (BSTR EncryptedMessage,
         HCRYPTPROV * phCryptProv,
         HCRYPTKEY * phKey,
         CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo);

    STDMETHOD(GenerateKey)
        (HCRYPTPROV hCryptProv,
         CAPICOM_ENCRYPTION_ALGORITHM AlgoName,
         CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
         DATA_BLOB SaltBlob,
         HCRYPTKEY * phKey);
};

#endif //__ENCRYPTEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\envelopeddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EnvelopedData.cpp

  Content: Implementation of CEnvelopedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Certificate.h"
#include "EnvelopedData.h"
#include "Convert.h"
#include "Settings.h"
#include "DialogUI.h"
#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// CEnvelopedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SetKeyLength

  Synopsis : Setup the symetric encryption key length.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.
  
             CRYPT_ALGORITHM_IDENTIFIER EncryptAlgorithm - Encryption algorithm.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.

             void ** pAuxInfo - Receive NULL or allocated and initialized
                                aux info structure.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT SetKeyLength (
        HCRYPTPROV                    hCryptProv,
        CRYPT_ALGORITHM_IDENTIFIER    EncryptAlgorithm,
        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
        void                       ** ppAuxInfo)
{
    HRESULT hr    = S_OK;
    ALG_ID  AlgID = 0;
    PROV_ENUMALGS_EX  peex;
    CMSG_RC2_AUX_INFO * pRC2AuxInfo = NULL;
    CMSG_RC4_AUX_INFO * pRC4AuxInfo = NULL;

    DebugTrace("Entering SetKeyLength().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(ppAuxInfo);

    //
    // Initialize.
    //
    *ppAuxInfo = (void *) NULL;

    //
    // Get ALG_ID.
    //
    if (FAILED(hr = ::OIDToAlgID(EncryptAlgorithm.pszObjId, &AlgID)))
    {
        DebugTrace("Error [%#x]: OIDToAlgID() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get algorithm capability from CSP.
    //
    if (FAILED(::IsAlgSupported(hCryptProv, AlgID, &peex)))
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: requested encryption algorithm is not available.\n");
        goto ErrorExit;
    }

    //
    // Setup AuxInfo for RC2.
    //
    if (CALG_RC2 == AlgID)
    {
        //
        // Allocate and intialize memory for RC2 AuxInfo structure.
        //
        if (!(pRC2AuxInfo = (CMSG_RC2_AUX_INFO *) ::CoTaskMemAlloc(sizeof(CMSG_RC2_AUX_INFO))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        ::ZeroMemory(pRC2AuxInfo, sizeof(CMSG_RC2_AUX_INFO));
        pRC2AuxInfo->cbSize = sizeof(CMSG_RC2_AUX_INFO);

        //
        // Determine key length requested.
        //
        if (CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM == KeyLength)
        {
            pRC2AuxInfo->dwBitLen = peex.dwMaxLen;
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 40 && 40 <= peex.dwMaxLen)
            {
                pRC2AuxInfo->dwBitLen = 40;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 40-bits encryption is not available.\n");
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 56 && 56 <= peex.dwMaxLen)
            {
                pRC2AuxInfo->dwBitLen = 56;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 56-bits encryption is not available.\n");
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 128 && 128 <= peex.dwMaxLen)
            {
                pRC2AuxInfo->dwBitLen = 128;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 128-bits encryption is not available.\n");
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Should never get to here.
            //
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error: unknown key length.\n");
            goto ErrorExit;
        }

        //
        // Return RC2 AuxInfo pointer to caller.
        //
        *ppAuxInfo = (void *) pRC2AuxInfo;
    }
    else if (CALG_RC4 == AlgID)
    {
        //
        // Allocate and intialize memory for RC4 AuxInfo structure.
        //
        if (!(pRC4AuxInfo = (CMSG_RC4_AUX_INFO *) ::CoTaskMemAlloc(sizeof(CMSG_RC4_AUX_INFO))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
                goto ErrorExit;
        }

        ::ZeroMemory(pRC4AuxInfo, sizeof(CMSG_RC4_AUX_INFO));
        pRC4AuxInfo->cbSize = sizeof(CMSG_RC4_AUX_INFO);

        //
        // Determine key length requested.
        //
        if (CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM == KeyLength)
        {
            pRC4AuxInfo->dwBitLen = peex.dwMaxLen;
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 40 && 40 <= peex.dwMaxLen)
            {
                pRC4AuxInfo->dwBitLen = 40;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 40-bits encryption is not available.\n");
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 56 && 56 <= peex.dwMaxLen)
            {
                pRC4AuxInfo->dwBitLen = 56;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 56-bits encryption is not available.\n");
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 128 && 128 <= peex.dwMaxLen)
            {
                pRC4AuxInfo->dwBitLen = 128;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error: 128-bits encryption is not available.\n");
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Should never get to here.
            //
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error: unknown key length.\n");
            goto ErrorExit;
        }

        //
        // Return RC4 AuxInfo pointer to caller.
        //
        *ppAuxInfo = (void *) pRC4AuxInfo;
    }

CommonExit:

    DebugTrace("Leaving SetKeyLength().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pRC2AuxInfo)
    {
        ::CoTaskMemFree(pRC2AuxInfo);
    }
    if (pRC4AuxInfo)
    {
        ::CoTaskMemFree(pRC4AuxInfo);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SetEncryptionAlgorithm

  Synopsis : Setup the encryption algorithm structure.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algorithm ID enum name.

             CRYPT_ALGORITHM_IDENTIFIER * pEncryptAlgorithm - Pointer to the
                                                              structure.

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT SetEncryptionAlgorithm (CAPICOM_ENCRYPTION_ALGORITHM AlgoName,
                                       CRYPT_ALGORITHM_IDENTIFIER * pEncryptAlgorithm)
{
    HRESULT hr    = S_OK;
    ALG_ID  AlgID = 0;

    DebugTrace("Entering SetEncryptionAlgorithm().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pEncryptAlgorithm);

    //
    // Initialize structure.
    //
    ::ZeroMemory(pEncryptAlgorithm, sizeof(CRYPT_ALGORITHM_IDENTIFIER));

    //
    // Convert to LPSTR.
    //
    if (FAILED(hr = ::EnumNameToAlgID(AlgoName, &AlgID)))
    {
        DebugTrace("Error: EnumNameToAlgID() failed.\n");
        goto ErrorExit;
    }
    
    if (FAILED(hr = ::AlgIDToOID(AlgID, &pEncryptAlgorithm->pszObjId)))
    {
        DebugTrace("Error: AlgIDToOID() failed.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving SetEncryptionAlgorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pEncryptAlgorithm->pszObjId)
    {
        ::CoTaskMemFree(pEncryptAlgorithm->pszObjId);
    }
    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CEnvelopedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::get_Content

  Synopsis : Return the content.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the content.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::get_Content (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::get_Content().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameter is valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

		    DebugTrace("Error: invalid parameter, pVal is NULL.\n");
		    goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENVELOP_NOT_INITIALIZED;

		    DebugTrace("Error: encrypt object has not been initialized.\n");
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Return content.
        //
        if (FAILED(hr = ::BlobToBstr(&m_ContentBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::get_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::put_Content

  Synopsis : Initialize the object with content to be enveloped.

  Parameter: BSTR newVal - BSTR containing the content to be enveloped.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::put_Content (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::put_Content().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (NULL == newVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, newVal is NULL.\n");
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, newVal is empty.\n");
            goto ErrorExit;
        }

        //
        // Update content.
        //
        if (FAILED(hr = ::BstrToBlob(newVal, &m_ContentBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::put_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::get_Algorithm

  Synopsis : Property to return the algorithm object.

  Parameter: IAlgorithm ** pVal - Pointer to pointer to IAlgorithm to receive 
                                  the interfcae pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::get_Algorithm (IAlgorithm ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::get_Algorithm().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Sanity check.
        //
        ATLASSERT(m_pIAlgorithm);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIAlgorithm->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIAlgorithm->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::get_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::get_Recipients

  Synopsis : Property to return the IRecipients collection object.

  Parameter: IRecipients ** pVal - Pointer to pointer to IRecipietns to receive
                                   the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::get_Recipients (IRecipients ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::get_Recipients().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Sanity check.
        //
        ATLASSERT(m_pIRecipients);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIRecipients->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIRecipients->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::get_Recipients().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::Encrypt

  Synopsis : Envelop the content.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
                                                       
             BSTR * pVal - Pointer to BSTR to receive the enveloped message.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::Encrypt (CAPICOM_ENCODING_TYPE EncodingType,
                                      BSTR                * pVal)
{
    HRESULT    hr               = S_OK;
    HCRYPTMSG  hMsg             = NULL;
    HCRYPTPROV hCryptProv       = NULL;
    CRYPT_DATA_BLOB MessageBlob = {0, NULL};

    DebugTrace("Entering CEnvelopedData::Encrypt().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, pVal is NULL.\n");
            goto ErrorExit;
        }

        //
        // Make sure we do have content to envelop.
        //
        if (!m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENVELOP_NOT_INITIALIZED;

		    DebugTrace("Error: envelop object has not been initialized.\n");
		    goto ErrorExit;
        }

        //
        // Open a new message to encode.
        //
        if (FAILED(hr = OpenToEncode(&hMsg, &hCryptProv)))
        {
            DebugTrace("Error [%#x]: CEnvelopedData::OpenToEncode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update envelop content.
        //
        if(!::CryptMsgUpdate(hMsg,
                             m_ContentBlob.pbData,
                             m_ContentBlob.cbData,
                             TRUE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve enveloped message.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg,
                                      CMSG_CONTENT_PARAM,
                                      0,
                                      (void **) &MessageBlob.pbData,
                                      &MessageBlob.cbData)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: GetMsgParam() failed to get message content.\n", hr);
            goto ErrorExit;
        }

        //
        // Now export the enveloped message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("Enveloped.asn", MessageBlob.pbData, MessageBlob.cbData);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::Encrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::Decrypt

  Synopsis : Decrypt the enveloped message.

  Parameter: BSTR EnvelopedMessage - BSTR containing the enveloped message.

  Remark   : If called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for decrypting.

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::Decrypt (BSTR EnvelopedMessage)
{
    HRESULT         hr              = S_OK;
    HCERTSTORE      hCertStores[2]  = {NULL, NULL};
    HCRYPTMSG       hMsg            = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    HCRYPTPROV      hCryptProv      = NULL;
    DWORD           dwKeySpec       = 0;
    BOOL            bReleaseContext = FALSE;
    DWORD           dwNumRecipients = 0;
    DWORD           cbNumRecipients = sizeof(dwNumRecipients);
    CRYPT_DATA_BLOB ContentBlob     = {0, NULL};

    DWORD dwIndex;
    CComBSTR bstrContent;
    CMSG_CTRL_DECRYPT_PARA DecryptPara;

    DebugTrace("Entering CEnvelopedData::Decrypt().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Reset member variables.
        //
        if (FAILED(hr = m_pIRecipients->Clear()))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->Clear() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure parameters are valid.
        //
        if (NULL == EnvelopedMessage )
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, EnvelopedMessage is NULL.\n");
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(EnvelopedMessage))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, EnvelopedMessage is empty\n");
            goto ErrorExit;
        }

        //
        // Open current user and local machine MY stores.
        //
        hCertStores[0] = ::CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                         CAPICOM_ASN_ENCODING,
                                         NULL,
                                         CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_OPEN_EXISTING_FLAG,
                                         L"My");
        hCertStores[1] = ::CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                         CAPICOM_ASN_ENCODING,
                                         NULL,
                                         CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_OPEN_EXISTING_FLAG,
                                         L"My");
        //
        // Did we manage to open any of the MY store?
        //
        if (NULL == hCertStores[0] && NULL == hCertStores[1])
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Open the message for decode.
        //
        if (FAILED(hr = OpenToDecode(NULL, EnvelopedMessage, &hMsg)))
        {
            DebugTrace("Error [%#x]: CEnvelopedData::OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine number of recipients.
        //
        if (!::CryptMsgGetParam(hMsg,
                                CMSG_RECIPIENT_COUNT_PARAM,
                                0,
                                (void *) &dwNumRecipients,
                                &cbNumRecipients))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed for CMSG_RECIPIENT_COUNT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Find recipient index.
        //
        for (dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
        {
            BOOL bFound = FALSE;
            DATA_BLOB CertInfoBlob = {0, NULL};

            //
            // Get RecipientInfo.
            //
            if (FAILED(hr = ::GetMsgParam(hMsg,
                                          CMSG_RECIPIENT_INFO_PARAM,
                                          dwIndex,
                                          (void **) &CertInfoBlob.pbData,
                                          &CertInfoBlob.cbData)))
            {
                DebugTrace("Error [%#x]: GetMsgParam() failed for CMSG_RECIPIENT_INFO_PARAM.\n", hr);
                goto ErrorExit;
            }

            //
            // Find recipient's cert in store.
            //
            if ((hCertStores[0] && (pCertContext = ::CertGetSubjectCertificateFromStore(hCertStores[0],
                                                                                        CAPICOM_ASN_ENCODING,
                                                                                        (CERT_INFO *) CertInfoBlob.pbData))) ||
                (hCertStores[1] && (pCertContext = ::CertGetSubjectCertificateFromStore(hCertStores[1],
                                                                                        CAPICOM_ASN_ENCODING,
                                                                                        (CERT_INFO *) CertInfoBlob.pbData))))
            {
                bFound = TRUE;
            }

            //
            // Free memory.
            //
            ::CoTaskMemFree(CertInfoBlob.pbData);

            //
            // Break if recipient was found.
            //
            if (bFound)
            {
                break;
            }
        }

        //
        // Did we find the recipient?
        //
        if (dwIndex == dwNumRecipients)
        {
            hr = CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND;

            DebugTrace("Error: recipient not found.\n");
            goto ErrorExit;
        }

        //
        // If we are called from a web page, we need to pop up UI 
        // to get user permission to perform decrypt operation.
        //
        if (m_dwCurrentSafety && 
            PromptForDecryptOperationEnabled() &&
            FAILED(hr = ::UserApprovedOperation(IDD_DECRYPT_SECURITY_ALERT_DLG)))
        {
            DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Acquire CSP context.
        //
        if (FAILED(hr = ::AcquireContext(pCertContext, &hCryptProv, &dwKeySpec, &bReleaseContext)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Decypt the message.
        //
        ::ZeroMemory(&DecryptPara, sizeof(DecryptPara));
        DecryptPara.cbSize = sizeof(DecryptPara);
        DecryptPara.hCryptProv = hCryptProv;
        DecryptPara.dwKeySpec = dwKeySpec;
        DecryptPara.dwRecipientIndex = dwIndex; 

        if(!::CryptMsgControl(hMsg,
                              0,
                              CMSG_CTRL_DECRYPT,
                              &DecryptPara))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgControl() failed to decrypt.\n", hr);
            goto ErrorExit;
        }

        //
        // Get decrypted content.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg,
                                      CMSG_CONTENT_PARAM,
                                      0,
                                      (void **) &ContentBlob.pbData,
                                      &ContentBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_CONTENT_PARAM.\n", hr);
            goto ErrorExit;
        }
    
        //
        // Update member variables.
        //
        m_ContentBlob = ContentBlob;
    }
   
    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hCryptProv && bReleaseContext)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if(hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
    if (hCertStores[0])
    {
        ::CertCloseStore(hCertStores[0], 0);
    }
    if (hCertStores[1])
    {
        ::CertCloseStore(hCertStores[1], 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::Decrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (ContentBlob.pbData)
    {
        ::CoTaskMemFree(ContentBlob.pbData);
    }

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::Init

  Synopsis : Initialize the object.

  Parameter: None.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::Init ()
{
    HRESULT hr = S_OK;
    CComPtr<IAlgorithm>  pIAlgorithm  = NULL;
    CComPtr<IRecipients> pIRecipients = NULL;

    DebugTrace("Entering CEnvelopedData::Init().\n");

    //
    // Create embeded IAlgorithm.
    //
    if (FAILED(hr = ::CreateAlgorithmObject(&pIAlgorithm)))
    {
        DebugTrace("Error [%#x]: CreateAlgorithmObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Create embeded IRecipients.
    //
    if (FAILED(hr = ::CreateRecipientsObject(&pIRecipients)))
    {
        DebugTrace("Error [%#x]: CreateRecipientsObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Update member variables.
    //
    m_ContentBlob.cbData = 0;
    m_ContentBlob.pbData = NULL;
    m_pIAlgorithm = pIAlgorithm;
    m_pIRecipients = pIRecipients;

CommonExit:

    DebugTrace("Leaving CEnvelopedData::Init().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::OpenToEncode

  Synopsis : Create and initialize an envelop message for encoding.

  Parameter: HCRYPTMSG * phMsg - Pointer to HCRYPTMSG to receive message 
                                 handler.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to receive CSP
                                        handler.
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::OpenToEncode (HCRYPTMSG  * phMsg, 
                                           HCRYPTPROV * phCryptProv)
{
    HRESULT          hr                 = S_OK;
    DWORD            dwNumRecipients    = 0;
    PCCERT_CONTEXT * pCertContexts      = NULL;
    PCERT_INFO     * pCertInfos         = NULL;
    HCRYPTPROV       hCryptProv         = NULL;
    void *           pEncryptionAuxInfo = NULL;
    CComPtr<ICertificate> pIRecipient   = NULL;


    DWORD                      dwIndex;
    CAPICOM_ENCRYPTION_ALGORITHM  AlgoName;
    CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength;
    CMSG_ENVELOPED_ENCODE_INFO EnvelopInfo;
    CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;

    DebugTrace("Entering CEnvelopedData::OpenToEncode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phMsg);
    ATLASSERT(phCryptProv);
    ATLASSERT(m_ContentBlob.cbData && m_ContentBlob.pbData);
    ATLASSERT(m_pIRecipients);

    //
    // Initialize.
    //
    ::ZeroMemory(&EnvelopInfo, sizeof(EnvelopInfo));
    ::ZeroMemory(&EncryptionAlgorithm, sizeof(EncryptionAlgorithm));

    //
    // Make sure we do have at least 1 recipient.
    //
    if (FAILED(hr = m_pIRecipients->get_Count((long *) &dwNumRecipients)))
    {
        DebugTrace("Error [%#x]: m_pIRecipients->get_Count() failed.\n", hr);
        goto ErrorExit;
    }
    if (0 == dwNumRecipients)
    {
        //
        // Prompt user to add a recipient.
        //
        if (FAILED(hr = SelectRecipientCert(&pIRecipient)))
        {
            if (hr == CAPICOM_E_STORE_EMPTY)
            {
                hr = CAPICOM_E_ENVELOP_NO_RECIPIENT;
            }

            DebugTrace("Error [%#x]: SelectRecipientCert() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add to collection.
        //
        if (FAILED (hr = m_pIRecipients->Add(pIRecipient)))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->Add() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure count is 1.
        //
        if (FAILED(hr = m_pIRecipients->get_Count((long *) &dwNumRecipients)))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->get_Count() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(1 == dwNumRecipients);
    }

    //
    // Allocate memory for CERT_CONTEXT array.
    //
    if (!(pCertContexts = (PCCERT_CONTEXT *) ::CoTaskMemAlloc(sizeof(PCCERT_CONTEXT) * dwNumRecipients)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }
    ::ZeroMemory(pCertContexts, sizeof(PCCERT_CONTEXT) * dwNumRecipients);

    //
    // Allocate memory for CERT_INFO array.
    //
    if (!(pCertInfos = (PCERT_INFO *) ::CoTaskMemAlloc(sizeof(PCERT_INFO) * dwNumRecipients)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }
    ::ZeroMemory(pCertInfos, sizeof(PCERT_INFO) * dwNumRecipients);

    //
    // Set CERT_INFO array.
    //
    for (dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
    {
        CComVariant varRecipient;
        CComPtr<ICertificate> pIRecipient = NULL;

        //
        // Get next recipient.
        //
        if (FAILED(hr = m_pIRecipients->get_Item((long) (dwIndex + 1), 
                                                 &varRecipient)))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->get_Item() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get custom interface.
        //
        if (FAILED(hr = varRecipient.pdispVal->QueryInterface(IID_ICertificate, 
                                                              (void **) &pIRecipient)))
        {
            DebugTrace("Error [%#x]: varRecipient.pdispVal->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pIRecipient, &pCertContexts[dwIndex])))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Set CERT_INFO.
        //
        pCertInfos[dwIndex] = pCertContexts[dwIndex]->pCertInfo;
    }

    //
    // Get algorithm ID enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_Name(&AlgoName)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_Name() failed.\n", hr);
        goto ErrorExit;
    }

   //
    // Get key length enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_KeyLength(&KeyLength)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_KeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get CSP context.
    //
    if (FAILED(hr = ::AcquireContext(AlgoName, 
                                     KeyLength, 
                                     &hCryptProv)))
    {
        DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set algorithm.
    //
    if (FAILED(hr = ::SetEncryptionAlgorithm(AlgoName, 
                                             &EncryptionAlgorithm)))
    {
        DebugTrace("Error [%#x]: SetEncryptionAlgorithm() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set key length.
    //
    if (FAILED(hr = ::SetKeyLength(hCryptProv, 
                                   EncryptionAlgorithm,
                                   KeyLength, 
                                   &pEncryptionAuxInfo)))
    {
        DebugTrace("Error [%#x]: SetKeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set CMSG_ENVELOPED_ENCODE_INFO.
    //
    EnvelopInfo.cbSize = sizeof(EnvelopInfo);
    EnvelopInfo.ContentEncryptionAlgorithm = EncryptionAlgorithm;
    EnvelopInfo.hCryptProv = hCryptProv;
    EnvelopInfo.cRecipients = dwNumRecipients;
    EnvelopInfo.rgpRecipients = pCertInfos;
    EnvelopInfo.pvEncryptionAuxInfo = pEncryptionAuxInfo;

    //
    // Open the message for encoding.
    //
    if(!(*phMsg = ::CryptMsgOpenToEncode(CAPICOM_ASN_ENCODING,    // ASN encoding type
                                         0,                       // Flags
                                         CMSG_ENVELOPED,          // Message type
                                         &EnvelopInfo,            // Pointer to structure
                                         NULL,                    // Inner content OID
                                         NULL)))                  // Stream information (not used)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgOpenToEncode() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return HCRYPTPROV to caller.
    //
    *phCryptProv = hCryptProv;

CommonExit:
    //
    // Free resource.
    //
    if (pEncryptionAuxInfo)
    {
        ::CoTaskMemFree(pEncryptionAuxInfo);
    }
    if (EncryptionAlgorithm.pszObjId)
    {
        ::CoTaskMemFree(EncryptionAlgorithm.pszObjId);
    }
    if (EncryptionAlgorithm.Parameters.pbData)
    {
        ::CoTaskMemFree(EncryptionAlgorithm.Parameters.pbData);
    }
    if (pCertInfos)
    {
        ::CoTaskMemFree(pCertInfos);
    }
    if (pCertContexts)
    {
        for (dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
        {
            if (pCertContexts[dwIndex])
            {
                ::CertFreeCertificateContext(pCertContexts[dwIndex]);
            }
        }

        ::CoTaskMemFree(pCertContexts);
    }

    DebugTrace("Leaving CEnvelopedData::OpenToEncode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::OpenToDeccode

  Synopsis : Open an enveloped message for decoding.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             BSTR EnvelopMessage - Enveloped message.
  
             HCRYPTMSG * phMsg - Pointer to HCRYPTMSG.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::OpenToDecode (HCRYPTPROV  hCryptProv,
                                           BSTR        EnvelopedMessage,
                                           HCRYPTMSG * phMsg)
{
    HRESULT   hr             = S_OK;
    HCRYPTMSG hMsg           = NULL;
    DWORD     dwMsgType      = 0;
    DWORD     cbMsgType      = sizeof(dwMsgType);
    DATA_BLOB MessageBlob    = {0, NULL};
    DATA_BLOB AlgorithmBlob  = {0, NULL};
    DATA_BLOB ParametersBlob = {0, NULL};

    DebugTrace("Leaving CEnvelopedData::OpenToDecode().\n");

    // Sanity check.
    //
    ATLASSERT(phMsg);
    ATLASSERT(EnvelopedMessage);

    try
    {
        //
        // Open the message for decoding.
        //
        if (!(hMsg = ::CryptMsgOpenToDecode(CAPICOM_ASN_ENCODING,
                                            0,
                                            0,
                                            hCryptProv,
                                            NULL,
                                            NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgOpenToDecode() failed.\n", hr);
            goto CommonExit;
        }

        //
        // Import the message.
        //
        if (FAILED(hr = ::ImportData(EnvelopedMessage, &MessageBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update message with enveloped content.
        //
        if (!::CryptMsgUpdate(hMsg,
                              MessageBlob.pbData,
                              MessageBlob.cbData,
                              TRUE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check message type.
        //
        if (!::CryptMsgGetParam(hMsg,
                                CMSG_TYPE_PARAM,
                                0,
                                (void *) &dwMsgType,
                                &cbMsgType))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed for CMSG_TYPE_PARAM.\n", hr);
            goto ErrorExit;
        }

        if (CMSG_ENVELOPED != dwMsgType)
        {
            hr = CAPICOM_E_ENVELOP_INVALID_TYPE;

            DebugTrace("Error: not an enveloped message.\n");
            goto ErrorExit;
        }

        //
        // Get algorithm ID.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg,
                                      CMSG_ENVELOPE_ALGORITHM_PARAM,
                                      0,
                                      (void **) &AlgorithmBlob.pbData,
                                      &AlgorithmBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed for CMSG_ENVELOPE_ALGORITHM_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Restore encryption algorithm state, as much as we can.
        //
        if (0 == lstrcmpA(szOID_RSA_RC2CBC, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength;

            DebugTrace("INFO: Envelop encryption algorithm was RC2.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_RC2)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Determine encryption key length.
            //
            if (((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->Parameters.cbData)
            {
                if (FAILED(hr = ::DecodeObject(PKCS_RC2_CBC_PARAMETERS,
                                               ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->Parameters.pbData,
                                               ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->Parameters.cbData,
                                               &ParametersBlob)))
                {
                    DebugTrace("Error [%#x]: DecodeObject() failed for PKCS_RC2_CBC_PARAMETERS.\n", hr);
                    goto ErrorExit;
                }
            }

            //
            // Set encryption key length.
            //
            switch (((CRYPT_RC2_CBC_PARAMETERS *) ParametersBlob.pbData)->dwVersion)
            {
                case CRYPT_RC2_40BIT_VERSION:
                {
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS;

                    DebugTrace("INFO: Envelop encryption key length was 40-bits.\n");
                    break;
                }

                case CRYPT_RC2_56BIT_VERSION:
                {
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS;

                    DebugTrace("INFO: Envelop encryption key length was 56-bits.\n");
                    break;
                }

                case CRYPT_RC2_128BIT_VERSION:
                {
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS;

                    DebugTrace("INFO: Envelop encryption key length was 128-bits.\n");
                    break;
                }

                default:
                {
                    //
                    // Unknown key length, so arbitrary choose one.
                    //
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;

                    DebugTrace("INFO: Unknown envelop encryption key length.\n");
                    break;
                }
            }

            //
            // Set key length.
            //
            if (FAILED(hr = m_pIAlgorithm->put_KeyLength(KeyLength)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_KeyLength() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else if (0 == lstrcmpA(szOID_RSA_RC4, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            DebugTrace("INFO: Envelop encryption algorithm was RC4.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_RC4)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // For RC4, CAPI simply does not provide a way to retrieve the
            // encryption key length, so we will have to leave it alone!!!
            //
        }
        else if (0 == lstrcmpA(szOID_OIWSEC_desCBC, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            DebugTrace("INFO: Envelop encryption algorithm was DES.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_DES)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // For DES, key length is fixed at 56, and should be ignored.
            //
        }
        else if (0 == lstrcmpA(szOID_RSA_DES_EDE3_CBC, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            DebugTrace("INFO: Envelop encryption algorithm was 3DES.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_3DES)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // For 3DES, key length is fixed at 168, and should be ignored.
            //
        }
        else
        {
            DebugTrace("INFO: Unknown envelop encryption algorithm.\n");
        }

        //
        // Return msg handler to caller.
        //
        *phMsg = hMsg;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (ParametersBlob.pbData)
    {
        ::CoTaskMemFree(ParametersBlob.pbData);
    }
    if (AlgorithmBlob.pbData)
    {
        ::CoTaskMemFree(AlgorithmBlob.pbData);
    }
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    DebugTrace("Leaving CEnvelopedData::OpenToDecode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\envelopeddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EnvelopedData.h

  Content: Declaration of the CEnvelopedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ENVELOPEDDATA_H_
#define __ENVELOPEDDATA_H_

#include <atlctl.h>
#include "resource.h"       // main symbols
#include "Certificate.h"
#include "Recipients.h"
#include "Algorithm.h"
#include "Lock.h"
#include "Error.h"


///////////////////////////////////////////////////////////////////////////////
//
// CEnvelopedData
//

class ATL_NO_VTABLE CEnvelopedData : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEnvelopedData, &CLSID_EnvelopedData>,
    public ICAPICOMError<CEnvelopedData, &IID_IEnvelopedData>,
	public IDispatchImpl<IEnvelopedData, &IID_IEnvelopedData, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CEnvelopedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                             INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CEnvelopedData()
	{
        m_bEnveloped            = FALSE;
        m_pIAlgorithm           = NULL;
        m_pIRecipients          = NULL;

        m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ENVELOPEDDATA)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEnvelopedData)
	COM_INTERFACE_ENTRY(IEnvelopedData)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEnvelopedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for EnvelopedData object.\n", hr);
            return hr;
        }

        if (FAILED(hr = Init()))
        {
            DebugTrace("Error [%#x]: CEnvelopedData::Init() failed inside CEnvelopedData::FinalConstruct().\n", hr);
            return hr;
        }

        return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        m_pIAlgorithm.Release();
        m_pIRecipients.Release();

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IEnvelopedData
//
public:
	STDMETHOD(Decrypt)
        (/*[in]*/ BSTR EnvelopedMessage);

	STDMETHOD(Encrypt)
        (/*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[out, retval]*/ BSTR * pVal);

	STDMETHOD(get_Recipients)
        (/*[out, retval]*/ IRecipients ** pVal);

    STDMETHOD(get_Algorithm)
        (/*[out, retval]*/ IAlgorithm ** pVal);

	STDMETHOD(get_Content)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(put_Content)
        (/*[in]*/ BSTR newVal);

private:
    CLock                m_Lock;
    DATA_BLOB            m_ContentBlob;
    CComPtr<IAlgorithm>  m_pIAlgorithm;
    CComPtr<IRecipients> m_pIRecipients;
    BOOL                 m_bEnveloped;

    STDMETHOD(Init)();

    STDMETHOD(OpenToEncode)
        (HCRYPTMSG * phMsg, 
         HCRYPTPROV * hCryptProv);

    STDMETHOD(OpenToDecode)
        (HCRYPTPROV hCryptProv,
         BSTR EnvelopedMessage,
         HCRYPTMSG * phMsg);
};

#endif //__ENVELOPEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\extendedkeyusage.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    ExtendedKeyUsage.h

  Content: Declaration of the CExtendedKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EXTENDEDKEYUSAGE_H_
#define __EXTENDEDKEYUSAGE_H_

#include "resource.h"       // main symbols
#include "EKUs.h"
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedKeyUsageObject

  Synopsis : Create an IExtendedKeyUsage object and populate the object
             with EKU data from the certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             IExtendedKeyUsage ** ppIExtendedKeyUsage - Pointer to pointer to
                                                        IExtendedKeyUsage 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedKeyUsageObject (PCCERT_CONTEXT pCertContext,
                                      IExtendedKeyUsage ** ppIExtendedKeyUsage);


///////////////////////////////////////////////////////////////////////////////
//
// CExtendedKeyUsage
//

class ATL_NO_VTABLE CExtendedKeyUsage : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CExtendedKeyUsage, &CLSID_ExtendedKeyUsage>,
    public ICAPICOMError<CExtendedKeyUsage, &IID_IExtendedKeyUsage>,
	public IDispatchImpl<IExtendedKeyUsage, &IID_IExtendedKeyUsage, &LIBID_CAPICOM>
{
public:
	CExtendedKeyUsage()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtendedKeyUsage)
	COM_INTERFACE_ENTRY(IExtendedKeyUsage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CExtendedKeyUsage)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for ExtendedKeyUsage object.\n", hr);
            return hr;
        }

        m_pIEKUs      = NULL;
        m_bIsPresent  = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        m_pIEKUs.Release();

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IExtendedKeyUsage
//
public:
	STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_EKUs)
        (/*[out, retval]*/ IEKUs ** pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock          m_Lock;
    CComPtr<IEKUs> m_pIEKUs;
    VARIANT_BOOL   m_bIsPresent;
    VARIANT_BOOL   m_bIsCritical;
};

#endif //__EXTENDEDKEYUSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\extendedkeyusage.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ExtendedKeyUsage.cpp

  Content: Implementation of CExtendedKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "ExtendedKeyUsage.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedKeyUsageObject

  Synopsis : Create an IExtendedKeyUsage object and populate the object
             with EKU data from the certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             IExtendedKeyUsage ** ppIExtendedKeyUsage - Pointer to pointer to 
                                                        IExtendedKeyUsage 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedKeyUsageObject (PCCERT_CONTEXT       pCertContext,
                                      IExtendedKeyUsage ** ppIExtendedKeyUsage)
{
    HRESULT hr = S_OK;
    CComObject<CExtendedKeyUsage> * pCExtendedKeyUsage = NULL;

    DebugTrace("Entering CreateExtendedKeyUsageObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIExtendedKeyUsage);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CExtendedKeyUsage>::CreateInstance(&pCExtendedKeyUsage)))
        {
            DebugTrace("Error [%#x]: CComObject<CExtendedKeyUsage>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCExtendedKeyUsage->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCExtendedKeyUsage->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCExtendedKeyUsage->QueryInterface(ppIExtendedKeyUsage)))
        {
            DebugTrace("Error [%#x]: pCExtendedKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateExtendedKeyUsageObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCExtendedKeyUsage)
    {
        delete pCExtendedKeyUsage;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CExtendedKeyUsage
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::get_IsPresent

  Synopsis : Check to see if the EKU extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   : Note that this function may return VARIANT_TRUE even if there is 
             no EKU extension found in the certificate, because CAPI will
             take intersection of EKU with EKU extended property (i.e. no 
             EKU extension, but there is EKU extended property.)
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedKeyUsage::get_IsPresent().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
  	    *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedKeyUsage::get_IsPresent().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::get_IsCritical

  Synopsis : Check to see if the EKU extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedKeyUsage::get_IsCritical().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
  	    *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedKeyUsage::get_IsCritical().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::get_EKUs

  Synopsis : Return an EKUs collection object representing all EKUs in the
             certificate.

  Parameter: IEKUs ** pVal - Pointer to pointer to IEKUs to receive the
                             interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::get_EKUs (IEKUs ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedKeyUsage::get_EKUs().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Sanity check.
        //
        ATLASSERT(m_pIEKUs);

        //
        // Return interface pointer to user.
        //
  	    if (FAILED(hr = m_pIEKUs->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEKUs->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedKeyUsage::get_EKUs().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT            hr          = S_OK;
    DWORD              dwWinError  = 0;
    DWORD              cbUsage     = 0;
    PCERT_ENHKEY_USAGE pUsage      = NULL;
    VARIANT_BOOL       bIsPresent  = VARIANT_FALSE;
    VARIANT_BOOL       bIsCritical = VARIANT_FALSE;

    CERT_EXTENSION * pCertExtension;

    DebugTrace("Entering CExtendedKeyUsage::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Determine extended key usage data length.
    //
    if (!::CertGetEnhancedKeyUsage(pCertContext,
                                   0,
                                   NULL,
                                   &cbUsage))
    {
        //
        // Older version of Crypt32.dll would return FALSE for
        // empty EKU. In this case, we want to treat it as success,
        //
        if (CRYPT_E_NOT_FOUND == (dwWinError  = ::GetLastError()))
        {
            //
            // and also set the cbUsage.
            //
            cbUsage = sizeof(CERT_ENHKEY_USAGE);

            DebugTrace("Info: CertGetEnhancedKeyUsage() get size found no EKU, so valid for all uses.\n");
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

    	    DebugTrace("Error [%#x]: CertGetEnhancedKeyUsage() failed to get size.\n", hr);
            goto CommonExit;
        }
    }

    //
    // Debug Log
    //
    DebugTrace("cbUsage = %d.\n", cbUsage);

    //
    // Allocate memory.
    //
    if (!(pUsage = (PCERT_ENHKEY_USAGE) ::CoTaskMemAlloc((ULONG) cbUsage)))
    {
        hr = E_OUTOFMEMORY;

    	DebugTrace("Error: out of memory.\n");
        goto CommonExit;
    }

    //
    // Get extended key usage data.
    //
    if (!::CertGetEnhancedKeyUsage(pCertContext,
                                   0,
                                   pUsage,
                                   &cbUsage))
    {
        //
        // Older version of Crypt32.dll would return FALSE for
        // empty EKU. In this case, we want to treat it as success.
        //
        if (CRYPT_E_NOT_FOUND == (dwWinError  = ::GetLastError()))
        {
            //
            // Structure pointed to by pUsage is not initialized by older
            // version of Cryp32 for empty EKU.
            //
            ::ZeroMemory(pUsage, sizeof(CERT_ENHKEY_USAGE));

            DebugTrace("Info: CertGetEnhancedKeyUsage() get data found no EKU, so valid for all uses.\n");
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

    	    DebugTrace("Error [%#x]: CertGetEnhancedKeyUsage() failed to get data.\n", hr);
            goto CommonExit;
        }
    }

    //
    // Debug Log
    //
    DebugTrace("pUsage->cUsageIdentifier = %d.\n", pUsage->cUsageIdentifier);

    //
    // See if we have any EKU?
    //
    if (0 == pUsage->cUsageIdentifier)
    {
        //
        // Need to see if valid for all use, or have no valid use.
        //
        // For valid for all use, we mark the EKU extension as not
        // present, not critical, and no EKU in the collection.
        //
        if (CRYPT_E_NOT_FOUND != ::GetLastError())
        {
            //
            // For no valid use, we mark the EKU extension as
            // present, not critical, and no EKU in the collection.
            //
            bIsPresent = VARIANT_TRUE;
        }
    }
    else
    {
        //
        // Mark as present.
        //
        bIsPresent = VARIANT_TRUE;
    }

    //
    // Find the extension to see if mark critical.
    //
    if (pCertExtension = ::CertFindExtension(szOID_ENHANCED_KEY_USAGE ,
                                             pCertContext->pCertInfo->cExtension,
                                             pCertContext->pCertInfo->rgExtension))
    {
        //
        // Need to do this since CAPI takes the intersection of EKU with
        // EKU extended property, which may filter out all EKUs in the extension.
        //
        if (pCertExtension->fCritical)
        {
            bIsCritical = VARIANT_TRUE;
        }
    }

    //
    // Create the EKUs collection object.
    //
    if (FAILED(hr = ::CreateEKUsObject(pUsage, &m_pIEKUs)))
    {
        DebugTrace("Error [%#x]: CreateEKUsObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Update member variables.
    //
    m_bIsPresent = bIsPresent;
    m_bIsCritical = bIsCritical;

CommonExit:
    //
    // Free resource.
    //
    if (pUsage)
    {
        ::CoTaskMemFree(pUsage);
    }

    DebugTrace("Leaving CExtendedKeyUsage::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\keyusage.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    KeyUsage.cpp

  Content: Implementation of CKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "KeyUsage.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateKeyUsageObject

  Synopsis : Create a IKeyUsage object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the IKeyUsage object.

             IKeyUsage ** ppIKeyUsage    - Pointer to pointer IKeyUsage object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateKeyUsageObject (PCCERT_CONTEXT pCertContext, 
                              IKeyUsage   ** ppIKeyUsage)
{
    HRESULT hr = S_OK;
    CComObject<CKeyUsage> * pCKeyUsage = NULL;

    DebugTrace("Entering CreateKeyUsageObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIKeyUsage);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CKeyUsage>::CreateInstance(&pCKeyUsage)))
        {
            DebugTrace("Error [%#x]: CComObject<CKeyUsage>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Init the object.
        //
        if (FAILED(hr = pCKeyUsage->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCKeyUsage->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IKeyUsage pointer to caller.
        //
        if (FAILED(hr = pCKeyUsage->QueryInterface(ppIKeyUsage)))
        {
            DebugTrace("Error [%#x]: pCKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateKeyUsageObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCKeyUsage)
    {
        delete pCKeyUsage;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CKeyUsage
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsPresent

  Synopsis : Check to see if the KeyUsage extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsPresent().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
  	    *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsPresent().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsCritical

  Synopsis : Check to see if the KeyUsage extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsCritical().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
  	    *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsCritical().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsDigitalSignatureEnabled

  Synopsis : Check to see if Digital Signature bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsDigitalSignatureEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsDigitalSignatureEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_DIGITAL_SIGNATURE_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsDigitalSignatureEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsNonRepudiationEnabled

  Synopsis : Check to see if Non Repudiation bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsNonRepudiationEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsNonRepudiationEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_NON_REPUDIATION_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsNonRepudiationEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsKeyEnciphermentEnabled

  Synopsis : Check to see if Key Encipherment bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsKeyEnciphermentEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsKeyEnciphermentEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_KEY_ENCIPHERMENT_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsKeyEnciphermentEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsDataEnciphermentEnabled

  Synopsis : Check to see if Data Encipherment bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsDataEnciphermentEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsDataEnciphermentEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_DATA_ENCIPHERMENT_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsDataEnciphermentEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsKeyAgreementEnabled

  Synopsis : Check to see if Key Agreement bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsKeyAgreementEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsKeyAgreementEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_KEY_AGREEMENT_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsKeyAgreementEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsKeyCertSignEnabled

  Synopsis : Check to see if Key Cert Sign bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsKeyCertSignEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsKeyCertSignEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_KEY_CERT_SIGN_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsKeyCertSignEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsCRLSignEnabled

  Synopsis : Check to see if CRL Sign bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsCRLSignEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsCRLSignEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_CRL_SIGN_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsCRLSignEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsEncipherOnlyEnabled

  Synopsis : Check to see if Encipher Only bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsEncipherOnlyEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsEncipherOnlyEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_ENCIPHER_ONLY_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsEncipherOnlyEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsDecipherOnlyEnabled

  Synopsis : Check to see if Decipher Only bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsDecipherOnlyEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsDecipherOnlyEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_DECIPHER_ONLY_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsDecipherOnlyEnabled().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT            hr          = S_OK;
    DWORD              dwKeyUsages = 0;
    VARIANT_BOOL       bIsPresent  = VARIANT_FALSE;
    VARIANT_BOOL       bIsCritical = VARIANT_FALSE;

    DebugTrace("Entering CKeyUsage::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Check the key usage.
    //
    if (::CertGetIntendedKeyUsage(CAPICOM_ASN_ENCODING,
                                  pCertContext->pCertInfo,
                                  (BYTE *) &dwKeyUsages,
                                  sizeof(dwKeyUsages))) 
    {
        CERT_EXTENSION * pCertExtension;
        
        bIsPresent = VARIANT_TRUE;

        //
        // Find the extension to see if mark critical.
        //
        pCertExtension = ::CertFindExtension(szOID_KEY_USAGE ,
                                             pCertContext->pCertInfo->cExtension,
                                             pCertContext->pCertInfo->rgExtension);
        if (NULL != pCertExtension)
        {
            if (pCertExtension->fCritical)
            {
                bIsCritical = VARIANT_TRUE;
            }
        }
    }
    else
    {
        //
        // Could be extension not present or an error.
        //
        DWORD dwWinError = ::GetLastError();
        if (dwWinError)
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

			DebugTrace("Error [%#x]: CertGetIntendedKeyUsage() failed.\n", hr);
            goto CommonExit;
        }
     }

    //
    // Update member variables.
    //
    m_bIsPresent = bIsPresent;
    m_bIsCritical = bIsCritical;
    m_dwKeyUsages = dwKeyUsages;

CommonExit:

    DebugTrace("Leaving CKeyUsage::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\keyusage.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    KeyUsage.h

  Content: Declaration of the CKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __KEYUSAGE_H_
#define __KEYUSAGE_H_

#include "resource.h"       // main symbols
#include "Lock.h"
#include "Error.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateKeyUsageObject

  Synopsis : Create a IKeyUsage object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                          to initialize the IKeyUsage object.

             IKeyUsage ** ppIKeyUsage   - Pointer to pointer IKeyUsage object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateKeyUsageObject (PCCERT_CONTEXT pCertContext, IKeyUsage ** ppIKeyUsage);


////////////////////////////////////////////////////////////////////////////////
//
// CKeyUsage
//

class ATL_NO_VTABLE CKeyUsage : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CKeyUsage, &CLSID_KeyUsage>,
    public ICAPICOMError<CKeyUsage, &IID_IKeyUsage>,
	public IDispatchImpl<IKeyUsage, &IID_IKeyUsage, &LIBID_CAPICOM>
{
public:
	CKeyUsage()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CKeyUsage)
	COM_INTERFACE_ENTRY(IKeyUsage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CKeyUsage)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for KeyUsage object.\n", hr);
            return hr;
        }

        m_dwKeyUsages = 0;
        m_bIsPresent  = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IKeyUsage
//
public:
	STDMETHOD(get_IsDecipherOnlyEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsEncipherOnlyEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsCRLSignEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsKeyCertSignEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsKeyAgreementEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsDataEnciphermentEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsKeyEnciphermentEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsNonRepudiationEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsDigitalSignatureEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock          m_Lock;
    DWORD          m_dwKeyUsages;
    VARIANT_BOOL   m_bIsPresent;
    VARIANT_BOOL   m_bIsCritical;
};
#endif //__KEYUSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\error.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Error.h

  Content: Global error reporting facilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef _INCLUDE_ERROR_H
#define _INCLUDE_ERROR_H

#include "CAPICOM.h"
#include "resource.h"

typedef struct capicom_error_map
{
    CAPICOM_ERROR_CODE ErrorCode;
    DWORD              ErrorStringId;
} CAPICOM_ERROR_MAP;

//
// Error code to error string ID map.
//
static CAPICOM_ERROR_MAP CapicomErrorMap[] = 
{
    {CAPICOM_E_ENCODE_INVALID_TYPE,               IDS_CAPICOM_E_ENCODE_INVALID_TYPE},
    {CAPICOM_E_EKU_INVALID_OID,                   IDS_CAPICOM_E_EKU_INVALID_OID},
    {CAPICOM_E_EKU_OID_NOT_INITIALIZED,           IDS_CAPICOM_E_EKU_OID_NOT_INITIALIZED},
    {CAPICOM_E_CERTIFICATE_NOT_INITIALIZED,       IDS_CAPICOM_E_CERTIFICATE_NOT_INITIALIZED},
    {CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY,        IDS_CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY},
    {CAPICOM_E_CHAIN_NOT_BUILT,                   IDS_CAPICOM_E_CHAIN_NOT_BUILT},
    {CAPICOM_E_STORE_NOT_OPENED,                  IDS_CAPICOM_E_STORE_NOT_OPENED},
    {CAPICOM_E_STORE_EMPTY,                       IDS_CAPICOM_E_STORE_EMPTY},
    {CAPICOM_E_STORE_INVALID_OPEN_MODE,           IDS_CAPICOM_E_STORE_INVALID_OPEN_MODE},
    {CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE,        IDS_CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE},
    {CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED,    IDS_CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED},
    {CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED,   IDS_CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED},
    {CAPICOM_E_ATTRIBUTE_INVALID_NAME,            IDS_CAPICOM_E_ATTRIBUTE_INVALID_NAME},
    {CAPICOM_E_ATTRIBUTE_INVALID_VALUE,           IDS_CAPICOM_E_ATTRIBUTE_INVALID_VALUE},
    {CAPICOM_E_SIGNER_NOT_INITIALIZED,            IDS_CAPICOM_E_SIGNER_NOT_INITIALIZED},
    {CAPICOM_E_SIGNER_NOT_FOUND,                  IDS_CAPICOM_E_SIGNER_NOT_FOUND},
    {CAPICOM_E_SIGN_NOT_INITIALIZED,              IDS_CAPICOM_E_SIGN_NOT_INITIALIZED},
    {CAPICOM_E_SIGN_INVALID_TYPE,                 IDS_CAPICOM_E_SIGN_INVALID_TYPE},
    {CAPICOM_E_SIGN_NOT_SIGNED,                   IDS_CAPICOM_E_SIGN_NOT_SIGNED},
    {CAPICOM_E_INVALID_ALGORITHM,                 IDS_CAPICOM_E_INVALID_ALGORITHM},
    {CAPICOM_E_INVALID_KEY_LENGTH,                IDS_CAPICOM_E_INVALID_KEY_LENGTH},
    {CAPICOM_E_ENVELOP_NOT_INITIALIZED,           IDS_CAPICOM_E_ENVELOP_NOT_INITIALIZED},
    {CAPICOM_E_ENVELOP_INVALID_TYPE,              IDS_CAPICOM_E_ENVELOP_INVALID_TYPE},
    {CAPICOM_E_ENVELOP_NO_RECIPIENT,              IDS_CAPICOM_E_ENVELOP_NO_RECIPIENT},
    {CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND,       IDS_CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND},
    {CAPICOM_E_ENCRYPT_NOT_INITIALIZED,           IDS_CAPICOM_E_ENCRYPT_NOT_INITIALIZED},
    {CAPICOM_E_ENCRYPT_INVALID_TYPE,              IDS_CAPICOM_E_ENCRYPT_INVALID_TYPE},
    {CAPICOM_E_ENCRYPT_NO_SECRET,                 IDS_CAPICOM_E_ENCRYPT_NO_SECRET},
    {CAPICOM_E_NOT_SUPPORTED,                     IDS_CAPICOM_E_NOT_SUPPORTED},
    {CAPICOM_E_UI_DISABLED,                       IDS_CAPICOM_E_UI_DISABLED},
    {CAPICOM_E_CANCELLED,                         IDS_CAPICOM_E_CANCELLED},
    {CAPICOM_E_INTERNAL,                          IDS_CAPICOM_E_INTERNAL},
    {CAPICOM_E_UNKNOWN,                           IDS_CAPICOM_E_UNKNOWN},
};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  ICAPICOMError:

  This is a template class that implements the ISupportErrorInfo interface. In
  addition, it also contains member functions that facilitate error reporting.
  
  To use it, simply derive your class from this class, and add ISupportErrorInfo
  entry into your COM map.

  ie.

  class ATL_NO_VTABLE CMyClass : 
	...
    public ICAPICOMError<CMyClass, &IID_IMyClass>,
    ...
  {
    ...

    BEGIN_COM_MAP(CMyClass)
        ...
	    COM_INTERFACE_ENTRY(ISupportErrorInfo)
        ...
    END_COM_MAP()
    
    ...
  };

------------------------------------------------------------------------------*/

template <class T, const IID * piid>
class ATL_NO_VTABLE ICAPICOMError: public ISupportErrorInfo
{
public:
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
    {
		return (InlineIsEqualGUID(riid, *piid)) ? S_OK : S_FALSE;
    }

    HRESULT ReportError(HRESULT hr)
    {
        HLOCAL pMsgBuf = NULL;

        DebugTrace("Entering ReportError(HRESULT).\n");

        //
        // If there's a system message associated with this error, report that.
        //
        if (::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             (DWORD) hr,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                             (LPWSTR) &pMsgBuf,
                             0,
                             NULL))
        {
            //
            // Sanity check.
            //
            ATLASSERT(NULL != pMsgBuf);

            //
            // Report error and free the buffer.
            //
            if (pMsgBuf)
            {
                CComCoClass<T>::Error((LPWSTR) pMsgBuf, *piid, hr);

                ::LocalFree(pMsgBuf);
            }
        }
        else
        {
            //
            // No, so try CAPICOM error.
            //
            ReportError((CAPICOM_ERROR_CODE) hr); 
        }

        DebugTrace("Leaving ReportError(HRESULT).\n");

        return hr;
    }

    HRESULT ReportError(CAPICOM_ERROR_CODE CAPICOMError)
    {
        HRESULT hr      = (HRESULT) CAPICOMError;
        DWORD   ids     = IDS_CAPICOM_E_UNKNOWN;
        DWORD   cbMsg   = 0;
        HLOCAL  pMsgBuf = NULL;
        WCHAR   wszFormat[512] = L"";

        DebugTrace("Entering ReportError(CAPICOM_ERROR_CODE).\n");

        //
        // Map to error string id.
        //
        for (DWORD i = 0; i < ARRAYSIZE(CapicomErrorMap); i++)
        {
            if (CapicomErrorMap[i].ErrorCode == CAPICOMError)
            {
                ids = CapicomErrorMap[i].ErrorStringId;
                break;
            }
        }

        //
        // Load error format string from resource.
        //
        if (::LoadStringW(_Module.GetModuleInstance(), 
                          ids, 
                          wszFormat,
                          sizeof(wszFormat) / sizeof(wszFormat[0])))
        {
            //
            // Format message into buffer.
            //
            if (L'\0' != wszFormat[0])
            {
                cbMsg = ::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                         wszFormat,
                                         0,
                                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                         (LPWSTR) &pMsgBuf,
                                         0,
                                         NULL);
            }
        }
        else
        {
            //
            // well, try a general error string.
            //
            if (::LoadStringW(_Module.GetModuleInstance(),
                              hr = CAPICOM_E_UNKNOWN,
                              wszFormat,
                              sizeof(wszFormat) / sizeof(wszFormat[0])))
            {
                cbMsg = ::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                         wszFormat,
                                         0,
                                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                         (LPWSTR) &pMsgBuf,
                                         0,
                                         NULL);
            }
        }

        //
        // If we are still unable to get a formatted error string, then
        // fablicate one ourselves (very unlikely).
        //
        if (0 == cbMsg)
        {
            pMsgBuf = (HLOCAL) ::LocalAlloc(LPTR, sizeof(wszFormat));
            if (NULL != pMsgBuf)
            {
                ::lstrcpyW((LPWSTR) pMsgBuf, L"Unknown error.\n");
            }
        }

        //
        // Report error and free the buffer.
        //
        if (pMsgBuf)
        {
            CComCoClass<T>::Error((LPWSTR) pMsgBuf, *piid, hr);

            ::LocalFree(pMsgBuf);
        }

        DebugTrace("Leaving ReportError(CAPICOM_ERROR_CODE).\n");

        return hr;
    }
};
#endif // __INCLUDE_ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\recipients.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000.

  File:    Recipients.cpp

  Content: Implementation of CRecipients.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Recipients.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateRecipientsObject

  Synopsis : Create and initialize an IRecipients collection object.

  Parameter: IRecipients ** ppIRecipients - Pointer to pointer to IRecipients 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateRecipientsObject (IRecipients ** ppIRecipients)
{
    HRESULT hr = S_OK;
    CComObject<CRecipients> * pCRecipients = NULL;

    DebugTrace("Entering CreateRecipientsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != ppIRecipients);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CRecipients>::CreateInstance(&pCRecipients)))
        {
            DebugTrace("Error [%#x]: CComObject<CRecipients>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IRecipients pointer to caller.
        //
        if (FAILED(hr = pCRecipients->QueryInterface(ppIRecipients)))
        {
            DebugTrace("Error [%#x]: pCRecipients->QueryInterface().\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateRecipientsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCRecipients)
    {
        delete pCRecipients;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CRecipients
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CRecipients::Add

  Synopsis : Add a recipient to the collection.

  Parameter: ICertificate * pVal - Recipient to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CRecipients::Add (ICertificate * pVal)
{
    HRESULT        hr           = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CRecipients::Add().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        char     szIndex[32];
        CComBSTR bstrIndex;

        //
        // Make sure we have a valid cert by getting the CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pVal, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Free the CERT_CONTEXT.
        //
        if (!::CertFreeCertificateContext(pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfA(szIndex, "%06u", m_coll.size() + 1);
        bstrIndex = szIndex;

        DebugTrace("Before adding to map: CRecipients.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pVal;

        DebugTrace("After adding to map: CRecipients.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CRecipients::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CRecipients::Remove

  Synopsis : Remove a recipient from the collection.

  Parameter: long Val - Recipient index (1-based).

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CRecipients::Remove (long Val)
{
	HRESULT  hr = S_OK;
    WCHAR    szIndex[32];
    CComBSTR bstrIndex;

    DebugTrace("Entering CRecipients::Remove().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameter is valid.
        //
        if (Val > (long) m_coll.size())
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, Val is out of range.\n");
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfW(szIndex, L"%06u", Val);
        bstrIndex = szIndex;

        //
        // Remove object from map.
        //
        if (!m_coll.erase(bstrIndex))
        {
            hr = E_UNEXPECTED;

            DebugTrace("Unexpected error: m_coll.erase() failed.\n");
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CRecipients::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CRecipients::Clear

  Synopsis : Remove all recipients from the collection.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CRecipients::Clear (void)
{
	HRESULT hr = S_OK;

    DebugTrace("Entering CRecipients::Clear().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Clear it.
        //
        m_coll.clear();
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CRecipients::Clear().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\lock.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File   : Lock.h

  Content: Implementation of CLock class.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __LOCK_H_
#define __LOCK_H_

#include <windows.h>

class CLock
{
public:
    CLock()
    {
        __try
        {
            ::InitializeCriticalSection(&m_CriticalSection);
            m_Initialized = S_OK;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            m_Initialized = HRESULT_FROM_WIN32(::GetExceptionCode());
        }
    }

    ~CLock()
    {
        if (SUCCEEDED(m_Initialized))
        {
            ::DeleteCriticalSection(&m_CriticalSection);
        }
    }

    HRESULT Initialized()
    {
        return m_Initialized;
    }

    void Lock()
    {
        if (SUCCEEDED(m_Initialized))
        {
            ::EnterCriticalSection(&m_CriticalSection);
        }
    }

    void Unlock()
    {
        if (SUCCEEDED(m_Initialized))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
        }
    }

private:
    HRESULT          m_Initialized;
    CRITICAL_SECTION m_CriticalSection;
};

#endif //__LOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\recipients.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Recipients.h

  Content: Declaration of CRecipients.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
	
#ifndef __RECIPIENTS_H_
#define __RECIPIENTS_H_

#include "resource.h"       // main symbols
#include "Certificate.h"
#include "Lock.h"
#include "Error.h"


////////////////////
//
// Locals
//

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<ICertificate> > RecipientMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<ICertificate>, RecipientMap> RecipientEnum;
typedef ICollectionOnSTLImpl<IRecipients, RecipientMap, VARIANT, _CopyMapItem<ICertificate>, RecipientEnum> IRecipientsCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateRecipientsObject

  Synopsis : Create and initialize an IRecipients collection object.

  Parameter: IRecipients ** ppIRecipients - Pointer to pointer to IRecipients 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateRecipientsObject (IRecipients ** ppIRecipients);


////////////////////////////////////////////////////////////////////////////////
//
// CRecipients
//

class ATL_NO_VTABLE CRecipients : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRecipients, &CLSID_Recipients>,
    public ICAPICOMError<CRecipients, &IID_IRecipients>,
	public IDispatchImpl<IRecipientsCollection, &IID_IRecipients, &LIBID_CAPICOM>
{
public:
	CRecipients()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRecipients)
	COM_INTERFACE_ENTRY(IRecipients)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CRecipients)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Recipients object.\n", hr);
            return hr;
        }

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IRecipients
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
	STDMETHOD(Clear)
        (void);

	STDMETHOD(Remove)
        (/*[in]*/ long Val);

	STDMETHOD(Add)
        (/*[in]*/ ICertificate * pVal);

private:
    CLock   m_Lock;
};

#endif //__RECIPIENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\signeddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    SignedData.cpp

  Content: Implementation of CSignedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Certificate.h"
#include "Signer.h"
#include "Chain.h"
#include "Convert.h"
#include "Common.h"
#include "Settings.h"
#include "DialogUI.h"
#include "SignedData.h"


////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : VerifyCertificate

  Synopsis : Verify if the certificate is valid.

  Parameter: HCERTSTORE hPKCS7Store - HCERTSTORE of message or NULL.

             PCCERT_CONTEXT - CERT_CONTEXT of cert to verify.

             DWORD * pdwCertError - Pointer to DWORD to receive the cert
                                    validity error code.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT VerifyCertificate (HCERTSTORE     hPKCS7Store, 
                           PCCERT_CONTEXT pCertContext,
                           DWORD        * pdwCertError)
{
    HRESULT                  hr            = S_OK;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    CERT_CHAIN_PARA          ChainPara     = {sizeof(CERT_CHAIN_PARA), {USAGE_MATCH_TYPE_AND, {0, NULL}}};
    CERT_CHAIN_POLICY_PARA   PolicyPara    = {sizeof(CERT_CHAIN_POLICY_PARA), 0, NULL};
    CERT_CHAIN_POLICY_STATUS PolicyStatus  = {sizeof(CERT_CHAIN_POLICY_STATUS), 0, 0, 0, NULL};

    DebugTrace("Entering VerifyCertificate().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pdwCertError);

    //
    // Build the chain.
    //
    if (!::CertGetCertificateChain(NULL,            // in optional 
                                   pCertContext,    // in 
                                   NULL,            // in optional
                                   hPKCS7Store,     // in optional 
                                   &ChainPara,      // in 
                                   0,               // in 
                                   NULL,            // in 
                                   &pChainContext)) // out 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertGetCertificateChain() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Verify the chain.
    //
    if (::CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                           pChainContext,
                                           &PolicyPara,
                                           &PolicyStatus))
    {
        *pdwCertError = 0;
    }
    else
    {
        *pdwCertError = PolicyStatus.dwError;

        DebugTrace("Error: CertVerifyCertificateChainPolicy() failed.\n");
    }
    
CommonExit:
    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    DebugTrace("Leaving VerifyCertificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetSignerCert

  Synopsis : Retrieve signer's cert from ISigner object. If signer's cert is
             not available in the ISigner object, pop UI to prompt user to 
             select a signing cert.

  Parameter: ISigner * pISigner - Pointer to ISigner or NULL.

             ISigner ** ppISigner - Pointer to pointer to ISigner to receive
                                    interface pointer.

             ICertificate ** ppICertificate - Pointer to pointer to ICertificate
                                              to receive interface pointer.

             PCCERT_CONTEXT * ppCertContext - Pointer to pointer to CERT_CONTEXT
                                              to receive cert context.

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT GetSignerCert (ISigner        * pISigner,
                              ISigner       ** ppISigner,
                              ICertificate  ** ppICertificate,
                              PCCERT_CONTEXT * ppCertContext)
{
    HRESULT               hr             = S_OK;
    CComPtr<ISigner>      pISigner2      = NULL;
    CComPtr<ICertificate> pICertificate  = NULL;
    PCCERT_CONTEXT        pCertContext   = NULL;
    DWORD                 dwCertError    = 0;
    VARIANT_BOOL          bHasPrivateKey = VARIANT_TRUE;

    DebugTrace("Entering GetSignerCert().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppISigner);
    ATLASSERT(ppICertificate);
    ATLASSERT(ppCertContext);

    //
    // Initialize.
    //
    *ppISigner = NULL;
    *ppICertificate = NULL;
    *ppCertContext = NULL;

    try
    {
        //
        // Did user pass us an ISigner?
        //
        if (pISigner)
        {
            //
            // Retrieve the signer's cert.
            //
            hr = pISigner->get_Certificate(&pICertificate);

            //
            // If signer's cert is not present, pop UI.
            //
            if (CAPICOM_E_SIGNER_NOT_INITIALIZED == hr)
            {
                //
                // Prompt user to select a certificate.
                //
                if (FAILED(hr = ::SelectSignerCert(&pICertificate)))
                {
                    DebugTrace("Error [%#x]: SelectSignerCert() failed.\n", hr);
                    goto ErrorExit;
                }
            }

            //
            // Get cert context.
            //
            if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
            {
                DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
                goto ErrorExit;
            }

            pISigner2 = pISigner;
        }
        else
        {
            CRYPT_ATTRIBUTES attributes = {0, NULL};

            //
            // No signer specified, so prompt user to select a certificate.
            //
            if (FAILED(hr = ::SelectSignerCert(&pICertificate)))
            {
                DebugTrace("Error [%#x]: SelectSignerCert() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get cert context.
            //
            if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
            {
                DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Create the ISigner object.
            //
            if (FAILED(hr = ::CreateSignerObject(pCertContext, &attributes, &pISigner2)))
            {
                DebugTrace("Error [%#x]: CreateSignerObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Make sure the cert is valid.
        //
        if (FAILED(hr = ::VerifyCertificate(NULL, pCertContext, &dwCertError)))
        {
            DebugTrace("Error: VerifyCertificate() failed.\n");
            goto ErrorExit;
        }
        if (dwCertError)
        {
            hr = HRESULT_FROM_WIN32(dwCertError);

            DebugTrace("Error [%#x]: invalid cert.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we have a private key.
        //
        if (FAILED(hr = pICertificate->HasPrivateKey(&bHasPrivateKey)))
        {
            DebugTrace("Error [%#x]: pICertifiacte->HasPrivateKey() failed.\n", hr);
            goto ErrorExit;
        }
        if (VARIANT_TRUE != bHasPrivateKey)
        {
            hr = CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY;

            DebugTrace("Error: signer's private key is not available.\n");
            goto ErrorExit;
        }

        //
        // Return values to caller.
        //
        if (FAILED(hr = pISigner2->QueryInterface(ppISigner)))
        {
            DebugTrace("Unexpected error [%#x]: pISigner2->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = pICertificate->QueryInterface(ppICertificate)))
        {
            DebugTrace("Unexpected error [%#x]: pICertificate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        *ppCertContext = pCertContext;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving GetSignerCert().\n");
       
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (*ppICertificate)
    {
        (*ppICertificate)->Release();
        *ppICertificate = NULL;
    }
    if (*ppISigner)
    {
        (*ppISigner)->Release();
        *ppISigner = NULL;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeCertificateChain

  Synopsis : Free resources allocated for the chain built with 
             InitCertificateChain.

  Parameter: CRYPT_DATA_BLOB * pChainBlob - Pointer to chain blob.

  Remark   :

------------------------------------------------------------------------------*/

static void FreeCertificateChain (CRYPT_DATA_BLOB * pChainBlob)
{
    PCCERT_CONTEXT * rgCertContext;

    DebugTrace("Entering FreeCertificateChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainBlob);

    //
    // Return if nothing to free.
    //
    if (0 == pChainBlob->cbData)
    {
        return;
    }

    //
    // Sanity check.
    //
    ATLASSERT(pChainBlob->pbData);

    //
    // Free all allocated memory for the chain.
    //
    rgCertContext = (PCCERT_CONTEXT *) pChainBlob->pbData;
    for (DWORD i = 0; i < pChainBlob->cbData; i++, rgCertContext++)
    {
        ATLASSERT(*rgCertContext);

        ::CertFreeCertificateContext(*rgCertContext);
    }

    ::CoTaskMemFree((LPVOID) pChainBlob->pbData);

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AddCertificateChain

  Synopsis : Add the chain of certificates to the bag of certs.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DATA_BLOB * pChainBlob - Pointer chain blob of PCCERT_CONTEXT.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT AddCertificateChain (HCRYPTMSG   hMsg, 
                                    DATA_BLOB * pChainBlob)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AddCertificateChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);

    DWORD cCertContext = pChainBlob->cbData;
    PCERT_CONTEXT * rgCertContext = (PCERT_CONTEXT *) pChainBlob->pbData;

    if (1 < cCertContext)
    {
        cCertContext--;
    }

    //
    // Add all certs from the chain to message.
    //
    for (DWORD i = 0; i < cCertContext; i++)
    {
        //
        // Is this cert already in the bag of certs?
        //
        if (FAILED(hr =::FindSignerCertInMessage(hMsg, 
                                                 &rgCertContext[i]->pCertInfo->Issuer,
                                                 &rgCertContext[i]->pCertInfo->SerialNumber,
                                                 NULL)))
        {
            //
            // No, so add to bag of certs.
            //
            DATA_BLOB CertBlob = {rgCertContext[i]->cbCertEncoded, 
                                  rgCertContext[i]->pbCertEncoded};

            if (!::CryptMsgControl(hMsg,
                                   0,
                                   CMSG_CTRL_ADD_CERT,
                                   &CertBlob))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptMsgControl() failed for CMSG_CTRL_ADD_CERT.\n", hr);
                break;
            }

            hr = S_OK;
        }
    }

    DebugTrace("Leaving AddCertificateChain().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : InitCertificateChain

  Synopsis : Allocate and initialize a certificate chain for the specified 
             certificate, and return the chain in an array of PCERT_CONTEXT.

  Parameter: ICertificate * pICertificate - Pointer to ICertificate for which
                                            the chain will be built.

             CRYPT_DATA_BLOB * pChainBlob - Pointer to blob to recevie the
                                            size and array of PCERT_CONTEXT
                                            for the chain.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT InitCertificateChain (ICertificate    * pICertificate, 
                                     CRYPT_DATA_BLOB * pChainBlob)
{
    HRESULT              hr      = S_OK;
    CComObject<CChain> * pCChain = NULL;
    CComPtr<IChain>      pIChain = NULL;
    VARIANT_BOOL         bResult = VARIANT_FALSE;

    DebugTrace("Entering InitCertificateChain().\n");

    //
    // Sanity checks.
    //
    ATLASSERT(pICertificate);
    ATLASSERT(pChainBlob);

    //
    // Create a chain object.
    //
    if (FAILED(hr = CComObject<CChain>::CreateInstance(&pCChain)))
    {
        DebugTrace("Error [%#x]: CComObject<CChain>::CreateInstance() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Get IChain pointer.
    //
    if (FAILED(hr = pCChain->QueryInterface(&pIChain)))
    {
        delete pCChain;

        DebugTrace("Unexpected error [%#x]: pCChain->QueryInterface() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Build the chain.
    //
    if (FAILED(hr = pIChain->Build(pICertificate, &bResult)))
    {
        DebugTrace("Error [%#x]: pIChain->Build() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Get the chain of certs.
    //
    if (FAILED(hr = ::GetChainContext(pIChain, pChainBlob)))
    {
        DebugTrace("Error [%#x]: GetChainContext() failed.\n", hr);
    }

CommonExit:

    DebugTrace("Leaving InitCertificateChain().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeAuthenticatedAttributes

  Synopsis : Free memory allocated for all authenticated attributes.

  Parameter: DWORD cAuthAttr             - Number of attributes.

             PCRYPT_ATTRIBUTE rgAuthAttr - Pointer to CRYPT_ATTRIBUTE array.

  Remark   :

------------------------------------------------------------------------------*/

static void FreeAuthenticatedAttributes (DWORD            cAuthAttr, 
                                         PCRYPT_ATTRIBUTE rgAuthAttr)
{
    DebugTrace("Entering FreeAuthenticatedAttributes().\n");

    //
    // Make sure we have something to free.
    //
    if (rgAuthAttr)
    {
        //
        // First free each element of the array.
        //
        for (DWORD i = 0; i < cAuthAttr; i++)
        {
            if (NULL != rgAuthAttr[i].rgValue)
            {
                for (DWORD j = 0; j < rgAuthAttr[i].cValue; j++)
                {
                    if (NULL != rgAuthAttr[i].rgValue[j].pbData)
                    {
                        ::CoTaskMemFree((LPVOID) rgAuthAttr[i].rgValue[j].pbData);
                    }
                }

                ::CoTaskMemFree(rgAuthAttr[i].rgValue);
            }
        }

        //
        // Then free the array itself.
        //
        ::CoTaskMemFree((LPVOID) rgAuthAttr);
    }

    DebugTrace("Leaving FreeAuthenticatedAttributes().\n");

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AddAuthenticatedAttributes

  Synopsis : Allocate memory and add authenticated attribute of the specified
             signer to the CMSG_SIGNER_ENCODE_INFO structure.

  Parameter: ISigner * pISigner - Pointer to ISigner.
  
             CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to 
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT AddAuthenticatedAttributes (ISigner                 * pISigner,
                                           CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo)
{
    HRESULT hr          = S_OK;
    long    cAttributes = 0;
    CComPtr<IAttributes> pIAttributes = NULL;

    DebugTrace("Entering AddAuthenticatedAttributes().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);

    //
    // Get authenticated attributes.
    //
    if (FAILED(hr = pISigner->get_AuthenticatedAttributes(&pIAttributes)))
    {
        DebugTrace("Error [%#x]: pISigner->get_AuthenticatedAttributes() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get count of attributes.
    //
    if (FAILED(hr = pIAttributes->get_Count(&cAttributes)))
    {
        DebugTrace("Error [%#x]: pIAttributes->get_Count() failed.\n", hr);
        goto ErrorExit;
    }

    if (0 < cAttributes)
    {
        //
        // Allocate memory for attribute array.
        //
        pSignerEncodeInfo->cAuthAttr = (DWORD) cAttributes;
        pSignerEncodeInfo->rgAuthAttr = (PCRYPT_ATTRIBUTE) ::CoTaskMemAlloc(sizeof(CRYPT_ATTRIBUTE) * cAttributes);
        if (!pSignerEncodeInfo->rgAuthAttr)
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        ::ZeroMemory(pSignerEncodeInfo->rgAuthAttr, sizeof(CRYPT_ATTRIBUTE) * cAttributes);

        //
        // Loop thru each attribute and add to the array.
        //
        for (long cAttr = 0; cAttr < cAttributes; cAttr++)
        {
            CAPICOM_ATTRIBUTE AttrName;
            CComVariant varValue;
            CComVariant varIAttribute;
            CComPtr<IAttribute> pIAttribute = NULL;

            //
            // Get next attribute.
            //
            if (FAILED(hr = pIAttributes->get_Item(cAttr + 1, &varIAttribute)))
            {
                DebugTrace("Error [%#x]: pIAttributes->get_Item() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get custom interface.
            //
            if (FAILED(hr = varIAttribute.pdispVal->QueryInterface(IID_IAttribute, 
                                                                   (void **) &pIAttribute)))
            {
                DebugTrace("Error [%#x]: varIAttribute.pdispVal->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get attribute name.
            //
            if (FAILED(hr = pIAttribute->get_Name(&AttrName)))
            {
                DebugTrace("Error [%#x]: pIAttribute->get_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get attribute value.
            //
            if (FAILED(hr = pIAttribute->get_Value(&varValue)))
            {
                DebugTrace("Error [%#x]: pIAttribute->get_Value() failed.\n", hr);
                goto ErrorExit;
            }

            switch (AttrName)
            {
                case CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME:
                {
                    FILETIME ft;
                    SYSTEMTIME st;

                    //
                    // Conver to FILETIME.
                    //
                    if (!::VariantTimeToSystemTime(varValue.date, &st))
                    {
                        hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                        DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n");
                        goto ErrorExit;
                    }

                    if (!::SystemTimeToFileTime(&st, &ft))
                    {
                        hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                        DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n");
                        goto ErrorExit;
                    }

                    //
                    // Now encode it.
                    //
                    pSignerEncodeInfo->rgAuthAttr[cAttr].cValue = 1;
                    pSignerEncodeInfo->rgAuthAttr[cAttr].pszObjId = szOID_RSA_signingTime;
                    pSignerEncodeInfo->rgAuthAttr[cAttr].rgValue = (CRYPT_ATTR_BLOB *) ::CoTaskMemAlloc(sizeof(CRYPT_ATTR_BLOB));

                    if (FAILED(hr = ::EncodeObject ((LPSTR) szOID_RSA_signingTime, 
                                                    (LPVOID) &ft, 
                                                    pSignerEncodeInfo->rgAuthAttr[cAttr].rgValue)))
                    {
                        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
                        goto ErrorExit;
                    }
                    
                    break;
                }

                case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME:
                {
                    CRYPT_DATA_BLOB NameBlob = {0, NULL};

                    NameBlob.cbData = ::SysStringByteLen(varValue.bstrVal);
                    NameBlob.pbData = (PBYTE) varValue.bstrVal;

                    pSignerEncodeInfo->rgAuthAttr[cAttr].cValue = 1;
                    pSignerEncodeInfo->rgAuthAttr[cAttr].pszObjId = szOID_CAPICOM_DOCUMENT_NAME;
                    pSignerEncodeInfo->rgAuthAttr[cAttr].rgValue = (CRYPT_ATTR_BLOB *) ::CoTaskMemAlloc(sizeof(CRYPT_ATTR_BLOB));

                    if (FAILED(hr = ::EncodeObject ((LPSTR) X509_OCTET_STRING, 
                                                    (LPVOID) &NameBlob, 
                                                    pSignerEncodeInfo->rgAuthAttr[cAttr].rgValue)))
                    {
                        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
                        goto ErrorExit;
                    }

                    break;
                }

                case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION:
                {
                    CRYPT_DATA_BLOB DescBlob = {0, NULL};

                    DescBlob.cbData = ::SysStringByteLen(varValue.bstrVal);
                    DescBlob.pbData = (PBYTE) varValue.bstrVal;

                    pSignerEncodeInfo->rgAuthAttr[cAttr].cValue = 1;
                    pSignerEncodeInfo->rgAuthAttr[cAttr].pszObjId = szOID_CAPICOM_DOCUMENT_DESCRIPTION;
                    pSignerEncodeInfo->rgAuthAttr[cAttr].rgValue = (CRYPT_ATTR_BLOB *) ::CoTaskMemAlloc(sizeof(CRYPT_ATTR_BLOB));

                    if (FAILED(hr = ::EncodeObject ((LPSTR) X509_OCTET_STRING, 
                                                    (LPVOID) &DescBlob, 
                                                    pSignerEncodeInfo->rgAuthAttr[cAttr].rgValue)))
                    {
                        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
                        goto ErrorExit;
                    }

                    break;
                }

                default:
                {
                    hr = CAPICOM_E_ATTRIBUTE_INVALID_NAME;

                    DebugTrace("Error [%#x]: unknown attribute name.\n", hr);
                    goto ErrorExit;
                }
            }
        }
    }

CommonExit:

    DebugTrace("Leaving AddAuthenticatedAttributes().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pSignerEncodeInfo->rgAuthAttr)
    {
        ::FreeAuthenticatedAttributes(pSignerEncodeInfo->cAuthAttr, 
                                      pSignerEncodeInfo->rgAuthAttr);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeSignerEncodeInfo

  Synopsis : Free all memory allocated for the CMSG_SIGNER_ENCODE_INFO 
             structure, including any memory allocated for members of the
             structure.

  Parameter: CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to the
                                                           structure.

  Remark   :

------------------------------------------------------------------------------*/

static void FreeSignerEncodeInfo (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo)
{
    DebugTrace("Entering FreeSignerEncodeInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);

    //
    // First free the authenticated attributes array, if present.
    // 
    if (pSignerEncodeInfo->rgAuthAttr)
    {
        ::FreeAuthenticatedAttributes(pSignerEncodeInfo->cAuthAttr, pSignerEncodeInfo->rgAuthAttr);
    }

    //
    // Then free the structure inself.
    //
    ::CoTaskMemFree((LPVOID) pSignerEncodeInfo);

    DebugTrace("Leaving FreeSignerEncodeInfo().\n");

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : InitSignerEncodeInfo

  Synopsis : Allocate a CMSG_SIGNER_ENCODE_INFO structure, and initialize it
             with values passed in through parameters.

  Parameter: ISigner * pISigner - Pointer to ISigner.
  
             PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert.

             HCRYPTPROV phCryptProv - CSP handle.

             DWORD dwKeySpec - Key spec, AT_KEYEXCHANGE or AT_SIGNATURE.

             CMSG_SIGNER_ENCODE_INFO ** ppSignerEncodeInfo - Receive the structure.

  Return   : Pointer to an initialized CMSG_SIGNER_ENCODE_INFO structure if
             success, otherwise NULL (out of memory).

  Remark   : Must call FreeSignerEncodeInfo to free the structure.

------------------------------------------------------------------------------*/

static HRESULT InitSignerEncodeInfo (ISigner                  * pISigner,
                                     PCCERT_CONTEXT             pCertContext, 
                                     HCRYPTPROV                 hCryptProv,
                                     DWORD                      dwKeySpec,
                                     CMSG_SIGNER_ENCODE_INFO ** ppSignerEncodeInfo)
{
    HRESULT hr = S_OK;
    CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo = NULL;

    DebugTrace("Entering InitSignerEncodeInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner);
    ATLASSERT(pCertContext);
    ATLASSERT(hCryptProv);

    //
    // Allocate memory for structure.
    //
    if (!(pSignerEncodeInfo = (CMSG_SIGNER_ENCODE_INFO *) ::CoTaskMemAlloc(sizeof(CMSG_SIGNER_ENCODE_INFO))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Setup CMSG_SIGNER_ENCODE_INFO structure.
    //
    ::ZeroMemory(pSignerEncodeInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));
    pSignerEncodeInfo->cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
    pSignerEncodeInfo->pCertInfo = pCertContext->pCertInfo;
    pSignerEncodeInfo->hCryptProv = hCryptProv;
    pSignerEncodeInfo->dwKeySpec = dwKeySpec;
    pSignerEncodeInfo->HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    //
    // Add authenticated attributes to SignerInfo.
    //
    if (FAILED(hr = ::AddAuthenticatedAttributes(pISigner, pSignerEncodeInfo)))
    {
        DebugTrace("Error [%#x]: AddAuthenticatedAttributes() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return structure to caller.
    //
    *ppSignerEncodeInfo = pSignerEncodeInfo;

CommonExit:

    DebugTrace("Leaving InitSignerEncodeInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pSignerEncodeInfo)
    {
        ::CoTaskMemFree((LPVOID) pSignerEncodeInfo);
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CSignedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::get_Content

  Synopsis : Return the content.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the content.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::get_Content (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedData::get_Content().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameter is valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

		    DebugTrace("Error: invalid parameter, pVal is NULL.\n");
		    goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

		    DebugTrace("Error: sign object has not been initialized.\n");
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Return content.
        //
        if (FAILED(hr = ::BlobToBstr(&m_ContentBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedData::get_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::put_Content

  Synopsis : Initialize the object with content to be signed.

  Parameter: BSTR newVal - BSTR containing the content to be signed.

  Remark   : Note that this property should not be changed once a signature
             is created, as it will re-initialize the object even in error
             condition, unless that's your intention.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::put_Content (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedData::put_Content().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Reset member variables.
        //
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = FALSE;
        m_bDetached = VARIANT_FALSE;
        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        //
        // Make sure parameters are valid.
        //
        if (NULL == newVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, newVal is NULL.\n");
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, newVal is empty.\n");
            goto ErrorExit;
        }

        //
        // Update content.
        //
        if (FAILED(hr = ::BstrToBlob(newVal, &m_ContentBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedData::put_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::get_Signers

  Synopsis : Return all the content signers as an ISigners collection object.

  Parameter: ISigner * pVal - Pointer to pointer to ISigners to receive
                              interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::get_Signers (ISigners ** pVal)
{
    HRESULT   hr   = S_OK;
    HCRYPTMSG hMsg = NULL;

    DebugTrace("Entering CSignedData::get_Signers().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure the messages is already signed.
        //
        if (!m_bSigned)
        {
            hr = CAPICOM_E_SIGN_NOT_SIGNED;

		    DebugTrace("Error: content was not signed.\n");
		    goto ErrorExit;
        }

        //
        // Open the encoded message for decode.
        //
        if (FAILED(hr = OpenToDecode(NULL,
                                     &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the ISigners collection object.
        //
        if (FAILED(hr = ::CreateSignersObject(hMsg, 1, pVal)))
        {
            DebugTrace("Error [%#x]: CreateSignersObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedData::get_Signers().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::get_Certificates

  Synopsis : Return all certificates found in the message as an non-ordered
             ICertificates collection object.

  Parameter: ICertificates ** pVal - Pointer to pointer to ICertificates 
                                     to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::get_Certificates (ICertificates ** pVal)
{
    HRESULT   hr   = S_OK;
    HCRYPTMSG hMsg = NULL;

    DebugTrace("Entering CSignedData::get_Certificates().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure the messages is already signed.
        //
        if (!m_bSigned)
        {
            hr = CAPICOM_E_SIGN_NOT_SIGNED;

		    DebugTrace("Error: content was not signed.\n");
		    goto ErrorExit;
        }

        //
        // Open the encoded message for decode.
        //
        if (FAILED(hr = OpenToDecode(NULL, &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the ICertificates collection object.
        //
        if (FAILED(hr = ::CreateCertificatesObject(CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE,
                                                   (LPARAM) hMsg,
                                                   pVal)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::get_Certificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::Sign

  Synopsis : Sign the content and produce a signed message.

  Parameter: ISigner * pSigner - Pointer to ISigner.

             VARIANT_BOOL bDetached - TRUE if content is to be detached, else
                                      FALSE.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the signed message.

  Remark   : The certificate selection dialog will be launched 
             (CryptUIDlgSelectCertificate API) to display a list of certificates
             from the Current User\My store for selecting a signer's certificate, 
             for the following conditions:

             1) A signer is not specified (pVal is NULL) or the ICertificate
                property of the ISigner is not set
             
             2) There is more than 1 cert in the store, and
             
             3) The Settings::EnablePromptForIdentityUI property is not disabled.

             Also if called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for signing.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::Sign (ISigner             * pISigner,
                                VARIANT_BOOL          bDetached, 
                                CAPICOM_ENCODING_TYPE EncodingType,
                                BSTR                * pVal)
{
    HRESULT               hr              = S_OK;
    CComPtr<ISigner>      pISigner2       = NULL;
    CComPtr<ICertificate> pICertificate   = NULL;
    HCRYPTPROV            hCryptProv      = NULL;
    PCCERT_CONTEXT        pCertContext    = NULL;
    DWORD                 dwKeySpec       = 0;
    BOOL                  bReleaseContext = FALSE;
    DATA_BLOB             ChainBlob       = {0, NULL};
    
    CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo = NULL;

    DebugTrace("Entering CSignedData::Sign().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameter is valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

		    DebugTrace("Error: invalid parameter, pVal is NULL.\n");
		    goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

		    DebugTrace("Error: sign object has not been initialized.\n");
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Get the signer's cert (may prompt user to select signer's cert).
        //
        if (FAILED(hr = ::GetSignerCert(pISigner, &pISigner2, &pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetSignerCert() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If we are called from a web page, we need to pop up UI 
        // to get user permission to perform signing operation.
        //
        if (m_dwCurrentSafety && 
            PromptForSigningOperationEnabled() &&
            FAILED(hr = ::UserApprovedOperation(IDD_SIGN_SECURITY_ALERT_DLG)))
        {
            DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Acquire CSP context and access to private key.
        //
        if (FAILED(hr = ::AcquireContext(pCertContext, 
                                         &hCryptProv, 
                                         &dwKeySpec, 
                                         &bReleaseContext)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Build the bag of certs (cert chain minus root) to be included 
        // into the message.
        //
        if (FAILED(hr = InitCertificateChain(pICertificate, &ChainBlob)))
        {
            DebugTrace("Error [%#x]: InitCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate and initialize a CMSG_SIGNER_ENCODE_INFO structure.
        //
        if (FAILED(hr = ::InitSignerEncodeInfo(pISigner2,
                                               pCertContext,
                                               hCryptProv,
                                               dwKeySpec,
                                               &pSignerEncodeInfo)))
        {
            DebugTrace("Error [%#x]: InitSignerEncodeInfo() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now sign the content.
        //
        if (FAILED(hr = SignContent(pSignerEncodeInfo,
                                    &ChainBlob,
                                    bDetached,
                                    EncodingType,
                                    pVal)))
        {
            DebugTrace("Error [%#x]: CSignedData::SignContent() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (pSignerEncodeInfo)
    {
        ::FreeSignerEncodeInfo(pSignerEncodeInfo);
    }
    if (ChainBlob.pbData)
    {
        ::FreeCertificateChain(&ChainBlob);
    }
    if (hCryptProv && bReleaseContext)
    {
        ::CryptReleaseContext(hCryptProv, 0);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::Sign().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::CoSign

  Synopsis : CoSign the content and produce a signed message. This method will
             behaves the same as the Sign method as a non-detached message if 
             the messge currently does not already have a signature.

  Parameter: ISigner * pSigner - Pointer to ISigner.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the signed message.

  Remark   : The certificate selection dialog will be launched 
             (CryptUIDlgSelectCertificate API) to display a list of certificates
             from the Current User\My store for selecting a signer's certificate, 
             for the following conditions:

             1) A signer is not specified (pVal is NULL) or the ICertificate
                property of the ISigner is not set
             
             2) There is more than 1 cert in the store, and
             
             3) The Settings::EnablePromptForIdentityUI property is not disabled.

             Also if called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for signing.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::CoSign (ISigner             * pISigner,
                                  CAPICOM_ENCODING_TYPE EncodingType, 
                                  BSTR                * pVal)
{
    HRESULT               hr              = S_OK;
    CComPtr<ISigner>      pISigner2       = NULL;
    CComPtr<ICertificate> pICertificate   = NULL;
    HCRYPTPROV            hCryptProv      = NULL;
    PCCERT_CONTEXT        pCertContext    = NULL;
    DWORD                 dwKeySpec       = 0;
    BOOL                  bReleaseContext = FALSE;
    DATA_BLOB             ChainBlob       = {0, NULL};
    
    CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo = NULL;

    DebugTrace("Entering CSignedData::CoSign().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        if (NULL == pVal)
        {
            hr = E_POINTER;

		    DebugTrace("Error: invalid parameter, pVal is NULL.\n");
		    goto ErrorExit;
        }

        //
        // Make sure message has been signed?
        //
        if (!m_bSigned)
        {
            hr = CAPICOM_E_SIGN_NOT_SIGNED;

		    DebugTrace("Error: cannot cosign an unsigned message.\n");
		    goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

		    DebugTrace("Error: sign object has not been initialized.\n");
		    goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);
        ATLASSERT(m_MessageBlob.cbData);
        ATLASSERT(m_MessageBlob.pbData);

        //
        // Get the signer's cert (may prompt user to select signer's cert).
        //
        if (FAILED(hr = ::GetSignerCert(pISigner, &pISigner2, &pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetSignerCert() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If we are called from a web page, we need to pop up UI 
        // to get user permission to perform signing operation.
        //
        if (m_dwCurrentSafety && 
            PromptForSigningOperationEnabled() &&
            FAILED(hr = ::UserApprovedOperation(IDD_SIGN_SECURITY_ALERT_DLG)))
        {
            DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Acquire CSP context and access to private key.
        //
        if (FAILED(hr = ::AcquireContext(pCertContext, 
                                         &hCryptProv, 
                                         &dwKeySpec, 
                                         &bReleaseContext)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Build the bag of certs (cert chain minus root) to be included 
        // into the message.
        //
        if (FAILED(hr = InitCertificateChain(pICertificate, &ChainBlob)))
        {
            DebugTrace("Error [%#x]: InitCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate and initialize a CMSG_SIGNER_ENCODE_INFO structure.
        //
        if (FAILED(hr = ::InitSignerEncodeInfo(pISigner2,
                                               pCertContext, 
                                               hCryptProv,
                                               dwKeySpec,
                                               &pSignerEncodeInfo)))
        {
            DebugTrace("Error [%#x]: InitSignerEncodeInfo() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // CoSign the content.
        //
        if (FAILED(hr = CoSignContent(pSignerEncodeInfo,
                                      &ChainBlob,
                                      EncodingType,
                                      pVal)))
        {
            DebugTrace("Error [%#x]: CSignedData::CoSignContent() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (pSignerEncodeInfo)
    {
        ::FreeSignerEncodeInfo(pSignerEncodeInfo);
    }
    if (ChainBlob.pbData)
    {
        ::FreeCertificateChain(&ChainBlob);
    }
    if (hCryptProv && bReleaseContext)
    {
        ::CryptReleaseContext(hCryptProv, 0);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::CoSign().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::Verify

  Synopsis : Verify a signed message.

  Parameter: BSTR SignedMessage - BSTR containing the signed message to be
                                  verified.

             VARIANT_BOOL bDetached - TRUE if content was detached, else
                                      FALSE.

             CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag - Verify flag.

  Remark   : Note that for non-detached message, this method will always try 
             to set the Content property using the signed message, even if the 
             signed message does not verify.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::Verify (BSTR                            SignedMessage, 
                                  VARIANT_BOOL                    bDetached,
                                  CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag)
{ 
    HRESULT    hr           = S_OK;
    HCRYPTMSG  hMsg         = NULL;
    HCERTSTORE hPKCS7Store  = NULL;
    DWORD      dwCertError  = 0;
    DWORD      dwNumSigners = 0;
    DWORD      cbSigners    = sizeof(dwNumSigners);
    DWORD      dwSigner     = 0;

    DebugTrace("Entering CSignedData::Verify().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Initialize member variables.
        //
        if (!bDetached)
        {
            if (m_ContentBlob.pbData)
            {
                ::CoTaskMemFree(m_ContentBlob.pbData);
            }

            m_ContentBlob.cbData = 0;
            m_ContentBlob.pbData = NULL;

        }
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = FALSE;
        m_bDetached = bDetached;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        //
        // Make sure parameters are valid.
        //
        if (NULL == SignedMessage)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, SignedMessage is NULL.\n");
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(SignedMessage))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, SignedMessage is empty.\n", hr);
            goto ErrorExit;
        }

        //
        // If detached, make sure content is already initialized.
        //
        if (m_bDetached)
        {
            if (0 == m_ContentBlob.cbData)
            {
                hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

                DebugTrace("Error: content was not initialized for detached decoding.\n");
                goto ErrorExit;
            }

            //
            // Sanity check.
            //
            ATLASSERT(m_ContentBlob.pbData);
        }

        //
        // Import the message.
        //
        if (FAILED(hr = ::ImportData(SignedMessage, 
                                     &m_MessageBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("ImportedSigned.asn", m_MessageBlob.pbData, m_MessageBlob.cbData);

        //
        // Open the message to decode.
        //
        if (FAILED(hr = OpenToDecode(NULL, &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Verify cert as well?
        //
        if (CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE == VerifyFlag)
        {
            //
            // Yes, so open the PKCS7 store.
            //
            if (!(hPKCS7Store = ::CertOpenStore(CERT_STORE_PROV_PKCS7,
                                                CAPICOM_ASN_ENCODING,
                                                NULL,
                                                CERT_STORE_OPEN_EXISTING_FLAG,
                                                &m_MessageBlob)))
            {
                DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get number of content signers (first level signers).
        //
        if (!::CryptMsgGetParam(hMsg, 
                                CMSG_SIGNER_COUNT_PARAM,
                                0,
                                (void **) &dwNumSigners,
                                &cbSigners))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed to get CMSG_SIGNER_COUNT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Verify all signatures.
        //
        for (dwSigner = 0; dwSigner < dwNumSigners; dwSigner++)
        {
            PCERT_CONTEXT      pCertContext   = NULL;
            CMSG_SIGNER_INFO * pSignerInfo    = NULL;
            CRYPT_DATA_BLOB    SignerInfoBlob = {0, NULL};
        
            //
            // Get signer info.
            //
            if (FAILED(hr = ::GetMsgParam(hMsg,
                                          CMSG_SIGNER_INFO_PARAM,
                                          dwSigner,
                                          (void**) &SignerInfoBlob.pbData,
                                          &SignerInfoBlob.cbData)))
            {
                DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_SIGNER_INFO_PARAM for signer #%d.\n", hr, dwSigner);
                goto ErrorExit;
            }

            pSignerInfo = (CMSG_SIGNER_INFO *) SignerInfoBlob.pbData;

            //
            // Find the cert in the message.
            //
            hr = ::FindSignerCertInMessage(hMsg,
                                           &pSignerInfo->Issuer,
                                           &pSignerInfo->SerialNumber,
                                           &pCertContext);
            //
            // First free memory.
            //
            ::CoTaskMemFree(SignerInfoBlob.pbData);

            //
            // Check result.
            //
            if (FAILED(hr))
            {
                DebugTrace("Error [%#x]: FindSignerCertInMessage() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Verify the cert regardless if the user had requested. This
            // is done so that the chain will always be built first before
            // we later verify the signature, which is required by DSS.
            //
            if (FAILED(hr = ::VerifyCertificate(hPKCS7Store, pCertContext, &dwCertError)))
            {
                //
                // Free CERT_CONTEXT.
                //
                ::CertFreeCertificateContext(pCertContext);

                DebugTrace("Error [%#x]: VerifyCertificate() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Verify cert as well?
            //
            if ((CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE == VerifyFlag) && (dwCertError))
            {
                //
                // Invalid certificate.
                //
                hr = HRESULT_FROM_WIN32(dwCertError);

                //
                // Free CERT_CONTEXT.
                //
                ::CertFreeCertificateContext(pCertContext);

                DebugTrace("Error [%#x]: invalid cert.\n", hr);
                goto ErrorExit;
            }

            //
            // Verify signature.
            //
            if (!::CryptMsgControl(hMsg,
                                   0,
                                   CMSG_CTRL_VERIFY_SIGNATURE,
                                   pCertContext->pCertInfo))
            {
                //
                // Invalid signature.
                //
                hr = HRESULT_FROM_WIN32(::GetLastError());

                //
                // Free CERT_CONTEXT.
                //
                ::CertFreeCertificateContext(pCertContext);

                DebugTrace("Error [%#x]: CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Free CERT_CONTEXT.
            //
            ::CertFreeCertificateContext(pCertContext);
        }

        //
        // Update member variables.
        //
        m_bSigned = TRUE;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resouce.
    //
    if(hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
    if (hPKCS7Store)
    {
        ::CertCloseStore(hPKCS7Store, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::Verify().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Reset member variables.
    //
    m_bSigned   = FALSE;
    m_bDetached = VARIANT_FALSE;
#if (0)
    if (m_ContentBlob.pbData)
    {
        ::CoTaskMemFree(m_ContentBlob.pbData);
    }
    m_ContentBlob.cbData = 0;
    m_ContentBlob.pbData = NULL;
#endif
    if (m_MessageBlob.pbData)
    {
        ::CoTaskMemFree(m_MessageBlob.pbData);
    }
    m_MessageBlob.cbData = 0;
    m_MessageBlob.pbData = NULL;

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSign::OpenToEncode

  Synopsis : Open a message for encoding.

  Parameter: CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to signer's
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.

             DATA_BLOB * pChainBlob                      - Pointer chain blob
                                                           of PCCERT_CONTEXT.

             HCRYPTMSG * phMsg                           - Pointer to HCRYPTMSG
                                                           to receive handle.

             CMSG_SIGNED_ENCODE_INFO * pSignedEncodeInfo - Pointer to 
                                                           CMSG_SIGNED_ENCODE_INFO
                                                           to receive initialized
                                                           structure.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::OpenToEncode(CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
                                       DATA_BLOB               * pChainBlob,
                                       HCRYPTMSG               * phMsg,
                                       CMSG_SIGNED_ENCODE_INFO * pSignedEncodeInfo)
{
    HRESULT     hr      = S_OK;
    HCRYPTMSG   hMsg    = NULL;
    DWORD       dwFlags = 0;
    CERT_BLOB * rgEncodedCertBlob = NULL;
    DWORD       i;

    DebugTrace("Entering CSignedData::OpenToEncode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);
    ATLASSERT(phMsg);
    ATLASSERT(pSignedEncodeInfo);

    //
    // If this is not a root cert, don't include its root, 
    //
    DWORD cCertContext = pChainBlob->cbData;
    PCERT_CONTEXT * rgCertContext = (PCERT_CONTEXT *) pChainBlob->pbData;

    if (1 < cCertContext)
    {
        cCertContext--;
    }

    //
    // Allocate memory for the array.
    //
    if (!(rgEncodedCertBlob = (CERT_BLOB *) ::CoTaskMemAlloc(cCertContext * sizeof(CERT_BLOB))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    ::ZeroMemory(rgEncodedCertBlob, cCertContext * sizeof(CERT_BLOB));

    //
    // Build encoded certs array.
    //
    for (i = 0; i < cCertContext; i++)
    {
        rgEncodedCertBlob[i].cbData = rgCertContext[i]->cbCertEncoded;
        rgEncodedCertBlob[i].pbData = rgCertContext[i]->pbCertEncoded;
    }

    //
    // Setup up CMSG_SIGNED_ENCODE_INFO structure.
    //
    ::ZeroMemory((void *) pSignedEncodeInfo, sizeof(CMSG_SIGNED_ENCODE_INFO));
    pSignedEncodeInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
    pSignedEncodeInfo->cSigners = 1;
    pSignedEncodeInfo->rgSigners = pSignerEncodeInfo;
    pSignedEncodeInfo->cCertEncoded = cCertContext;
    pSignedEncodeInfo->rgCertEncoded = rgEncodedCertBlob;

    //
    // Detached flag.
    //
    if (m_bDetached)
    {
        dwFlags = CMSG_DETACHED_FLAG;
    }

    //
    // Open a message to encode.
    //
    if (!(hMsg = ::CryptMsgOpenToEncode(CAPICOM_ASN_ENCODING,
                                        dwFlags,
                                        CMSG_SIGNED,
                                        pSignedEncodeInfo,
                                        NULL,
                                        NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgOpenToEncode() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Returned message handle to caller.
    //
    *phMsg = hMsg;

CommonExit:
    //
    // Free resources.
    //
    if (rgEncodedCertBlob)
    {
        ::CoTaskMemFree(rgEncodedCertBlob);
    }

    DebugTrace("Leaving CSignedData::OpenToEncode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::OpenToDecode

  Synopsis : Open a signed message for decoding.

  Parameter: HCRYPTPROV hCryptProv - CSP handle or NULL for default CSP.

             HCRYPTMSG * phMsg - Pointer to HCRYPTMSG to receive handle.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::OpenToDecode (HCRYPTPROV  hCryptProv,
                                        HCRYPTMSG * phMsg)
{
    HRESULT   hr        = S_OK;
    HCRYPTMSG hMsg      = NULL;
    DWORD     dwFlags   = 0;
    DWORD     dwMsgType = 0;
    DWORD     cbMsgType = sizeof(dwMsgType);

    DebugTrace("Entering CSignedData::OpenToDecode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phMsg);

    //
    // Detached flag.
    //
    if (m_bDetached)
    {
        dwFlags = CMSG_DETACHED_FLAG;
    }

    //
    // Open a message for decode.
    //
    if (!(hMsg = ::CryptMsgOpenToDecode(CAPICOM_ASN_ENCODING,   // ANS encoding type
                                        dwFlags,                // Flags
                                        0,                      // Message type (get from message)
                                        hCryptProv,             // Cryptographic provider
                                        NULL,                   // Inner content OID
                                        NULL)))                 // Stream information (not used)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgOpenToDecode() failed.\n");
        goto ErrorExit;
    }

    //
    // Update message with signed content.
    //
    if (!::CryptMsgUpdate(hMsg,
                          m_MessageBlob.pbData,
                          m_MessageBlob.cbData,
                          TRUE))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        
        DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n",hr);
        goto ErrorExit;
    }

    //
    // Check message type.
    //
    if (!::CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            (void *) &dwMsgType,
                            &cbMsgType))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed for CMSG_TYPE_PARAM.\n", hr);
        goto ErrorExit;
    }

    if (CMSG_SIGNED != dwMsgType)
    {
        hr = CAPICOM_E_SIGN_INVALID_TYPE;

        DebugTrace("Error: not an singed message.\n");
        goto ErrorExit;
    }

    //
    // If detached message, update content.
    //
    if (m_bDetached)
    {
        if (!::CryptMsgUpdate(hMsg,
                              m_ContentBlob.pbData,
                              m_ContentBlob.cbData,
                              TRUE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        
            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n",hr);
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Retrieve content.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_CONTENT_PARAM, 
                                      0, 
                                      (void **) &m_ContentBlob.pbData, 
                                      &m_ContentBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_CONTENT_PARAM.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Returned message handle to caller.
    //
    *phMsg = hMsg;

CommonExit:

    DebugTrace("Leaving SignedData::OpenToDecode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::SignContent

  Synopsis : Sign the content by adding the very first signature to the message.

  Parameter: CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to signer's
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.

             DATA_BLOB * pChainBlob - Pointer chain blob of PCCERT_CONTEXT.

             VARIANT_BOOL bDetached - Detached flag.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the signed message.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::SignContent (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
                                       DATA_BLOB               * pChainBlob,
                                       VARIANT_BOOL              bDetached,
                                       CAPICOM_ENCODING_TYPE     EncodingType,
                                       BSTR                    * pVal)
{
    HRESULT   hr   = S_OK;
    HCRYPTMSG hMsg = NULL;
    DATA_BLOB MessageBlob = {0, NULL};
    CMSG_SIGNED_ENCODE_INFO SignedEncodeInfo;

    DebugTrace("Entering CSignedData::SignContent().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);
    ATLASSERT(pVal);

    ATLASSERT(m_ContentBlob.cbData);
    ATLASSERT(m_ContentBlob.pbData);

    try
    {
        //
        // Initialize member variables.
        //
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }
        m_bSigned = FALSE;
        m_bDetached = bDetached;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        //
        // Open message to encode.
        //
        if (FAILED(hr = OpenToEncode(pSignerEncodeInfo,
                                     pChainBlob,
                                     &hMsg,
                                     &SignedEncodeInfo)))
        {
            DebugTrace("Error [%#x]: OpenToEncode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update the message with data.
        //
        if (!::CryptMsgUpdate(hMsg,                     // Handle to the message
                              m_ContentBlob.pbData,     // Pointer to the content
                              m_ContentBlob.cbData,     // Size of the content
                              TRUE))                    // Last call
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        
            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n",hr);
            goto ErrorExit;
        }

        //
        // Retrieve the resulting message.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_CONTENT_PARAM, 
                                      0, 
                                      (void **) &MessageBlob.pbData, 
                                      &MessageBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_CONTENT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Now export the signed message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("ExportedSigned.asn", MessageBlob.pbData, MessageBlob.cbData);

        //
        // Update member variables.
        //
        //
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = TRUE;
        m_bDetached = bDetached;
        m_MessageBlob = MessageBlob;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }
CommonExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    DebugTrace("Leaving CSignedData::SignContent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSign::CoSignContent

  Synopsis : CoSign the content by adding another signature to the message.

  Parameter: CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to signer's
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.

             DATA_BLOB * pChainBlob - Pointer chain blob of PCCERT_CONTEXT.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to pointer to SAFEARRAY to receive 
                                 the signed message.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::CoSignContent (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
                                         DATA_BLOB               * pChainBlob,
                                         CAPICOM_ENCODING_TYPE     EncodingType,
                                         BSTR                    * pVal)
{
    HRESULT   hr   = S_OK;
    HCRYPTMSG hMsg = NULL;
    DATA_BLOB MessageBlob = {0, NULL};

    DebugTrace("Entering CSignedData::CoSignContent().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);
    ATLASSERT(pVal);

    ATLASSERT(m_bSigned);
    ATLASSERT(m_ContentBlob.cbData);
    ATLASSERT(m_ContentBlob.pbData);
    ATLASSERT(m_MessageBlob.cbData);
    ATLASSERT(m_MessageBlob.pbData);

    try
    {
        //
        // Open the encoded message for decode.
        //
        if (FAILED(hr = OpenToDecode(pSignerEncodeInfo->hCryptProv, &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add the co-signature to the message.
        //
        if (!::CryptMsgControl(hMsg,
                               0,
                               CMSG_CTRL_ADD_SIGNER,
                               (const void *) pSignerEncodeInfo))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        
            DebugTrace("Error [%#x]: CryptMsgControl() failed for CMSG_CTRL_ADD_SIGNER.\n",hr);
            goto ErrorExit;
        }

        //
        // Add chain to message.
        //
        if (FAILED(hr = ::AddCertificateChain(hMsg, pChainBlob)))
        {
            DebugTrace("Error [%#x]: AddCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve the resulting message.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_ENCODED_MESSAGE, 
                                      0, 
                                      (void **) &MessageBlob.pbData, 
                                      &MessageBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_ENCODED_MESSAGE.\n",hr);
            goto ErrorExit;
        }

        //
        // Now export the signed message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("ExportedCoSigned.asn", MessageBlob.pbData, MessageBlob.cbData);

        //
        // Update member variables.
        //
        //
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = TRUE;
        m_MessageBlob = MessageBlob;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
 
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\signeddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    SignedData.h

  Content: Declaration of the CSignedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SIGNEDDATA_H_
#define __SIGNEDDATA_H_

#include "resource.h"       // main symbols
#include "Signer.h"
#include "Signers.h"
#include "Certificates.h"
#include "Error.h"
#include "Lock.h"


///////////////////////////////////////////////////////////////////////////////
//
// CSignedData
//

class ATL_NO_VTABLE CSignedData : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSignedData, &CLSID_SignedData>,
    public ICAPICOMError<CSignedData, &IID_ISignedData>,
	public IDispatchImpl<ISignedData, &IID_ISignedData, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CSignedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                          INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CSignedData()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SIGNEDDATA)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSignedData)
	COM_INTERFACE_ENTRY(ISignedData)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSignedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()


	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for SignedData object.\n", hr);
            return hr;
        }

        m_bSigned   = FALSE;
        m_bDetached = VARIANT_FALSE;
        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// ISignedData
//
public:
	STDMETHOD(Verify)
        (/*[in]*/ BSTR SignedMessage, 
         /*[in, defaultvalue(0)]*/ VARIANT_BOOL bDetached, 
         /*[in, defaultvalue(CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE)]*/ CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag);

	STDMETHOD(CoSign)
        (/*[in, defaultvalue(NULL)]*/ ISigner * pSigner,
         /*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

	STDMETHOD(Sign)
        (/*[in, defaultvalue(NULL)]*/ ISigner * pSigner,
         /*[in, defaultvalue(0)]*/ VARIANT_BOOL bDetached, 
         /*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

	STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates ** pVal);

	STDMETHOD(get_Signers)
        (/*[out, retval]*/ ISigners ** pVal);

    STDMETHOD(get_Content)
        (/*[out, retval]*/ BSTR * pVal);

	STDMETHOD(put_Content)
        (/*[in]*/ BSTR newVal);

private:
    CLock        m_Lock;
    BOOL         m_bSigned;
    VARIANT_BOOL m_bDetached;
    DATA_BLOB    m_ContentBlob;
    DATA_BLOB    m_MessageBlob;

    STDMETHOD(OpenToEncode)
        (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
         DATA_BLOB * pChainBlob,
         HCRYPTMSG * phMsg,
         CMSG_SIGNED_ENCODE_INFO * pSignedEncodeInfo);

    STDMETHOD(OpenToDecode)
        (HCRYPTPROV hCryptProv,
         HCRYPTMSG * phMsg);

    STDMETHOD(SignContent)
        (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
         DATA_BLOB * pChainBlob,
         VARIANT_BOOL bDetached,
         CAPICOM_ENCODING_TYPE EncodingType,
         BSTR * pVal);

    STDMETHOD(CoSignContent)
        (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
         DATA_BLOB * pChainBlob,
         CAPICOM_ENCODING_TYPE EncodingType,
         BSTR * pVal);
};

#endif //__SIGNEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CAPICOM.rc
//

// IDRs
#define IDS_PROJNAME                                    100
#define IDR_EKU                                         110
#define IDR_EKUS                                        111
#define IDR_KEYUSAGE                                    120
#define IDR_EXTENDED_KEY_USAGE                          130
#define IDR_BASICCONSTRAIN                              140
#define IDR_CERTIFICATESTATUS                           150
#define IDR_CERTIFICATE                                 160
#define IDR_CERTIFICATES                                170
#define IDR_SETTINGS                                    180
#define IDD_STOREDLG                                    190
#define IDR_SIGNERS                                     200
#define IDR_STORE                                       210
#define IDR_ATTRIBUTE                                   220
#define IDR_ATTRIBUTES                                  230
#define IDR_CHAIN                                       240
#define IDR_SIGNER                                      250
#define IDR_SIGNEDDATA                                  260
#define IDR_ALGORITHM                                   270
#define IDR_RECIPIENTS                                  280
#define IDR_ENVELOPEDDATA                               290
#define IDR_ENCRYPTEDDATA                               300

// IDCs
#define IDC_SEPARATORLINE                               500
#define IDC_DLG_NO_SHOW_AGAIN                           510
#define IDC_SECURITY_ALERT_BMP                          520

//IDBs
#define IDB_SECURITY_STORE_BMP                          600
#define IDB_SECURITY_SIGN_BMP                           610
#define IDB_SECURITY_DECRYPT_BMP                        620

// IDDs
#define IDD_STORE_SECURITY_ALERT_DLG                    700
#define IDD_SIGN_SECURITY_ALERT_DLG                     710
#define IDD_DECRYPT_SECURITY_ALERT_DLG                  720

// IDSs
#define IDS_CAPICOM_E_ENCODE_INVALID_TYPE               800
                
#define IDS_CAPICOM_E_EKU_INVALID_OID                   810
#define IDS_CAPICOM_E_EKU_OID_NOT_INITIALIZED           811

#define IDS_CAPICOM_E_CERTIFICATE_NOT_INITIALIZED       820
#define IDS_CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY        821

#define IDS_CAPICOM_E_CHAIN_NOT_BUILT                   830

#define IDS_CAPICOM_E_STORE_NOT_OPENED                  840
#define IDS_CAPICOM_E_STORE_EMPTY                       841
#define IDS_CAPICOM_E_STORE_INVALID_OPEN_MODE           842
#define IDS_CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE        843

#define IDS_CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED    850
#define IDS_CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED   851
#define IDS_CAPICOM_E_ATTRIBUTE_INVALID_NAME            852
#define IDS_CAPICOM_E_ATTRIBUTE_INVALID_VALUE           853
    
#define IDS_CAPICOM_E_SIGNER_NOT_INITIALIZED            860
#define IDS_CAPICOM_E_SIGNER_NOT_FOUND                  861

#define IDS_CAPICOM_E_SIGN_NOT_INITIALIZED              870
#define IDS_CAPICOM_E_SIGN_INVALID_TYPE                 871
#define IDS_CAPICOM_E_SIGN_NOT_SIGNED                   872

#define IDS_CAPICOM_E_INVALID_ALGORITHM                 880
#define IDS_CAPICOM_E_INVALID_KEY_LENGTH                881

#define IDS_CAPICOM_E_ENVELOP_NOT_INITIALIZED           890
#define IDS_CAPICOM_E_ENVELOP_INVALID_TYPE              891
#define IDS_CAPICOM_E_ENVELOP_NO_RECIPIENT              892
#define IDS_CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND       893

#define IDS_CAPICOM_E_ENCRYPT_NOT_INITIALIZED           900
#define IDS_CAPICOM_E_ENCRYPT_INVALID_TYPE              901
#define IDS_CAPICOM_E_ENCRYPT_NO_SECRET                 902

#define IDS_CAPICOM_E_NOT_SUPPORTED	                    990
#define IDS_CAPICOM_E_UI_DISABLED                       991
#define IDS_CAPICOM_E_CANCELLED                         992
#define IDS_CAPICOM_E_INTERNAL                          993
#define IDS_CAPICOM_E_UNKNOWN		                    994

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1000
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         2000
#define _APS_NEXT_SYMED_VALUE           3000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\settings.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      Settings.cpp

  Contents:  Implementation of CSettings class.

  Remarks:

  History:   11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Settings.h"


///////////////
//
// Global
//

VARIANT_BOOL g_bPromptCertificateUI      = VARIANT_TRUE;
BOOL         g_bPromptStoreAddRemoveUI   = TRUE;
BOOL         g_bPromptSigningOperationUI = TRUE;
BOOL         g_bPromptDecryptOperationUI = TRUE;

CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION g_ADSearchLocation = CAPICOM_SEARCH_ANY;


////////////////////////////////////////////////////////////////////////////////
//
// Globl functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnableSecurityAlertDialog

  Synopsis : Enable/disable security alert dialog box.

  Parameter: DWORD iddDialog - The dialog to enable/disable.

             BOOL bEnabled - TRUE to enable, else FALSE.

  Remark   :
  
------------------------------------------------------------------------------*/

HRESULT EnableSecurityAlertDialog (DWORD iddDialog, BOOL bEnabled)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering EnableSecurityAlertDialog().\n");

    //
    // Which dialog?
    //
    switch (iddDialog)
    {
        case IDD_STORE_SECURITY_ALERT_DLG:
        {
            g_bPromptStoreAddRemoveUI = bEnabled;
            break;
        }
    
        case IDD_SIGN_SECURITY_ALERT_DLG:
        {
            g_bPromptSigningOperationUI = bEnabled;
            break;
        }

        case IDD_DECRYPT_SECURITY_ALERT_DLG:
        {
            g_bPromptDecryptOperationUI = bEnabled;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error: unknown dialog ID %#x.\n", iddDialog);
            break;
        }
    }

    DebugTrace("Leaving EnableSecurityAlertDialog().\n");
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CSettings
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::get_EnablePromptForCertificateUI

  Synopsis : Get current EnablePromptForCertificateUI setting.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::get_EnablePromptForCertificateUI (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::get_EnablePromptForCertificateUI().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return it.
        //
        *pVal = g_bPromptCertificateUI;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::get_EnablePromptForCertificateUI().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::put_EnablePromptForCertificateUI

  Synopsis : Set EnablePromptForCertificateUI setting.

  Parameter: VARIANT_BOOL newVal - VARIANT_TRUE to enable UI or VARAINT_FALSE
                                   to disable.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::put_EnablePromptForCertificateUI (VARIANT_BOOL newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::put_EnablePromptForCertificateUI().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Set it.
    //
    g_bPromptCertificateUI = newVal;

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::put_EnablePromptForCertificateUI().\n");

	return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::get_ActiveDirectorySearchLocation

  Synopsis : Get current ActiveDirectorySearchLocation setting.

  Parameter: CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION * pVal - Pointer to variable
                                                               to receive result.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::get_ActiveDirectorySearchLocation (
        CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::get_ActiveDirectorySearchLocation().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Return it.
        //
        *pVal = g_ADSearchLocation;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::get_ActiveDirectorySearchLocation().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::put_ActiveDirectorySearchLocation

  Synopsis : Set ActiveDirectorySearchLocation setting.

  Parameter: CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal - AD search location.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::put_ActiveDirectorySearchLocation (
        CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::put_ActiveDirectorySearchLocation().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure parameter is valid.
    //
    switch (newVal)
    {
        case CAPICOM_SEARCH_ANY:

        case CAPICOM_SEARCH_GLOBAL_CATALOG:

        case CAPICOM_SEARCH_DEFAULT_DOMAIN:
        {
            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, unknown search location.\n");
            goto ErrorExit;
        }
    }

    //
    // Set it.
    //
    g_ADSearchLocation = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::put_ActiveDirectorySearchLocation().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\settings.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Settings.h

  Content: Declaration of CSettings class.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SETTINGS_H_
#define __SETTINGS_H_

#include <atlctl.h>
#include "resource.h"       // main symbols
#include "Error.h"
#include "Lock.h"

///////////////
//
// Global
//

#define PromptForCertificateEnabled()           (g_bPromptCertificateUI)
#define PromptForStoreAddRemoveEnabled()        (g_bPromptStoreAddRemoveUI)
#define PromptForSigningOperationEnabled()      (g_bPromptSigningOperationUI)
#define PromptForDecryptOperationEnabled()      (g_bPromptDecryptOperationUI)
#define ActiveDirectorySearchLocation()         (g_ADSearchLocation)

extern VARIANT_BOOL                             g_bPromptCertificateUI;
extern BOOL                                     g_bPromptStoreAddRemoveUI;
extern BOOL                                     g_bPromptSigningOperationUI;
extern BOOL                                     g_bPromptDecryptOperationUI;
extern CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION g_ADSearchLocation;


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnableSecurityAlertDialog

  Synopsis : Enable/disable security alert dialog box.

  Parameter: DWORD iddDialog - The dialog to enable/disable.

             BOOL bEnabled - TRUE to enable, else FALSE.

  Remark   :
  
------------------------------------------------------------------------------*/

HRESULT EnableSecurityAlertDialog (DWORD iddDialog, 
                                   BOOL  bEnabled);


////////////////////////////////////////////////////////////////////////////////
//
// CSettings
//

class ATL_NO_VTABLE CSettings : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSettings, &CLSID_Settings>,
    public ICAPICOMError<CSettings, &IID_ISettings>,
	public IDispatchImpl<ISettings, &IID_ISettings, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CSettings, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                        INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CSettings()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SETTINGS)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSettings)
	COM_INTERFACE_ENTRY(ISettings)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSettings)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Settings object.\n", hr);
            return hr;
        }

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// ISettings
//
public:
	STDMETHOD(get_EnablePromptForCertificateUI)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

	STDMETHOD(put_EnablePromptForCertificateUI)
        (/*[in, defaultvalue(0)]*/ VARIANT_BOOL newVal);

    STDMETHOD(get_ActiveDirectorySearchLocation)
        (/*[out, retval]*/ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION * pVal);

	STDMETHOD(put_ActiveDirectorySearchLocation)
        (/*[in, defaultvalue(SEARCH_LOCATION_UNSPECIFIED)]*/ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION Val);

private:
    CLock m_Lock;
};

#endif //__SETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\signer.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signer.cpp

  Content: Implementation of CSigner.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Attributes.h"
#include "Signer.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignerObject

  Synopsis : Create a ISigner object and initialize the object with the 
             specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

             ISigner ** ppISigner - Pointer to pointer to ISigner object to
                                    receive the interface pointer.         
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignerObject (PCCERT_CONTEXT     pCertContext,
                            CRYPT_ATTRIBUTES * pAuthAttrs,
                            ISigner         ** ppISigner)
{
    HRESULT hr = S_OK;
    CComObject<CSigner> * pCSigner = NULL;

    DebugTrace("Entering CreateSignerObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pAuthAttrs);
    ATLASSERT(ppISigner);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CSigner>::CreateInstance(&pCSigner)))
        {
            DebugTrace("Error [%#x]: CComObject<CSigner>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCSigner->Init(pCertContext, pAuthAttrs)))
        {
            DebugTrace("Error [%#x]: pCSigner->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCSigner->QueryInterface(ppISigner)))
        {
            DebugTrace("Error [%#x]: pCSigner->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateSignerObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCSigner)
    {
        delete pCSigner;
    }

    goto CommonExit;
}


///////////////////////////////////////////////////////////////////////////////
//
// CSigner
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_Certificate

  Synopsis : Return the signer's cert as an ICertificate object.

  Parameter: ICertificate ** pVal - Pointer to pointer to ICertificate to receive
                                    interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_Certificate (ICertificate ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::get_Certificate().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure we indeed have a certificate.
        //
        if (!m_pICertificate)
        {
            hr = CAPICOM_E_SIGNER_NOT_INITIALIZED;

            DebugTrace("Error: signer object currently does not have a certificate.\n");
            goto ErrorExit;
        }

        //
        // Return interface pointer.
        //
        if (FAILED(hr = m_pICertificate->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pICertificate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_Certificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::put_Certificate

  Synopsis : Set signer's cert.

  Parameter: ICertificate * newVal - Pointer to ICertificate.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::put_Certificate (ICertificate * newVal)
{
    HRESULT hr = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CSigner::put_Certificate().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure is a valid ICertificate by getting its CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(newVal, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // Free the CERT_CONTEXT.
        //
        if (!::CertFreeCertificateContext(pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Clear all attributes.
        //
        if (FAILED(hr = m_pIAttributes->Clear()))
        {
            DebugTrace("Error [%#x]: m_pIAttributes->Clear() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Store new ICertificate.
        //
        m_pICertificate = newVal;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_Certificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_AuthenticatedAttributes

  Synopsis : Property to return the IAttributes collection object authenticated
             attributes.

  Parameter: IAttributes ** pVal - Pointer to pointer to IAttributes to receive
                                   the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_AuthenticatedAttributes (IAttributes ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::get_AuthenticatedAttributes().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Sanity check.
        //
        ATLASSERT(m_pIAttributes);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIAttributes->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIAttributes->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_AuthenticatedAttributes().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::Init

  Synopsis : Initialize the object.

  Parameter: PCERT_CONTEXT pCertContext - Poiner to CERT_CONTEXT used to 
                                          initialize this object, or NULL.

             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::Init (PCCERT_CONTEXT     pCertContext, 
                            CRYPT_ATTRIBUTES * pAuthAttrs)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pAuthAttrs);

    //
    // Reset.
    //
    m_pICertificate.Release();
    m_pIAttributes.Release();

    //
    // Create the embeded ICertificate object.
    //
    if (FAILED(hr = ::CreateCertificateObject(pCertContext, &m_pICertificate)))
    {
        DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Create the embeded IAttributes collection object.
    //
    if (FAILED(hr = ::CreateAttributesObject(pAuthAttrs, &m_pIAttributes)))
    {
        DebugTrace("Error [%#x]: CreateAttributesObject() failed.\n", hr);
        goto CommonExit;
    }

CommonExit:

    DebugTrace("Leaving CSigner::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\signer.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signer.h

  Content: Declaration of the CSigner.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
	
#ifndef __SIGNER_H_
#define __SIGNER_H_

#include "resource.h"       // main symbols
#include "Certificate.h"
#include "Attributes.h"
#include "Lock.h"
#include "Error.h"

#include <wincrypt.h>

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignerObject

  Synopsis : Create a ISigner object and initialize the object with the 
             specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

             ISigner ** ppISigner - Pointer to pointer to ISigner object to
                                    receive the interface pointer.         
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignerObject (PCCERT_CONTEXT     pCertContext,
                            CRYPT_ATTRIBUTES * pAuthAttrs,
                            ISigner **         ppISigner);


///////////////////////////////////////////////////////////////////////////////
//
// CSigner
//

class ATL_NO_VTABLE CSigner : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSigner, &CLSID_Signer>,
    public ICAPICOMError<CSigner, &IID_ISigner>,
	public IDispatchImpl<ISigner, &IID_ISigner, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CSigner, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                      INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CSigner()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SIGNER)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSigner)
	COM_INTERFACE_ENTRY(ISigner)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSigner)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;
        CRYPT_ATTRIBUTES attributes = {0, NULL};

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Signer object.\n", hr);
            return hr;
        }

        //
        // Create the embeded IAttributes collection object.
        //
        if (FAILED(hr = ::CreateAttributesObject(&attributes, &m_pIAttributes)))
        {
            DebugTrace("Internal error [%#x]: CreateAttributesObject() failed inside CSigner::FinalConstruct().\n", hr);
            return hr;
        }

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        m_pICertificate.Release();
        m_pIAttributes.Release();

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
//
// ISigner
//
public:
	STDMETHOD(get_AuthenticatedAttributes)
        (/*[out, retval]*/ IAttributes ** pVal);

	STDMETHOD(get_Certificate)
        (/*[out, retval]*/ ICertificate ** pVal);

	STDMETHOD(put_Certificate)
        (/*[in]*/ ICertificate * newVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT     pCertContext, 
         CRYPT_ATTRIBUTES * pAttributes);

private:
    CLock                  m_Lock;
    CComPtr<ICertificate>  m_pICertificate;
    CComPtr<IAttributes>   m_pIAttributes;
};

#endif //__SIGNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\signers.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signers.cpp

  Content: Implementation of CSigners.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Signers.h"
#include "Common.h"


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignersObject

  Synopsis : Create an ISigners collection object, and load the object with 
             signers from the specified signed message for a specified level.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DWORD dwLevel - Signature level (1 based).

             ISigners ** ppISigners - Pointer to pointer ISigners to receive
                                      interface pointer.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignersObject (HCRYPTMSG   hMsg, 
                             DWORD       dwLevel, 
                             ISigners ** ppISigners)
{
    HRESULT hr = S_OK;
    CComObject<CSigners> * pCSigners = NULL;

    DebugTrace("Entering CreateSignersObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);
    ATLASSERT(dwLevel);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CSigners>::CreateInstance(&pCSigners)))
        {
            DebugTrace("Error [%#x]: CComObject<CSigners>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now load all signers from the specified signed message.
        //
        if (FAILED(hr = pCSigners->LoadSigners(hMsg, dwLevel)))
        {
            DebugTrace("Error [%#x]: pCSigners->LoadSigners() failed.\n");
            goto ErrorExit;
        }

        //
        // Return ISigners pointer to caller.
        //
        if (FAILED(hr = pCSigners->QueryInterface(ppISigners)))
        {
            DebugTrace("Error [%#x]: pCSigners->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateSignersObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCSigners)
    {
       delete pCSigners;
    }

    goto CommonExit;
}


/////////////////////////////////////////////////////////////////////////////
//
// CSigners
//


////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigners::Add

  Synopsis : Add a signer to the collection.

  Parameter: PCERT_CONTEXT pCertContext - Cert of signer.
             CMSG_SIGNER_INFO * pSignerInfo - SignerInfo of signer.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CSigners::Add (PCERT_CONTEXT      pCertContext,
                            CMSG_SIGNER_INFO * pSignerInfo)
{
    HRESULT  hr = S_OK;
    CComPtr<ISigner> pISigner = NULL;

    DebugTrace("Entering CSigners::Add().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != pCertContext);
    ATLASSERT(NULL != pSignerInfo);

    try
    {
        char     szIndex[32];
        CComBSTR bstrIndex;

        //
        // Create an ISigner object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = ::CreateSignerObject(pCertContext, 
                                             &pSignerInfo->AuthAttrs, 
                                             &pISigner)))
        {
            DebugTrace("Error [%#x]: CreateSignerObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfA(szIndex, "%06u", m_coll.size() + 1);
        bstrIndex = szIndex;

        DebugTrace("Before adding to map: CSigners.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);

        //
        // Now add signer to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pISigner;

        DebugTrace("After adding to map: CSigners.m_coll.size() = %d, and szIndex = %s.\n", m_coll.size(), szIndex);
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CSigners::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigners::LoadSigners

  Synopsis : Load all signers from a specified signed message.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DWORD dwLevel - Signature level (1-based).

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSigners::LoadSigners (HCRYPTMSG hMsg, 
                                    DWORD     dwLevel)
{
    HRESULT hr           = S_OK;
    DWORD   dwNumSigners = 0;
    DWORD   cbSigners    = sizeof(dwNumSigners);
    DWORD   dwSigner;

    DebugTrace("Entering CSigners::LoadSigners().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);
    ATLASSERT(dwLevel);

    //
    // Are we getting content signers?
    //
    if (1 == dwLevel)
    {
        //
        // Get number of content signers (first level signers).
        //
        if (!::CryptMsgGetParam(hMsg, 
                                CMSG_SIGNER_COUNT_PARAM,
                                0,
                                (void **) &dwNumSigners,
                                &cbSigners))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed to get CMSG_SIGNER_COUNT_PARAM.\n", hr);
            goto CommonExit;
        }

        //
        // Go through each content signer.
        //
        for (dwSigner = 0; dwSigner < dwNumSigners; dwSigner++)
        {
            PCERT_CONTEXT      pCertContext   = NULL;
            CMSG_SIGNER_INFO * pSignerInfo    = NULL;
            CRYPT_DATA_BLOB    SignerInfoBlob = {0, NULL};
        
            //
            // Get signer info.
            //
            if (FAILED(hr = ::GetMsgParam(hMsg,
                                          CMSG_SIGNER_INFO_PARAM,
                                          dwSigner,
                                          (void**) &SignerInfoBlob.pbData,
                                          &SignerInfoBlob.cbData)))
            {
                DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_SIGNER_INFO_PARAM for signer #%d.\n", hr, dwSigner);
                goto CommonExit;
            }

            pSignerInfo = (CMSG_SIGNER_INFO *) SignerInfoBlob.pbData;

            //
            // Find the cert in the message.
            //
            if (FAILED(hr = ::FindSignerCertInMessage(hMsg,
                                                      &pSignerInfo->Issuer,
                                                      &pSignerInfo->SerialNumber,
                                                      &pCertContext)))
            {
                DebugTrace("Error [%#x]: FindSignerCertInMessage() failed.\n", hr);

                ::CoTaskMemFree(SignerInfoBlob.pbData);
                goto CommonExit;
            }

            //
            // Add the signer.
            //
            hr = Add((PCERT_CONTEXT) pCertContext, pSignerInfo);

            ::CertFreeCertificateContext(pCertContext);
            ::CoTaskMemFree(SignerInfoBlob.pbData);

            if (FAILED(hr))
            {
                DebugTrace("Error [%#x]: CSigners::Add() failed.\n", hr);
                goto CommonExit;
            }
        }
    }
    else
    {
#if (1) // DSIE: For version 1, we still do not support counter signature.

        //
        // For version 1, should never reach here.
        //
        hr = CAPICOM_E_INTERNAL;
        goto CommonExit;
#else
        //
        // WARNING: Code within this #else branch is incomplete.
        //

        //
        // For counter-signature level, we need to traverse
        // the chain until the desired level. Note that we only
        // have to traverse one branch of the tree, since all
        // branches are identical except the root (level = 1).
        //
        CRYPT_DATA_BLOB SignerInfoBlob = {0, NULL};
        CMSG_SIGNER_INFO * pSignerInfo = NULL;
        PCERT_CONTEXT pCertContext = NULL;
 
        //
        // Get signer info.
        //
        hr = ::GetMsgParam(hMsg,
                           CMSG_SIGNER_INFO_PARAM,
                           0,
                           (void**) &SignerInfoBlob.pbData,
                           &SignerInfoBlob.cbData);
        if (FAILED(hr))
        {
            DebugTrace("Unable to retrieve SignerInfo for first level signer [0x%x]: GetMsgParam() failed.\n", hr);
            goto CommonExit;
        }

        pSignerInfo = (CMSG_SIGNER_INFO *) SignerInfoBlob.pbData;

        //
        // Find the desired level.
        //
        for (DWORD i = 2; i < dwLevel; i++)
        {
            for (DWORD dwAttribute = 0; dwAttribute < pSignerInfo->UnauthAttrs.cAttr; dwAttribute++)
            {
                //
                // Is this a counter-signature attribute?
                //
                if (0 == ::lstrcmpA(szOID_RSA_counterSign, pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].pszObjId))
                {
                    CRYPT_DATA_BLOB NextSignerInfoBlob = {0, NULL};

                    //
                    // Decode next level signer info.
                    //
                    hr = ::DecodeObject((LPSTR) PKCS7_SIGNER_INFO, 
                                        pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].rgValue->pbData,
                                        pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].rgValue->cbData,
                                        &NextSignerInfoBlob);

                    ::CoTaskMemFree(pSignerInfo);
        
                    if (FAILED(hr))
                    {
                        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                        goto CommonExit;
                    }

                    pSignerInfo = (CMSG_SIGNER_INFO *) NextSignerInfoBlob.pbData;
                    break;
                }
            }
        }

        for (DWORD dwAttribute = 0; dwAttribute < pSignerInfo->UnauthAttrs.cAttr; dwAttribute++)
        {
            //
            // Is this a counter-signature attribute?
            //
            if (0 == ::lstrcmpA(szOID_RSA_counterSign, pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].pszObjId))
            {
                for (DWORD dwValue = 0; dwValue < pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].cValue; dwValue++)
                {
                    CRYPT_DATA_BLOB NextSignerInfoBlob = {0, NULL};
                    CMSG_SIGNER_INFO * pNextSignerInfo = NULL;

                    //
                    // Decode next level signer info.
                    //
                    hr = ::DecodeObject((LPSTR) PKCS7_SIGNER_INFO, 
                                        pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].rgValue[dwValue].pbData,
                                        pSignerInfo->UnauthAttrs.rgAttr[dwAttribute].rgValue[dwValue].cbData,
                                        &NextSignerInfoBlob);
        
                    if (FAILED(hr))
                    {
                        ::CoTaskMemFree(pSignerInfo);

                        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                        break;
                    }

                    pNextSignerInfo = (CMSG_SIGNER_INFO *) NextSignerInfoBlob.pbData;

                    //
                    // Find the cert in the message.
                    //
                    hr = ::FindSignerCertInMessage(hMsg,
                                                   &pNextSignerInfo->Issuer,
                                                   &pNextSignerInfo->SerialNumber,
                                                   &pCertContext);
                    if (FAILED(hr))
                    {
                        ::CoTaskMemFree(pNextSignerInfo);

                        DebugTrace("Error [%#x]: FindSignerCertInMessage() failed.\n", hr);
                        break;
                    }

                    //
                    // Add the signer.
                    //
                    hr = Add((PCERT_CONTEXT) pCertContext, pNextSignerInfo);

                    ::CoTaskMemFree(pNextSignerInfo);
                    ::CertFreeCertificateContext(pCertContext);

                    if (FAILED(hr))
                    {
                        DebugTrace("Error [%#x]: CSigners::Add() failed.\n", hr);
                        break;
                    }
                }

                if (FAILED(hr))
                {
                    ::CoTaskMemFree(pSignerInfo);
                    goto CommonExit;
                }
            }
        }

        ::CoTaskMemFree(pSignerInfo);

        //
        //
        //
        if (0 == m_coll.size())
        {
            hr = E_UNEXPECTED;

            DebugTrace("Unexpected error: no signer was found for level %d.\n", dwLevel);
        }
#endif
    }

CommonExit:
    //
    // Remove all items from map, if error.
    //
    if (FAILED(hr))
    {
       m_coll.clear();
    }

    DebugTrace("Leaving CSigners::LoadSigners().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\signers.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signers.h

  Content: Declaration of CSigners.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SIGNERS_H_
#define __SIGNERS_H_

#include "resource.h"       // main symbols
#include "Signer.h"
#include "CopyItem.h"


////////////////////
//
// Locals
//

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<ISigner> > SignerMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<ISigner>, SignerMap> SignerEnum;
typedef ICollectionOnSTLImpl<ISigners, SignerMap, VARIANT, _CopyMapItem<ISigner>, SignerEnum> ISignersCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignersObject

  Synopsis : Create an ISigners collection object, and load the object with 
             signers from the specified signed message for a specified level.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DWORD dwLevel - Signature level (1 based).

             ISigners ** ppISigners - Pointer to pointer ISigners to receive
                                      interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignersObject (HCRYPTMSG   hMsg, 
                             DWORD       dwLevel, 
                             ISigners ** ppISigners);


////////////////////////////////////////////////////////////////////////////////
//
// CSigners
//

class ATL_NO_VTABLE CSigners : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSigners, &CLSID_Signers>,
	public IDispatchImpl<ISignersCollection, &IID_ISigners, &LIBID_CAPICOM>
{
public:
	CSigners()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSigners)
	COM_INTERFACE_ENTRY(ISigners)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSigners)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// ISigners
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Add)
        (PCERT_CONTEXT      pCertContext, 
         CMSG_SIGNER_INFO * pSignerInfo);

    STDMETHOD(LoadSigners)
        (HCRYPTMSG hMsg, 
         DWORD     dwLevel);
};

#endif //__SIGNERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\stdafx.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    stdafx.h

  Content: Include file, generated by ATL, for standard system include files,
           or project specific include files that are used frequently,
           but are changed infrequently

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#if !defined(AFX_STDAFX_H__DC6F3774_66B7_4578_91AD_7950EF7CAF8A__INCLUDED_)
#define AFX_STDAFX_H__DC6F3774_66B7_4578_91AD_7950EF7CAF8A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//
// Global defines.
//
#define CAPICOM_VERSION_MAJOR           ((DWORD) 1)
#define CAPICOM_VERSION_MINOR           ((DWORD) 0)
#define CAPICOM_VERSION                 ((DWORD) ((CAPICOM_VERSION_MAJOR << 16) | CAPICOM_VERSION_MINOR))

#define CAPICOM_ASN_ENCODING            (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)

#define szOID_CAPICOM                       "1.3.6.1.4.1.311.88"     // Reserved for CAPICOM.
#define szOID_CAPICOM_VERSION               "1.3.6.1.4.1.311.88.1"   // CAPICOM version
#define szOID_CAPICOM_ATTRIBUTE             "1.3.6.1.4.1.311.88.2"   // CAPICOM attribute
#define szOID_CAPICOM_DOCUMENT_NAME         "1.3.6.1.4.1.311.88.2.1" // Document type attribute
#define szOID_CAPICOM_DOCUMENT_DESCRIPTION  "1.3.6.1.4.1.311.88.2.2" // Document description attribute
#define szOID_CAPICOM_ENCRYPTED_DATA        "1.3.6.1.4.1.311.88.3"   // CAPICOM encrypted data message.
#define szOID_CAPICOM_ENCRYPTED_CONTENT     "1.3.6.1.4.1.311.88.3.1" // CAPICOM content of encrypted data.

#define ARRAYSIZE(x)                    (sizeof(x) / sizeof(x[0]))

//
// Global includes.
//
#include "Debug.h"
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DC6F3774_66B7_4578_91AD_7950EF7CAF8A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\store.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Store.cpp

  Content: Implementation of CStore.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "stdafx.h"
#include "CAPICOM.h"
#include "Store.h"
#include "Convert.h"
#include "Settings.h"
#include "DialogUI.h"
#include "ADHelpers.h"


////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

#if (0)
static BYTE Hex2Byte(BYTE hex)
{
    if ('0' <= hex && hex <= '9')
    {
        return (hex - '0');
    }
    else
    {
        hex = toupper(hex);

        if ('A' <= hex && hex <= 'F')
        {
            return (hex - 'A' + 10);
        }
    }

    return 0;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Hex2IntegerBlob

  Synopsis : Convert a hex string to CRYPT_INTEGER_BLOB.

  Parameter: BSTR bstrHex - Hex string to convert.
  
             CRYPT_INTEGER_BLOB * pBlob - To receive the blob.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT Hex2IntegerBlob (BSTR                 bstrHex, 
                                CRYPT_INTEGER_BLOB * pBlob)
{
    LPSTR lpszHex = NULL;

    //
    // For OLE2A macro.
    //
    USES_CONVERSION;

    //
    // Sanity check.
    //
    ATLASSERT(bstrHex);
    ATLASSERT(pBlob);

     //
    // Conver to LPSTR (string is allocated off the stack by OLE2A
    // so no need to explicit free these strings, as they will be poped
    // when this function exits.
    //
    if (!(lpszHex = OLE2A(bstrHex)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    //
    // Determine length (Need 1 byte for every 2 hex digits).
    //
    if (0 == (pBlob->cbData = (::lstrlen(lpszHex) + 1) >> 1))
    {
        pBlob->pbData = NULL;

        DebugTrace("Warning: empty serial number.\n");
        return S_OK;
    }

    //
    // Allocate memory.
    //
    if(!(pBlob->pbData = (PBYTE) ::CoTaskMemAlloc(pBlob->cbData)))
    {
        pBlob->cbData = 0;

        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    //
    // Now convert it to integer blob (Remember data must be stored in little-endian).
    //
    for (LPBYTE pbBlob = (LPBYTE) pBlob->pbData + pBlob->cbData - 1; *lpszHex; pbBlob--)
    {
        //
        // Convert upper nibble.
        //
        *pbBlob = ::Hex2Byte(*lpszHex++) << 4;

        if (*lpszHex)
        {
            //
            // Conver lower nibble.
            //
            *pbBlob |= ::Hex2Byte(*lpszHex++);
        }
    }

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Name2NameBlob

  Synopsis : Convert a name string to CERT_NAME_BLOB.

  Parameter: BSTR bstrName - Name string to convert.
  
             CERT_NAME_BLOB * pBlob - To receive the blob.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT Name2NameBlob (BSTR             bstrName, 
                              CERT_NAME_BLOB * pBlob)
{
    HRESULT hr = S_OK;
    LPSTR lpszName = NULL;

    //
    // For OLE2A macro.
    //
    USES_CONVERSION;

    //
    // Sanity check.
    //
    ATLASSERT(bstrName);
    ATLASSERT(pBlob);

     //
    // Conver to LPSTR (string is allocated off the stack by OLE2A
    // so no need to explicit free these strings, as they will be poped
    // when this function exits.
    //
    if (!(lpszName = OLE2A(bstrName)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    //
    // Determine lenght of name blob.
    //
    if (!::CertStrToName(CAPICOM_ASN_ENCODING,
                         lpszName,
                         CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                         NULL,
                         NULL,
                         &pBlob->cbData,
                         NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertStrToName() failed.\n", hr);
        return hr;
    }

    //
    // Allocate memory.
    //
    if (!(pBlob->pbData = (PBYTE) ::CoTaskMemAlloc(pBlob->cbData)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    //
    // Convert name string to name blob.
    //
    if (!::CertStrToName(CAPICOM_ASN_ENCODING,
                         lpszName,
                         CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                         NULL,
                         pBlob->pbData,
                         &pBlob->cbData,
                         NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        ::CoTaskMemFree(pBlob->pbData);

        pBlob->cbData = 0;
        pBlob->pbData = NULL;

        DebugTrace("Error [%#x]: CertStrToName() failed.\n", hr);
    }

    return hr;
}
#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindCertInStore

  Synopsis : Find the specified certificate in the specified store by SHA1 
             match.

  Parameter: HCERTSTORE hStore - Store handle of store to search.

             PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert
                                           to be located.
  
             PCCERT_CONTEXT * ppCertContext - Pointer to pointer to CERT_CONTEXT
                                              to receiev the found cert or NULL
                                              if the cert is not found.                                 

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT FindCertInStore (HCERTSTORE       hStore,
                                PCCERT_CONTEXT   pCertContext, 
                                PCCERT_CONTEXT * ppCertContext)
{
    HRESULT hr = S_OK;
    CRYPT_HASH_BLOB HashBlob = {0, NULL};

    DebugTrace("Entering FindCertInStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hStore);
    ATLASSERT(pCertContext);
    ATLASSERT(ppCertContext);

    //
    // Determine hash buffer size.
    //
    if (!::CryptHashCertificate(NULL,
                                CALG_SHA1,
                                0,
                                pCertContext->pbCertEncoded,
                                pCertContext->cbCertEncoded,
                                NULL,
                                &HashBlob.cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptHashCertificate() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory.
    //
    if (!(HashBlob.pbData = (BYTE *) ::CoTaskMemAlloc(HashBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Create the hash.
    //
    if (!::CryptHashCertificate(NULL,
                                CALG_SHA1,
                                0,
                                pCertContext->pbCertEncoded,
                                pCertContext->cbCertEncoded,
                                HashBlob.pbData,
                                &HashBlob.cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptHashCertificate() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now find the cert.
    //
    if (!(*ppCertContext = ::CertFindCertificateInStore(hStore,              
                                                        CAPICOM_ASN_ENCODING,
                                                        0,
                                                        CERT_FIND_HASH,                  
                                                        &HashBlob,
                                                        NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertFindCertificateInStore() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (HashBlob.pbData)
    {
        ::CoTaskMemFree(HashBlob.pbData);
    }

    DebugTrace("Leaving FindCertInStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CStore
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::get_Certificates

  Synopsis : Get the ICertificates collection object.

  Parameter: ICertificates ** ppCertificates - Pointer to pointer to 
                                               ICertificates to receive the
                                               interface pointer.

  Remark   : This is the default property which returns an ICertificates 
             collection object, which can then be accessed using standard COM 
             collection interface.

             The collection is not ordered, and can be accessed using a 1-based
             numeric index.

             Note that the collection is a snapshot of all current certificates
             in the store. In other words, the collection will not be affected
             by Add/Remove operations after the collection is obtained.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::get_Certificates (ICertificates ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CStore::get_Certificates().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
#if (1) 
        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit; 
        }

        //
        // Create the ICertificates collection object.
        //
        if (FAILED(hr = ::CreateCertificatesObject(CAPICOM_CERTIFICATES_LOAD_FROM_STORE,
                                                   (LPARAM) m_hCertStore,
                                                   pVal)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }
#else
        if (!m_pICertificates)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit; 
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pICertificates->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pICertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
#endif
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::get_Certificates().\n");

	return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Open

  Synopsis : Open a certificate store for read/write. Note that for MEMORY_STORE
             and ACTIVE_DIRECTORY_USER_STORE, the write operation does not
             persist the certificate.

  Parameter: CAPICOM_STORE_LOCATION StoreLocation - Store location.

             BSTR StoreName - Store name or NULL.

                    For:

                    MEMORY_STORE                - This argument is ignored.

                    LOCAL_MACHINE_STORE         - System store name or NULL.
                    
                                                  If not NULL, then it can be:
                                        
                                                  MY_STORE    = "My"
                                                  CA_STORE    = "Ca"
                                                  ROOT_STORE  = "Root"
                                                  OTHER_STORE = "AddressBook"

                                                  If NULL, then MY_STORE is 
                                                  used.

                    CURRENT_USER_STORE          - See explaination for
                                                  LOCAL_MACHINE_STORE.

                    ACTIVE_DIRECTORY_USER_STORE - LDAP filter for user container 
                                                  or NULL,.
                    
                                                  If NULL, then all users in the 
                                                  default domain will be 
                                                  included, so this can be very 
                                                  slow. 
                                                  
                                                  If not NULL, then it should 
                                                  resolve to group of 0 or more
                                                  users.
                                                  
                                                  For example,

                                                  "cn=Daniel Sie"
                                                  "cn=Daniel *"
                                                  "sn=Sie"
                                                  "mailNickname=dsie"
                                                  "userPrincipalName=dsie@ntdev.microsoft.com"
                                                  "distinguishedName=CN=Daniel Sie,OU=Users,OU=ITG,DC=ntdev,DC=microsoft,DC=com"
                                                  "|((cn=Daniel Sie)(sn=Hallin))"

             CAPICOM_STORE_OPEN_MODE OpenMode - Ignored for MEMORY_STORE and
                                                ACTIVE_DIRECTORY_USER_STORE.

  Remark   : If the system store does not exist, a new system store will be 
             created, and for memory store, a new memory store is always 
             created.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Open (CAPICOM_STORE_LOCATION  StoreLocation, 
                           BSTR                    StoreName,
                           CAPICOM_STORE_OPEN_MODE OpenMode)
{
    HRESULT    hr           = S_OK;
    LPWSTR     wszName      = NULL;
    LPCSTR     szProvider   = (LPCSTR) CERT_STORE_PROV_SYSTEM;
    DWORD      dwOpenFlag   = 0;
    DWORD      dwLocation   = 0;
    HCERTSTORE hCertStore   = NULL;
    HMODULE    hDSClientDLL = NULL;
    CComPtr<ICertificates> pICertificates = NULL;

    DebugTrace("Entering CStore::Open().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Reset.
        //
        if (m_hCertStore)
        {
            ::CertCloseStore(m_hCertStore, 0);
            m_hCertStore = NULL;
        }

        //
        // Make sure parameters are valid.
        //
        switch (OpenMode)
        {
            case CAPICOM_STORE_OPEN_READ_ONLY:
            {
                dwOpenFlag = CERT_STORE_READONLY_FLAG;
                break;
            }

            case CAPICOM_STORE_OPEN_READ_WRITE:
            {
                break;
            }

            case CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED:
            {
                dwOpenFlag = CERT_STORE_MAXIMUM_ALLOWED_FLAG;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, unknown store open mode.\n");
                goto ErrorExit;
            }
        }

        switch (StoreLocation)
        {
            case CAPICOM_MEMORY_STORE:
            {
                wszName = NULL;
                szProvider = (LPSTR) CERT_STORE_PROV_MEMORY;
                break;
            }

            case CAPICOM_LOCAL_MACHINE_STORE:
            {
                wszName = StoreName;
                dwLocation = CERT_SYSTEM_STORE_LOCAL_MACHINE;
                break;
            }

            case CAPICOM_CURRENT_USER_STORE:
            {
                wszName = StoreName;
                dwLocation = CERT_SYSTEM_STORE_CURRENT_USER;
                break;
            }

            case CAPICOM_ACTIVE_DIRECTORY_USER_STORE:
            {
                wszName = NULL;
                szProvider = (LPSTR) CERT_STORE_PROV_MEMORY;

                //
                // Make sure DSClient is installed, and is not WRITE mode.
                //
                if (!(hDSClientDLL = ::LoadLibrary("ActiveDS.DLL")))
                {
                    hr = CAPICOM_E_NOT_SUPPORTED;

                    DebugTrace("Error [%#x]: DSClient not installed.\n", hr);
                    goto ErrorExit;
                }
                if (CAPICOM_STORE_OPEN_READ_WRITE == OpenMode)
                {
                    hr = CAPICOM_E_STORE_INVALID_OPEN_MODE;

                    DebugTrace("Error [%#x]: Attemp to open AD Store for WRITE.\n", hr);
                    goto ErrorExit;
                }

                //
                // Always force to read only even if user asked for 
                // maximum allowed.
                //
                dwOpenFlag = CERT_STORE_READONLY_FLAG;

                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, unknown store location.\n");
                goto ErrorExit;
            }
        }

        //
        // Call CAPI to open the store.
        //
        if (!(hCertStore = ::CertOpenStore(szProvider,
                                           CAPICOM_ASN_ENCODING,
                                           NULL,
                                           dwOpenFlag | dwLocation,
                                           (void *) (LPCWSTR) wszName)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit; 
        }

        //
        // Load userCertificate from the directory, if necessary.
        //
        if (CAPICOM_ACTIVE_DIRECTORY_USER_STORE == StoreLocation &&
            FAILED(hr = ::LoadFromDirectory(hCertStore, StoreName)))
        {
            DebugTrace("Error [%#x]: LoadFromDirectory() failed.\n", hr);
            goto ErrorExit;
        }

#if (0)
        //
        // Create the ICertificates collection object.
        //
        if (FAILED(hr = ::CreateCertificatesObject(CAPICOM_CERTIFICATES_LOAD_FROM_STORE,
                                                   (LPARAM) hCertStore,
                                                   &pICertificates)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }
#endif

        //
        // Update member variables.
        //
        m_hCertStore = hCertStore;
        m_pICertificates = pICertificates;
        m_StoreLocation = StoreLocation;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hDSClientDLL)
    {
        ::FreeLibrary(hDSClientDLL);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Open().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    ReportError(hr);

    goto UnlockExit;
}

#if (0) //DSIE - Drop this for now.
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Find

  Synopsis : Find a certificate in the store by issuer's name and serial
             number.

  Parameter: BSTR Issuer - Issuer's mame.
  
             BSTR SerialNumber - Serial number in hex format.
             
             ICertificate ** pVal - Pointer to pointer to ICertificate interface
                                    to receive the found certificate.                                    

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Find (BSTR Issuer, BSTR SerialNumber, ICertificate ** pVal)
{
    HRESULT               hr            = S_OK;
    PCCERT_CONTEXT        pCertContext  = NULL;
    CComPtr<ICertificate> pICertificate = NULL;
    CERT_INFO             CertInfo;

    DebugTrace("Entering CStore::Find().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Initialize CERT_INFO.
        //   
        ::ZeroMemory(&CertInfo, sizeof(CertInfo));

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit;
        }

        //
        // Convert issuer's name string to name blob.
        //
        if (FAILED(hr = ::Name2NameBlob(Issuer, &CertInfo.Issuer)))
        {
            DebugTrace("Error [%#x]: Name2NameBlob() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert serial number to integer blob.
        //
        if (FAILED(hr = ::Hex2IntegerBlob(SerialNumber, &CertInfo.SerialNumber)))
        {
            DebugTrace("Error [%#x]: Hex2IntegerBlob() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Find the cert.
        //
        if (!(pCertContext = ::CertFindCertificateInStore(m_hCertStore,
                                                          CAPICOM_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_SUBJECT_CERT,
                                                          (const void *) &CertInfo,             
                                                          NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFindCertificateInStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create an ICertificate object for the found cert.
        //
        if (FAILED(hr = ::CreateCertificateObject(pCertContext, pVal)))
        {
            DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (CertInfo.Issuer.pbData)
    {
        ::CoTaskMemFree(CertInfo.Issuer.pbData);
    }
    if (CertInfo.SerialNumber.pbData)
    {
        ::CoTaskMemFree(CertInfo.SerialNumber.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Find().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ::ReportError(hr);

    goto UnlockExit;
}
#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Add

  Synopsis : Add a certificate to the store.

  Parameter: PCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to add.

  Remark   : If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to add 
             certificate to the system store.

             Added certificates are not persisted for non-system stores.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Add (ICertificate * pVal)
{
    HRESULT               hr            = S_OK;
    PCCERT_CONTEXT        pCertContext  = NULL;
    CComPtr<ICertificate> pICertificate = NULL;

    DebugTrace("Entering CStore::Add().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // QI for ICertificate pointer (Just to make sure it is indeed
        // an ICertificate object).
        //
        if (!(pICertificate = pVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, not an ICertificate interface pointer.\n");
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit;
        }

        //
        // If it is a system store and we are called from a web page, then
        // we need to pop up UI to get user permission to add certificates
        // to the store.
        //
        if ((m_dwCurrentSafety) &&
            (CAPICOM_CURRENT_USER_STORE == m_StoreLocation || CAPICOM_LOCAL_MACHINE_STORE == m_StoreLocation) &&
            (PromptForStoreAddRemoveEnabled()))
        {
            if (FAILED(hr = ::UserApprovedOperation(IDD_STORE_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get cert context from certificate object, using the restriced private
        // method, ICertificate::_GetContext().
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext);

        //
        // Add to the store.
        //
        if (!::CertAddCertificateContextToStore(m_hCertStore,
                                                pCertContext,
                                                CERT_STORE_ADD_USE_EXISTING,
                                                NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Remove

  Synopsis : Remove a certificate from the store.

  Parameter: ICertificate * - Pointer to certificate object to remove.

  Remark   : If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to remove 
             certificate to the system store.

             Removed certificates are not persisted for non-system stores.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Remove (ICertificate * pVal)
{
    HRESULT               hr            = S_OK;
    PCCERT_CONTEXT        pCertContext  = NULL;
    PCCERT_CONTEXT        pCertContext2 = NULL;
    CComPtr<ICertificate> pICertificate = NULL;

    DebugTrace("Entering CStore::Remove().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        BOOL bResult;

        //
        // QI for ICertificate pointer (Just to make sure it is indeed
        // an ICertificate object).
        //
        if (!(pICertificate = pVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, not an ICertificate interface pointer.\n");
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit;
        }

        //
        // If it is a system store and we are called from a web page, then
        // we need to pop up UI to get user permission to remove certificates
        // to the store.
        //
        if ((m_dwCurrentSafety) &&
            (CAPICOM_CURRENT_USER_STORE == m_StoreLocation || CAPICOM_LOCAL_MACHINE_STORE == m_StoreLocation) &&
            (PromptForStoreAddRemoveEnabled()))
        {
            if (FAILED(hr = ::UserApprovedOperation(IDD_STORE_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get cert context from certificate object, using the restriced private
        // method, ICertificate::_GetContext().
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext);
    
        //
        // Find the cert in store.
        //
        if (FAILED(hr = ::FindCertInStore(m_hCertStore, pCertContext, &pCertContext2)))
        {
            DebugTrace("Error [%#x]: FindCertInStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext2);

        //
        // Remove from the store.
        //
        bResult =::CertDeleteCertificateFromStore(pCertContext2);

        //
        // Since CertDeleteCertificateFromStore always release the
        // context regardless of success or failure, we must first 
        // NULL the CERT_CONTEXT before checking for result.
        //
        pCertContext2 = NULL;

        if (!bResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDeleteCertificateFromStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext2)
    {
        ::CertFreeCertificateContext(pCertContext2);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore:Export

  Synopsis : Export all certificates in the store.

  Parameter: CAPICOM_STORE_SAVE_AS_TYPE SaveAs - Save as type.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the store blob.

  Remark   : If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to export 
             certificate from the system store.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Export (CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
                             CAPICOM_ENCODING_TYPE      EncodingType, 
                             BSTR                     * pVal)
{
    HRESULT   hr       = S_OK;
    DWORD     dwSaveAs = 0;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CStore::Export().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Determine SaveAs type.
        //
        switch (SaveAs)
        {
            case CAPICOM_STORE_SAVE_AS_SERIALIZED:
            {
                dwSaveAs = CERT_STORE_SAVE_AS_STORE;
                break;
            }

            case CAPICOM_STORE_SAVE_AS_PKCS7:
            {
                dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, unknown encoding type.\n");
                goto ErrorExit;
            }
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit;
        }

        //
        // If it is a system store and we are called from a web page, then
        // we need to pop up UI to get user permission to export certificates
        // from the store.
        //
        if (m_dwCurrentSafety && PromptForStoreAddRemoveEnabled())
        {
            if (FAILED(hr = ::UserApprovedOperation(IDD_STORE_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Determine required length.
        //
        if (!::CertSaveStore(m_hCertStore,              // in
                             CAPICOM_ASN_ENCODING,      // in
                             dwSaveAs,                  // in
                             CERT_STORE_SAVE_TO_MEMORY, // in
                             (void *) &DataBlob,        // in/out
                             0))                        // in
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DebugTrace("Error [%#x]: CertSaveStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate memory.
        //
        if (!(DataBlob.pbData = (BYTE *) ::CoTaskMemAlloc(DataBlob.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now save the store to memory blob.
        //
        if (!::CertSaveStore(m_hCertStore,              // in
                             CAPICOM_ASN_ENCODING,      // in
                             dwSaveAs,                  // in
                             CERT_STORE_SAVE_TO_MEMORY, // in
                             (void *) &DataBlob,        // in/out
                             0))                        // in
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertSaveStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Export store.
        //
        if (FAILED(hr = ::ExportData(DataBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Export().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Import

  Synopsis : Import either a serialized or PKCS #7 certificate store.

  Parameter: BSTR EncodedStore - Pointer to BSTR containing the encoded 
                                 store blob.

  Remark   : Note that the SaveAs and EncodingType will be determined
             automatically.
  
             If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to import 
             certificate to the system store.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Import (BSTR EncodedStore)
{
    HRESULT        hr           = S_OK;
    DATA_BLOB      DataBlob     = {0, NULL};
    HCERTSTORE     hCertStore   = NULL;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CStore::Import().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(EncodedStore))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, EncodedStore is empty.\n");
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error: store object does not represent an opened certificate store.\n");
            goto ErrorExit;
        }

        //
        // If it is a system store and we are called from a web page, then
        // we need to pop up UI to get user permission to import certificates
        // to the store.
        //
        if ((m_dwCurrentSafety) &&
            (CAPICOM_CURRENT_USER_STORE == m_StoreLocation || CAPICOM_LOCAL_MACHINE_STORE == m_StoreLocation) &&
            (PromptForStoreAddRemoveEnabled()))
        {
            if (FAILED(hr = ::UserApprovedOperation(IDD_STORE_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Decode store.
        //
        if (FAILED(hr = ::ImportData(EncodedStore, &DataBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n");
            goto ErrorExit;
        }

        //
        // Open the store.
        //
        if (!(hCertStore = ::CertOpenStore(CERT_STORE_PROV_SERIALIZED,
                                           CAPICOM_ASN_ENCODING,
                                           NULL,
                                           CERT_STORE_OPEN_EXISTING_FLAG,
                                           (void *) &DataBlob)) &&
            !(hCertStore = ::CertOpenStore(CERT_STORE_PROV_PKCS7,
                                           CAPICOM_ASN_ENCODING,
                                           NULL,
                                           CERT_STORE_OPEN_EXISTING_FLAG,
                                           (void *) &DataBlob)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now add all certificates to the current store.
        //
        while (pCertContext = ::CertEnumCertificatesInStore(hCertStore, pCertContext))
        {
            //
            // Add to the store.
            //
            if (!::CertAddCertificateContextToStore(m_hCertStore,
                                                    pCertContext,
                                                    CERT_STORE_ADD_USE_EXISTING,
                                                    NULL))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                ::CertFreeCertificateContext(pCertContext);

                DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Import().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\capicom\store.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Store.h

  Content: Declaration of CStore.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __STORE_H_
#define __STORE_H_

#include <atlctl.h>
#include "resource.h"
#include "Certificates.h"
#include "Error.h"
#include "Lock.h"


////////////////////////////////////////////////////////////////////////////////
//
// CStore
//

class ATL_NO_VTABLE CStore : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStore, &CLSID_Store>,
    public ICAPICOMError<CStore, &IID_IStore>,
	public IDispatchImpl<IStore, &IID_IStore, &LIBID_CAPICOM>,
    public IObjectSafetyImpl<CStore, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                     INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CStore()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STORE)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStore)
	COM_INTERFACE_ENTRY(IStore)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CStore)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

	HRESULT FinalConstruct()
	{
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Store object.\n", hr);
            return hr;
        }

        m_hCertStore = NULL;
        m_pICertificates = NULL;
        m_StoreLocation = CAPICOM_CURRENT_USER_STORE;

		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
        if (m_hCertStore)
        {
            ::CertCloseStore(m_hCertStore, 0);
        }
        m_pICertificates.Release();

		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

//
// IStore
//
public:
	STDMETHOD(Import)
        (/*[in]*/ BSTR EncodedStore);

	STDMETHOD(Export)
        (/*[in, defaultvalue(CAPICOM_STORE_SAVE_AS_SERIALIZED)]*/ CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
         /*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

	STDMETHOD(Remove)
        (/*[in]*/ ICertificate * pVal);

	STDMETHOD(Add)
        (/*[in]*/ ICertificate * pVal);

	STDMETHOD(Open)
        (/*[in]*/ CAPICOM_STORE_LOCATION StoreLocation,
         /*[in, defaultvalue(NULL)]*/ BSTR StoreName,
         /*[in, defaultvalue(CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED)]*/ CAPICOM_STORE_OPEN_MODE OpenMode);

	STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates ** pVal);

private:
    CLock                  m_Lock;
    HCERTSTORE             m_hCertStore;
    CComPtr<ICertificates> m_pICertificates;
    CAPICOM_STORE_LOCATION m_StoreLocation;
};

#endif //__STORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\scrdenrl\makefile.inc ===
$(O)\scrdx86.dll  : i386\scrdenrl.dll
    copy $** $@

w2k\scrdw2k.dll  : w2k\scrdenrl.dll
    copy $** $@

$(O)\scrdia64.dll : ia64\scrdenrl.dll
    copy $** $@

$(O)\scrdsign.dll : $(TARGET_DIRECTORY)\scrdenrl.dll
    copy $** $@

$(O)\scrdenrl.pdb : $(TARGET_DIRECTORY)\scrdenrl.pdb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\chs\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\ara\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\br\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\cs\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\da\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\el\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\es\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\cht\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\fi\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\fr\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\ger\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\heb\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\hu\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\it\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\kor\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\jpn\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\nl\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\localized\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\no\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\pl\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\pt\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\ru\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\sv\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\tr\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\release\xenroll\usa\makefile.inc ===
!INCLUDE ..\mkinc.tpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scenum.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scenlist

Abstract:

    This header file describes the linkages to the smart card helper routines
    provided to Xiaohung Su for use in the smart card enrollment station.

Author:

    Doug Barlow (dbarlow) 11/12/1998

Remarks:

    This header file is hardcoded to UNICODE for backwards compatibility.

Notes:

    ?Notes?

--*/

#ifndef _SCENUM_H_
#define _SCENUM_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
CountReaders(
    LPVOID pvHandle);

DWORD
ScanReaders(
    LPVOID *ppvHandle);

BOOL
EnumInsertedCards(
    LPVOID pvHandle,
    LPWSTR szCryptoProvider,
    DWORD cchCryptoProvider,
    LPDWORD pdwProviderType,
    LPCWSTR *pszReaderName);

void
EndReaderScan(
    LPVOID *ppvHandle);

#ifdef __cplusplus
}
#endif
#endif // _SCENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scrdenrl.rc
//
#define IDS_PROJNAME                    100
#define IDR_SCRDENR                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\enrlhelp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       enrlhelp.h
//
//  Contents:   Headers for the helper functions for smard card enrollment station
//
//----------------------------------------------------------------------------

#ifndef __ENRLHELP_H__
#define __ENRLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif
    
/////////////////////////////////////////////////////////////////////////////
// Contants defines
#define g_dwMsgAndCertEncodingType  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING

const   WCHAR g_MyStoreName[]=L"MY";


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CSP_INFO
typedef struct  _SCrdEnroll_CERT_SELECT_INFO
{
    DWORD   dwFlags;
    LPWSTR  pwszCertTemplateName;
}SCrdEnroll_CERT_SELECT_INFO, *PSCrdEnroll_CERT_SELECT_INFO;

/////////////////////////////////////////////////////////////////////////////
// Function Prototypes
LPWSTR  CopyWideString(LPCWSTR wsz);

BOOL    SearchAndDeleteCert(PCCERT_CONTEXT  pCertContext);

BOOL    InitlializeCSPList(DWORD    *pdwCSPCount, SCrdEnroll_CSP_INFO **prgCSPInfo);

void    FreeCSPInfo(DWORD   dwCSPCount, SCrdEnroll_CSP_INFO *prgCSPInfo);

BOOL    GetCAInfoFromCertType(HANDLE					hToken,
							  LPWSTR                    pwszCTName,
                              DWORD                     *pdwValidCA,
                              SCrdEnroll_CA_INFO        **prgCAInfo);

HRESULT GetCAArchivalCert(LPWSTR           pwszCAName, 
			  PCCERT_CONTEXT  *ppCert);  

BOOL    InitializeCTList(DWORD              *pdwCTIndex,
                         DWORD              *pdwCTCount, 
                         SCrdEnroll_CT_INFO **prgCTInfo);

LPVOID  SCrdEnrollAlloc (
        ULONG cbSize);

LPVOID  SCrdEnrollRealloc (
        LPVOID pv,
        ULONG cbSize);

VOID    SCrdEnrollFree (
        LPVOID pv);


void    FreeCTInfo(DWORD    dwCTCount, SCrdEnroll_CT_INFO *rgCTInfo);

void    FreeCAInfo(DWORD    dwCACount, SCrdEnroll_CA_INFO *rgCAInfo);


HRESULT CodeToHR(HRESULT hr);

HRESULT GetSelectedUserName(IDsObjectPicker     *pDsObjectPicker,
			    LPWSTR              *ppwszSelectedUserSAM,
                            LPWSTR              *ppwszSelectedUserUPN);

BOOL    SignWithCert(LPSTR              pszCSPName,
                     DWORD              dwCSPType,
                     PCCERT_CONTEXT     pSigningCert);



HRESULT ChkSCardStatus(BOOL             fSCardSigningCert,
                       PCCERT_CONTEXT   pSigningCertCertContext,
                       LPSTR            pszCSPNameSigningCert,
                       DWORD            dwCSPTypeSigningCert,
                       LPSTR            pszContainerSigningCert,
                       LPWSTR           pwszSelectedCSP,
                       LPWSTR           *ppwszNewContainerName);


BOOL    ChKInsertedCardSigningCert(LPWSTR           pwszInsertProvider,
                                   DWORD            dwInsertProviderType,
                                   LPWSTR           pwszReaderName,
                                   PCCERT_CONTEXT   pSignCertContext,
                                   LPSTR            pszSignProvider,
                                   DWORD            dwSignProviderType,
                                   LPSTR            pszSignContainer,
                                   BOOL             *pfSame);

BOOL    DecodeBlobW(WCHAR   *pch,
                    DWORD   cch,
                    BYTE    **ppbData,
                    DWORD   *pcbData);


BOOL    EncodeBlobW(BYTE    *pbData,
                    DWORD   cbData,
                    DWORD   dwFlags,
                    WCHAR   **ppch,
                    DWORD   *pcch);


BOOL    GetNameFromPKCS10(BYTE      *pbPKCS10,
                          DWORD     cbPKCS10,
                          DWORD     dwFlags, 
                          LPSTR     pszOID, 
                          LPWSTR    *ppwszName);

BOOL    VerifyCertTemplateName(PCCERT_CONTEXT   pCertContext, 
                               LPWSTR           pwszCertTemplateName);


BOOL    WINAPI SelectSignCertCallBack(
                                PCCERT_CONTEXT  pCertContext,
                                BOOL            *pfInitialSelectedCert,
                                void            *pvCallbackData);

BOOL    VerifyCertChain(PCCERT_CONTEXT      pCertContext);

BOOL    IsNewerCert(PCCERT_CONTEXT  pFirstCert,
                    PCCERT_CONTEXT  pSecondCert);

BOOL    SmartCardCSP(PCCERT_CONTEXT pCertContext);

DWORD   GetEncodeFlag(DWORD dwFlags);

BOOL    GetName(LPWSTR                  pwszName,
                EXTENDED_NAME_FORMAT    NameFormat,
                EXTENDED_NAME_FORMAT    DesiredFormat,
                LPWSTR                  *ppwszDesiredName);	


BOOL	RetrieveCAName(DWORD					dwFlags, 
					   SCrdEnroll_CA_INFO		*pCAInfo, 
					   LPWSTR					*ppwszName);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif  //__ENRLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scrdenr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scrdenr.cpp
//
//--------------------------------------------------------------------------

// SCrdEnr.cpp : Implementation of CSCrdEnr


#define SECURITY_WIN32  //Or in the sources file -DSECURITY_WIN32

#include "stdafx.h"
#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#include <oleauto.h>
#include <objbase.h>
#include <cryptui.h>
#include "certca.h"
#include "certsrv.h"
#include "security.h"
#include <dbgdef.h>


#include "scrdenrl.h"
#include "SCrdEnr.h"
#include "enrlhelp.h"
#include "xEnroll.h"
#include "wzrdpvk.h"

/////////////////////////////////////////////////////////////////////////////
// CSCrdEnr
CSCrdEnr::CSCrdEnr(void) 
{  
    DWORD                       dwIndex=0;
    DSOP_SCOPE_INIT_INFO        ScopeInit;
    DSOP_INIT_INFO              InitInfo;

    m_dwCTCount=0;
    m_dwCTIndex=0;
    m_rgCTInfo=NULL;
    m_pwszUserUPN=NULL;
    m_pwszUserSAM=NULL;
    m_pEnrolledCert=NULL;

    m_dwCSPCount=0;
    m_dwCSPIndex=0;
    m_rgCSPInfo=NULL;  

    m_lEnrollmentStatus = CR_DISP_INCOMPLETE;
    
    m_pSigningCert=NULL;
    m_fSCardSigningCert=FALSE;     
    m_pszCSPNameSigningCert=NULL;
    m_dwCSPTypeSigningCert=0;  
    m_pszContainerSigningCert=NULL;

    m_pDsObjectPicker=NULL;

    m_pCachedCTEs = NULL; //no need to free
    m_pwszCachedCTEOid = NULL;
    m_pCachedCTE = NULL;

    if(!FAILED(CoInitialize(NULL)))
        m_fInitialize=TRUE;

    // Initialize functions who's loading we've deferred.  
    InitializeThunks(); 

    __try
    {
        InitializeCriticalSection(&m_cSection); 
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    //we now need to get the CSP list
    InitlializeCSPList(&m_dwCSPCount, &m_rgCSPInfo);


    //we now need to initialize the CA and its cert types
    InitializeCTList(&m_dwCTIndex, &m_dwCTCount, &m_rgCTInfo); 


    //init for the user selection dialogue
    memset(&ScopeInit, 0, sizeof(DSOP_SCOPE_INIT_INFO));
    memset(&InitInfo,  0, sizeof(InitInfo));

    ScopeInit.cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    ScopeInit.flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN|DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    ScopeInit.flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;            //this will give us the SAM name for the user
    ScopeInit.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    ScopeInit.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = &ScopeInit;
    InitInfo.flOptions = 0;             //we are doing single select

    //create the COM object
     if (S_OK == CoCreateInstance
         (CLSID_DsObjectPicker,
          NULL,
          CLSCTX_INPROC_SERVER,
          IID_IDsObjectPicker,
          (void **) &m_pDsObjectPicker))
     {
         if(S_OK != (m_pDsObjectPicker->Initialize(&InitInfo)))
         {
             m_pDsObjectPicker->Release();
             m_pDsObjectPicker=NULL;
         }
     }
     else 
        m_pDsObjectPicker=NULL;

}


CSCrdEnr::~CSCrdEnr(void) 
{
  
    if(m_pDsObjectPicker)
        m_pDsObjectPicker->Release();

    if(m_rgCTInfo)
        FreeCTInfo(m_dwCTCount, m_rgCTInfo);

    if(m_rgCSPInfo)
        FreeCSPInfo(m_dwCSPCount, m_rgCSPInfo);

    if(m_pwszUserUPN)
        SCrdEnrollFree(m_pwszUserUPN);

    if(m_pwszUserSAM)
        SCrdEnrollFree(m_pwszUserSAM);

    if(m_pSigningCert)
        CertFreeCertificateContext(m_pSigningCert); 

    if(m_pszCSPNameSigningCert)
        SCrdEnrollFree(m_pszCSPNameSigningCert);

    if(m_pszContainerSigningCert)
        SCrdEnrollFree(m_pszContainerSigningCert);

    if(m_pEnrolledCert)
        CertFreeCertificateContext(m_pEnrolledCert);

    if (NULL != m_pwszCachedCTEOid)
    {
        LocalFree(m_pwszCachedCTEOid);
    }

    if (NULL != m_pCachedCTE)
    {
        LocalFree(m_pCachedCTE);
    }

    if(m_fInitialize)
        CoUninitialize();  

    DeleteCriticalSection(&m_cSection); 
}


STDMETHODIMP CSCrdEnr::get_CSPCount(long * pVal)
{
	if(NULL==pVal)
        return E_INVALIDARG;

    EnterCriticalSection(&m_cSection);
    *pVal = (long)m_dwCSPCount;
    LeaveCriticalSection(&m_cSection);

	return S_OK;
}

STDMETHODIMP CSCrdEnr::get_CSPName(BSTR * pVal)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cSection);

    if(NULL==m_rgCSPInfo || 0==m_dwCSPCount)
    {
        *pVal=NULL;
        hr=E_INVALIDARG;
    }
    else
    {
        if( NULL == (*pVal = SysAllocString(m_rgCSPInfo[m_dwCSPIndex].pwszCSPName)))
            hr = E_OUTOFMEMORY;
    }

    LeaveCriticalSection(&m_cSection);

    return(hr);
}



STDMETHODIMP CSCrdEnr::put_CSPName(BSTR newVal)
{
    HRESULT            hr= E_FAIL;
    DWORD              errBefore= GetLastError();

    DWORD              dwIndex=0;

    EnterCriticalSection(&m_cSection);

    if(NULL == m_rgCSPInfo || 0 == m_dwCSPCount || NULL == newVal)
        goto InvalidArgErr;

    for(dwIndex=0; dwIndex < m_dwCSPCount; dwIndex++)
    {
        if(0 == _wcsicmp(newVal, m_rgCSPInfo[dwIndex].pwszCSPName))
        {
            m_dwCSPIndex=dwIndex;
            break;
        }
    }

    if(dwIndex == m_dwCSPCount)
        goto InvalidArgErr;
     
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}




STDMETHODIMP CSCrdEnr::selectUserName
        (/* [in] */              DWORD dwFlags)
{
    HRESULT                         hr= E_FAIL;
    DWORD                           errBefore= GetLastError();
    LPWSTR                          pwszSelectedUserSAM=NULL;                            
    LPWSTR                          pwszSelectedUserUPN=NULL;

    EnterCriticalSection(&m_cSection);
    
    if(NULL == m_pDsObjectPicker)
        goto InvalidArgErr;


    if(S_OK != (hr = GetSelectedUserName(m_pDsObjectPicker,
                                        &pwszSelectedUserSAM,
                                        &pwszSelectedUserUPN)))
        goto SelectUserErr;

    //we should at least have the UserSAM name
    if(NULL == pwszSelectedUserSAM)
    {
        if(pwszSelectedUserUPN)
            SCrdEnrollFree(pwszSelectedUserUPN);

        goto UnexpectedErr;
    }


    if(m_pwszUserSAM)
    {
        SCrdEnrollFree(m_pwszUserSAM);
        m_pwszUserSAM=NULL;
    }

    if(m_pwszUserUPN)
    {
        SCrdEnrollFree(m_pwszUserUPN);
        m_pwszUserUPN=NULL;
    }

    m_pwszUserSAM=pwszSelectedUserSAM;

    m_pwszUserUPN=pwszSelectedUserUPN;
     
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR_VAR(SelectUserErr, hr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
}

STDMETHODIMP CSCrdEnr::enroll

        (/* [in] */                 DWORD   dwFlags)
{
    HRESULT             hr              = E_FAIL;
    DWORD               errBefore       = GetLastError();
    ULONG               cbSize          = 0;
    SCrdEnroll_CA_INFO *pCAInfo         = NULL; 
    SCrdEnroll_CT_INFO *pCertTypeInfo   = NULL;
    BSTR                bstrAttribs     = NULL; 
    BSTR                bstrCA          = NULL;
    BSTR                bstrCertificate = NULL; 
    BSTR                bstrReq         = NULL; 

    LPWSTR              pwszRequesterName = NULL;
    ICertRequest2      *pICertRequest     = NULL;
    IEnroll4           *pIEnroll          = NULL;
    CRYPT_DATA_BLOB     PKCS10Blob;
    CRYPT_DATA_BLOB     PKCS7Request;
    CRYPT_DATA_BLOB     PKCS7Response;
    DWORD               dwDisposition; 
    DWORD               dwRequestID; 
    LPWSTR              pwszNewContainerName=NULL;
    PCCERT_CONTEXT      pArchivalCert; 
    LONG lKeySpec = XEKL_KEYSPEC_KEYX;
    LONG lKeyMin, lKeyMax;
    DWORD dwKeyMin, dwKeyMax, dwKeySize;

    //------------------------------------------------------------
    //
    // Define locally scoped utility functions: 
    //
    //------------------------------------------------------------

    LocalScope(EnrollUtilities): 
	BSTR bstrConcat(LPWSTR pwsz1, LPWSTR pwsz2, LPWSTR pwsz3, LPWSTR pwsz4)
	{ 
	    // Note:  assumes valid input parameters!
	    BSTR   bstrResult = NULL;
	    LPWSTR pwszResult = NULL;
	    
	    pwszResult = (LPWSTR)SCrdEnrollAlloc(sizeof(WCHAR) * (wcslen(pwsz1) + wcslen(pwsz2) + wcslen(pwsz3) + wcslen(pwsz4)));
	    if (pwszResult == NULL) { return NULL; }
	    else { 
		wcscpy(pwszResult, pwsz1);
		wcscat(pwszResult, pwsz2);
		wcscat(pwszResult, pwsz3);
		wcscat(pwszResult, pwsz4);
		// Convert the result to a BSTR
		bstrResult = SysAllocString(pwszResult);
		// Free the temporary storage.  
		SCrdEnrollFree(pwszResult);
		// Return the result. 
		return bstrResult; 
	    }
	}

	DWORD ICEnrollDispositionToCryptuiStatus(IN  DWORD  dwDisposition)
	{
	    switch (dwDisposition)
		{
		case CR_DISP_INCOMPLETE:          return CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		case CR_DISP_DENIED:              return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;
		case CR_DISP_ISSUED:              return CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
		case CR_DISP_ISSUED_OUT_OF_BAND:  return CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
		case CR_DISP_UNDER_SUBMISSION:    return CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION;
		case CR_DISP_ERROR:               return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;

		default: 
		    // Should never happen
		    return CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
		}
	}
    EndLocalScope;

    //------------------------------------------------------------
    //
    // Begin procedure body
    //
    //------------------------------------------------------------

    memset(&PKCS10Blob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&PKCS7Request, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&PKCS7Response, 0, sizeof(CRYPT_DATA_BLOB));

    EnterCriticalSection(&m_cSection);

    //check for the status of the smart cards in the reader.
    //return the fully qualified container name for the new user
    //smart card
    if(S_OK != (hr = ChkSCardStatus(m_fSCardSigningCert,
                            m_pSigningCert,
                            m_pszCSPNameSigningCert,
                            m_dwCSPTypeSigningCert,
                            m_pszContainerSigningCert, 
                            m_rgCSPInfo[m_dwCSPIndex].pwszCSPName,
                            &pwszNewContainerName)))
        goto StatusErr;

    //delete the old certificate
    if(m_pEnrolledCert)
    {
        CertFreeCertificateContext(m_pEnrolledCert);
        m_pEnrolledCert=NULL;
    }

    //init enrollment status
    m_lEnrollmentStatus = CR_DISP_INCOMPLETE;

    //make sure that we have the correct information for processing
    //the enrollment request

    if(0 == m_dwCTCount || NULL == m_rgCTInfo || 0 == m_dwCSPCount ||
        NULL == m_rgCSPInfo || NULL == m_pSigningCert ||
        ((NULL == m_pwszUserSAM) && (NULL == m_pwszUserUPN)))
        goto InvalidArgErr;

    //make sure that we have some CA
    pCertTypeInfo=&(m_rgCTInfo[m_dwCTIndex]);

    if(NULL == pCertTypeInfo->rgCAInfo || 0 == pCertTypeInfo->dwCACount)
        goto InvalidArgErr;

    pCAInfo=&(pCertTypeInfo->rgCAInfo[pCertTypeInfo->dwCAIndex]);

    if(NULL == (pIEnroll=MyPIEnroll4GetNoCOM()))
        goto TraceErr;
    
    //we use our own My store to store the enrolled certificate
    if(S_OK != (hr = pIEnroll->put_MyStoreNameWStr((LPWSTR)g_MyStoreName)))
        goto xEnrollErr;

    //we always use a new key
    if(S_OK != (hr=pIEnroll->put_UseExistingKeySet(FALSE)))
        goto xEnrollErr;

    //we the key container name
    if(S_OK != (hr=pIEnroll->put_ContainerNameWStr(pwszNewContainerName)))
        goto xEnrollErr;

    //set the CSP information
    if(S_OK != (hr=pIEnroll->put_ProviderType(m_rgCSPInfo[m_dwCSPIndex].dwCSPType)))
        goto xEnrollErr;

    if(S_OK !=(hr=pIEnroll->put_ProviderNameWStr(m_rgCSPInfo[m_dwCSPIndex].pwszCSPName)))
        goto xEnrollErr;

    //dwKeySpec
    if(S_OK !=(hr=pIEnroll->put_KeySpec(pCertTypeInfo->dwKeySpec)))
            goto xEnrollErr;

    //private key flags.  Left half-word is the key size. 
    //If the key size is 0, then specify a default key size.  
    if (0 == (pCertTypeInfo->dwGenKeyFlags & 0xFFFF0000))
    {
	// If min key size is not set, use 1024 bits.  
	pCertTypeInfo->dwGenKeyFlags |= (1024 << 16); 
    }

    dwKeySize = (pCertTypeInfo->dwGenKeyFlags & 0xFFFF0000) >> 16;
    if (0x0 != dwKeySize)
    {
        //make sure key size is in the range
        //let's get CSP key size information

        if (AT_SIGNATURE  == pCertTypeInfo->dwKeySpec)
        {
            lKeySpec = XEKL_KEYSPEC_SIG;
        }
        hr = pIEnroll->GetKeyLenEx(XEKL_KEYSIZE_MIN, lKeySpec, &lKeyMin);
        // don't have error check because the CSP may not support it
        if (S_OK == hr)
        {
            hr = pIEnroll->GetKeyLenEx(XEKL_KEYSIZE_MAX, lKeySpec, &lKeyMax);
            if (S_OK != hr)
            {
                goto xEnrollErr;
            }
            dwKeyMin = (DWORD)lKeyMin;
            dwKeyMax = (DWORD)lKeyMax;
            if (dwKeySize < dwKeyMin)
            {
                //reset the current key size
                pCertTypeInfo->dwGenKeyFlags &= 0x0000FFFF;
                //set adjusted size
                pCertTypeInfo->dwGenKeyFlags |= ((dwKeyMin & 0x0000FFFF) << 16);
            }
            if (dwKeySize > dwKeyMax)
            {
                //reset the current key size
                pCertTypeInfo->dwGenKeyFlags &= 0x0000FFFF;
                //set adjusted size
                pCertTypeInfo->dwGenKeyFlags |= ((dwKeyMax & 0x0000FFFF) << 16);
            }
        }
    }

    if (S_OK !=(hr=pIEnroll->put_GenKeyFlags(pCertTypeInfo->dwGenKeyFlags)))
	goto xEnrollErr; 

    // S/MIME supported? 
    if (S_OK !=(hr=pIEnroll->put_EnableSMIMECapabilities
		(pCertTypeInfo->dwEnrollmentFlags & CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS)))
	goto xEnrollErr; 

    // Set archival cert, if one has been specified. 
    // bstrCA <-- CA_location\CA_Name
    //
    bstrCA      = local.bstrConcat
	(pCAInfo->pwszCALocation,
	 L"\\", 
	 pCAInfo->pwszCADisplayName ? pCAInfo->pwszCADisplayName : pCAInfo->pwszCAName, 
	 L"\0"); 
    if (NULL == bstrCA)
	goto MemoryErr; 

    if (pCertTypeInfo->dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL)
    {
        if (S_OK != (hr = this->GetCAExchangeCertificate(bstrCA, &pArchivalCert)))
	    goto xEnrollErr;
	
	if (S_OK != (hr = pIEnroll->SetPrivateKeyArchiveCertificate(pArchivalCert)))
	    goto xEnrollErr;
    }
    
    //cert Type extensions
    if(pCertTypeInfo->pCertTypeExtensions)
    {
        if(S_OK != (hr=pIEnroll->AddExtensionsToRequest
                                (pCertTypeInfo->pCertTypeExtensions)))
            goto xEnrollErr;
    }

    //no smart card stuff
    if(S_OK != (hr=pIEnroll->put_ReuseHardwareKeyIfUnableToGenNew(FALSE)))
        goto xEnrollErr;

    //create a PKCS10 request
    if(FAILED(hr=pIEnroll->createPKCS10WStr(NULL,
                                NULL,
                                &PKCS10Blob)))
        goto xEnrollErr;


    //add the name value pair of the enroll-on-behalf
    pwszRequesterName=MkWStr(wszPROPREQUESTERNAME);

    if(NULL==pwszRequesterName)
        goto MemoryErr;

    if(S_OK != (hr=pIEnroll->AddNameValuePairToSignatureWStr( 
           pwszRequesterName, m_pwszUserSAM)))
        goto xEnrollErr;


    //sign the request
    if(S_OK != (hr=pIEnroll->CreatePKCS7RequestFromRequest( 
            &PKCS10Blob,
            m_pSigningCert,
            &PKCS7Request)))
        goto xEnrollErr;


    //send the request to the CA
    //we set the purpose to the renew so that the format
    //will be a PKCS7
    
    bstrReq     = SysAllocStringByteLen((LPCSTR)PKCS7Request.pbData, PKCS7Request.cbData);
    if (NULL == bstrReq)
	goto MemoryErr;

    bstrAttribs = NULL;
    // RECALL: bstrCA <-- CA_location\CA_Name    

    if (pICertRequest == NULL)
    {
        if (S_OK != (hr = CoCreateInstance
                     (CLSID_CCertRequest, 
                      NULL, 
                      CLSCTX_INPROC_SERVER,
                      IID_ICertRequest2, 
                      (void**)&pICertRequest)))
	    goto xEnrollErr; 
    }

    if (S_OK != (hr = pICertRequest->Submit	     
		 (CR_IN_BINARY | CR_IN_PKCS7, 
		  bstrReq, 
		  bstrAttribs, 
		  bstrCA, 
		  (long *)&dwDisposition)))
	goto xEnrollErr;

    //use CR_DISP_ as enrollment status
    m_lEnrollmentStatus = dwDisposition;
    
    // check pending and save pending info
    // however, smart card enrollment station don't know how to deal with
    // this pending requests, may not necessary to do that
    if (CR_DISP_UNDER_SUBMISSION == m_lEnrollmentStatus)
    {
        hr = pICertRequest->GetRequestId((long *)&dwRequestID);
        if (S_OK != hr)
        {
            goto xEnrollErr; 
        }
        hr = pIEnroll->setPendingRequestInfoWStr(
                      dwRequestID, 
                      pCAInfo->pwszCALocation, 
                      NULL != pCAInfo->pwszCADisplayName ?
                          pCAInfo->pwszCADisplayName : pCAInfo->pwszCAName, 
                      NULL); 
    }
    if (CR_DISP_ISSUED != m_lEnrollmentStatus)
    {
        //if not issued, return
        goto CommonReturn; 
    }
    
    //must be CR_DISP_ISSUED
    hr = pICertRequest->GetCertificate(
                CR_OUT_BINARY | CR_OUT_CHAIN, &bstrCertificate);
    if (S_OK != hr)
    {
        goto xEnrollErr;
    }

    // Marshal the cert into a CRYPT_DATA_BLOB, and install it: 
    PKCS7Response.pbData = (LPBYTE)bstrCertificate; 
    PKCS7Response.cbData = SysStringByteLen(bstrCertificate); 
     
    m_pEnrolledCert = pIEnroll->getCertContextFromPKCS7(&PKCS7Response);
    if (NULL == m_pEnrolledCert)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto TraceErr;
    }

    hr=pIEnroll->acceptPKCS7Blob(&PKCS7Response);

    //we delete the enrolled certificate from the "My" store since it is added by
    //xEnroll.  No need to check the error
    SearchAndDeleteCert(m_pEnrolledCert);

    if(S_OK != hr)
    {
        goto TraceErr;
    }

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwszNewContainerName) 
        LocalFree((HLOCAL)pwszNewContainerName);

    if(pwszRequesterName)
        FreeWStr(pwszRequesterName);

    //the memory from xEnroll is freed via LocalFree
    //since we use the PIEnrollGetNoCOM function
    if(PKCS10Blob.pbData)
        LocalFree(PKCS10Blob.pbData);

    if(PKCS7Request.pbData)
        LocalFree(PKCS7Request.pbData);

    // PKCS7Respone's data is just an alias to m_pEnrolledCert's data:  we don't need to free it.

    if (NULL != bstrAttribs)     { SysFreeString(bstrAttribs); } 
    if (NULL != bstrCA)          { SysFreeString(bstrCA); } 
    if (NULL != bstrCertificate) { SysFreeString(bstrCertificate); }
    if (NULL != pICertRequest)   { pICertRequest->Release(); } 
       
    if(pIEnroll)
        pIEnroll->Release();
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore); 

    //if an error has occurred, the free the enrolled certificate
    if(m_pEnrolledCert)
    {
        CertFreeCertificateContext(m_pEnrolledCert);
        m_pEnrolledCert=NULL;
    }

    goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(xEnrollErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(StatusErr, hr);
}

HRESULT CSCrdEnr::GetCAExchangeCertificate(IN  BSTR             bstrCAQualifiedName, 
					   OUT PCCERT_CONTEXT  *ppCert) 
{
    HRESULT         hr                      = S_OK; 
    ICertRequest2  *pICertRequest            = NULL; 
    VARIANT         varExchangeCertificate; 
    
    // Input validation: 
    if (NULL == bstrCAQualifiedName || NULL == ppCert)
	return E_INVALIDARG; 

    // Init: 
    *ppCert                        = NULL; 
    varExchangeCertificate.vt      = VT_EMPTY; 
    varExchangeCertificate.bstrVal = NULL;

    if (S_OK != (hr = CoCreateInstance
                 (CLSID_CCertRequest, 
                  NULL, 
                  CLSCTX_INPROC_SERVER,
                  IID_ICertRequest2, 
                  (void**)&pICertRequest)))
	goto ErrorReturn; 

    if (S_OK != (hr = pICertRequest->GetCAProperty
		 (bstrCAQualifiedName,     // CA Name/CA Location
		  CR_PROP_CAXCHGCERT,      // Get the exchange certificate from the CA. 
		  0,                       // Unused
		  PROPTYPE_BINARY,         // 
		  CR_OUT_BINARY,           // 
		  &varExchangeCertificate  // Variant type representing the certificate. 
		  )))
	goto ErrorReturn;
 
    if (VT_BSTR != varExchangeCertificate.vt || NULL == varExchangeCertificate.bstrVal)
        goto UnexpectedErr; 

    *ppCert = CertCreateCertificateContext
	(X509_ASN_ENCODING, 
	 (LPBYTE)varExchangeCertificate.bstrVal, 
	 SysStringByteLen(varExchangeCertificate.bstrVal)); 
    if (*ppCert == NULL)
        goto CertCliErr; 

 CommonReturn: 
    if (NULL != pICertRequest)                    { pICertRequest->Release(); }
    if (NULL != varExchangeCertificate.bstrVal)  { SysFreeString(varExchangeCertificate.bstrVal); } 
    return hr; 
   
 ErrorReturn:
    if (ppCert != NULL && *ppCert != NULL)
    {
	CertFreeCertificateContext(*ppCert);
	*ppCert = NULL;
    }
    
    goto CommonReturn; 

SET_HRESULT(CertCliErr, HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(UnexpectedErr, E_UNEXPECTED);
}


STDMETHODIMP CSCrdEnr::selectSigningCertificate
        (/* [in] */                   DWORD     dwFlags,
         /* [in] */                   BSTR      bstrCertTemplateName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    CRYPTUI_SELECTCERTIFICATE_STRUCT    SelCert;
    BOOL                                fSCardSigningCert=FALSE;        
    DWORD                               dwCSPTypeSigningCert=0;     
    DWORD                               dwSize=0;
    DWORD                               dwImpType=0;
    SCrdEnroll_CERT_SELECT_INFO         CertSelectInfo;


    HCRYPTPROV                          hProv=NULL; //no need to free it
    LPSTR                               pszContainerSigningCert=NULL; 
    LPSTR                               pszCSPNameSigningCert=NULL;   
    PCCERT_CONTEXT                      pSigningCert=NULL;
    HCERTSTORE                          hMyStore=NULL;

    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_POLICY_PARA ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_CONTEXT const *pCertChain = NULL;

    memset(&SelCert, 0, sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT));

    EnterCriticalSection(&m_cSection);

    //select a signing certificate in my store with private key
    hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"my");

    if(NULL==hMyStore)
        goto TraceErr;

    CertSelectInfo.dwFlags = dwFlags;
    CertSelectInfo.pwszCertTemplateName = bstrCertTemplateName;

    SelCert.dwSize=sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT);
    SelCert.cDisplayStores=1;
    SelCert.rghDisplayStores=&hMyStore;
    SelCert.pFilterCallback=SelectSignCertCallBack;
    SelCert.pvCallbackData=&CertSelectInfo;

    pSigningCert=CryptUIDlgSelectCertificate(&SelCert);

    if(NULL==pSigningCert)
    {
        //user clicks on the cancel button.  
        hr=S_OK;
        goto CommonReturn;
    }

    //verification on the cert
    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    //get cert chain 1st
    if (!CertGetCertificateChain(
                HCCE_CURRENT_USER,  //enrollment agent
                pSigningCert,   //signing cert
                NULL,   //use current system time
                NULL,   //no additional stores
                &ChainParams,   //chain params
                0,   //no crl check
                NULL,   //reserved
                &pCertChain))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CertGetCertificateChainError;
    }

    ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;
    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;

    //verify the chain
    if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_BASE,  //basic
                pCertChain,
                &ChainPolicy,
                &PolicyStatus))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CertVerifyCertificateChainPolicyError;
    }
    if (S_OK != PolicyStatus.dwError)
    {
        hr = PolicyStatus.dwError;
        goto CertVerifyCertificateChainPolicyError;
    }

    //get the hProv 
    if(!CryptAcquireCertificatePrivateKey(
        pSigningCert,
        CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
        NULL,
        &hProv,     //this handle is cached and no need to be freed
        NULL,
        NULL))
        goto TraceErr;

    //get related information  
    //impType
    dwSize = sizeof(dwImpType);

    if(!CryptGetProvParam(hProv,
                PP_IMPTYPE,
                (BYTE *)(&dwImpType),
                &dwSize,
                0))
        goto TraceErr;

    if(CRYPT_IMPL_REMOVABLE & dwImpType)
        fSCardSigningCert=TRUE;

    //CSP Type
    dwSize = sizeof(dwCSPTypeSigningCert);  

    if(!CryptGetProvParam(hProv,
                PP_PROVTYPE,
                (BYTE *)(&dwCSPTypeSigningCert),
                &dwSize,
                0))
    {
            goto TraceErr;   
    }


    //CSP name
    dwSize = 0;

    if(!CryptGetProvParam(hProv,
                            PP_NAME,
                            NULL,
                            &dwSize,
                            0) || (0==dwSize))
        goto TraceErr;

    
    pszCSPNameSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

    if(NULL == pszCSPNameSigningCert)
        goto MemoryErr;

    if(!CryptGetProvParam(hProv,
                            PP_NAME,
                            (BYTE *)pszCSPNameSigningCert,
                            &dwSize,
                            0))
        goto TraceErr;

    //Container name
    dwSize = 0;

    if(!CryptGetProvParam(hProv,
                           PP_CONTAINER,
                            NULL,
                            &dwSize,
                            0) || (0==dwSize))
        goto TraceErr;

    
    pszContainerSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

    if(NULL == pszContainerSigningCert)
        goto MemoryErr;

    if(!CryptGetProvParam(hProv,
                          PP_CONTAINER,
                            (BYTE *)pszContainerSigningCert,
                            &dwSize,
                            0))
        goto TraceErr;


    //now, we need to perform a signig operation so that we 
    //can invoke the smard card dialogue and cash the reader information
    //to the hProv handle.  This operation is benign if the CSP of the signing
    //certificate is not on a smart card
    if(!SignWithCert(pszCSPNameSigningCert,
                     dwCSPTypeSigningCert,
                     pSigningCert))
        goto TraceErr;


    //the certificate looks good
    if(m_pSigningCert)
        CertFreeCertificateContext(m_pSigningCert);

    if(m_pszContainerSigningCert)
        SCrdEnrollFree(m_pszContainerSigningCert);

    if(m_pszCSPNameSigningCert)
        SCrdEnrollFree(m_pszCSPNameSigningCert);

    m_pSigningCert=pSigningCert;
    m_fSCardSigningCert = fSCardSigningCert;       
    m_pszCSPNameSigningCert = pszCSPNameSigningCert;  
    m_dwCSPTypeSigningCert = dwCSPTypeSigningCert;    
    m_pszContainerSigningCert = pszContainerSigningCert; 
    
    pSigningCert=NULL;
    pszCSPNameSigningCert=NULL;
    pszContainerSigningCert=NULL;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hMyStore)
        CertCloseStore(hMyStore, 0);

    if(pszContainerSigningCert)
        SCrdEnrollFree(pszContainerSigningCert);

    if(pszCSPNameSigningCert)
        SCrdEnrollFree(pszCSPNameSigningCert);

    if (NULL != pCertChain)
    {
        CertFreeCertificateChain(pCertChain);
    }

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);     
TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CertVerifyCertificateChainPolicyError)
}


STDMETHODIMP CSCrdEnr::setSigningCertificate
        (/* [in] */                   DWORD     dwFlags, 
         /* [in] */                   BSTR      bstrCertTemplateName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    BOOL                                fSCardSigningCert=FALSE;        
    DWORD                               dwCSPTypeSigningCert=0;     
    DWORD                               dwSize=0;
    DWORD                               dwImpType=0;
    SCrdEnroll_CERT_SELECT_INFO         CertSelectInfo;
    BOOL                                fSetCert=FALSE;


    HCRYPTPROV                          hProv=NULL;     //no need to free it
    PCCERT_CONTEXT                      pPreCert=NULL;  //no need to free it
    LPSTR                               pszContainerSigningCert=NULL; 
    LPSTR                               pszCSPNameSigningCert=NULL;   
    PCCERT_CONTEXT                      pSigningCert=NULL;
    HCERTSTORE                          hMyStore=NULL;



    EnterCriticalSection(&m_cSection);

    //mark if the signing cert is set previously
    if(m_pSigningCert)
        fSetCert=TRUE;
 
    //select a signing certificate in my store with private key
    hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"my");

    if(NULL==hMyStore)
        goto TraceErr;

    CertSelectInfo.dwFlags = dwFlags;
    CertSelectInfo.pwszCertTemplateName = bstrCertTemplateName;


    while(pSigningCert = CertEnumCertificatesInStore(hMyStore, pPreCert))
    {

        //check for the certificate
        if(!SelectSignCertCallBack(pSigningCert, NULL, &CertSelectInfo))
            goto NextCert;

        //this is a detaul NO-UI selection.  We can not handle the case
        //when the signing certificate is on a smart card
        if(SmartCardCSP(pSigningCert))
		   goto NextCert;

        //get the hProv 
        if(!CryptAcquireCertificatePrivateKey(
            pSigningCert,
            CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hProv,     //this handle is cached and no need to be freed
            NULL,
            NULL))
            goto NextCert;

        //get related information  
        //impType
        dwSize = sizeof(dwImpType);

        if(!CryptGetProvParam(hProv,
                    PP_IMPTYPE,
                    (BYTE *)(&dwImpType),
                    &dwSize,
                    0))
            goto NextCert;

        if(CRYPT_IMPL_REMOVABLE & dwImpType)
            fSCardSigningCert=TRUE;

        //CSP Type
        dwSize = sizeof(dwCSPTypeSigningCert);  

        if(!CryptGetProvParam(hProv,
                    PP_PROVTYPE,
                    (BYTE *)(&dwCSPTypeSigningCert),
                    &dwSize,
                    0))
            goto NextCert;


        //CSP name
        dwSize = 0;

        if(!CryptGetProvParam(hProv,
                                PP_NAME,
                                NULL,
                                &dwSize,
                                0) || (0==dwSize))
            goto NextCert;

    
        pszCSPNameSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

        if(NULL == pszCSPNameSigningCert)
            goto MemoryErr;

        if(!CryptGetProvParam(hProv,
                                PP_NAME,
                                (BYTE *)pszCSPNameSigningCert,
                                &dwSize,
                                0))
            goto NextCert;

        //Container name
        dwSize = 0;

        if(!CryptGetProvParam(hProv,
                               PP_CONTAINER,
                                NULL,
                                &dwSize,
                                0) || (0==dwSize))
            goto NextCert;

    
        pszContainerSigningCert = (LPSTR) SCrdEnrollAlloc(dwSize);

        if(NULL == pszContainerSigningCert)
            goto MemoryErr;

        if(!CryptGetProvParam(hProv,
                              PP_CONTAINER,
                                (BYTE *)pszContainerSigningCert,
                                &dwSize,
                                0))
            goto NextCert;


        //now, we need to perform a signig operation so that we 
        //can invoke the smard card dialogue and cash the reader information
        //to the hProv handle.  This operation is benign if the CSP of the signing
        //certificate is not on a smart card
        if(!SignWithCert(pszCSPNameSigningCert,
                         dwCSPTypeSigningCert,
                         pSigningCert))
            goto NextCert;

        //the certificate looks good
        if((NULL == m_pSigningCert) || (TRUE == fSetCert) ||
            (IsNewerCert(pSigningCert, m_pSigningCert)))
        {
            fSetCert = FALSE;

            if(m_pSigningCert)
            {
                CertFreeCertificateContext(m_pSigningCert);
                m_pSigningCert = NULL;
            }

            m_pSigningCert=CertDuplicateCertificateContext(pSigningCert);
            if(NULL == m_pSigningCert)
                goto DupErr;

            //copy the data
            if(m_pszContainerSigningCert)
                SCrdEnrollFree(m_pszContainerSigningCert);

            if(m_pszCSPNameSigningCert)
                SCrdEnrollFree(m_pszCSPNameSigningCert);

            m_fSCardSigningCert = fSCardSigningCert;       
            m_pszCSPNameSigningCert = pszCSPNameSigningCert;  
            m_dwCSPTypeSigningCert = dwCSPTypeSigningCert;    
            m_pszContainerSigningCert = pszContainerSigningCert;

            pszCSPNameSigningCert=NULL;
            pszContainerSigningCert=NULL;
        }
    
NextCert:

        if(pszContainerSigningCert)
            SCrdEnrollFree(pszContainerSigningCert);

        if(pszCSPNameSigningCert)
            SCrdEnrollFree(pszCSPNameSigningCert);

        pszCSPNameSigningCert=NULL;
        pszContainerSigningCert=NULL;
        fSCardSigningCert=FALSE;        
        dwCSPTypeSigningCert=0;     
        dwSize=0;
        dwImpType=0;

        pPreCert = pSigningCert;
    }

    //we should find a certificate
    if((NULL == m_pSigningCert) || (m_pSigningCert && (TRUE == fSetCert)))
        goto CryptNotFindErr;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hMyStore)
        CertCloseStore(hMyStore, 0);

    if(pszContainerSigningCert)
        SCrdEnrollFree(pszContainerSigningCert);

    if(pszCSPNameSigningCert)
        SCrdEnrollFree(pszCSPNameSigningCert);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

TRACE_ERROR(DupErr); 
SET_ERROR(CryptNotFindErr, CRYPT_E_NOT_FOUND);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}


STDMETHODIMP CSCrdEnr::get_EnrollmentStatus
( /* [retval][out] */ LONG * plEnrollmentStatus)
{
    if (plEnrollmentStatus == NULL)
    {
        return E_INVALIDARG; 
    }

    EnterCriticalSection(&m_cSection); 
    *plEnrollmentStatus = m_lEnrollmentStatus; 
    LeaveCriticalSection(&m_cSection); 

    return S_OK;
}



STDMETHODIMP CSCrdEnr::getEnrolledCertificateName
        (/*[in]  */                   DWORD     dwFlags,
        /* [retval][out] */           BSTR      *pBstrCertName)
{
    HRESULT                         hr= E_FAIL;
    DWORD                           errBefore= GetLastError();
    DWORD                           dwChar=0;
    LPWSTR                          pwsz=NULL;    
    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;


    EnterCriticalSection(&m_cSection);

    if(NULL == m_pEnrolledCert)
        goto InvalidArgErr;

    *pBstrCertName=NULL;
    
    if(0 == (SCARD_ENROLL_NO_DISPLAY_CERT & dwFlags))
    {
        //view the certificate
        memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));   

        CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
        CertViewStruct.pCertContext=m_pEnrolledCert;
        CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES | CRYPTUI_DISABLE_ADDTOSTORE;

        CryptUIDlgViewCertificate(&CertViewStruct, NULL);
    }


    dwChar=CertGetNameStringW(
        m_pEnrolledCert,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0); 

    if ((dwChar != 0) && (NULL != (pwsz = (LPWSTR)SCrdEnrollAlloc(dwChar * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
            m_pEnrolledCert,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwsz,
            dwChar);
                 
        if( NULL == (*pBstrCertName = SysAllocString(pwsz)) )
            goto MemoryErr;
    }
     
    hr=S_OK;

CommonReturn: 

    LeaveCriticalSection(&m_cSection);


    if(pwsz)
        SCrdEnrollFree(pwsz);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


STDMETHODIMP CSCrdEnr::resetUser()
{
    EnterCriticalSection(&m_cSection);

    if(m_pwszUserUPN)
    {
        SCrdEnrollFree(m_pwszUserUPN);
        m_pwszUserUPN=NULL;
    }

    if(m_pwszUserSAM)
    {
        SCrdEnrollFree(m_pwszUserSAM);
        m_pwszUserSAM=NULL;
    }                


    if(m_pEnrolledCert)
    {
        CertFreeCertificateContext(m_pEnrolledCert);
        m_pEnrolledCert=NULL;
    }
    
    LeaveCriticalSection(&m_cSection);
    
    return S_OK;

}

STDMETHODIMP CSCrdEnr::enumCSPName
       (/* [in] */                    DWORD dwIndex, 
        /* [in] */                    DWORD dwFlags, 
        /* [retval][out] */           BSTR *pbstrCSPName)
{
    HRESULT            hr= E_FAIL;
    DWORD              errBefore= GetLastError();

    EnterCriticalSection(&m_cSection);

    if(NULL == pbstrCSPName)
        goto InvalidArgErr;

    *pbstrCSPName=NULL;

    if(0 == m_dwCSPCount || NULL == m_rgCSPInfo)
        goto InvalidArgErr;

    if(dwIndex >= m_dwCSPCount)
        goto  NoItemErr;

    if( NULL == (*pbstrCSPName = SysAllocString(m_rgCSPInfo[dwIndex].pwszCSPName)))
        goto MemoryErr;
 
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(NoItemErr,ERROR_NO_MORE_ITEMS);
}


STDMETHODIMP CSCrdEnr::getUserName
       (/* [in] */                    DWORD dwFlags, 
        /* [retval][out] */           BSTR *pbstrUserName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();

    EnterCriticalSection(&m_cSection);

    if(!pbstrUserName)
        goto InvalidArgErr;

    *pbstrUserName = NULL;

    if((NULL==m_pwszUserUPN) && (NULL==m_pwszUserSAM))
        goto InvalidArgErr;

    if(SCARD_ENROLL_UPN_NAME & dwFlags)
    {
		if(NULL == m_pwszUserUPN)
			goto InvalidArgErr;

        if( NULL == (*pbstrUserName = SysAllocString(m_pwszUserUPN)))
                goto MemoryErr;
    }
	else
	{
		if(NULL == m_pwszUserSAM)
			goto InvalidArgErr;

		if( NULL == (*pbstrUserName = SysAllocString(m_pwszUserSAM)))
				goto MemoryErr;
	}

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;


SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

STDMETHODIMP CSCrdEnr::setUserName
       (/* [in] */                    DWORD dwFlags, 
        /* [in] */                    BSTR  bstrUserName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    LPWSTR                              pwszSAM=NULL;

    EnterCriticalSection(&m_cSection);

    if(!bstrUserName)
        goto InvalidArgErr;

    if(SCARD_ENROLL_UPN_NAME & dwFlags)
	{
        //the UPN name has to have a corresponding SAM name
        if(!GetName(bstrUserName, NameUserPrincipal, NameSamCompatible, &pwszSAM))
            goto TraceErr;

        if(m_pwszUserUPN)
        {
            SCrdEnrollFree(m_pwszUserUPN);
            m_pwszUserUPN=NULL;
        }

        if(m_pwszUserSAM)
        {
            SCrdEnrollFree(m_pwszUserSAM);
            m_pwszUserSAM=NULL;
        }

        if(NULL == (m_pwszUserUPN=CopyWideString(bstrUserName)))
            goto MemoryErr;

        m_pwszUserSAM=pwszSAM;

        pwszSAM = NULL;
	}
	else
    {
        if(m_pwszUserUPN)
        {
            SCrdEnrollFree(m_pwszUserUPN);
            m_pwszUserUPN=NULL;
        }

        if(m_pwszUserSAM)
        {
            SCrdEnrollFree(m_pwszUserSAM);
            m_pwszUserSAM=NULL;
        }

        if(NULL == (m_pwszUserSAM=CopyWideString(bstrUserName)))
            goto MemoryErr;

        GetName(m_pwszUserSAM,
            NameSamCompatible,
            NameUserPrincipal,
            &m_pwszUserUPN);
    }

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwszSAM)
        SCrdEnrollFree(pwszSAM);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

STDMETHODIMP CSCrdEnr::getCertTemplateCount
        (/* [in] */                   DWORD dwFlags, 
         /* [retval][out] */          long *pdwCertTemplateCount)
{
    return CertTemplateCountOrName(
                    0, //index, doesn't matter what it is
                    dwFlags,
                    pdwCertTemplateCount,
                    NULL); //count
}

STDMETHODIMP CSCrdEnr::getCertTemplateName
        (/* [in] */                   DWORD dwFlags, 
		 /* [retval][out] */          BSTR *pbstrCertTemplateName)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cSection);

    if(NULL==m_rgCTInfo || 0==m_dwCTCount)
    {
        *pbstrCertTemplateName=NULL;
        hr=E_INVALIDARG;
    }
    else
    {
		if(dwFlags & SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME)
		{
			if( NULL == (*pbstrCertTemplateName = SysAllocString(m_rgCTInfo[m_dwCTIndex].pwszCTDisplayName)))
				hr = E_OUTOFMEMORY;
		}
		else
		{
			if( NULL == (*pbstrCertTemplateName = SysAllocString(m_rgCTInfo[m_dwCTIndex].pwszCTName)))
				hr = E_OUTOFMEMORY;
		}
    }

    LeaveCriticalSection(&m_cSection);

    return(hr);  
}

STDMETHODIMP CSCrdEnr::setCertTemplateName
		(/* [in] */                   DWORD dwFlags, 
		 /* [in] */                   BSTR bstrCertTemplateName)
{
    HRESULT            hr= E_FAIL;
    DWORD              errBefore= GetLastError();

    DWORD              dwIndex=0;

    EnterCriticalSection(&m_cSection);

    if(NULL==m_rgCTInfo || 0==m_dwCTCount)
        goto InvalidArgErr;

    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
		if(dwFlags & SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME)
		{
			if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTDisplayName))
			{
				m_dwCTIndex=dwIndex;
				break;
			}
		}
		else
		{
			if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
			{
				m_dwCTIndex=dwIndex;
				break;
			}
		}
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;  

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[m_dwCTIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[m_dwCTIndex].pwszCTName,
                             &(m_rgCTInfo[m_dwCTIndex].dwCACount),
                             &(m_rgCTInfo[m_dwCTIndex].rgCAInfo));

       m_rgCTInfo[m_dwCTIndex].dwCAIndex=0;

       m_rgCTInfo[m_dwCTIndex].fCAInfo=TRUE;
    }
    
    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);    
}


HRESULT CSCrdEnr::CertTemplateCountOrName(
    IN  DWORD dwIndex, 
    IN  DWORD dwFlags, 
    OUT long *pdwCertTemplateCount,
    OUT BSTR *pbstrCertTemplateName)
{
    HRESULT hr;
    DWORD   errBefore = GetLastError();
    DWORD   dwIdx = 0;
    DWORD   dwValidCount = 0;
    BOOL    fCount;
    WCHAR  *pwszName;
    DWORD const OFFLINE_SUBJECT_NAME_FLAGS = 
                        CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
                        CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME;

    EnterCriticalSection(&m_cSection);

    if (NULL == pdwCertTemplateCount && NULL == pbstrCertTemplateName)
    {
        //can't be both
        goto InvalidParamErr;
    }

    //set flag for use of count or enum
    fCount = (NULL != pdwCertTemplateCount);

    if (fCount)
    {
        //init out
        *pdwCertTemplateCount = 0;
    }
    else
    {
        //init out
        *pbstrCertTemplateName = NULL;

        if (0 == m_dwCTCount || NULL == m_rgCTInfo)
        {
            //no templates
            goto InvalidArgErr;
        }

        if (dwIndex >= m_dwCTCount)
        {
            goto NoItemErr;
        }
    }

    //set default flags if not defined by caller
    if (0x0 == (dwFlags & SCARD_ENROLL_USER_CERT_TEMPLATE) &&
        0x0 == (dwFlags & SCARD_ENROLL_MACHINE_CERT_TEMPLATE))
    {
        //assume both machine and user
        dwFlags |= SCARD_ENROLL_USER_CERT_TEMPLATE |
                   SCARD_ENROLL_MACHINE_CERT_TEMPLATE; 
    }

    if (0x0 == (dwFlags & SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE) &&
        0x0 == (dwFlags & SCARD_ENROLL_OFFLINE_CERT_TEMPLATE)) 
    {
        //assume both enterprise and offline
        dwFlags |= SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE |
                   SCARD_ENROLL_OFFLINE_CERT_TEMPLATE; 
    }

    for (dwIdx = 0; dwIdx < m_dwCTCount; dwIdx++)
    {
        if (0x0 == (dwFlags & SCARD_ENROLL_CROSS_CERT_TEMPLATE) &&
            0 < m_rgCTInfo[dwIdx].dwRASignature)
        {
            //don't include template require signatures
            continue;
        }

        if((0x0 != (SCARD_ENROLL_USER_CERT_TEMPLATE & dwFlags) &&
            FALSE == m_rgCTInfo[dwIdx].fMachine) ||
           (0x0 != (SCARD_ENROLL_MACHINE_CERT_TEMPLATE & dwFlags) &&
            TRUE == m_rgCTInfo[dwIdx].fMachine))
        {
            if (0 != (SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE & dwFlags) &&
                0 == (OFFLINE_SUBJECT_NAME_FLAGS &
                      m_rgCTInfo[dwIdx].dwSubjectNameFlags))
            {
                //enterprise user/machine and no subject DN required
                dwValidCount++;  
            }
            else if (0 != (SCARD_ENROLL_OFFLINE_CERT_TEMPLATE & dwFlags) && 
                     0 != (OFFLINE_SUBJECT_NAME_FLAGS &
                           m_rgCTInfo[dwIdx].dwSubjectNameFlags))
            {
                //offline user/machine and subject DN required
                dwValidCount++;
            }
        }

        if (!fCount && dwValidCount == (dwIndex + 1))
        {
            //get name & hit the one by index. get display or real name 
            if (0x0 != (dwFlags & SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME))
            {
                //display name
                pwszName = m_rgCTInfo[dwIdx].pwszCTDisplayName;
            }
            else
            {
                //real name
                pwszName = m_rgCTInfo[dwIdx].pwszCTName;
            }
            *pbstrCertTemplateName = SysAllocString(pwszName);
            if (NULL == *pbstrCertTemplateName)
            {
                goto MemoryErr;
            }
            else
            {
                //done
                break;
            }
        }
    }

    if(!fCount && dwIdx == m_dwCTCount)
    {
        //go beyond
        goto  NoItemErr;
    }

    if (fCount)
    {
        *pdwCertTemplateCount = dwValidCount;
    }
 
    hr = S_OK;
CommonReturn:
    LeaveCriticalSection(&m_cSection);
    SetLastError(errBefore);
	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;
    hr = CodeToHR(errBefore);
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG)
SET_ERROR(InvalidParamErr, HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
SET_ERROR(MemoryErr, E_OUTOFMEMORY)
SET_ERROR(NoItemErr,ERROR_NO_MORE_ITEMS)
}

STDMETHODIMP CSCrdEnr::enumCertTemplateName       
       (/* [in] */                    DWORD dwIndex, 
        /* [in] */                    DWORD dwFlags, 
        /* [retval][out] */           BSTR *pbstrCertTemplateName)
{
    return CertTemplateCountOrName(
                dwIndex,
                dwFlags,
                NULL,  //get name
                pbstrCertTemplateName);
}

HRESULT CSCrdEnr::_getCertTemplateExtensionInfo(
    IN CERT_EXTENSIONS  *pCertTypeExtensions,
    IN LONG              lType,
    OUT VOID            *pExtInfo)
{
    HRESULT  hr;
    DWORD    cwc = 0;
    DWORD    dwCTE;
    DWORD    i;
    BOOL     fV2 = FALSE; //default v1 template
    BOOL     fDword = TRUE;
    DWORD    dwValue;

    EnterCriticalSection(&m_cSection);

    if (NULL == m_pCachedCTEs || m_pCachedCTEs != pCertTypeExtensions)
    {
        //new template, don't use cache
        //free the current cache if any
        if (NULL != m_pwszCachedCTEOid)
        {
            LocalFree(m_pwszCachedCTEOid);
            m_pwszCachedCTEOid = NULL;
        }
        if (NULL != m_pCachedCTE)
        {
            LocalFree(m_pCachedCTE);
            m_pCachedCTE = NULL;
        }
        //reset extension pointer
        m_pCachedCTEs = NULL;

        //loop to find CT extension
        for (i = 0; i < pCertTypeExtensions->cExtension; ++i)
        {
            if (0 == _stricmp(pCertTypeExtensions->rgExtension[i].pszObjId,
                              szOID_CERTIFICATE_TEMPLATE))
            {
                //v2 template
                fV2 = TRUE;
                //cache it
                m_pCachedCTEs = pCertTypeExtensions;
                break;
            }
        }

        if (!fV2)
        {
            //v1 template, return empty string
            m_pwszCachedCTEOid = (WCHAR*)LocalAlloc(LMEM_FIXED, sizeof(WCHAR));
            if (NULL == m_pwszCachedCTEOid)
            {
                hr = E_OUTOFMEMORY;
                goto MemoryErr;
            }
            m_pwszCachedCTEOid[0] = L'\0';
        }
        else
        {
            //decode cert template extension
            if (!CryptDecodeObjectEx(
                        X509_ASN_ENCODING,
                        X509_CERTIFICATE_TEMPLATE,
                        pCertTypeExtensions->rgExtension[i].Value.pbData,
                        pCertTypeExtensions->rgExtension[i].Value.cbData,
                        CRYPT_DECODE_ALLOC_FLAG,
                        NULL,     //use default LocalAlloc
                        (void*)&m_pCachedCTE,
                        &dwCTE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto CryptDecodeObjectExErr;
            }

            //have to convert asn to wchar
            while (TRUE)
            {
                cwc = MultiByteToWideChar(
                            GetACP(),
                            0,
                            m_pCachedCTE->pszObjId,
                            -1,
                            m_pwszCachedCTEOid,
                            cwc);
                if (0 >= cwc)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto MultiByteToWideCharErr;
                }
                if (NULL != m_pwszCachedCTEOid)
                {
                    //done
                    break;
                }
                m_pwszCachedCTEOid = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                            cwc * sizeof(WCHAR));
                if (NULL == m_pwszCachedCTEOid)
                {
                    hr = E_OUTOFMEMORY;
                    goto MemoryErr;
                }
            }
        }
    }

    //hit here, either from cached or new cache
    switch (lType)
    {
        case SCARD_CTINFO_EXT_OID:
            *(WCHAR**)pExtInfo = m_pwszCachedCTEOid;
        break;
        case SCARD_CTINFO_EXT_MAJOR:
            if (NULL != m_pCachedCTE)
            {
                *(LONG*)pExtInfo = m_pCachedCTE->dwMajorVersion;
            }
            else
            {
                //must be v1
                *(LONG*)pExtInfo = 0;
            }
        break;
        case SCARD_CTINFO_EXT_MINOR:
            if (NULL != m_pCachedCTE)
            {
                *(LONG*)pExtInfo = m_pCachedCTE->dwMinorVersion;
            }
            else
            {
                //must be v1
                *(LONG*)pExtInfo = 0;
            }
        break;
        case SCARD_CTINFO_EXT_MINOR_FLAG:
            if (NULL != m_pCachedCTE)
            {
                *(LONG*)pExtInfo = m_pCachedCTE->fMinorVersion;
            }
            else
            {
                //must be v1
                *(LONG*)pExtInfo = 0;
            }
        break;
        default:
            hr = E_INVALIDARG;
            goto InvalidArgError;
    }

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_cSection);
    return hr;

TRACE_ERROR(CryptDecodeObjectExErr)
TRACE_ERROR(MemoryErr)
TRACE_ERROR(MultiByteToWideCharErr)
TRACE_ERROR(InvalidArgError)
}

HRESULT CSCrdEnr::_getStrCertTemplateCSPList(
    IN DWORD             dwIndex,
    IN DWORD             dwFlag,
    OUT WCHAR          **ppwszSupportedCSP)
{
    HRESULT  hr;
    DWORD    i;
    WCHAR  **ppwsz;
    WCHAR   *pwszOut = NULL;

    EnterCriticalSection(&m_cSection);

    //init
    *ppwszSupportedCSP = NULL;

    if (SCARD_CTINFO_CSPLIST_FIRST == dwFlag)
    {
        //reset to first
        m_rgCTInfo[dwIndex].dwCurrentCSP = 0;
    }

    //get it
    ppwsz = m_rgCTInfo[dwIndex].rgpwszSupportedCSPs;
    for (i = 0; i < m_rgCTInfo[dwIndex].dwCurrentCSP && NULL != *ppwsz; ++i)
    {
        ++ppwsz;
    }
    if (NULL == *ppwsz)
    {
        //hit the end
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto NoMoreItemsErr;
    }        

    // allocate buffer
    pwszOut = (WCHAR*)LocalAlloc(LMEM_FIXED, (wcslen(*ppwsz) + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
        hr = E_OUTOFMEMORY;
        goto MemoryErr;
    }

    //copy string
    wcscpy(pwszOut, *ppwsz);
    *ppwszSupportedCSP = pwszOut;
    pwszOut = NULL;
    ++m_rgCTInfo[dwIndex].dwCurrentCSP;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_cSection);
    if (NULL != pwszOut)
    {
        LocalFree(pwszOut);
    }
    return hr;

TRACE_ERROR(MemoryErr)
TRACE_ERROR(NoMoreItemsErr)
}

STDMETHODIMP CSCrdEnr::getCertTemplateInfo(
    /* [in] */                   BSTR     bstrCertTemplateName, 
    /* [in] */                   LONG     lType,
    /* [retval][out] */          VARIANT *pvarCertTemplateInfo)
{
    HRESULT hr;
    DWORD   dwIndex;
    WCHAR  *pwszInfo = NULL;
    BOOL    fFound = FALSE;
    DWORD   dwCSPFlag = SCARD_CTINFO_CSPLIST_NEXT;
    LONG    lInfo;
    BOOL    fStr = FALSE; //default to long
    BOOL    fFree = TRUE;
    VARIANT varInfo;

    ZeroMemory(&varInfo, sizeof(varInfo));

    EnterCriticalSection(&m_cSection);

    if (NULL == bstrCertTemplateName ||
        0 == m_dwCTCount ||
        NULL == m_rgCTInfo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParamErr;
    }

    //get the CT information
    for (dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if (0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
        {
            // found it
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        //likely pass incorrect template name
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto NotFoundErr;
    }

    switch (lType)
    {
        case SCARD_CTINFO_KEYSPEC:
            lInfo = m_rgCTInfo[dwIndex].dwKeySpec;
        break;
        case SCARD_CTINFO_KEYFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwGenKeyFlags;
            break;
        case SCARD_CTINFO_EXT_OID:
            hr = _getCertTemplateExtensionInfo(
                        m_rgCTInfo[dwIndex].pCertTypeExtensions,
                        lType,
                        &pwszInfo);
            if (S_OK != hr)
            {
                goto _getCertTemplateExtensionInfoErr;
            }
            fStr = TRUE;
            fFree = FALSE; //don't free cache
        break;
        case SCARD_CTINFO_EXT_MAJOR:
        case SCARD_CTINFO_EXT_MINOR:
        case SCARD_CTINFO_EXT_MINOR_FLAG:
            hr = _getCertTemplateExtensionInfo(
                        m_rgCTInfo[dwIndex].pCertTypeExtensions,
                        lType,
                        &lInfo);
            if (S_OK != hr)
            {
                goto _getCertTemplateExtensionInfoErr;
            }
        break;
        case SCARD_CTINFO_CSPLIST_FIRST:
            dwCSPFlag = SCARD_CTINFO_CSPLIST_FIRST;
            //fall through
        case SCARD_CTINFO_CSPLIST_NEXT:
            hr = _getStrCertTemplateCSPList(dwIndex, dwCSPFlag, &pwszInfo);
            if (S_OK != hr)
            {
                goto _getStrCertTemplateCSPListErr;
            }
            fStr = TRUE;
        break;
        case SCARD_CTINFO_SUBJECTFLAG:
            lInfo = m_rgCTInfo[dwIndex].dwSubjectNameFlags;
            break;
        case SCARD_CTINFO_GENERALFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwGeneralFlags;
            break;
        case SCARD_CTINFO_ENROLLMENTFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwEnrollmentFlags;
            break;
        case SCARD_CTINFO_PRIVATEKEYFLAGS:
            lInfo = m_rgCTInfo[dwIndex].dwPrivateKeyFlags;
            break;
        case SCARD_CTINFO_RA_SIGNATURES:
            lInfo = m_rgCTInfo[dwIndex].dwRASignature;
            break;
        default:
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto InvalidParamErr;
    }

    if (fStr)
    {
        varInfo.vt = VT_BSTR;
        varInfo.bstrVal = SysAllocString(pwszInfo);
        if (NULL == varInfo.bstrVal)
        {
            hr = E_OUTOFMEMORY;
            goto MemoryErr;
        }
    }
    else
    {
        varInfo.vt = VT_I4;
        varInfo.lVal = lInfo;
    }
    //return
    *pvarCertTemplateInfo = varInfo;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_cSection);
    if (fFree && NULL != pwszInfo)
    {
        LocalFree(pwszInfo);
    }
    return hr;

TRACE_ERROR(InvalidParamErr)
TRACE_ERROR(NotFoundErr)
TRACE_ERROR(MemoryErr)
TRACE_ERROR(_getCertTemplateExtensionInfoErr)
TRACE_ERROR(_getStrCertTemplateCSPListErr)
}

STDMETHODIMP CSCrdEnr::getCACount
       (/* [in] */                    BSTR bstrCertTemplateName, 
        /* [retval][out] */           long *pdwCACount)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwIndex=0;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == pdwCACount)
        goto InvalidArgErr;

    *pdwCACount=0;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
            break;
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwIndex].pwszCTName,
                             &(m_rgCTInfo[dwIndex].dwCACount),
                             &(m_rgCTInfo[dwIndex].rgCAInfo));

       m_rgCTInfo[dwIndex].dwCAIndex=0;

       m_rgCTInfo[dwIndex].fCAInfo=TRUE;
    }

    *pdwCACount = (long)m_rgCTInfo[dwIndex].dwCACount;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

STDMETHODIMP CSCrdEnr::getCAName
       (/* [in] */                    DWORD dwFlags,
        /* [in] */                    BSTR bstrCertTemplateName, 
        /* [retval][out] */           BSTR *pbstrCAName)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwIndex=0;
	LPWSTR				pwszName=NULL;

    SCrdEnroll_CT_INFO  *pCTInfo=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == pbstrCAName)
        goto InvalidArgErr;

    *pbstrCAName=NULL;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
            break;
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwIndex].pwszCTName,
                             &(m_rgCTInfo[dwIndex].dwCACount),
                             &(m_rgCTInfo[dwIndex].rgCAInfo));

       m_rgCTInfo[dwIndex].dwCAIndex=0;

       m_rgCTInfo[dwIndex].fCAInfo=TRUE;
    }

    pCTInfo=&(m_rgCTInfo[dwIndex]);

    if(NULL == pCTInfo->rgCAInfo)
        goto InvalidArgErr;


	if(!RetrieveCAName(dwFlags, &(pCTInfo->rgCAInfo[pCTInfo->dwCAIndex]), &pwszName))
		goto TraceErr;					 

    if(NULL == (*pbstrCAName = SysAllocString(pwszName)))
        goto MemoryErr;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

	if(pwszName)
		SCrdEnrollFree(pwszName);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

STDMETHODIMP CSCrdEnr::setCAName
       (/* [in] */                    DWORD dwFlags,
        /* [in] */                    BSTR bstrCertTemplateName, 
        /* [in] */                    BSTR bstrCAName)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwIndex=0;
    DWORD               dwCAIndex=0;
	LPWSTR				pwszName=NULL;

    SCrdEnroll_CT_INFO  *pCTInfo=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == bstrCAName)
        goto InvalidArgErr;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwIndex=0; dwIndex < m_dwCTCount; dwIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwIndex].pwszCTName))
            break;
    }

    if(dwIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwIndex].pwszCTName,
                             &(m_rgCTInfo[dwIndex].dwCACount),
                             &(m_rgCTInfo[dwIndex].rgCAInfo));

       m_rgCTInfo[dwIndex].dwCAIndex=0;

       m_rgCTInfo[dwIndex].fCAInfo=TRUE;
    }

    pCTInfo=&(m_rgCTInfo[dwIndex]);

    if(NULL == pCTInfo->rgCAInfo)
        goto InvalidArgErr;


    //search for the CA specified in the input
    for(dwCAIndex=0; dwCAIndex < pCTInfo->dwCACount; dwCAIndex++)
    {

		if(!RetrieveCAName(dwFlags, &(pCTInfo->rgCAInfo[dwCAIndex]), &pwszName))
			continue;

		if(0 == _wcsicmp(pwszName, bstrCAName))
                break;

		SCrdEnrollFree(pwszName);
		pwszName=NULL;
    }

    if(dwCAIndex == pCTInfo->dwCACount)
        goto InvalidArgErr;

    //remember the selected CA by its index
    pCTInfo->dwCAIndex = dwCAIndex;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

	if(pwszName)
		SCrdEnrollFree(pwszName);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

STDMETHODIMP CSCrdEnr::enumCAName
       (/* [in] */                    DWORD dwIndex, 
        /* [in] */                    DWORD dwFlags, 
        /* [in] */                    BSTR  bstrCertTemplateName, 
        /* [retval][out] */           BSTR  *pbstrCAName)
{
    HRESULT             hr= E_FAIL;
    DWORD               errBefore= GetLastError();
    DWORD               dwCTIndex=0;
	LPWSTR				pwszName=NULL;

    SCrdEnroll_CT_INFO  *pCTInfo=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == bstrCertTemplateName || NULL == pbstrCAName)
        goto InvalidArgErr;

    *pbstrCAName=NULL;

    if(0 == m_dwCTCount || NULL == m_rgCTInfo)
        goto InvalidArgErr;

    //get the CT information
    for(dwCTIndex=0; dwCTIndex < m_dwCTCount; dwCTIndex++)
    {
        if(0 == _wcsicmp(bstrCertTemplateName, m_rgCTInfo[dwCTIndex].pwszCTName))
            break;
    }

    if(dwCTIndex == m_dwCTCount)
        goto InvalidArgErr;

    //we need to get the CA information for the newly selected cert type
    if(FALSE == m_rgCTInfo[dwCTIndex].fCAInfo)
    {
       GetCAInfoFromCertType(NULL,
							 m_rgCTInfo[dwCTIndex].pwszCTName,
                             &(m_rgCTInfo[dwCTIndex].dwCACount),
                             &(m_rgCTInfo[dwCTIndex].rgCAInfo));

       m_rgCTInfo[dwCTIndex].dwCAIndex=0;

       m_rgCTInfo[dwCTIndex].fCAInfo=TRUE;
    }

    pCTInfo=&(m_rgCTInfo[dwCTIndex]);

    //search for the CA specified in the input
    if(dwIndex >= pCTInfo->dwCACount)
        goto InvalidArgErr;


	if(!RetrieveCAName(dwFlags, &(pCTInfo->rgCAInfo[dwIndex]), &pwszName))
		goto TraceErr;

    if(NULL == (*pbstrCAName = SysAllocString(pwszName)))
        goto MemoryErr;

    hr=S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

	if(pwszName)
		SCrdEnrollFree(pwszName);
    
    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

STDMETHODIMP CSCrdEnr::getSigningCertificateName
        (/* [in] */                   DWORD dwFlags, 
         /* [retval][out] */          BSTR  *pbstrSigningCertName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    DWORD                               dwChar=0;
    LPWSTR                              pwsz=NULL; 
    CRYPTUI_VIEWCERTIFICATE_STRUCT      CertViewStruct;

    *pbstrSigningCertName=NULL;

    EnterCriticalSection(&m_cSection);

    if(NULL == m_pSigningCert)
        goto InvalidArgErr;
   
    if(0 == (SCARD_ENROLL_NO_DISPLAY_CERT & dwFlags))
    {
        //view the certificate
        memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));   

        CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
        CertViewStruct.pCertContext=m_pSigningCert;
        CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES | CRYPTUI_DISABLE_ADDTOSTORE;

        CryptUIDlgViewCertificate(&CertViewStruct, NULL); 
    }


    dwChar=CertGetNameStringW(
        m_pSigningCert,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0); 

    if ((dwChar != 0) && (NULL != (pwsz = (LPWSTR)SCrdEnrollAlloc(dwChar * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
            m_pSigningCert,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwsz,
            dwChar);
             
        if( NULL == (*pbstrSigningCertName = SysAllocString(pwsz)))
            goto MemoryErr;
    }

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwsz)
        SCrdEnrollFree(pwsz);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


/*STDMETHODIMP CSCrdEnr::getSubjectNameFromPKCS10
        (     [in]              BSTR      bstrPKCS10, 
              [in]				DWORD     dwFlags, 
              [in]              BSTR      bstrAttrOID, 
              [retval][out]		BSTR      *pbstrName)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    DWORD                               cbData=0;

    LPSTR                               pszOID=NULL;
    BYTE                                *pbData=NULL;
    LPWSTR                              pwszName=NULL;

    if(NULL == bstrPKCS10 || NULL == bstrAttrOID || NULL == pbstrName)
        goto InvalidArgErr;

    *pbstrName=NULL;

    if(!MkMBStr(NULL, 0, bstrAttrOID, &pszOID))
        goto TraceErr;

    if(!DecodeBlobW(bstrPKCS10,
                    SysStringLen(bstrPKCS10),
                    &pbData,
                    &cbData))
        goto TraceErr;

    
    if(!GetNameFromPKCS10(pbData, cbData, dwFlags, pszOID, &pwszName))
        goto TraceErr;

    if( NULL == (*pbstrName = SysAllocString(pwszName)))
        goto MemoryErr;

    hr= S_OK;

CommonReturn:

    if(pszOID)
        FreeMBStr(NULL,pszOID);

    if(pbData)
        SCrdEnrollFree(pbData);

    if(pwszName)
        SCrdEnrollFree(pwszName);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


STDMETHODIMP CSCrdEnr::generatePKCS7FromRequest
        ( [in]                    DWORD     dwFlags, 
          [in]                    BSTR      bstrRequest, 
          [retval][out]           BSTR      *pbstrPKCS7)
{
    HRESULT                             hr= E_FAIL;
    DWORD                               errBefore= GetLastError();
    DWORD                               cbData=0;
    CRYPT_DATA_BLOB                     RequestBlob;
    DWORD                               dwEncodeFlag = 0;


    BYTE                                *pbData=NULL;
    IEnroll                             *pIEnroll=NULL;
    LPWSTR                              pwszRequesterName=NULL;
    CRYPT_DATA_BLOB                     PKCS7Request;
    LPWSTR                              pwszRequest=NULL;

    memset(&RequestBlob,    0, sizeof(CRYPT_DATA_BLOB));
    memset(&PKCS7Request,   0, sizeof(CRYPT_DATA_BLOB));

    EnterCriticalSection(&m_cSection);

    if(!bstrRequest || !pbstrPKCS7 || !m_pSigningCert || !m_pwszUserSAM)
        goto InvalidArgErr;


    *pbstrPKCS7 = NULL;

    if(!DecodeBlobW(bstrRequest,
                    SysStringLen(bstrRequest),
                    &pbData,
                    &cbData))
        goto TraceErr;

    if(NULL == (pIEnroll=PIEnrollGetNoCOM()))
        goto TraceErr;

    RequestBlob.cbData = cbData;
    RequestBlob.pbData = pbData;

    //add the name value pair of the enroll-on-behalf
    pwszRequesterName=MkWStr(wszPROPREQUESTERNAME);

    if(NULL==pwszRequesterName)
        goto MemoryErr;

    if(S_OK != (hr=pIEnroll->AddNameValuePairToSignatureWStr( 
           pwszRequesterName, m_pwszUserSAM)))
        goto TraceErr;


    //sign the request
    if(S_OK != (hr=pIEnroll->CreatePKCS7RequestFromRequest( 
            &RequestBlob,
            m_pSigningCert,
            &PKCS7Request)))
        goto TraceErr;

    //encode the request
    dwEncodeFlag = GetEncodeFlag(dwFlags);

    cbData =0;

    if(!EncodeBlobW(PKCS7Request.pbData,
                    PKCS7Request.cbData,
                    dwEncodeFlag,
                    &pwszRequest,
                    &cbData))
        goto TraceErr;

    if( NULL == (*pbstrPKCS7 = SysAllocString(pwszRequest)))
        goto MemoryErr;

    hr= S_OK;

CommonReturn:

    LeaveCriticalSection(&m_cSection);

    if(pwszRequesterName)
        FreeWStr(pwszRequesterName);
    
    //the memory from xEnroll is freed via LocalFree
    //since we use the PIEnrollGetNoCOM function
    if(PKCS7Request.pbData)
        LocalFree(PKCS7Request.pbData);

    if(pIEnroll)
        pIEnroll->Release();

    if(pbData)
        SCrdEnrollFree(pbData);

    if(pwszRequest)
        SCrdEnrollFree(pwszRequest);

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}	  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\enrlhelp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       enrlhelp.cpp
//
//  Contents:   Helper functions for smard card enrollment station
//
//----------------------------------------------------------------------------
#define INC_OLE2
#define SECURITY_WIN32  //Or in the sources file -DSECURITY_WIN32

#include "stdafx.h"
#include <windows.h>
#include <wincrypt.h>
#include <oleauto.h>
#include <objbase.h>
#include "security.h"
#include "certca.h"              
#include <dbgdef.h>
#include "unicode.h"

#include "scrdenrl.h"
#include "SCrdEnr.h"
#include "xEnroll.h"
#include "enrlhelp.h"  
#include "scenum.h"
#include "wzrdpvk.h"

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

//-----------------------------------------------------------------------------
//  Memory routines
//
//-----------------------------------------------------------------------------
void*
MIDL_user_allocate(size_t cb)
{
    return(SCrdEnrollAlloc(cb));
}

void
MIDL_user_free(void *pb)
{
    SCrdEnrollFree(pb);
}

LPVOID  SCrdEnrollAlloc (ULONG cbSize)
{
    return CoTaskMemAlloc(cbSize);
}


LPVOID  SCrdEnrollRealloc (
        LPVOID pv,
        ULONG cbSize)
{
    LPVOID  pvTemp=NULL;

    if(NULL==pv)
        return CoTaskMemAlloc(cbSize);

    return CoTaskMemRealloc(pv, cbSize);
}

VOID    SCrdEnrollFree (LPVOID pv)
{
    if (pv)
        CoTaskMemFree(pv);
}


BOOL CertTypeFlagsToGenKeyFlags(IN OPTIONAL DWORD dwEnrollmentFlags,
				IN OPTIONAL DWORD dwSubjectNameFlags,
				IN OPTIONAL DWORD dwPrivateKeyFlags,
				IN OPTIONAL DWORD dwGeneralFlags, 
				OUT DWORD *pdwGenKeyFlags)
{
    // Define a locally scoped helper function.  This allows us to gain the benefits of procedural
    // abstraction without corrupting the global namespace.  
    // 
    LocalScope(CertTypeMap): 
	// Maps cert type flags of one category (enrollment flags, private key flags, etc...)
	// to their corresponding gen key flags.  This function always returns successfully.  
	// 
	DWORD mapOneCertTypeCategory(IN DWORD dwOption, IN DWORD dwCertTypeFlags) 
	{ 
	    static DWORD const rgdwEnrollmentFlags[][2] = { 
		{ 0, 0 } // No enrollment flags mapped. 
	    }; 
	    static DWORD const rgdwSubjectNameFlags[][2] = { 
		{ 0, 0 } // No subject name flags mapped. 
	    }; 
	    static DWORD const rgdwPrivateKeyFlags[][2]   = { 
		{ CT_FLAG_EXPORTABLE_KEY, CRYPT_EXPORTABLE } 
	    }; 
	    static DWORD const rgdwGeneralFlags[][2] = { 
		{ 0, 0 } // No general flags mapped. 
	    }; 
	    
	    static DWORD const dwEnrollmentLen  = sizeof(rgdwEnrollmentFlags)  / sizeof(DWORD[2]); 
	    static DWORD const dwSubjectNameLen = sizeof(rgdwSubjectNameFlags) / sizeof(DWORD[2]); 
	    static DWORD const dwPrivateKeyLen  = sizeof(rgdwPrivateKeyFlags)  / sizeof(DWORD[2]); 
	    static DWORD const dwGeneralLen     = sizeof(rgdwGeneralFlags)     / sizeof(DWORD[2]); 
	    
	    static DWORD const CERT_TYPE_INDEX  = 0; 
	    static DWORD const GEN_KEY_INDEX    = 1;

	    DWORD const  *pdwFlags; 
	    DWORD         dwLen, dwIndex, dwResult = 0; 

	    switch (dwOption)
	    {

	    case CERTTYPE_ENROLLMENT_FLAG:    
		pdwFlags = &rgdwEnrollmentFlags[0][0]; 
		dwLen    = dwEnrollmentLen; 
		break;
	    case CERTTYPE_SUBJECT_NAME_FLAG:  
		pdwFlags = &rgdwSubjectNameFlags[0][0]; 
		dwLen    = dwSubjectNameLen; 
		break;
	    case CERTTYPE_PRIVATE_KEY_FLAG:   
		pdwFlags = &rgdwPrivateKeyFlags[0][0]; 
		dwLen    = dwPrivateKeyLen;
		break;
	    case CERTTYPE_GENERAL_FLAG:       
		pdwFlags = &rgdwGeneralFlags[0][0]; 
		dwLen    = dwGeneralLen;
		break;
	    }
	    
	    for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
	    {
		if (0 != (pdwFlags[CERT_TYPE_INDEX] & dwCertTypeFlags))
		{
		    dwResult |= pdwFlags[GEN_KEY_INDEX]; 
		}
		pdwFlags += 2; 
	    }
	    
	    return dwResult; 
	}
    EndLocalScope; 

    //
    // Begin procedure body: 
    //

    BOOL   fResult; 
    DWORD  dwResult = 0; 
    DWORD  dwErr    = ERROR_SUCCESS; 
	
    // Input parameter validation: 
    _JumpConditionWithExpr(pdwGenKeyFlags == NULL, Error, dwErr = ERROR_INVALID_PARAMETER); 

    // Compute the gen key flags using the locally scope function.  
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_ENROLLMENT_FLAG, dwEnrollmentFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_SUBJECT_NAME_FLAG, dwSubjectNameFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_PRIVATE_KEY_FLAG, dwPrivateKeyFlags);
    dwResult |= local.mapOneCertTypeCategory(CERTTYPE_GENERAL_FLAG, dwGeneralFlags); 

    // Assign the out parameter: 
    *pdwGenKeyFlags = dwResult; 

    fResult = TRUE; 

 CommonReturn: 
    return fResult;

 Error: 
    fResult = FALSE; 
    SetLastError(dwErr); 
    goto CommonReturn; 
}

//----------------------------------------------------------------------------
//  CallBack fro cert selection call back
//
//----------------------------------------------------------------------------
BOOL WINAPI SelectSignCertCallBack(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData)
{
    BOOL                            fRet = FALSE;
    DWORD                           cbData=0;
    SCrdEnroll_CERT_SELECT_INFO     *pCertSelectInfo;
    PCERT_ENHKEY_USAGE              pUsage = NULL;
    CHAR                            *pszOID = NULL;
    DWORD                           i;
    BOOL                            fFoundOid;

    if(!pCertContext)
    {
        goto done;
    }

    //the certificate has to have the CERT_KEY_PROV_INFO_PROP_ID
    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
    {
        goto done;
    }

    if(0==cbData)
    {
        goto done;
    }

    pCertSelectInfo = (SCrdEnroll_CERT_SELECT_INFO *)pvCallbackData;
    if(NULL == pCertSelectInfo)
    {
        goto done;
    }

    if (NULL == pCertSelectInfo->pwszCertTemplateName ||
        L'\0' == pCertSelectInfo->pwszCertTemplateName[0])
    {
        goto done;
    }

    switch (pCertSelectInfo->dwFlags)
    {
        case SCARD_SELECT_TEMPLATENAME:
            //ask to check template name
            if(!VerifyCertTemplateName(
                    pCertContext,
                    pCertSelectInfo->pwszCertTemplateName))
            {
                goto done;
            }
        break;
        case SCARD_SELECT_EKU:
            cbData = 0;
            while (TRUE)
            {
                cbData = WideCharToMultiByte(
                                GetACP(),
                                0,
                                pCertSelectInfo->pwszCertTemplateName,
                                -1,
                                pszOID,
                                cbData,
                                NULL,
                                NULL);
                if(0 == cbData)
                {
                    goto done;
                }
                if (NULL != pszOID)
                {
                    break;
                }
                pszOID = (CHAR*)LocalAlloc(LMEM_FIXED, cbData);
                if (NULL == pszOID)
                {
                    goto done;
                }
            }
            cbData = 0;
            while (TRUE)
            {
                if (!CertGetEnhancedKeyUsage(
                        pCertContext,
                        CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                        pUsage,
                        &cbData))
                {
                    goto done;
                }
                if (NULL != pUsage)
                {
                    //done
                    break;
                }
                pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LMEM_FIXED, cbData);
                if (NULL == pUsage)
                {
                    goto done;
                }
            }
            fFoundOid = FALSE;
            for (i = 0 ; i < pUsage->cUsageIdentifier; ++i)
            {
                if (0 == strcmp(pszOID, pUsage->rgpszUsageIdentifier[i]))
                {
                    fFoundOid = TRUE;
                    break;
                }
            }
            if (!fFoundOid)
            {
                //not found
                goto done;
            }
        break;
        default:
            //invalid_parameter
            goto done;
    }

    //make sure the certificate pass the chain building
    if(!VerifyCertChain(pCertContext))
    {
        goto done;
    }

    fRet = TRUE;    
done:
    if (NULL != pUsage)
    {
        LocalFree(pUsage);
    }
    if (NULL != pszOID)
    {
        LocalFree(pszOID);
    }
    return fRet;
}

//-------------------------------------------------------------------------
// GetName
//
//--------------------------------------------------------------------------
BOOL    GetName(LPWSTR                  pwszName,
                EXTENDED_NAME_FORMAT    NameFormat,
                EXTENDED_NAME_FORMAT    DesiredFormat,
                LPWSTR                  *ppwszDesiredName)
{
    BOOL                                fResult = FALSE;
    DWORD                               cbSize = 0;

    *ppwszDesiredName = NULL;

    if(!TranslateNameW(
        pwszName,
        NameFormat,
        DesiredFormat,
        NULL,
        &cbSize))
        goto TraceErr;

    *ppwszDesiredName=(LPWSTR)SCrdEnrollAlloc((cbSize + 1) * sizeof(WCHAR));

    if(NULL == *ppwszDesiredName)
        goto MemoryErr;

    if(!TranslateNameW(
        pwszName,
        NameFormat,
        DesiredFormat,
        *ppwszDesiredName,
        &cbSize))
        goto TraceErr; 

    fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppwszDesiredName)
    {
        SCrdEnrollFree(*ppwszDesiredName);
        *ppwszDesiredName = NULL;
    }
   
    fResult = FALSE;

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}


//-------------------------------------------------------------------------
// VerifyCertChain
//
//--------------------------------------------------------------------------
BOOL    VerifyCertChain(PCCERT_CONTEXT      pCertContext)
{
    
	PCCERT_CHAIN_CONTEXT		pCertChainContext = NULL;
	CERT_CHAIN_PARA				CertChainPara;
	BOOL                        fResult=FALSE;
    DWORD                       dwChainError=CERT_TRUST_IS_NOT_TIME_VALID |        
                                                CERT_TRUST_IS_NOT_TIME_NESTED |     
                                                CERT_TRUST_IS_REVOKED |               
                                                CERT_TRUST_IS_NOT_SIGNATURE_VALID |    
                                                CERT_TRUST_IS_NOT_VALID_FOR_USAGE |   
                                                CERT_TRUST_IS_UNTRUSTED_ROOT |        
                                                CERT_TRUST_IS_CYCLIC |
                                                CERT_TRUST_IS_PARTIAL_CHAIN |          
                                                CERT_TRUST_CTL_IS_NOT_TIME_VALID |     
                                                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID |
                                                CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;                

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				HCCE_CURRENT_USER,
				pCertContext,
				NULL,
                NULL,
				&CertChainPara,
				CERT_CHAIN_REVOCATION_CHECK_CHAIN,
				NULL,
				&pCertChainContext))
        goto CLEANUP;
    
	//
	// make sure there is at least 1 simple chain
	//
    if (pCertChainContext->cChain == 0)
        goto CLEANUP;

    // make sure that we have a good simple chain
    if(dwChainError & (pCertChainContext->rgpChain[0]->TrustStatus.dwErrorStatus))
        goto CLEANUP;
    
    fResult = TRUE;
	
CLEANUP:

	if (pCertChainContext != NULL)
		CertFreeCertificateChain(pCertChainContext);

	return fResult;
}

//-------------------------------------------------------------------------
//  VerifyCertTemplateName
//
//--------------------------------------------------------------------------
BOOL    VerifyCertTemplateName(PCCERT_CONTEXT   pCertContext, 
                               LPWSTR           pwszCertTemplateName)
{
    BOOL                    fResult=FALSE;
    PCERT_EXTENSION         pCertTypeExtension=NULL;
    DWORD                   cbCertType=0;
    CERT_NAME_VALUE         *pCertType=NULL;


    if((!pCertContext) || (!pwszCertTemplateName))
        goto CLEANUP;

    //find the extension for cert type
    if(NULL==(pCertTypeExtension=CertFindExtension(
                          szOID_ENROLL_CERTTYPE_EXTENSION,
                          pCertContext->pCertInfo->cExtension,
                          pCertContext->pCertInfo->rgExtension)))
        goto CLEANUP;

    if(!CryptDecodeObject(pCertContext->dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            pCertTypeExtension->Value.pbData,
            pCertTypeExtension->Value.cbData,
            0,
            NULL,
            &cbCertType) || (0==cbCertType))
        goto CLEANUP;


    pCertType=(CERT_NAME_VALUE *)SCrdEnrollAlloc(cbCertType);

    if(NULL==pCertType)
        goto CLEANUP;

    if(!CryptDecodeObject(pCertContext->dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            pCertTypeExtension->Value.pbData,
            pCertTypeExtension->Value.cbData,
            0,
            (void *)pCertType,
            &cbCertType))
        goto CLEANUP;

    if(0 != _wcsicmp((LPWSTR)(pCertType->Value.pbData), pwszCertTemplateName))
        goto CLEANUP;

    fResult=TRUE;


CLEANUP:

    if(pCertType)
        SCrdEnrollFree(pCertType);

    return fResult;
}



//----------------------------------------------------------------------------
//
//  CopyWideString
//
//----------------------------------------------------------------------------
LPWSTR CopyWideString(LPCWSTR wsz)
{

    DWORD   cch     = 0;
    LPWSTR  wszOut  = NULL;

    if(wsz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    cch = wcslen(wsz) + 1;

    if( (wszOut = (LPWSTR) SCrdEnrollAlloc(sizeof(WCHAR) * cch)) == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    wcscpy(wszOut, wsz);

    return(wszOut);
}

//----------------------------------------------------------------------------
//
//  CopyWideStrings
//
//----------------------------------------------------------------------------
LPWSTR* CopyWideStrings(LPWSTR* rgpwsz)
{

    DWORD    dwCount = 1;
    DWORD    dwIndex = 0;
    DWORD    cb = 0;
    LPWSTR  *ppwsz;
    LPWSTR  *rgpwszOut = NULL;
    LPWSTR   pwszCur;

    if (NULL != rgpwsz)
    {
        //get count of strings
        for (ppwsz = rgpwsz; NULL != *ppwsz; ppwsz++)
        {
            ++dwCount;
            cb += (wcslen(*ppwsz) + 1) * sizeof(WCHAR);
        }
    }

    // allocate buffer
    rgpwszOut = (LPWSTR*)SCrdEnrollAlloc(dwCount * sizeof(WCHAR*) + cb);
    if (NULL == rgpwszOut)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto error;
    }

    if (NULL != rgpwsz)
    {
        pwszCur = (LPWSTR)(rgpwszOut + dwCount);

        for(ppwsz = rgpwsz; NULL != *ppwsz; ppwsz++)
        {
            rgpwszOut[dwIndex] = pwszCur;
            wcscpy(pwszCur, *ppwsz);
            pwszCur += wcslen(pwszCur) + 1;
            ++dwIndex;
        }
    }
    rgpwszOut[dwIndex] = NULL;

error:
    return(rgpwszOut);
}

//--------------------------------------------------------------------------
//
//	  Decode a generic BLOB
//
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo)
{
	DWORD	cbStructInfo=0;

	//decode the object.  No copying
	if(!CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,NULL,	&cbStructInfo))
		return FALSE;

	*ppStructInfo=SCrdEnrollAlloc(cbStructInfo);

	if(!(*ppStructInfo))
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	return CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,*ppStructInfo,&cbStructInfo);
}



//----------------------------------------------------------------------------
//
// GetNameFromPKCS10
//
//----------------------------------------------------------------------------
BOOL    GetNameFromPKCS10(BYTE      *pbPKCS10,
                          DWORD     cbPKCS10,
                          DWORD     dwFlags, 
                          LPSTR     pszOID, 
                          LPWSTR    *ppwszName)
{
    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    DWORD               dwRDNIndex=0;
    DWORD               dwAttrCount=0;
    DWORD               dwAttrIndex=0;
    CERT_RDN_ATTR	    *pCertRDNAttr=NULL;

    CERT_REQUEST_INFO   *pCertRequestInfo=NULL;
    CERT_NAME_INFO      *pCertNameInfo=NULL;

    *ppwszName=NULL;

    if(!DecodeGenericBLOB(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_CERT_REQUEST_TO_BE_SIGNED,
			              pbPKCS10, 
                          cbPKCS10,
                          (void **)&pCertRequestInfo))
        goto TraceErr;


    if(!DecodeGenericBLOB(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_UNICODE_NAME,
			              (pCertRequestInfo->Subject).pbData, 
                          (pCertRequestInfo->Subject).cbData,
                          (void **)&pCertNameInfo))
        goto TraceErr;

	//search for the OID requested.
    *ppwszName = (LPWSTR)SCrdEnrollAlloc(sizeof(WCHAR));

    if(NULL == (*ppwszName))
        goto MemoryErr;

    *(*ppwszName)=L'\0';

	for(dwRDNIndex=0; dwRDNIndex<pCertNameInfo->cRDN; dwRDNIndex++)
	{
		dwAttrCount=(pCertNameInfo->rgRDN)[dwRDNIndex].cRDNAttr;

		for(dwAttrIndex=0; dwAttrIndex<dwAttrCount; dwAttrIndex++)
		{
            pCertRDNAttr=&((pCertNameInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex]);

			if(_stricmp(pszOID, pCertRDNAttr->pszObjId)==0)   
			{
                if(0 != wcslen(*ppwszName))
                    wcscat(*ppwszName, L"; ");

                (*ppwszName) = (LPWSTR)SCrdEnrollRealloc
                 (*ppwszName, sizeof(WCHAR) * 
                    (wcslen(*ppwszName) + wcslen(L"; ") +
                     wcslen((LPWSTR)((pCertRDNAttr->Value).pbData))+1));

                if(NULL == *ppwszName)
                    goto MemoryErr;

                wcscat(*ppwszName, (LPWSTR)((pCertRDNAttr->Value).pbData));
            }
        }
    }

    if(0 == wcslen(*ppwszName))
        goto NotFindErr;

    fResult=TRUE;


CommonReturn:

    if(pCertRequestInfo)
        SCrdEnrollFree(pCertRequestInfo);

    if(pCertNameInfo)
        SCrdEnrollFree(pCertNameInfo);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    errBefore = GetLastError();

    if(*ppwszName)
    {
        SCrdEnrollFree(*ppwszName);
        *ppwszName=NULL;
    }


	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(NotFindErr, CRYPT_E_NOT_FOUND);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//----------------------------------------------------------------------------
//
// SearchAndDeleteCert
//
//----------------------------------------------------------------------------
BOOL    SearchAndDeleteCert(PCCERT_CONTEXT  pCertContext)
{
    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    HCERTSTORE          hCertStore=NULL;
    PCCERT_CONTEXT      pFoundCert=NULL;
    CERT_BLOB           HashBlob;

    memset(&HashBlob, 0, sizeof(CERT_BLOB));


    if(NULL==pCertContext)
        goto InvalidArgErr;

    //open the temporary store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							        g_dwMsgAndCertEncodingType,
							        NULL,
							        CERT_SYSTEM_STORE_CURRENT_USER,
							        g_MyStoreName);
                                    
    if(NULL==hCertStore)
        goto TraceErr;

    //get the SHA1 hash
    if(!CertGetCertificateContextProperty(
        pCertContext,	
        CERT_SHA1_HASH_PROP_ID,	
        NULL,	
        &(HashBlob.cbData)))
        goto TraceErr;

    HashBlob.pbData=(BYTE *)SCrdEnrollAlloc(HashBlob.cbData);

    if(NULL==(HashBlob.pbData))
        goto MemoryErr;

    if(!CertGetCertificateContextProperty(
        pCertContext,	
        CERT_SHA1_HASH_PROP_ID,	
        HashBlob.pbData,	
        &(HashBlob.cbData)))
        goto TraceErr;


    pFoundCert=CertFindCertificateInStore(
                    hCertStore,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &HashBlob,
                    NULL);

    if(pFoundCert)
        CertDeleteCertificateFromStore(pFoundCert);


    fResult=TRUE;


CommonReturn:

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(HashBlob.pbData)
        SCrdEnrollFree(HashBlob.pbData);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    errBefore = GetLastError();

	fResult=FALSE;

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,LPWSTR wszFormat,...)
{
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    // format message into requested buffer
    va_start(argList, wszFormat);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//-----------------------------------------------------------------------
//
// IsNewerCert
//
//      Return TRUE is pFirstCert has a later starting date of pSecondCert
//------------------------------------------------------------------------
BOOL    IsNewerCert(PCCERT_CONTEXT  pFirstCert,
                    PCCERT_CONTEXT  pSecondCert)
{
    if(NULL == pSecondCert)
        return TRUE;

    if(NULL == pFirstCert)
        return FALSE;

    if(1 != CompareFileTime(&(pFirstCert->pCertInfo->NotBefore),
                    &(pSecondCert->pCertInfo->NotBefore)))
        return FALSE;


    return TRUE;
}


//-----------------------------------------------------------------------
//
// SmartCardCSP
//
//  Return TRUE is the CSP is a smart card CSP.  If anything went wrong,
//  we will return TRUE for as a safe guard.
//------------------------------------------------------------------------
BOOL    SmartCardCSP(PCCERT_CONTEXT pCertContext)
{
    BOOL                    fResult = TRUE;
    DWORD                   cbData = 0;
    DWORD                   dwImpType=0;

    CRYPT_KEY_PROV_INFO     *pProvInfo=NULL;
    HCRYPTPROV              hProv = NULL;

    if(NULL == pCertContext)
        goto CLEANUP;


    //the certificate has to have the CERT_KEY_PROV_INFO_PROP_ID
    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
        goto CLEANUP;

    if((cbData == 0) || (NULL == (pProvInfo =(CRYPT_KEY_PROV_INFO *)SCrdEnrollAlloc(cbData))))
        goto CLEANUP;

    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                pProvInfo,
                                &cbData))
        goto CLEANUP;

    if(!CryptAcquireContextU(&hProv,
                            NULL,
                            pProvInfo->pwszProvName,
                            pProvInfo->dwProvType,
                            CRYPT_VERIFYCONTEXT))
        goto CLEANUP;

    cbData = sizeof(dwImpType);
         
    if(!CryptGetProvParam(hProv,
                PP_IMPTYPE,
                (BYTE *)(&dwImpType),
                &cbData,
                0))
        goto CLEANUP;

    if(0 == (CRYPT_IMPL_REMOVABLE & dwImpType))
        fResult = FALSE;


CLEANUP:

    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(pProvInfo)
        SCrdEnrollFree(pProvInfo);

    return fResult;

}

//-----------------------------------------------------------------------
//
// ChKInsertedCardSigningCert
//
//  This function checks to see if the inserted smart card matches
//  the signing certificate.  That is, they are actually the same cert
//  with the same public key
//
//------------------------------------------------------------------------
BOOL    ChKInsertedCardSigningCert(LPWSTR           pwszInsertProvider,
                                   DWORD            dwInsertProviderType,
                                   LPWSTR           pwszReaderName,
                                   PCCERT_CONTEXT   pSignCertContext,
                                   LPSTR            pszSignProvider,
                                   DWORD            dwSignProviderType,
                                   LPSTR            pszSignContainer,
                                   BOOL             *pfSame)
{

    BOOL                    fResult=FALSE;
    DWORD                   cbData=0;

    CRYPT_KEY_PROV_INFO     *pKeyProvInfo=NULL;
    CERT_PUBLIC_KEY_INFO    *pPubInfo=NULL;
    HCRYPTPROV              hProv=NULL;
    LPWSTR                  pwszInsertContainer=NULL;
    LPWSTR                  pwszSignProvider=NULL;
    
    if(NULL==pwszInsertProvider || NULL == pwszReaderName ||
       NULL == pSignCertContext || NULL == pszSignProvider ||
       NULL == pszSignContainer || NULL == pfSame)
        goto InvalidArgErr;

    *pfSame=FALSE;

    //get the key specification from the signing cert
    if(!CertGetCertificateContextProperty(
                pSignCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,	
                &cbData) || (0==cbData))
        goto TraceErr;

    pKeyProvInfo=(CRYPT_KEY_PROV_INFO *)SCrdEnrollAlloc(cbData);
    if(NULL==pKeyProvInfo)
        goto MemoryErr;

    if(!CertGetCertificateContextProperty(
            pSignCertContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,	
            &cbData))
        goto TraceErr;


    //build a default container name with the reader information
    if(!FormatMessageUnicode(&pwszInsertContainer,
                             L"\\\\.\\%1!s!\\",
                             pwszReaderName))
        goto TraceErr;
    

    //get the hProv from the reader's card
    if(!CryptAcquireContextU(&hProv,
                            pwszInsertContainer,
                            pwszInsertProvider,
                            dwInsertProviderType,
                            CRYPT_SILENT))
    {
        //check to see if we have an empty card
        if((GetLastError() == NTE_BAD_KEYSET) ||
           (GetLastError() == NTE_KEYSET_NOT_DEF))
        {
            //we have an empty card
            *pfSame=FALSE;
            fResult=TRUE;
            goto CommonReturn;
        }
        else
            goto TraceErr;
    }

    //get the public key information
    cbData=0;

    if(!CryptExportPublicKeyInfo(hProv,
                        pKeyProvInfo->dwKeySpec,
                        pSignCertContext->dwCertEncodingType,	
                        NULL,	
                        &cbData) || (0 == cbData))
    {
        //the insert card does not have a private key
        *pfSame=FALSE;
        fResult=TRUE;
        goto CommonReturn;
    }

    pPubInfo = (CERT_PUBLIC_KEY_INFO *)SCrdEnrollAlloc(cbData);

    if(NULL == pPubInfo)
        goto MemoryErr;

    if(!CryptExportPublicKeyInfo(hProv,
                        pKeyProvInfo->dwKeySpec,
                        pSignCertContext->dwCertEncodingType,	
                        pPubInfo,	
                        &cbData))
    {
        //the insert card does not have a private key
        *pfSame=FALSE;
        fResult=TRUE;
        goto CommonReturn;
    }
                
    if(CertComparePublicKeyInfo(pSignCertContext->dwCertEncodingType,
                                pPubInfo,                                                
                                &(pSignCertContext->pCertInfo->SubjectPublicKeyInfo)))
    {
        //make sure that we have the same CSP name
        pwszSignProvider=MkWStr(pszSignProvider);

        if(NULL != pwszSignProvider)
        {
            //case insensitive compare of the two csp names
            if(0 == _wcsicmp(pwszSignProvider, pwszInsertProvider))
                *pfSame=TRUE;
            else
                *pfSame=FALSE;
        }
        else
        {       
            //we are out of memory.  Assume same CSP here
            *pfSame=TRUE;
        }
    }
    else
        *pfSame=FALSE;


    fResult=TRUE;


CommonReturn:

    if(pwszSignProvider)
        FreeWStr(pwszSignProvider);

    if(pPubInfo)
        SCrdEnrollFree(pPubInfo);

    if(pKeyProvInfo)
        SCrdEnrollFree(pKeyProvInfo);

    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(pwszInsertContainer)
         LocalFree((HLOCAL)pwszInsertContainer);

	return fResult;

ErrorReturn:

    fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);

}
//-----------------------------------------------------------------------
//
// DeleteKeySet
//
//   If the user's smart card is not empty, we delete the private key
//
//------------------------------------------------------------------------
BOOL    DeleteKeySet(LPWSTR     pwszUserCSPName,
                     DWORD      dwUserCSPType,
                     LPWSTR     pwszReaderName)
{
    BOOL             fResult=FALSE;
    DWORD            dwSize=0;
    HCRYPTPROV       hDeleteProv=NULL;      //no need to free this 

    HCRYPTPROV       hProv=NULL;
    LPWSTR           pwszDefaultContainer=NULL;
    LPSTR            pszContainer=NULL;
    LPWSTR           pwszContainer=NULL;

    if(NULL == pwszUserCSPName || NULL == pwszReaderName)
        goto InvalidArgErr;

    if(!FormatMessageUnicode(&pwszDefaultContainer,
                             L"\\\\.\\%1!s!\\",
                             pwszReaderName))
        goto TraceErr;

    //get the hProv from the reader's card
    if(!CryptAcquireContextU(&hProv,
                            pwszDefaultContainer,
                            pwszUserCSPName,
                            dwUserCSPType,
                            CRYPT_SILENT))
    {
        //check to see if we have an empty card
        if((GetLastError() == NTE_BAD_KEYSET) ||
           (GetLastError() == NTE_KEYSET_NOT_DEF))
        {
            //we have an empty card
            fResult=TRUE;
            goto CommonReturn;
        }
        else
            goto TraceErr;
    }

    //get the container name
    dwSize = 0;

    if(!CryptGetProvParam(hProv,
                           PP_CONTAINER,
                            NULL,
                            &dwSize,
                            0) || (0==dwSize))
        goto TraceErr;

    
    pszContainer = (LPSTR) SCrdEnrollAlloc(dwSize);

    if(NULL == pszContainer)
        goto MemoryErr;

    if(!CryptGetProvParam(hProv,
                          PP_CONTAINER,
                            (BYTE *)pszContainer,
                            &dwSize,
                            0))
        goto TraceErr;

    //release the context
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv=NULL;
    }

    //build the fully qualified container name
    if(!FormatMessageUnicode(&pwszContainer,
                             L"\\\\.\\%1!s!\\%2!S!",
                             pwszReaderName,
                             pszContainer))
        goto TraceErr;

    //delete the container
    if(!CryptAcquireContextU(&hDeleteProv,
                            pwszContainer,
                            pwszUserCSPName,
                            dwUserCSPType,
                            CRYPT_DELETEKEYSET))
    {
        //check to see if we have an empty card
        if(GetLastError() == NTE_BAD_KEYSET)
        {
            //we have an empty card
            fResult=TRUE;
            goto CommonReturn;
        }
        else
            goto TraceErr;
    }

    fResult=TRUE;


CommonReturn:

    if(pwszDefaultContainer)
        LocalFree((HLOCAL)pwszDefaultContainer);

    if(pwszContainer)
        LocalFree((HLOCAL)pwszContainer);

    if(pszContainer)
        SCrdEnrollFree(pszContainer);

    if(hProv)
        CryptReleaseContext(hProv, 0);

	return fResult;

ErrorReturn:

    fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//-----------------------------------------------------------------------
//
// ChkSCardStatus
//
//  This function makes sure that the smart card enrollment station has the 
//  correct number of readers connected to the station, and the correct number
//  of smart cards inserted into the readers.  If everything looks good,  
//  the user smart card is initialized (old key container deleted) and a fully
//  qualified key container name, in the format of "\\.\ReaderName\ContainerName",
//  will be returned.
//
//------------------------------------------------------------------------
HRESULT ChkSCardStatus(BOOL             fSCardSigningCert,
                       PCCERT_CONTEXT   pSigningCertCertContext,
                       LPSTR            pszCSPNameSigningCert,
                       DWORD            dwCSPTypeSigningCert,
                       LPSTR            pszContainerSigningCert,
                       LPWSTR           pwszSelectedCSP,
                       LPWSTR           *ppwszNewContainerName)
{

    HRESULT     hr=E_FAIL;
    DWORD       dwExpectedReader=0;
    DWORD       dwReader=0;
    DWORD       dwSCard=0;        
    WCHAR       wszProvider[MAX_PATH];
    DWORD       dwProviderType=0;
    DWORD       dwCount=0;
    BOOL        fFindSigningCert=FALSE;
    DWORD       errBefore=0;
    BOOL        fSameCert=FALSE;
    DWORD       dwUserCSPType=0;
    LPCWSTR     pwszReaderName=NULL;        //no need to free.  Point to internal data
    LPWSTR      pwszUserReaderName=NULL;    //no need to free . Point to internal data
    GUID        guidContainerName;

    LPVOID      pvContext = NULL;
    LPWSTR      pwszNewContainerName=NULL;
    LPWSTR      pwszUserCSPName=NULL;
    char *      sz = NULL;
    RPC_STATUS  rpc_status;


    if(NULL == pszCSPNameSigningCert || NULL == pszContainerSigningCert ||
        NULL == ppwszNewContainerName || NULL == pSigningCertCertContext ||
        NULL == pwszSelectedCSP)
        goto CLEANUP;

    *ppwszNewContainerName=NULL;

    if(fSCardSigningCert)
        dwExpectedReader=2;
    else
        dwExpectedReader=1;

    dwReader = CountReaders(NULL);

    //check the # of smart card readers
    if(dwReader < dwExpectedReader)
    {
        hr=SCARD_E_READER_UNAVAILABLE;
        goto CLEANUP;
    }

    dwSCard = ScanReaders(&pvContext);

    //no smart card is inserted
    if( 0 == dwSCard || NULL == pvContext)
    {
        hr=SCARD_E_NO_SMARTCARD;
        goto CLEANUP;
    }

    //we have more than expected # of smart card inserted
    if(dwSCard > dwExpectedReader)
    {
        // seems ERROR_TOO_MANY_OPEN_FILES is closest one for this case
        hr=HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);
        goto CLEANUP;
    }

    dwCount=0;
    dwProviderType=0;
    wszProvider[0]=L'\0';
    pwszReaderName=NULL;
    fSameCert=FALSE;

    //now, we loop through we all inserted cards and make sure:
    //1. We find the signing certificate if applicable
    //2. We find a valid user certificate
    while (EnumInsertedCards(
                    pvContext, 
                    wszProvider, 
                    sizeof(wszProvider)/sizeof(wszProvider[0]),
                    &dwProviderType,
                    &pwszReaderName))
    {
        if((NULL == pwszReaderName) || (0 == wcslen(wszProvider)))
        {
            //we can not determine the status of the smart card
            hr = SCARD_E_CARD_UNSUPPORTED;
            goto CLEANUP;
        }

        if (!ChKInsertedCardSigningCert(
                                    wszProvider, 
                                    dwProviderType, 
                                    (LPWSTR)pwszReaderName,
                                    pSigningCertCertContext,
                                    pszCSPNameSigningCert,
                                    dwCSPTypeSigningCert,
                                    pszContainerSigningCert,
                                    &fSameCert))
        {
            if(ERROR_SUCCESS == (errBefore = GetLastError()))
                errBefore=E_UNEXPECTED;

            hr = CodeToHR(GetLastError());
            goto CLEANUP;
        }

        if(TRUE == fSameCert)
        {
            if(TRUE == fSCardSigningCert)
            {
                if(TRUE == fFindSigningCert)
                {
                    //too many signing cards.  Not expected
                    hr = SCARD_E_CARD_UNSUPPORTED;
                    goto CLEANUP;
                }
                else
                    fFindSigningCert=TRUE;
            }
            else
            {
                //we should not expect a siging certificate
                hr=SCARD_E_CARD_UNSUPPORTED;
                goto CLEANUP;
            }
        }
        else
        {
            //this is a user card.  
            if(NULL != (pwszUserCSPName))
            {
                //too many user cards.
                // seems ERROR_TOO_MANY_OPEN_FILES is closest one for this case
                hr=HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES);
                goto CLEANUP;
            }

            pwszUserCSPName = CopyWideString(wszProvider);

            if(NULL == pwszUserCSPName)
            {
                hr=E_OUTOFMEMORY;
                goto CLEANUP;
            }

            dwUserCSPType = dwProviderType;    
            pwszUserReaderName = (LPWSTR)pwszReaderName;
        }

        dwCount++;
        if(dwCount >= dwSCard)
            break;

        dwProviderType=0;
        pwszReaderName=NULL;
        wszProvider[0]=L'\0';
        fSameCert=FALSE;
    }    

    if((TRUE == fSCardSigningCert) && (FALSE == fFindSigningCert))
    {
        //we failed to find the signing certificate
        hr=SCARD_E_NO_SUCH_CERTIFICATE;

        goto CLEANUP;
    }
         
    if(NULL == pwszUserCSPName)
    {
        //we failed to find the target user certificate
        hr=SCARD_E_NO_SMARTCARD;
        goto CLEANUP;
    }

    //make sure the pwszUserCSPName matches with the CSP selected by the admin
    if(0 != _wcsicmp(pwszUserCSPName, pwszSelectedCSP))
    {
        hr=SCARD_E_PROTO_MISMATCH;
        goto CLEANUP;
    }

    //delete the key set from the user's certificate
    if(!DeleteKeySet(pwszUserCSPName,
                     dwUserCSPType,
                     pwszUserReaderName))
    {
        if(ERROR_SUCCESS == (errBefore = GetLastError()))
            errBefore=E_UNEXPECTED;

        hr = CodeToHR(GetLastError());
        goto CLEANUP;

    }

    //Build the fully qualified container name with a GUID
   
    // get a container based on a guid
    rpc_status = UuidCreate(&guidContainerName);
    if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
    {
        hr = rpc_status;
        goto CLEANUP;
    }

    rpc_status = UuidToStringA(&guidContainerName, (unsigned char **) &sz);
    if (RPC_S_OK != rpc_status)
    {
        hr = rpc_status;
        goto CLEANUP;
    }


    if(NULL == sz)
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //although the chance is VERY low, we could generate a same GUID
    //as the signing cert's container.  
    if(0 == _stricmp(sz,pszContainerSigningCert))
    {
        //we will have to do this again
        RpcStringFree((unsigned char **) &sz);
        sz=NULL;

        rpc_status = UuidCreate(&guidContainerName);
        if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
        {
            hr = rpc_status;
            goto CLEANUP;
        }

        rpc_status = UuidToStringA(&guidContainerName, (unsigned char **) &sz);
        if (RPC_S_OK != rpc_status)
        {
            hr = rpc_status;
            goto CLEANUP;
        }

        if(NULL == sz)
        {
            hr=E_OUTOFMEMORY;
            goto CLEANUP;
        }

        //since we are guaranted a new GUID, we should be fine here
        if(0 == _stricmp(sz,pszContainerSigningCert))
        {
            //can not support this smart card
            hr = SCARD_E_CARD_UNSUPPORTED;
            goto CLEANUP;
        }
    }

    if(!FormatMessageUnicode(&pwszNewContainerName,
                             L"\\\\.\\%1!s!\\%2!S!",
                             pwszUserReaderName,
                             sz))
    {
        if(ERROR_SUCCESS == (errBefore = GetLastError()))
            errBefore=E_UNEXPECTED;

        hr = CodeToHR(GetLastError());
        goto CLEANUP;
    }


    *ppwszNewContainerName = pwszNewContainerName;
    pwszNewContainerName = NULL;

    hr=S_OK;

CLEANUP:

    if(pwszUserCSPName)
        SCrdEnrollFree(pwszUserCSPName);

    if(sz)
        RpcStringFree((unsigned char **) &sz);

    if(pvContext)
        EndReaderScan(&pvContext);

    if(pwszNewContainerName)
        LocalFree((HLOCAL)pwszNewContainerName);


    return hr;

}
     
//-----------------------------------------------------------------------
//
// SignWithCert
//
//  We sign a dummy message with the signing certificate so that 
//  the smart card insert cert dialogue will be prompted
//
//------------------------------------------------------------------------
BOOL    SignWithCert(LPSTR              pszCSPName,
                     DWORD              dwCSPType,
                     PCCERT_CONTEXT     pSigningCert)
{
    BOOL                        fResult=FALSE;
    DWORD                       errBefore= GetLastError();
    HRESULT                     hr=E_FAIL;
	CRYPT_SIGN_MESSAGE_PARA     signMsgPara;
    DWORD                       cbData=0;

    BYTE                        *pbData=NULL;
    IEnroll                     *pIEnroll=NULL;
    LPWSTR                      pwszCSPName=NULL;
    LPWSTR                      pwszOID=NULL;
    LPSTR                       pszOID=NULL;

    char                        szMessage[] = "MyMessage"; 
    LPSTR                       pszMessage = szMessage;          
    BYTE*                       pbMessage = (BYTE*) pszMessage;   
    DWORD                       cbMessage = sizeof(szMessage);    

    memset(&signMsgPara, 0, sizeof(CRYPT_SIGN_MESSAGE_PARA));

    if(NULL == pszCSPName)
        goto InvalidArgErr;

    pwszCSPName = MkWStr(pszCSPName);

    if(NULL == pwszCSPName)
         goto MemoryErr;

    //use xEnroll to get the correct hash algorithm for the 
    //CSP
    if(NULL == (pIEnroll=PIEnrollGetNoCOM()))
        goto TraceErr;

    //set the CSP information
    if(S_OK != (hr=pIEnroll->put_ProviderType(dwCSPType)))
        goto SetErr;

    if(S_OK !=(hr=pIEnroll->put_ProviderNameWStr(pwszCSPName)))
        goto SetErr;

    if(S_OK != (hr=pIEnroll->get_HashAlgorithmWStr(&pwszOID)))
        goto SetErr;

    if(!MkMBStr(NULL, 0, pwszOID, &pszOID))
        goto TraceErr;


    signMsgPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signMsgPara.dwMsgEncodingType       = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    signMsgPara.pSigningCert            = pSigningCert;
    signMsgPara.HashAlgorithm.pszObjId  = pszOID;
    signMsgPara.cMsgCert                = 1;
    signMsgPara.rgpMsgCert              = &pSigningCert;


    cbData = 0;

    if( !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &(pbMessage),
        &(cbMessage) ,
        NULL,
        &cbData)|| (0 == cbData))
        goto TraceErr;

    pbData = (BYTE *)SCrdEnrollAlloc(cbData);

    if(NULL == pbData)
        goto MemoryErr;

    if( !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &(pbMessage),
        &(cbMessage) ,
        pbData,
        &cbData))
        goto TraceErr;


    fResult=TRUE;


CommonReturn:

    if(pbData)
        SCrdEnrollFree(pbData);

    if(pwszCSPName)
        FreeWStr(pwszCSPName);

    if(pszOID)
        FreeMBStr(NULL,pszOID);

    //the memory from xEnroll is freed via LocalFree
    //since we use the PIEnrollGetNoCOM function
    if(pwszOID)
        LocalFree(pwszOID);

    if(pIEnroll)
        pIEnroll->Release();

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    errBefore = GetLastError();

	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(SetErr, hr);
}



//-----------------------------------------------------------------------
//
// GetSelectedUserName
//
//------------------------------------------------------------------------
HRESULT GetSelectedUserName(IDsObjectPicker     *pDsObjectPicker,
                            LPWSTR              *ppwszSelectedUserSAM,
                            LPWSTR              *ppwszSelectedUserUPN)
{
    HRESULT                         hr= E_FAIL;
    DWORD                           errBefore= GetLastError();
    BOOL                            fGotStgMedium = FALSE;
    LPWSTR                          pwszPath=NULL;
    DWORD                           dwIndex =0 ;
    DWORD                           dwCount=0;

    IDataObject                     *pdo = NULL;
    PDS_SELECTION_LIST              pDsSelList=NULL;
    WCHAR                           wszWinNT[]=L"WinNT://";

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    //input check
    if((NULL == ppwszSelectedUserSAM) || (NULL == ppwszSelectedUserUPN))
        goto InvalidArgErr;

    *ppwszSelectedUserSAM = NULL;
    *ppwszSelectedUserUPN = NULL;

    if(NULL == pDsObjectPicker)
        goto InvalidArgErr;

    if(S_OK != (hr = pDsObjectPicker->InvokeDialog(NULL, &pdo)))
        goto SetErr;

    if(S_OK != (hr = pdo->GetData(&formatetc, &stgmedium)))
        goto SetErr;

    fGotStgMedium = TRUE;

    pDsSelList = (PDS_SELECTION_LIST)GlobalLock(stgmedium.hGlobal);

    if(!pDsSelList)
        goto TraceErr;

    //Get the SAM name
    if((pDsSelList->aDsSelection[0]).pwzADsPath == NULL)
        goto UnexpectedErr;

    //the ADsPath is in the form of "WinNT://" 
    if(wcslen((pDsSelList->aDsSelection[0]).pwzADsPath) <= wcslen(wszWinNT))
        goto UnexpectedErr;

    if( 0 != _wcsnicmp((pDsSelList->aDsSelection[0]).pwzADsPath, wszWinNT, wcslen(wszWinNT)))
        goto UnexpectedErr;

    pwszPath = ((pDsSelList->aDsSelection[0]).pwzADsPath) + wcslen(wszWinNT);

    *ppwszSelectedUserSAM=CopyWideString(pwszPath);

    if(NULL == (*ppwszSelectedUserSAM))
        goto MemoryErr;

    //search for the "/" and make it "\".  Since the ADsPath is in the form
    //of "WinNT://domain/name".  We need the SAM name in the form of 
    //domain\name
    dwCount = wcslen(*ppwszSelectedUserSAM);

    for(dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        if((*ppwszSelectedUserSAM)[dwIndex] == L'/')
        {
            (*ppwszSelectedUserSAM)[dwIndex] = L'\\';
            break;
        }
    }
    
    //get the UPN name
    if((pDsSelList->aDsSelection[0]).pwzUPN != NULL)
    {

        if(0 != _wcsicmp(L"",(pDsSelList->aDsSelection[0]).pwzUPN))
        {

            *ppwszSelectedUserUPN= CopyWideString((pDsSelList->aDsSelection[0]).pwzUPN);

            if(NULL == (*ppwszSelectedUserUPN))
                goto MemoryErr;

            //if we already have a UPN name, get the SAM name from TraslateName
            if(*ppwszSelectedUserSAM)
            {
                SCrdEnrollFree(*ppwszSelectedUserSAM);
                *ppwszSelectedUserSAM=NULL;
            }

            if(!GetName(*ppwszSelectedUserUPN, 
                        NameUserPrincipal,
                        NameSamCompatible,
                        ppwszSelectedUserSAM))
                goto TraceErr;
        }
    }

    hr=S_OK;

CommonReturn:

    if(pDsSelList)
        GlobalUnlock(stgmedium.hGlobal);

    if (TRUE == fGotStgMedium)
        ReleaseStgMedium(&stgmedium);

    if(pdo)
        pdo->Release();

    SetLastError(errBefore);

	return hr;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    hr = CodeToHR(errBefore);

    //we should free the memory for the output
    if(ppwszSelectedUserSAM)
    {
        if(*ppwszSelectedUserSAM)
        {
            SCrdEnrollFree(*ppwszSelectedUserSAM);
            *ppwszSelectedUserSAM=NULL;
        }
    }

    if(ppwszSelectedUserUPN)
    {
        if(*ppwszSelectedUserUPN)
        {
            SCrdEnrollFree(*ppwszSelectedUserUPN);
            *ppwszSelectedUserUPN=NULL;
        }
    }


	goto CommonReturn;

SET_ERROR_VAR(SetErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//-----------------------------------------------------------------------
//
// CodeToHR
//
//------------------------------------------------------------------------
HRESULT CodeToHR(HRESULT hr)
{
    if (S_OK != hr && S_FALSE != hr &&
	    (!FAILED(hr) || 0x0 == (LONG)HRESULT_FACILITY(hr)))
    {
        hr = HRESULT_FROM_WIN32(hr);
	    if (0x0 == (LONG)HRESULT_CODE(hr))
	    {
	        // A call failed without properly setting an error condition!
	        hr = E_UNEXPECTED;
	    }
    }
    return(hr);
}

//-----------------------------------------------------------------------
//
// ValidCSP
//
//------------------------------------------------------------------------
BOOL    ValidCSP(DWORD  dwProviderType, LPWSTR  pwszName)
{
    HCRYPTPROV      hProv=NULL;
    BOOL            fValid=FALSE;
    DWORD           dwImpType=0;
    DWORD           dwSize=sizeof(dwImpType);

    if(CryptAcquireContextU(&hProv,
                NULL,
                pwszName,
                dwProviderType,
                CRYPT_VERIFYCONTEXT))
    {

        if(CryptGetProvParam(hProv,
                    PP_IMPTYPE,
                    (BYTE *)(&dwImpType),
                    &dwSize,
                    0))
        {
            if(CRYPT_IMPL_REMOVABLE & dwImpType)
                fValid=TRUE;
        }
    }

    if(hProv)
        CryptReleaseContext(hProv, 0);

   return fValid;
}

//-----------------------------------------------------------------------
//
// InitlializeCSPList
//
//------------------------------------------------------------------------
BOOL    InitlializeCSPList(DWORD    *pdwCSPCount, SCrdEnroll_CSP_INFO **prgCSPInfo)
{
    BOOL                    fResult=FALSE;
    DWORD                   errBefore= GetLastError();

    DWORD                   dwIndex=0;
    DWORD                   dwProviderType=0;
    DWORD                   cbSize=0;

    SCrdEnroll_CSP_INFO     *rgCSPInfo=NULL;
    LPWSTR                  pwszName=NULL;

    *pdwCSPCount=0;
    *prgCSPInfo=NULL;

    while(CryptEnumProvidersU(
                    dwIndex,
                    0,
                    0,
                    &dwProviderType,
                    NULL,
                    &cbSize))
    {

        pwszName=(LPWSTR)SCrdEnrollAlloc(cbSize);

        if(NULL==pwszName)
            goto MemoryErr;

        if(!CryptEnumProvidersU(
                    dwIndex,
                    0,
                    0,
                    &dwProviderType,
                    pwszName,
                    &cbSize))
            goto TraceErr;

        if(ValidCSP(dwProviderType, pwszName))
        {
            rgCSPInfo=(SCrdEnroll_CSP_INFO *)SCrdEnrollRealloc(*prgCSPInfo,
                ((*pdwCSPCount) + 1) * sizeof(SCrdEnroll_CSP_INFO));

            if(NULL==rgCSPInfo)
                goto MemoryErr;

            *prgCSPInfo=rgCSPInfo;

            memset(&(*prgCSPInfo)[*pdwCSPCount], 0, sizeof(SCrdEnroll_CSP_INFO));

            (*prgCSPInfo)[*pdwCSPCount].pwszCSPName=pwszName;
            pwszName=NULL;

            (*prgCSPInfo)[*pdwCSPCount].dwCSPType=dwProviderType;

            (*pdwCSPCount)++;
        }
        else
        {
            SCrdEnrollFree(pwszName);
            pwszName=NULL;
        }


        dwIndex++;

        dwProviderType=0;
        cbSize=0;
    }


    if((*pdwCSPCount == 0) || (*prgCSPInfo == NULL))
        goto NoItemErr;

    fResult=TRUE;

CommonReturn:

    if(pwszName)
        SCrdEnrollFree(pwszName);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //we need to free all the memory
     FreeCSPInfo(*pdwCSPCount, *prgCSPInfo);

     *pdwCSPCount=0;
     *prgCSPInfo=NULL;

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
SET_ERROR(NoItemErr,ERROR_NO_MORE_ITEMS);

}

//-----------------------------------------------------------------------
//
// FreeCSPInfo
//
//------------------------------------------------------------------------
void    FreeCSPInfo(DWORD   dwCSPCount, SCrdEnroll_CSP_INFO *prgCSPInfo)
{
    DWORD   dwIndex=0;

    if(prgCSPInfo)
    {
        for(dwIndex=0; dwIndex < dwCSPCount; dwIndex++)
        {
            if(prgCSPInfo[dwIndex].pwszCSPName)
                SCrdEnrollFree(prgCSPInfo[dwIndex].pwszCSPName);
        }

        SCrdEnrollFree(prgCSPInfo);
    }
}


//-----------------------------------------------------------------------
//
// FreeCAInfoElement
//
//------------------------------------------------------------------------
void    FreeCAInfoElement(SCrdEnroll_CA_INFO *pCAInfo)
{
    if(pCAInfo)
    {
        if(pCAInfo->pwszCAName)
            SCrdEnrollFree(pCAInfo->pwszCAName);

        if(pCAInfo->pwszCALocation)
            SCrdEnrollFree(pCAInfo->pwszCALocation);

        if(pCAInfo->pwszCADisplayName)
            SCrdEnrollFree(pCAInfo->pwszCADisplayName);

        memset(pCAInfo, 0, sizeof(SCrdEnroll_CA_INFO));
    }
}

//-----------------------------------------------------------------------
//
// FreeCAInfo
//
//------------------------------------------------------------------------
void    FreeCAInfo(DWORD    dwCACount, SCrdEnroll_CA_INFO *rgCAInfo)
{
    DWORD   dwIndex=0;

    if(rgCAInfo)
    {
        for(dwIndex=0; dwIndex < dwCACount; dwIndex++)
            FreeCAInfoElement(&(rgCAInfo[dwIndex]));

        SCrdEnrollFree(rgCAInfo);
    }
}
//-----------------------------------------------------------------------
//
// FreeCTInfoElement
//
//------------------------------------------------------------------------
void    FreeCTInfoElement(SCrdEnroll_CT_INFO    * pCTInfo)
{

    if(pCTInfo)
    {
        if(pCTInfo->pCertTypeExtensions)
            CAFreeCertTypeExtensions(NULL,pCTInfo->pCertTypeExtensions);

        if(pCTInfo->pwszCTName)
            SCrdEnrollFree(pCTInfo->pwszCTName);

        if(pCTInfo->pwszCTDisplayName)
            SCrdEnrollFree(pCTInfo->pwszCTDisplayName);

        if(pCTInfo->rgCAInfo)
            FreeCAInfo(pCTInfo->dwCACount, pCTInfo->rgCAInfo);

        if (NULL != pCTInfo->rgpwszSupportedCSPs)
        {
            SCrdEnrollFree(pCTInfo->rgpwszSupportedCSPs);
        }
        memset(pCTInfo, 0, sizeof(SCrdEnroll_CT_INFO));
    }
}



//-----------------------------------------------------------------------
//
// FreeCTInfo(DWORD    dwCTCount, SCrdEnroll_CT_INFO *rgCTInfo);
//
//------------------------------------------------------------------------
void    FreeCTInfo(DWORD    dwCTCount, SCrdEnroll_CT_INFO *rgCTInfo)
{
    DWORD   dwIndex=0;

    if(rgCTInfo)
    {
        for(dwIndex=0; dwIndex < dwCTCount; dwIndex++)
            FreeCTInfoElement(&(rgCTInfo[dwIndex]));

        SCrdEnrollFree(rgCTInfo);
    }
}

//-----------------------------------------------------------------------
//
// GetCertTypeProperties
//
//------------------------------------------------------------------------
BOOL    GetCertTypeProperties(HCERTTYPE             hCurCertType,
                              SCrdEnroll_CT_INFO    *pCertInfo)
{

    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    HRESULT             hr=S_OK;
    DWORD               dwCertType=0;
    DWORD               dwMinKeySize; 
    DWORD               dwEnrollmentFlags; 
    DWORD               dwSubjectNameFlags;
    DWORD               dwPrivateKeyFlags;
    DWORD               dwGeneralFlags; 
    DWORD               dwGenKeyFlags; 
    LPWSTR             *rgpwszSupportedCSPs = NULL;

    LPWSTR              *ppwszDisplayCertTypeName=NULL;
    LPWSTR              *ppwszCertTypeName=NULL;


    if((NULL==pCertInfo) || (NULL == hCurCertType))
        goto InvalidArgErr;
    
    //
    // Get all of the cert type flags. 
    //
    
    // Get enrollment flags:
    if (S_OK != (hr=MyCAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_ENROLLMENT_FLAG, 
		  &pCertInfo->dwEnrollmentFlags)))
	goto CertCliErr;
	   
    // Get subject name flags: 
    if (S_OK != (hr=MyCAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_SUBJECT_NAME_FLAG, 
		  &pCertInfo->dwSubjectNameFlags)))
	goto CertCliErr;


    // Get private key flags.  
    if(S_OK != (hr = MyCAGetCertTypeFlagsEx
		(hCurCertType, 
		 CERTTYPE_PRIVATE_KEY_FLAG, 
		 &pCertInfo->dwPrivateKeyFlags)))
        goto CertCliErr;

    
    // Get general flags:
    if (S_OK != (hr=MyCAGetCertTypeFlagsEx
		 (hCurCertType,
		  CERTTYPE_GENERAL_FLAG,
		  &pCertInfo->dwGeneralFlags)))
	goto CertCliErr;
    
    //detremine machine boolean flag
    pCertInfo->fMachine = (0x0 != (pCertInfo->dwGeneralFlags & CT_FLAG_MACHINE_TYPE)) ? TRUE : FALSE;

    // Extract gen key flags from the type flags. 
    dwGenKeyFlags = 0;     
    if (!(CertTypeFlagsToGenKeyFlags
	  (pCertInfo->dwEnrollmentFlags,
	   pCertInfo->dwSubjectNameFlags,
	   pCertInfo->dwPrivateKeyFlags,
	   pCertInfo->dwGeneralFlags,
	   &pCertInfo->dwGenKeyFlags)))
	goto CertCliErr; 

    // Get key spec: 
    if(S_OK != (hr= CAGetCertTypeKeySpec(hCurCertType, &(pCertInfo->dwKeySpec))))
        goto CertCliErr;

    //get the display name of the cert type
    hr=CAGetCertTypeProperty(
        hCurCertType,
        CERTTYPE_PROP_FRIENDLY_NAME,
        &ppwszDisplayCertTypeName);

    if(S_OK != hr || NULL==ppwszDisplayCertTypeName)
    {
        if(S_OK == hr)
            hr=E_FAIL;
        goto CertCliErr;
    }

    //copy the name
    pCertInfo->pwszCTDisplayName=CopyWideString(ppwszDisplayCertTypeName[0]);

    if(NULL==(pCertInfo->pwszCTDisplayName))
        goto MemoryErr;


    //get the machine readable name of the cert type
    hr=CAGetCertTypeProperty(
        hCurCertType,
        CERTTYPE_PROP_DN,
        &ppwszCertTypeName);

    if(S_OK != hr || NULL==ppwszCertTypeName)
    {
        if(S_OK == hr)
            hr=E_FAIL;
        goto CertCliErr;
    }

    //copy the name
    pCertInfo->pwszCTName=CopyWideString(ppwszCertTypeName[0]);

    if(NULL==(pCertInfo->pwszCTName))
        goto MemoryErr;

    //copy the certType extensions
    if(S_OK != (hr=CAGetCertTypeExtensions(
            hCurCertType,
            &(pCertInfo->pCertTypeExtensions))))
        goto CertCliErr;

    //copy csp list supported by template
    hr = CAGetCertTypeProperty(
                hCurCertType,
                CERTTYPE_PROP_CSP_LIST,
                &rgpwszSupportedCSPs);
    if (S_OK != hr)
    {
        goto CertCliErr;
    }
    pCertInfo->rgpwszSupportedCSPs = CopyWideStrings(rgpwszSupportedCSPs);
    if (NULL == pCertInfo->rgpwszSupportedCSPs)
    {
        goto MemoryErr;
    }
    pCertInfo->dwCurrentCSP = 0; //first one

    //
    // Set V2 properties. 
    // If we're dealing with a v2 cert type, add v2 properties.
    // Otherwise, insert defaults.  
    // 

    if (S_OK != (hr=MyCAGetCertTypePropertyEx
		 (hCurCertType,
		  CERTTYPE_PROP_SCHEMA_VERSION, 
		  &dwCertType)))
	goto CertCliErr;

    if (dwCertType == CERTTYPE_SCHEMA_VERSION_1)
    {
	// Just a v1 cert type, it won't have v2 properties.  
	// Set left half-word of the type flags to 0.  This means that
	// that the min key size is not specified.  
	pCertInfo->dwGenKeyFlags &= 0x0000FFFF;  
	pCertInfo->dwRASignature = 0; 
    }
    else // We must have a v2 (or greater) cert type.  
    {
	// Get the minimum key size of the cert type
	if (S_OK != (hr=MyCAGetCertTypePropertyEx
		     (hCurCertType,
		      CERTTYPE_PROP_MIN_KEY_SIZE,
		      (LPVOID)&dwMinKeySize)))
	    goto CertCliErr; 

	// store the minimum key size in the left half-word of the 
	// type flags. 
	pCertInfo->dwGenKeyFlags = 
	    (dwMinKeySize << 16) | (pCertInfo->dwGenKeyFlags & 0x0000FFFF) ; 

	// Get the number of RA signatures required for this cert type. 
	if (S_OK != (hr=MyCAGetCertTypePropertyEx
		     (hCurCertType,
		      CERTTYPE_PROP_RA_SIGNATURE,
		      (LPVOID)(&pCertInfo->dwRASignature))))
	    goto CertCliErr; 
    }
    
    fResult=TRUE;

CommonReturn:

    if(ppwszDisplayCertTypeName)
        CAFreeCertTypeProperty(hCurCertType, ppwszDisplayCertTypeName);

    if(ppwszCertTypeName)
        CAFreeCertTypeProperty(hCurCertType, ppwszCertTypeName);
 
    if (NULL != rgpwszSupportedCSPs)
    {
        CAFreeCertTypeProperty(hCurCertType, rgpwszSupportedCSPs);
    }

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //in error case, free the memory and memset to 0
    if(pCertInfo)
        FreeCTInfoElement(pCertInfo);

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------
//
//  IsMachineCertType
//
//--------------------------------------------------------------------
BOOL    IsMachineCertType(HCERTTYPE hCertType)
{
    DWORD   dwCertType=0;

    if(S_OK != CAGetCertTypeFlags(hCertType, &dwCertType))
        return FALSE;

    if(CT_FLAG_MACHINE_TYPE & dwCertType)
        return TRUE;

    return FALSE;
}

//-----------------------------------------------------------------------
//  Get a list of allowed cert types
//
//------------------------------------------------------------------------
/*BOOL    GetAllowedCertTypeName(LPWSTR   **pawszAllowedCertTypes)
{
    DWORD                   dwErr=0;
    KEYSVC_TYPE             dwServiceType=KeySvcMachine;
    DWORD                   cTypes=0;
    DWORD                   dwSize=0;
    CHAR                    szComputerName[MAX_COMPUTERNAME_LENGTH + 1]={0};
    DWORD                   cbArray = 0;
    DWORD                   i=0;
    LPWSTR                  wszCurrentType;
    BOOL                    fResult=FALSE;
        
    KEYSVCC_HANDLE          hKeyService=NULL;
    PKEYSVC_UNICODE_STRING  pCertTypes = NULL;

    dwSize=sizeof(szComputerName);

    if(0==GetComputerNameA(szComputerName, &dwSize))
        goto TraceErr;
       
    dwErr = KeyOpenKeyService(szComputerName,
                                    dwServiceType,
                                    NULL, 
                                    NULL,     // no authentication string right now
                                    NULL,
                                    &hKeyService);

    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    dwErr = KeyEnumerateAvailableCertTypes(hKeyService,
                                          NULL, 
                                          &cTypes,
                                          &pCertTypes);
    if(dwErr != ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        goto TraceErr;
    }

    cbArray = (cTypes+1)*sizeof(LPWSTR);

    // Convert into a simple array
    for(i=0; i < cTypes; i++)
    {
       cbArray += pCertTypes[i].Length;
    }

    *pawszAllowedCertTypes = (LPWSTR *)SCrdEnrollAlloc(cbArray);


    if(*pawszAllowedCertTypes == NULL)
           goto MemoryErr;


    memset(*pawszAllowedCertTypes, 0, cbArray);

    wszCurrentType = (LPWSTR)(&((*pawszAllowedCertTypes)[cTypes + 1]));
    
    for(i=0; i < cTypes; i++)
    {
       (*pawszAllowedCertTypes)[i] = wszCurrentType;

       wcscpy(wszCurrentType, pCertTypes[i].Buffer);

       wszCurrentType += wcslen(wszCurrentType)+1;
    }

    fResult=TRUE;

CommonReturn:

    //memory from the KeyService
    if(pCertTypes)
        LocalFree((HLOCAL)pCertTypes);


    if(hKeyService)
        KeyCloseKeyService(hKeyService, NULL);


    return fResult;


ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}  */


//--------------------------------------------------------------------
//
//  CheckAccessPermission
//
//--------------------------------------------------------------------
BOOL    CheckAccessPermission(HCERTTYPE  hCertType)
{
     //make sure the principal making this call has access to request
    //this cert type, even if he's requesting on behalf of another.
    //
    HRESULT         hr = S_OK;
    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(hr == S_OK)
    {

        hr = CACertTypeAccessCheck(
            hCertType,
            hClientToken);

        CloseHandle(hClientToken);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }

    return (S_OK == hr);
}

//--------------------------------------------------------------------
//
//  TokenCheckAccessPermission
//
//--------------------------------------------------------------------
BOOL	TokenCheckAccessPermission(HANDLE hToken, HCERTTYPE hCertType)
{
	HRESULT	hr=E_FAIL;

	if(hToken)
	{
		hr = CACertTypeAccessCheck(
            hCertType,
            hToken);

		return (S_OK == hr);

	}

	return CheckAccessPermission(hCertType);
}


//--------------------------------------------------------------------
//
//  CheckCAPermission
//
//--------------------------------------------------------------------
BOOL    CheckCAPermission(HCAINFO hCAInfo)
{
     //make sure the principal making this call has access to request
    //this cert type, even if he's requesting on behalf of another.
    //
    HRESULT         hr = S_OK;
    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(hr == S_OK)
    {

        hr = CAAccessCheck(
            hCAInfo,
            hClientToken);

        CloseHandle(hClientToken);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }

    return (S_OK == hr);
}

//--------------------------------------------------------------------
//
//  TokenCheckCAPermission
//
//--------------------------------------------------------------------
BOOL	TokenCheckCAPermission(HANDLE hToken, HCAINFO hCAInfo)
{
	HRESULT	hr=E_FAIL;

	if(hToken)
	{
		hr = CAAccessCheck(
            hCAInfo,
            hToken);

		return (S_OK == hr);

	}

	return CheckCAPermission(hCAInfo);
}


//--------------------------------------------------------------------
//
//   CheckSubjectRequirement
//
//--------------------------------------------------------------------
/*BOOL    CheckSubjectRequirement(HCERTTYPE    hCurCertType)
{
    DWORD   dwFlags=0;

    //check the subject requirement of the cert type
    if(S_OK != CAGetCertTypeFlags(hCurCertType, &dwFlags))
        return FALSE;

    if(CT_FLAG_IS_SUBJECT_REQ & dwFlags)
        return FALSE;

    return  TRUE;
} */

//-----------------------------------------------------------------------
//
// GetCAProperties
//
//------------------------------------------------------------------------
BOOL    GetCAProperties(HCAINFO                 hCurCAInfo,
                        SCrdEnroll_CA_INFO      *pCAInfo)
{
    BOOL                fResult=FALSE;
    DWORD               errBefore= GetLastError();
    HRESULT             hr=S_OK;

    LPWSTR              *ppwszNameProp=NULL;
    LPWSTR              *ppwszLocationProp=NULL;
	LPWSTR				*ppwszDisplayNameProp=NULL;


    //get the CAName
    hr=CAGetCAProperty(
                hCurCAInfo,
                CA_PROP_NAME,
                &ppwszNameProp);

    if((S_OK != hr) || (NULL==ppwszNameProp))
    {
        if(!FAILED(hr))
            hr=E_FAIL;

        goto CertCliErr;
    }

    pCAInfo->pwszCAName=CopyWideString(ppwszNameProp[0]);

    if(NULL == pCAInfo->pwszCAName)
        goto MemoryErr;

	//get the CADisplayName
    hr=CAGetCAProperty(
                hCurCAInfo,
                CA_PROP_DISPLAY_NAME,
                &ppwszDisplayNameProp);

    if((S_OK != hr) || (NULL==ppwszDisplayNameProp))
    {
        if(!FAILED(hr))
            hr=E_FAIL;

        goto CertCliErr;
    }

    pCAInfo->pwszCADisplayName=CopyWideString(ppwszDisplayNameProp[0]);

    if(NULL == pCAInfo->pwszCADisplayName)
        goto MemoryErr;


    //get the CA location
    hr=CAGetCAProperty(
        hCurCAInfo,
        CA_PROP_DNSNAME,
        &ppwszLocationProp);

    if((S_OK != hr) || (NULL==ppwszLocationProp))
    {
        if(!FAILED(hr))
            hr=E_FAIL;

        goto CertCliErr;
    }

    //copy the name
    pCAInfo->pwszCALocation=CopyWideString(ppwszLocationProp[0]);

    if(NULL == pCAInfo->pwszCALocation)
        goto MemoryErr;

    fResult=TRUE;

CommonReturn:

    if(ppwszNameProp)
        CAFreeCAProperty(hCurCAInfo, ppwszNameProp);

    if(ppwszLocationProp)
        CAFreeCAProperty(hCurCAInfo, ppwszLocationProp);

	if(ppwszDisplayNameProp)
		CAFreeCAProperty(hCurCAInfo, ppwszDisplayNameProp);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //in error case, free the memory and memset to 0
    if(pCAInfo)
        FreeCAInfoElement(pCAInfo);

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(CertCliErr, hr);
}

//-----------------------------------------------------------------------
//
// GetCAInfoFromCertType
//
//------------------------------------------------------------------------
BOOL    GetCAInfoFromCertType(HANDLE					hToken,
							  LPWSTR                    pwszCTName,
                              DWORD                     *pdwValidCA,
                              SCrdEnroll_CA_INFO        **prgCAInfo)
{

    BOOL                        fResult=FALSE;
    HRESULT                     hr=S_OK;
    DWORD                       errBefore= GetLastError();

    DWORD                       dwCACount=0;
    DWORD                       dwValidCA=0;
    SCrdEnroll_CA_INFO          *rgCAInfo=NULL;

    HCAINFO                     hCurCAInfo=NULL;
    HCAINFO                     hPreCAInfo=NULL;


    //init
    *pdwValidCA=0;
    *prgCAInfo=NULL;


    if(NULL == pwszCTName)
        goto InvalidArgErr;

    hr = CAFindByCertType(
        pwszCTName,
        NULL,
        0,
        &hCurCAInfo);

    if( hr!=S_OK || NULL==hCurCAInfo)
    {
        if(S_OK == hr)
            hr=E_FAIL;

        goto CertCliErr;
    }

    //get the CA count
    dwCACount=CACountCAs(hCurCAInfo);

    if(0==dwCACount)
    {
        hr=E_FAIL;
        goto CertCliErr;

    }

    //allocate memory
    rgCAInfo=(SCrdEnroll_CA_INFO *)SCrdEnrollAlloc(dwCACount *
                sizeof(SCrdEnroll_CA_INFO));

    if(NULL == rgCAInfo)
        goto MemoryErr;

    memset(rgCAInfo, 0, dwCACount * sizeof(SCrdEnroll_CA_INFO));

    dwValidCA=0;

    while(hCurCAInfo)
    {

        //get the CA information
		if(TokenCheckCAPermission(hToken, hCurCAInfo))
		{
			if(GetCAProperties(hCurCAInfo, &(rgCAInfo[dwValidCA])))
			{
				//increment the count
				dwValidCA++;
			}
		}

        //enum for the CA
        hPreCAInfo=hCurCAInfo;

        hr=CAEnumNextCA(
                hPreCAInfo,
                &hCurCAInfo);

        //free the old CA Info
        CACloseCA(hPreCAInfo);
        hPreCAInfo=NULL;

        if((S_OK != hr) || (NULL==hCurCAInfo))
            break;
    }

    if( (0 == dwValidCA) || (NULL == rgCAInfo))
    {
        hr=E_FAIL;
        goto CertCliErr;
    }

    //copy the output data
    *pdwValidCA=dwValidCA;
    *prgCAInfo=rgCAInfo;

    fResult=TRUE;

CommonReturn:

    if(hPreCAInfo)
        CACloseCA(hPreCAInfo);

    if(hCurCAInfo)
        CACloseCA(hCurCAInfo);

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    if(rgCAInfo)
        FreeCAInfo(dwValidCA, rgCAInfo);

    //NULL the output
    *pdwValidCA=0;
    *prgCAInfo=NULL;

	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(CertCliErr, hr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);

}

//-----------------------------------------------------------------------
//
// InitializeCTList
//
//------------------------------------------------------------------------
BOOL    InitializeCTList(DWORD  *pdwCTIndex,
                         DWORD  *pdwCTCount,
                         SCrdEnroll_CT_INFO **prgCTInfo)
{

    BOOL                        fResult=FALSE;
    HRESULT                     hr=S_OK;
    DWORD                       errBefore= GetLastError();

    HCERTTYPE                   hCurCertType=NULL;
    HCERTTYPE                   hPreCertType=NULL;
    DWORD                       dwCertTypeCount=0;
    DWORD                       dwIndex=0;

    DWORD                       dwValidCertType=0;
    SCrdEnroll_CT_INFO *        rgCTInfo=NULL;

	HANDLE						hThread=NULL;	//no need to close
	HANDLE						hToken=NULL;



    *pdwCTIndex=0;
    *pdwCTCount=0;
    *prgCTInfo=NULL;

	//first of all, we need to revert to ourselves if we are under impersonation
	hThread=GetCurrentThread();
	
	if(NULL != hThread)
	{
		if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		{
			if(hToken)
			{
				//no need to check for return here.  If this failed, just go on
				RevertToSelf();
			}
		}
	}

    //get the 1st CT, including both machine and user cert types
    hr=CAEnumCertTypes(CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES, &hCurCertType);

    if((S_OK != hr) || (NULL==hCurCertType))
    {
        if(S_OK != hr)
            hr=E_FAIL;

        goto CertCliErr;
    }

    //get the count of the cert types supported by this CA
    dwCertTypeCount=CACountCertTypes(hCurCertType);

    if(0==dwCertTypeCount)
    {
        hr=E_FAIL;

        goto CertCliErr;
    }

    //allocate memory
    rgCTInfo=(SCrdEnroll_CT_INFO *)SCrdEnrollAlloc(dwCertTypeCount *
                sizeof(SCrdEnroll_CT_INFO));

    if(NULL == rgCTInfo)
        goto MemoryErr;

    memset(rgCTInfo, 0, dwCertTypeCount * sizeof(SCrdEnroll_CT_INFO));

    dwValidCertType = 0;


    while(hCurCertType)
    {

        if(TokenCheckAccessPermission(hToken, hCurCertType) &&
           GetCertTypeProperties(hCurCertType, &(rgCTInfo[dwValidCertType]))
          )
        {
            dwValidCertType++;
        }

        //enum for the next cert types
        hPreCertType=hCurCertType;

        hr=CAEnumNextCertType(
                hPreCertType,
                &hCurCertType);

        //free the old cert type
        CACloseCertType(hPreCertType);
        hPreCertType=NULL;

        if((S_OK != hr) || (NULL==hCurCertType))
            break;
    }

    //now that we have find all the cert types, we need to find one cert
    //that has the associated CA information

    //if hToken, we are running as the certserv's ASP pages.  We need to retrieve all the 
    // CA's information since we are in the revert to self mode.
    if(NULL == hToken)
    {
	for(dwIndex=0; dwIndex < dwValidCertType; dwIndex++)
	{
	    //we do not consider the machine cert types
	    if(TRUE == rgCTInfo[dwIndex].fMachine)
		continue;
	    
	    //mark that we have queried the CA information of the
	    //certType
	    rgCTInfo[dwIndex].fCAInfo=TRUE;
	    
	    if(GetCAInfoFromCertType(NULL,
				     rgCTInfo[dwIndex].pwszCTName,
				     &(rgCTInfo[dwIndex].dwCACount),
				     &(rgCTInfo[dwIndex].rgCAInfo)))
		break;
	}
	
	if(dwIndex == dwValidCertType)
	{
	    hr=E_FAIL;
	    goto CertCliErr;
	}
    }
    else
    {
	for(dwIndex=0; dwIndex < dwValidCertType; dwIndex++)
	{
	    //mark that we have queried the CA information of the
	    //certType
	    rgCTInfo[dwIndex].fCAInfo=TRUE;
	    
	    GetCAInfoFromCertType( hToken,
				   rgCTInfo[dwIndex].pwszCTName,
				   &(rgCTInfo[dwIndex].dwCACount),
				   &(rgCTInfo[dwIndex].rgCAInfo));
	}
    }


    if((0 == dwValidCertType) || (NULL == rgCTInfo))
    {
        hr=E_FAIL;
        goto CertCliErr;
    }

    *pdwCTIndex=dwIndex;
    *pdwCTCount=dwValidCertType;
    *prgCTInfo=rgCTInfo;

    fResult=TRUE;

CommonReturn:

    if(hPreCertType)
        CACloseCertType(hPreCertType);

    if(hCurCertType)
        CACloseCertType(hCurCertType);

	//if hToken is valid, we reverted to ourselves.
	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

    SetLastError(errBefore);

	return fResult;

ErrorReturn:
    if(ERROR_SUCCESS == (errBefore = GetLastError()))
        errBefore=E_UNEXPECTED;

    //free all the memory
    if(rgCTInfo)
        FreeCTInfo(dwValidCertType, rgCTInfo);

    //NULL the output
    *pdwCTIndex=0;
    *pdwCTCount=0;
    *prgCTInfo=NULL;


	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(CertCliErr, hr);
}


//-----------------------------------------------------------------------
//
// RetrieveCAName
//
//------------------------------------------------------------------------
BOOL	RetrieveCAName(DWORD					dwFlags, 
					   SCrdEnroll_CA_INFO		*pCAInfo, 
					   LPWSTR					*ppwszName)
{
	DWORD	dwSize = 0;
	BOOL	fResult=FALSE;

	if(NULL == ppwszName)
		goto InvalidArgErr;

	if(dwFlags == SCARD_ENROLL_CA_MACHINE_NAME)
		*ppwszName = CopyWideString(pCAInfo->pwszCALocation);
	else
	{
		if(dwFlags == SCARD_ENROLL_CA_DISPLAY_NAME)
			*ppwszName = CopyWideString(pCAInfo->pwszCADisplayName);
		else
		{
			if(dwFlags == SCARD_ENROLL_CA_UNIQUE_NAME)
			{
				dwSize = wcslen(pCAInfo->pwszCALocation) + wcslen(pCAInfo->pwszCADisplayName) + wcslen(L"\\") + 2;

				*ppwszName = (LPWSTR)SCrdEnrollAlloc(sizeof(WCHAR) * dwSize);
				if(NULL == (*ppwszName))
					goto MemoryErr;

				wcscpy(*ppwszName, pCAInfo->pwszCALocation);
				wcscat(*ppwszName, L"\\");
				wcscat(*ppwszName, pCAInfo->pwszCADisplayName);
			}
			else
				*ppwszName = CopyWideString(pCAInfo->pwszCAName);

		}
	}

	if(NULL == (*ppwszName))
		goto MemoryErr;

    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scenum.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scenum.cpp

Abstract:

    This module provides the implementation of the smart card helper functions
    provided to Xiaohung Su for use in the Smart Card Enrollment Station.

Author:

    Doug Barlow (dbarlow) 11/12/1998

Notes:

    Most of these routines use a "context handle", defined as LPVOID.  The
    proper usage of these routines is to declare a context variable in your
    code, and assign it the value 'NULL'.  For example,

        LPVOID pvScEnlistHandle = NULL;

    These routines will use this pointer to establish internal working
    structures.  It's actual value will change between calls, but the value can
    be ignored by the caller.

    These routines assume a Windows 2000 platform.

--*/

#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include "scenum.h"


typedef struct {
    SCARDCONTEXT hCtx;
    LPWSTR mszReaders;
    DWORD dwEnumIndex;
    DWORD dwActiveReaderCount;
    DWORD dwReaderCount;
    LPSCARD_READERSTATEW rgReaderStates;
} scEnlistContext;


/*++

CountReaders:

    This routine returns the number of active smart card readers currently
    installed in the system.

Arguments:

    pvHandle supplies the context handle, if any.  If it is not NULL, then an
        existing context is assumed and used.  Otherwise, a temporary internal
        context is created for use just within this routine.

Return Value:

    The actual number of readers currently installed in the system.

Remarks:

    If an error occurs, this routine returns zero.  The actual error code will
    be available via GetLastError.

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

DWORD
CountReaders(
    IN LPVOID pvHandle)
{
    DWORD dwCount = 0;
    DWORD dwErr = ERROR_SUCCESS;
    SCARDCONTEXT hCtx = NULL;
    LPWSTR mszReaders = NULL;
    LPWSTR szRdr;
    DWORD cchReaders;
    scEnlistContext *pscCtx = (scEnlistContext *)pvHandle;


    //
    // See if we can take a shortcut.
    //

    if (NULL != pscCtx)
    {
        if (0 == pscCtx->dwReaderCount)
            SetLastError(ERROR_SUCCESS);
        return pscCtx->dwReaderCount;
    }

    //
    // We have to do things the hard way.
    // Create a temporary context.
    //

    dwErr = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hCtx);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // Get a list of active readers, and count them.
    //

    cchReaders = SCARD_AUTOALLOCATE;
    dwErr = SCardListReadersW(hCtx, NULL, (LPWSTR)&mszReaders, &cchReaders);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;
    for (szRdr = mszReaders; 0 != *szRdr; szRdr += lstrlenW(szRdr) + 1)
        dwCount += 1;
    dwErr = SCardFreeMemory(hCtx, mszReaders);
    mszReaders = NULL;
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // Eliminate our temporary context.
    //

    dwErr = SCardReleaseContext(hCtx);
    hCtx = NULL;
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // Inform the caller of our findings.
    //

    if (0 == dwCount)
        SetLastError(ERROR_SUCCESS);
    return dwCount;


    //
    // An error has occurred.  Clean up, and return.
    //

ErrorExit:
    if (NULL != mszReaders)
        SCardFreeMemory(hCtx, mszReaders);
    if ((NULL == pvHandle) && (NULL != hCtx))
        SCardReleaseContext(hCtx);
    SetLastError(dwErr);
    return 0;
}


/*++

ScanReaders:

    This function scans active readers in preparation for future
    EnumInsertedCards calls.  It does not block for changes, but just takes a
    snapshot of the existing environment.

Arguments:

    ppvHandle supplies a pointer to an LPVOID to be used by this and associated
        routines to maintain an internal context.

Return Value:

    The number of readers with cards inserted, or zero if an error occurs.  When
    an error occurs, the actual error code can be obtained from GetLastError.

Remarks:

    Prior to the first call to this service, the value of the LPVOID pointed to
    by ppvHandle should be set to NULL.  When all processing is complete, call
    the EndReaderScan service to clean up the internal working space and reset
    the value to NULL.

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

DWORD
ScanReaders(
    IN OUT LPVOID *ppvHandle)
{
    DWORD dwCount = 0;
    DWORD dwErr = SCARD_S_SUCCESS;
    LPWSTR szRdr;
    DWORD cchReaders, cRdrs, dwIndex;
    scEnlistContext *pscCtx = *(scEnlistContext **)ppvHandle;

    if (NULL == pscCtx)
    {

        //
        // Create the context structure.
        //

        pscCtx = (scEnlistContext *)LocalAlloc(LPTR, sizeof(scEnlistContext));
        if (NULL == pscCtx)
        {
            dwErr = SCARD_E_NO_MEMORY;
            goto ErrorExit;
        }
        ZeroMemory(pscCtx, sizeof(scEnlistContext));

        dwErr = SCardEstablishContext(
                    SCARD_SCOPE_USER,
                    NULL,
                    NULL,
                    &pscCtx->hCtx);
        if (SCARD_S_SUCCESS != dwErr)
            goto ErrorExit;
    }


    //
    // Get a list and a count of the readers.
    //

    if (NULL != pscCtx->mszReaders)
    {
        dwErr = SCardFreeMemory(pscCtx->hCtx, pscCtx->mszReaders);
        pscCtx->mszReaders = NULL;
        if (dwErr != SCARD_S_SUCCESS)
            goto ErrorExit;
    }
    cchReaders = SCARD_AUTOALLOCATE;
    dwErr = SCardListReadersW(
                pscCtx->hCtx,
                NULL,
                (LPWSTR)&pscCtx->mszReaders,
                &cchReaders);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;
    cRdrs = 0;
    for (szRdr = pscCtx->mszReaders; 0 != *szRdr; szRdr += lstrlenW(szRdr) + 1)
        cRdrs += 1;


    //
    // Enlarge the reader state array if necessary.
    //

    if (cRdrs > pscCtx->dwReaderCount)
    {
        if (NULL != pscCtx->rgReaderStates)
        {
            LocalFree(pscCtx->rgReaderStates);
            pscCtx->dwReaderCount = 0;
        }
        pscCtx->rgReaderStates =
            (LPSCARD_READERSTATEW)LocalAlloc(
                LPTR,
                cRdrs * sizeof(SCARD_READERSTATEW));
        if (NULL == pscCtx->rgReaderStates)
        {
            dwErr = SCARD_E_NO_MEMORY;
            goto ErrorExit;
        }
        pscCtx->dwReaderCount = cRdrs;
    }
    ZeroMemory(pscCtx->rgReaderStates, cRdrs * sizeof(SCARD_READERSTATEW));
    pscCtx->dwActiveReaderCount = cRdrs;


    //
    // Fill in the state array.
    //

    cRdrs = 0;
    for (szRdr = pscCtx->mszReaders; 0 != *szRdr; szRdr += lstrlenW(szRdr) + 1)
    {
        pscCtx->rgReaderStates[cRdrs].szReader = szRdr;
        pscCtx->rgReaderStates[cRdrs].dwCurrentState = SCARD_STATE_UNAWARE;
        cRdrs += 1;
    }
    dwErr = SCardGetStatusChangeW(
                pscCtx->hCtx,
                0,
                pscCtx->rgReaderStates,
                cRdrs);
    if (SCARD_S_SUCCESS != dwErr)
        goto ErrorExit;


    //
    // We're all set for EnumInsertedCard calls.
    // Count the number of readers with cards, and return.
    //

    for (dwIndex = 0; dwIndex < cRdrs; dwIndex += 1)
    {
        if (0 != (
                SCARD_STATE_PRESENT
                & pscCtx->rgReaderStates[dwIndex].dwEventState))
            dwCount += 1;
    }

    pscCtx->dwEnumIndex = 0;
    *ppvHandle = pscCtx;
    if (0 == dwCount)
        SetLastError(SCARD_S_SUCCESS);
    return dwCount;


    //
    // An error has occurred.  Clean up to the last known good state.
    //

ErrorExit:
    if ((NULL == *ppvHandle) && (NULL != pscCtx))
    {
        if (NULL != pscCtx->mszReaders)
        {
            SCardFreeMemory(pscCtx->hCtx, pscCtx->mszReaders);
            pscCtx->mszReaders = NULL;
        }
        if (NULL != pscCtx->hCtx)
            SCardReleaseContext(pscCtx->hCtx);
        if (NULL != pscCtx->rgReaderStates)
            LocalFree(pscCtx->rgReaderStates);
        LocalFree(pscCtx);
    }
    return 0;
}


/*++

EnumInsertedCards:

    This routine is designed to be called repeatedly after first calling the
    ScanReaders service.  It will repeatedly return information about cards
    available for use against CryptoAPI, until all cards have been returned.

Arguments:

    pvHandle supplies the context handle in use.

    szCryptoProvider is a buffer to receive the name of the Cryptographic
        Service Provider associated with the card in the reader.

    cchCryptoProvider supplies the length of the szCryptoProvider buffer, in
        characters.  If this length is not sufficient to hold the name of the
        provider, the routine returns FALSE, and GetLastError will return
        SCARD_E_INSUFFICIENT_BUFFER.

    pdwProviderType receives the type of the smart card provider (this will be
        PROV_RSA_FULL for all known smart card CSPs).

    pszReaderName receives a pointer to the name of the reader being returned.

Return Value:

    TRUE - The output variables have been set to the next available card.

    FALSE - There are no more cards to be returned, or some other error has
        occurred, per the value available from GetLastError.

Remarks:

    The list of cards can be reset using the ScanReaders service.

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

BOOL
EnumInsertedCards(
    IN  LPVOID pvHandle,
    OUT LPWSTR szCryptoProvider,
    IN  DWORD cchCryptoProvider,
    OUT LPDWORD pdwProviderType,
    OUT LPCWSTR *pszReaderName)
{
    DWORD dwIndex;
    DWORD dwSts;
    LPWSTR mszCards = NULL;
    DWORD dwLength;
    scEnlistContext *pscCtx = (scEnlistContext *)pvHandle;


    //
    // Run through the remaining readers and see what's left to report.
    //

    for (dwIndex = pscCtx->dwEnumIndex;
         dwIndex < pscCtx->dwActiveReaderCount;
         dwIndex += 1)
    {
        if (   (0 != ( SCARD_STATE_PRESENT
                       & pscCtx->rgReaderStates[dwIndex].dwEventState))
            && (0 == ( SCARD_STATE_MUTE
                       & pscCtx->rgReaderStates[dwIndex].dwEventState)))
        {

            //
            // This card is active.  Try to map it to a CSP.
            //

            dwLength = SCARD_AUTOALLOCATE;
            dwSts = SCardListCardsW(
                        pscCtx->hCtx,
                        pscCtx->rgReaderStates[dwIndex].rgbAtr,
                        NULL,
                        0,
                        (LPWSTR)&mszCards,
                        &dwLength);
            if (SCARD_S_SUCCESS != dwSts)
            {

                //
                // Probably an unregistered card type.  Keep looking.
                //

                goto NextCard;
            }


            //
            // We just use the first returned card name.  We don't
            // have a mechanism to declare, "same card, next provider"
            // yet.  Since there are no cards that have this problem
            // that we know of, we'll limp along for now.
            //

            //
            // Map the card name to a CSP.
            //

            dwLength = cchCryptoProvider;
            dwSts = SCardGetCardTypeProviderNameW(
                        pscCtx->hCtx,
                        mszCards,
                        SCARD_PROVIDER_CSP,
                        szCryptoProvider,
                        &dwLength);
            if (SCARD_S_SUCCESS != dwSts)
            {

                //
                // Probably no mapping.  Keep looking.
                //

                goto NextCard;
            }


            //
            // At this point, we've found a card and mapped it to it's
            // CSP Name.
            //

            //
            // It would be nice to map the CSP Name to a CSP Type.
            // For now, they're all PROV_RSA_FULL.
            //

            *pdwProviderType = PROV_RSA_FULL;


            //
            // Return what we know to the caller, saving state for the
            // next time through.
            //

            SCardFreeMemory(pscCtx->hCtx, mszCards);
            mszCards = NULL;
            pscCtx->dwEnumIndex = dwIndex + 1;
            *pszReaderName = pscCtx->rgReaderStates[dwIndex].szReader;
            return TRUE;
        }


        //
        // The current card was rejected.  Do any clean up, and move on to
        // the next card.
        //

NextCard:
        if (NULL != mszCards)
        {
            SCardFreeMemory(pscCtx->hCtx, mszCards);
            mszCards = NULL;
        }
    }


    //
    // We fell out the bottom of the loop.  This means we didn't find any
    // more readers with cards inserted.  Report that we're done for this
    // scan.
    //

    pscCtx->dwEnumIndex = pscCtx->dwActiveReaderCount;
    SetLastError(SCARD_S_SUCCESS);
    return FALSE;
}


/*++

EndReaderScan:

    This routine is used to clean up internal memory used by other services
    in this module.

Arguments:

    ppvHandle supplies a pointer to an LPVOID being used by this and associated
        routines to maintain an internal context.  Associated memory will be
        freed, and the value reset to NULL.

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 11/12/1998

--*/

void
EndReaderScan(
    LPVOID *ppvHandle)
{
    scEnlistContext *pscCtx = *(scEnlistContext **)ppvHandle;

    if (NULL != pscCtx)
    {
        if (NULL != pscCtx->mszReaders)
        {
            SCardFreeMemory(pscCtx->hCtx, pscCtx->mszReaders);
            pscCtx->mszReaders = NULL;
        }
        if (NULL != pscCtx->hCtx)
            SCardReleaseContext(pscCtx->hCtx);
        if (NULL != pscCtx->rgReaderStates)
            LocalFree(pscCtx->rgReaderStates);
        LocalFree(pscCtx);
        *ppvHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scrdenrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scrdenrl.cpp
//
//--------------------------------------------------------------------------

// scrdenrl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for scrdenrl.idl by adding the following 
//		files to the Outputs.
//			scrdenrl_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f scrdenrlps.mk in the project directory.

#include <stdafx.h>
#include <comcat.h>
#include <objsafe.h>
#include "resource.h"
#include "initguid.h"
#include "scrdenrl.h"



#include "SCrdEnr.h"

/*#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif*/

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SCrdEnr, CSCrdEnr)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
/*#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif  */
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
/*#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif */
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
/*#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif */
	return _Module.GetClassObject(rclsid, riid, ppv);
}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
/*#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif*/

    HRESULT hRes=S_OK;
    BOOL    fInitialize=FALSE;

    hRes= _Module.RegisterServer(TRUE);

    if(!FAILED(CoInitialize(NULL)))
        fInitialize=TRUE;

	// registers object, typelib and all interfaces in typelib
    RegisterCLSIDInCategory(CLSID_SCrdEnr, CATID_SafeForScripting);

    if(fInitialize)
        CoUninitialize();  

	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
/*#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif  */

    BOOL    fInitialize=FALSE;

    if(!FAILED(CoInitialize(NULL)))
        fInitialize=TRUE;

    UnRegisterCLSIDInCategory(CLSID_SCrdEnr, CATID_SafeForScripting);

    if(fInitialize)
        CoUninitialize();  

	_Module.UnregisterServer();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\scrdenr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scrdenr.h
//
//--------------------------------------------------------------------------

// SCrdEnr.h : Declaration of the CSCrdEnr

#ifndef __SCRDENR_H_
#define __SCRDENR_H_

#include <certca.h>
#include "xenroll.h"
#include "resource.h"       // main symbols
#include "objsel.h"


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CSP_INFO
typedef struct  _SCrdEnroll_CSP_INFO
{
    DWORD   dwCSPType;
    LPWSTR  pwszCSPName;
}SCrdEnroll_CSP_INFO, *PSCrdEnroll_CSP_INFO;


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CA_INFO
typedef struct  _SCrdEnroll_CA_INFO
{
    LPWSTR              pwszCAName;
    LPWSTR              pwszCALocation;
	LPWSTR				pwszCADisplayName;
}SCrdEnroll_CA_INFO, *PSCrdEnroll_CA_INFO;


/////////////////////////////////////////////////////////////////////////////
// SCrdEnroll_CT_INFO
typedef struct  _SCrdEnroll_CT_INFO
{
    LPWSTR              pwszCTName;
    LPWSTR              pwszCTDisplayName;
    PCERT_EXTENSIONS    pCertTypeExtensions;
    DWORD               dwKeySpec;
    DWORD               dwGenKeyFlags; 
    DWORD               dwRASignature; 
    BOOL                fCAInfo;
    DWORD               dwCAIndex;
    DWORD               dwCACount;
    SCrdEnroll_CA_INFO  *rgCAInfo;
    BOOL                fMachine;
    DWORD               dwEnrollmentFlags;
    DWORD               dwSubjectNameFlags;
    DWORD               dwPrivateKeyFlags;
    DWORD               dwGeneralFlags; 
    LPWSTR             *rgpwszSupportedCSPs;
    DWORD               dwCurrentCSP;
} SCrdEnroll_CT_INFO, *PSCrdEnroll_CT_INFO;


////////////////////////////////////////////////////////////////////////
// 
// Prototypes for functions loaded at runtime. 
//
////////////////////////////////////////////////////////////////////////
HRESULT WINAPI MyCAGetCertTypeFlagsEx
(IN  HCERTTYPE           hCertType,
 IN  DWORD               dwOption,
 OUT DWORD *             pdwFlags);

HRESULT WINAPI MyCAGetCertTypePropertyEx
(IN  HCERTTYPE   hCertType,
 IN  LPCWSTR     wszPropertyName,
 OUT LPVOID      pPropertyValue);

IEnroll4 * WINAPI MyPIEnroll4GetNoCOM();

void InitializeThunks(); 

/////////////////////////////////////////////////////////////////////////////
// CSCrdEnr
class ATL_NO_VTABLE CSCrdEnr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSCrdEnr, &CLSID_SCrdEnr>,
	public IDispatchImpl<ISCrdEnr, &IID_ISCrdEnr, &LIBID_SCRDENRLLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SCRDENR)

BEGIN_COM_MAP(CSCrdEnr)
	COM_INTERFACE_ENTRY(ISCrdEnr)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISCrdEnr
public:

    CSCrdEnr();

    virtual ~CSCrdEnr();


    STDMETHOD(getCertTemplateCount)
        (/* [in] */                   DWORD dwFlags, 
         /* [retval][out] */          long *pdwCertTemplateCount);


    STDMETHOD(setCertTemplateName)
	(/* [in] */                   DWORD dwFlags, 
	 /* [in] */                   BSTR bstrCertTemplateName);

    STDMETHOD(getCertTemplateName)
	(/* [in] */                   DWORD dwFlags, 
	 /* [retval][out] */          BSTR *pbstrCertTemplateName);


    STDMETHOD(enumCSPName)
	(/* [in] */                    DWORD dwIndex, 
	 /* [in] */                    DWORD dwFlags, 
	 /* [retval][out] */           BSTR *pbstrCSPName);

    STDMETHOD(enumCertTemplateName)
	(/* [in] */                    DWORD dwIndex, 
	 /* [in] */                    DWORD dwFlags, 
	 /* [retval][out] */           BSTR *pbstrCertTemplateName);


    STDMETHOD(getCertTemplateInfo)
	(/* [in] */                   BSTR     bstrCertTemplateName, 
	 /* [in] */                   LONG     lType,
     /* [retval][out] */          VARIANT *pvarCertTemplateInfo);


    STDMETHOD(setUserName)
	(/* [in] */                    DWORD dwFlags, 
	 /* [in] */                    BSTR bstrUserName);


    STDMETHOD(getUserName)
	(/* [in] */                    DWORD dwFlags, 
	 /* [retval][out] */           BSTR *pbstrUserName);

    STDMETHOD(getCACount)
	(/* [in] */                    BSTR bstrCertTemplateName, 
	 /* [retval][out] */           long *pdwCACount);

    STDMETHOD(setCAName)
	(/* [in] */                    DWORD dwFlags,
	 /* [in] */                    BSTR bstrCertTemplateName, 
	 /* [in] */                    BSTR bstrCAName);

    STDMETHOD(getCAName)
	(/* [in] */                    DWORD dwFlags,
	 /* [in] */                    BSTR bstrCertTemplateName, 
	 /* [retval][out] */           BSTR *pbstrCAName);

    STDMETHOD(enumCAName)
	(/* [in] */                    DWORD dwIndex, 
	 /* [in] */                    DWORD dwFlags, 
	 /* [in] */                    BSTR bstrCertTemplateName, 
	 /* [retval][out] */           BSTR *pbstrCAName);

    STDMETHOD(resetUser)();

    STDMETHOD(selectSigningCertificate)
        (/* [in] */                   DWORD     dwFlags,
         /* [in] */                   BSTR      bstrCertTemplateName);

    STDMETHOD(setSigningCertificate)
        (/* [in] */                   DWORD     dwFlags, 
         /* [in] */                   BSTR      bstrCertTemplateName);

    STDMETHOD(getSigningCertificateName)
        (/* [in] */                   DWORD     dwFlags, 
         /* [retval][out] */          BSTR      *pbstrSigningCertName);

    STDMETHOD(getEnrolledCertificateName)
        (/*[in]  */                   DWORD     dwFlags,
	 /* [retval][out] */           BSTR      *pBstrCertName);

    STDMETHOD(enroll)
        (/* [in] */                 DWORD   dwFlags);

    STDMETHOD(selectUserName)
        (/* [in] */                 DWORD   dwFlags);

    STDMETHOD(get_CSPName)
        (/*[out, retval]*/ BSTR *pVal);

    STDMETHOD(put_CSPName)
        (/*[in]*/ BSTR newVal);

    STDMETHOD(get_CSPCount)
        (/*[out, retval]*/ long *pVal);

    STDMETHOD(get_EnrollmentStatus)
      (/*[retval][out] */ LONG * plEnrollmentStatus); 


 private:
    HRESULT GetCAExchangeCertificate(IN BSTR bstrCAQualifiedName, PCCERT_CONTEXT *ppCert); 
    HRESULT _getCertTemplateExtensionInfo(
        IN CERT_EXTENSIONS  *pCertTypeExtensions,
        IN LONG              lType,
        OUT VOID            *pExtInfo);
    HRESULT _getStrCertTemplateCSPList(
        IN DWORD             dwIndex,
        IN DWORD             dwFlag,
        OUT WCHAR          **ppwszSupportedCSP);
    
    HRESULT CertTemplateCountOrName(
	    IN  DWORD dwIndex, 
	    IN  DWORD dwFlags, 
        OUT long *pdwCertTemplateCount,
	    OUT BSTR *pbstrCertTemplateName);

     DWORD                   m_dwCTCount;
    DWORD                   m_dwCTIndex;
    SCrdEnroll_CT_INFO      *m_rgCTInfo;
    DWORD                   m_dwCSPCount;
    DWORD                   m_dwCSPIndex;
    SCrdEnroll_CSP_INFO     *m_rgCSPInfo;
    LPWSTR                  m_pwszUserUPN;              //the UPN name of the user
    LPWSTR                  m_pwszUserSAM;              //the SAM name of the user
    PCCERT_CONTEXT          m_pSigningCert;
    PCCERT_CONTEXT          m_pEnrolledCert;
    CRITICAL_SECTION		m_cSection;
    BOOL                    m_fInitialize;
    LONG                    m_lEnrollmentStatus;
    BOOL                    m_fSCardSigningCert;        //whether the signing certificate is on a smart card
    LPSTR                   m_pszCSPNameSigningCert;    //the CSP name of the signing certificate
    DWORD                   m_dwCSPTypeSigningCert;     //the CSP type of the signing certificate
    LPSTR                   m_pszContainerSigningCert;  //the container name of the signing certificate 
    IDsObjectPicker        *m_pDsObjectPicker;         //pointer to the object selection dialogue
    CERT_EXTENSIONS        *m_pCachedCTEs;  //point to cert extensions
    WCHAR                  *m_pwszCachedCTEOid;
    CERT_TEMPLATE_EXT      *m_pCachedCTE;
};

#endif //__SCRDENR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\caddroot.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:	caddroot.cpp
//
//--------------------------------------------------------------------------

// caddroot.cpp : Implementation of Ccaddroot

#include "stdafx.h"
#include "cobjsaf.h"
#include "Xaddroot.h"
#include "caddroot.h"
#include "rootlist.h"
#include "assert.h"

#include "wincrypt.h"
#include "unicode.h"
#include "ui.h"

BOOL FAnyCertUpdates(HCERTSTORE hStore, HCERTSTORE hStoreCertsToCheck) {

    BOOL            fSomeNotInStore = FALSE;
    PCCERT_CONTEXT  pCertContext    = NULL;
    PCCERT_CONTEXT  pCertTemp       = NULL;
    BYTE            arHashBytes[20];
    CRYPT_HASH_BLOB blobHash        = {sizeof(arHashBytes), arHashBytes};

    while(NULL != (pCertContext = CertEnumCertificatesInStore(hStoreCertsToCheck, pCertContext))) {

        if( CryptHashCertificate(
            NULL,
            0,
            X509_ASN_ENCODING,
            pCertContext->pbCertEncoded,
            pCertContext->cbCertEncoded,
            blobHash.pbData,
            &blobHash.cbData) ) {

            pCertTemp = CertFindCertificateInStore(
                    hStore,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_HASH,
                    &blobHash,
                    NULL);

            fSomeNotInStore = (fSomeNotInStore || (pCertTemp == NULL));

            if(pCertTemp != NULL)
                CertFreeCertificateContext(pCertTemp);

        }
    }

    return(fSomeNotInStore);
}

BOOL MyCryptInstallSignedListOfTrustedRoots(
    DWORD       dwMsgAndCertEncodeingType,
    LPCWSTR     wszCTL,
    DWORD       dwFlags,
    void *      pvReserved
    ) {

    BOOL            fIsProtected        = TRUE;
    BOOL            fRet                = TRUE;
    DWORD           cb                  = 0;
    BYTE *          pb                  = NULL;
    BOOL            fRemoveRoots        = FALSE;
    HCERTSTORE      hStore              = NULL;
    HCERTSTORE      hStoreRoot          = NULL;
    PCCERT_CONTEXT  pCertContext        = NULL;
    PCCERT_CONTEXT  pCertContextInStore = NULL;
    PCCERT_CONTEXT  pCertContextSigner  = NULL;
    HINSTANCE       hCryptUI            = NULL;
    INT_PTR         iDlgRet             = 0;
    HKEY            hKeyStores          = NULL;
    DWORD           err;
    DWORD           dwVer               = 0;
    CRYPT_DATA_BLOB dataBlob            = {0, NULL};
    MDI             mdi;
    WCHAR           wrgInstallCA[MAX_MSG_LEN];
    WCHAR           wrgJustSayYes[MAX_MSG_LEN];

    BYTE            arHashBytes[20];
    CRYPT_HASH_BLOB blobHash                = {sizeof(arHashBytes), arHashBytes};

    BOOL fAnyCertUpdates;

     if(NULL == (pb = HTTPGet(wszCTL, &cb)))
        goto ErrorReturn;

    // get the certs to add or delete
    if(!I_CertVerifySignedListOfTrustedRoots(
        pb,
        cb,
        &fRemoveRoots,  
        &hStore,
        &pCertContextSigner
        ))
        goto ErrorReturn;

    if(fRemoveRoots) {
        SetLastError(E_NOTIMPL);
        goto ErrorReturn;
    }

    dwVer = GetVersion();

    // see if this is NT5 or higher
    if((dwVer < 0x80000000) && ((dwVer & 0xFF) >= 5)) {

        if(NULL == (hStoreRoot = CertOpenStore(
                  CERT_STORE_PROV_SYSTEM,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                  L"Root" 
                  )) ) 
            goto ErrorReturn;

    // else it is before NT5 or Win9x and does not have a protected store.
    } else {

        if(ERROR_SUCCESS != (err = RegOpenKeyA(
            HKEY_CURRENT_USER,
            "Software\\Microsoft\\SystemCertificates\\Root",
            &hKeyStores
            ))) {
            SetLastError(err);
            hKeyStores = NULL;
            goto ErrorReturn;
        }
            
        // open the root store
        // must be current user
        if( NULL == (hStoreRoot = CertOpenStore(
                  CERT_STORE_PROV_REG,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_CURRENT_USER,
                  (void *) hKeyStores 
                  )) )
            goto ErrorReturn;

        fIsProtected = FALSE;            
    }


    // prepare the data for the dialog
    memset(&mdi, 0, sizeof(mdi));
    if( NULL != (hCryptUI = LoadLibraryA("cryptui.dll")) )
        mdi.pfnCryptUIDlgViewCertificateW = (PFNCryptUIDlgViewCertificateW)
                            GetProcAddress(hCryptUI, "CryptUIDlgViewCertificateW");
    mdi.hStore = hStore;
    mdi.pCertSigner = pCertContextSigner;
    mdi.hInstance = _Module.GetResourceInstance();

    fAnyCertUpdates = FAnyCertUpdates(hStoreRoot, hStore);
    if (fAnyCertUpdates) {
      // put the dialog up
      iDlgRet = DialogBoxParam(
        _Module.GetResourceInstance(),  
        (LPSTR) MAKEINTRESOURCE(IDD_MAINDLG),
        NULL,      
        MainDialogProc,
        (LPARAM) &mdi);
    }
    else
    {
       iDlgRet = IDYES;
    }

   
    if(hCryptUI != NULL)
        FreeLibrary(hCryptUI);
    hCryptUI = NULL;

    // only take it if the user said OK
    if(iDlgRet != IDYES)
        goto ErrorReturn;

    // throw UI if we are on a protected system
    if(fIsProtected && fAnyCertUpdates) {
    
        // put up the Just Say Yes to install the CA dialog
        LoadStringU(_Module.GetResourceInstance(), IDS_INSTALLCA, wrgInstallCA, sizeof(wrgInstallCA)/sizeof(WCHAR));
        LoadStringU(_Module.GetResourceInstance(), IDS_JUST_SAY_YES, wrgJustSayYes, sizeof(wrgJustSayYes)/sizeof(WCHAR));
        MessageBoxU(NULL, wrgJustSayYes, wrgInstallCA, MB_OK);
    }
 
    while(NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertContext))) {

        // add the cert to the store
        assert(pCertContextInStore == NULL);
        CertAddCertificateContextToStore(
            hStoreRoot,
            pCertContext,
            CERT_STORE_ADD_USE_EXISTING,
            &pCertContextInStore
            );

        // move the EKU property in case the cert already existed
        if(pCertContextInStore != NULL) {

            assert(dataBlob.cbData == 0);

            // Attempt to delete the old EKU, if we succeed we will put
            // the new EKU on it, otherwise if we fail we know we don't
            // have access to HKLM and we should just add the cert to the HKCU
            if(!CertSetCertificateContextProperty(
                  pCertContextInStore,
                  CERT_ENHKEY_USAGE_PROP_ID,
                  0,
                  NULL
                  )) {

                // just add the cert, should go to HKCU, if it fails, what am I going
                // to do about it, just continue
                CertAddCertificateContextToStore(
                    hStoreRoot,
                    pCertContext,
                    CERT_STORE_ADD_ALWAYS,
                    NULL
                    );

                // at this point I know I have access to the cert and I know the
                // EKU have been removed, only add the EKU if the new one has some EKU's
            } else if( CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    NULL, 
                    &dataBlob.cbData  
                    )                    
                &&
                (NULL != (dataBlob.pbData = (PBYTE) malloc(dataBlob.cbData)))
                &&
                CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    dataBlob.pbData, 
                    &dataBlob.cbData  
                    )
                ) {

                // set EKU on the cert, what am I going to do if it fails, just continue
                CertSetCertificateContextProperty(
                    pCertContextInStore,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    0,
                    &dataBlob
                    );
            }

            // free context and memory
            CertFreeCertificateContext(pCertContextInStore);
            pCertContextInStore = NULL;

            if(dataBlob.pbData != NULL)
                free(dataBlob.pbData);
            memset(&dataBlob, 0, sizeof(CRYPT_DATA_BLOB));
        }
    }

CommonReturn:    

    if(pCertContextSigner != NULL)
        CertFreeCertificateContext(pCertContextSigner);
        
    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);

    if(pCertContextInStore != NULL)
        CertFreeCertificateContext(pCertContextInStore);

    if(hStore != NULL) 
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);  // clean up from dialog box dups

    if(hStoreRoot != NULL) 
        CertCloseStore(hStoreRoot, 0);

    if(hKeyStores != NULL)
        RegCloseKey(hKeyStores);
        
    if(pb != NULL)
        free(pb);

    return(fRet);

ErrorReturn: 

    fRet = FALSE;

    goto CommonReturn;

}    

HRESULT STDMETHODCALLTYPE Ccaddroot::AddRoots(BSTR wszCTL) {

    HRESULT                                 hr;
    DWORD                                   fRet                                        = TRUE;


        fRet =  MyCryptInstallSignedListOfTrustedRoots(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            wszCTL,
            0,
            NULL);


    if(fRet)
        hr = S_OK;
    else
        hr = MY_HRESULT_FROM_WIN32(GetLastError());


    return hr;

}

BOOL MyCryptInstallIntermediateCAs(
    DWORD       dwMsgAndCertEncodeingType,
    LPCWSTR     wszX509,
    DWORD       dwFlags,
    void *      pvReserved
    ) {

    DWORD           cb              = 0;
    DWORD           cCerts          = 0;
    BYTE *          pb              = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    PCCERT_CONTEXT  pCertContextT   = NULL;
    HCERTSTORE      hStore          = NULL;
    BOOL            fOK             = FALSE;

    pb = HTTPGet(wszX509, &cb);

    if(pb != NULL) {

        pCertContext = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pb,
            cb
            );
 
        if(pCertContext != NULL) {

            hStore = CertOpenStore(
              CERT_STORE_PROV_SYSTEM,
              X509_ASN_ENCODING,
              NULL,
              CERT_SYSTEM_STORE_CURRENT_USER,
              L"CA" 
              );

            if(hStore != NULL) {

                // count the number of certs in the store
                cCerts = 0;
                while(NULL != (pCertContextT = CertEnumCertificatesInStore(hStore, pCertContextT)))
                    cCerts++;

                if(FIsTooManyCertsOK(cCerts, _Module.GetResourceInstance())) {

                    CertAddCertificateContextToStore(
                        hStore,
                        pCertContext,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        );

                    CertCloseStore(hStore, 0);
                    fOK = TRUE;
                }
            }
 
            CertFreeCertificateContext(pCertContext);
        }
        free(pb);
    }

    return(fOK);
}

HRESULT STDMETHODCALLTYPE Ccaddroot::AddCA(BSTR wszX509) {

    HRESULT                                 hr;
    DWORD                                   fRet                                        = TRUE;

        fRet =  MyCryptInstallIntermediateCAs(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            wszX509,
            0,
            NULL);

    if(fRet)
        hr = S_OK;
    else
        hr = MY_HRESULT_FROM_WIN32(GetLastError());


    return hr;
}

HRESULT __stdcall Ccaddroot::GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) {

    RPC_STATUS rpcStatus;          

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    *pdwEnabledOptions   = dwEnabledSafteyOptions;
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;


    return(S_OK);
}


HRESULT __stdcall Ccaddroot::SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) {

    RPC_STATUS rpcStatus;          
    DWORD dwSupport = 0;            

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    dwSupport = dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);        
    if(dwSupport != 0)
        return(E_FAIL);

    dwEnabledSafteyOptions &= ~dwOptionSetMask;
    dwEnabledSafteyOptions |= dwEnabledOptions; 
            
return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\caddroot.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:	caddroot.h
//
//--------------------------------------------------------------------------

// caddroot.h : Declaration of the Ccaddroot

#ifndef __CADDROOT_H_
#define __CADDROOT_H_

#include "instres.h"       // main symbols
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Ccaddroot
class ATL_NO_VTABLE Ccaddroot : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Ccaddroot, &CLSID_caddroot>,
	public IDispatchImpl<Icaddroot, &IID_Icaddroot, &LIBID_XADDROOTLib>,
	public IObjectSafety
{
public:
	Ccaddroot()
	{
	    dwEnabledSafteyOptions = 0;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CADDROOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Ccaddroot)
	COM_INTERFACE_ENTRY(Icaddroot)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// Icaddroot
public:

DWORD   dwEnabledSafteyOptions;

HRESULT virtual STDMETHODCALLTYPE AddRoots(BSTR wszCTL);

HRESULT virtual STDMETHODCALLTYPE AddCA(BSTR wszX509);


virtual HRESULT __stdcall Ccaddroot::GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);


virtual HRESULT __stdcall Ccaddroot::SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions);

};



BYTE * HTTPGet(const WCHAR * wszURL, DWORD * pcbReceiveBuff);

#endif //__CADDROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__80CB787B_20DE_11D2_8D5C_00C04FC29D45__INCLUDED_)
#define AFX_STDAFX_H__80CB787B_20DE_11D2_8D5C_00C04FC29D45__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__80CB787B_20DE_11D2_8D5C_00C04FC29D45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\cobjsaf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cobjsaf.cpp
//
//--------------------------------------------------------------------------


#include "cobjsaf.h"

// This class provides a simple implementation for IObjectSafety for
// for object that are either always safe or always unsafe for scripting
// and/or initializing with persistent data.
//
// The constructor takes an IUnknown interface on an outer object and delegates
// all IUnknown calls through that object.  Because of this, the object must
// be explicitly destroyed using C++ (rather than COM) mechanisms, either by
// using "delete" or by making the object an embedded member of some other class.
//
// The constructor also takes two booleans telling whether the object is safe
// for scripting and initializing from persistent data.

#if 0
// Return the interface setting options on this object
STDMETHODIMP CObjectSafety::GetInterfaceSafetyOptions(
    /*IN */  REFIID iid,                    // Interface that we want options for
    /*OUT*/ DWORD   *   pdwSupportedOptions,    // Options meaningful on this interface
    /*OUT*/ DWORD * pdwEnabledOptions)      // current option values on this interface
{
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER || INTERFACESAFE_FOR_UNTRUSTED_DATA;
    if (iid==IID_IDispatch)
    {
        *pdwEnabledOptions = m_fSafeForScripting ?
            INTERFACESAFE_FOR_UNTRUSTED_CALLER :
            0;
        return S_OK;
    }
    else if (iid==IID_IPersistStorage || iid==IID_IPersistStream)
    {
        *pdwEnabledOptions = m_fSafeForInitializing ?
            INTERFACESAFE_FOR_UNTRUSTED_DATA :
            0;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

// Attempt to set the interface setting options on this object.
// Since these are assumed to be fixed, we basically just check
// that the attempted settings are valid.
STDMETHODIMP CObjectSafety::SetInterfaceSafetyOptions(
    /*IN */  REFIID iid,                    // Interface to set options for
    /*IN */  DWORD      dwOptionsSetMask,       // Options to change
    /*IN */  DWORD      dwEnabledOptions)       // New option values

{
    // If they haven't asked for anything, we can certainly provide that
    if ((dwOptionsSetMask & dwEnabledOptions) == 0)
        return S_OK;

    if (iid==IID_IDispatch)
    {
        // Make sure they haven't asked for an option we don't support
        if ((dwEnabledOptions & dwOptionsSetMask) != INTERFACESAFE_FOR_UNTRUSTED_CALLER)
            return E_FAIL;

        return m_fSafeForScripting ? S_OK : E_FAIL;
    }
    else if (iid==IID_IPersistStorage || iid==IID_IPersistStream)
    {
        if ((dwEnabledOptions & dwOptionsSetMask) != INTERFACESAFE_FOR_UNTRUSTED_DATA)
            return E_FAIL;
        return m_fSafeForInitializing ? S_OK : E_FAIL;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
    {

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (FAILED(hr))
        return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is
    int len = wcslen(catDescription);
    if (len>127)
        len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
    // Make sure the description is null terminated
    catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
    pcr->Release();

    return hr;
    }

#endif


// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
    }

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\scrdenrl\thunks.cpp ===
#include <windows.h>
#include <certca.h>
#include "xenroll.h"

typedef HRESULT (WINAPI * PFNCAGetCertTypeFlagsEx) 
    (IN  HCERTTYPE           hCertType,
     IN  DWORD               dwOption,
     OUT DWORD *             pdwFlags);

typedef HRESULT (WINAPI * PFNCAGetCertTypePropertyEx) 
    (IN  HCERTTYPE   hCertType,
     IN  LPCWSTR     wszPropertyName,
     OUT LPVOID      pPropertyValue);

typedef IEnroll4 * (WINAPI * PFNPIEnroll4GetNoCOM)(); 

PFNCAGetCertTypeFlagsEx     g_pfnCAGetCertTypeFlagsEx     = NULL; 
PFNCAGetCertTypePropertyEx  g_pfnCAGetCertTypePropertyEx  = NULL; 
PFNPIEnroll4GetNoCOM        g_pfnPIEnroll4GetNoCOM        = NULL; 

//////////////////////////////////////////////////////////////////////
//
// Initializes the thunked procedures.  Should be called before calling
// any other function in this file. 
//
//////////////////////////////////////////////////////////////////////
void InitializeThunks() 
{ 
    HINSTANCE hCertCliDll = NULL; 
    HINSTANCE hXenroll   = NULL; 

    hCertCliDll = LoadLibraryW(L"certcli.dll"); 
    if (NULL != hCertCliDll) {
        g_pfnCAGetCertTypeFlagsEx     = (PFNCAGetCertTypeFlagsEx)GetProcAddress(hCertCliDll, "CAGetCertTypeFlagsEx"); 
        g_pfnCAGetCertTypePropertyEx  = (PFNCAGetCertTypePropertyEx)GetProcAddress(hCertCliDll, "CAGetCertTypePropertyEx"); 
    }
     
    hXenroll = LoadLibraryW(L"xenroll.dll"); 
    if (NULL != hXenroll) { 
        g_pfnPIEnroll4GetNoCOM  = (PFNPIEnroll4GetNoCOM)GetProcAddress(hXenroll, "PIEnroll4GetNoCOM"); 
    }
}

HRESULT WINAPI MyCAGetCertTypeFlagsEx
(IN  HCERTTYPE           hCertType,
 IN  DWORD               dwOption,
 OUT DWORD *             pdwFlags)
{
    if (NULL != g_pfnCAGetCertTypeFlagsEx) { 
        return g_pfnCAGetCertTypeFlagsEx(hCertType, dwOption, pdwFlags); 
    } else { 
        return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    }
}

HRESULT WINAPI MyCAGetCertTypePropertyEx
(IN  HCERTTYPE   hCertType,
 IN  LPCWSTR     wszPropertyName,
 OUT LPVOID      pPropertyValue)
{
    if (NULL != g_pfnCAGetCertTypePropertyEx) { 
        return g_pfnCAGetCertTypePropertyEx(hCertType, wszPropertyName, pPropertyValue); 
    } else { 
        return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    }
}

IEnroll4 * WINAPI MyPIEnroll4GetNoCOM()
{
    if (NULL != g_pfnPIEnroll4GetNoCOM) { 
        return g_pfnPIEnroll4GetNoCOM(); 
    } else { 
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED); 
        return NULL; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\makefile.inc ===
xaddroot_i.c : $(PROJECT_ROOT)\published\xaddroot\xaddroot_i.c
    copy $** $@

$(O)\xaddroot.tlb : $(PROJECT_ROOT)\published\xaddroot\$(O)\xaddroot.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cactl2.rc
//
#define IDD_MAINDLG			270
#define IDD_CAINFO			271
#define IDI_INSTALL_CERT			3490
#define IDC_INSTALLCA_CALIST		1010
#define IDC_INSTALLCA_VERIFIER		1011
#define IDC_INSTALLCA_MOREINFO		1012
#define IDC_INSTALLCA_LEGALDISCLAIMER	1014
#define IDC_CAINFO_THUMBPRINT		1015
#define IDC_CAINFO_THUMBPRINT_ALGORITHM 1016
#define IDC_CAINFO_VIEWCERT		1018
#define IDC_CAINFO_NAME 		1019
#define IDC_CAINFO_EXPIRATION_DATE	1020
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\instres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       instres.h
//
//--------------------------------------------------------------------------
#define IDS_PROJNAME                    7000
#define IDS_LEGALDISCLAIMER             7005
#define IDR_CADDROOT			        7006
#define IDR_CDELROOT			        7007
#define IDS_INSTALLCA			        7008
#define IDS_JUST_SAY_YES		        7009
#define IDS_TOO_MANY_CA_CERTS		    7010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\rootlist.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.h
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#ifndef __ROOT_LIST_INCLUDED__
#define __ROOT_LIST_INCLUDED__

#include "wincrypt.h"


//+-------------------------------------------------------------------------
//  Verify that the encoded CTL contains a signed list of roots. For success,
//  return certificate store containing the trusted roots to add or
//  remove. Also for success, return certificate context of the signer.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - There is at least one SubjectUsage (really the roots enhanced key usage)
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  The following CTL extensions are processed:
//   - szOID_ENHANCED_KEY_USAGE - if present, must contain
//     szOID_ROOT_LIST_SIGNER usage
//   - szOID_REMOVE_CERTIFICATE - integer value, 0 => FALSE (add)
//     1 => TRUE (remove), all other values are invalid
//   - szOID_CERT_POLICIES - ignored
//
//  If the CTL contains any other critical extensions, then, the
//  CTL verification fails.
//
//  For a successfully verified CTL:
//   - TRUE is returned
//   - *pfRemoveRoots is set to FALSE to add roots and is set to TRUE to
//     remove roots.
//   - *phRootListStore is a certificate store containing only the roots to
//     add or remove. *phRootListStore must be closed by calling
//     CertCloseStore(). For added roots, the CTL's SubjectUsage field is
//     set as CERT_ENHKEY_USAGE_PROP_ID on all of the certificates in the
//     store.
//   - *ppSignerCert is a pointer to the certificate context of the signer.
//     *ppSignerCert must be freed by calling CertFreeCertificateContext().
//
//   Otherwise, FALSE is returned with *phRootListStore and *ppSignerCert
//   set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertVerifySignedListOfTrustedRoots(
    IN const BYTE               *pbCtlEncoded,
    IN DWORD                    cbCtlEncoded,
    OUT BOOL                    *pfRemoveRoots,     // FALSE: add, TRUE: remove
    OUT HCERTSTORE              *phRootListStore,
    OUT PCCERT_CONTEXT          *ppSignerCert
    );





#endif  // __ROOT_LIST_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A8B640FA_461D_442D_8E72_6C9824635647__INCLUDED_)
#define AFX_STDAFX_H__A8B640FA_461D_442D_8E72_6C9824635647__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A8B640FA_461D_442D_8E72_6C9824635647__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\cobjsaf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cobjsaf.h
//
//--------------------------------------------------------------------------

#ifndef __COBJSAF_H
#define __COBJSAF_H

#include "objsafe.h"
#include "comcat.h"

// This class provides a simple implementation for IObjectSafety for
// for object that are either always safe or always unsafe for scripting
// and/or initializing with persistent data.
//
// The constructor takes an IUnknown interface on an outer object and delegates
// all IUnknown calls through that object.  Because of this, the object must
// be explicitly destroyed using C++ (rather than COM) mechanisms, either by
// using "delete" or by making the object an embedded member of some other class.
//
// The constructor also takes two booleans telling whether the object is safe
// for scripting and initializing from persistent data.

#if 0
class CObjectSafety : public IObjectSafety
{
	public:
	CObjectSafety::CObjectSafety
	(
	IUnknown *punkOuter,				// outer (controlling object)
	BOOL fSafeForScripting = TRUE,		// whether the object is safe for scripting
	BOOL fSafeForInitializing = TRUE	// whether the object is safe for initializing
	)	
	{
		m_punkOuter = punkOuter;
		m_fSafeForScripting = fSafeForScripting;
		m_fSafeForInitializing = fSafeForInitializing;
	}

	// Delegating versions of IUnknown functions
	STDMETHODIMP_(ULONG) AddRef() {
		return m_punkOuter->AddRef();
	}

	STDMETHODIMP_(ULONG) Release()	{
		return m_punkOuter->Release();
	}

	STDMETHODIMP QueryInterface(REFIID iid, LPVOID* ppv)	{
		return m_punkOuter->QueryInterface(iid, ppv);
	}

	// Return the interface setting options on this object
	STDMETHODIMP GetInterfaceSafetyOptions(
		/*IN */  REFIID	iid,					// Interface that we want options for
		/*OUT*/ DWORD	*	pdwSupportedOptions,	// Options meaningful on this interface
		/*OUT*/ DWORD *	pdwEnabledOptions)		// current option values on this interface
		;

	// Attempt to set the interface setting options on this object.
	// Since these are assumed to be fixed, we basically just check
	// that the attempted settings are valid.
	STDMETHODIMP SetInterfaceSafetyOptions(
		/*IN */  REFIID	iid,					// Interface to set options for
		/*IN */  DWORD		dwOptionsSetMask,		// Options to change
		/*IN */  DWORD		dwEnabledOptions)		// New option values
		;

	protected:
	IUnknown *m_punkOuter;
	BOOL	m_fSafeForScripting;
	BOOL	m_fSafeForInitializing;
};

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription);
#endif

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\rootlist.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.cpp
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//
//  Functions:  I_CertVerifySignedListOfTrustedRoots
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "softpub.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "dbgdef.h"
#include "rootlist.h"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


#define SHA1_HASH_LEN       20

//+-------------------------------------------------------------------------
//  SHA1 Key Identifier of the signer's root
//--------------------------------------------------------------------------
STATIC BYTE rgbSignerRootKeyId[SHA1_HASH_LEN] = {
#if 1
    // The following is the sha1 key identifier for the Microsoft root
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D
#else
    // The following is the sha1 key identifier for the test root
    0x9A, 0xA6, 0x58, 0x7F, 0x94, 0xDD, 0x91, 0xD9, 0x1E, 0x63,
    0xDF, 0xD3, 0xF0, 0xCE, 0x5F, 0xAE, 0x18, 0x93, 0xAA, 0xB7
#endif
};

//+-------------------------------------------------------------------------
// If the certificate has an EKU extension, returns an allocated and
// decoded EKU. Otherwise, returns NULL.
//
// LocalFree() must be called to free the returned EKU.
//--------------------------------------------------------------------------
STATIC
PCERT_ENHKEY_USAGE
WINAPI
GetAndAllocCertEKUExt(
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage;

    cbUsage = 0;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,                                   // pUsage
            &cbUsage) || 0 == cbUsage)
        goto GetEnhancedKeyUsageError;
    if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) LocalAlloc(LPTR, cbUsage)))
        goto OutOfMemory;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            pUsage,
            &cbUsage))
        goto GetEnhancedKeyUsageError;

CommonReturn:
    return pUsage;
ErrorReturn:
    if (pUsage) {
        LocalFree(pUsage);
        pUsage = NULL;
    }
    goto CommonReturn;

SET_ERROR(GetEnhancedKeyUsageError, CERT_E_WRONG_USAGE)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

//+-------------------------------------------------------------------------
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  For success, *ppSignerCert is updated with certificate context of the
//  signer.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
GetAndVerifyTrustedRootsSigner(
    IN HCRYPTMSG hCryptMsg,
    IN HCERTSTORE hMsgStore,
    OUT PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    LONG lStatus;
    PCCERT_CONTEXT pSignerCert = NULL;
    GUID wvtCertActionID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    WINTRUST_CERT_INFO wvtCertInfo;
    WINTRUST_DATA wvtData;
    BOOL fCloseWVT = FALSE;
    DWORD dwLastError = 0;

    CRYPT_PROVIDER_DATA *pProvData;     // not allocated
    CRYPT_PROVIDER_SGNR *pProvSigner;   // not allocated
    CRYPT_PROVIDER_CERT *pProvCert;     // not allocated
    DWORD idxCert;
    PCCERT_CONTEXT pCert;               // not refCount'ed

    PCERT_ENHKEY_USAGE pUsage = NULL;

    BYTE rgbKeyId[SHA1_HASH_LEN];
    DWORD cbKeyId;

    if (!CryptMsgGetAndVerifySigner(
            hCryptMsg,
            0,                      // cSignerStore
            NULL,                   // rghSignerStore
            0,                      // dwFlags
            &pSignerCert,
            NULL                    // pdwSignerIndex
            ))
        goto CryptMsgGetAndVerifySignerError;

    memset(&wvtCertInfo, 0, sizeof(wvtCertInfo));
    wvtCertInfo.cbStruct = sizeof(wvtCertInfo);
    wvtCertInfo.psCertContext = (PCERT_CONTEXT) pSignerCert;
    wvtCertInfo.chStores = 1;
    wvtCertInfo.pahStores = &hMsgStore;
    wvtCertInfo.dwFlags = 0;
    wvtCertInfo.pcwszDisplayName = L"";

    memset(&wvtData, 0, sizeof(wvtData));
    wvtData.cbStruct = sizeof(wvtData);
    wvtData.pPolicyCallbackData = (void *) szOID_ROOT_LIST_SIGNER;
    wvtData.dwUIChoice = WTD_UI_NONE;
    wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
    wvtData.pCert = &wvtCertInfo;
    wvtData.dwStateAction = WTD_STATEACTION_VERIFY;
    wvtData.hWVTStateData = NULL;
    wvtData.dwProvFlags = 0;

    lStatus = WinVerifyTrust(
                NULL,               // hwnd
                &wvtCertActionID,
                &wvtData
                );

#if (0) // DSIE
    if (ERROR_SUCCESS != lStatus)
        goto WinVerifyTrustError;
    else
        fCloseWVT = TRUE;
#else
    if (ERROR_SUCCESS != lStatus  && CERT_E_REVOCATION_FAILURE != lStatus)
        goto WinVerifyTrustError;
    else
        fCloseWVT = TRUE;
#endif
    if (NULL == (pProvData = WTHelperProvDataFromStateData(
            wvtData.hWVTStateData)))
        goto NoProvDataError;
    if (0 == pProvData->csSigners)
        goto NoProvSignerError;
    if (NULL == (pProvSigner = WTHelperGetProvSignerFromChain(
            pProvData,
            0,              // idxSigner
            FALSE,          // fCounterSigner
            0               // idxCounterSigner
            )))
        goto NoProvSignerError;

    if (2 > pProvSigner->csCertChain)
        goto MissingSignerCertsError;

    // Check that the top level certificate contains the public
    // key for the Microsoft root.
    pProvCert = WTHelperGetProvCertFromChain(pProvSigner,
        pProvSigner->csCertChain - 1);
    if (NULL == pProvCert)
        goto UnexpectedError;
    pCert = pProvCert->pCert;

    cbKeyId = SHA1_HASH_LEN;
    if (!CryptHashPublicKeyInfo(
            NULL,               // hCryptProv
            CALG_SHA1,
            0,                  // dwFlags
            X509_ASN_ENCODING,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            rgbKeyId,
            &cbKeyId
            ))
        goto HashPublicKeyInfoError;

    if (SHA1_HASH_LEN != cbKeyId ||
            0 != memcmp(rgbSignerRootKeyId, rgbKeyId, SHA1_HASH_LEN))
        goto InvalidSignerRootError;

    // Check that the signer and intermediate certs have the RootListSigner
    // Usage extension
    for (idxCert = 0; idxCert < pProvSigner->csCertChain - 1; idxCert++) {
        DWORD i;

        pProvCert = WTHelperGetProvCertFromChain(pProvSigner, idxCert);
        if (NULL == pProvCert)
            goto UnexpectedError;
        pCert = pProvCert->pCert;

        pUsage = GetAndAllocCertEKUExt(pCert);
        if (NULL == pUsage)
            goto GetAndAllocCertEKUExtError;

        for (i = 0; i < pUsage->cUsageIdentifier; i++) {
            if (0 == strcmp(szOID_ROOT_LIST_SIGNER,
                    pUsage->rgpszUsageIdentifier[i]))
                break;
        }

        if (i == pUsage->cUsageIdentifier)
            goto MissingTrustListSignerUsageError;

        LocalFree(pUsage);
        pUsage = NULL;

    }

    fResult = TRUE;

CommonReturn:
    if (fCloseWVT) {
        wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
        lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    &wvtCertActionID,
                    &wvtData
                    );
    }
    if (pUsage)
        LocalFree(pUsage);

    SetLastError(dwLastError);
    *ppSignerCert = pSignerCert;
    return fResult;
ErrorReturn:
    dwLastError = GetLastError();
    if (pSignerCert) {
        CertFreeCertificateContext(pSignerCert);
        pSignerCert = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CryptMsgGetAndVerifySignerError)
SET_ERROR_VAR(WinVerifyTrustError, lStatus)
SET_ERROR(NoProvDataError, E_UNEXPECTED)
SET_ERROR(NoProvSignerError, TRUST_E_NO_SIGNER_CERT)
SET_ERROR(MissingSignerCertsError, CERT_E_CHAINING)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
TRACE_ERROR(HashPublicKeyInfoError)
SET_ERROR(InvalidSignerRootError, CERT_E_UNTRUSTEDROOT)
TRACE_ERROR(GetAndAllocCertEKUExtError)
SET_ERROR(MissingTrustListSignerUsageError, CERT_E_WRONG_USAGE)
}

//+-------------------------------------------------------------------------
// Returns TRUE if all the CTL fields are valid. Checks for the following:
//  - There is at least one SubjectUsage (really the roots enhanced key usage)
//  - If NextUpdate isn't NULL, that the CTL is still time valid
//  - Only allow roots identified by their sha1 hash
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyTrustedRootsCtlFields(
    IN PCTL_INFO pCtlInfo
    )
{
    BOOL fResult;

    // Must have a least one usage
    if (0 == pCtlInfo->SubjectUsage.cUsageIdentifier)
        goto NoSubjectUsageError;


    // If NextUpdate is present, verify that the CTL hasn't expired.
    if (pCtlInfo->NextUpdate.dwLowDateTime ||
                pCtlInfo->NextUpdate.dwHighDateTime) {
        SYSTEMTIME SystemTime;
        FILETIME FileTime;

        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);

        if (CompareFileTime(&FileTime, &pCtlInfo->NextUpdate) > 0)
            goto ExpiredCtlError;
    }

    // Only allow roots identified by their sha1 hash
    if (0 != strcmp(szOID_OIWSEC_sha1,
            pCtlInfo->SubjectAlgorithm.pszObjId))
        goto InvalidSubjectAlgorithm;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoSubjectUsageError, ERROR_INVALID_DATA)
SET_ERROR(ExpiredCtlError, CERT_E_EXPIRED)
SET_ERROR(InvalidSubjectAlgorithm, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
// Returns TRUE if all the known extensions are valid and there aren't any
// unknown critical extensions.
//
// We know about the following extensions:
//  - szOID_ENHANCED_KEY_USAGE - if present, must contain
//      szOID_ROOT_LIST_SIGNER usage
//  - szOID_REMOVE_CERTIFICATE - integer value, 0 => FALSE (add)
//      1 => TRUE (remove), all other values are invalid
//  - szOID_CERT_POLICIES - ignored
//
// If szOID_REMOVE_CERTIFICATE is present, then, *pfRemoveRoots is updated.
// Otherwise, *pfRemoveRoots defaults to FALSE.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyTrustedRootsCtlExtensions(
    IN PCTL_INFO pCtlInfo,
    OUT BOOL *pfRemoveRoots
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    DWORD cExt;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbRemoveRoots;

    *pfRemoveRoots = FALSE;

    // Verify the extensions
    for (cExt = pCtlInfo->cExtension,
         pExt = pCtlInfo->rgExtension; 0 < cExt; cExt--, pExt++) {
        if (0 == strcmp(szOID_ENHANCED_KEY_USAGE, pExt->pszObjId)) {
            DWORD cbUsage;
            DWORD i;

            // Check for szOID_ROOT_LIST_SIGNER usage

            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    0,                          // dwFlags
                    NULL,                       // pvStructInfo
                    &cbUsage
                    ))
                goto DecodeEnhancedKeyUsageExtError;
            if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) LocalAlloc(
                    LPTR, cbUsage)))
                goto OutOfMemory;
            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    0,                          // dwFlags
                    pUsage,
                    &cbUsage
                    ))
                goto DecodeEnhancedKeyUsageExtError;
            for (i = 0; i < pUsage->cUsageIdentifier; i++) {
                if (0 == strcmp(szOID_ROOT_LIST_SIGNER,
                        pUsage->rgpszUsageIdentifier[i]))
                    break;
            }

            if (i == pUsage->cUsageIdentifier)
                goto MissingTrustListSignerUsageInExtError;

            LocalFree(pUsage);
            pUsage = NULL;
        } else if (0 == strcmp(szOID_REMOVE_CERTIFICATE, pExt->pszObjId)) {
            int iVal;
            DWORD cbVal;

            cbVal = sizeof(iVal);
            iVal = 0;
            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_INTEGER,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    0,                          // dwFlags
                    &iVal,
                    &cbVal
                    ))
                goto DecodeRemoveCertificateExtError;

            switch(iVal) {
                case 0:
                    *pfRemoveRoots = FALSE;
                    break;
                case 1:
                    *pfRemoveRoots = TRUE;
                    break;
                default:
                    goto InvalidRemoveCertificateExtValueError;
            }
        } else if (0 == strcmp(szOID_CERT_POLICIES, pExt->pszObjId)) {
            ;
        } else if (pExt->fCritical) {
            goto UnknownCriticalExtensionError;
        }
    }

    fResult = TRUE;

CommonReturn:
    if (pUsage)
        LocalFree(pUsage);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeEnhancedKeyUsageExtError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(MissingTrustListSignerUsageInExtError, ERROR_INVALID_DATA)
TRACE_ERROR(DecodeRemoveCertificateExtError)
SET_ERROR(InvalidRemoveCertificateExtValueError, ERROR_INVALID_DATA)
SET_ERROR(UnknownCriticalExtensionError, ERROR_INVALID_DATA)
}


//+-------------------------------------------------------------------------
// Returns TRUE, if a sha1 entry exists in the CTL for the certificate
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
IsTrustedRoot(
    IN PCTL_INFO pCtlInfo,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult = FALSE;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];
    DWORD cbSha1Hash;
    DWORD cEntry;
    PCTL_ENTRY pEntry;          // not allocated

    cbSha1Hash = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbSha1Hash,
            &cbSha1Hash
            ))
        goto GetSha1HashError;

    for (cEntry = pCtlInfo->cCTLEntry,
         pEntry = pCtlInfo->rgCTLEntry; 0 < cEntry; cEntry--, pEntry++) {
        if (SHA1_HASH_LEN == pEntry->SubjectIdentifier.cbData &&
                0 == memcmp(rgbSha1Hash, pEntry->SubjectIdentifier.pbData,
                    SHA1_HASH_LEN)) {
            fResult = TRUE;
            break;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(GetSha1HashError)
}

//+-------------------------------------------------------------------------
// Checks if the certificate has an EKU extension and if all of the
// cert's usages are within the specified list of usages.
//
// Returns TRUE if the above two conditions are satisfied.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
IsValidCertEKUExtSubset(
    IN PCCERT_CONTEXT pCert,
    PCERT_ENHKEY_USAGE pValidUsage
    )
{
    PCERT_ENHKEY_USAGE pCertUsage = NULL;
    BOOL fResult = FALSE;
    DWORD i, j;

    pCertUsage = GetAndAllocCertEKUExt(pCert);
    if (NULL == pCertUsage || 0 == pCertUsage->cUsageIdentifier)
        goto CommonReturn;

    for (i = 0; i < pCertUsage->cUsageIdentifier; i++) {
        for (j = 0; j < pValidUsage->cUsageIdentifier; j++) {
            if (0 == strcmp(pCertUsage->rgpszUsageIdentifier[i],
                    pValidUsage->rgpszUsageIdentifier[j]))
                break;
        }
        if (j == pValidUsage->cUsageIdentifier)
            // No Match
            goto CommonReturn;
    }

    fResult = TRUE;

CommonReturn:
    if (pCertUsage)
        LocalFree(pCertUsage);
    return fResult;
}

//+-------------------------------------------------------------------------
// Removes all certificates from the store not having a sha1 hash
// entry in the CTL.
//
// For added certificates, sets the CERT_ENHKEY_USAGE_PROP_ID
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
FilterAndUpdateTrustedRootsInStore(
    IN PCTL_INFO pCtlInfo,
    IN BOOL fRemoveRoots,
    IN OUT HCERTSTORE hMsgStore
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;
    CRYPT_DATA_BLOB EncodedUsage = {0, NULL};   // pbData is allocated

    if (!fRemoveRoots) {
        // Re-encode the decoded SubjectUsage field. It will be added as
        // a CERT_ENHKEY_USAGE_PROP_ID to each of the certs in the list

        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_ENHANCED_KEY_USAGE,
                &pCtlInfo->SubjectUsage,
                NULL,                   // pbEncoded
                &EncodedUsage.cbData
                ))
            goto EncodeUsageError;
        if (NULL == (EncodedUsage.pbData = (BYTE *) LocalAlloc(
            LPTR, EncodedUsage.cbData)))
                goto OutOfMemory;
        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_ENHANCED_KEY_USAGE,
                &pCtlInfo->SubjectUsage,
                EncodedUsage.pbData,
                &EncodedUsage.cbData
                ))
            goto EncodeUsageError;
    }

    // Iterate through the certificates in the message store.
    // Remove certificates not in the signed CTL entry list
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hMsgStore, pCert)) {
        if (IsTrustedRoot(pCtlInfo, pCert)) {
            // Add the enhanced key usage property if the certificate
            // doesn't already have an EKU extension that's a subset
            // of the SubjectUsage
            if (!fRemoveRoots && !IsValidCertEKUExtSubset(
                    pCert, &pCtlInfo->SubjectUsage)) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_ENHKEY_USAGE_PROP_ID,
                        0,                          // dwFlags
                        &EncodedUsage
                        ))
                    goto SetEnhancedKeyUsagePropertyError;
            }
        } else {
            PCCERT_CONTEXT pCertDup;

            pCertDup = CertDuplicateCertificateContext(pCert);
            CertDeleteCertificateFromStore(pCertDup);
        }
    }

    fResult = TRUE;
CommonReturn:
    if (EncodedUsage.pbData)
        LocalFree(EncodedUsage.pbData);
    if (pCert)
        CertFreeCertificateContext(pCert);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EncodeUsageError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(SetEnhancedKeyUsagePropertyError)
}

//+-------------------------------------------------------------------------
//  Verify that the encoded CTL contains a signed list of roots. For success,
//  return certificate store containing the trusted roots to add or
//  remove. Also for success, return certificate context of the signer.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - There is at least one SubjectUsage (really the roots enhanced key usage)
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  The following CTL extensions are processed:
//   - szOID_ENHANCED_KEY_USAGE - if present, must contain
//     szOID_ROOT_LIST_SIGNER usage
//   - szOID_REMOVE_CERTIFICATE - integer value, 0 => FALSE (add)
//     1 => TRUE (remove), all other values are invalid
//   - szOID_CERT_POLICIES - ignored
//
//  If the CTL contains any other critical extensions, then, the
//  CTL verification fails.
//
//  For a successfully verified CTL:
//   - TRUE is returned
//   - *pfRemoveRoots is set to FALSE to add roots and is set to TRUE to
//     remove roots.
//   - *phRootListStore is a certificate store containing only the roots to
//     add or remove. *phRootListStore must be closed by calling
//     CertCloseStore(). For added roots, the CTL's SubjectUsage field is
//     set as CERT_ENHKEY_USAGE_PROP_ID on all of the certificates in the
//     store.
//   - *ppSignerCert is a pointer to the certificate context of the signer.
//     *ppSignerCert must be freed by calling CertFreeCertificateContext().
//
//   Otherwise, FALSE is returned with *phRootListStore and *ppSignerCert
//   set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertVerifySignedListOfTrustedRoots(
    IN const BYTE               *pbCtlEncoded,
    IN DWORD                    cbCtlEncoded,
    OUT BOOL                    *pfRemoveRoots,     // FALSE: add, TRUE: remove
    OUT HCERTSTORE              *phRootListStore,
    OUT PCCERT_CONTEXT          *ppSignerCert
    )
{
    BOOL fResult;
    PCCTL_CONTEXT pCtl = NULL;
    HCERTSTORE hMsgStore = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    BOOL fRemoveRoots = FALSE;
    PCTL_INFO pCtlInfo;                 // not allocated

    if (NULL == (pCtl = CertCreateCTLContext(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pbCtlEncoded,
            cbCtlEncoded)))
        goto CreateCtlContextError;

    if (NULL == (hMsgStore = CertOpenStore(
            CERT_STORE_PROV_MSG,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                      // hCryptProv
            0,                      // dwFlags
            pCtl->hCryptMsg         // pvPara
            )))
        goto OpenMsgStoreError;

    if (!GetAndVerifyTrustedRootsSigner(
            pCtl->hCryptMsg, hMsgStore, &pSignerCert))
        goto GetAndVerifyTrustedRootsSignerError;

    pCtlInfo = pCtl->pCtlInfo;

    if (!VerifyTrustedRootsCtlFields(pCtlInfo))
        goto VerifyCtlFieldsError;
    if (!VerifyTrustedRootsCtlExtensions(pCtlInfo, &fRemoveRoots))
        goto VerifyCtlExtensionsError;
    if (!FilterAndUpdateTrustedRootsInStore(pCtlInfo, fRemoveRoots, hMsgStore))
        goto FilterAndUpdateTrustedRootsError;

    fResult = TRUE;
CommonReturn:
    if (pCtl)
        CertFreeCTLContext(pCtl);
    *pfRemoveRoots = fRemoveRoots;
    *phRootListStore = hMsgStore;
    *ppSignerCert = pSignerCert;
    return fResult;
ErrorReturn:
    if (pSignerCert) {
        CertFreeCertificateContext(pSignerCert);
        pSignerCert = NULL;
    }

    if (hMsgStore) {
        CertCloseStore(hMsgStore, 0);
        hMsgStore = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateCtlContextError)
TRACE_ERROR(OpenMsgStoreError)
TRACE_ERROR(GetAndVerifyTrustedRootsSignerError)
TRACE_ERROR(VerifyCtlFieldsError)
TRACE_ERROR(VerifyCtlExtensionsError)
TRACE_ERROR(FilterAndUpdateTrustedRootsError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\ui.h ===
#include "cryptui.h"

#define MY_HRESULT_FROM_WIN32(a) ((a >= 0x80000000) ? a : HRESULT_FROM_WIN32(a))
#define MAX_HASH_LEN                20
#define MAX_MSG_LEN                 256
#define CACERTWARNINGLEVEL          500

typedef BOOL (WINAPI * PFNCryptUIDlgViewCertificateW) (
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged
        );

typedef struct _MDI {
    HCERTSTORE                      hStore;
    PCCERT_CONTEXT                  pCertSigner;
    HINSTANCE                       hInstance;
    PFNCryptUIDlgViewCertificateW   pfnCryptUIDlgViewCertificateW;
} MDI, * PMDI;  // Main Dialog Init

typedef struct _MIU {
    PCCERT_CONTEXT                  pCertContext;
    HINSTANCE                       hInstance;
    PFNCryptUIDlgViewCertificateW   pfnCryptUIDlgViewCertificateW;
} MIU, *PMIU; // More Info User data

INT_PTR CALLBACK MainDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
); 

BOOL FIsTooManyCertsOK(DWORD cCerts, HINSTANCE hInstanceUI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\ui.cpp ===
#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#include "ui.h"
#include "instres.h"
#include "resource.h"

#include <malloc.h>
#include <assert.h>


//+-------------------------------------------------------------------------
//  Formats multi bytes into WCHAR hex. Includes a space after every 4 bytes.
//
//  Needs (cb * 2 + cb/4 + 1) characters in wsz
//--------------------------------------------------------------------------
static void FormatMsgBoxMultiBytes(DWORD cb, BYTE *pb, LPWSTR wsz)
{
    for (DWORD i = 0; i<cb; i++) {
        int b;
        if (i && 0 == (i & 1))
            *wsz++ = L' ';
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}


INT_PTR CALLBACK MoreInfoDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
) {

    PMIU                                pmiu            = NULL;
    FILETIME                            ftLocal;
    SYSTEMTIME                          stLocal;
    DWORD                               dwChar;
    LPWSTR                              wszName;
    BYTE                                rgbHash[MAX_HASH_LEN];
    DWORD                               cbHash = MAX_HASH_LEN;
    HWND                                hwnd;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW     cryptUI;
    WCHAR                               wsz[128];

    switch(uMsg) {

        case WM_CLOSE:
            EndDialog(hwndDlg, 0);
            return(0);
            break;
     
        case WM_INITDIALOG:

            // remember my imput data
            SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
            pmiu = (PMIU) lParam;

            // hide the window if we don't have a cryptUI dll
            if(NULL == pmiu->pfnCryptUIDlgViewCertificateW  &&
               NULL != (hwnd = GetDlgItem(hwndDlg, IDC_CAINFO_VIEWCERT)) )
                   ShowWindow(hwnd, SW_HIDE);
 
            // put in the name
	    if(0 != (dwChar=CertNameToStrW(
		X509_ASN_ENCODING,
		&pmiu->pCertContext->pCertInfo->Subject,
        CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                NULL,
                0
                ) )) {
                
                wszName = (LPWSTR) _alloca(sizeof(WCHAR) * dwChar); 
            
		if(dwChar == CertNameToStrW(
		    X509_ASN_ENCODING,
		    &pmiu->pCertContext->pCertInfo->Subject,
		    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    wszName,
                    dwChar
                    ) ) {
                    
                    SendDlgItemMessageU( 
                        hwndDlg, 
                        IDC_CAINFO_NAME, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM) wszName);
                }
            }

            wsz[0] = 0;
            FileTimeToLocalFileTime(&pmiu->pCertContext->pCertInfo->NotAfter, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &stLocal);
            GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal, NULL, wsz, 128);
            
            // put not after date
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_CAINFO_EXPIRATION_DATE,
                WM_SETTEXT, 
                0, 
                (LPARAM) wsz);
 
            // get the sha1 thumbprint
            if (CertGetCertificateContextProperty(
                    pmiu->pCertContext,
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash,
                    &cbHash)) {
                FormatMsgBoxMultiBytes(cbHash, rgbHash, wsz);
                SendDlgItemMessageU( 
                    hwndDlg, 
                    IDC_CAINFO_THUMBPRINT, 
                    WM_SETTEXT, 
                    0, 
                    (LPARAM) wsz);
            }

            // put in the thumbprint alg
            // no localization needed
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_CAINFO_THUMBPRINT_ALGORITHM, 
                WM_SETTEXT, 
                0, 
                (LPARAM) L"SHA1");

            return(TRUE);
            break;

        case WM_COMMAND:

            switch(HIWORD(wParam)) {

                case BN_CLICKED:

                    switch(LOWORD(wParam)) {
                        case IDOK:
                        case IDCANCEL:
                            EndDialog(hwndDlg, LOWORD(wParam));
                            return(TRUE);
                            break;

                        case IDC_CAINFO_VIEWCERT:

                        GetWindowLongPtr(hwndDlg, DWLP_USER);

                            if(NULL != (pmiu = (PMIU) GetWindowLongPtr(hwndDlg, DWLP_USER))     &&
                               NULL != pmiu->pfnCryptUIDlgViewCertificateW                      ) {
                            
                                memset(&cryptUI, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW));
                                cryptUI.dwSize = sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW);
                                cryptUI.pCertContext = pmiu->pCertContext;
                                cryptUI.hwndParent = hwndDlg;
                                cryptUI.dwFlags = 
                                    CRYPTUI_DISABLE_ADDTOSTORE | CRYPTUI_IGNORE_UNTRUSTED_ROOT;
                                pmiu->pfnCryptUIDlgViewCertificateW(&cryptUI, NULL);
                                return(TRUE);
                            }
                            break;
                    }
                    break;
            }
            break;
    }

    return(FALSE);
}

int MoreInfoDlg(
    HWND            hDlgBox,
    int             idLB
) {
    PCCERT_CONTEXT  pCertContext;
    PMDI            pmdi    = (PMDI) GetWindowLongPtr(hDlgBox, DWLP_USER);
    INT_PTR         iItem;
    MIU             miu;

    // What is currently selected
    iItem = SendDlgItemMessageA( 
      hDlgBox,
      idLB, 
      LB_GETCURSEL, 
      0,
      0
      );

    if(iItem == LB_ERR)
      return(LB_ERR);


    // get the pCertContext
    pCertContext = (PCCERT_CONTEXT) SendDlgItemMessageA( 
      hDlgBox,
      idLB, 
      LB_GETITEMDATA, 
      (WPARAM) iItem,
      0
      );

    if(pCertContext == (PCCERT_CONTEXT) LB_ERR  ||  pCertContext == NULL)
      return(LB_ERR);

    // set up the parameters for the more info dialog
    miu.pCertContext                    = pCertContext;
    miu.hInstance                       = pmdi->hInstance;
    miu.pfnCryptUIDlgViewCertificateW   = pmdi->pfnCryptUIDlgViewCertificateW;

    // put the dialog up
    DialogBoxParam(
      pmdi->hInstance,  
      (LPSTR) MAKEINTRESOURCE(IDD_CAINFO),
      hDlgBox,      
      MoreInfoDialogProc,
      (LPARAM) &miu);

    return(0);
}

int AddCertNameToListBox(
    PCCERT_CONTEXT  pCertContext, 
    HWND            hDlgBox,
    int             idLB
) {

    int     itemIndex;
    DWORD   dwChar;
    LPWSTR  wszName;

    if(0 == (dwChar=CertNameToStrW(
	X509_ASN_ENCODING,
	&pCertContext->pCertInfo->Subject,
    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
	NULL,
        0
        ) ))
        return(LB_ERR);

    wszName = (LPWSTR) _alloca(sizeof(WCHAR) * dwChar); // no error checking, will stack fault, not return NULL
    
    if(dwChar != CertNameToStrW(
	X509_ASN_ENCODING,
	&pCertContext->pCertInfo->Subject,
    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
	wszName,
        dwChar
        ) )
         return(LB_ERR);

    itemIndex = (int) SendDlgItemMessageU( 
        hDlgBox, 
        idLB, 
        LB_ADDSTRING, 
        0, 
        (LPARAM) wszName) ;

    if(LB_ERR == itemIndex || LB_ERRSPACE == itemIndex)
        return(itemIndex);

    if(LB_ERR ==  SendDlgItemMessageA( 
      hDlgBox,
      idLB, 
      LB_SETITEMDATA, 
      (WPARAM) itemIndex,
      (LPARAM) CertDuplicateCertificateContext(pCertContext)
      ) )
      return(LB_ERR);
      
       
return(0);
}


INT_PTR CALLBACK MainDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
) {

    PMDI            pmdi            = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    WCHAR           wrgDisclaimer[4096];  // because legal stuff is long
    DWORD           dwChar;
    LPWSTR          wszName;

    switch(uMsg) {

        case WM_CLOSE:
            EndDialog(hwndDlg, IDNO);
            return(0);
            break;
     
        case WM_INITDIALOG:

            pmdi = (PMDI) lParam;
            SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);

            // put in the signer name
	    if(0 != (dwChar=CertNameToStrW(
		X509_ASN_ENCODING,
		&pmdi->pCertSigner->pCertInfo->Subject,
        CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		NULL,
                0
                ) )) {
                
                wszName = (LPWSTR) _alloca(sizeof(WCHAR) * dwChar); 
            
		if(dwChar == CertNameToStrW(
		    X509_ASN_ENCODING,
		    &pmdi->pCertSigner->pCertInfo->Subject,
		    CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    wszName,
                    dwChar
                    ) ) {
                    
                    SendDlgItemMessageU( 
                        hwndDlg, 
                        IDC_INSTALLCA_VERIFIER, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM) wszName);
                }
            }

            // set legal disclaimer
            LoadStringU(pmdi->hInstance, IDS_LEGALDISCLAIMER, wrgDisclaimer, sizeof(wrgDisclaimer)/sizeof(WCHAR));
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_INSTALLCA_LEGALDISCLAIMER, 
                WM_SETTEXT, 
                0, 
                (LPARAM) wrgDisclaimer) ;

            // add each cert to the list box
            while(NULL != (pCertContext = CertEnumCertificatesInStore(pmdi->hStore, pCertContext)))
                AddCertNameToListBox(pCertContext, hwndDlg, IDC_INSTALLCA_CALIST);

            // set the selection to the first item, don't worry about errors
            SendDlgItemMessageU( 
                hwndDlg, 
                IDC_INSTALLCA_CALIST, 
                LB_SETCURSEL, 
                0, 
                0);

            return(TRUE);
            break;

        case WM_COMMAND:

            switch(HIWORD(wParam)) {

                case BN_CLICKED:

                    switch(LOWORD(wParam)) {
                        case IDYES:
                        case IDNO:
                        case IDCANCEL:
                            EndDialog(hwndDlg, LOWORD(wParam));
                            return(TRUE);

                        case IDC_INSTALLCA_MOREINFO:
                            MoreInfoDlg(hwndDlg, IDC_INSTALLCA_CALIST);
                            return(TRUE);
                    }
                    break;

                case LBN_DBLCLK:

                    switch(LOWORD(wParam)) {
                        case IDC_INSTALLCA_CALIST:
                            MoreInfoDlg(hwndDlg, IDC_INSTALLCA_CALIST);
                            return(TRUE);
                    }
                    break;
            }
    }

    return(FALSE);
}


BOOL FIsTooManyCertsOK(DWORD cCerts, HINSTANCE hInstanceUI) {

    WCHAR           wszT[MAX_MSG_LEN];
    WCHAR           wszT1[MAX_MSG_LEN];

    // if too many, ask the user if you wan to continue
    if(cCerts > CACERTWARNINGLEVEL) {
        LoadStringU(hInstanceUI, IDS_INSTALLCA, wszT1, sizeof(wszT1)/sizeof(WCHAR));
        LoadStringU(hInstanceUI, IDS_TOO_MANY_CA_CERTS, wszT, sizeof(wszT)/sizeof(WCHAR));
        return(IDYES == MessageBoxU(NULL, wszT, wszT1, MB_YESNO));
    }
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\xaddroot.cpp ===
// xaddroot.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xaddrootps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xaddroot.h"
#include "cobjsaf.h"

#include "caddroot.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_caddroot, Ccaddroot)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
	_Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
//    RegisterCLSIDInCategory(CLSID_caddroot, CATID_SafeForScripting);
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

//    UnRegisterCLSIDInCategory(CLSID_caddroot, CATID_SafeForScripting);
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xaddroot\httpget.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <assert.h> 
#include <memory.h>
#include <wininet.h>
#include "unicode.h"


BYTE * HTTPGet(const WCHAR * wszURL, DWORD * pcbReceiveBuff) {

    HINTERNET	hIOpen      = NULL;
	HINTERNET	hIConnect   = NULL;
	HINTERNET	hIHttp      = NULL;
    BYTE *      pbRecBuf    = NULL;
    char *	szPartURL	= NULL;
    char	szBuff[1024];
    char        szLong[16];
    char	szDomanName[_MAX_PATH];
    char	szPort[12];
    char *	pch;
    DWORD       cch;
    DWORD       dwService = INTERNET_SERVICE_HTTP;
    char *	pchT;
    DWORD       cbBuff, cbBuffRead, cbBuffT;
    DWORD	dwPort	= INTERNET_INVALID_PORT_NUMBER;
    char  *	szURL = NULL;


    assert(wszURL != NULL);
    assert(pcbReceiveBuff != NULL);

    *pcbReceiveBuff = 0;

    // figure out the protocol
    if( !MkMBStr(NULL, 0, wszURL, &szURL)) {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
    }

    //
    // DSIE: Fix bug 112117
    //
    if (NULL == szURL) {
        return NULL;
    }

    cch = strlen(szURL);
    if(cch >= 7  &&  _strnicmp(szURL, "http://", 7) == 0) {
        dwService = INTERNET_SERVICE_HTTP;
	pch = (char *) &szURL[7];

    } else if(cch >= 6	&&  _strnicmp(szURL, "ftp://", 6) == 0) {
        dwService = INTERNET_SERVICE_FTP ;
	pch = (char *) &szURL[6];
        
    } else {
        dwService = INTERNET_SERVICE_HTTP;
	pch = (char *) &szURL[0];
    }

    // if none of the above, assump http;
   
    // copy the Doman Name
    pchT = szDomanName;
    while(*pch != '/'  && *pch != ':' &&  *pch != 0)
        *pchT++ = *pch++;
    *pchT = 0;

    // parse out the port number
    szPort[0] = 0;
    if(*pch == ':') {
	pchT = szPort;
        pch++; // get past the :
	while(*pch != '/' && *pch != 0)
            *pchT++ = *pch++;
        *pchT = 0;
    }

    // Get port #, zero is INTERNET_INVALID_PORT_NUMBER
    if(szPort[0] != 0)
	dwPort = atol(szPort);
 
    // save away what to look up.
    if(NULL == (szPartURL = (char *) malloc(sizeof(char) * (strlen(pch) + 1)))) {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
        }

    strcpy(szPartURL, pch);

    //                        INTERNET_OPENLYPE_DIRECT,
    if( (hIOpen = InternetOpenA( "Transport",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0)) == NULL                 ||

	(hIConnect = InternetConnectA(hIOpen,
				    szDomanName,
                                    (INTERNET_PORT) dwPort,
                                    NULL,
                                    NULL,
                                    dwService,
                                    0,
                                    0)) == NULL     ) {
        goto ErrorReturn;                                    
        }

    // If this is a GET, do a dummy send
    if( ((hIHttp = HttpOpenRequestA(hIConnect,
				    "GET",
				    szPartURL,
				    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL     ||
	HttpSendRequestA(hIHttp, "Accept: */*\r\n", (DWORD) -1, NULL, 0) == FALSE) ) {
        goto ErrorReturn;
        }

    cbBuff = sizeof(szBuff);
    if(HttpQueryInfoA(	hIHttp,
                        HTTP_QUERY_CONTENT_TYPE,
			szBuff,
                        &cbBuff,
                        NULL) == FALSE)
        goto ErrorReturn;

    assert(cbBuff > 0);
 
    // now get the length of the buffer returned
    cbBuff = sizeof(szLong);
    if(HttpQueryInfo(   hIHttp,
                        HTTP_QUERY_CONTENT_LENGTH,
                        szLong,
                        &cbBuff,
                        NULL) == FALSE)
        goto ErrorReturn;

    assert(cbBuff > 0);
    // always appears to be in ascii
    cbBuff = atol(szLong);

    // allocate a buffer
    if( (pbRecBuf = (BYTE *) malloc(cbBuff)) == NULL ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
        }

    // read the data
    cbBuffRead = 0;
    while(cbBuffRead < cbBuff) {
        cbBuffT = 0;
        if(InternetReadFile(hIHttp, &pbRecBuf[cbBuffRead], (cbBuff - cbBuffRead), &cbBuffT)  == FALSE  ) 
            goto ErrorReturn;
         cbBuffRead += cbBuffT;
    }

    // close out the handle
    InternetCloseHandle(hIHttp);
    hIHttp = NULL;

    // pass back the info
    *pcbReceiveBuff = cbBuff;

CommonReturn:

    if(szPartURL != NULL)
	free(szPartURL);

    if(szURL != NULL)
	FreeMBStr(NULL, szURL);

    return(pbRecBuf);
    
ErrorReturn:

    if(pbRecBuf != NULL)
        free(pbRecBuf);
    pbRecBuf = NULL;

    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xelib\cmc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       cmc.cpp
//
//  Contents:   CMC request creation code shared between xenroll and CA
//
//  History:    03-2000   vich   created
//              03-2000   xtan   moved from ca
//              05-2000   xtan   moved from xenroll\xcertlib
//--------------------------------------------------------------------------
#define CMSG_SIGNER_ENCODE_INFO_HAS_CMS_FIELDS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include <wincrypt.h>
#include <dbgdef.h>
#include <unicode.h>

#include "xelib.h"
#include "xenroll.h"

//#define USE_OLD_DUMMY_SIGNER

#ifndef SAVE_DUMMY_SIGNER
#  define SAVE_DUMMY_SIGNER	FALSE
#endif


#ifdef _XENROLL_SRC_
#define CryptAcquireContextW CryptAcquireContextU
#endif //_XENROLL_SRC_

HRESULT
GenerateKeys(
    IN  WCHAR const   *pwszContainer,
    IN  DWORD          dwProvType,
    OUT HCRYPTPROV    *phProv)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;

    *phProv = NULL;

    // see if the container already exists

//    if (CryptAcquireContext(
    if (CryptAcquireContextW(
			phProv,
			pwszContainer,
			NULL,		// pwszProvName
			dwProvType,
			0))		// dwFlags
    {
	if (NULL != *phProv)
	{
	    CryptReleaseContext(*phProv, 0);
	    *phProv = NULL;
	}

        // container exists -- remove old keys and generate new ones.

//        if (!CryptAcquireContext(
        if (!CryptAcquireContextW(
			    phProv,
			    pwszContainer,
			    NULL,		// pwszProvName
			    dwProvType,
			    CRYPT_DELETEKEYSET))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptAcquireContext");
        }
    }

    // create new container

//    if (!CryptAcquireContext(
    if (!CryptAcquireContextW(
                        phProv,
                        pwszContainer,
			NULL,			// pwszProvName
                        dwProvType,
                        CRYPT_NEWKEYSET))	// force new container
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
 
    // create signature keys 

    if (!CryptGenKey(*phProv, AT_SIGNATURE, 0, &hKey))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenKey");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return(hr);
}


#define wszDUMMYSIGNER	L"Dummy Signer"

#ifdef USE_OLD_DUMMY_SIGNER

HRESULT
CreateDummySignerNameInfo(
    OUT BYTE  **ppbEncodedName,
    OUT DWORD *pcbEncodedName)
{
    HRESULT hr;
    CERT_RDN_ATTR rgRDNAttr[2];
    CERT_RDN rgRDN[2];
    CERT_NAME_INFO NameInfo;
    DWORD i;

    CSASSERT(NULL != ppbEncodedName && NULL != pcbEncodedName);

    NameInfo.cRDN = ARRAYSIZE(rgRDN);
    NameInfo.rgRDN = rgRDN;

    for (i = 0; i < ARRAYSIZE(rgRDN); i++)
    {
	rgRDN[i].cRDNAttr = 1;
	rgRDN[i].rgRDNAttr = &rgRDNAttr[i];

	rgRDNAttr[i].pszObjId = (0 == i)?
	    szOID_RDN_DUMMY_SIGNER : szOID_COMMON_NAME;

	rgRDNAttr[i].dwValueType = 0;
	rgRDNAttr[i].Value.pbData = (BYTE *) wszDUMMYSIGNER;
	rgRDNAttr[i].Value.cbData = 0;
    }

//    if (!myEncodeName(
    if (!myEncodeObject(
		 X509_ASN_ENCODING,
                 X509_UNICODE_NAME,
		 &NameInfo,
		 0,
		 CERTLIB_USE_LOCALALLOC,
		 ppbEncodedName,
		 pcbEncodedName))
    {
        hr = myHLastError();
//        _JumpError(hr, error, "myEncodeName");
        _JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
EncodeCertAndSign(
    IN HCRYPTPROV hProv,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    
    *ppbSigned = NULL;
//    if (!myEncodeToBeSigned(
    if (!myEncodeObject(
		    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
		    pCert,
                    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
//	_JumpError(hr, error, "myEncodeToBeSigned");
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszAlgId,
			pbEncoded,
			cbEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbSigned,
			pcbSigned);
    _JumpIfError(hr, error, "myEncodeSignedContent");

error:
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(hr);
}


VOID
GenerateSerialNumber(
    UUID *puuidSerialNumber)
{
    HRESULT hr;
    BYTE *pb;

    ZeroMemory(puuidSerialNumber, sizeof(*puuidSerialNumber));
    hr = UuidCreate(puuidSerialNumber);
    if (S_OK != hr)
    {
	BYTE *pbEnd;
	
	CSASSERT(RPC_S_UUID_LOCAL_ONLY == hr);

	// No net card?  Fake up a GUID:

	pb = (BYTE *) puuidSerialNumber;
	pbEnd = (BYTE *) pb + sizeof(*puuidSerialNumber);

	GetSystemTimeAsFileTime((FILETIME *) pb);
	pb += sizeof(FILETIME);

	while (pb < pbEnd)
	{
	    *(DWORD *) pb = GetTickCount();
	    pb += sizeof(DWORD);
	}
	CSASSERT(pb == pbEnd);
    }
    pb = &((BYTE *) puuidSerialNumber)[sizeof(*puuidSerialNumber) - 1];

    // make sure the last byte is never zero
    if (0 == *pb)
    {
	*pb = 'z';
    }

    // Some clients can't handle negative serial numbers:
    *pb &= 0x7f;
}

HRESULT
CreateKPI(
    IN CERT_CONTEXT const *pCert,
    IN BSTR strKeyContainer)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CRYPT_KEY_PROV_INFO kpi;
    CERT_CONTEXT const *pCertStore = NULL;

    hStore = CertOpenStore(
		CERT_STORE_PROV_SYSTEM_W,
		X509_ASN_ENCODING,
		NULL,		// hProv
		CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_CURRENT_USER,
		L"My");
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    if (!CertAddCertificateContextToStore(
				    hStore,
				    pCert,
				    CERT_STORE_ADD_REPLACE_EXISTING,
				    &pCertStore))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    ZeroMemory(&kpi, sizeof(kpi));
    kpi.pwszContainerName = strKeyContainer;
    kpi.pwszProvName = MS_DEF_PROV_W;
    kpi.dwProvType = PROV_RSA_FULL;
    kpi.dwKeySpec = AT_SIGNATURE;

    if (!CertSetCertificateContextProperty(
					pCertStore,
					CERT_KEY_PROV_INFO_PROP_ID,
					0,
					&kpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    hr = S_OK;

error:
    if (NULL != pCertStore)
    {
	CertFreeCertificateContext(pCertStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}

VOID
DestroyDummyCert(
    IN HCRYPTPROV hProv,
    IN BSTR strKeyContainer,
    IN CERT_CONTEXT const *pCert,
    IN BOOL fSaveDummySignerCert)
{
    HRESULT hr;
    
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != strKeyContainer)
    {
	if (fSaveDummySignerCert && NULL != pCert)
	{
	    CreateKPI(pCert, strKeyContainer);
	}
	else
	{
//	    if (!CryptAcquireContext(
	    if (!CryptAcquireContextW(
				&hProv,
				strKeyContainer,
				NULL,		// pwszProvName
				PROV_RSA_FULL,
				CRYPT_DELETEKEYSET))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptAcquireContext");
	    }
	}
	SysFreeString(strKeyContainer);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
}


HRESULT
EncodeDummyCert(
    OUT HCRYPTPROV *phProv,
    OUT BSTR *pstrKeyContainer,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    CERT_NAME_BLOB NameBlob;
    CERT_INFO Cert;
    char *pszAlgId = szOID_RSA_SHA1RSA;
    UUID uuidSerialNumber;
    BSTR strKeyContainer = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    //ZeroMemory(aext, sizeof(aext));
    NameBlob.pbData = NULL;

    *phProv = NULL;
    *pstrKeyContainer = NULL;
    *ppCert = NULL;

    // Use a GUID for the serial number and the key container name

    GenerateSerialNumber(&uuidSerialNumber);

    hr = MultiByteIntegerToBstr(
			    FALSE,
			    sizeof(uuidSerialNumber),
			    (BYTE const *) &uuidSerialNumber,
			    &strKeyContainer);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");


    hr = GenerateKeys(strKeyContainer, PROV_RSA_FULL, &hProv);
    _JumpIfError(hr, error, "GenerateKeys");

    // SUBJECT & ISSUER:

    hr = CreateDummySignerNameInfo(&NameBlob.pbData, &NameBlob.cbData);
    _JumpIfError(hr, error, "CreateDummySignerNameInfo");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    // CERT:

    ZeroMemory(&Cert, sizeof(Cert));
    Cert.dwVersion = CERT_V1;

    Cert.SerialNumber.pbData = (BYTE *) &uuidSerialNumber;
    Cert.SerialNumber.cbData = sizeof(uuidSerialNumber);
    Cert.SignatureAlgorithm.pszObjId = pszAlgId;
    Cert.Issuer = NameBlob;			// Structure assignment

    GetSystemTimeAsFileTime(&Cert.NotBefore);
    Cert.NotAfter = Cert.NotBefore;
    myMakeExprDateTime(
		&Cert.NotBefore,
		-CCLOCKSKEWMINUTESDEFAULT,
		ENUM_PERIOD_MINUTES);
    myMakeExprDateTime(&Cert.NotAfter, 1, ENUM_PERIOD_MONTHS);

    Cert.Subject = NameBlob;			// Structure assignment
    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    //Cert.cExtension = 0;
    //Cert.rgExtension = NULL;

    hr = EncodeCertAndSign(
		    hProv,
		    &Cert,
		    pszAlgId,
		    &pbEncoded,
		    &cbEncoded);
    _JumpIfError(hr, error, "EncodeCertAndSign");

    *ppCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbEncoded,
				    cbEncoded);
    if (NULL == *ppCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    *phProv = hProv;
    hProv = NULL;

    *pstrKeyContainer = strKeyContainer;
    strKeyContainer = NULL;

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != strKeyContainer)
    {
	SysFreeString(strKeyContainer);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != NameBlob.pbData)
    {
        LocalFree(NameBlob.pbData);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    return(hr);
}
#endif // USE_OLD_DUMMY_SIGNER


HRESULT
BuildCMCExtensions(
    IN DWORD cExt,
    IN CERT_EXTENSION const *rgExt,
    IN DWORD dwCMCDataReference,
    IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob)
{
    HRESULT hr;
    CMC_ADD_EXTENSIONS_INFO cmcExt;

    ZeroMemory(&cmcExt, sizeof(cmcExt));
    cmcExt.dwCmcDataReference = dwCMCDataReference;
    if (0 != dwBodyPartIdOfRequest)
    {
	cmcExt.cCertReference = 1;
	cmcExt.rgdwCertReference = &dwBodyPartIdOfRequest;
    }
    cmcExt.cExtension = cExt;
    cmcExt.rgExtension = const_cast<CERT_EXTENSION *>(rgExt);
    pTaggedAttribute->dwBodyPartID = dwBodyPartId;
    pTaggedAttribute->Attribute.pszObjId = szOID_CMC_ADD_EXTENSIONS;
    pTaggedAttribute->Attribute.cValue = 1;
    pTaggedAttribute->Attribute.rgValue = pBlob;

    // Encode CMC_ADD_EXTENSIONS_INFO --> Extensions Blob

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_EXTENSIONS,
		    &cmcExt,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pBlob->pbData,
		    &pBlob->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildCMCAttributes(
    IN DWORD cAttribute,
    IN CRYPT_ATTRIBUTE const *rgAttribute,
    IN DWORD dwCMCDataReference,
    IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO cmcAttrib;

    ZeroMemory(&cmcAttrib, sizeof(cmcAttrib));
    cmcAttrib.dwCmcDataReference = dwCMCDataReference;
    if (0 != dwBodyPartIdOfRequest)
    {
	cmcAttrib.cCertReference = 1;
	cmcAttrib.rgdwCertReference = &dwBodyPartIdOfRequest;
    }
    cmcAttrib.cAttribute = cAttribute;
    cmcAttrib.rgAttribute = const_cast<CRYPT_ATTRIBUTE *>(rgAttribute);

    //for (DWORD i = 0; i < cAttribute; i++)
    //{
	//DBGPRINT((DBG_SS_CERTLIBI, "Attr[%d]: %d values\n", i, rgAttribute[i].cValue));
    //}

    pTaggedAttribute->dwBodyPartID = dwBodyPartId;

    // MS proprietary OID: encoded attribute name, value pairs

    pTaggedAttribute->Attribute.pszObjId = szOID_CMC_ADD_ATTRIBUTES;
    pTaggedAttribute->Attribute.cValue = 1;
    pTaggedAttribute->Attribute.rgValue = pBlob;

    // Encode CMC_ADD_ATTRIBUTES_INFO --> Attribute Blob

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    &cmcAttrib,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pBlob->pbData,
		    &pBlob->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildCMCRegInfo(
    IN CHAR const *pszNameValuePairs,
    //IN DWORD dwCMCDataReference,
    //IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob)
{
    HRESULT hr;
    BYTE *pbOctet = NULL;
    CRYPT_DATA_BLOB Blob;
    
    pTaggedAttribute->dwBodyPartID = dwBodyPartId;
    pTaggedAttribute->Attribute.pszObjId = szOID_CMC_REG_INFO;
    pTaggedAttribute->Attribute.cValue = 1;
    pTaggedAttribute->Attribute.rgValue = pBlob;

    // Encode CMC_REG_INFO --> Octet string Blob

    Blob.pbData = (BYTE *) pszNameValuePairs;
    Blob.cbData = strlen(pszNameValuePairs);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &Blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pBlob->pbData,
		    &pBlob->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pbOctet)
    {
	LocalFree(pbOctet);
    }
    return(hr);
}


#ifndef WSZARRAYSIZE
#define WSZARRAYSIZE(a)	((sizeof(a)/sizeof((a)[0])) - 1)
#endif

HRESULT
CanonicalizeURLParm(
    IN WCHAR const *pwszParmIn,
    OUT WCHAR **ppwszParmOut)
{
    HRESULT hr;
    WCHAR *pwszUncanon = NULL;
    WCHAR *pwszCanon = NULL;
    static const WCHAR s_wszLdap[] = L"ldap:///";

    *ppwszParmOut = NULL;

    pwszUncanon = (WCHAR *) LocalAlloc(
	LMEM_FIXED,
	(WSZARRAYSIZE(s_wszLdap) + wcslen(pwszParmIn) + 1) * sizeof(WCHAR));
    if (NULL == pwszUncanon)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszUncanon, s_wszLdap);
    wcscat(pwszUncanon, pwszParmIn);

    hr = myInternetCanonicalizeUrl(pwszUncanon, &pwszCanon);
    _JumpIfError(hr, error, "myInternetCanonicalizeUrl");

    hr = myDupString(&pwszCanon[WSZARRAYSIZE(s_wszLdap)], ppwszParmOut);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwszUncanon)
    {
	LocalFree(pwszUncanon);
    }
    if (NULL != pwszCanon)
    {
	LocalFree(pwszCanon);
    }
    return(hr);
}


// SeparateNameValuePairs
//
// Separate szOID_ENROLLMENT_NAME_VALUE_PAIR attributes from the rest,
// and construct a URL-style, UTF8-encoded parameter string.

HRESULT
SeparateNameValuePairs(
    IN CRYPT_ATTRIBUTES const *rgAttributes,
    IN DWORD cAttributes,
    OUT CRYPT_ATTRIBUTE **prgAttr,
    OUT DWORD *pcAttr,
    OUT CHAR **ppszNameValuePairs)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD cAttr;
    DWORD iAttr;
    CRYPT_ATTRIBUTE *rgAttr = NULL;
    CRYPT_ATTRIBUTE *pAttr;
    DWORD cNameValuePair;
    DWORD iNameValuePair;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pNameValuePair = NULL;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *rgNameValuePair = NULL;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pnvp;
    DWORD cb;
    WCHAR *pwszNameValuePairs = NULL;
    CHAR *pszNameValuePairs = NULL;
    DWORD cwc;
    
    *prgAttr = NULL;
    *ppszNameValuePairs = NULL;

    // Count the name/value pairs, as well as the rest of the attributes

    cAttr = 0;
    cNameValuePair = 0;
    for (i = 0; i < cAttributes; i++)
    {
	for (j = 0; j < rgAttributes[i].cAttr; j++)
	{
	    pAttr = &rgAttributes[i].rgAttr[j];
	    if (0 == strcmp(szOID_ENROLLMENT_NAME_VALUE_PAIR, pAttr->pszObjId))
	    {
		cNameValuePair += pAttr->cValue;
	    }
	    else
	    {
		cAttr++;
	    }
	}
    }

    // Allocate an array of name/value pair pointers, and an array for the rest
    // of the attributes.

    if (0 != cAttr)
    {
	rgAttr = (CRYPT_ATTRIBUTE *) LocalAlloc(
					LMEM_FIXED,
					cAttr * sizeof(rgAttr[0]));
	if (NULL == rgAttr)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    if (0 != cNameValuePair)
    {
	rgNameValuePair = (CRYPT_ENROLLMENT_NAME_VALUE_PAIR *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cNameValuePair * sizeof(rgNameValuePair[0]));
	if (NULL == rgNameValuePair)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    // Decode name/values pairs, canonicalize each URL token, and compute
    // total string length.  Copy other attributes to the allocated array.

    iAttr = 0;
    iNameValuePair = 0;
    cwc = 0;
    for (i = 0; i < cAttributes; i++)
    {
	for (j = 0; j < rgAttributes[i].cAttr; j++)
	{
	    pAttr = &rgAttributes[i].rgAttr[j];
	    if (0 == strcmp(szOID_ENROLLMENT_NAME_VALUE_PAIR, pAttr->pszObjId))
	    {
		for (k = 0; k < pAttr->cValue; k++)
		{
		    if (NULL != pNameValuePair)
		    {
			LocalFree(pNameValuePair);
			pNameValuePair = NULL;
		    }
		    cb = 0;
		    if (!myDecodeObject(
				X509_ASN_ENCODING,
				szOID_ENROLLMENT_NAME_VALUE_PAIR,
				pAttr->rgValue[k].pbData,
				pAttr->rgValue[k].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNameValuePair,
				&cb))
		    {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			_JumpError(hr, error, "myDecodeObject");
		    }
		    if (NULL != pNameValuePair->pwszName &&
			L'\0' != pNameValuePair->pwszName &&
			NULL != pNameValuePair->pwszValue &&
			L'\0' != pNameValuePair->pwszValue)
		    {
			pnvp = &rgNameValuePair[iNameValuePair];

			hr = CanonicalizeURLParm(
				    pNameValuePair->pwszName,
				    &pnvp->pwszName);
			_JumpIfError(hr, error, "CanonicalizeURLParm");

			hr = CanonicalizeURLParm(
				    pNameValuePair->pwszValue,
				    &pnvp->pwszValue);
			_JumpIfError(hr, error, "CanonicalizeURLParm");

			cwc +=
			    wcslen(pnvp->pwszName) +
			    1 +
			    wcslen(pnvp->pwszValue) +
			    1;
			iNameValuePair++;
		    }
		}
	    }
	    else	// copy other attributes
	    {
		rgAttr[iAttr++] = *pAttr;
	    }
	}
    }
    CSASSERT(cAttr == iAttr);
    CSASSERT(cNameValuePair >= iNameValuePair);
    cNameValuePair = iNameValuePair;
    if (0 != cwc)
    {
	pwszNameValuePairs = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszNameValuePairs)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*pwszNameValuePairs = L'\0';
	for (i = 0; i < cNameValuePair; i++)
	{
	    pnvp = &rgNameValuePair[i];

	    wcscat(pwszNameValuePairs, pnvp->pwszName);
	    wcscat(pwszNameValuePairs, L"=");
	    wcscat(pwszNameValuePairs, pnvp->pwszValue);
	    wcscat(pwszNameValuePairs, L"&");
	}
	CSASSERT(wcslen(pwszNameValuePairs) == cwc);

	// and construct a URL-style, UTF8-encoded parameter string.

	if (!myConvertWszToUTF8(&pszNameValuePairs, pwszNameValuePairs, -1))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myConvertWszToUTF8");
	}
    }

    *prgAttr = rgAttr;
    rgAttr = NULL;
    *pcAttr = cAttr;

    *ppszNameValuePairs = pszNameValuePairs;
    pszNameValuePairs = NULL;

    hr = S_OK;

error:
    if (NULL != pszNameValuePairs)
    {
	LocalFree(pszNameValuePairs);
    }
    if (NULL != pwszNameValuePairs)
    {
	LocalFree(pwszNameValuePairs);
    }
    if (NULL != rgAttr)
    {
	LocalFree(rgAttr);
    }
    if (NULL != pNameValuePair)
    {
	LocalFree(pNameValuePair);
    }
    if (NULL != rgNameValuePair)
    {
	for (i = 0; i < cNameValuePair; i++)
	{
	    if (NULL != rgNameValuePair[i].pwszName)
	    {
		LocalFree(rgNameValuePair[i].pwszName);
	    }
	    if (NULL != rgNameValuePair[i].pwszValue)
	    {
		LocalFree(rgNameValuePair[i].pwszValue);
	    }
	}
	LocalFree(rgNameValuePair);
    }
    return(hr);
}


HRESULT
BuildCMCRequest(
    IN DWORD dwClientId,
    IN BOOL fNestedCMCRequest,
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    OPTIONAL IN CERT_EXTENSION const *rgExt,
    IN DWORD cExt,
    OPTIONAL IN CRYPT_ATTRIBUTES const *rgAttributes,
    IN DWORD cAttributes,
    OPTIONAL IN CRYPT_ATTRIBUTE const *rgAttributeUnauth,
    IN DWORD cAttributeUnauth,
    OPTIONAL IN BYTE const *pbKeyIdRequest,
    IN DWORD cbKeyIdRequest,
    OPTIONAL IN HCRYPTPROV hProvRequest,
    IN DWORD dwKeySpecRequest,
    OPTIONAL IN LPCSTR pszObjIdHashRequest,
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    OPTIONAL IN HCRYPTPROV hProvSigner,
    IN DWORD dwKeySpecSigner,
    OPTIONAL IN LPCSTR pszObjIdHashSigner,
    OUT BYTE **ppbReqCMC,
    OUT DWORD *pcbReqCMC)
{
    HRESULT hr;
    CMC_DATA_INFO cmcData;
    CRYPT_ATTRIBUTE *rgAttr = NULL;
    DWORD cAttr;
    CHAR *pszNameValuePairs = NULL;
    CMC_TAGGED_ATTRIBUTE *rgTaggedAttribute = NULL;
    CMC_TAGGED_ATTRIBUTE *pTaggedAttribute;
    CRYPT_ATTR_BLOB *rgBlob = NULL;
    CRYPT_ATTR_BLOB *pBlob;
    CMC_TAGGED_CERT_REQUEST cmcTaggedCertRequest;
    CMC_TAGGED_REQUEST cmcTaggedRequest;
    CMC_TAGGED_CONTENT_INFO cmcTaggedContentInfo;
    DWORD dwBodyPartId = 1;
    DWORD dwBodyPartIdOfRequest = 0;
    DWORD dwCMCDataReference = 0;
    BYTE *pbCMCContent = NULL;
    DWORD cbCMCContent;
    DWORD i;
    CMSG_SIGNER_ENCODE_INFO aSignerEncodeInfo[2];
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CERT_BLOB aSignerCertBlob[2];
    DWORD cb;
    HCRYPTMSG hMsg = NULL;
    HCRYPTPROV hProvVerify = NULL;

    CRYPT_ATTRIBUTE AttributeRequestClient;
    CRYPT_ATTR_BLOB BlobRequestClient;

    CERT_ISSUER_SERIAL_NUMBER IssuerSerial;
    ZeroMemory(&IssuerSerial, sizeof(IssuerSerial));
    BYTE Zero = 0;
#define BCR_CTAGGEDATTR		3
#define BCR_CBLOB		3

#ifdef USE_OLD_DUMMY_SIGNER
    HCRYPTPROV hProvDummy = NULL;
    BSTR strContainerDummy = NULL;
    CERT_CONTEXT const *pCertDummy = NULL;
    BOOL fSaveDummySignerCert = SAVE_DUMMY_SIGNER;
#endif // USE_OLD_DUMMY_SIGNER
    CERT_CONTEXT const *pCert;
    HCRYPTPROV hProv;
    DWORD dwKeySpec;
    CHAR const *pszObjIdHash;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;

    *ppbReqCMC = NULL;
    ZeroMemory(&cmcData, sizeof(cmcData));
    BlobRequestClient.pbData = NULL;

    if ((NULL == pbKeyIdRequest) ^
	(0 == cbKeyIdRequest) ^
	(NULL == hProvRequest) ^
	(0 == dwKeySpecRequest))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "request parms inconsistent");
    }
    if (NULL != pszObjIdHashRequest && NULL == hProvRequest)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "request signing OID parm inconsistent");
    }
    if ((NULL == pCertSigner) ^ (NULL == hProvSigner))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "signer parms inconsistent");
    }

    rgTaggedAttribute = (CMC_TAGGED_ATTRIBUTE *) LocalAlloc(
			    LMEM_FIXED,
			    BCR_CTAGGEDATTR * sizeof(rgTaggedAttribute[0]));
    if (NULL == rgTaggedAttribute)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    cmcData.rgTaggedAttribute = rgTaggedAttribute;
    pTaggedAttribute = rgTaggedAttribute;

    rgBlob = (CRYPT_ATTR_BLOB *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    BCR_CBLOB * sizeof(rgBlob[0]));
    if (NULL == rgBlob)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pBlob = rgBlob;

    if (fNestedCMCRequest)
    {
	dwCMCDataReference = dwBodyPartId++;

	// cmcData.rgTaggedContentInfo[0] = Nested CMC request 

	ZeroMemory(&cmcTaggedContentInfo, sizeof(cmcTaggedContentInfo));
	cmcData.cTaggedContentInfo = 1;
	cmcData.rgTaggedContentInfo = &cmcTaggedContentInfo;

	cmcTaggedContentInfo.dwBodyPartID = dwCMCDataReference;
	cmcTaggedContentInfo.EncodedContentInfo.pbData = const_cast<BYTE *>(pbReq);
	cmcTaggedContentInfo.EncodedContentInfo.cbData = cbReq;
    }
    else
    {
	// possibly unsigned PKCS10

	dwBodyPartIdOfRequest = dwBodyPartId++;

	// cmcData.rgTaggedRequest[0] = PKCS10 request

	ZeroMemory(&cmcTaggedRequest, sizeof(cmcTaggedRequest));
	ZeroMemory(&cmcTaggedCertRequest, sizeof(cmcTaggedCertRequest));

	cmcData.cTaggedRequest = 1;
	cmcData.rgTaggedRequest = &cmcTaggedRequest;
	cmcTaggedRequest.dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
	cmcTaggedRequest.pTaggedCertRequest = &cmcTaggedCertRequest;

	cmcTaggedCertRequest.dwBodyPartID = dwBodyPartIdOfRequest;
	cmcTaggedCertRequest.SignedCertRequest.pbData = const_cast<BYTE *>(pbReq);
	cmcTaggedCertRequest.SignedCertRequest.cbData = cbReq;
    }

    // *pTaggedAttribute++ = Collected Extensions

    if (0 != cExt)
    {
	CSASSERT(
	    pTaggedAttribute <
	    &rgTaggedAttribute[BCR_CTAGGEDATTR + cAttributes);
	CSASSERT(pBlob < &rgBlob[BCR_CBLOB + cAttributes);

	hr = BuildCMCExtensions(
			cExt,
			rgExt,
			dwCMCDataReference,
			dwBodyPartIdOfRequest,
			dwBodyPartId,
			pTaggedAttribute,
			pBlob);
	_JumpIfError(hr, error, "BuildCMCExtensions");

	dwBodyPartId++;
	cmcData.cTaggedAttribute++;
	pTaggedAttribute++;
	pBlob++;
    }

    // *pTaggedAttribute++ = Collected Request Attributes

    if (0 != cAttributes)
    {
	hr = SeparateNameValuePairs(
			    rgAttributes,
			    cAttributes,
			    &rgAttr,
			    &cAttr,
			    &pszNameValuePairs);
	_JumpIfError(hr, error, "SeparateNameValuePairs");

	if (0 != cAttr)
	{
	    CSASSERT(
		pTaggedAttribute <
		&rgTaggedAttribute[BCR_CTAGGEDATTR + cAttributes);
	    CSASSERT(pBlob < &rgBlob[BCR_CBLOB + cAttributes);

	    hr = BuildCMCAttributes(
			    cAttr,
			    rgAttr,
			    dwCMCDataReference,
			    dwBodyPartIdOfRequest,
			    dwBodyPartId,
			    pTaggedAttribute,
			    pBlob);
	    _JumpIfError(hr, error, "BuildCMCAttributes");

	    dwBodyPartId++;
	    cmcData.cTaggedAttribute++;
	    pTaggedAttribute++;
	    pBlob++;
	}
	if (NULL != pszNameValuePairs)
	{
	    CSASSERT(
		pTaggedAttribute <
		&rgTaggedAttribute[BCR_CTAGGEDATTR + cAttributes);
	    CSASSERT(pBlob < &rgBlob[BCR_CBLOB + cAttributes);

	    hr = BuildCMCRegInfo(
			    pszNameValuePairs,
			    //dwCMCDataReference,
			    //dwBodyPartIdOfRequest,
			    dwBodyPartId,
			    pTaggedAttribute,
			    pBlob);
	    _JumpIfError(hr, error, "BuildCMCRegInfo");

	    dwBodyPartId++;
	    cmcData.cTaggedAttribute++;
	    pTaggedAttribute++;
	    pBlob++;
	}
    }

    // Encode CMC_DATA_INFO --> CMC Request Blob

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    &cmcData,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbCMCContent,
		    &cbCMCContent))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    if (XECI_DISABLE != dwClientId)
    {
	hr = myEncodeRequestClientAttributeFromClientId(
					    dwClientId,
					    &BlobRequestClient.pbData,
					    &BlobRequestClient.cbData);
	_JumpIfError(hr, error, "myEncodeRequestClientAttributeFromClientId");

	AttributeRequestClient.pszObjId = szOID_REQUEST_CLIENT_INFO;
	AttributeRequestClient.cValue = 1;
	AttributeRequestClient.rgValue = &BlobRequestClient;
    }

    pCert = NULL;
    hProv = hProvRequest;
    dwKeySpec = dwKeySpecRequest;
    pszObjIdHash = pszObjIdHashRequest;

    if (NULL == hProvRequest && NULL == pbKeyIdRequest)
    {
#ifdef USE_OLD_DUMMY_SIGNER
	hr = EncodeDummyCert(&hProvDummy, &strContainerDummy, &pCertDummy);
	_JumpIfError(hr, error, "EncodeDummyCert");

	pCert = pCertDummy;
	hProv = hProvDummy;
	dwKeySpec = AT_SIGNATURE;
	pszObjIdHash = pszObjIdHashSigner;
#else
	// Fake up the NULL signature Signer info

	CERT_RDN_ATTR rdnAttr;
	CERT_RDN rdn;
	CERT_NAME_INFO NameInfo;
	
	NameInfo.cRDN = 1;
	NameInfo.rgRDN = &rdn;
	rdn.cRDNAttr = 1;
	rdn.rgRDNAttr = &rdnAttr;
	rdnAttr.pszObjId = szOID_RDN_DUMMY_SIGNER;
	rdnAttr.dwValueType = 0;
	rdnAttr.Value.pbData = (BYTE *) wszDUMMYSIGNER;
	rdnAttr.Value.cbData = 0;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_NAME,
			&NameInfo,
			0,
			CERTLIB_USE_LOCALALLOC,
			&IssuerSerial.Issuer.pbData,
			&IssuerSerial.Issuer.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	IssuerSerial.SerialNumber.pbData = &Zero;
	IssuerSerial.SerialNumber.cbData = sizeof(Zero);
#endif // USE_OLD_DUMMY_SIGNER
    }

    ZeroMemory(&aSignerEncodeInfo, sizeof(aSignerEncodeInfo));
    ZeroMemory(&SignedMsgEncodeInfo, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.rgSigners = aSignerEncodeInfo;
    //SignedMsgEncodeInfo.cCrlEncoded = 0;
    //SignedMsgEncodeInfo.rgCrlEncoded = NULL;

    // Encode CMC content into a PKCS 7, signed by the request's private key
    // if available, otherwise use a NULL signature.
    // Initialize the CMSG_SIGNER_ENCODE_INFO structure for one signer.
    // If the optional pCertSigner is non-NULL, add a second signature.

    for (i = 0; i < 2; i++)
    {
	CMSG_SIGNER_ENCODE_INFO *pSignerEncodeInfo = &aSignerEncodeInfo[i];
	CRYPT_OID_INFO const *pOIDInfo;
	CHAR const *pszObjIdPubKey;
	BOOL fDSSKey;
	
	pSignerEncodeInfo->cbSize = sizeof(*pSignerEncodeInfo);
	if (NULL != pCert)
	{
	    pSignerEncodeInfo->pCertInfo = pCert->pCertInfo;

	    aSignerCertBlob[SignedMsgEncodeInfo.cCertEncoded].cbData = pCert->cbCertEncoded;
	    aSignerCertBlob[SignedMsgEncodeInfo.cCertEncoded].pbData = pCert->pbCertEncoded;

	    SignedMsgEncodeInfo.rgCertEncoded = aSignerCertBlob;
	    SignedMsgEncodeInfo.cCertEncoded++;
	}
	if (XECI_DISABLE != dwClientId)
	{
	    pSignerEncodeInfo->cAuthAttr = 1;
	    pSignerEncodeInfo->rgAuthAttr = &AttributeRequestClient;
	}
	pSignerEncodeInfo->HashAlgorithm.pszObjId =
		NULL != pszObjIdHash?
		    const_cast<CHAR *>(pszObjIdHash) : szOID_OIWSEC_sha1;

	if (NULL != pCert)
	{
	    pszObjIdPubKey = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
	}
	else if (NULL != hProv)
	{
	    CSASSERT(0 == i);
	    CSASSERT(NULL == pPubKey);
	    if (!myCryptExportPublicKeyInfo(
				    hProv,
				    dwKeySpec,
				    CERTLIB_USE_LOCALALLOC,
				    &pPubKey,
				    &cbPubKey))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myCryptExportPublicKeyInfo");
	    }
	    pszObjIdPubKey = pPubKey->Algorithm.pszObjId;
	}
	else
	{
	    pszObjIdPubKey = szOID_PKIX_NO_SIGNATURE;
	    if (NULL == hProvVerify)
	    {
		if (!CryptAcquireContextW(
				    &hProvVerify,
				    NULL,	// pwszContainer
				    NULL,	// pwszProvName
				    PROV_RSA_FULL,
				    CRYPT_VERIFYCONTEXT)) // dwFlags
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptAcquireContextW");
		}
	    }
	    hProv = hProvVerify;
	    dwKeySpec = AT_SIGNATURE;
	}
	pSignerEncodeInfo->hCryptProv = hProv;
	pSignerEncodeInfo->dwKeySpec = dwKeySpec;

	fDSSKey = FALSE;
#ifdef _XENROLL_SRC_
	pOIDInfo = xeCryptFindOIDInfo(
#else
	pOIDInfo = CryptFindOIDInfo(
#endif
				CRYPT_OID_INFO_OID_KEY,
				const_cast<CHAR *>(pszObjIdPubKey),
				CRYPT_PUBKEY_ALG_OID_GROUP_ID);
	if (NULL != pOIDInfo && CALG_DSS_SIGN == pOIDInfo->Algid)
	{
	    pszObjIdPubKey = szOID_X957_SHA1DSA;
	    fDSSKey = TRUE;
	}

	if (NULL == pCert || fDSSKey)
	{
	    pSignerEncodeInfo->HashEncryptionAlgorithm.pszObjId = const_cast<CHAR *>(pszObjIdPubKey);
	}
	if (NULL == pCert)
	{
	    if (NULL == pbKeyIdRequest)
	    {
		pSignerEncodeInfo->SignerId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
		pSignerEncodeInfo->SignerId.IssuerSerialNumber = IssuerSerial;
	    }
	    else
	    {
		pSignerEncodeInfo->SignerId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
		pSignerEncodeInfo->SignerId.KeyId.cbData = cbKeyIdRequest;
		pSignerEncodeInfo->SignerId.KeyId.pbData = const_cast<BYTE *>(pbKeyIdRequest);
	    }
	}
	SignedMsgEncodeInfo.cSigners++;

	if (NULL == pCertSigner)
	{
	    break;
	}
	pCert = pCertSigner;
	hProv = hProvSigner;
	dwKeySpec = dwKeySpecSigner;
	pszObjIdHash = pszObjIdHashSigner;
    }

    // Unauthenticated attributes are attached to the first signature ONLY!

    aSignerEncodeInfo[0].cUnauthAttr = cAttributeUnauth;
    aSignerEncodeInfo[0].rgUnauthAttr = const_cast<CRYPT_ATTRIBUTE *>(rgAttributeUnauth);

    hMsg = CryptMsgOpenToEncode(
		PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		CMSG_CMS_ENCAPSULATED_CONTENT_FLAG,	// dwFlags
		CMSG_SIGNED,
		&SignedMsgEncodeInfo,
		szOID_CT_PKI_DATA,
		NULL);				// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToEncode");
    }

    // Update the message with the CMC content

    if (!CryptMsgUpdate(hMsg, pbCMCContent, cbCMCContent, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    // Return the encoded and signed content.
    // Use CMSG_CONTENT_PARAM to get the signed message.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppbReqCMC,
		    pcbReqCMC);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg); //make sure close before hProv release
    }
    if (NULL != rgAttr)
    {
	LocalFree(rgAttr);
    }
    if (NULL != pszNameValuePairs)
    {
	LocalFree(pszNameValuePairs);
    }
    if (NULL != IssuerSerial.Issuer.pbData)
    {
	LocalFree(IssuerSerial.Issuer.pbData);
    }
    if (NULL != hProvVerify)
    {
	CryptReleaseContext(hProvVerify, 0);
    }
    if (NULL != BlobRequestClient.pbData)
    {
	LocalFree(BlobRequestClient.pbData);
    }
#ifdef USE_OLD_DUMMY_SIGNER
    DestroyDummyCert(
		hProvDummy,
		strContainerDummy,
		pCertDummy,
		fSaveDummySignerCert);
#endif // USE_OLD_DUMMY_SIGNER
    if (NULL != rgBlob)
    {
	for (i = 0; i < BCR_CBLOB; i++)
	{
	    if (NULL != rgBlob[i].pbData)
	    {
		LocalFree(rgBlob[i].pbData);
	    }
	}
	LocalFree(rgBlob);
    }
    if (NULL != rgTaggedAttribute)
    {
	LocalFree(rgTaggedAttribute);
    }
    if (NULL != pbCMCContent)
    {
	LocalFree(pbCMCContent);
    }
    if (NULL != pPubKey)
    {
	LocalFree(pPubKey);
    }
    return(hr);
}


VOID
FreeCMCResponse(
    IN XCMCRESPONSE *rgResponse,
    IN DWORD cResponse)
{
    DWORD i;
    
    if (NULL != rgResponse)
    {
	for (i = 0; i < cResponse; i++)
	{
	    XCMCRESPONSE *pResponse = &rgResponse[i];

	    if (CMC_OTHER_INFO_PEND_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice &&
		NULL != pResponse->StatusInfo.pPendInfo)
	    {
		if (NULL != pResponse->StatusInfo.pPendInfo->PendToken.pbData)
		{
		    LocalFree(pResponse->StatusInfo.pPendInfo->PendToken.pbData);
		}
		LocalFree(pResponse->StatusInfo.pPendInfo);
	    }
	    if (NULL != pResponse->StatusInfo.pwszStatusString)
	    {
		LocalFree(pResponse->StatusInfo.pwszStatusString);
	    }
	    if (NULL != pResponse->pbCertHash)
	    {
		LocalFree(pResponse->pbCertHash);
	    }
	    if (NULL != pResponse->pbEncryptedKeyHash)
	    {
		LocalFree(pResponse->pbEncryptedKeyHash);
	    }
	    if (NULL != pResponse->pwszBodyPart)
	    {
		LocalFree(pResponse->pwszBodyPart);
	    }
	}
	LocalFree(rgResponse);
    }
}


HRESULT
_AppendBodyPart(
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN DWORD cwcPrefix,
    IN DWORD dwBodyPart)
{
    HRESULT hr;
    WCHAR awc[14];	// L".%u"

    if (cwcBodyPartBuffer <=
	cwcPrefix +
	wsprintfW(awc, L".%u", dwBodyPart))
//	wsprintf(awc, L".%u", dwBodyPart))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	_JumpError(hr, error, "pwszBodyPartBuffer");
    }
    wcscpy(&pwszBodyPartBuffer[cwcPrefix], awc);
//    DBGPRINT((DBG_SS_CERTLIBI, "BodyPartString: %ws\n", &pwszBodyPartBuffer[1]));
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// _SaveCMCStatus -- Save CMC Status Info
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_SaveCMCStatus(
    IN BYTE *pbIn,
    IN DWORD cbIn,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE **prgResponse,
    IN OUT DWORD *pcResponse)
{
    HRESULT hr;
    DWORD i;
    DWORD cwcPrefix;
    CMC_STATUS_INFO *pcmcStatus = NULL;
    CMC_STATUS_INFO *pStatusInfo;
    XCMCRESPONSE *pResponse;
    DWORD cb;
    BYTE *pb;
    WCHAR *pwszBodyPartT = NULL;
    WCHAR *pwszStatusStringT = NULL;
    BYTE *pbToken = NULL;
    DWORD cbToken;

    cwcPrefix = wcslen(pwszBodyPartBuffer);
    
    // Decode CMC_STATUS_INFO from Attribute Blob

    CSASSERT(NULL == pcmcStatus);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_STATUS,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcStatus,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    for (i = 0; i < pcmcStatus->cBodyList; i++)
    {
	hr = _AppendBodyPart(
			pwszBodyPartBuffer,
			cwcBodyPartBuffer,
			cwcPrefix,
			pcmcStatus->rgdwBodyList[i]);
	_JumpIfError(hr, error, "_AppendBodyPart");

#if 0
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "  Status: %u\n",
	    pcmcStatus->dwStatus));

	if (NULL != pcmcStatus->pwszStatusString)
	{
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"  StatusString: %ws\n",
		pcmcStatus->pwszStatusString));
	}

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "  OtherInfoChoice: %u\n",
	    pcmcStatus->dwOtherInfoChoice));
#endif //0

	if (CMC_OTHER_INFO_PEND_CHOICE == pcmcStatus->dwOtherInfoChoice)
	{
	    //pcmcStatus->pPendInfo->PendToken.pbData
	    //pcmcStatus->pPendInfo->PendToken.cbData
	    //pcmcStatus->pPendInfo->PendTime
	}
	if (0 == *pcResponse)
	{
	    pResponse = (XCMCRESPONSE *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(**prgResponse));
	}
	else
	{
	    pResponse = (XCMCRESPONSE *) LocalReAlloc(
				    *prgResponse,
				    (1 + *pcResponse) * sizeof(**prgResponse),
				    LMEM_MOVEABLE | LMEM_ZEROINIT);
	}
	if (NULL == pResponse)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, 0 == *pcResponse? "LocalAlloc" : "LocalReAlloc");
	}
	*prgResponse = pResponse;
	pResponse += *pcResponse;

	pResponse->StatusInfo.dwStatus = pcmcStatus->dwStatus;
	pResponse->StatusInfo.cBodyList = pcmcStatus->rgdwBodyList[i];
	pResponse->StatusInfo.dwOtherInfoChoice = pcmcStatus->dwOtherInfoChoice;

	if (CMC_OTHER_INFO_FAIL_CHOICE == pcmcStatus->dwOtherInfoChoice)
	{
	    pResponse->StatusInfo.dwFailInfo = pcmcStatus->dwFailInfo;
	}

	hr = myDupString(&pwszBodyPartBuffer[1], &pwszBodyPartT);
	_JumpIfError(hr, error, "myDupString");

	if (NULL != pcmcStatus->pwszStatusString)
	{
	    hr = myDupString(pcmcStatus->pwszStatusString, &pwszStatusStringT);
	    _JumpIfError(hr, error, "myDupString");
	}

	if (CMC_OTHER_INFO_PEND_CHOICE == pcmcStatus->dwOtherInfoChoice &&
	    NULL != pcmcStatus->pPendInfo)
	{
	    if (NULL != pcmcStatus->pPendInfo->PendToken.pbData &&
		0 != pcmcStatus->pPendInfo->PendToken.cbData)
	    {
		pbToken = (BYTE *) LocalAlloc(
				    LMEM_FIXED,
				    pcmcStatus->pPendInfo->PendToken.cbData);
		if (NULL == pbToken)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		CopyMemory(
			pbToken,
			pcmcStatus->pPendInfo->PendToken.pbData,
			pcmcStatus->pPendInfo->PendToken.cbData);
	    }
	    pResponse->StatusInfo.pPendInfo = (CMC_PEND_INFO *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				sizeof(*pResponse->StatusInfo.pPendInfo));
	    if (NULL == pResponse->StatusInfo.pPendInfo)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

	    // Can't fail now.

	    pResponse->StatusInfo.pPendInfo->PendTime =
		pcmcStatus->pPendInfo->PendTime;

	    if (NULL != pbToken)
	    {
		pResponse->StatusInfo.pPendInfo->PendToken.pbData = pbToken;
		pResponse->StatusInfo.pPendInfo->PendToken.cbData =
		    pcmcStatus->pPendInfo->PendToken.cbData;
		pbToken = NULL;
	    }
	}
	pResponse->pwszBodyPart = pwszBodyPartT;
	pwszBodyPartT = NULL;

	pResponse->StatusInfo.pwszStatusString = pwszStatusStringT;
	pwszStatusStringT = NULL;

	(*pcResponse)++;
    }
    hr = S_OK;

error:
    pwszBodyPartBuffer[cwcPrefix] = L'\0';
    if (NULL != pwszBodyPartT)
    {
	LocalFree(pwszBodyPartT);
    }
    if (NULL != pwszStatusStringT)
    {
	LocalFree(pwszStatusStringT);
    }
    if (NULL != pbToken)
    {
	LocalFree(pbToken);
    }
    if (NULL != pcmcStatus)
    {
	LocalFree(pcmcStatus);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// _SaveCertHashInResponse -- Save cert hash to response array
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_SaveCertHashInResponse(
    IN BYTE const *pbCertHash,
    IN DWORD cbCertHash,
    IN WCHAR const *pwszBodyPart,
    IN OUT XCMCRESPONSE *rgResponse,
    IN DWORD cResponse,
    IN BOOL fCertHash)
{
    HRESULT hr;
    DWORD i;
    
    for (i = 0; i < cResponse; i++)
    {
	XCMCRESPONSE *pResponse = &rgResponse[i];

	if (0 == lstrcmpW(pwszBodyPart, pResponse->pwszBodyPart))
	{
	    BYTE **ppbHash = fCertHash?
		    &pResponse->pbCertHash : &pResponse->pbEncryptedKeyHash;
	    DWORD *pcbHash = fCertHash?
		    &pResponse->cbCertHash : &pResponse->cbEncryptedKeyHash;

	    if (NULL != *ppbHash)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "hash already set");
	    }
	    *ppbHash = (BYTE *) LocalAlloc(LMEM_FIXED, cbCertHash);
	    if (NULL == *ppbHash)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    *pcbHash = cbCertHash;
	    CopyMemory(*ppbHash, pbCertHash, cbCertHash);
	    break;
	}
    }
    if (i >= cResponse)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "unknown hash");
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// _SaveCMCCertHash -- Save CMC cert hash from attributes
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

#define BLOB_ROUND(cb) \
	(((cb) + sizeof(CRYPT_DATA_BLOB) - 1) / sizeof(CRYPT_DATA_BLOB))

HRESULT
_SaveCMCCertHash(
    IN BYTE *pbIn,
    IN DWORD cbIn,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE *rgResponse,
    IN OUT DWORD cResponse)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    CRYPT_ATTRIBUTE const *pAttr;
    CRYPT_ATTRIBUTE const *pAttrEnd;
    CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(CBMAX_CRYPT_HASH_LEN)];
    DWORD cb;
    DWORD cwcPrefix;

    cwcPrefix = wcslen(pwszBodyPartBuffer);

    // Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

    CSASSERT(NULL == pcmcAttrib);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcAttrib,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (0 != pcmcAttrib->dwCmcDataReference)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "pcmcAttrib->dwCmcDataReference");
    }

    pAttrEnd = &pcmcAttrib->rgAttribute[pcmcAttrib->cAttribute];
    for (pAttr = pcmcAttrib->rgAttribute; pAttr < pAttrEnd; pAttr++)
    {
	BOOL fCertHash = 0 == strcmp(pAttr->pszObjId, szOID_ISSUED_CERT_HASH);

	if (fCertHash ||
	    0 == strcmp(pAttr->pszObjId, szOID_ENCRYPTED_KEY_HASH))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (1 != pAttr->cValue)
	    {
		_JumpError(hr, error, "pAttr->cValue");
	    }
	    if (1 != pcmcAttrib->cCertReference)
	    {
		_JumpError(hr, error, "pcmcAttrib->dwCmcDataReference");
	    }
	    hr = _AppendBodyPart(
			    pwszBodyPartBuffer,
			    cwcBodyPartBuffer,
			    cwcPrefix,
			    pcmcAttrib->rgdwCertReference[0]);
	    _JumpIfError(hr, error, "_AppendBodyPart");

	    cb = sizeof(aBlob);
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttr->rgValue[0].pbData,
			    pAttr->rgValue[0].cbData,
			    0,
			    &aBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    hr = _SaveCertHashInResponse(
			    aBlob[0].pbData,
			    aBlob[0].cbData,
			    &pwszBodyPartBuffer[1],
			    rgResponse,
			    cResponse,
			    fCertHash);
	    _JumpIfError(hr, error, "SaveCertHashInResponse");
	}
    }
    hr = S_OK;

error:
    pwszBodyPartBuffer[cwcPrefix] = L'\0';
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// _DecodeCMCTaggedAttributes -- Decode CMC Tagged Attributes
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_DecodeCMCTaggedAttributes(
    IN DWORD cTaggedAttribute,
    IN CMC_TAGGED_ATTRIBUTE const *rgTaggedAttribute,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE **prgResponse,
    IN OUT DWORD *pcResponse)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ATTRIBUTE const *pAttribute;
    DWORD j;

    for (i = 0; i < cTaggedAttribute; i++)
    {
	pAttribute = &rgTaggedAttribute[i].Attribute;

	for (j = 0; j < pAttribute->cValue; j++)
	{
	    if (0 == strcmp(szOID_CMC_STATUS_INFO, pAttribute->pszObjId))
	    {
		hr = _SaveCMCStatus(
			    pAttribute->rgValue[j].pbData,
			    pAttribute->rgValue[j].cbData,
			    pwszBodyPartBuffer,
			    cwcBodyPartBuffer,
			    prgResponse,
			    pcResponse);
		_JumpIfError(hr, error, "_SaveCMCStatus");
	    }
	}
    }
    for (i = 0; i < cTaggedAttribute; i++)
    {
	pAttribute = &rgTaggedAttribute[i].Attribute;

	for (j = 0; j < pAttribute->cValue; j++)
	{
	    if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	    {
		hr = _SaveCMCCertHash(
			    pAttribute->rgValue[j].pbData,
			    pAttribute->rgValue[j].cbData,
			    pwszBodyPartBuffer,
			    cwcBodyPartBuffer,
			    *prgResponse,
			    *pcResponse);
		_JumpIfError(hr, error, "_SaveCMCCertHash");
	    }
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// _DecodeCMCResponse -- Decode a CMC Response Message
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
_DecodeCMCResponse(
    IN BYTE *pbIn,
    IN DWORD cbIn,
    IN OUT WCHAR *pwszBodyPartBuffer,
    IN DWORD cwcBodyPartBuffer,
    IN OUT XCMCRESPONSE **prgResponse,
    IN OUT DWORD *pcResponse)
{
    HRESULT hr;
    CMC_RESPONSE_INFO *pcmcResponse = NULL;
    DWORD cbcmcResponse;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_RESPONSE,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcResponse,
		    &cbcmcResponse))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = _DecodeCMCTaggedAttributes(
			pcmcResponse->cTaggedAttribute,
			pcmcResponse->rgTaggedAttribute,
			pwszBodyPartBuffer,
			cwcBodyPartBuffer,
			prgResponse,
			pcResponse);
    _JumpIfError(hr, error, "_DecodeTaggedAttributes");

#if 0
    hr = _DecodeTaggedContent(
			pcmcResponse->cTaggedContentInfo,
			pcmcResponse->rgTaggedContentInfo);
    _JumpIfError(hr, error, "_DecodeTaggedContent");

    hr = _DecodeTaggedOther(
			pcmcResponse->cTaggedOtherMsg,
			pcmcResponse->rgTaggedOtherMsg);
    _JumpIfError(hr, error, "_DecodeTaggedOther");
#endif

error:
    if (NULL != pcmcResponse)
    {
        LocalFree(pcmcResponse);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// ParseCMCResponse -- Decode a Full Response Message
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
ParseCMCResponse(
    IN BYTE *pbResponse,
    IN DWORD cbResponse,
    OPTIONAL OUT HCERTSTORE *phStoreResponse,
    OUT XCMCRESPONSE **prgResponse,
    OUT DWORD *pcResponse)
{
    HRESULT hr;
    DWORD dwMsgType;
    char *pszInnerContentObjId = NULL;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    HCERTSTORE hStore = NULL;
    WCHAR awcBodyPartBuffer[MAX_PATH];

    if (NULL != phStoreResponse)
    {
	*phStoreResponse = NULL;
    }
    *prgResponse = NULL;
    *pcResponse = 0;

    // Decode outer PKCS 7 signed message, which contains all of the certs.

    hr = myDecodePKCS7(
		    pbResponse,
		    cbResponse,
		    &pbContents,
		    &cbContents,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    NULL,		// &cSigner,
		    NULL,		// &cRecipient,
		    &hStore,
		    NULL);		// phMsg
    _JumpIfError(hr, error, "myDecodePKCS7(outer)");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CMSG_SIGNED != dwMsgType)
    {
	_JumpError(hr, error, "dwMsgType");
    }
    if (NULL == pszInnerContentObjId ||
	0 != strcmp(pszInnerContentObjId, szOID_CT_PKI_RESPONSE))
    {
	_JumpError(hr, error, "pszInnerContentObjId");
    }
    awcBodyPartBuffer[0] = L'\0';
    hr = _DecodeCMCResponse(
		    pbContents,
		    cbContents,
		    awcBodyPartBuffer,
		    ARRAYSIZE(awcBodyPartBuffer),
		    prgResponse,
		    pcResponse);
    _JumpIfError(hr, error, "_DecodeCMCResponse");

    if (NULL != phStoreResponse)
    {
	*phStoreResponse = hStore;
	hStore = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pbContents)
    {
        LocalFree(pbContents);
    }
    if (NULL != pszInnerContentObjId)
    {
        LocalFree(pszInnerContentObjId);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
myCryptMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    VOID *pvData = NULL;

    *ppvData = NULL;
    *pcbData = 0;
    if (!CryptMsgGetParam(
		    hMsg,
		    dwParamType,
		    dwIndex,
		    NULL,
		    pcbData))
    {
	hr = myHLastError();
	if (CRYPT_E_ATTRIBUTES_MISSING == hr || CRYPT_E_INVALID_INDEX == hr)
	{
	    hr = S_FALSE;
	}
//	_JumpError2(hr, error, "CryptMsgGetParam", S_FALSE);
	_JumpError(hr, error, "CryptMsgGetParam");
    }

    pvData = myAlloc(*pcbData, allocType);
    if (NULL == pvData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(pvData, *pcbData);

    if (!CryptMsgGetParam(
		    hMsg,
		    dwParamType,
		    dwIndex,
		    pvData,
		    pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgGetParam");
    }

    *ppvData = pvData;
    pvData = NULL;
    hr = S_OK;

error:
    if (NULL != pvData)
    {
	LocalFree(pvData);
    }
    return(hr);
}


HRESULT
myEncodeUTF8String(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_NAME_VALUE cnv;

    *ppbOut = NULL;

    cnv.dwValueType = CERT_RDN_UTF8_STRING;
    cnv.Value.pbData = (BYTE *) pwszIn;
    cnv.Value.cbData = 0;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    &cnv,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myDecodeUTF8String(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    CERT_NAME_VALUE *pNameValue = NULL;
    DWORD cb;

    *ppwszOut = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pNameValue,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (NULL != pNameValue->Value.pbData)
    {
	hr = myDupString((WCHAR *) pNameValue->Value.pbData, ppwszOut);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = S_OK;

error:
    if (NULL != pNameValue)
    {
	LocalFree(pNameValue);
    }
    return(hr);
}


HRESULT
myEncodeRequestClientAttribute(
    IN CRYPT_REQUEST_CLIENT_INFO const *pcrci,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_DER_BLOB aBlob[4];
    CRYPT_SEQUENCE_OF_ANY Sequence;
    DWORD i;

    ZeroMemory(aBlob, sizeof(aBlob));

    Sequence.cValue = ARRAYSIZE(aBlob);
    Sequence.rgValue = aBlob;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &pcrci->dwClientId,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aBlob[0].pbData,
		    &aBlob[0].cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = myEncodeUTF8String(
		    pcrci->pwszMachine,
		    &aBlob[1].pbData,
		    &aBlob[1].cbData);
    _JumpIfError(hr, error, "myEncodeUTF8String");

    hr = myEncodeUTF8String(
		    pcrci->pwszUser,
		    &aBlob[2].pbData,
		    &aBlob[2].cbData);
    _JumpIfError(hr, error, "myEncodeUTF8String");

    hr = myEncodeUTF8String(
		    pcrci->pwszProcess,
		    &aBlob[3].pbData,
		    &aBlob[3].cbData);
    _JumpIfError(hr, error, "myEncodeUTF8String");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    for (i = 0; i < ARRAYSIZE(aBlob); i++)
    {
	if (NULL != aBlob[i].pbData)
	{
	    LocalFree(aBlob[i].pbData);
	}
    }
    return(hr);
}


HRESULT
myDecodeRequestClientAttribute(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CRYPT_REQUEST_CLIENT_INFO **ppcrci)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    CRYPT_REQUEST_CLIENT_INFO crci;
    DWORD cb;
    BYTE *pb;

    ZeroMemory(&crci, sizeof(crci));
    *ppcrci = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pSequence,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (4 != pSequence->cValue)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "incomplete structure");
    }
    cb = sizeof(crci.dwClientId);
    if (!CryptDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pSequence->rgValue[0].pbData,
		    pSequence->rgValue[0].cbData,
		    0,		// dwFlags
		    (VOID *) &crci.dwClientId,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = myDecodeUTF8String(
		    pSequence->rgValue[1].pbData,
		    pSequence->rgValue[1].cbData,
		    &crci.pwszMachine);
    _JumpIfError(hr, error, "myDecodeUTF8String");

    hr = myDecodeUTF8String(
		    pSequence->rgValue[2].pbData,
		    pSequence->rgValue[2].cbData,
		    &crci.pwszUser);
    _JumpIfError(hr, error, "myDecodeUTF8String");

    hr = myDecodeUTF8String(
		    pSequence->rgValue[3].pbData,
		    pSequence->rgValue[3].cbData,
		    &crci.pwszProcess);
    _JumpIfError(hr, error, "myDecodeUTF8String");

    cb = sizeof(crci);
    if (NULL != crci.pwszMachine)
    {
	cb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszMachine) + 1));
    }
    if (NULL != crci.pwszUser)
    {
	cb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszUser) + 1));
    }
    if (NULL != crci.pwszProcess)
    {
	cb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszProcess) + 1));
    }
    *ppcrci = (CRYPT_REQUEST_CLIENT_INFO *) LocalAlloc(
						LMEM_FIXED | LMEM_ZEROINIT,
						cb);
    if (NULL == *ppcrci)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pb = (BYTE *) (*ppcrci + 1);
    (*ppcrci)->dwClientId = crci.dwClientId;
    if (NULL != crci.pwszMachine)
    {
	(*ppcrci)->pwszMachine = (WCHAR *) pb;
	wcscpy((*ppcrci)->pwszMachine, crci.pwszMachine);
	pb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszMachine) + 1));
    }
    if (NULL != crci.pwszUser)
    {
	(*ppcrci)->pwszUser = (WCHAR *) pb;
	wcscpy((*ppcrci)->pwszUser, crci.pwszUser);
	pb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszUser) + 1));
    }
    if (NULL != crci.pwszProcess)
    {
	(*ppcrci)->pwszProcess = (WCHAR *) pb;
	wcscpy((*ppcrci)->pwszProcess, crci.pwszProcess);
	pb += DWORDROUND(sizeof(WCHAR) * (wcslen(crci.pwszProcess) + 1));
    }
    hr = S_OK;

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (NULL != crci.pwszMachine)
    {
	LocalFree(crci.pwszMachine);
    }
    if (NULL != crci.pwszUser)
    {
	LocalFree(crci.pwszUser);
    }
    if (NULL != crci.pwszProcess)
    {
	LocalFree(crci.pwszProcess);
    }
    return(hr);
}



HRESULT
myEncodeRequestClientAttributeFromClientId(
    IN DWORD dwClientId,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_REQUEST_CLIENT_INFO crci;

    *ppbOut = NULL;
    ZeroMemory(&crci, sizeof(crci));
    crci.dwClientId = dwClientId;
    //crci.pwszMachine = NULL;
    //crci.pwszUser = NULL;
    //crci.pwszProcess = NULL;

    hr = myGetMachineDnsName(&crci.pwszMachine);
    _PrintIfError(hr, "myGetMachineDnsName");

    hr = myGetUserNameEx(NameSamCompatible, &crci.pwszUser);
    _PrintIfError(hr, "myGetUserNameEx");

    hr = myGetProcessName(&crci.pwszProcess);
    _PrintIfError(hr, "myGetProcessName");

    hr = myEncodeRequestClientAttribute(&crci, ppbOut, pcbOut);
    _JumpIfError(hr, error, "myEncodeRequestClientAttribute");

error:
    if (NULL != crci.pwszProcess)
    {
	LocalFree(crci.pwszProcess);
    }
    if (NULL != crci.pwszUser)
    {
	LocalFree(crci.pwszUser);
    }
    if (NULL != crci.pwszMachine)
    {
	LocalFree(crci.pwszMachine);
    }
    return(hr);
}

#ifdef _XENROLL_SRC_
typedef BOOL
(WINAPI * PFNGetComputerNameExW) (
  COMPUTER_NAME_FORMAT NameType,  // name type
  WCHAR *lpBuffer,                // name buffer
  LPDWORD lpnSize                 // size of name buffer
);

typedef BOOL
(WINAPI * PFNGetUserNameExW)(
  EXTENDED_NAME_FORMAT NameFormat,  // name format
  WCHAR *lpNameBuffer,              // name buffer
  PULONG nSize                      // size of name buffer
);

typedef WCHAR*
(WINAPI * PFNGetCommandLineW)(
    VOID
);
#endif //_XENROLL_SRC_

BOOL
xeGetUserNameExW(
    IN EXTENDED_NAME_FORMAT NameFormat,
    IN WCHAR *pwszUserName,
    IN PULONG pcwc)
{
#ifdef _XENROLL_SRC_
    BOOL   b = FALSE;
    PFNGetUserNameExW pfnGetUserNameExW = NULL;
    HMODULE hModule = GetModuleHandle("secur32.dll");
    if (NULL != hModule)
    {
        pfnGetUserNameExW = (PFNGetUserNameExW)
                GetProcAddress(hModule, "GetUserNameExW");
        if (NULL != pfnGetUserNameExW)
        {
            return pfnGetUserNameExW(NameFormat, pwszUserName, pcwc);
        }
        //downlevel clients, do the hard work
        if (NULL == pwszUserName)
        {
            //just get size
            return GetUserName(NULL, pcwc);
        }

        CHAR *pszUserName = (CHAR*)LocalAlloc(LMEM_FIXED, *pcwc * sizeof(CHAR));
        if (NULL == pszUserName)
        {
            return FALSE;
        }
        if (GetUserName(pszUserName, pcwc))
        {
            //convert to wide string
            if (0 != MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszUserName,
                            -1,
                            pwszUserName,
                            *pcwc))
            {
                b = TRUE;
            }
        }
        LocalFree(pszUserName);
    }
    return b;
#else
    return GetUserNameExW(NameFormat, pwszUserName, pcwc);
#endif //_XENROLL_SRC_
}

BOOL
xeGetComputerNameExW(
    IN     COMPUTER_NAME_FORMAT NameFormat,  // name format
    IN     WCHAR               *pwszComputerName,    // name buffer
    IN OUT DWORD                *pcwc)       // size of name buffer
{
#ifdef _XENROLL_SRC_
    BOOL b = FALSE;
    PFNGetComputerNameExW pfnGetComputerNameExW = NULL;
    HMODULE hModule = GetModuleHandle("kernel32.dll");
    if (NULL != hModule)
    {
        pfnGetComputerNameExW = (PFNGetComputerNameExW)
                GetProcAddress(hModule, "GetComputerNameExW");
        if (NULL != pfnGetComputerNameExW)
        {
            return pfnGetComputerNameExW(NameFormat, pwszComputerName, pcwc);
        }
        //downlevel clients, do the hard work
        if (NULL == pwszComputerName)
        {
            //just get size, donwlevel machine has max size
            *pcwc = MAX_COMPUTERNAME_LENGTH + 1;
            SetLastError(ERROR_MORE_DATA); // caller check on
            return FALSE;
        }

        CHAR *pszComputerName = (CHAR*)
                        LocalAlloc(LMEM_FIXED, *pcwc * sizeof(CHAR));
        if (NULL == pszComputerName)
        {
            return FALSE;
        }
        if (GetComputerName(pszComputerName, pcwc))
        {
            //convert to wide string
            if (0 != MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszComputerName,
                            -1,
                            pwszComputerName,
                            *pcwc + 1))
            {
                b = TRUE;
            }
        }
        LocalFree(pszComputerName);
    }
    return b;
#else
    return GetComputerNameExW(NameFormat, pwszComputerName, pcwc);
#endif // _XENROLL_SRC_
}

WCHAR*
xeGetCommandLineW(
    OUT BOOL  *pfNeedFree)
{
    //init
    *pfNeedFree = FALSE;

#ifdef _XENROLL_SRC_
    WCHAR *pwszCommandLine = NULL;
    PFNGetCommandLineW pfnGetCommandLineW = NULL;
    HMODULE hModule = GetModuleHandle("kernel32.dll");
    CHAR *pszCommandLine;
    int  cch;

    if (NULL != hModule)
    {
        pfnGetCommandLineW = (PFNGetCommandLineW)
                GetProcAddress(hModule, "GetCommandLineW");
        if (NULL != pfnGetCommandLineW)
        {
            return pfnGetCommandLineW();
        }
        //downlevel clients, do the hard work
        pszCommandLine = GetCommandLine();
        if (NULL == pszCommandLine)
        {
            //error
            return NULL;
        }
        cch = strlen(pszCommandLine) + 1;
        pwszCommandLine = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL != pwszCommandLine)
        {
            //convert to wide string
            if (0 == MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszCommandLine,
                            -1,
                            pwszCommandLine,
                            cch))
            {
                LocalFree(pwszCommandLine);
                pwszCommandLine = NULL;
            }
            else
            {
                //caller to free
                *pfNeedFree = TRUE;
            }
        }
    }
    return pwszCommandLine;
#else
    return GetCommandLineW();
#endif // _XENROLL_SRC_
}

HRESULT
myGetUserNameEx(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszUserName)
{
    HRESULT hr;
    DWORD cwc = 0;
    WCHAR *pwszUserName = NULL;

    while (TRUE)
    {
	if (!xeGetUserNameExW(NameFormat, pwszUserName, &cwc))
	{
	    hr = myHLastError();
	    if (NULL != pwszUserName ||
		HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
	    {
		_JumpError(hr, error, "GetUserNameEx");
	    }
	}
	if (NULL != pwszUserName)
	{
	    break;
	}
	pwszUserName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszUserName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppwszUserName = pwszUserName;
    pwszUserName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    return(hr);
}


HRESULT
myGetMachineDnsName(
    OUT WCHAR **ppwszDnsName)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    DWORD cwc;
    COMPUTER_NAME_FORMAT NameType = ComputerNameDnsFullyQualified;

    *ppwszDnsName = NULL;
    while (TRUE)
    {
	cwc = 0;
	if (!xeGetComputerNameExW(NameType, NULL, &cwc))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
		ComputerNameDnsFullyQualified == NameType)
	    {
		_PrintError(hr, "GetComputerNameExW(DnsFullyQualified) -- switching to NetBIOS");
		NameType = ComputerNameNetBIOS;
		continue;
	    }
	    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
	    {
		_JumpError(hr, error, "GetComputerNameEx");
	    }
	    break;
	}
    }
    pwszDnsName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszDnsName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!xeGetComputerNameExW(NameType, pwszDnsName, &cwc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetComputerNameEx");
    }

    *ppwszDnsName = pwszDnsName;
    pwszDnsName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    return(hr);
}

HRESULT
myGetProcessName(
    OUT WCHAR **ppwszProcessName)
{
    HRESULT hr;
    WCHAR *pwszCommandLine;
    WCHAR const *pwsz;
    WCHAR const *pwszStart;
    WCHAR *pwszAlloc;
    DWORD cwc;
    WCHAR wc;
    BOOL  fNeedFree;
    
    *ppwszProcessName = NULL;
    pwszCommandLine = xeGetCommandLineW(&fNeedFree);
    if (NULL == pwszCommandLine)
    {
	pwszCommandLine = L"";
    }
    wc = L' ';
    pwsz = pwszCommandLine;
    if ('"' == *pwsz)
    {
	wc = '"';
	pwsz++;
    }
    pwszStart = pwsz;
    while (L'\0' != *pwsz && wc != *pwsz)
    {
	if (L'\\' == *pwsz++)
	{
	    pwszStart = pwsz;
	}
    }
    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszStart);

    pwszAlloc = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszAlloc, pwszStart, cwc * sizeof(WCHAR));
    pwszAlloc[cwc] = L'\0';
    *ppwszProcessName = pwszAlloc;
    hr = S_OK;

error:
    if (fNeedFree && NULL != pwszCommandLine)
    {    
        LocalFree(pwszCommandLine);        
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xelib\xelib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       xcertlib.cpp
//
//  Contents:   most functions are moved and modofied from certsrv library
//
//  History:    03-2000   xtan   created
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include <dbgdef.h>
#include <wininet.h>

#include "xelib.h"


// Crypt callback versions: must have certain signatures
LPVOID myCryptAlloc_LocalAlloc(size_t cbSize)  { return myAlloc(cbSize, CERTLIB_USE_LOCALALLOC); }
VOID myCryptAlloc_LocalFree(VOID* pv)  { myFree(pv, CERTLIB_USE_LOCALALLOC); }

LPVOID myCryptAlloc_CoTaskMemAlloc(size_t cbSize)  { return myAlloc(cbSize, CERTLIB_USE_COTASKMEMALLOC); }
VOID myCryptAlloc_CoTaskMemFree(VOID* pv)  { myFree(pv, CERTLIB_USE_COTASKMEMALLOC); }

// give callers an easy way to choose what to call: pick allocator based on allocation type
PFN_CRYPT_ALLOC PickAlloc(CERTLIB_ALLOCATOR allocType) 
{ 
    if (allocType == CERTLIB_USE_LOCALALLOC) 
       return myCryptAlloc_LocalAlloc;
    else if (allocType == CERTLIB_USE_COTASKMEMALLOC)
       return myCryptAlloc_CoTaskMemAlloc;

    CSASSERT(!"Bad allocType");
    return NULL;
}

PFN_CRYPT_FREE PickFree(CERTLIB_ALLOCATOR allocType)
{
    if (allocType == CERTLIB_USE_LOCALALLOC) 
       return myCryptAlloc_LocalFree;
    else if (allocType == CERTLIB_USE_COTASKMEMALLOC)
       return myCryptAlloc_CoTaskMemFree;

    CSASSERT(!"Bad allocType");
    return NULL;
}

VOID *
myAlloc(IN size_t cbBytes, IN CERTLIB_ALLOCATOR allocType)
{
    void *pv;

    switch (allocType)
    {
    case CERTLIB_USE_LOCALALLOC:
        pv = LocalAlloc(LMEM_FIXED, cbBytes);
        break;
    case CERTLIB_USE_COTASKMEMALLOC:
        pv = CoTaskMemAlloc(cbBytes);
        break;
    default:
        CSASSERT(FALSE);
        pv = NULL;
        break;
    }

    if (NULL == pv)
    {
	_PrintError(E_OUTOFMEMORY, "myAlloc");
        SetLastError(E_OUTOFMEMORY);
    }
    return(pv);
}

VOID
myFree(IN void *pv, IN CERTLIB_ALLOCATOR allocType)
{
    switch(allocType)
    {
    case CERTLIB_USE_LOCALALLOC:
        LocalFree(pv);
        break;
    case CERTLIB_USE_COTASKMEMALLOC:
        CoTaskMemFree(pv);
        break;
    default:
        CSASSERT(FALSE);
        break;
    }
}

HRESULT
myHError(HRESULT hr)
{
    CSASSERT(S_FALSE != hr);

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if (0 == HRESULT_CODE(hr))
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
        CSASSERT(FAILED(hr));
    }
    return(hr);
}

HRESULT
myHLastError(VOID)
{
    return(myHError(GetLastError()));
}

#ifdef _XENROLL_SRC_

typedef BOOL
(WINAPI * PFNCryptEncodeObjectEx)
   (IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded);

typedef BOOL
(WINAPI * PFNCryptDecodeObjectEx)
   (IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo);

#endif //_XENROLL_SRC_

BOOL
myEncodeObject(
    DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    BOOL b = FALSE;

    CSASSERT(NULL != ppbEncoded);
        CRYPT_ENCODE_PARA sAllocator;
        sAllocator.cbSize = sizeof(sAllocator);
        sAllocator.pfnAlloc = PickAlloc(allocType);
        sAllocator.pfnFree = PickFree(allocType);

#ifdef _XENROLL_SRC_
    PFNCryptEncodeObjectEx pfnCryptEncodeObjectEx = NULL;
    HMODULE hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCryptEncodeObjectEx = (PFNCryptEncodeObjectEx)
                GetProcAddress(hModule, "CryptEncodeObjectEx");
        if (NULL != pfnCryptEncodeObjectEx)
        {
            b = pfnCryptEncodeObjectEx(
                    dwEncodingType,
                    lpszStructType,
                    const_cast<VOID *>(pvStructInfo),
                    dwFlags|CRYPT_ENCODE_ALLOC_FLAG,
                    &sAllocator,
                    ppbEncoded,
                    pcbEncoded);
        }
    }
#else
	b = CryptEncodeObjectEx(
		    dwEncodingType,
		    lpszStructType,
		    const_cast<VOID *>(pvStructInfo),
		    dwFlags|CRYPT_ENCODE_ALLOC_FLAG,
		    &sAllocator,
		    ppbEncoded,
		    pcbEncoded);
	if (b && 0 == *pcbEncoded)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
#endif //_XENROLL_SRC_

    return(b);
}

BOOL
myDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo)
{
    BOOL b = FALSE;

        CRYPT_DECODE_PARA sAllocator;
        sAllocator.cbSize = sizeof(sAllocator);
        sAllocator.pfnAlloc = PickAlloc(allocType);
        sAllocator.pfnFree = PickFree(allocType);

#ifdef _XENROLL_SRC_
    PFNCryptDecodeObjectEx pfnCryptDecodeObjectEx = NULL;
    HMODULE hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCryptDecodeObjectEx = (PFNCryptDecodeObjectEx)
                GetProcAddress(hModule, "CryptDecodeObjectEx");
        if (NULL != pfnCryptDecodeObjectEx)
        {
            b = pfnCryptDecodeObjectEx(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    CRYPT_DECODE_ALLOC_FLAG,                  // dwFlags
                    &sAllocator,
		    ppvStructInfo,
		    pcbStructInfo);
        }
    }
#else
	b = CryptDecodeObjectEx(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    CRYPT_DECODE_ALLOC_FLAG,                  // dwFlags
                    &sAllocator,
		    ppvStructInfo,
		    pcbStructInfo);
	if (b && 0 == *pcbStructInfo)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
#endif //_XENROLL_SRC_

    return(b);
}

HRESULT
myDecodePKCS7(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT BYTE **ppbContents,
    OPTIONAL OUT DWORD *pcbContents,
    OPTIONAL OUT DWORD *pdwMsgType,
    OPTIONAL OUT char **ppszInnerContentObjId,
    OPTIONAL OUT DWORD *pcSigner,
    OPTIONAL OUT DWORD *pcRecipient,
    OPTIONAL OUT HCERTSTORE *phStore,
    OPTIONAL OUT HCRYPTMSG *phMsg)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    DWORD cbContents;
    char *pszInnerContentObjId = NULL;
    DWORD cb;

    if (NULL != ppszInnerContentObjId)
    {
	*ppszInnerContentObjId = NULL;
    }
    if (NULL != pcSigner)
    {
	*pcSigner = 0;
    }
    if (NULL != pcRecipient)
    {
	*pcRecipient = 0;
    }
    if (NULL != ppbContents)
    {
	*ppbContents = NULL;
    }
    if (NULL != phStore)
    {
	*phStore = NULL;
    }
    if (NULL != phMsg)
    {
	*phMsg = NULL;
    }
    if (NULL != phStore)
    {
	CRYPT_DATA_BLOB blobPKCS7;

	blobPKCS7.pbData = (BYTE *) pbIn;
	blobPKCS7.cbData = cbIn;

	hStore = CertOpenStore(
			    CERT_STORE_PROV_PKCS7,
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    NULL,		// hCryptProv
			    0,			// dwFlags
			    &blobPKCS7);
	if (NULL == hStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
//	    _JumpError2(hr, error, "CertOpenStore", CRYPT_E_ASN1_BADTAG);
	}
    }

    hMsg = CryptMsgOpenToDecode(
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    0,			// dwFlags
			    0,			// dwMsgType
			    NULL,		// hCryptProv
			    NULL,		// pRecipientInfo
			    NULL);		// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    if (!CryptMsgUpdate(hMsg, pbIn, cbIn, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }
    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_INNER_CONTENT_TYPE_PARAM,
		    0, 		// dwIndex
                    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pszInnerContentObjId,
		    &cb);
    _PrintIfError(hr, "myCryptMsgGetParam(inner content type)");

#if 0
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"pszInnerContentObjId = %hs\n",
	pszInnerContentObjId));
#endif //0

    cbContents = 0;
    hr = myCryptMsgGetParam(
			hMsg,
			CMSG_CONTENT_PARAM,
			0, 		// dwIndex
                        CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbContents,
			&cbContents);
    _JumpIfError(hr, error, "myCryptMsgGetParam(content)");

    if (NULL != pdwMsgType)
    {
	cb = sizeof(*pdwMsgType);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_TYPE_PARAM,
			0,
			pdwMsgType,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetParam(type)");
	}
    }
    if (NULL != pcSigner)
    {
	cb = sizeof(*pcSigner);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_SIGNER_COUNT_PARAM,
			0,
			pcSigner,
			&cb))
	{
	    hr = myHLastError();
	    *pcSigner = 0;
	    if (CRYPT_E_INVALID_MSG_TYPE != hr)
	    {
		_JumpError(hr, error, "CryptMsgGetParam(signer count)");
	    }
	}
    }
    if (NULL != pcRecipient)
    {
	cb = sizeof(*pcRecipient);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_RECIPIENT_COUNT_PARAM,
			0,
			pcRecipient,
			&cb))
	{
	    hr = myHLastError();
	    *pcRecipient = 0;
	    if (CRYPT_E_INVALID_MSG_TYPE != hr)
	    {
		_JumpError(hr, error, "CryptMsgGetParam(recipient count)");
	    }
	}
    }
    if (NULL != phMsg)
    {
	*phMsg = hMsg;
	hMsg = NULL;
    }
    if (NULL != phStore)
    {
	*phStore = hStore;
	hStore = NULL;
    }
    if (NULL != ppszInnerContentObjId)
    {
	*ppszInnerContentObjId = pszInnerContentObjId;
	pszInnerContentObjId = NULL;
    }
    if (NULL != pcbContents)
    {
	*pcbContents = cbContents;
    }
    if (NULL != ppbContents && 0 != cbContents)
    {
	*ppbContents = pbContents;
	pbContents = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbContents)
    {
	LocalFree(pbContents);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    return(hr);
}

HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myAddNameSuffix(
    IN WCHAR const *pwszValue,
    IN WCHAR const *pwszSuffix,
    IN DWORD cwcNameMax,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    DWORD cwcValue = wcslen(pwszValue);
    DWORD cwcSuffix = wcslen(pwszSuffix);
    WCHAR *pwszOut;

    *ppwszOut = NULL;
    pwszOut = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    sizeof(WCHAR) * (1 + cwcValue + cwcSuffix));
    if (NULL == pwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CSASSERT(cwcNameMax > cwcSuffix);
    if (cwcValue > cwcNameMax - cwcSuffix)
    {
	cwcValue = cwcNameMax - cwcSuffix;
    }
    wcscpy(pwszOut, pwszValue);
    wcscpy(&pwszOut[cwcValue], pwszSuffix);
    *ppwszOut = pwszOut;
    hr = S_OK;

error:
    return(hr);
}


#define OCTECTSPACES

VOID
MultiByteStringSize(
    IN BOOL fOctetString,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbIn,
    OUT DWORD *pcbString)
{
    DWORD cbIn = *pcbIn;
    DWORD cbString;

    if (!fOctetString)
    {
	while (1 < cbIn && 0 == pbIn[cbIn - 1])
	{
	    cbIn--;
	}
    }

    // Two ascii-hex characters per byte, plus the null terminator:
    cbString = ((2 * cbIn) + 1) * sizeof(WCHAR);

#ifdef OCTECTSPACES
    // Allow for separating spaces after each byte except the last:
    if (fOctetString && 1 < cbIn)
    {
	cbString += (cbIn - 1) * sizeof(WCHAR);
    }
#endif // OCTECTSPACES
    *pcbIn = cbIn;
    *pcbString = cbString;
}

__inline WCHAR
NibbleToAscii(
    IN BYTE b)
{
    return(L"0123456789abcdef"[b & 0x0f]);
}


// MultiByteIntegerToWszBuf - convert a little-endian integer blob to
// a big endian null-terminated ascii-hex encoded WCHAR string of even length.

HRESULT
MultiByteIntegerToWszBuf(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT WCHAR *pwszOut)
{
    HRESULT hr = S_OK;
    DWORD cbOut;
    BYTE const *pbEnd = &pbIn[cbIn];
    WCHAR *pwsz = pwszOut;

    MultiByteStringSize(fOctetString, pbIn, &cbIn, &cbOut);

    if (NULL != pwszOut)
    {
	BYTE const *pb;

	if (cbOut > *pcbOut)
	{
	    hr = TYPE_E_BUFFERTOOSMALL;
	    _JumpError(hr, error, "MultiByteIntegerToWsz: buffer overflow");
	}
	if (fOctetString)
	{
	    for (pb = pbIn; pb < pbEnd; pb++)
	    {
		*pwszOut++ = NibbleToAscii(*pb >> 4);
		*pwszOut++ = NibbleToAscii(*pb);
#ifdef OCTECTSPACES
		if (pb + 1 < pbEnd)
		{
		    *pwszOut++ = L' ';
		}
#endif // OCTECTSPACES
	    }
	}
	else
	{
	    for (pb = pbEnd; pb-- > pbIn; )
	    {
		*pwszOut++ = NibbleToAscii(*pb >> 4);
		*pwszOut++ = NibbleToAscii(*pb);
	    }
	}
	*pwszOut = L'\0';
	CSASSERT(
	    (SAFE_SUBTRACT_POINTERS(pwszOut, pwsz) + 1) * sizeof(WCHAR) ==
	    cbOut);
    }
    *pcbOut = cbOut;

error:
    return(hr);
}


// MultiByteIntegerToBstr - convert a little-endian integer blob to
// a big endian null-terminated ascii-hex encoded BSTR of even length.
// If fOctetString is TRUE, preserve endian order, as in a hex dump

HRESULT
MultiByteIntegerToBstr(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OUT BSTR *pstrOut)
{
    HRESULT hr = S_OK;
    BSTR str = NULL;
    DWORD cbOut;

    MultiByteStringSize(fOctetString, pbIn, &cbIn, &cbOut);

    str = SysAllocStringByteLen(NULL, cbOut - sizeof(WCHAR));
    if (NULL == str)
    {
	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "SysAllocStringLen");
    }

    hr = MultiByteIntegerToWszBuf(fOctetString, cbIn, pbIn, &cbOut, str);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    CSASSERT((wcslen(str) + 1) * sizeof(WCHAR) == cbOut);
    CSASSERT(SysStringByteLen(str) + sizeof(WCHAR) == cbOut);

    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
    }
    *pstrOut = str;
    str = NULL;

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
    return(hr);
}


BOOL
myCryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,            // AT_SIGNATURE | AT_KEYEXCHANGE
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_PUBLIC_KEY_INFO **ppPubKey,
    OUT DWORD *pcbPubKey)
{
    BOOL b;

    *ppPubKey = NULL;
    *pcbPubKey = 0;
    while (TRUE)
    {
	b = CryptExportPublicKeyInfo(
				hCryptProv,
				dwKeySpec,
				X509_ASN_ENCODING,
				*ppPubKey,
				pcbPubKey);
	if (b && 0 == *pcbPubKey)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppPubKey)
	    {
		myFree(*ppPubKey, allocType);
		*ppPubKey = NULL;
	    }
	    break;
	}
	if (NULL != *ppPubKey)
	{
	    break;
	}
	*ppPubKey = (CERT_PUBLIC_KEY_INFO *) myAlloc(*pcbPubKey, allocType);
	if (NULL == *ppPubKey)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}

VOID
myMakeExprDateTime(
    IN OUT FILETIME *pft,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    LONGLONG llDelta;
    BOOL fSysTimeDelta;

    llDelta = lDelta;
    fSysTimeDelta = FALSE;
    switch (enumPeriod)
    {
	case ENUM_PERIOD_WEEKS:   llDelta *= CVT_WEEKS;    break;
	case ENUM_PERIOD_DAYS:    llDelta *= CVT_DAYS;     break;
	case ENUM_PERIOD_HOURS:   llDelta *= CVT_HOURS;    break;
	case ENUM_PERIOD_MINUTES: llDelta *= CVT_MINUTES;  break;
	case ENUM_PERIOD_SECONDS: 			  break;
	default:
	    fSysTimeDelta = TRUE;
	    break;
    }
    if (fSysTimeDelta)
    {
	    SYSTEMTIME SystemTime;

	    FileTimeToSystemTime(pft, &SystemTime);
	    switch (enumPeriod)
	    {
	        case ENUM_PERIOD_MONTHS:
		    if (0 > lDelta)
		    {
		        DWORD dwDelta = (DWORD) -lDelta;

		        SystemTime.wYear -= (WORD) (dwDelta / 12) + 1;
		        SystemTime.wMonth += 12 - (WORD) (dwDelta % 12);
		    }
		    else
		    {
		        SystemTime.wMonth += (WORD) lDelta;
		    }
		    if (12 < SystemTime.wMonth)
		    {
		        SystemTime.wYear += (SystemTime.wMonth - 1) / 12;
		        SystemTime.wMonth = ((SystemTime.wMonth - 1) % 12) + 1;
		    }
		    break;

	        case ENUM_PERIOD_YEARS:
		    SystemTime.wYear += (WORD) lDelta;
		    break;

	        default:
		    SystemTime.wYear += 1;
		    break;
	    }

DoConvert:
        if (!SystemTimeToFileTime(&SystemTime, pft))
        {
            if (GetLastError() != ERROR_INVALID_PARAMETER)
            {
                CSASSERT(!"Unable to do time conversion");
                return;
            }

            // In some cases we'll convert to an invalid month-end

            // only one month changes length from year to year
            if (SystemTime.wMonth == 2)
            {
                // > 29? try leap year
                if (SystemTime.wDay > 29)
                {
                    SystemTime.wDay = 29;
                    goto DoConvert;
                }
                // == 29? try non-leap year
                else if (SystemTime.wDay == 29)
                {
                    SystemTime.wDay = 28;
                    goto DoConvert;
                }
            }
            // sept (9), apr(4), jun(6), nov(11) all have 30 days
            else if ((SystemTime.wMonth == 9) ||
                     (SystemTime.wMonth == 4) ||
                     (SystemTime.wMonth == 6) ||
                     (SystemTime.wMonth == 11))
            {
                if (SystemTime.wDay > 30)
                {
                    SystemTime.wDay = 30;
                    goto DoConvert;
                }
            }

            // should never get here
            CSASSERT(!"Month/year processing: inaccessible code");
            return;
        }
    }
    else
    {
	    *(LONGLONG UNALIGNED *) pft += llDelta * CVT_BASE;
    }
}


BOOL
myCryptSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncodedToBeSigned,
    IN DWORD cbEncodedToBeSigned,
    IN CRYPT_ALGORITHM_IDENTIFIER const *pSignatureAlgorithm,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSignature,
    OUT DWORD *pcbSignature)
{
    BOOL b;

    *ppbSignature = NULL;
    *pcbSignature = 0;
    while (TRUE)
    {
        b = CryptSignCertificate(
		hCryptProv,
		dwKeySpec,
		dwEncodingType,
		pbEncodedToBeSigned,
		cbEncodedToBeSigned,
		const_cast<CRYPT_ALGORITHM_IDENTIFIER *>(pSignatureAlgorithm),
		NULL,		// pvHashAuxInfo
		*ppbSignature,
		pcbSignature);
	if (b && 0 == *pcbSignature)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppbSignature)
	    {
		myFree(*ppbSignature, allocType);
		*ppbSignature = NULL;
	    }
	    break;
	}
	if (NULL != *ppbSignature)
	{
	    break;
	}
	*ppbSignature = (BYTE *) myAlloc(*pcbSignature, allocType);
	if (NULL == *ppbSignature)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}

HRESULT
myEncodeSignedContent(
    IN HCRYPTPROV hProv,
    IN DWORD dwCertEncodingType,
    IN char const *pszObjIdSignatureAlgorithm,
    IN BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned)
{
    HRESULT hr;
    CERT_SIGNED_CONTENT_INFO csci;

    ZeroMemory(&csci, sizeof(csci));
    csci.SignatureAlgorithm.pszObjId = (char *) pszObjIdSignatureAlgorithm;
    csci.ToBeSigned.cbData = cbToBeSigned;
    csci.ToBeSigned.pbData = pbToBeSigned;

    *ppbSigned = NULL;

    if (!myCryptSignCertificate(
			    hProv,
			    AT_SIGNATURE,
			    dwCertEncodingType,
			    csci.ToBeSigned.pbData,
			    csci.ToBeSigned.cbData,
			    &csci.SignatureAlgorithm,
			    CERTLIB_USE_LOCALALLOC,
			    &csci.Signature.pbData,
			    &csci.Signature.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignCertificate");
    }

//    if (!myEncodeCert(
    if (!myEncodeObject(
		dwCertEncodingType,
                X509_CERT,
		&csci,
                0,
		allocType,
		ppbSigned,
		pcbSigned))
    {
	hr = myHLastError();
//	_JumpError(hr, error, "myEncodeCert");
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != csci.Signature.pbData)
    {
        LocalFree(csci.Signature.pbData);
    }
    return(hr);
}

HRESULT
myGetPublicKeyHash(
    OPTIONAL IN CERT_INFO const *pCertInfo,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    CRYPT_DATA_BLOB *pBlob = NULL;
    DWORD cb;
    BYTE const *pb;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];

    *ppbData = NULL;

    if (NULL == pPublicKeyInfo)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "parm NULL");
    }

    pb = NULL;
    if (NULL != pCertInfo)
    {
	CERT_EXTENSION const *pExt;
	CERT_EXTENSION const *pExtEnd;

	pExtEnd = &pCertInfo->rgExtension[pCertInfo->cExtension];
	for (pExt = pCertInfo->rgExtension; pExt < pExtEnd; pExt++)
	{
	    if (0 == strcmp(szOID_SUBJECT_KEY_IDENTIFIER, pExt->pszObjId))
	    {
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				pExt->Value.pbData,
				pExt->Value.cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pBlob,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		pb = pBlob->pbData;
		cb = pBlob->cbData;
		break;
	    }
	}
    }
    if (NULL == pb)
    {
	cb = sizeof(abHash);
	if (!CryptHashPublicKeyInfo(
			    NULL,		// hCryptProv
			    CALG_SHA1,
			    0,                  // dwFlags,
			    X509_ASN_ENCODING,
			    const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			    abHash,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashPublicKeyInfo");
	}
	pb = abHash;
    }

    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pcbData = cb;
    CopyMemory(*ppbData, pb, cb);
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}

HRESULT
myCreateSubjectKeyIdentifierExtension(
    IN CERT_PUBLIC_KEY_INFO const *pPubKey,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    HRESULT hr;
    CRYPT_DATA_BLOB KeyIdentifier;

    KeyIdentifier.pbData = NULL;
    hr = myGetPublicKeyHash(
			NULL,		// pCertInfo
			pPubKey,
			&KeyIdentifier.pbData,
			&KeyIdentifier.cbData);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    // Issuer's KeyId:

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &KeyIdentifier,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != KeyIdentifier.pbData)
    {
	LocalFree(KeyIdentifier.pbData);
    }
    return(hr);
}


HRESULT
myCalculateKeyArchivalHash(
    IN const BYTE     *pbEncryptedKey,
    IN DWORD           cbEncryptedKey,
    OUT BYTE         **ppbHash,
    OUT DWORD         *pcbHash)
{
    HRESULT    hr;
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE*      pbHash = NULL;
    DWORD      cbHash = 0;
    DWORD      dwSize;

    if (NULL == pbEncryptedKey ||
        NULL == ppbHash ||
        NULL == pcbHash)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        _JumpError(hr, error, "Invalid parameters");
    }

    //init
    *ppbHash = NULL;
    *pcbHash = 0;

    if (!CryptAcquireContext(
            &hProv,
            NULL,       // pszContainer
            NULL,       // pszProvider
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptAcquireContext");
    }

    //create a hash object
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptCreateHash");
    }

    //hash the data
    if (!CryptHashData(
            hHash,
            pbEncryptedKey,
            cbEncryptedKey,
            0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptHashData");
    }

    //get the hash size
    dwSize = sizeof(cbHash);
    if (!CryptGetHashParam(
            hHash,
            HP_HASHSIZE,
            (BYTE*)&cbHash,
            &dwSize,
            0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGetHashParam");
    }

    //allocate for hash buffer
    pbHash = (BYTE*)LocalAlloc(LMEM_FIXED, cbHash);
    if (NULL == pbHash)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    dwSize = cbHash;
    //get the hash
    if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            (BYTE*)pbHash,
            &dwSize,
            0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGetHashParam");
    }

    //should be the same
    CSASSERT(dwSize == cbHash);

    //return
    *ppbHash = pbHash;
    *pcbHash = cbHash;
    pbHash = NULL;

    hr = S_OK;
error:
    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbHash)
    {
        LocalFree(pbHash);
    }
    return hr;
}


//--------------------------------------------------------------------
// Escapes any characters unsuitable for a URL.  Returns a new string.

HRESULT
myInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    CSASSERT(NULL != pwszIn);

    // Calculate required buffer size by passing a very small buffer
    // The call will fail, and tell us how big the buffer should be.

    WCHAR wszPlaceHolder[1];
    DWORD cwc = ARRAYSIZE(wszPlaceHolder);
    BOOL bResult;

    bResult = InternetCanonicalizeUrlW(
				pwszIn,		// lpszUrl
				wszPlaceHolder,	// lpszBuffer
				&cwc,		// lpdwBufferLength
				0);		// dwFlags
    CSASSERT(!bResult);	// This will always fail

    hr = myHLastError();
    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
    {
        // unexpected error

        _JumpError(hr, error, "InternetCanonicalizeUrl");
    }

    // NOTE: InternetCanonicalizeUrl counts characters, not bytes as doc'd
    // cwc includes trailing L'0'

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // canonicalize
    if (!InternetCanonicalizeUrlW(
			    pwszIn,	// lpszUrl
			    pwsz,	// lpszBuffer
			    &cwc,	// lpdwBufferLength
			    0))		// dwFlags
    {
        hr = myHLastError();
        _JumpError(hr, error, "InternetCanonicalizeUrl");
    }
    *ppwszOut = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return(hr);
}


// Inverse of InternetCanonicalizeUrl -- Convert "%20" sequences to " ", etc.

HRESULT
myInternetUncanonicalizeURL(
    IN WCHAR const *pwszURLIn,
    OUT WCHAR **ppwszURLOut)
{
    HRESULT hr;
    URL_COMPONENTSW urlcomp;
    WCHAR wszScheme[10];	// L"ldap"
    WCHAR wszHost[MAX_PATH];
    WCHAR wszURL[MAX_PATH];
    WCHAR wszExtra[MAX_PATH];
    WCHAR *pwszURL = NULL;
    DWORD cURL;
    DWORD cwcURLAlloc;

    *ppwszURLOut = NULL;
    ZeroMemory(&urlcomp, sizeof(urlcomp));
    urlcomp.dwStructSize = sizeof(urlcomp);

    urlcomp.lpszScheme = wszScheme;
    urlcomp.dwSchemeLength = ARRAYSIZE(wszScheme);

    urlcomp.lpszHostName = wszHost;
    urlcomp.dwHostNameLength = ARRAYSIZE(wszHost);

    urlcomp.lpszUrlPath = wszURL;
    urlcomp.dwUrlPathLength = ARRAYSIZE(wszURL);

    urlcomp.lpszExtraInfo = wszExtra;
    urlcomp.dwExtraInfoLength = ARRAYSIZE(wszExtra);

    // Decode escape sequemces

    if (!InternetCrackUrlW(pwszURLIn, 0, ICU_ESCAPE, &urlcomp))
    {
	hr = myHLastError();
	_JumpError(hr, error, "InternetCrackUrl");
    }

    cURL = 0;
    while (TRUE)
    {
	// InternetCreateUrl is spec'd strangely:
	//
	// When called with a NULL input pointer or an insufficient buffer
	// size, the returned count is the number of bytes required, including
	// the trailing L'\0'.
	//
	// When called with a non-NULL input pointer of adequate size, the
	// returned count is the count of chars, excluding the trailing L'\0'.
	//
	// This is just so wierd!

	if (!InternetCreateUrlW(&urlcomp, 0, pwszURL, &cURL))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr ||
		NULL != pwszURL)
	    {
		_JumpError(hr, error, "InternetCreatUrl");
	    }
	}
	if (NULL != pwszURL)
	{
	    CSASSERT(wcslen(pwszURL) == cURL);
	    CSASSERT(cwcURLAlloc == cURL + 1);
	    break;
	}
	pwszURL = (WCHAR *) LocalAlloc(LMEM_FIXED, cURL);
	if (NULL == pwszURL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	cURL /= sizeof(WCHAR);
	cwcURLAlloc = cURL;
    }
    *ppwszURLOut = pwszURL;
    pwszURL = NULL;
    hr = S_OK;

error:
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    return(hr);
}


BOOL
ConvertWszToMultiByte(
    OUT CHAR **ppsz,
    IN UINT CodePage,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    HRESULT hr;
    LONG cch = 0;

    *ppsz = NULL;
    while (TRUE)
    {
	cch = WideCharToMultiByte(
			CodePage,
			0,          // dwFlags
			pwc,
			cwc,        // cchWideChar, -1 => null terminated
			*ppsz,
			cch,
			NULL,
			NULL);
	if (0 >= cch && 
	    (0 != cch || (0 != cwc && (MAXLONG != cwc || L'\0' != *pwc))))
	{
	    hr = myHLastError();
	    _PrintError(hr, "WideCharToMultiByte");

	    if (NULL != *ppsz)
	    {
		LocalFree(*ppsz);
		*ppsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppsz)
	{
	    (*ppsz)[cch] = '\0';
	    hr = S_OK;
	    break;
	}
	*ppsz = (CHAR *) LocalAlloc(LMEM_FIXED, cch + 1);
	if (NULL == *ppsz)
	{
	    hr = E_OUTOFMEMORY;
	    break;
	}
    }
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


BOOL
myConvertWszToUTF8(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    return(ConvertWszToMultiByte(ppsz, CP_UTF8, pwc, cwc));
}


BOOL
myConvertWszToSz(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    DWORD cch;
    
    return(ConvertWszToMultiByte(ppsz, GetACP(), pwc, cwc));
}


BOOL
myConvertMultiByteToWsz(
    OUT WCHAR **ppwsz,
    IN UINT CodePage,
    IN CHAR const *pch,
    IN LONG cch)
{
    HRESULT hr;
    LONG cwc = 0;

    *ppwsz = NULL;
    while (TRUE)
    {
	cwc = MultiByteToWideChar(CodePage, 0, pch, cch, *ppwsz, cwc);
	if (0 >= cwc)
	{
	    hr = myHLastError();
	    _PrintError(hr, "MultiByteToWideChar");

	    if (NULL != *ppwsz)
	    {
		LocalFree(*ppwsz);
		*ppwsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppwsz)
	{
	    (*ppwsz)[cwc] = L'\0';
	    hr = S_OK;
	    break;
	}
	*ppwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == *ppwsz)
	{
	    hr = E_OUTOFMEMORY;
	    break;
	}
    }
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


BOOL
myConvertUTF8ToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch)
{
    return(myConvertMultiByteToWsz(ppwsz, CP_UTF8, pch, cch));
}


BOOL
myConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch)
{
    return(myConvertMultiByteToWsz(ppwsz, GetACP(), pch, cch));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\cenroll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cenroll.h
//
//--------------------------------------------------------------------------

// CEnroll.h : Declaration of the CCEnroll

#ifndef __CENROLL_H_
#define __CENROLL_H_

#include <objsafe.h>
#include "resource.h"	    // main symbols

extern HINSTANCE hInstanceXEnroll;
#define MAX_SAFE_FOR_SCRIPTING_REQUEST_STORE_COUNT  500

typedef enum _StoreType {
	StoreNONE,
	StoreMY,
	StoreCA,
	StoreROOT,
	StoreREQUEST
} StoreType;

typedef struct _StoreInfo {
    LPWSTR  	wszName;
    LPSTR  		szType;
    DWORD   	dwFlags;
    HCERTSTORE	hStore;
} STOREINFO, *PSTOREINFO;

typedef struct _EXT_STACK {
    CERT_EXTENSION  	ext;
    struct _EXT_STACK *	pNext;
} EXT_STACK, * PEXT_STACK;

typedef struct _ATTR_STACK {
    CRYPT_ATTRIBUTE  		attr;
    struct _ATTR_STACK *	pNext;
} ATTR_STACK, * PATTR_STACK;

typedef struct _PROP_STACK {
    LONG                    lPropId;
    LONG                    lFlags;
    CRYPT_DATA_BLOB  		prop;
    struct _PROP_STACK *	pNext;
} PROP_STACK, * PPROP_STACK;

// Interface for a generic certificate context filter, currently used 
// filter enumerations of the certificate store.  
class CertContextFilter { 

 public:
    // Returns S_OK on success, and assigns the out parameter. 
    // The out parameter is TRUE if the cert context should be present in its enumeration,
    // FALSE if it should be filtered out.  On error, the value of the out parameter is
    // undefined.  
    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult) = 0; 
}; 

class CompositeCertContextFilter : public CertContextFilter { 
    CertContextFilter * filter1, * filter2; 
 public: 
    CompositeCertContextFilter(CertContextFilter * _filter1, CertContextFilter * _filter2) { 
	filter1 = _filter1; 
	filter2 = _filter2; 
    }
      
    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult) 
    { 
	HRESULT hr = S_OK;
	*fResult = TRUE; 

	// Note:  do not do input validation, as that could lead to a change in the behavior
	//        of the filters composed.  

	if (filter1 == NULL || S_OK == (hr = filter1->accept(pCertContext, fResult)))
	{ 
	    if (*fResult && (filter2 != NULL) )
		{ hr = filter2->accept(pCertContext, fResult); }
	}
	return hr; 
    }
}; 

// Extension of the base certificate context filter.  Filters out all certificate contexts
// with different hash valeus.  
class EquivalentHashCertContextFilter : public CertContextFilter { 
 public: 
    EquivalentHashCertContextFilter(CRYPT_DATA_BLOB hashBlob) : m_hashBlob(hashBlob) { }

    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult) 
    {
	BOOL            fFreeBuffer = FALSE, fDone = FALSE; 
	BYTE            buffer[30]; 
	CRYPT_DATA_BLOB hashBlob; 
	HRESULT         hr          = S_OK; 

	// Input validation: 
	if (pCertContext == NULL) { return E_INVALIDARG; }

	hashBlob.cbData = 30;
	hashBlob.pbData = buffer; 

	do { 
	    if (!CertGetCertificateContextProperty
		(pCertContext, 
		 CERT_HASH_PROP_ID, 
		 (LPVOID)(hashBlob.pbData),
		 &(hashBlob.cbData)))
	    {
		// We need to allocate a bigger buffer for our OUT param: 
		if (ERROR_MORE_DATA == GetLastError())
		{
		    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData);
		    if (NULL == hashBlob.pbData)
		    {
			hr = E_OUTOFMEMORY; 
			goto ErrorReturn; 
		    }
		    fFreeBuffer = TRUE;
		}
		else
		{
		    hr = HRESULT_FROM_WIN32(GetLastError());
		    goto ErrorReturn; 
		}
	    }
	    else
	    {
		fDone = TRUE;
	    }
	} while (!fDone); 

	// We have the same hashes if they are the same size and contain the same data. 
	*fResult = (hashBlob.cbData == m_hashBlob.cbData &&
		    0               == memcmp(hashBlob.pbData, m_hashBlob.pbData, hashBlob.cbData)); 

    CommonReturn:
	if (fFreeBuffer) { LocalFree(hashBlob.pbData); } 
	return hr; 

    ErrorReturn: 
	goto CommonReturn; 
    }   

 private: 
    CRYPT_DATA_BLOB m_hashBlob; 
}; 

// Extension of the base certificate context filter.  Filters out all certificate contexts
// which are not pending. 
class PendingCertContextFilter : public CertContextFilter { 
 public:
    virtual HRESULT accept(IN PCCERT_CONTEXT pCertContext, OUT BOOL * fResult)
    {
	BOOL            fFreeBuffer = FALSE, fDone = FALSE; 
	BYTE            buffer[100]; 
	CRYPT_DATA_BLOB pendingInfoBlob;  
	HRESULT         hr          = S_OK; 

	// Input validation: 
	if (pCertContext == NULL) { return E_INVALIDARG; }

	pendingInfoBlob.cbData = 100; 
	pendingInfoBlob.pbData = buffer; 

	do { 
	    if (!CertGetCertificateContextProperty
		(pCertContext,
		 CERT_ENROLLMENT_PROP_ID,
		 (LPVOID)(pendingInfoBlob.pbData),
		 &(pendingInfoBlob.cbData)))
	    {
		switch (GetLastError()) { 
		case CRYPT_E_NOT_FOUND: 
		    // The cert doesn't have this property, it can't be pending. 
		    *fResult = FALSE; 
		    fDone    = TRUE;
		    break;
		case ERROR_MORE_DATA: 
		    // Our output buffer wasn't big enough.  Reallocate and try again...
		    pendingInfoBlob.pbData = (LPBYTE)LocalAlloc(LPTR, pendingInfoBlob.cbData); 
		    if (NULL == pendingInfoBlob.pbData)
		    {
			hr = E_OUTOFMEMORY;
			goto ErrorReturn; 
		    }
		    fFreeBuffer = TRUE; 
		    break; 
		default: 
		    // Oops, an error
		    hr = HRESULT_FROM_WIN32(GetLastError()); 
		    goto ErrorReturn; 
		}
	    }
	    else
	    {
	    // No error, cert must have this property.
		*fResult = TRUE;
		fDone    = TRUE; 
	    }
	} while (!fDone); 

    CommonReturn:
	if (fFreeBuffer) { LocalFree(pendingInfoBlob.pbData); } 
	return hr;

    ErrorReturn:
	goto CommonReturn; 
    }
};


class PendingRequestTable { 

private:
    //
    // Auxiliary class definitions: 
    // 
    typedef struct _TableElem { 
	PCCERT_CONTEXT pCertContext; 
    } TableElem; 

public:
    //
    // Public interface: 
    //
    PendingRequestTable(); 
    ~PendingRequestTable(); 

    HRESULT construct(HCERTSTORE hStore); 

    DWORD            size()                    { return this->dwElemCount; } 
    PCCERT_CONTEXT & operator[] (DWORD dwElem) { return this->table[dwElem].pCertContext; } 

private:
    HRESULT add    (TableElem   tePendingRequest); 
    HRESULT resize (DWORD       dwNewSize);

    DWORD        dwElemCount; 
    DWORD        dwElemSize; 
    TableElem   *table; 
};


// General procedure for providing a filtered iteration of certificates in a store. 
// Excepting its ability to filter, behaves in the same manner as 
// CertEnumCertificatesInStore(). 
HRESULT FilteredCertEnumCertificatesInStore(HCERTSTORE           hStore, 
					    PCCERT_CONTEXT       pCertContext, 
					    CertContextFilter   *pFilter,
					    PCCERT_CONTEXT      *pCertContextNext); 

#define XENROLL_PASS_THRU_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x100)
#define XENROLL_RENEWAL_CERTIFICATE_PROP_ID (CERT_FIRST_USER_PROP_ID + 0x101)
#define XENROLL_REQUEST_INFO ((LPCSTR) 400)


/////////////////////////////////////////////////////////////////////////////
// CCEnroll
class ATL_NO_VTABLE CCEnroll : IEnroll4,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCEnroll, &CLSID_CEnroll>,
	public IDispatchImpl<ICEnroll4, &IID_ICEnroll4, &LIBID_XENROLLLib>,
	public IObjectSafety
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_CENROLL)

BEGIN_COM_MAP(CCEnroll)
	COM_INTERFACE_ENTRY(IEnroll)
	COM_INTERFACE_ENTRY(IEnroll2)
	COM_INTERFACE_ENTRY(IEnroll4)
	COM_INTERFACE_ENTRY(ICEnroll)
	COM_INTERFACE_ENTRY(ICEnroll2)
	COM_INTERFACE_ENTRY(ICEnroll3)
	COM_INTERFACE_ENTRY(ICEnroll4)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ICEnroll
public:

		CCEnroll();

		virtual ~CCEnroll();
		
        virtual HRESULT __stdcall GetInterfaceSafetyOptions( 
                    /* [in]  */ REFIID riid,
                    /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
                    /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions);


        virtual HRESULT __stdcall SetInterfaceSafetyOptions( 
                    /* [in] */ REFIID riid,
                    /* [in] */ DWORD dwOptionSetMask,
                    /* [in] */ DWORD dwEnabledOptions);
           
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10( 
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName);
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7( 
            /* [in] */ BSTR wszPKCS7FileName);
            
        virtual HRESULT STDMETHODCALLTYPE getCertFromPKCS7( 
			/* [in] */ BSTR wszPKCS7,
			/* [retval][out] */ BSTR __RPC_FAR *pbstrCert);
            
        virtual HRESULT STDMETHODCALLTYPE createPKCS10( 
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR __RPC_FAR *pPKCS10);
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7( 
            /* [in] */ BSTR PKCS7);

		virtual HRESULT STDMETHODCALLTYPE enumProviders(
            /* [in] */ LONG  dwIndex,
            /* [in] */ LONG  dwFlags,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrProvName);
            
       	virtual HRESULT STDMETHODCALLTYPE enumContainers(
            /* [in] */ LONG                     dwIndex,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
            
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequest( 
            /* [in] */ BSTR CertType);
            
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToSignature( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Value);
     
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfo( 
            /* [in] */ BSTR PKCS7OrPKCS10);

        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreName( 
            /* [in] */ BSTR bstrName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreType( 
            /* [in] */ BSTR bstrType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContainer);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerName( 
            /* [in] */ BSTR bstrContainer);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProvider);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderName( 
            /* [in] */ BSTR bstrProvider);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [retval][out] */ LONG __RPC_FAR *pdwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [retval][out] */ LONG __RPC_FAR *pdw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [retval][out] */ BOOL __RPC_FAR *fUseExistingKeys);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [retval][out] */ LONG __RPC_FAR *pdwFlags);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fBool);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool);

        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [retval][out] */ BOOL __RPC_FAR *fBool);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileName( 
            /* [in] */ BSTR bstr);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileName( 
            /* [in] */ BSTR bstr);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ BSTR bstr);
	
	virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrint(
	    /* [in] */ BSTR bstrThumbPrint); 
     
	virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrint(
	    /* [out, retval] */  BSTR *pbstrThumbPrint);     

	virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrintWStr(
	    /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob); 
     
	virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrintWStr(
	    /* [out, retval] */  PCRYPT_DATA_BLOB thumbPrintBlob);     

        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7( 
            /* [in] */ BSTR PKCS7);

        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7WStr( 
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE getCertContextFromPKCS7( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);

        virtual HCERTSTORE STDMETHODCALLTYPE getMyStore( void);
        
        virtual HCERTSTORE STDMETHODCALLTYPE getCAStore( void);
        
        virtual HCERTSTORE STDMETHODCALLTYPE getROOTHStore( void);
        
        virtual HRESULT STDMETHODCALLTYPE enumProvidersWStr( 
            /* [in] */ LONG  dwIndex,
            /* [in] */ LONG  dwFlags,
            /* [out] */ LPWSTR __RPC_FAR *pbstrProvName);
        
        virtual HRESULT STDMETHODCALLTYPE enumContainersWStr( 
            /* [in] */ LONG  dwIndex,
            /* [out] */ LPWSTR __RPC_FAR *pbstr);

        virtual HRESULT STDMETHODCALLTYPE freeRequestInfoBlob( 
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwName);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreNameWStr( 
            /* [in] */ LPWSTR szwName);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreTypeWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwType);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreTypeWStr( 
            /* [in] */ LPWSTR szwType);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwContainer);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerNameWStr( 
            /* [in] */ LPWSTR szwContainer);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szwProvider);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderNameWStr( 
            /* [in] */ LPWSTR szwProvider);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileNameWStr( 
            /* [in] */ LPWSTR szw);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileNameWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileNameWStr( 
            /* [in] */ LPWSTR szw);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithmWStr( 
            /* [out] */ LPWSTR __RPC_FAR *szw);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithmWStr( 
            /* [in] */ LPWSTR szw);
            
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [out] */ PCCERT_CONTEXT __RPC_FAR *ppCertContext);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RenewalCertificate( 
            /* [in] */ PCCERT_CONTEXT pCertContext);
            
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStr( 
            LPWSTR szw);
            
        virtual HRESULT STDMETHODCALLTYPE AddNameValuePairToSignatureWStr( 
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
     
        virtual HRESULT STDMETHODCALLTYPE AddExtensionsToRequest( 
            PCERT_EXTENSIONS pCertExtensions);
        
        virtual HRESULT STDMETHODCALLTYPE AddAuthenticatedAttributesToPKCS7Request( 
            PCRYPT_ATTRIBUTES pAttributes);
        
        virtual HRESULT STDMETHODCALLTYPE CreatePKCS7RequestFromRequest( 
            PCRYPT_DATA_BLOB pRequest,
            PCCERT_CONTEXT pSigningCertContext,
            PCRYPT_DATA_BLOB pPkcs7Blob);

        virtual HRESULT STDMETHODCALLTYPE Reset(void);

        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec(
            LONG __RPC_FAR *pdwKeySpec);

        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Blob( 
            PCRYPT_DATA_BLOB pBlobPKCS7);

        virtual HRESULT STDMETHODCALLTYPE GetKeyLen(
            BOOL    fMin,
            BOOL    fExchange,
            LONG __RPC_FAR *pdwKeySize);

        virtual HRESULT STDMETHODCALLTYPE EnumAlgs(
            LONG dwIndex,
            LONG algMask,
            LONG __RPC_FAR *pdwAlgID);

        virtual HRESULT STDMETHODCALLTYPE GetAlgNameWStr(
            LONG  algID,
            LPWSTR __RPC_FAR *ppwsz);

        virtual HRESULT STDMETHODCALLTYPE GetAlgName(
            LONG algID,
            BSTR __RPC_FAR *pbstr);

        virtual HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        virtual HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            BOOL __RPC_FAR *fReuseHardwareKeyIfUnableToGenNew);

        virtual HRESULT STDMETHODCALLTYPE put_HashAlgID(
            LONG    hashAlgID);

        virtual HRESULT STDMETHODCALLTYPE get_HashAlgID(
            LONG *   hashAlgID);

        virtual HRESULT STDMETHODCALLTYPE SetHStoreMy(
            HCERTSTORE   hStore
            );
       
        virtual HRESULT STDMETHODCALLTYPE SetHStoreCA(
            HCERTSTORE   hStore
            );
       
        virtual HRESULT STDMETHODCALLTYPE SetHStoreROOT(
            HCERTSTORE   hStore
            );
       
        virtual HRESULT STDMETHODCALLTYPE SetHStoreRequest(
            HCERTSTORE   hStore
            );

        virtual HRESULT STDMETHODCALLTYPE  put_LimitExchangeKeyToEncipherment(
            BOOL    fLimitExchangeKeyToEncipherment
            );

        virtual HRESULT STDMETHODCALLTYPE  get_LimitExchangeKeyToEncipherment(
            BOOL * fLimitExchangeKeyToEncipherment
            );

        virtual HRESULT STDMETHODCALLTYPE  put_EnableSMIMECapabilities(
            BOOL fEnableSMIMECapabilities
            );

        virtual HRESULT STDMETHODCALLTYPE  get_EnableSMIMECapabilities(
            BOOL * fEnableSMIMECapabilities
            );

//ICEnroll4

        virtual HRESULT STDMETHODCALLTYPE put_PrivateKeyArchiveCertificate(
            IN  BSTR  bstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE get_PrivateKeyArchiveCertificate(
            OUT BSTR __RPC_FAR *pbstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE binaryToString(
            IN  LONG  Flags,
            IN  BSTR  strBinary,
            OUT BSTR *pstrEncoded
            );

        virtual HRESULT STDMETHODCALLTYPE stringToBinary(
            IN  LONG  Flags,
            IN  BSTR  strEncoded,
            OUT BSTR *pstrBinary
            );

        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequest(
            IN  LONG  Flags,
            IN  BSTR  strName,
            IN  BSTR  strValue
            );

        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequest(
            IN  LONG  Flags,
            IN  BSTR  strName,
            IN  BSTR  strValue
            );

        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequest(
            IN  LONG  Flags,
            IN  BSTR  strName,
            IN  BSTR  strValue
            );

        virtual HRESULT STDMETHODCALLTYPE createRequest(
            IN  LONG  Flags,
            IN  BSTR  strDNName,
            IN  BSTR  strUsage,
            OUT BSTR *pstrRequest    
            );

        virtual HRESULT STDMETHODCALLTYPE createFileRequest(
            IN  LONG  Flags,
            IN  BSTR  strDNName,
            IN  BSTR  strUsage,
            IN  BSTR  strRequestFileName
            );

        virtual HRESULT STDMETHODCALLTYPE acceptResponse(
            IN  BSTR  strResponse
            );

        virtual HRESULT STDMETHODCALLTYPE acceptFileResponse(
            IN  BSTR  strResponseFileName
            );

        virtual HRESULT STDMETHODCALLTYPE getCertFromResponse(
            IN  BSTR  strResponse,
            OUT BSTR *pstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE getCertFromFileResponse(
            IN  BSTR  strResponseFileName,
            OUT BSTR *pstrCert
            );

        virtual HRESULT STDMETHODCALLTYPE createPFX(
            IN  BSTR  strPassword,
            OUT BSTR *pstrPFX
            );

        virtual HRESULT STDMETHODCALLTYPE createFilePFX(
            IN  BSTR  strPassword,
            IN  BSTR  strPFXFileName
            );

        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfo(
            IN  LONG  lRequestID,
            IN  BSTR  strCADNS,
            IN  BSTR  strCAName,
            IN  BSTR  strFriendlyName
            );

        virtual HRESULT STDMETHODCALLTYPE enumPendingRequest(
            IN  LONG  lIndex,
            IN  LONG  lDesiredProperty,
            OUT VARIANT *pvarProperty
            );

        virtual HRESULT STDMETHODCALLTYPE removePendingRequest(
            IN  BSTR  strThumbprint
            );

        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Ex(
            IN  BSTR        PKCS7,
            OUT LONG __RPC_FAR *plCertInstalled
            );

        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificate(
            IN  LONG   lPropertyId,
            IN  LONG   lFlags,
            IN  BSTR   strProperty
        );
        virtual HRESULT STDMETHODCALLTYPE put_SignerCertificate(
            IN  BSTR  bstrCert
            );

//IEnroll4

        virtual HRESULT STDMETHODCALLTYPE SetPrivateKeyArchiveCertificate(
	        IN PCCERT_CONTEXT  pPrivateKeyArchiveCert
            );
    		
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE GetPrivateKeyArchiveCertificate(
            void
            );
    
        virtual HRESULT STDMETHODCALLTYPE binaryBlobToString(
            IN   LONG               Flags,
            IN   PCRYPT_DATA_BLOB   pblobBinary,
            OUT  LPWSTR            *ppwszString
            );

        virtual HRESULT STDMETHODCALLTYPE stringToBinaryBlob(
            IN   LONG               Flags,
            IN   LPCWSTR            pwszString,
            OUT  PCRYPT_DATA_BLOB   pblobBinary,
            OUT  LONG              *pdwSkip,
            OUT  LONG              *pdwFlags
            );

        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequestWStr(
            IN   LONG               Flags,
            IN   LPCWSTR            pwszName,
            IN   PCRYPT_DATA_BLOB   pblobValue
            );

        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequestWStr(
            IN   LONG               Flags,
            IN   LPCWSTR            pwszName,
            IN   PCRYPT_DATA_BLOB   pblobValue
            );

        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequestWStr(
            IN   LONG         Flags,
            IN   LPCWSTR      pwszName,
            IN   LPCWSTR      pwszValue
            );

        virtual HRESULT STDMETHODCALLTYPE createRequestWStr(
            IN   LONG              Flags,
            IN   LPCWSTR           pwszDNName,
            IN   LPCWSTR           pwszUsage,
            OUT  PCRYPT_DATA_BLOB  pblobRequest
            );

        virtual HRESULT STDMETHODCALLTYPE createFileRequestWStr(
            IN   LONG        Flags,
            IN   LPCWSTR     pwszDNName,
            IN   LPCWSTR     pwszUsage,
            IN   LPCWSTR     pwszRequestFileName
            );

        virtual HRESULT STDMETHODCALLTYPE acceptResponseBlob(
            IN   PCRYPT_DATA_BLOB   pblobResponse
            );

        virtual HRESULT STDMETHODCALLTYPE acceptFileResponseWStr(
            IN   LPCWSTR     pwszResponseFileName
            );

        virtual HRESULT STDMETHODCALLTYPE getCertContextFromResponseBlob(
            IN   PCRYPT_DATA_BLOB   pblobResponse,
            OUT  PCCERT_CONTEXT    *ppCertContext
            );

        virtual HRESULT STDMETHODCALLTYPE getCertContextFromFileResponseWStr(
            IN   LPCWSTR          pwszResponseFileName,
            OUT  PCCERT_CONTEXT  *ppCertContext
            );

        virtual HRESULT STDMETHODCALLTYPE createPFXWStr(
            IN   LPCWSTR           pwszPassword,
            OUT  PCRYPT_DATA_BLOB  pblobPFX
            );

        virtual HRESULT STDMETHODCALLTYPE createFilePFXWStr(
            IN   LPCWSTR     pwszPassword,
            IN   LPCWSTR     pwszPFXFileName
            );

        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfoWStr(
            IN   LONG     lRequestID,
            IN   LPCWSTR  pwszCADNS,
            IN   LPCWSTR  pwszCAName,
            IN   LPCWSTR  pwszFriendlyName
            );

        virtual HRESULT STDMETHODCALLTYPE removePendingRequestWStr(
            IN  CRYPT_DATA_BLOB thumbPrintBlob
            );

        virtual HRESULT STDMETHODCALLTYPE enumPendingRequestWStr(
            IN  LONG  lIndex,
            IN  LONG  lDesiredProperty,
            OUT LPVOID ppProperty
            );


        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7BlobEx( 
            IN PCRYPT_DATA_BLOB pBlobPKCS7,
            OPTIONAL OUT LONG  *plCertInstalled);

        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequestEx( 
            IN  LONG            lType,
            IN  BSTR            bstrOIDOrName,
            IN  LONG            lMajorVersion,
            IN  BOOL            fMinorVersion,
            IN  LONG            lMinorVersion
            );
            
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStrEx( 
            IN  LONG            lType,
            IN  LPCWSTR         pwszOIDOrName,
            IN  LONG            lMajorVersion,
            IN  BOOL            fMinorVersion,
            IN  LONG            lMinorVersion
            );

        virtual HRESULT STDMETHODCALLTYPE getProviderType(
            IN  BSTR            strProvName,
            OUT LONG           *lpProvType
            );

        virtual HRESULT STDMETHODCALLTYPE getProviderTypeWStr(
            IN  LPCWSTR         pwszProvName,
            OUT LONG           *lpProvType
            );

        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificateWStr(
            IN  LONG               lPropertyId,
            IN  LONG               lFlags,
            IN  PCRYPT_DATA_BLOB   pBlobProperty
        );

        virtual HRESULT STDMETHODCALLTYPE SetSignerCertificate(
	        IN PCCERT_CONTEXT  pSignerCert
            );
    		
        
//both ICEnroll4 and IEnroll4
        virtual HRESULT STDMETHODCALLTYPE resetExtensions(
            void
            );

        virtual HRESULT STDMETHODCALLTYPE resetAttributes(
            void
            );

        virtual HRESULT STDMETHODCALLTYPE resetBlobProperties(
            void
            );

        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx(
            IN  LONG    lSizeSpec,
            IN  LONG    lKeySpec,
            OUT LONG __RPC_FAR *plKeySize
            );

        virtual HRESULT STDMETHODCALLTYPE get_ClientId( 
            OUT LONG __RPC_FAR *plClientId);
        
        virtual HRESULT STDMETHODCALLTYPE put_ClientId( 
            IN  LONG lClientId);
        
        virtual HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            OUT BOOL __RPC_FAR *pfInclude);
        
        virtual HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            IN  BOOL lfInclude);
        
 private:

        HRESULT Init(void);
        void Destruct(void);

		HCERTSTORE GetStore(
			StoreType storeType
			);
			
		void FlushStore(
			StoreType storeType
			);
			
		HCRYPTPROV GetProv(
			DWORD dwFlags
			);
			
		BOOL SetKeyParams(
    		PCRYPT_KEY_PROV_INFO pKeyProvInfo
    		);

        HRESULT AddCertsToStores(
            HCERTSTORE    hStoreMsg,
            LONG         *plCertInstalled
            );

		HRESULT GetEndEntityCert(
		    PCRYPT_DATA_BLOB    pBlobPKCS7,
		    BOOL                fSaveToStores,
		    PCCERT_CONTEXT     *ppCert
		    );

        HRESULT BStringToFile(
            IN BSTR         bString,
            IN LPCWSTR      pwszFileName);

        HRESULT BlobToBstring(
            IN   CRYPT_DATA_BLOB   *pBlob,
            IN   DWORD              dwFlag,
            OUT  BSTR              *pBString);

        HRESULT BstringToBlob(
            IN  BSTR              bString,
            OUT CRYPT_DATA_BLOB  *pBlob);

        HRESULT GetCertFromResponseBlobToBStr(
            IN  CRYPT_DATA_BLOB  *pBlobResponse,
            OUT BSTR             *pstrCert);

		HRESULT createPKCS10WStrBStr( 
            LPCWSTR DNName,
            LPCWSTR wszPurpose,
            BSTR __RPC_FAR *pPKCS10);

		HRESULT createPFXWStrBStr( 
            IN  LPCWSTR         pwszPassword,
            OUT BSTR __RPC_FAR *pbstrPFX);

        HRESULT createRequestWStrBStr(
            IN   LONG              Flags,
            IN   LPCWSTR           pwszDNName,
            IN   LPCWSTR           pwszUsage,
            IN   DWORD             dwFlag,
            OUT  BSTR __RPC_FAR   *pbstrRequest);

       	BOOL GetCapiHashAndSigAlgId(ALG_ID rgAlg[2]);
       	
       	DWORD GetKeySizeInfo(
            LONG    lKeySizeSpec,
            DWORD   algClass
            );

        HRESULT GetKeyArchivePKCS7(CRYPT_ATTR_BLOB *pBlobKeyArchivePKCS7);

        BOOL CopyAndPushStackExtension(PCERT_EXTENSION pExt, BOOL fNewRequestMethod);
        PCERT_EXTENSION PopStackExtension(BOOL fNewRequestMethod);
        DWORD CountStackExtension(BOOL fNewRequestMethod);
        void FreeStackExtension(PCERT_EXTENSION pExt);
        PCERT_EXTENSION EnumStackExtension(PCERT_EXTENSION pExtLast, BOOL fNewRequestMethod);
        void FreeAllStackExtension(void);
 
        BOOL CopyAndPushStackAttribute(PCRYPT_ATTRIBUTE pAttr, BOOL fNewRequestMethod);
        PCRYPT_ATTRIBUTE PopStackAttribute(BOOL fNewRequestMethod);
        DWORD CountStackAttribute(BOOL fNewRequestMethod);
        void FreeStackAttribute(PCRYPT_ATTRIBUTE pAttr);
        PCRYPT_ATTRIBUTE EnumStackAttribute(PCRYPT_ATTRIBUTE pAttrLast, BOOL fNewRequestMethod);
        void FreeAllStackAttribute(void);

        HANDLE CreateOpenFileSafely(
            LPCWSTR wsz,
            BOOL    fCreate);
        HANDLE CreateFileSafely(
            LPCWSTR wsz);
        HANDLE OpenFileSafely(
            LPCWSTR wsz);
        HANDLE CreateOpenFileSafely2(
            LPCWSTR wsz,
            DWORD idsCreate,
            DWORD idsOverwrite);
        BOOL fIsRequestStoreSafeForScripting(void);

        HRESULT
        xeStringToBinaryFromFile(
            IN  WCHAR const *pwszfn,
            OUT BYTE       **ppbOut,
            OUT DWORD       *pcbOut,
            IN  DWORD        Flags);

        HRESULT PKCS7ToCert(IN   HCERTSTORE        hCertStore,
			    IN   CRYPT_DATA_BLOB   pkcs10Blob, 
			    OUT  PCCERT_CONTEXT   *ppCertContext);

        HRESULT PKCS10ToCert(IN   HCERTSTORE        hCertStore,
			     IN   CRYPT_DATA_BLOB   pkcs10Blob, 
			     OUT  PCCERT_CONTEXT   *ppCertContext);

        PPROP_STACK EnumStackProperty(PPROP_STACK pProp);
 
        HRESULT GetGoodCertContext(
            IN PCCERT_CONTEXT pCertContext,
            OUT PCCERT_CONTEXT *ppGoodCertContext);

        HRESULT GetVerifyProv();

private:


	PCCERT_CONTEXT			m_PrivateKeyArchiveCertificate;
	PCCERT_CONTEXT			m_pCertContextRenewal;
	PCCERT_CONTEXT			m_pCertContextSigner;
	PCCERT_CONTEXT			m_pCertContextStatic;

	PendingRequestTable            *m_pPendingRequestTable; 
	
	// The cert last created through createPKCS10().  This is used as the target
	// of setPendingRequestInfo() if no other target is specified by the client. 
	PCCERT_CONTEXT                  m_pCertContextPendingRequest; 

	// The HASH of the current request created with the xenroll instance. 
	// This value is set through the put_ThumbPrint() method, and is used to 
	// determine the target cert of the setPendingRequestInfo() operation. 
	// If this value is not set through the put_ThumbPrint() method, it will be 
	// NULL, and m_pCertContextPendingRequest will contain the target cert.  
	CRYPT_DATA_BLOB                 m_hashBlobPendingRequest; 
	
	// Used to keep track of last enumerated element in enumPendingRequestWStr
	PCCERT_CONTEXT                  m_pCertContextLastEnumerated; 
	DWORD                           m_dwCurrentPendingRequestIndex; 

	BYTE                    m_arHashBytesNewCert[20];
	BYTE                    m_arHashBytesOldCert[20];
	BOOL                    m_fArchiveOldCert;
	CRYPT_KEY_PROV_INFO		m_keyProvInfo;
	HCRYPTPROV				m_hProv;
	HCRYPTPROV				m_hVerifyProv;
	CRITICAL_SECTION		m_csXEnroll;
	BOOL					m_fWriteCertToUserDS;
	BOOL					m_fWriteCertToUserDSModified;
	BOOL					m_fWriteCertToCSP;
	BOOL					m_fWriteCertToCSPModified;
	BOOL					m_fDeleteRequestCert;
	BOOL					m_fUseExistingKey;
	BOOL					m_fMyStoreOpenFlagsModified;
	BOOL					m_fCAStoreOpenFlagsModified;
	BOOL					m_fRootStoreOpenFlagsModified;
	BOOL					m_fRequestStoreOpenFlagsModified;
	BOOL                    m_fReuseHardwareKeyIfUnableToGenNew;
	BOOL                    m_fLimitExchangeKeyToEncipherment;
	BOOL                    m_fEnableSMIMECapabilities;
	BOOL                    m_fSMIMESetByClient;
	BOOL                    m_fKeySpecSetByClient;
	DWORD					m_dwT61DNEncoding;
    DWORD                   m_dwEnabledSafteyOptions;
	DWORD					m_dwGenKeyFlags;
	STOREINFO				m_MyStore;
	STOREINFO				m_CAStore;
	STOREINFO				m_RootStore;
	STOREINFO				m_RequestStore;
	LPWSTR					m_wszSPCFileName;
	LPWSTR					m_wszPVKFileName;
	DWORD					m_HashAlgId;

	PEXT_STACK				m_pExtStack;
	DWORD					m_cExtStack;
	PATTR_STACK				m_pAttrStack;
	DWORD					m_cAttrStack;

    PEXT_STACK              m_pExtStackNew;
	DWORD					m_cExtStackNew;
	PATTR_STACK				m_pAttrStackNew;
	DWORD					m_cAttrStackNew;
    BOOL                    m_fNewRequestMethod;
    BOOL                    m_fHonorRenew;
    BOOL                    m_fOID_V2;
    HCRYPTKEY               m_hCachedKey;
    BOOL                    m_fUseClientKeyUsage;
    BOOL                    m_fCMCFormat;
	PPROP_STACK             m_pPropStack;
	DWORD                   m_cPropStack;
    LONG                    m_lClientId;
    BOOL                    m_fOpenConfirmed;
    DWORD                   m_dwLastAlgIndex;
    BOOL                    m_fIncludeSubjectKeyID;
    BOOL                    m_fHonorIncludeSubjectKeyID;
    PCERT_PUBLIC_KEY_INFO   m_pPublicKeyInfo;
	CRYPT_HASH_BLOB         m_blobResponseKAHash;
    DWORD                   m_dwSigKeyLenMax;
    DWORD                   m_dwSigKeyLenMin;
    DWORD                   m_dwSigKeyLenDef;
    DWORD                   m_dwSigKeyLenInc;
    DWORD                   m_dwXhgKeyLenMax;
    DWORD                   m_dwXhgKeyLenMin;
    DWORD                   m_dwXhgKeyLenDef;
    DWORD                   m_dwXhgKeyLenInc;
};

BOOL GetSignatureFromHPROV(
                           IN HCRYPTPROV hProv,
                           OUT BYTE **ppbSignature,
                           DWORD *pcbSignature
                           );

PCCERT_CONTEXT
WINAPI
MyCertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    ) ;

BOOL
WINAPI
MyCryptQueryObject(DWORD                dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext);

BOOL
WINAPI
MyCertStrToNameW(
    IN DWORD                dwCertEncodingType,
    IN LPCWSTR              pwszX500,
    IN DWORD                dwStrType,
    IN OPTIONAL void *      pvReserved,
    OUT BYTE *              pbEncoded,
    IN OUT DWORD *          pcbEncoded,
    OUT OPTIONAL LPCWSTR *  ppwszError
    );

BOOL
WINAPI
MyCryptVerifyMessageSignature
(IN            PCRYPT_VERIFY_MESSAGE_PARA   pVerifyPara,
 IN            DWORD                        dwSignerIndex,
 IN            BYTE const                  *pbSignedBlob,
 IN            DWORD                        cbSignedBlob,
 OUT           BYTE                        *pbDecoded,
 IN OUT        DWORD                       *pcbDecoded,
 OUT OPTIONAL  PCCERT_CONTEXT              *ppSignerCert);


extern "C" BOOL WINAPI InitIE302UpdThunks(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);


BOOL
MyCryptStringToBinaryA(
    IN     LPCSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    );

BOOL
MyCryptStringToBinaryW(
    IN     LPCWSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    );

BOOL
MyCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPSTR      pszString,
    IN OUT DWORD       *pcchString
    );

BOOL
MyCryptBinaryToStringW(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPWSTR      pszString,
    IN OUT DWORD       *pcchString
    );

HRESULT
xeLoadRCString(
    HINSTANCE      hInstance,
    IN int         iRCId,
    OUT WCHAR    **ppwsz);

#endif //__CENROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\crtstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crtstr.cpp
//
//--------------------------------------------------------------------------

#if !DBG

// Only build for retail

#include "windows.h"
#include "malloc.h"


int __cdecl _wcsicmp(const wchar_t * wsz1, const wchar_t * wsz2)
//
// REVIEW: Who calls this function, and should they be doing so?
//
// Return:
//       <0 if wsz1 < wsz2
//        0 if wsz1 = wsz2
//       >0 if wsz1 > wsz2
{
    //
    // Convert to multibyte and let the system do it
    //
    int cch1 = lstrlenW(wsz1);
    int cch2 = lstrlenW(wsz2);
    int cb1 = (cch1+1) * sizeof(WCHAR);
    int cb2 = (cch2+1) * sizeof(WCHAR);
    char* sz1= NULL;
    char* sz2= NULL;

    __try {

    sz1= (char*) _alloca(cb1);
    sz2= (char*) _alloca(cb2);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //xiaohs: We return a non-zero value to
        //signal a falture case because all the calls to this
        //function compare the return value with 0
        SetLastError(GetExceptionCode());
        return -1;
    }

    WideCharToMultiByte(CP_ACP, 0, wsz1, -1, sz1, cb1, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, wsz2, -1, sz2, cb2, NULL, NULL);

    return lstrcmpiA(sz1, sz2);
}

#endif // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\makefile.inc ===
xenroll_i.c : $(PROJECT_ROOT)\published\xenroll\xenroll_i.c
    copy $** $@

$(O)\xenroll.tlb : $(PROJECT_ROOT)\published\xenroll\$(O)\xenroll.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\getsig.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : getsig.cpp                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  5 1998 jeffspel                                                //
//                                                                         //
//  Copyright (C) Microsoft Corporation, 1996 - 1999All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>

// designatred resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   "#666"      

/*++

GetCryptSigResourcePtr:

    Given hInst, allocs and returns pointers to signature pulled from
    resource

Arguments:

    IN  hInst - Handle to the loaded file
    OUT ppbRsrcSig - Signature from the resource
    OUT pcbRsrcSig- Length of the signature from the resource

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL GetCryptSigResourcePtr(
                            HMODULE hInst,
                            BYTE **ppbRsrcSig,
                            DWORD *pcbRsrcSig
                            )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResource(hInst, CRYPT_SIG_RESOURCE_NUMBER,
                                      RT_RCDATA)))
        goto Ret;
    
    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcSig = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcSig = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

/*++

GetCryptSignatureResource:

    Gets the signature from the file resource.

Arguments:

    IN  szFile - Name of the file to get the signature from
    OUT ppbSignature - Signature of the specified provider
    OUT pcbSignature- Length of the signature of the specified provider

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL GetCryptSignatureResource(
                               IN LPCSTR pszFile,
                               OUT BYTE **ppbSig,
                               OUT DWORD *pcbSig
                               )
{
    HMODULE hInst = NULL;
    BYTE    *pbSig;
    DWORD   cbTemp = 0;
    LPSTR   pszDest = NULL;
    DWORD   cbSig;
    BOOL    fRet = FALSE;

    // expand the path if necessary
    if (0 == (cbTemp = ExpandEnvironmentStrings(pszFile, (CHAR *) &pszDest,
                                                cbTemp)))
    {
        goto Ret;
    }
    if (NULL == (pszDest = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                             (UINT)cbTemp)))
    {
        goto Ret;
    }
    if (0 == (cbTemp = ExpandEnvironmentStrings(pszFile, pszDest,
                                                cbTemp)))
    {
        goto Ret;
    }

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszDest, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        goto Ret;
    }
    if (!GetCryptSigResourcePtr(hInst, &pbSig, &cbSig))
    {
        goto Ret;
    }

    *pcbSig = cbSig - (sizeof(DWORD) * 2);
    if (NULL == (*ppbSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbSig)))
        goto Ret;

    memcpy(*ppbSig, pbSig + (sizeof(DWORD) * 2), *pcbSig);

    fRet = TRUE;
Ret:
    if (pszDest)
        LocalFree(pszDest);
    if (hInst)
        FreeLibrary(hInst);
    return fRet;
}

#define PROV_INITIAL_REG_PATH  "Software\\Microsoft\\Cryptography\\Defaults\\Provider\\"

/*++

CheckForSignatureInRegistry:

    Check if signature is in the registry, if so then get it
    if it isn't then get the filename for the provider

Arguments:

    IN  hProv - Handle to the provider to get the signature of
    OUT ppbSignature - Signature of the specified provider if in registry
    OUT pcbSignature - Length of the signature of the specified provider
                       if in the registry
    OUT pszProvFile - Provider file name if signature is not in registry
    OUT pfSigInReg - TRUE if signature is in the registry

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL CheckForSignatureInRegistry(
                                 IN HCRYPTPROV hProv,
                                 OUT BYTE **ppbSignature,
                                 OUT DWORD *pcbSignature,
                                 OUT LPSTR *ppszProvFile,
                                 OUT BOOL *pfSigInReg
                                 )
{
    HKEY    hRegKey = 0;
    LPSTR   pszProvName = NULL;
    DWORD   cbProvName;
    LPSTR   pszFullRegPath = NULL;
    DWORD   cbFullRegPath;
    DWORD   dwType;
    DWORD   cbData;
    BOOL    fRet = FALSE;

    *pfSigInReg = TRUE;

    // get the provider name
    if (!CryptGetProvParam(hProv, PP_NAME, NULL, &cbProvName, 0))
        goto Ret;
    if (NULL == (pszProvName = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbProvName)))
        goto Ret;
    if (!CryptGetProvParam(hProv, PP_NAME, (BYTE*)pszProvName,
                           &cbProvName, 0))
    {
        goto Ret;
    }

    // open the registry key of the provider
    cbFullRegPath = sizeof(PROV_INITIAL_REG_PATH) + strlen(pszProvName) + 1;
    if (NULL == (pszFullRegPath = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                                    cbFullRegPath)))
    {
        goto Ret;
    }
    strcpy(pszFullRegPath, PROV_INITIAL_REG_PATH);
    strcat(pszFullRegPath, pszProvName);
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      pszFullRegPath, 0,
                                      KEY_READ, &hRegKey))
        goto Ret; 

    // Check if SigInFile entry is there
    // NOTE : this may change in the next couple weeks
    if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, "SigInFile", NULL, &dwType,
                                         NULL, &cbData))
    {
        // get the file name
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Image Path",
                                             NULL, &dwType,
                                             NULL, &cbData))
            goto Ret;
        if (NULL == (*ppszProvFile = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbData)))
            goto Ret;
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Image Path",
                                             NULL, &dwType,
                                             (BYTE*)*ppszProvFile, &cbData))
            goto Ret;

        *pfSigInReg = FALSE;
    }
    else
    {
        // get signature from registry
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Signature",
                                             NULL, &dwType,
                                             NULL, pcbSignature))
            goto Ret;
        if (NULL == (*ppbSignature = (BYTE*)LocalAlloc(LMEM_ZEROINIT,
                                                       *pcbSignature)))
            goto Ret;
        if (ERROR_SUCCESS != RegQueryValueEx(hRegKey, "Signature",
                                             NULL, &dwType,
                                             *ppbSignature, pcbSignature))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pszProvName)
        LocalFree(pszProvName);
    if (pszFullRegPath)
        LocalFree(pszFullRegPath);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return fRet;
}

/*++

GetSignatureFromHPROV:

    Gets the signature of a provider associated with the passed in
    HCRYPTPROV.

Arguments:

    IN  hProv - Handle to the provider to get the signature of
    OUT ppbSignature - Signature of the specified provider
    OUT pcbSignature- Length of the signature of the specified provider

Return Value:

    TRUE - Success
    FALSE - Error

--*/
BOOL GetSignatureFromHPROV(
                           IN HCRYPTPROV hProv,
                           OUT BYTE **ppbSignature,
                           DWORD *pcbSignature
                           )
{
    LPSTR   pszProvFile = NULL;
    BOOL    fSigInReg;
    BOOL    fRet = FALSE;

    // Check if signature is in the registry, if so then get it
    // if it isn't then get the filename for the provider
    if (!CheckForSignatureInRegistry(hProv, ppbSignature, pcbSignature,
                                     &pszProvFile, &fSigInReg))
        goto Ret;

    if (!fSigInReg)
    {
        //
        // Get the signature from the resource in the file
        //

        if (!GetCryptSignatureResource(pszProvFile, ppbSignature,
                                       pcbSignature))
        {
            goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    if (pszProvFile)
        LocalFree(pszProvFile);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\cenroll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cenroll.cpp
//
//--------------------------------------------------------------------------

// CEnroll.cpp : Implementation of CCEnroll


#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include <pvk.h>
#include <wintrust.h>
#include <xasn.h>
#include <autoenr.h>

#include "xenroll.h"
#include "cenroll.h"
#include "xelib.h"

#define NO_OSS_DEBUG
#include <dbgdef.h>

#include <string.h>

#include <assert.h>

static LPVOID (* MyCoTaskMemAlloc)(ULONG) = NULL;
static LPVOID (* MyCoTaskMemRealloc)(LPVOID, ULONG) = NULL;
static void (* MyCoTaskMemFree)(LPVOID) = NULL;

#define MY_HRESULT_FROM_WIN32(a) ((a >= 0x80000000) ? a : HRESULT_FROM_WIN32(a))

#ifndef NTE_TOKEN_KEYSET_STORAGE_FULL
#define NTE_TOKEN_KEYSET_STORAGE_FULL _HRESULT_TYPEDEF_(0x80090023L)
#endif

#define CEnrollLocalScope(ScopeName) struct ScopeName##TheLocalScope { public
#define CEnrollEndLocalScope } local

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))



static LPSTR MBFromWide(LPCWSTR wsz) {

    LPSTR   sz = NULL;
    DWORD   cb = 0;

    assert(wsz != NULL);
    if(wsz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if( (cb = WideCharToMultiByte(0, 0, wsz, -1, NULL, 0, NULL, NULL)) == 0   ||
        (sz = (char *) MyCoTaskMemAlloc(cb)) == NULL  ||
        (cb = WideCharToMultiByte(0, 0, wsz, -1, sz, cb, NULL, NULL)) == 0 ) {

        if(GetLastError() == ERROR_SUCCESS)
            SetLastError(ERROR_OUTOFMEMORY);

        return(NULL);
    }

    return(sz);
}

static LPWSTR WideFromMB(LPCSTR sz) {

    BSTR    bstr    = NULL;
    DWORD   cch     = 0;
    LPWSTR  wsz     = NULL;

    assert(sz != NULL);
    if(sz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if( (cch = MultiByteToWideChar(0, 0, sz, -1, NULL, 0)) == 0   ||
        (wsz = (WCHAR *) MyCoTaskMemAlloc(cch * sizeof(WCHAR))) == NULL  ||
        (cch = MultiByteToWideChar(0, 0, sz, -1, wsz, cch)) == 0) {

        if(GetLastError() == ERROR_SUCCESS)
            SetLastError(ERROR_OUTOFMEMORY);

        return(NULL);
    }

    return(wsz);
}

static BSTR
BSTRFromMB(LPCSTR sz)
{
    BSTR    bstr    = NULL;
    DWORD   cch     = 0;
    WCHAR  *pwsz     = NULL;
    BOOL    fFail = FALSE;

    assert(sz != NULL);
    if(sz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
 
    while (TRUE)
    {
        if(0 == (cch = MultiByteToWideChar(0, 0, sz, -1, pwsz, cch)))
        {
            //error
            fFail = TRUE;
            break;
        }
        if (NULL != pwsz)
        {
            //done
            break;
        }
        pwsz = (WCHAR *)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            //error
            if(GetLastError() == ERROR_SUCCESS)
                SetLastError(ERROR_OUTOFMEMORY);
            break;
        }
    }

    if (!fFail && NULL != pwsz)
    {
        bstr = SysAllocString(pwsz);
        if (NULL == bstr)
        {
            if(GetLastError() == ERROR_SUCCESS)
                SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return(bstr);
}

static LPWSTR CopyWideString(LPCWSTR wsz) {

    DWORD   cch     = 0;
    LPWSTR  wszOut  = NULL;

    // shouldn't send in a NULL
    assert(wsz != NULL);
    if(wsz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    cch = wcslen(wsz) + 1;

    if( (wszOut = (LPWSTR) MyCoTaskMemAlloc(sizeof(WCHAR) * cch)) == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    wcscpy(wszOut, wsz);

    return(wszOut);
}

static LPSTR CopyAsciiString(LPCSTR sz) {

    DWORD   cch     = 0;
    LPSTR   szOut   = NULL;

    // shouldn't send in a NULL
    assert(sz != NULL);
    if(sz == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    cch = strlen(sz) + 1;

    if( (szOut = (LPSTR) MyCoTaskMemAlloc(cch)) == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    strcpy(szOut, sz);

    return(szOut);
}

static DWORD KeyLocationFromStoreLocation(DWORD dwStoreFlags) {

    if(
        ((CERT_SYSTEM_STORE_LOCATION_MASK & dwStoreFlags) == CERT_SYSTEM_STORE_CURRENT_USER) ||
        ((CERT_SYSTEM_STORE_LOCATION_MASK & dwStoreFlags) == CERT_SYSTEM_STORE_USERS) ||
        ((CERT_SYSTEM_STORE_LOCATION_MASK & dwStoreFlags) == CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY)
      ) {
        return(0);
    }

    // CERT_SYSTEM_STORE_LOCAL_MACHINE
    // CERT_SYSTEM_STORE_DOMAIN_POLICY
    // CERT_SYSTEM_STORE_CURRENT_SERVICE
    // CERT_SYSTEM_STORE_SERVICES
    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY

    return(CRYPT_MACHINE_KEYSET);
}

//modified from myLoadRCString from ca
HRESULT
xeLoadRCString(
    IN HINSTANCE   hInstance,
    IN int         iRCId,
    OUT WCHAR    **ppwsz)
{
#define REALLOCATEBLOCK 256
    HRESULT   hr;
    WCHAR    *pwszTemp = NULL;
    int       sizeTemp;
    int       size = 0;
    int       cBlocks = 1;

    *ppwsz = NULL;

    while (NULL == pwszTemp)
    {
        sizeTemp = cBlocks * REALLOCATEBLOCK;
        pwszTemp = (WCHAR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                        sizeTemp * sizeof(WCHAR));
        if (NULL == pwszTemp)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }

        size = LoadStringU(
                   hInstance,
                   iRCId,
                   pwszTemp,
                   sizeTemp);
        if (0 == size)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto LoadStringError;
        }

        if (size < sizeTemp - 1)
        {
            // ok, size is big enough
            break;
        }
        ++cBlocks;
        LocalFree(pwszTemp);
        pwszTemp = NULL;
    }

    *ppwsz = (WCHAR*) LocalAlloc(LPTR, (size+1) * sizeof(WCHAR));
    if (NULL == *ppwsz)
    {
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    }
    // copy it
    wcscpy(*ppwsz, pwszTemp);

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return hr;

TRACE_ERROR(LocalAllocError)
TRACE_ERROR(LoadStringError)
}

HANDLE CCEnroll::CreateOpenFileSafely2(
    LPCWSTR pwszFileName,
    DWORD   idsCreate,
    DWORD   idsOverwrite)
{
    HANDLE      hFile = NULL;
    WCHAR      *pwszMsg = NULL;
    WCHAR      *pwszFormat = NULL;
    WCHAR      *pwszTitle = NULL;
    WCHAR      *pwszSafety = NULL;
    DWORD       dwAttribs = 0;
    BOOL        fNotProperFile;
    
    LPCWSTR     apwszInsertArray[2];
    BOOL        fNo;
    BOOL        fMsgBox;
    int         idPrefix = IDS_NOTSAFE_WRITE_PREFIX; //default to write prefix
    BOOL        fCreate = (0xFFFFFFFF != idsCreate) &&
                          (0xFFFFFFFF != idsOverwrite);
    HRESULT hr;

    EnterCriticalSection(&m_csXEnroll);

    // by default, you do not need to throw ui for PVK
    // even in a safe for scripting environment.
    // this is because the pvk dialog is thrown.
    fMsgBox = (m_dwEnabledSafteyOptions != 0  &&  idsCreate != IDS_PVK_C);
    dwAttribs = GetFileAttributesU(pwszFileName);

    if(0xFFFFFFFF == dwAttribs)
    {
        //file doesn't exist
        if (!fCreate)
        {
            //try to read a non-existing file
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
        //if got here, write a new file
        if (fMsgBox)
        {
            hr = xeLoadRCString(hInstanceXEnroll, idsCreate, &pwszFormat);
            if (S_OK != hr)
            {
                goto xeLoadRCStringError;
            }
        }
    }
    else
    {
        //file exists, check if a proper file to write or read
        //in either write or read, the following file attrib not proper
        fNotProperFile = 
              (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ||
              (dwAttribs & FILE_ATTRIBUTE_HIDDEN)    ||
              (dwAttribs & FILE_ATTRIBUTE_SYSTEM);

        if (!fNotProperFile)
        {
            //so far so good
            if (fCreate)
            {
                //write a file
                if (0x0 != (dwAttribs & FILE_ATTRIBUTE_READONLY))
                {
                    //don't take read-only and archive
                    fNotProperFile = TRUE;
                }
                else
                {
                    //try to overwrite existing file
                    hr = xeLoadRCString(hInstanceXEnroll, idsOverwrite, &pwszFormat);
                    if (S_OK != hr)
                    {
                        goto xeLoadRCStringError;
                    }
                    //enforce popup if overwrite
                    fMsgBox = TRUE;
                }
            }
            else
            {
                //read a file
                if (!m_fOpenConfirmed)
                {
                    //read an existing file always violate scripting safety
                    //it allows detecting file existence
                    //put out a warning
                    fMsgBox = TRUE;
                    hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFE_OPEN, &pwszFormat);
                    if (S_OK != hr)
                    {
                        goto xeLoadRCStringError;
                    }
                    idPrefix = IDS_NOTSAFE_OPEN_PREFIX;
                }
            }
        }

        if (fNotProperFile)
        {
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
    }

    if (fMsgBox)
    {
        hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszTitle);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }
        hr = xeLoadRCString(hInstanceXEnroll, idPrefix, &pwszSafety);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }

        apwszInsertArray[0] = pwszSafety;
        apwszInsertArray[1] = pwszFileName;

        FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pwszFormat,
            0,
            0,
            (LPWSTR) &pwszMsg,
            0,
            (va_list *)apwszInsertArray);

        fNo = (MessageBoxU(
                    NULL,
                    pwszMsg,
                    pwszTitle,
                    MB_YESNO | MB_ICONWARNING) == IDNO);
                
        if(fNo)
        {
            SetLastError(ERROR_CANCELLED);
            goto CancelError;
        }

        //if got here, Yes is selected
        if (!fCreate && !m_fOpenConfirmed)
        {
            //this is the first time open ask and confirm YES
            //don't ask again
            m_fOpenConfirmed = TRUE;
        }
    }
    
    hFile = CreateFileU(
            pwszFileName,
            fCreate ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            fCreate ? CREATE_ALWAYS : OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE  ||  hFile == NULL)
    {
        //don't return system error so keep xenroll relative safe for scripting
        SetLastError(ERROR_ACCESS_DENIED);
        hFile = NULL;
        goto CreateFileUError;
    }

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);

    if(NULL != pwszMsg)
    {
        LocalFree(pwszMsg);
    }
    if(NULL != pwszFormat)
    {
        LocalFree(pwszFormat);
    }
    if(NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if(NULL != pwszSafety)
    {
        LocalFree(pwszSafety);
    }
    return(hFile);

TRACE_ERROR(CreateFileUError)
TRACE_ERROR(CancelError)
TRACE_ERROR(InvalidFileError)
TRACE_ERROR(xeLoadRCStringError)
}

HANDLE CCEnroll::CreateOpenFileSafely(
    LPCWSTR pwszFileName,
    BOOL    fCreate)
{
    HANDLE      hFile = NULL;
    WCHAR      *pwszMsg = NULL;
    DWORD       dwAttribs = 0;
    BOOL        fNotProperFile;
    
    WCHAR      *pwszFormat = NULL;
    WCHAR      *pwszTitle = NULL;
    LPCWSTR     apwszInsertArray[] = {pwszFileName};
    BOOL        fNo;
    BOOL        fMsgBox = TRUE;
    BOOL        fOverWrite = FALSE;
    HRESULT     hr;

    EnterCriticalSection(&m_csXEnroll);

#if 0
    if (fCreate)
    {
        fMsgBox = (0x0 != m_dwEnabledSafteyOptions);
    }
    else
    {
        fMsgBox = (!m_fOpenConfirmed && (0x0 != m_dwEnabledSafteyOptions));
    }
#endif
    if (!fCreate)
    {
        fMsgBox = !m_fOpenConfirmed;
    }

    dwAttribs = GetFileAttributesU(pwszFileName);

    if(0xFFFFFFFF == dwAttribs)
    {
        //file doesn't exist
        if (!fCreate)
        {
            //try to read a non-existing file
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
    }
    else
    {
        //file exists, check if a proper file to write or read
        //in either write or read, the following file attrib not proper
        fNotProperFile = 
              (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ||
              (dwAttribs & FILE_ATTRIBUTE_HIDDEN)    ||
              (dwAttribs & FILE_ATTRIBUTE_SYSTEM);

        if (!fNotProperFile)
        {
            //so far so good
            if (fCreate)
            {
                //write a file
                if (0x0 != (dwAttribs & FILE_ATTRIBUTE_READONLY))
                {
                    //don't take read-only and archive
                    fNotProperFile = TRUE;
                }
                else
                {
                    //try to overwrite existing file
                    fOverWrite = TRUE;
                }
            }
        }

        if (fNotProperFile)
        {
            //for safety reasons, don't return system error
            SetLastError(ERROR_ACCESS_DENIED);
            goto InvalidFileError;
        }
    }

    if (fMsgBox)
    {
        hr = xeLoadRCString(hInstanceXEnroll, IDS_CERTENROLL, &pwszTitle);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }
        hr = xeLoadRCString(
                hInstanceXEnroll,
                fCreate ? IDS_NOTSAFE_WRITE_FORMAT : IDS_NOTSAFE_OPEN_FORMAT,
                &pwszFormat);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }

        FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pwszFormat,
            0,
            0,
            (LPWSTR) &pwszMsg,
            0,
            (va_list *)apwszInsertArray);

        fNo = (MessageBoxU(
                    NULL,
                    pwszMsg,
                    pwszTitle,
                    MB_YESNO | MB_ICONWARNING) == IDNO);
        if(fNo)
        {
            SetLastError(ERROR_CANCELLED);
            goto CancelError;
        }

        //if got here, Yes is selected
        if (!fCreate && !m_fOpenConfirmed)
        {
            //this is the first time open ask and confirm YES
            //don't ask again
            m_fOpenConfirmed = TRUE;
        }
    }

    if (fCreate && fOverWrite)
    {
        if (!fMsgBox)
        {
            hr = xeLoadRCString(hInstanceXEnroll, IDS_CERTENROLL, &pwszTitle);
            if (S_OK != hr)
            {
                goto xeLoadRCStringError;
            }
        }

        //popup overwrite confirmation
        hr = xeLoadRCString(hInstanceXEnroll, IDS_OVERWRITE_FORMAT, &pwszFormat);
        if (S_OK != hr)
        {
            goto xeLoadRCStringError;
        }

        //make sure free before alloc again
        if (NULL != pwszMsg)
        {
            LocalFree(pwszMsg);
            pwszMsg = NULL;
        }
        FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pwszFormat,
            0,
            0,
            (LPWSTR) &pwszMsg,
            0,
            (va_list *)apwszInsertArray);

        fNo = (MessageBoxU(
                    NULL,
                    pwszMsg,
                    pwszTitle,
                    MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) == IDNO);
        if(fNo)
        {
            SetLastError(ERROR_CANCELLED);
            goto CancelError;
        }
    }
    
    hFile = CreateFileU(
            pwszFileName,
            fCreate ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            fCreate ? CREATE_ALWAYS : OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE  ||  hFile == NULL)
    {
        //don't return system error so keep xenroll relative safe for scripting
        SetLastError(ERROR_ACCESS_DENIED);
        hFile = NULL;
        goto CreateFileUError;
    }

ErrorReturn:
    if(NULL != pwszMsg)
    {
        LocalFree(pwszMsg);
    }
    if(NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if(NULL != pwszFormat)
    {
        LocalFree(pwszFormat);
    }
    LeaveCriticalSection(&m_csXEnroll);

    return(hFile);

TRACE_ERROR(CreateFileUError)
TRACE_ERROR(CancelError)
TRACE_ERROR(InvalidFileError)
TRACE_ERROR(xeLoadRCStringError)
}

HANDLE CCEnroll::CreateFileSafely(
    LPCWSTR pwszFileName)
{
    return CreateOpenFileSafely(pwszFileName, TRUE); //write
}

HANDLE CCEnroll::OpenFileSafely(
    LPCWSTR pwszFileName)
{
    return CreateOpenFileSafely(pwszFileName, FALSE); //open
}

void DwordToWide(DWORD dw, LPWSTR lpwstr) {

    DWORD   i = 0;
    DWORD   j;
    WCHAR   wch;

    while(dw > 0) {
        j = dw % 10;
        dw /= 10;
        lpwstr[i++] = (WCHAR) (j + L'\0');
    }

    if( i == 0 )
        lpwstr[i++] = L'\0';

    lpwstr[i] = 0;

    for(j=0, i--; i > j; i--, j++) {
        wch = lpwstr[i];
        lpwstr[i] = lpwstr[j];
        lpwstr[j] = wch;
    }
}

//take a name value pair info and return encoded value
HRESULT
xeEncodeNameValuePair(
    IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValuePair,
    OUT BYTE                           **ppbData,
    OUT DWORD                           *pcbData)
{
    HRESULT hr = S_OK;

    //init
    *ppbData = NULL;
    *pcbData = 0;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                szOID_ENROLLMENT_NAME_VALUE_PAIR,
                pNameValuePair,
                *ppbData,
                pcbData))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }

        if (NULL != *ppbData)
        {
            break;
        }

        *ppbData = (BYTE*)MyCoTaskMemAlloc(*pcbData);
        if (NULL == *ppbData)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

error:
    if (S_OK != hr && NULL != *ppbData)
    {
        MyCoTaskMemFree(*ppbData);
    }
    return hr;
}

//convert wsz to sz and allocate mem
HRESULT
xeWSZToSZ(
    IN LPCWSTR    pwsz,
    OUT LPSTR    *ppsz)
{
    HRESULT hr = S_OK;
    LONG    cc = 0;

    //init
    *ppsz = NULL;

    while (TRUE)
    {
        cc = WideCharToMultiByte(
                    GetACP(),
                    0,
                    pwsz,
                    -1,
                    *ppsz,
                    cc,
                    NULL,
                    NULL);
        if (0 >= cc)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }

        if (NULL != *ppsz)
        {
            break;
        }
        *ppsz= (CHAR*)MyCoTaskMemAlloc(cc);
        if (NULL == *ppsz)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }
error:
    if (S_OK != hr && NULL != *ppsz)
    {
        MyCoTaskMemFree(*ppsz);
    }
    return hr;
}

//modified from DecodeFile on certsrv
HRESULT
CCEnroll::xeStringToBinaryFromFile(
    IN  WCHAR const *pwszfn,
    OUT BYTE       **ppbOut,
    OUT DWORD       *pcbOut,
    IN  DWORD        Flags)
{
    HANDLE hFile;
    HRESULT hr;
    CHAR *pchFile = NULL;
    BYTE *pbOut = NULL;
    DWORD cchFile;
    DWORD cbRead;
    DWORD cbOut = 0;

    hFile = OpenFileSafely(pwszfn);
    if (NULL == hFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto OpenFileSafelyError;
    }

    cchFile = GetFileSize(hFile, NULL);
    if ((DWORD) -1 == cchFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetFileSizeError;
    }

    pchFile = (CHAR *) LocalAlloc(LMEM_FIXED, cchFile);
    if (NULL == pchFile)
    {
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    }

    if (!ReadFile(hFile, pchFile, cchFile, &cbRead, NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto ReadFileError;
    }

    assert(cbRead <= cchFile);
    if (cbRead != cchFile)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
        goto ReadFileError;
    }

    if (CRYPT_STRING_BINARY == Flags)
    {
        pbOut = (BYTE *) pchFile;
        cbOut = cchFile;
        pchFile = NULL;
    }
    else
    {
        // Decode file contents.
        while (TRUE)
        {
            if (!MyCryptStringToBinaryA(
                        pchFile,
                        cchFile,
                        Flags,
                        pbOut,
                        &cbOut,
                        NULL,
                        NULL))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto CyrptStringToBinaryError;
            }
            if (NULL != pbOut)
            {
                //done
                break;
            }
            pbOut = (BYTE*)LocalAlloc(LMEM_FIXED, cbOut);
            if (NULL == pbOut)
            {
                hr = E_OUTOFMEMORY;
                goto LocalAllocError;
            }
        }
    }
    *pcbOut = cbOut;
    *ppbOut = pbOut;
    pbOut = NULL;

    hr = S_OK;
error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (NULL != pchFile)
    {
        LocalFree(pchFile);
    }
    if (NULL != pbOut)
    {
        LocalFree(pbOut);
    }
    return(hr);

ErrorReturn:
    goto error;

TRACE_ERROR(CyrptStringToBinaryError)
TRACE_ERROR(ReadFileError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(GetFileSizeError)
TRACE_ERROR(OpenFileSafelyError)
}

//following two functions handle some APIs not available
//in downlevel client crypt32.dll
typedef VOID
(WINAPI * PFNCertFreeCertificateChain)
   (IN PCCERT_CHAIN_CONTEXT pChainContext);

typedef BOOL
(WINAPI * PFNCertGetCertificateChain)
   (IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext);

typedef BOOL (WINAPI *PFNCertVerifyCertificateChainPolicy) (
  LPCSTR pszPolicyOID,
  PCCERT_CHAIN_CONTEXT pChainContext,
  PCERT_CHAIN_POLICY_PARA pPolicyPara,
  PCERT_CHAIN_POLICY_STATUS pPolicyStatus
);

typedef BOOL (*PFNCheckTokenMembership) (
  HANDLE TokenHandle,  // handle to access token
  PSID SidToCheck,     // SID
  PBOOL IsMember       // result
);

typedef BOOL (*PFNSetSecurityDescriptorControl) (
  PSECURITY_DESCRIPTOR pSecurityDescriptor,          // SD
  SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, // control bits
  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet       // new control bits
);

VOID
MyCertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    PFNCertFreeCertificateChain pfnCertFreeCertificateChain = NULL;
    HMODULE  hModule = NULL;

    hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCertFreeCertificateChain = (PFNCertFreeCertificateChain)
                GetProcAddress(hModule,
                               "CertFreeCertificateChain");
        if (NULL != pfnCertFreeCertificateChain)
        {
            pfnCertFreeCertificateChain(pChainContext);
        }
    }
}

BOOL
MyCertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    PFNCertGetCertificateChain pfnCertGetCertificateChain = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCertGetCertificateChain = (PFNCertGetCertificateChain)
                GetProcAddress(hModule,
                               "CertGetCertificateChain");
        if (NULL != pfnCertGetCertificateChain)
        {
            return pfnCertGetCertificateChain(
                hChainEngine,
                pCertContext,
                pTime,
                hAdditionalStore,
                pChainPara,
                dwFlags,
                pvReserved,
                ppChainContext);
        }
    }
    return FALSE;
}

BOOL
MyCertVerifyCertificateChainPolicy(
  LPCSTR pszPolicyOID,
  PCCERT_CHAIN_CONTEXT pChainContext,
  PCERT_CHAIN_POLICY_PARA pPolicyPara,
  PCERT_CHAIN_POLICY_STATUS pPolicyStatus
)
{
    PFNCertVerifyCertificateChainPolicy pfnCertVerifyCertificateChainPolicy = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("crypt32.dll");
    if (NULL != hModule)
    {
        pfnCertVerifyCertificateChainPolicy = (PFNCertVerifyCertificateChainPolicy)
                GetProcAddress(hModule,
                               "CertVerifyCertificateChainPolicy");
        if (NULL != pfnCertVerifyCertificateChainPolicy)
        {
            return pfnCertVerifyCertificateChainPolicy(
                            pszPolicyOID,
                            pChainContext,
                            pPolicyPara,
                            pPolicyStatus);
        }
    }
    return FALSE;
}

BOOL
MyCheckTokenMembership(
  HANDLE TokenHandle,  // handle to access token
  PSID SidToCheck,     // SID
  PBOOL IsMember       // result
)
{
    PFNCheckTokenMembership pfnCheckTokenMembership = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("advapi32.dll");
    if (NULL != hModule)
    {
        pfnCheckTokenMembership = (PFNCheckTokenMembership)
                GetProcAddress(hModule,
                               "CheckTokenMembership");
        if (NULL != pfnCheckTokenMembership)
        {
            return pfnCheckTokenMembership(
                        TokenHandle,
                        SidToCheck,
                        IsMember);
        }
    }
    return FALSE;
}

BOOL
MySetSecurityDescriptorControl(
  PSECURITY_DESCRIPTOR pSecurityDescriptor,          // SD
  SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, // control bits
  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet       // new control bits
)
{
    PFNSetSecurityDescriptorControl pfnSetSecurityDescriptorControl = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("advapi32.dll");
    if (NULL != hModule)
    {
        pfnSetSecurityDescriptorControl = (PFNSetSecurityDescriptorControl)
                GetProcAddress(hModule,
                               "SetSecurityDescriptorControl");
        if (NULL != pfnSetSecurityDescriptorControl)
        {
            return pfnSetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        ControlBitsOfInterest,
                        ControlBitsToSet);
        }
    }
    return FALSE;
}

HRESULT __stdcall CCEnroll::GetInterfaceSafetyOptions( 
            /* [in]  */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions) {

    RPC_STATUS rpcStatus;          

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    *pdwEnabledOptions   = m_dwEnabledSafteyOptions;
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;


    return(S_OK);
}

HRESULT __stdcall CCEnroll::SetInterfaceSafetyOptions( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions) {

    RPC_STATUS rpcStatus;          
    DWORD dwSupport = 0;            

    if(0 != UuidCompare((GUID *) &riid, (GUID *) &IID_IDispatch, &rpcStatus) )
        return(E_NOINTERFACE);

    dwSupport = dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);        
    if(dwSupport != 0)
        return(E_FAIL);

    m_dwEnabledSafteyOptions &= ~dwOptionSetMask;
    m_dwEnabledSafteyOptions |= dwEnabledOptions; 
            
return(S_OK);
}


HRESULT
CCEnroll::GetVerifyProv()
{
    HRESULT hr;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL == m_hVerifyProv)
    {
        if (!CryptAcquireContextU(
                    &m_hVerifyProv,
                    NULL,
                    m_keyProvInfo.pwszProvName,
                    m_keyProvInfo.dwProvType,
                    CRYPT_VERIFYCONTEXT))
        {
#if DBG
            assert(NULL == m_hVerifyProv);
#endif //DBG
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptAcquireContextUError;
        }
    }

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(CryptAcquireContextUError)
}

BOOL CCEnroll::GetCapiHashAndSigAlgId(ALG_ID rgAlg[2]) {


    DWORD   iHashBest       = 0;
    ALG_ID  arDefaultHash[] = {m_HashAlgId, CALG_SHA1, CALG_MD5};
    DWORD   cDefaultHash    = sizeof(arDefaultHash) / sizeof(DWORD);

    HCRYPTPROV  hProvU      = NULL;

    DWORD       dwFlags     = CRYPT_FIRST;

    DWORD       i;
    PROV_ENUMALGS               enumAlgs;
    DWORD       cb          = sizeof(enumAlgs);

    BOOL        fRet        = TRUE;

    rgAlg[0] = 0;
    rgAlg[1] = 0;

    EnterCriticalSection(&m_csXEnroll);

    // only get a prov if one wasn't passed in.
    if(m_hProv == NULL)
    {
        HRESULT hr;
        hr = GetVerifyProv();
        if (S_OK != hr)
        {
            goto GetVerifyProvError;
        }
        hProvU = m_hVerifyProv;
    }
    else
    {
        // otherwise use the current m_hProv, SCard only likes on
        // CryptAcquireContext to be used.
        hProvU = m_hProv;
    }

    cb = sizeof(enumAlgs);
    while( CryptGetProvParam(
        hProvU,
            PP_ENUMALGS,
        (BYTE *) &enumAlgs,
        &cb,
        dwFlags
        ) ) {

        cb = sizeof(enumAlgs);

        // not first pass anymore
        dwFlags = 0;

        // see if this is a hash alg
        if( ALG_CLASS_HASH == GET_ALG_CLASS(enumAlgs.aiAlgid) ) {

            // get things init with the first hash alg
            if(rgAlg[0] == 0) {
                rgAlg[0] = enumAlgs.aiAlgid;
                iHashBest = cDefaultHash;
            }

            // pick the best one
            for(i=0; i<iHashBest; i++) {

                if(arDefaultHash[i] == enumAlgs.aiAlgid) {
                    rgAlg[0] = enumAlgs.aiAlgid;
                    iHashBest   = i;
                    break;
                }
            }
        }

        // we will only pick up the first signature type
        // in general there is only 1 per csp (Ref: JeffSpel)
        else if( ALG_CLASS_SIGNATURE == GET_ALG_CLASS(enumAlgs.aiAlgid) ) {

            if(rgAlg[1] == 0)
                rgAlg[1] = enumAlgs.aiAlgid;
        }
    }

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);

    // some CSPs say they can't sign, but they really can
    // so if we have not hashalg or sigalg we will put a default
    // in and if the CSP really can't do it, it will error
    // this is for backwards compatibility

    // default hash to sha1
    if(rgAlg[0] == 0)
        rgAlg[0] = CALG_SHA1;

    // default sig to RSA
    if(rgAlg[1] == 0)
        rgAlg[1] = CALG_RSA_SIGN;

#if 0
    if(rgAlg[0] == 0 || rgAlg[1] == 0) {
        SetLastError(NTE_BAD_ALGID);
        fRet = FALSE;
    }
#endif

    return(fRet);

TRACE_ERROR(GetVerifyProvError)
}

BOOL CreatePvkProperty(
    CRYPT_KEY_PROV_INFO *pKeyProvInfo,
    PCRYPT_DATA_BLOB    pBlob)
{
    WCHAR   wszKeySpec[11];
    WCHAR   wszProvType[11];
    DWORD   cbContainer;
    DWORD   cbKeySpec;
    DWORD   cbProvType;
    DWORD   cbProvName;

    assert(pBlob != NULL);
    assert(pKeyProvInfo != NULL);

    // convert dwords to strings
    DwordToWide(pKeyProvInfo->dwKeySpec, wszKeySpec);
    DwordToWide(pKeyProvInfo->dwProvType, wszProvType);

    // get total length of string
    cbContainer = (wcslen(pKeyProvInfo->pwszContainerName) + 1) * sizeof(WCHAR);
    cbKeySpec   = (wcslen(wszKeySpec) + 1) * sizeof(WCHAR);
    cbProvType  = (wcslen(wszProvType) + 1) * sizeof(WCHAR);

    cbProvName  = (wcslen(pKeyProvInfo->pwszProvName) + 1) * sizeof(WCHAR);

    pBlob->cbData =
        cbContainer +
        cbKeySpec   +
        cbProvType  +
        cbProvName  +
        sizeof(WCHAR);

    // allocate the string
    if( (pBlob->pbData = (BYTE *) MyCoTaskMemAlloc(pBlob->cbData)) == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // copy the strings
    memset(pBlob->pbData, 0, pBlob->cbData);
    memcpy(pBlob->pbData, pKeyProvInfo->pwszContainerName, cbContainer);
    memcpy(&pBlob->pbData[cbContainer], wszKeySpec, cbKeySpec);
    memcpy(&pBlob->pbData[cbContainer + cbKeySpec], wszProvType, cbProvType);
    memcpy(&pBlob->pbData[cbContainer + cbKeySpec + cbProvType], pKeyProvInfo->pwszProvName, cbProvName);

    return(TRUE);
}

static LPWSTR wszEmpty      = L"";
static LPWSTR wszMY         = L"MY";
static LPWSTR wszCA         = L"CA";
static LPWSTR wszROOT       = L"ROOT";
static LPWSTR wszREQUEST    = L"REQUEST";
static LPSTR  szSystemStore = sz_CERT_STORE_PROV_SYSTEM;
// static LPSTR  szSystemStore = sz_CERT_STORE_PROV_SYSTEM_REGISTRY;
/////////////////////////////////////////////////////////////////////////////
// CCEnroll


CCEnroll::~CCEnroll(void) {
    Destruct();
    DeleteCriticalSection(&m_csXEnroll);
}

void CCEnroll::Destruct(void) {

    if(NULL != m_PrivateKeyArchiveCertificate)
    {
        CertFreeCertificateContext(m_PrivateKeyArchiveCertificate);
    }
    if(NULL != m_pCertContextSigner)
    {
        CertFreeCertificateContext(m_pCertContextSigner);
    }
    if(m_pCertContextRenewal != NULL)
        CertFreeCertificateContext(m_pCertContextRenewal);
    if(m_pCertContextStatic != NULL)
        CertFreeCertificateContext(m_pCertContextStatic);

    if(m_keyProvInfo.pwszContainerName != wszEmpty)
        MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);

    if(m_keyProvInfo.pwszProvName != wszEmpty)
        MyCoTaskMemFree(m_keyProvInfo.pwszProvName);

    if(m_MyStore.wszName != wszMY)
        MyCoTaskMemFree(m_MyStore.wszName);

    if(m_CAStore.wszName != wszCA)
        MyCoTaskMemFree(m_CAStore.wszName);

    if(m_RootStore.wszName != wszROOT)
        MyCoTaskMemFree(m_RootStore.wszName);

    if(m_RequestStore.wszName != wszREQUEST)
        MyCoTaskMemFree(m_RequestStore.wszName);

    if(m_MyStore.szType  != szSystemStore)
        MyCoTaskMemFree(m_MyStore.szType);

    if(m_CAStore.szType != szSystemStore)
        MyCoTaskMemFree(m_CAStore.szType);

    if(m_RootStore.szType != szSystemStore)
        MyCoTaskMemFree(m_RootStore.szType);

    if(m_RequestStore.szType != szSystemStore)
        MyCoTaskMemFree(m_RequestStore.szType);

    if(m_wszSPCFileName != wszEmpty)
        MyCoTaskMemFree(m_wszSPCFileName);

    if(m_wszPVKFileName != wszEmpty)
        MyCoTaskMemFree(m_wszPVKFileName);

    if (NULL != m_pCertContextPendingRequest)
        CertFreeCertificateContext(m_pCertContextPendingRequest);

    if (NULL != m_pPendingRequestTable)
        delete m_pPendingRequestTable; 

    // store handles
    if(m_RootStore.hStore != NULL)
        CertCloseStore(m_RootStore.hStore, 0);
    m_RootStore.hStore = NULL;

    if(m_CAStore.hStore != NULL)
        CertCloseStore(m_CAStore.hStore, 0);
    m_CAStore.hStore = NULL;

    if(m_MyStore.hStore != NULL)
        CertCloseStore(m_MyStore.hStore, 0);
    m_MyStore.hStore = NULL;

    if(m_RequestStore.hStore != NULL)
        CertCloseStore(m_RequestStore.hStore, 0);
    m_RequestStore.hStore = NULL;

    // remove provider handles
    if(m_hProv != NULL)
        CryptReleaseContext(m_hProv, 0);
    m_hProv = NULL;

    if(m_hVerifyProv != NULL)
        CryptReleaseContext(m_hVerifyProv, 0);
    m_hVerifyProv = NULL;

    if (NULL != m_hCachedKey)
    {
        //this should be destroyed early but just in case
        CryptDestroyKey(m_hCachedKey);
    }

    if (NULL != m_pPublicKeyInfo)
    {
        LocalFree(m_pPublicKeyInfo);
        m_pPublicKeyInfo = NULL;
    }

    FreeAllStackExtension();
    FreeAllStackAttribute();
    resetBlobProperties();
}

static LPVOID CoTaskMemAllocTrap(ULONG cb) {

    __try {
        return(CoTaskMemAlloc(cb));

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_DLL_NOT_FOUND);
        return(NULL);
    }
}

static LPVOID CoTaskMemReallocTrap(LPVOID ptr, ULONG cb) {
    __try {
        return(CoTaskMemRealloc(ptr, cb));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_DLL_NOT_FOUND);
        return(NULL);
    }
}

static void CoTaskMemFreeTrap(LPVOID ptr) {
    __try {
        CoTaskMemFree(ptr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_DLL_NOT_FOUND);
    }
    return;
}


CCEnroll::CCEnroll(void) {
    __try
    {
        InitializeCriticalSection(&m_csXEnroll);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    Init();
}

HRESULT
CCEnroll::Init(void)
{
    HRESULT hr;
    GUID    guidContainerName;
    char *  sz = NULL;
    RPC_STATUS  rpc_status;

    // set default mem allocators
    if(MyCoTaskMemAlloc == NULL)
    {

        MyCoTaskMemAlloc    = CoTaskMemAllocTrap;
        MyCoTaskMemRealloc  = CoTaskMemReallocTrap;
        MyCoTaskMemFree     = CoTaskMemFreeTrap;
    }

    // get a container based on a guid
    rpc_status = UuidCreate(&guidContainerName);
    if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
    {
        hr = rpc_status;
        goto UuidCreateError;
    }
    rpc_status = UuidToStringA(&guidContainerName, (unsigned char **) &sz);
    if (RPC_S_OK != rpc_status)
    {
        hr = rpc_status;
        goto UuidToStringAError;
    }
    assert(sz != NULL);
    m_keyProvInfo.pwszContainerName = WideFromMB(sz);
    RpcStringFree((unsigned char **) &sz);

    m_keyProvInfo.pwszProvName        = wszEmpty;
    m_keyProvInfo.dwProvType          = PROV_RSA_FULL;
    m_keyProvInfo.dwFlags             = 0;
    m_keyProvInfo.cProvParam          = 0;
    m_keyProvInfo.rgProvParam         = NULL;
    m_keyProvInfo.dwKeySpec           = AT_SIGNATURE;
    m_fEnableSMIMECapabilities =
                    (m_keyProvInfo.dwKeySpec == AT_KEYEXCHANGE);
    m_fSMIMESetByClient               = FALSE;
    m_fKeySpecSetByClient             = FALSE;
    m_hProv                           = NULL;
    m_hVerifyProv                     = NULL;

    m_fDeleteRequestCert              = TRUE;
    m_fUseExistingKey                 = FALSE;
    m_fWriteCertToCSPModified         = FALSE;
    m_fWriteCertToCSP                 = TRUE;     // always want to try
    m_fWriteCertToUserDSModified      = FALSE;
    m_fWriteCertToUserDS              = FALSE;
    m_fReuseHardwareKeyIfUnableToGenNew = TRUE;
    m_fLimitExchangeKeyToEncipherment = FALSE;
    m_dwT61DNEncoding                 = 0;        // or CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG
    m_dwEnabledSafteyOptions          = 0;
    m_dwGenKeyFlags                   = 0;
    m_wszSPCFileName                  = wszEmpty;
    m_wszPVKFileName                  = wszEmpty;
    m_HashAlgId                       = 0;

    m_fMyStoreOpenFlagsModified   = FALSE;
    m_MyStore.wszName             = wszMY;
    m_MyStore.szType              = szSystemStore;
    m_MyStore.dwFlags             = CERT_SYSTEM_STORE_CURRENT_USER;
    m_MyStore.hStore              = NULL;

    m_fCAStoreOpenFlagsModified   = FALSE;
    m_CAStore.wszName             = wszCA;
    m_CAStore.szType              = szSystemStore;
    m_CAStore.dwFlags             = CERT_SYSTEM_STORE_CURRENT_USER;
    m_CAStore.hStore              = NULL;

    m_fRootStoreOpenFlagsModified = FALSE;
    m_RootStore.wszName           = wszROOT;
    m_RootStore.szType            = szSystemStore;
    m_RootStore.dwFlags           = CERT_SYSTEM_STORE_CURRENT_USER;
    m_RootStore.hStore            = NULL;

    m_fRequestStoreOpenFlagsModified = FALSE;
    m_RequestStore.wszName        = wszREQUEST ;
    m_RequestStore.szType         = szSystemStore;
    m_RequestStore.dwFlags        = CERT_SYSTEM_STORE_CURRENT_USER;
    m_RequestStore.hStore         = NULL;

    m_PrivateKeyArchiveCertificate= NULL;
    m_pCertContextRenewal         = NULL;
    m_pCertContextSigner         = NULL;
    m_pCertContextStatic          = NULL;
    memset(m_arHashBytesNewCert, 0, sizeof(m_arHashBytesNewCert));
    memset(m_arHashBytesOldCert, 0, sizeof(m_arHashBytesOldCert));
    m_fArchiveOldCert             = FALSE;

    m_pExtStack                 = NULL;
    m_cExtStack                 = 0;

    m_pAttrStack                = NULL;
    m_cAttrStack                = 0;

    m_pExtStackNew              = NULL;
    m_cExtStackNew              = 0;

    m_pAttrStackNew             = NULL;
    m_cAttrStackNew             = 0;

    m_pPropStack                = NULL;
    m_cPropStack                = 0;

    m_fNewRequestMethod         = FALSE;
    m_fCMCFormat                = FALSE;
    m_fHonorRenew               = TRUE; //critical, if passing XECR_PKCS10*
    m_fOID_V2                   = FALSE; //critical
    m_hCachedKey                = NULL;
    m_fUseClientKeyUsage        = FALSE;
    m_lClientId                 = XECI_XENROLL;
    m_fOpenConfirmed            = FALSE;
    m_dwLastAlgIndex            = MAXDWORD;
    m_fIncludeSubjectKeyID      = TRUE;
    m_fHonorIncludeSubjectKeyID = FALSE;
    m_pPublicKeyInfo            = NULL;

    m_dwSigKeyLenMax = 0;
    m_dwSigKeyLenMin = 0;
    m_dwSigKeyLenDef = 0;
    m_dwSigKeyLenInc = 0;
    m_dwXhgKeyLenMax = 0;
    m_dwXhgKeyLenMin = 0;
    m_dwXhgKeyLenDef = 0;
    m_dwXhgKeyLenInc = 0;

    // Initialize pending info data:
    m_pCertContextPendingRequest       = NULL;
    m_pCertContextLastEnumerated       = NULL;
    m_dwCurrentPendingRequestIndex     = 0; 
    m_pPendingRequestTable             = NULL; 
    memset(&m_hashBlobPendingRequest, 0, sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&m_blobResponseKAHash, sizeof(m_blobResponseKAHash));

    hr = S_OK;
ErrorReturn:
    return hr;
TRACE_ERROR(UuidToStringAError)
TRACE_ERROR(UuidCreateError)
}

void CCEnroll::FlushStore(StoreType storeType) {
    PSTOREINFO   pStoreInfo = NULL;
    HCERTSTORE   hStore     = NULL;

    // get store struct
    switch(storeType) {

        case StoreMY:
            pStoreInfo = &m_MyStore;
            break;

        case StoreCA:
            pStoreInfo = &m_CAStore;
            break;

        case StoreROOT:
            pStoreInfo = &m_RootStore;
            break;

        case StoreREQUEST:
            pStoreInfo = &m_RequestStore;
            break;
    }

    EnterCriticalSection(&m_csXEnroll);

    // if store already open, return it
    if(pStoreInfo->hStore != NULL) {

        CertCloseStore(pStoreInfo->hStore, 0);
        pStoreInfo->hStore = NULL;
    }

    // we may have something or not, but return it
    // the errors will be correct.
    LeaveCriticalSection(&m_csXEnroll);
}

HCERTSTORE CCEnroll::GetStore(StoreType storeType) {

    PSTOREINFO   pStoreInfo = NULL;
    HCERTSTORE   hStore     = NULL;

    // get store struct
    switch(storeType) {

        case StoreMY:
            pStoreInfo = &m_MyStore;
            break;

        case StoreCA:
            pStoreInfo = &m_CAStore;
            break;

        case StoreROOT:
            pStoreInfo = &m_RootStore;
            break;

        case StoreREQUEST:
            pStoreInfo = &m_RequestStore;
            break;

        default:
            SetLastError(ERROR_BAD_ARGUMENTS);
            return(NULL);
            break;
    }

    EnterCriticalSection(&m_csXEnroll);

    // if store already open, return it
    if(pStoreInfo->hStore == NULL) {

        // otherwise attempt to open the store
        pStoreInfo->hStore = CertOpenStore(
                pStoreInfo->szType,
                PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                NULL,
                pStoreInfo->dwFlags,
                pStoreInfo->wszName);
    }

    // we may have something or not, but return it
    // the errors will be correct.
    hStore = pStoreInfo->hStore;
    LeaveCriticalSection(&m_csXEnroll);

    return(hStore);
}

HCRYPTPROV CCEnroll::GetProv(DWORD dwFlags) {

    HCRYPTPROV  hProvT          = NULL;
    DWORD       cb              = 0;
    char *      pszProvName     = NULL;
    char *      pszContainerName = NULL;

    EnterCriticalSection(&m_csXEnroll);
    DWORD       dwProvType      = m_keyProvInfo.dwProvType;

    switch(dwFlags) {

        case CRYPT_NEWKEYSET:
            dwFlags = dwFlags | m_keyProvInfo.dwFlags;
            break;

        case CRYPT_DELETEKEYSET:
            if( m_hProv != NULL ) {

                CryptReleaseContext(m_hProv, 0);
                m_hProv = NULL;

                CryptAcquireContextU(&m_hProv,
                     m_keyProvInfo.pwszContainerName,
                     m_keyProvInfo.pwszProvName,
                     m_keyProvInfo.dwProvType,
                     CRYPT_DELETEKEYSET);
            }
            m_hProv = NULL;
            goto CommonReturn;
            break;

        default:
            dwFlags = m_keyProvInfo.dwFlags;
            break;
   }

    if(m_hProv == NULL) {

            if( CryptAcquireContextU(&m_hProv,
             m_keyProvInfo.pwszContainerName,
             m_keyProvInfo.pwszProvName,
             m_keyProvInfo.dwProvType,
             dwFlags) ) {

                // we have the m_hProv, now set the provider name
                // Since this is secondary to the task, don't do error checking
                // nothing here should really fail anyway
                pszProvName = NULL;
                while (TRUE)
                {
                    if(!CryptGetProvParam( m_hProv,
                                    PP_NAME,
                                    (BYTE*)pszProvName,
                                    &cb,
                                    0))
                    {
                        break;
                    }
                    if (NULL != pszProvName)
                    {
                        if(m_keyProvInfo.pwszProvName != wszEmpty)
                            MyCoTaskMemFree(m_keyProvInfo.pwszProvName);
                        m_keyProvInfo.pwszProvName = WideFromMB(pszProvName);
                        break;
                    }
                    pszProvName = (char *)LocalAlloc(LMEM_FIXED, cb);
                    if (NULL == pszProvName)
                    {
                        goto CommonReturn;
                    }
                }

                // Here we just try and get the unique container name
                // If not, just go on

                BOOL fTryAnother = FALSE;
                cb = 0;
                pszContainerName = NULL;
                while (TRUE)
                {
                    if(!CryptGetProvParam( m_hProv,
                                    PP_UNIQUE_CONTAINER,
                                    (BYTE*)pszContainerName,
                                    &cb,
                                    0))
                    {
                        if (NULL == pszContainerName)
                        {
                             fTryAnother = TRUE;
                        }
                        else
                        {
                             pszContainerName = NULL;
                        }
                        break;
                    }
                    else
                    {
                        if (NULL != pszContainerName)
                        {
                            //got it, done
                            break;
                        }
                    }
                    pszContainerName = (char *)LocalAlloc(LMEM_FIXED, cb);
                    if (NULL == pszContainerName)
                    {
                        goto CommonReturn;
                    }
                }

                if (fTryAnother)
                {
                    // so we can't get the unique container name,
                    // lets just go for the container name (may not be unique).
                    cb = 0;
                    pszContainerName = NULL;
                    while (TRUE)
                    {
                        if(!CryptGetProvParam(m_hProv,
                                    PP_CONTAINER,
                                    (BYTE*)pszContainerName,
                                    &cb,
                                    0))
                        {
                            if (NULL != pszContainerName)
                            {
                                pszContainerName = NULL;
                            }
                            break;
                        }
                        else
                        {
                            if (NULL != pszContainerName)
                            {
                                //got it, done
                                break;
                            }
                            pszContainerName = (char *)LocalAlloc(LMEM_FIXED, cb);
                            if (NULL == pszContainerName)
                            {
                                goto CommonReturn;
                            }
                        }
                    }
                }

                // set the container, otherwise use what was there
                if(pszContainerName != NULL) {
                    if( m_keyProvInfo.pwszContainerName != wszEmpty )
                        MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);
                    m_keyProvInfo.pwszContainerName = WideFromMB(pszContainerName);
                }

                // now because some providers double duty for provider types
                // get what the the provider thinks its type is
                cb = sizeof(DWORD);
                if(CryptGetProvParam(   m_hProv,
                                        PP_PROVTYPE,
                                        (BYTE *) &dwProvType,
                                        &cb,
                                        0) ) {
                    m_keyProvInfo.dwProvType = dwProvType;
                }
                
        } else {
            m_hProv = NULL;
        }

    }

CommonReturn:
    hProvT = m_hProv;
    LeaveCriticalSection(&m_csXEnroll);
    if (NULL != pszProvName)
    {
        LocalFree(pszProvName);
    }
    if (NULL != pszContainerName)
    {
        LocalFree(pszContainerName);
    }
    return(hProvT);
}


BOOL CCEnroll::SetKeyParams(
    PCRYPT_KEY_PROV_INFO pKeyProvInfo
) {

    EnterCriticalSection(&m_csXEnroll);

    // remove provider handles
    if(m_hProv != NULL)
        CryptReleaseContext(m_hProv, 0);
    m_hProv = NULL;

    if(m_hVerifyProv != NULL)
        CryptReleaseContext(m_hVerifyProv, 0);
    m_hVerifyProv = NULL;

    put_ContainerNameWStr(pKeyProvInfo->pwszContainerName);
    put_ProviderNameWStr(pKeyProvInfo->pwszProvName);
    put_ProviderFlags(pKeyProvInfo->dwFlags);
    put_KeySpec(pKeyProvInfo->dwKeySpec);
    put_ProviderType(pKeyProvInfo->dwProvType);

    // someday we will have to pay attention to this too.
    m_keyProvInfo.cProvParam          = 0;
    m_keyProvInfo.rgProvParam         = NULL;

    LeaveCriticalSection(&m_csXEnroll);

    return(TRUE);
}

HRESULT STDMETHODCALLTYPE CCEnroll::createPKCS10(
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR wszPurpose,
            /* [retval][out] */ BSTR __RPC_FAR *pPKCS10) {

    return(createPKCS10WStrBStr(DNName, wszPurpose, pPKCS10));
}

HRESULT  CCEnroll::createPKCS10WStrBStr(
            LPCWSTR DNName,
            LPCWSTR wszPurpose,
            BSTR __RPC_FAR *pPKCS10) {

    HRESULT                     hr              = S_OK;
    CRYPT_DATA_BLOB             blobPKCS10;

    memset(&blobPKCS10, 0, sizeof(CRYPT_DATA_BLOB));

    hr = createPKCS10WStr(DNName, wszPurpose, &blobPKCS10);
    if(S_OK != hr)
    {
        goto createPKCS10Error;
    }

    // BASE64 encode pkcs 10, no header for backward compatible
    hr = BlobToBstring(&blobPKCS10, CRYPT_STRING_BASE64, pPKCS10);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

CommonReturn:

    if(NULL != blobPKCS10.pbData)
    {
        MyCoTaskMemFree(blobPKCS10.pbData);
    }
    return(hr);

ErrorReturn:
    if(*pPKCS10 != NULL)
        SysFreeString(*pPKCS10);
    *pPKCS10 = NULL;

    goto CommonReturn;

TRACE_ERROR(createPKCS10Error);
TRACE_ERROR(BlobToBstringError);
}

HRESULT CCEnroll::AddCertsToStores(
    HCERTSTORE    hStoreMsg,
    LONG         *plCertInstalled
    ) {

    HCERTSTORE                  hStoreRoot              = NULL;
    HCERTSTORE                  hStoreCA                = NULL;
    PCCERT_CONTEXT              pCertContext            = NULL;
    PCCERT_CONTEXT              pCertContextLast        = NULL;
    LONG                        lCertInstalled = 0;
    HRESULT hr = S_OK;

    //init
    if (NULL != plCertInstalled)
    {
        *plCertInstalled = 0;
    }

    EnterCriticalSection(&m_csXEnroll);

    if( (hStoreCA = GetStore(StoreCA)) == NULL )
        goto ErrorCertOpenCAStore;

    if( (hStoreRoot = GetStore(StoreROOT)) == NULL )
        goto ErrorCertOpenRootStore;

    // now just place the rest of the cert in either the ROOT or CA store
    // we know we removed the end-entity cert from the msg store already
    // put all certs that came in the message into the appropriate store
    while( (pCertContext = CertEnumCertificatesInStore(
                        hStoreMsg,
                        pCertContextLast)) != NULL ) {

        // if it is a self sign, it is a ROOT
        if( CertCompareCertificateName(
                CRYPT_ASN_ENCODING,
                &pCertContext->pCertInfo->Subject,
                &pCertContext->pCertInfo->Issuer) ) {

            // to root store could invoke a pop up, check cancel button
            // but don't error out from any fail
            if (CertAddCertificateContextToStore(
                    hStoreRoot,
                    pCertContext,
                    CERT_STORE_ADD_USE_EXISTING,
                    NULL))
            {
                ++lCertInstalled;
            }
            else
            {
                if (S_OK == hr)
                {
                    //save the 1st error as return
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                    {
                        //map generic access deny to xenroll error
                        hr = XENROLL_E_CANNOT_ADD_ROOT_CERT;
                    }
                }
                //don't goto error here and finish the loop
            }
        }

        // if it is not the MY cert, it must go in the CA store
        // do nothing with the MY cert as we already handled it
        else  {

            // likewise we don't care if these get added to the
            // CA store
            if (CertAddCertificateContextToStore(
                    hStoreCA,
                    pCertContext,
                    CERT_STORE_ADD_USE_EXISTING,
                    NULL))
            {
                //no error code check
                ++lCertInstalled;
            }
        }

        pCertContextLast = pCertContext;
    }
    pCertContextLast = NULL;
    if (NULL != plCertInstalled)
    {
        *plCertInstalled = lCertInstalled;
    }

CommonReturn:

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);

    goto CommonReturn;

TRACE_ERROR(ErrorCertOpenCAStore);
TRACE_ERROR(ErrorCertOpenRootStore);
}

BOOL
IsDesiredProperty(DWORD  dwPropertyId)
{
    DWORD  DesiredIds[] = {
        CERT_PVK_FILE_PROP_ID,
        CERT_FRIENDLY_NAME_PROP_ID,
        CERT_DESCRIPTION_PROP_ID,
        CERT_RENEWAL_PROP_ID,
    };
    DWORD i;

    for (i = 0; i < ARRAYSIZE(DesiredIds); ++i)
    {
        if (dwPropertyId == DesiredIds[i])
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsFilteredOutProperty(DWORD  dwPropertyId)
{
    DWORD  FilteredIds[] = {
        XENROLL_RENEWAL_CERTIFICATE_PROP_ID,
        XENROLL_PASS_THRU_PROP_ID,
        CERT_KEY_PROV_INFO_PROP_ID,
        CERT_ENROLLMENT_PROP_ID, //pending property
    };
    DWORD i;

    for (i = 0; i < ARRAYSIZE(FilteredIds); ++i)
    {
        if (dwPropertyId == FilteredIds[i])
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CCEnroll::GetEndEntityCert(
    PCRYPT_DATA_BLOB    pBlobPKCS7,
    BOOL                fSaveToStores,
    PCCERT_CONTEXT     *ppCert
    )
{
    HRESULT                     hr = S_OK;
    HCERTSTORE                  hStoreMsg               = NULL;
    HCERTSTORE                  hStoreMy                = NULL;
    HCERTSTORE                  hStoreRequest           = NULL;

    PCCERT_CONTEXT              pCertContextLast        = NULL;
    PCCERT_CONTEXT              pCertContextRequest     = NULL;
    PCCERT_CONTEXT              pCertContextMsg         = NULL;
    PCCERT_CONTEXT              pCertContextArchive     = NULL;

    PCRYPT_KEY_PROV_INFO                pKeyProvInfo            = NULL;
    DWORD                       cb                      = 0;
    CRYPT_DATA_BLOB             blobData;

    CRYPT_HASH_BLOB             blobHash                = {sizeof(m_arHashBytesNewCert), m_arHashBytesNewCert};
    CRYPT_HASH_BLOB             blobHashRenew           = {sizeof(m_arHashBytesOldCert), m_arHashBytesOldCert};

    RequestFlags                requestFlags;
    CRYPT_HASH_BLOB             requestFlagsBlob;

    CRYPT_HASH_BLOB             renewalCertBlob;

    //Bug #202557 for IE3.02 upd clients (xiaohs)
    HCRYPTPROV                  hProv=NULL;
    BOOL  fSetting;
    PPROP_STACK                 pProp;
    DWORD                       dwPropertyId;
    CRYPT_DATA_BLOB             blobProp;
    BYTE                        *pbArchivedKeyHash = NULL;
    DWORD                        cbArchivedKeyHash = 0;

    EnterCriticalSection(&m_csXEnroll);

    memset(&requestFlags, 0, sizeof(RequestFlags));
    memset(&blobData, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&requestFlagsBlob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&renewalCertBlob, 0, sizeof(CRYPT_DATA_BLOB));
    ZeroMemory(&blobProp, sizeof(blobProp));

    if (NULL == ppCert)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //init return
    *ppCert = NULL;

    if(!MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                       pBlobPKCS7,
                       (CERT_QUERY_CONTENT_FLAG_CERT |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hStoreMsg,
                       NULL,
                       NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto ErrorCryptQueryObject;
    }

    // check to see if this hash is in the message
    if (m_pCertContextStatic == NULL  ||
        (NULL == (pCertContextMsg = CertFindCertificateInStore(
                                hStoreMsg,
                                X509_ASN_ENCODING,
                                0,
                                CERT_FIND_HASH,
                                &blobHash,
                                NULL))))
    {
        // open the request store
        if (NULL == (hStoreRequest = GetStore(StoreREQUEST)))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenRequestStore;
        }
        // find cert in request store that matches cert
        // in message, by public key
        while (NULL != (pCertContextMsg = CertEnumCertificatesInStore(
                            hStoreMsg,
                            pCertContextLast)))
        {
            // check to see if this is in the request store
            if (NULL != (pCertContextRequest = CertFindCertificateInStore(
                    hStoreRequest,
                    CRYPT_ASN_ENCODING,
                    0,
                    CERT_FIND_PUBLIC_KEY,
                    (void *) &pCertContextMsg->pCertInfo->SubjectPublicKeyInfo,
                    NULL)))
            {
                // found a match, get out
                break;
            }

            pCertContextLast = pCertContextMsg;
        }
        pCertContextLast = NULL;

        // if we didn't find one, then GetLastError was set either
        // by CertEnumCerificatesInStore or CertEnumCerificatesInStore
        if (NULL == pCertContextRequest)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorNoCertFound;
        }

        if (fSaveToStores)
        {
        // check archived key hash property first
        // if the property exists, means key archival was in the request
        cb = 0;
        while (TRUE)
        {
            if(!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    CERT_ARCHIVED_KEY_HASH_PROP_ID,
                    pbArchivedKeyHash,
                    &cbArchivedKeyHash))
            {
                if (NULL == pbArchivedKeyHash)
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    if (MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) == hr)
                    {
                        //no such property, so we are done
                        break;
                    }
                    // some other error
                    goto ErrorCertGetCertificateContextProperty;
                }
                else
                {
                    //if pbArchivedKeyHash non-null, error
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertGetCertificateContextProperty;
                }
            }
            if (NULL != pbArchivedKeyHash)
            {
                //got it, done
                break;
            }
            pbArchivedKeyHash = (BYTE*)LocalAlloc(
                                    LMEM_FIXED, cbArchivedKeyHash);
            if (NULL == pbArchivedKeyHash)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }

        if (NULL != pbArchivedKeyHash && NULL == m_blobResponseKAHash.pbData)
        {
            //request cert has archived key hash but response
            //doesn't contain key hash for verification. maybe
            //a spoofing response?
            hr = XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND;
            goto ResponseKAHashNotFoundError;
        }
        if (NULL == pbArchivedKeyHash && NULL != m_blobResponseKAHash.pbData)
        {
            //request cert doesn't have archived key hash but
            //response does. confliciting. seems no security harm
            hr = XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH;
            goto ResponseUnexpectedKAHashError;
        }
        if (NULL != pbArchivedKeyHash && NULL != m_blobResponseKAHash.pbData)
        {
            //now we should check if they match
            //compare size and hash
            if (cbArchivedKeyHash != m_blobResponseKAHash.cbData ||
                0 != memcmp(pbArchivedKeyHash,
                            m_blobResponseKAHash.pbData,
                            cbArchivedKeyHash))
            {
                //oh, potential attack
                hr = XENROLL_E_RESPONSE_KA_HASH_MISMATCH;
                //should remove the request cert?
                goto ResponseKAMismatchError;
            }
        }
        }

        // get those request cert properties that are,
        // either the property not blob property
        // or blob property needs special handling
        // Important: remember to add these Ids in IsFilteredOutProperty
        fSetting = TRUE;
        cb = 0;
        while (TRUE)
        {
            if(!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pKeyProvInfo,
                    &cb))
            {
                if (NULL == pKeyProvInfo)
                {
                    //skip setting
                    fSetting = FALSE;
                    break;
                }
                else
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertGetCertificateContextProperty;
                }
            }
            if (NULL != pKeyProvInfo)
            {
                //got it, done
                break;
            }
            pKeyProvInfo = (PCRYPT_KEY_PROV_INFO)LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pKeyProvInfo)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        if (fSetting)
        {
            // put the property on the returned cert
            if( !CertSetCertificateContextProperty(
                    pCertContextMsg,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0,
                    pKeyProvInfo) )
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorSetMyCertPropError;
            }

            // Set the provider info
            SetKeyParams(pKeyProvInfo);
        }

        fSetting = TRUE;
        while (TRUE)
        {
            if(!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    XENROLL_PASS_THRU_PROP_ID,
                    requestFlagsBlob.pbData,
                    &requestFlagsBlob.cbData) )
            {
                if (NULL == requestFlagsBlob.pbData)
                {
                    //do nothing
                    fSetting = FALSE;
                    break;
                }
                else
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorDecodeRequestFlags;
                }
            }
            if (NULL != requestFlagsBlob.pbData)
            {
                //got it, done
                break;
            }
            requestFlagsBlob.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                                requestFlagsBlob.cbData);
            if (NULL == requestFlagsBlob.pbData)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }

        if (fSetting)
        {
            // get the encoded blob
            cb = sizeof(requestFlags);
            // since this is a private data structure, its size should be
            // known and this should aways pass
            if (!CryptDecodeObject(
                    CRYPT_ASN_ENCODING,
                    XENROLL_REQUEST_INFO,
                    requestFlagsBlob.pbData,
                    requestFlagsBlob.cbData,
                    0,
                    &requestFlags,
                    &cb))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorDecodeRequestFlags;
            }
            // now set the flags
            if(!m_fWriteCertToCSPModified)
                m_fWriteCertToCSP     = requestFlags.fWriteToCSP;
            if(!m_fWriteCertToUserDSModified)
                m_fWriteCertToUserDS  = requestFlags.fWriteToDS;
            if(!m_fRequestStoreOpenFlagsModified)
                m_RequestStore.dwFlags = requestFlags.openFlags;
            if(!m_fMyStoreOpenFlagsModified)
                m_MyStore.dwFlags =   (m_MyStore.dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                    (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
            if(!m_fCAStoreOpenFlagsModified)
                m_CAStore.dwFlags =   (m_CAStore.dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                    (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
            if(!m_fRootStoreOpenFlagsModified)
                m_RootStore.dwFlags = (m_RootStore.dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                    (requestFlags.openFlags & CERT_SYSTEM_STORE_LOCATION_MASK);

        }

        // see if this is a renewal request
        m_fArchiveOldCert = FALSE;
        fSetting = TRUE;
        while (TRUE)
        {
            // get the encoded blob
            if (!CertGetCertificateContextProperty(
                    pCertContextRequest,
                    XENROLL_RENEWAL_CERTIFICATE_PROP_ID,
                    renewalCertBlob.pbData,
                    &renewalCertBlob.cbData))
            {
                if (NULL == renewalCertBlob.pbData)
                {
                    fSetting = FALSE;
                    break;
                }
                else
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertGetCertificateContextProperty;
                }
            }
            if (NULL != renewalCertBlob.pbData)
            {
                //got it, done
                break;
            }
            renewalCertBlob.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                                renewalCertBlob.cbData);
            if (NULL == renewalCertBlob.pbData)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        if (fSetting)
        {
            //Bug #202557 for IE3.02 upd clients (xiaohs)
            if (NULL==hProv)
            {
                if(!CryptAcquireContext(
                        &hProv,
                        NULL,
                        MS_DEF_PROV,
                        PROV_RSA_FULL,
                        CRYPT_VERIFYCONTEXT))
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorAcquireContext;
                }
            }

            if (!CryptHashCertificate(
                hProv,  //NULL,         Bug #202557 for IE3.02 upd clients (xiaohs)
                0,      //alg
                X509_ASN_ENCODING,      //0 dwFlags
                renewalCertBlob.pbData,
                renewalCertBlob.cbData,
                blobHashRenew.pbData,
                &blobHashRenew.cbData))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorCryptHashCertificate;
            }
            m_fArchiveOldCert = TRUE;
        }

        //get rest of blob properties from request store and set to the cert
        dwPropertyId = CertEnumCertificateContextProperties(
                            pCertContextRequest, 0);  //enum from 1st
        while (0 != dwPropertyId)
        {
//            if (!IsFilteredOutProperty(dwPropertyId))
//because iis cert install doesn't like to copy all properties from
//request cert to install cert we just copy selected properties for now
            if (IsDesiredProperty(dwPropertyId))
            {
                fSetting = TRUE;
                while (TRUE)
                {
                    if (!CertGetCertificateContextProperty(
                            pCertContextRequest,
                            dwPropertyId,
                            blobProp.pbData,
                            &blobProp.cbData))
                    {
                        //no get, no set, go on
                        fSetting = FALSE;
                        break;
                    }
                    if (NULL != blobProp.pbData)
                    {
                        //done
                        break;
                    }
                    blobProp.pbData = (BYTE*)LocalAlloc(LMEM_FIXED, 
                                                        blobProp.cbData);
                    if (NULL == blobProp.pbData)
                    {
                        goto OutOfMemoryError;
                    }
                }
                if (fSetting)
                {
                    //should get the property from the request cert
                    if (!CertSetCertificateContextProperty(
                                pCertContextMsg,
                                dwPropertyId,
                                0,
                                &blobProp))
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto ErrorSetMyCertPropError;
                    }
                }
                if (NULL != blobProp.pbData)
                {
                    //set for the next enum
                    LocalFree(blobProp.pbData);
                    blobProp.pbData = NULL;
                }
            }
            dwPropertyId = CertEnumCertificateContextProperties(
                                  pCertContextRequest,
                                  dwPropertyId);
        }

        // save this away in the cache
        if(m_pCertContextStatic != NULL)
            CertFreeCertificateContext(m_pCertContextStatic);

        m_pCertContextStatic = CertDuplicateCertificateContext(pCertContextMsg);

        //Bug #202557 for IE3.02 upd clients (xiaohs)
        if(NULL==hProv)
        {
            if(!CryptAcquireContext(
                &hProv,
                NULL,
                MS_DEF_PROV,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto ErrorAcquireContext;
            }
        }

        if( !CryptHashCertificate(
            hProv,             //NULL Bug #202557 for IE3.02 upd clients (xiaohs)
            0,
            X509_ASN_ENCODING,
            pCertContextMsg->pbCertEncoded,
            pCertContextMsg->cbCertEncoded,
            blobHash.pbData,
            &blobHash.cbData) )
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCryptHashCertificate;
        }
    }

    // at this point we have 2 context m_pCertContextStatic which we want to return to the user
    // and pCertContextMsg which we want to delete from the Msg store
    assert(pCertContextMsg != NULL);
    CertDeleteCertificateFromStore(pCertContextMsg);
    pCertContextMsg = NULL; // freed by the delete

    // we want to return our static, so make a dup and this is what we will return
    assert(m_pCertContextStatic != NULL);
    pCertContextMsg = CertDuplicateCertificateContext(m_pCertContextStatic);

    // put these in the stores if asked
    if(fSaveToStores) {

        // open the stores
        if( (hStoreMy = GetStore(StoreMY)) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenMYStore;
        }

        // we know that the pCertContextMsg is a dup of the end-entity cert in m_pCertContextStatic
        // and we want to put this in the MY store
        assert(pCertContextMsg != NULL);
        if( !CertAddCertificateContextToStore(
                hStoreMy,
                pCertContextMsg,
                CERT_STORE_ADD_USE_EXISTING,
                NULL) )
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertAddToMyStore;
        }

        // If we have renewal, then mark the old cert as an archive
        if(m_fArchiveOldCert &&
            ((pCertContextArchive = CertFindCertificateInStore(
                    hStoreMy,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_HASH,
                    &blobHashRenew,
                    NULL)) != NULL) ) {

            // Set the Archive property on the cert.
            // crypt32 in IE3.02upd does not support this prop, so don't fail on error
            CertSetCertificateContextProperty(
                                pCertContextArchive,
                                CERT_ARCHIVED_PROP_ID,
                                0,
                                &blobData);

            //set new cert hash on old archived cert
            //ignore error if it fails
            CertSetCertificateContextProperty(
                                pCertContextArchive,
                                CERT_RENEWAL_PROP_ID,
                                0,
                                &blobHash);
        }

        // add the rest of the certs to the stores
        hr = AddCertsToStores(hStoreMsg, NULL);
        //ignore cancel error since it from root cert install
        //ignore XENROLL_E_CANNOT_ADD_ROOT_CERT also
        if (S_OK != hr &&
            MY_HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr &&
            XENROLL_E_CANNOT_ADD_ROOT_CERT != hr)
        {
            goto ErrorAddCertsToStores;
        }
    }

    *ppCert = pCertContextMsg;

CommonReturn:

    //Bug #202557 for IE3.02 upd clients (xiaohs)
    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(pCertContextRequest != NULL)
        CertFreeCertificateContext(pCertContextRequest);

    if(pCertContextArchive != NULL)
        CertFreeCertificateContext(pCertContextArchive);

    // it really should be NULL
    assert(pCertContextLast == NULL);

    if(hStoreMsg != NULL)
        CertCloseStore(hStoreMsg, 0);

    // we need to do this because the store that may be opened is the systemstore, but
    // the store we may need is the local machine store, but we don't know that until the
    // system store finds the request cert in the local machine physical store.
    // Later when we do the delete, we want the local machine store open.
    FlushStore(StoreREQUEST);

    if (NULL != requestFlagsBlob.pbData)
    {
        LocalFree(requestFlagsBlob.pbData);
    }
    if (NULL != renewalCertBlob.pbData)
    {
        LocalFree(renewalCertBlob.pbData);
    }
    if (NULL != blobProp.pbData)
    {
        LocalFree(blobProp.pbData);
    }
    if (NULL != pKeyProvInfo)
    {
        LocalFree(pKeyProvInfo);
    }
    if (NULL != pbArchivedKeyHash)
    {
        LocalFree(pbArchivedKeyHash);
    }

    LeaveCriticalSection(&m_csXEnroll);

    return (hr);

ErrorReturn:
    if(NULL != pCertContextMsg)
    {
        CertFreeCertificateContext(pCertContextMsg);
    }
    goto CommonReturn;

TRACE_ERROR(ErrorCryptHashCertificate);
TRACE_ERROR(ErrorCertOpenMYStore);
TRACE_ERROR(ErrorCertAddToMyStore);
TRACE_ERROR(ErrorCryptQueryObject);
TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorNoCertFound);
TRACE_ERROR(ErrorCertGetCertificateContextProperty);
TRACE_ERROR(ErrorSetMyCertPropError);
TRACE_ERROR(ErrorDecodeRequestFlags);
TRACE_ERROR(ErrorAcquireContext);      //Bug #202557 for IE3.02 upd clients (xiaohs)
TRACE_ERROR(ErrorAddCertsToStores);
TRACE_ERROR(OutOfMemoryError);
TRACE_ERROR(InvalidParameterError);
TRACE_ERROR(ResponseKAMismatchError)
TRACE_ERROR(ResponseUnexpectedKAHashError)
TRACE_ERROR(ResponseKAHashNotFoundError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::getCertFromPKCS7(
                        /* [in] */ BSTR wszPKCS7,
                        /* [retval][out] */ BSTR __RPC_FAR *pbstrCert
) {

    HRESULT     hr;                     
    CRYPT_DATA_BLOB             blobPKCS7;
    CRYPT_DATA_BLOB             blobX509;
    PCCERT_CONTEXT              pCertContextMy          = NULL;

    LPWSTR                      wszCert                 = NULL;
    DWORD                       cchCert                  = 0;

    DWORD                       err;

    assert(wszPKCS7 != NULL);

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // Get a Cert Context for the end-entity
    if( (pCertContextMy = getCertContextFromPKCS7(&blobPKCS7)) == NULL)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto getCertContextFromPKCS7Error;
    }

    blobX509.pbData = pCertContextMy->pbCertEncoded;
    blobX509.cbData = pCertContextMy->cbCertEncoded;
    //base64 with no header for backward compatible
    hr = BlobToBstring(&blobX509, CRYPT_STRING_BASE64, pbstrCert);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if(pCertContextMy != NULL)
        CertFreeCertificateContext(pCertContextMy);

    return(hr);

TRACE_ERROR(getCertContextFromPKCS7Error);
TRACE_ERROR(BlobToBstringError);
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptPKCS7(
                        /* [in] */ BSTR wszPKCS7) {

    CRYPT_DATA_BLOB             blobPKCS7;

    assert(wszPKCS7 != NULL);

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // accept the blob
    return(acceptPKCS7Blob(&blobPKCS7));
}

HRESULT STDMETHODCALLTYPE CCEnroll::createFilePKCS10(
    /* [in] */ BSTR DNName,
    /* [in] */ BSTR Usage,
    /* [in] */ BSTR wszPKCS10FileName) {
    return(createFilePKCS10WStr(DNName, Usage, wszPKCS10FileName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::addCertTypeToRequest(
            /* [in] */ BSTR CertType) {
    return(AddCertTypeToRequestWStr(CertType));
}


HRESULT STDMETHODCALLTYPE CCEnroll::addCertTypeToRequestEx( 
    IN  LONG            lType,
    IN  BSTR            bstrOIDOrName,
    IN  LONG            lMajorVersion,
    IN  BOOL            fMinorVersion,
    IN  LONG            lMinorVersion)
{
    return AddCertTypeToRequestWStrEx(
                        lType,
                        bstrOIDOrName,
                        lMajorVersion,
                        fMinorVersion,
                        lMinorVersion);
                    
}

HRESULT STDMETHODCALLTYPE CCEnroll::getProviderType( 
    IN  BSTR  strProvName,
    OUT LONG *plProvType)
{
    return getProviderTypeWStr(strProvName, plProvType);
}

HRESULT STDMETHODCALLTYPE CCEnroll::addNameValuePairToSignature(
    /* [in] */ BSTR Name,
    /* [in] */ BSTR Value) {
    return(AddNameValuePairToSignatureWStr(Name, Value));
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptFilePKCS7(
    /* [in] */ BSTR wszPKCS7FileName) {
    return(acceptFilePKCS7WStr(wszPKCS7FileName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::freeRequestInfo(
    /* [in] */ BSTR bstrPKCS7OrPKCS10)
{
    HRESULT  hr;
    CRYPT_DATA_BLOB blob; 
    BYTE *pbData = NULL;
    DWORD cbData = 0;

    // could be base64
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                        (WCHAR*)bstrPKCS7OrPKCS10,
                        SysStringLen(bstrPKCS7OrPKCS10),
                        CRYPT_STRING_ANY,
                        pbData,
                        &cbData,
                        NULL,
                        NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbData)
        {
            break; //done
        }
        pbData = (BYTE*)LocalAlloc(LMEM_FIXED, cbData);
        if (NULL == pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    blob.cbData = cbData;
    blob.pbData = pbData;

    hr = freeRequestInfoBlob(blob); 
    if (S_OK != hr)
    {
        goto freeRequestInfoBlobError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(freeRequestInfoBlobError)
}

//
// MY STORE
//
HCERTSTORE STDMETHODCALLTYPE CCEnroll::getMyStore( void)
{
    HCERTSTORE hStore;
    
    EnterCriticalSection(&m_csXEnroll);
    hStore = m_MyStore.hStore;
    LeaveCriticalSection(&m_csXEnroll);
    
return(hStore);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_MyStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_MyStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_MyStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_MyStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_MyStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_MyStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {

        // set the my store flags
        m_MyStore.dwFlags = dwFlags;
        m_fMyStoreOpenFlagsModified = TRUE;
        m_keyProvInfo.dwFlags |= KeyLocationFromStoreLocation(dwFlags);

        // track the request store location to the my store, only if the request store has not been modified
        // do NOT set the modify bit for the request store, this is a default
        if(!m_fRequestStoreOpenFlagsModified) {
            m_RequestStore.dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
            m_RequestStore.dwFlags |= (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
        }
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_MyStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_MyStore.wszName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreNameWStr(
    /* [in] */ LPWSTR szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_MyStore.wszName != wszMY)
            MyCoTaskMemFree(m_MyStore.wszName);
        if( (m_MyStore.wszName = CopyWideString(szwName)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_MyStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_MyStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_MyStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_MyStore.szType != szSystemStore)
            MyCoTaskMemFree(m_MyStore.szType);
        if( (m_MyStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//
// CA STORE
//
HCERTSTORE STDMETHODCALLTYPE CCEnroll::getCAStore( void)
{

    HCERTSTORE hStore;
    
    EnterCriticalSection(&m_csXEnroll);
    hStore = m_CAStore.hStore;
    LeaveCriticalSection(&m_csXEnroll);

return(hStore);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_CAStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_CAStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_CAStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_CAStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_CAStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_CAStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        m_fCAStoreOpenFlagsModified = TRUE;
        m_CAStore.dwFlags = dwFlags;
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_CAStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_CAStore.wszName)) == NULL )
         hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreNameWStr(
    /* [in] */ LPWSTR szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_CAStore.wszName != wszCA)
            MyCoTaskMemFree(m_CAStore.wszName);
        if( (m_CAStore.wszName = CopyWideString(szwName)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_CAStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_CAStore.szType)) == NULL )
         hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_CAStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_CAStore.szType != szSystemStore)
            MyCoTaskMemFree(m_CAStore.szType);
        if( (m_CAStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//
// ROOT STORE
//
HCERTSTORE STDMETHODCALLTYPE CCEnroll::getROOTHStore( void)
{
    HCERTSTORE hStore;
    
    EnterCriticalSection(&m_csXEnroll);
    hStore = m_RootStore.hStore;
    LeaveCriticalSection(&m_csXEnroll);

return(hStore);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RootStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_RootStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_RootStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_RootStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_RootStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_RootStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        m_fRootStoreOpenFlagsModified = TRUE;
        m_RootStore.dwFlags = dwFlags;
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
   
    if(m_RootStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_RootStore.wszName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreNameWStr(
    /* [in] */ LPWSTR szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RootStore.wszName != wszROOT)
            MyCoTaskMemFree(m_RootStore.wszName);
        if( (m_RootStore.wszName = CopyWideString(szwName)) == NULL )
             hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RootStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_RootStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RootStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RootStore.szType != szSystemStore)
            MyCoTaskMemFree(m_RootStore.szType);
        if( (m_RootStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//
// REQUEST STORE
//
HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RequestStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*pbstrName = SysAllocString(m_RequestStore.wszName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreName(
    /* [in] */ BSTR bstrName) {
    return(put_RequestStoreNameWStr(bstrName));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreType(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrType = BSTRFromMB(m_RequestStore.szType)) == NULL )
         hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreType(
    /* [in] */ BSTR bstrType) {
    return(put_RequestStoreTypeWStr(bstrType));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_RequestStore.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {

        // set the request store flags
        m_RequestStore.dwFlags = dwFlags;
        m_fRequestStoreOpenFlagsModified = TRUE;

        // track the My store location to the request store, only if the my store has not been modified
        // do NOT set the modify bit for the my store, this is a default
        if(!m_fMyStoreOpenFlagsModified) {
            m_MyStore.dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
            m_MyStore.dwFlags |= (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK);
            m_keyProvInfo.dwFlags |= KeyLocationFromStoreLocation(m_MyStore.dwFlags);
        }
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwName) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RequestStore.wszName == NULL) 
        return(ERROR_UNKNOWN_PROPERTY);
        
    if( (*szwName = CopyWideString(m_RequestStore.wszName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreNameWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RequestStore.wszName != wszREQUEST)
            MyCoTaskMemFree(m_RequestStore.wszName);
        if( (m_RequestStore.wszName = CopyWideString(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RequestStoreTypeWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwType = WideFromMB(m_RequestStore.szType)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RequestStoreTypeWStr(
    /* [in] */ LPWSTR szwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RequestStore.szType != szSystemStore)
            MyCoTaskMemFree(m_RequestStore.szType);
        if( (m_RequestStore.szType = MBFromWide(szwType)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//
// Provider Stuff
//

HRESULT STDMETHODCALLTYPE CCEnroll::get_ContainerName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContainer) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrContainer = SysAllocString(m_keyProvInfo.pwszContainerName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ContainerName(
    /* [in] */ BSTR bstrContainer) {
    return(put_ContainerNameWStr(bstrContainer));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstrProvider) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstrProvider = SysAllocString(m_keyProvInfo.pwszProvName)) == NULL )
         hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderName(
    /* [in] */ BSTR bstrProvider) {
    return(put_ProviderNameWStr(bstrProvider));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderType(
    /* [retval][out] */ LONG __RPC_FAR *pdwType) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwType = m_keyProvInfo.dwProvType;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderType(
    /* [in] */ LONG dwType) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else
        m_keyProvInfo.dwProvType = dwType;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_KeySpec(
    /* [retval][out] */ LONG __RPC_FAR *pdw) {
    EnterCriticalSection(&m_csXEnroll);
    *pdw = m_keyProvInfo.dwKeySpec;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_KeySpec(
    /* [in] */ LONG dwKeySpec) {
    HRESULT hr;
    EnterCriticalSection(&m_csXEnroll);

    if(m_hProv != NULL)
    {
        hr = E_ACCESSDENIED;
        goto NullProvError;
    }

    if (m_fSMIMESetByClient)
    {
        //SMIME is set by the client
        if (m_fEnableSMIMECapabilities && AT_SIGNATURE == dwKeySpec)
        {
            //try to set signature key spec also SMIME
            hr = XENROLL_E_KEYSPEC_SMIME_MISMATCH;
            goto MismatchError;
        }
    }
    else
    {
        //currently smime is not set by user
        //turn on SMIME for according to key spec
        m_fEnableSMIMECapabilities = (dwKeySpec == AT_KEYEXCHANGE);
    }
    m_keyProvInfo.dwKeySpec = dwKeySpec;
    m_fKeySpecSetByClient = TRUE;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(NullProvError)
TRACE_ERROR(MismatchError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ClientId(
    /* [retval][out] */ LONG __RPC_FAR *pdw) {
    EnterCriticalSection(&m_csXEnroll);
    *pdw = m_lClientId;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ClientId(
    /* [in] */ LONG dw) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    m_lClientId = dw;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_IncludeSubjectKeyID(
    /* [retval][out] */ BOOL __RPC_FAR *pfInclude) {
    EnterCriticalSection(&m_csXEnroll);
    *pfInclude = m_fIncludeSubjectKeyID;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_IncludeSubjectKeyID(
    /* [in] */ BOOL fInclude) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    m_fIncludeSubjectKeyID = fInclude;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderFlags(
    /* [retval][out] */ LONG __RPC_FAR *pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_keyProvInfo.dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderFlags(
    /* [in] */ LONG dwFlags) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else
       m_keyProvInfo.dwFlags = dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ContainerNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwContainer) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwContainer = CopyWideString(m_keyProvInfo.pwszContainerName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ContainerNameWStr(
    /* [in] */ LPWSTR szwContainer) {
    HRESULT hr = S_OK;

    if(szwContainer == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else {
        if( m_keyProvInfo.pwszContainerName != wszEmpty)
            MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);
        if( (m_keyProvInfo.pwszContainerName = CopyWideString(szwContainer)) == NULL )
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ProviderNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szwProvider) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szwProvider = CopyWideString(m_keyProvInfo.pwszProvName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ProviderNameWStr(
    /* [in] */ LPWSTR szwProvider) {
    HRESULT hr = S_OK;
    
    if(szwProvider == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
        
    if(m_hProv != NULL)
        hr = E_ACCESSDENIED;
    else {
        if (0 != wcscmp(m_keyProvInfo.pwszProvName, szwProvider))
        {
            if( m_keyProvInfo.pwszProvName != wszEmpty )
                MyCoTaskMemFree(m_keyProvInfo.pwszProvName);
            if( (m_keyProvInfo.pwszProvName = CopyWideString(szwProvider)) == NULL )
                hr = MY_HRESULT_FROM_WIN32(GetLastError());

            //one last thing, free/null cached prov handle
            if (NULL != m_hVerifyProv)
            {
                CryptReleaseContext(m_hVerifyProv, 0);
                m_hVerifyProv = NULL;
            }
            // csp is changed, reset key size cache
            m_dwXhgKeyLenMax = 0;
            m_dwXhgKeyLenMin = 0;
            m_dwXhgKeyLenDef = 0;
            m_dwXhgKeyLenInc = 0;
            m_dwSigKeyLenMax = 0;
            m_dwSigKeyLenMin = 0;
            m_dwSigKeyLenDef = 0;
            m_dwSigKeyLenInc = 0;
        }
    }
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

//
// Other Stuff
//

HRESULT STDMETHODCALLTYPE CCEnroll::get_UseExistingKeySet(
    /* [retval][out] */ BOOL __RPC_FAR *fUseExistingKeys) {

    EnterCriticalSection(&m_csXEnroll);
    *fUseExistingKeys = m_fUseExistingKey;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_UseExistingKeySet(
    /* [in] */ BOOL fUseExistingKeys) {

    EnterCriticalSection(&m_csXEnroll);
    m_fUseExistingKey = fUseExistingKeys;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_GenKeyFlags(
    /* [retval][out] */ LONG __RPC_FAR * pdwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    *pdwFlags = m_dwGenKeyFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_GenKeyFlags(
    /* [in] */ LONG dwFlags) {
    EnterCriticalSection(&m_csXEnroll);
    m_dwGenKeyFlags = dwFlags;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_DeleteRequestCert(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fDeleteRequestCert;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_DeleteRequestCert(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fDeleteRequestCert = fBool;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_WriteCertToCSP(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fWriteCertToCSP;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_WriteCertToCSP(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fWriteCertToCSP = fBool;
    m_fWriteCertToCSPModified = TRUE;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_WriteCertToUserDS(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fWriteCertToUserDS;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_WriteCertToUserDS(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fWriteCertToUserDS = fBool;
    m_fWriteCertToUserDSModified = TRUE;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_EnableT61DNEncoding(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {
    EnterCriticalSection(&m_csXEnroll);
    *fBool = (m_dwT61DNEncoding == CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG);
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_EnableT61DNEncoding(
    /* [in] */ BOOL fBool) {

    EnterCriticalSection(&m_csXEnroll);
    if(fBool)
        m_dwT61DNEncoding = CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG;
    else
        m_dwT61DNEncoding = 0;
        
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_SPCFileName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstr) {

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstr = SysAllocString(m_wszSPCFileName)) == NULL )
        hr = E_OUTOFMEMORY;
        
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_SPCFileName(
    /* [in] */ BSTR bstr) {
    return(put_SPCFileNameWStr(bstr));
}


HRESULT STDMETHODCALLTYPE CCEnroll::get_PVKFileName(
    /* [retval][out] */ BSTR __RPC_FAR *pbstr) {

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);
    if( (*pbstr = SysAllocString(m_wszPVKFileName)) == NULL )
        hr = E_OUTOFMEMORY;
    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_PVKFileName(
    /* [in] */ BSTR bstr) {
    return(put_PVKFileNameWStr(bstr));
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_HashAlgorithm(
    /* [retval][out] */ BSTR __RPC_FAR *pbstr) {

    LPWSTR  wszAlg  = NULL;
    HRESULT hr      = S_OK;

    assert(pbstr != NULL);
    *pbstr          = NULL;

    if( (hr = get_HashAlgorithmWStr(&wszAlg)) == S_OK ) {

        if( (*pbstr = SysAllocString(wszAlg)) == NULL )
            hr = E_OUTOFMEMORY;
    }

    if(wszAlg != NULL)
        MyCoTaskMemFree(wszAlg);

    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_HashAlgorithm(
    /* [in] */ BSTR bstr) {
    return(put_HashAlgorithmWStr(bstr));
}

HRESULT STDMETHODCALLTYPE CCEnroll::enumContainers(
            /* [in] */ LONG                     dwIndex,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) {

    LPWSTR      pwsz        = NULL;
    HRESULT     hr;

    assert(pbstr != NULL);

    if((hr = enumContainersWStr(dwIndex, &pwsz)) != S_OK)
        goto EnumContainerError;

    if( (*pbstr = SysAllocString(pwsz)) == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ErrorSysAllocString;
    }

    hr = S_OK;
ErrorReturn:
    if(pwsz != NULL)
        MyCoTaskMemFree(pwsz);
    return(hr);

TRACE_ERROR(EnumContainerError);
TRACE_ERROR(ErrorSysAllocString);
}


HRESULT STDMETHODCALLTYPE CCEnroll::enumProviders(
            /* [in] */ LONG  dwIndex,
            /* [in] */ LONG  dwFlags,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrProvName) {
    HRESULT hr;
    LPWSTR pwszProvName  = NULL;

    assert(pbstrProvName != NULL);
    *pbstrProvName = NULL;

    if( (hr = enumProvidersWStr(dwIndex, dwFlags, &pwszProvName)) != S_OK)
        goto EnumProvidersError;

    if( (*pbstrProvName = SysAllocString(pwszProvName)) == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ErrorSysAllocString;
    }

    hr = S_OK;
ErrorReturn:

    if(pwszProvName != NULL)
        MyCoTaskMemFree(pwszProvName);

    return(hr);

TRACE_ERROR(EnumProvidersError);
TRACE_ERROR(ErrorSysAllocString);
}

HRESULT STDMETHODCALLTYPE CCEnroll::createFilePKCS10WStr(
    /* [in] */ LPCWSTR DNName,
    /* [in] */ LPCWSTR Usage,
    /* [in] */ LPCWSTR wszPKCS10FileName) {

    HRESULT     hr;                     
    BSTR        bstrPKCS10  = NULL;

    // get the pkcs 10
    if( (hr = createPKCS10WStrBStr(
            DNName,
            Usage,
            &bstrPKCS10)) != S_OK)
    {
        goto ErrorCreatePKCS10;
    }

    // save it to file
    hr = BStringToFile(bstrPKCS10, wszPKCS10FileName);
    if (S_OK != hr)
    {
        goto ErrorBStringToFile;
    }

    hr = S_OK;
ErrorReturn:
    if(bstrPKCS10 != NULL)
        SysFreeString(bstrPKCS10);

    return(hr);


TRACE_ERROR(ErrorBStringToFile);
TRACE_ERROR(ErrorCreatePKCS10);
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptFilePKCS7WStr(
    /* [in] */ LPCWSTR wszPKCS7FileName)
{
    HRESULT     hr;
    CRYPT_DATA_BLOB  blob;

    ZeroMemory(&blob, sizeof(blob));

    hr = xeStringToBinaryFromFile(
                wszPKCS7FileName,
                &blob.pbData,
                &blob.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    // accept the blob
    hr = acceptPKCS7Blob(&blob);

ErrorReturn:
    if (NULL != blob.pbData)
    {
        MyCoTaskMemFree(blob.pbData);
    }
    return(hr);

TRACE_ERROR(xeStringToBinaryFromFileError)
}

BOOL GetAlgAndBitLen(
    HCRYPTPROV hProv,
    ALG_ID *    pAlg,
    DWORD  *    pdwBitLen,
    DWORD       dwFlags)
{
    static BOOL fNew = TRUE;
    PROV_ENUMALGS_EX    enumAlgsEx;
    PROV_ENUMALGS       enumAlgs;
    DWORD               cb = 0;

    *pAlg = 0;
    *pdwBitLen = 0;

    if(fNew) {

        cb = sizeof(enumAlgsEx);
        if(CryptGetProvParam(
            hProv,
            PP_ENUMALGS_EX,
            (BYTE *) &enumAlgsEx,
            &cb,
            dwFlags)) {

            *pAlg       = enumAlgsEx.aiAlgid;
            *pdwBitLen  = enumAlgsEx.dwMaxLen;

            return(TRUE);        

        } else if(dwFlags != 0)
            fNew = FALSE;
        else
            return(FALSE);
    }

    // otherwise do the old stuff
    cb = sizeof(PROV_ENUMALGS);
    if(CryptGetProvParam(
        hProv,
            PP_ENUMALGS,
        (BYTE *) &enumAlgs,
        &cb,
        dwFlags) ) {

        *pAlg       = enumAlgs.aiAlgid;
        *pdwBitLen  = enumAlgs.dwBitLen;

        return(TRUE);

    }

    return(FALSE);
}    

HRESULT
CreateSMimeExtension(
    IN  HCRYPTPROV   hProv, 
    OUT BYTE       **ppbSMime,
    OUT DWORD       *pcbSMime)
{
#define                     CINCSMIMECAP    20
    HRESULT  hr;

    DWORD                      dwBitLen;
    DWORD                      i;
    DWORD                      cbE;
    BYTE                      *pbE;
    DWORD                      dwFlags;
    PCCRYPT_OID_INFO           pOidInfo = NULL;
    CRYPT_SMIME_CAPABILITIES   smimeCaps;
    DWORD                      crgsmimeCap = 0;
    ALG_ID                     AlgID;
    BYTE                      *pb = NULL;
    DWORD                      cb = 0;

    memset(&smimeCaps, 0, sizeof(CRYPT_SMIME_CAPABILITIES));

    smimeCaps.rgCapability = (PCRYPT_SMIME_CAPABILITY) LocalAlloc(
                LMEM_FIXED, CINCSMIMECAP * sizeof(CRYPT_SMIME_CAPABILITY));
    if (NULL == smimeCaps.rgCapability)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    ZeroMemory(smimeCaps.rgCapability,
               CINCSMIMECAP * sizeof(CRYPT_SMIME_CAPABILITY));
    crgsmimeCap = CINCSMIMECAP;

    dwFlags = CRYPT_FIRST; //first item
    while (GetAlgAndBitLen(hProv, &AlgID, &dwBitLen, dwFlags))
    {
        pbE = NULL;
        cbE = 0;
        dwFlags = 0; //next item

        if(ALG_CLASS_DATA_ENCRYPT == GET_ALG_CLASS(AlgID))
        {
            if(AlgID == CALG_RC2  || AlgID == CALG_RC4)
            {
                // encode the usage
                while (TRUE)
                {
                    if(!CryptEncodeObject(
                            CRYPT_ASN_ENCODING,
                            X509_INTEGER,
                            &dwBitLen,
                            pbE,           // pbEncoded
                            &cbE))
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto CryptEncodeObjectError;
                    }
                    if (NULL != pbE)
                    {
                        break;
                    }
                    pbE = (BYTE *)LocalAlloc(LMEM_FIXED, cbE);
                    if (NULL == pbE)
                    {
                        hr = E_OUTOFMEMORY;
                        goto OutOfMemoryError;
                    }
                }
            }
        } else {
            continue;
        }
        // convert to an oid,
        pOidInfo = xeCryptFindOIDInfo(
                        CRYPT_OID_INFO_ALGID_KEY,
                        (void *) &AlgID,
                        CRYPT_ENCRYPT_ALG_OID_GROUP_ID);
        if(NULL == pOidInfo)
        {
            // don't crash on an error, just say we don't known it.
            continue;
        }
      
        // make sure we have enough room
        if(smimeCaps.cCapability >= crgsmimeCap)
        {
            //increment the size
            crgsmimeCap += CINCSMIMECAP;
            smimeCaps.rgCapability = (PCRYPT_SMIME_CAPABILITY)LocalReAlloc(
                                smimeCaps.rgCapability,
                                crgsmimeCap * sizeof(CRYPT_SMIME_CAPABILITY),
                                LMEM_MOVEABLE);
            if(NULL == smimeCaps.rgCapability)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }

        smimeCaps.rgCapability[smimeCaps.cCapability].pszObjId = (char *) pOidInfo->pszOID;
        smimeCaps.rgCapability[smimeCaps.cCapability].Parameters.pbData = pbE;
        smimeCaps.rgCapability[smimeCaps.cCapability].Parameters.cbData = cbE;
        smimeCaps.cCapability++;
    }

    // encode the capabilities
    while (TRUE)
    {
        if (!CryptEncodeObject(
                        CRYPT_ASN_ENCODING,
                        PKCS_SMIME_CAPABILITIES,
                        &smimeCaps,
                        pb,
                        &cb)) 
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptEncodeObjectError;
        }
        if (NULL != pb)
        {
            break;
        }
        pb = (BYTE *)LocalAlloc(LMEM_FIXED, cb);
    }
    *ppbSMime = pb;
    *pcbSMime = cb;
    pb = NULL;

    hr = S_OK;

ErrorReturn:
    if(NULL != smimeCaps.rgCapability)
    {
        for (i = 0; i < smimeCaps.cCapability; ++i)
        {
            if (NULL != smimeCaps.rgCapability[i].Parameters.pbData)
            {
                LocalFree(smimeCaps.rgCapability[i].Parameters.pbData);
            }
        }
        LocalFree(smimeCaps.rgCapability);
    }
    if(NULL != pb)
    {
        LocalFree(pb);
    }
    return hr;

TRACE_ERROR(CryptEncodeObjectError)
TRACE_ERROR(OutOfMemoryError)
}


BOOL CCEnroll::fIsRequestStoreSafeForScripting(void) {

    DWORD           fRet = FALSE;
    HCERTSTORE      hStore          = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    DWORD           dwCertCnt       = 0;
    WCHAR          *pwszSafety = NULL;
    WCHAR          *pwszMsg = NULL;
    HRESULT         hr;

    if(m_dwEnabledSafteyOptions != 0) {

        // open the request cert store
        if( (hStore = GetStore(StoreREQUEST)) == NULL)
            goto ErrorCertOpenRequestStore;

        // count how many requests in the store
        while(NULL != (pCertContext =  CertEnumCertificatesInStore(
                                                                    hStore,    
                                                                    pCertContext)))
            dwCertCnt++;                                                                

        if(dwCertCnt >= MAX_SAFE_FOR_SCRIPTING_REQUEST_STORE_COUNT)
        {
            hr = xeLoadRCString(hInstanceXEnroll, IDS_NOTSAFEACTION, &pwszSafety);
            if (S_OK != hr)
            {
                goto xeLoadRCStringError;
            }
            hr = xeLoadRCString(hInstanceXEnroll, IDS_REQ_STORE_FULL, &pwszMsg);
            if (S_OK != hr)
            {
                goto xeLoadRCStringError;
            }
     
            switch(MessageBoxU(NULL, pwszMsg, pwszSafety, MB_YESNO | MB_ICONWARNING)) {

                case IDYES:
                    break;

/* Cleaning the store is not to be done by XEnroll as damage can be done to other outstanding requests
                    // clean the request store
                    pCertContext = NULL;
                    while(NULL != (pCertContext =  CertEnumCertificatesInStore(
                                                                    hStore,    
                                                                    pCertContext))) {
                        pCertContextDup = CertDuplicateCertificateContext(pCertContext);
                        CertDeleteCertificateFromStore(pCertContextDup);
                    }
                    
 */

                case IDNO:
                    SetLastError(ERROR_CANCELLED);
                    goto ErrorCancelled;
                    break;

            }
        }
    }   

    fRet = TRUE;
ErrorReturn:
    if (NULL != pwszMsg)
    {
        LocalFree(pwszMsg);
    }
    if (NULL != pwszSafety)
    {
        LocalFree(pwszSafety);
    }
    return(fRet);

TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorCancelled);
TRACE_ERROR(xeLoadRCStringError);
}


#if DBG
void DebugGetContainerSD(HCRYPTPROV hProv)
{
    PSECURITY_DESCRIPTOR  pSD = NULL;
    DWORD                 cbSD;

    while (TRUE)
    {
        if (!CryptGetProvParam(
                hProv,
                PP_KEYSET_SEC_DESCR,
                (BYTE*)pSD,
                &cbSD,
                DACL_SECURITY_INFORMATION))
        {
            break;
        }
        if (NULL != pSD)
        {
            break;
        }
        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);
        if (NULL == pSD)
        {
            break;
        }
    }
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
}
#endif //DBG

//get the current user sids
HRESULT
GetCurrentUserInfo(
    OUT PTOKEN_USER *ppUserInfo,
    OUT BOOL        *pfAdmin)
{
    HRESULT  hr;
    PTOKEN_USER   pUserInfo = NULL;
    DWORD         dwSize = 0;
    HANDLE        hToken = NULL;
    HANDLE        hDupToken = NULL;
    PSID          psidAdministrators = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    HANDLE hThread;
    HANDLE hProcess;

    //init
    *pfAdmin = FALSE;

    if (!AllocateAndInitializeSid(
                            &siaNtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdministrators))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto AllocateAndInitializeSidError;
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetCurrentThreadError;
    }

    // Get the access token for current thread
    if (!OpenThreadToken(
            hThread, 
            TOKEN_QUERY | TOKEN_DUPLICATE, 
            FALSE,
            &hToken))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        if(HRESULT_FROM_WIN32(ERROR_NO_TOKEN) != hr)
        {
            goto OpenThreadTokenError;
        }
        //get process token instead
        hProcess = GetCurrentProcess();
        if (NULL == hProcess)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto GetCurrentProcessError;
        }

        hToken = NULL;
        if (!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &hToken))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto OpenProcessTokenError;
        }
    }

    // CheckTokenMembership must operate on impersonation token, so make one
    if (!DuplicateToken(hToken, SecurityIdentification, &hDupToken))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto DuplicateTokenError;
    }

    if (!MyCheckTokenMembership(hDupToken, psidAdministrators, pfAdmin))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CheckTokenMembershipError;
    }

    //get current user sid
    while (TRUE)
    {
        if (!GetTokenInformation(
                hToken,
                TokenUser,
                pUserInfo,
                dwSize,
                &dwSize))
        {
            if (NULL != pUserInfo ||
                ERROR_INSUFFICIENT_BUFFER != GetLastError())
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto GetTokenInformationError;
            }
        }

        if (NULL != pUserInfo)
        {
            //done
            break;
        }
        pUserInfo = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, dwSize);
        if (NULL == pUserInfo)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    if (NULL != ppUserInfo)
    {
        *ppUserInfo = pUserInfo;
        pUserInfo = NULL;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pUserInfo)
    {
        LocalFree(pUserInfo);
    }
    if (NULL != hToken)
    {
        CloseHandle(hToken);
    }
    if (NULL != hDupToken)
    {
        CloseHandle(hDupToken);
    }
    if (NULL != psidAdministrators)
    {
        FreeSid(psidAdministrators);
    }

    return hr;

TRACE_ERROR(LocalAllocError)
TRACE_ERROR(GetTokenInformationError)
TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(GetCurrentProcessError)
TRACE_ERROR(CheckTokenMembershipError)
TRACE_ERROR(DuplicateTokenError)
TRACE_ERROR(OpenThreadTokenError)
TRACE_ERROR(GetCurrentThreadError)
TRACE_ERROR(AllocateAndInitializeSidError)
}

//set key container with create owner only ACE
HRESULT
SetKeyContainerSecurity(
    HCRYPTPROV hProv,
    DWORD      dwFlags)
{
    HRESULT               hr;
    PSECURITY_DESCRIPTOR  pNewSD = NULL;
    PSECURITY_DESCRIPTOR  pSD = NULL;
    DWORD                 cbSD;
    ACL_SIZE_INFORMATION  AclInfo;

    PTOKEN_USER           pUserInfo = NULL;
    PACL                  pNewAcl = NULL;
    LPVOID pAce;
    DWORD  dwIndex;
    BYTE   AceType;
    PACL   pAcl;
    BOOL   fDacl = TRUE;
    BOOL   fDef = FALSE;
    BOOL   fAdmin;
    BOOL   fKeepSystemSid;
    BOOL   fMachineKeySet = (0x0 != (dwFlags & CRYPT_MACHINE_KEYSET)) ?
                            TRUE : FALSE;

    PSID                      pSidSystem = NULL;
    SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;

    //get the current user info
    hr = GetCurrentUserInfo(&pUserInfo, &fAdmin);
    if (S_OK != hr)
    {
        goto GetCurrentUserInfoError;
    }

    //if admin, skip any acl changes, ???
    if (fAdmin)
    {
        goto done;
    }

    //get the current sd from key container
    while (TRUE)
    {
        if (!CryptGetProvParam(
                hProv,
                PP_KEYSET_SEC_DESCR,
                (BYTE*)pSD,
                &cbSD,
                DACL_SECURITY_INFORMATION))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptGetProvParamError;
        }
        if (NULL != pSD)
        {
            break;
        }
        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);
        if (NULL == pSD)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    //get acl from sd
    if (!GetSecurityDescriptorDacl(
            pSD,
            &fDacl,
            &pAcl,
            &fDef))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetSecurityDescriptorDaclError;
    }
    if (!fDacl)
    {
        //if no dacl, quit
        hr = MY_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto GetSecurityDescriptorDaclError;
    }
    if (NULL == pAcl)
    {
        //this means allow everyone access the key which is unexpected,
        hr = E_UNEXPECTED;
        goto UnexpectedError;
    }

    //get acl info
    if (!GetAclInformation(
            pAcl,
            &AclInfo,
            sizeof(AclInfo),
            AclSizeInformation))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto GetAclInformationError;
    }

    //allocate enough for new dacl since we just remove aces
    pNewAcl = (PACL)LocalAlloc(LMEM_ZEROINIT, AclInfo.AclBytesInUse);
    if (NULL == pNewAcl)
    {
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    }
    if (!InitializeAcl(pNewAcl, AclInfo.AclBytesInUse, ACL_REVISION))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto InitializeAclError;
    }

    fKeepSystemSid = fAdmin && fMachineKeySet;
    if (fKeepSystemSid)
    {
        //get system sid to later use
        if (!AllocateAndInitializeSid(
                            &siaNtAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &pSidSystem))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto AllocateAndInitializeSidError;
        }
    }

    //go through each ace, get only current user aces
    for (dwIndex = 0; dwIndex < AclInfo.AceCount; ++dwIndex)
    {
        if (!GetAce(pAcl, dwIndex, &pAce))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto GetAceError;
        }
        AceType = ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType;
        if (ACCESS_ALLOWED_ACE_TYPE == AceType)
        {
            if (EqualSid(pUserInfo->User.Sid,
                         (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart)) ||
                (fKeepSystemSid &&
                 EqualSid(pSidSystem,
                          (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart))))
            {
                //add current user ace or system ace into new acl
                if (!AddAccessAllowedAce(
                        pNewAcl,
                        ACL_REVISION,
                        ((PACCESS_ALLOWED_ACE)pAce)->Mask,
                        (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart)))
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto AddAccessAllowedAceError;
                }
            }
        }
        else if (ACCESS_DENIED_ACE_TYPE == AceType)
        {
            //add all deny ace into new acl
            if (!AddAccessDeniedAce(
                    pNewAcl,
                    ACL_REVISION,
                    ((PACCESS_ALLOWED_ACE)pAce)->Mask,
                    (PSID)&(((PACCESS_DENIED_ACE)pAce)->SidStart)))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto AddAccessDeniedAceError;
            }
        }
    }

    // initialize a security descriptor.  
    pNewSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pNewSD == NULL)
    { 
        hr = E_OUTOFMEMORY;
        goto LocalAllocError;
    } 
 
    if (!InitializeSecurityDescriptor(pNewSD, SECURITY_DESCRIPTOR_REVISION))
    {  
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto InitializeSecurityDescriptorError;
    } 
 
    // add the ACL to the security descriptor. 
    if (!SetSecurityDescriptorDacl(
            pNewSD, 
            TRUE,     // fDaclPresent flag   
            pNewAcl, 
            FALSE))   // not a default DACL 
    {  
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto SetSecurityDescriptorDaclError;
    } 

    //ok, set sd to be protected
    if (!MySetSecurityDescriptorControl(
            pNewSD,
            SE_DACL_PROTECTED,
            SE_DACL_PROTECTED))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto SetSecurityDescriptorControlError;
    }

    if (!IsValidSecurityDescriptor(pNewSD))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto IsValidSecurityDescriptorError;
    }

#if DBG
    DebugGetContainerSD(hProv); //just for ntsd debug
#endif

    //now we just set it
    if (!CryptSetProvParam(
            hProv,
            PP_KEYSET_SEC_DESCR,
            (BYTE*)pNewSD,
            DACL_SECURITY_INFORMATION))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CryptSetProvParamError;
    }

#if DBG
    DebugGetContainerSD(hProv); //just for ntsd debug
#endif

done:
    hr = S_OK;
ErrorReturn:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    if (NULL != pUserInfo) 
    {
        LocalFree(pUserInfo);
    }
    if (NULL != pNewAcl) 
    {
        LocalFree(pNewAcl);
    }
    if (NULL != pNewSD) 
    {
        LocalFree(pNewSD);
    }
    if (NULL != pSidSystem)
    {
        FreeSid(pSidSystem);
    }
    return hr;

TRACE_ERROR(CryptSetProvParamError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(AddAccessAllowedAceError)
TRACE_ERROR(AddAccessDeniedAceError)
TRACE_ERROR(GetAceError)
TRACE_ERROR(GetCurrentUserInfoError)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(GetAclInformationError)
TRACE_ERROR(GetSecurityDescriptorDaclError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptGetProvParamError)
TRACE_ERROR(SetSecurityDescriptorControlError)
TRACE_ERROR(IsValidSecurityDescriptorError)
TRACE_ERROR(AllocateAndInitializeSidError)
TRACE_ERROR(UnexpectedError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::createPKCS10WStr(
    /* [in] */ LPCWSTR DNName,
    /* [in] */ LPCWSTR wszPurpose,
    /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob)
{
    #define EndExt      5

    #define EndAttr     6

    HCRYPTPROV                  hProv           = NULL;
    HCRYPTKEY                   hKey            = NULL;

    CERT_REQUEST_INFO           reqInfo;

    CERT_EXTENSIONS             Extensions;
    PCERT_EXTENSION             pExtCur         = NULL;
    PCERT_EXTENSION             rgExtension     = NULL;
    CRYPT_ATTRIBUTE             rgAttribute[EndAttr];
    CRYPT_ATTR_BLOB             blobExt;
    CRYPT_ATTR_BLOB             blobCSPAttr;
    CRYPT_CSP_PROVIDER          CSPProvider;
    CRYPT_ATTR_BLOB             blobOSVAttr;
    CRYPT_ATTR_BLOB             blobSMIMEPKCS7;
    CERT_NAME_VALUE             cnvOSVer;
    OSVERSIONINFO               osvInfo;

    DWORD                       iExt            = 0;
    CRYPT_BIT_BLOB              bbKeyUsage;
    BYTE                        bKeyUsage;

    CERT_SIGNED_CONTENT_INFO    SignatureInfo;

    HRESULT                     hr              = S_OK;
    DWORD                       errBefore       = GetLastError();

    PCCERT_CONTEXT              pCertContext    = NULL;
    HCERTSTORE                  hStore          = NULL;
    DWORD                       ssFlags         = 0;

    HANDLE                      hFile           = NULL;
    CRYPT_DATA_BLOB             blobData;

    DWORD                       cb              = 0;
    char *                      pszPurpose       = NULL;
    char *                      szStart         = NULL;
    char *                      szEnd           = NULL;
    char                        szVersion[45]   = {0};

    BOOL                        fAddCodeSign    = FALSE;
    DWORD                       cPassedEKU      = 0;
    DWORD                       i               = 0;
    BOOL                        fRet;
    BYTE                       *pbSMime = NULL;
    BYTE                       *pbKU = NULL;
    BYTE                       *pbEKU = NULL;
    PPROP_STACK                 pProp;
    CRYPT_ATTR_BLOB             blobClientId;
    DWORD                       cPublicKeyInfo = 0;
    BYTE                       *pbSubjectKeyHashExtension = NULL;
    DWORD                       cbSubjectKeyHashExtension = 0;
    DWORD                       dwErr;

    //
    // Declaration of extensions we need.  The extensions with matching OIDs will be added
    // to the temporary cert context created by this method. 
    // 
    LPSTR rgszExtensionOIDs[] = { 
        szOID_ENROLL_CERTTYPE_EXTENSION,
        szOID_CERTIFICATE_TEMPLATE
    }; 

    // An array of the extensions we need to add to the certificate 
    CERT_EXTENSION  rgNeededExtensions[sizeof(rgszExtensionOIDs) / sizeof(LPSTR)]; 

    // Need to put the array in a CERT_EXTENSIONS struct. 
    CERT_EXTENSIONS ceExtensions; 
    ceExtensions.rgExtension = &rgNeededExtensions[0]; 
    ceExtensions.cExtension  = 0; 

    CRYPT_KEY_PROV_INFO         keyProvInfoT;
        CERT_ENHKEY_USAGE                   enhKeyUsage;

        CRYPT_DATA_BLOB             blobPKCS7;
        CRYPT_DATA_BLOB             blobRenewAttr;
        RequestFlags                requestFlags;
        CRYPT_DATA_BLOB             requestInfoBlob;
        CRYPT_DATA_BLOB             blobRenewalCert;

        ALG_ID                      rgAlg[2];
        PCCRYPT_OID_INFO            pOidInfo        = NULL;

    EnterCriticalSection(&m_csXEnroll);

    // for the life of our procedure.
    SetLastError(ERROR_SUCCESS);

    assert(pPkcs10Blob != NULL);

    // clean out the PKCS 10
    memset(&Extensions, 0, sizeof(CERT_EXTENSIONS));
    memset(&rgAttribute, 0, sizeof(rgAttribute));
    memset(&reqInfo, 0, sizeof(CERT_REQUEST_INFO));
    memset(&SignatureInfo, 0, sizeof(SignatureInfo));
    memset(&blobData, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&enhKeyUsage, 0, sizeof(CERT_ENHKEY_USAGE ));
    memset(pPkcs10Blob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&blobRenewAttr, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&requestFlags, 0, sizeof(RequestFlags));
    memset(&requestInfoBlob, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&CSPProvider, 0, sizeof(CRYPT_CSP_PROVIDER));
    memset(&cnvOSVer, 0, sizeof(CERT_NAME_VALUE));
    memset(&osvInfo, 0, sizeof(OSVERSIONINFO));
    memset(&blobSMIMEPKCS7, 0, sizeof(CRYPT_ATTR_BLOB));
    memset(&rgNeededExtensions[0], 0, sizeof(rgNeededExtensions)); 
    ZeroMemory(&blobExt, sizeof(blobExt));
    memset(&blobCSPAttr, 0, sizeof(CRYPT_ATTR_BLOB));
    memset(&blobOSVAttr, 0, sizeof(CRYPT_ATTR_BLOB));
    memset(&blobClientId, 0, sizeof(CRYPT_ATTR_BLOB));

    reqInfo.dwVersion = CERT_REQUEST_V1;

    // check to see if we are safe for scripting
    if( !fIsRequestStoreSafeForScripting())
        goto ErrorRequestStoreSafeForScripting;

    if(!m_fUseExistingKey)
    {
        // attempt to get a new keyset
        if((hProv = GetProv(CRYPT_NEWKEYSET)) == NULL) {

            // in the hardware token case, there may only be a finite number of containers
            // if you run out, then use the default container. The Default container can
            // be specified by either a NULL or empty container name.
            // this is behavior requested by the smart cards, in particular smart card enrollment.
            if( m_fReuseHardwareKeyIfUnableToGenNew &&
                GetLastError() == NTE_TOKEN_KEYSET_STORAGE_FULL) {

                    // set it to the default container name
                    if( m_keyProvInfo.pwszContainerName != wszEmpty )
                        MyCoTaskMemFree(m_keyProvInfo.pwszContainerName);
                    m_keyProvInfo.pwszContainerName = wszEmpty;

                    // say we want to use an exiting key.
                    m_fUseExistingKey = TRUE;
            }
            else
                goto ErrorCryptAcquireContext;
        }
    }

    // if we are to use an existing key
    if(m_fUseExistingKey) {

        if((hProv = GetProv(0)) == NULL)
            goto ErrorCryptAcquireContext;
    }

    // we have the keyset, now make sure we have the key gen'ed
    if(!CryptGetUserKey(
                hProv,
                m_keyProvInfo.dwKeySpec,
                &hKey))
    {
        //in case of smartcard csp, above call could be failed from
        //PIN Cancel button, don't go next to try genkey
        //also notice different csp could return different cancel errors
        dwErr = GetLastError();
        if (SCARD_W_CANCELLED_BY_USER == dwErr ||
            ERROR_CANCELLED == dwErr ||
            ERROR_ACCESS_DENIED == dwErr)
        {
            goto CryptGetUserKeyCancelError;
        }
            
        // doesn't exist so gen it
        assert(hKey == NULL);
        if(!CryptGenKey(    hProv,
                            m_keyProvInfo.dwKeySpec,
                            m_dwGenKeyFlags | CRYPT_ARCHIVABLE,
                            &m_hCachedKey) )
        {
            //could be cancelled by user? don't make next try
            dwErr = GetLastError();
            if (SCARD_W_CANCELLED_BY_USER == dwErr ||
                ERROR_CANCELLED == dwErr ||
                ERROR_ACCESS_DENIED == dwErr)
            {
                goto ErrorCryptGenKey;
            }

            //this error may be caused by not supporting CRYPT_ARCHIVABLE
            //we should check against error NTE_BAD_FLAGS but I doubt all
            //csps return consistent error code
            //let's try one more time without archivable flag
            assert(NULL == m_hCachedKey);
            DWORD dwGenKeyFlags = m_dwGenKeyFlags;
            if (NULL != m_PrivateKeyArchiveCertificate && m_fNewRequestMethod)
            {
                //want key archival, enforce exportable
                dwGenKeyFlags |= CRYPT_EXPORTABLE;
            }
            if (!CryptGenKey(
                        hProv,
                        m_keyProvInfo.dwKeySpec,
                        dwGenKeyFlags,
                        &hKey))
            {
                goto ErrorCryptGenKey;
            }
        }
    }

    //try to set key container ACL with owner ACE only
    hr = SetKeyContainerSecurity(hProv, m_keyProvInfo.dwFlags);
#if DBG
    if (S_OK != hr)
    {
        goto SetKeyContainerSecurityError;
    }
#endif //DBG
    hr = S_OK; //free build, no error checking here, if fails, live with it

    if (NULL != hKey)
    {
        // don't need the hKey on existing key, so get rid of it
        CryptDestroyKey(hKey);
    }
    if ((NULL == m_PrivateKeyArchiveCertificate || !m_fNewRequestMethod) &&
        NULL != m_hCachedKey)
    {
        //we don't need cache it, destroy it as soon as key is gen(ed)
        CryptDestroyKey(m_hCachedKey);
        m_hCachedKey = NULL;
    }

    // now get the public key out into m_pPublicKeyInfo
    // m_pPublicKeyInfo is internal use for cache
    if (NULL != m_pPublicKeyInfo)
    {
        LocalFree(m_pPublicKeyInfo);
        m_pPublicKeyInfo = NULL;
    }
    while (TRUE)
    {
        if(!CryptExportPublicKeyInfo(hProv,
                            m_keyProvInfo.dwKeySpec,
                            X509_ASN_ENCODING,
                            m_pPublicKeyInfo,
                            &cPublicKeyInfo))
        {
            goto ErrorCryptExportPublicKeyInfo;
        }
        if (NULL != m_pPublicKeyInfo)
        {
            break;
        }
        m_pPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO)LocalAlloc(
                                LMEM_FIXED, cPublicKeyInfo);
        if (NULL == m_pPublicKeyInfo)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    reqInfo.SubjectPublicKeyInfo = *m_pPublicKeyInfo;

    // get the Subject DN only if one is specified
    reqInfo.Subject.pbData = NULL;
    while (TRUE)
    {
        if( !MyCertStrToNameW(
                CRYPT_ASN_ENCODING,
                DNName,
                0 | m_dwT61DNEncoding,
                NULL,
                reqInfo.Subject.pbData,
                &reqInfo.Subject.cbData,
                NULL))
        {
            if (CRYPT_E_INVALID_X500_STRING == GetLastError() &&
                L'\0' == DNName[0])
            {
                //this is likely on W95, W98, or NT4 with some IEs
                //crypt32 doesn't support empty DN conversion
                //hard code here
                reqInfo.Subject.cbData = 2;
                reqInfo.Subject.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                                reqInfo.Subject.cbData);
                if (NULL == reqInfo.Subject.pbData)
                {        
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                reqInfo.Subject.pbData[0] = 0x30;
                reqInfo.Subject.pbData[1] = 0x0;
                //done
                break;
            }
            else
            {
               goto ErrorCertStrToNameW;
            }
        }
        if (NULL != reqInfo.Subject.pbData)
        {
            break;
        }
        reqInfo.Subject.pbData = (BYTE *)LocalAlloc(LMEM_FIXED,
                                            reqInfo.Subject.cbData);
        if (NULL == reqInfo.Subject.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // allocate room for the extensions
    cb = (CountStackExtension(m_fNewRequestMethod) + EndExt) * sizeof(CERT_EXTENSION);
    rgExtension = (PCERT_EXTENSION)LocalAlloc(LMEM_FIXED, cb);
    if (NULL == rgExtension)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    memset(rgExtension, 0, cb);
    cb = 0;

    if (!m_fUseClientKeyUsage)
    {
        // Make Key Usage
        rgExtension[iExt].pszObjId = szOID_KEY_USAGE;
        rgExtension[iExt].fCritical = TRUE;

        // AT_SIGNATURE
        if( m_keyProvInfo.dwKeySpec == AT_SIGNATURE)
            bKeyUsage =
                CERT_DIGITAL_SIGNATURE_KEY_USAGE |
                CERT_NON_REPUDIATION_KEY_USAGE;

        //AT_KEYEXCHANGE, limited for EMAIL single use
        // email may not work if signature is present
        else if(m_fLimitExchangeKeyToEncipherment)
        bKeyUsage =
                CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                CERT_DATA_ENCIPHERMENT_KEY_USAGE;

        // AT_KEYEXCHANGE and AT_SIGNATURE dual key 
        // This is the normal case for AT_KEYEXCHANGE since CAPI will sign with this.
        else 
            bKeyUsage =
                CERT_KEY_ENCIPHERMENT_KEY_USAGE     |
                CERT_DATA_ENCIPHERMENT_KEY_USAGE    |
                CERT_DIGITAL_SIGNATURE_KEY_USAGE    |
                CERT_NON_REPUDIATION_KEY_USAGE;

        bbKeyUsage.pbData = &bKeyUsage;
        bbKeyUsage.cbData = 1;
        bbKeyUsage.cUnusedBits = 1;

        // encode the usage
        rgExtension[iExt].Value.pbData = NULL;
        while (TRUE)
        {
            if(!CryptEncodeObject(
                    CRYPT_ASN_ENCODING,
                    X509_KEY_USAGE,
                    &bbKeyUsage,
                    pbKU,
                    &rgExtension[iExt].Value.cbData))
            {
                goto ErrorEncodeKeyUsage;
            }
            if (NULL != pbKU)
            {
                rgExtension[iExt].Value.pbData = pbKU;
                //done
                break;
            }
            pbKU = (BYTE *)LocalAlloc(LMEM_FIXED, rgExtension[iExt].Value.cbData);
            if (NULL == pbKU)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        iExt++;
    }

    if(m_fEnableSMIMECapabilities)
    {
        // add SMIME extension for symmetric algorithms
        rgExtension[iExt].pszObjId = szOID_RSA_SMIMECapabilities;
        rgExtension[iExt].fCritical = FALSE;
        hr = CreateSMimeExtension(
                    hProv,
                    &pbSMime,
                    &rgExtension[iExt].Value.cbData);
        if (S_OK != hr)
        {
            goto CreateSMimeExtensionError;
        }
        rgExtension[iExt].Value.pbData = pbSMime;
        iExt++;
    }

    if (m_fHonorIncludeSubjectKeyID && m_fIncludeSubjectKeyID)
    {
        hr = myCreateSubjectKeyIdentifierExtension(
                    m_pPublicKeyInfo,
                    &pbSubjectKeyHashExtension,
                    &cbSubjectKeyHashExtension);
        if (S_OK != hr)
        {
            goto myCreateSubjectKeyIdentifierExtensionError;
        }
        //add subject key ID hash extension into PKCS10
        rgExtension[iExt].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
        rgExtension[iExt].fCritical = FALSE;
        rgExtension[iExt].Value.pbData = pbSubjectKeyHashExtension;
        rgExtension[iExt].Value.cbData = cbSubjectKeyHashExtension;
        iExt++;
    }

    if(wszPurpose != NULL) {
        cb = 0;
        while (TRUE)
        {
            if(0 == (cb = WideCharToMultiByte(
                            0, 0, wszPurpose, -1, pszPurpose, cb, NULL, NULL)))
            {
                SetLastError(ERROR_OUTOFMEMORY);
                goto ErrorCantConvertPurpose;
            }
            if (NULL != pszPurpose)
            {
                break;
            }
            pszPurpose = (CHAR*)LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pszPurpose)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        szStart = pszPurpose;

        // remove leading blanks
        while(*szStart == ',' || *szStart == ' ')
            *szStart++ = '\0';

        while( szStart[0] != '\0' ) {

            // find the next string
            szEnd = szStart;
            while(*szEnd != ',' && *szEnd != ' ' && *szEnd != '\0')
                szEnd++;

            // remove trailing blanks
            while(*szEnd == ',' || *szEnd == ' ')
                *szEnd++ = '\0';

            enhKeyUsage.cUsageIdentifier++;

            // see if this implies codesigning
            fAddCodeSign |= !strcmp(szStart, SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) ||
                            !strcmp(szStart, SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID);

            // go to next string
            szStart = szEnd;
        }

        // count the codesign EKU once
        cPassedEKU = enhKeyUsage.cUsageIdentifier;
        if(fAddCodeSign)
            enhKeyUsage.cUsageIdentifier++;

        // encode the extension
        if(enhKeyUsage.cUsageIdentifier != 0) {

            // allocate the EKU array
            enhKeyUsage.rgpszUsageIdentifier = (LPSTR *)LocalAlloc(LMEM_FIXED,
                            enhKeyUsage.cUsageIdentifier * sizeof(LPSTR));
            if (NULL == enhKeyUsage.rgpszUsageIdentifier)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }

            // add the EKU's
            szStart = pszPurpose;
            for(i=0; i<cPassedEKU; i++) {

                while(*szStart == '\0')
                    szStart++;

                enhKeyUsage.rgpszUsageIdentifier[i] = szStart;

                while(*szStart != '\0')
                    szStart++;

            }

            // add the code sign EKU
            if(fAddCodeSign)
                enhKeyUsage.rgpszUsageIdentifier[enhKeyUsage.cUsageIdentifier - 1] = szOID_PKIX_KP_CODE_SIGNING;

            // Deal with the policy, or purpose
            rgExtension[iExt].pszObjId = szOID_ENHANCED_KEY_USAGE ;
            rgExtension[iExt].fCritical = FALSE;

            // encode the enhanced key usage
            rgExtension[iExt].Value.cbData = 0;
            while (TRUE)
            {
                if(!CryptEncodeObject(
                        CRYPT_ASN_ENCODING, X509_ENHANCED_KEY_USAGE,
                        &enhKeyUsage,
                        pbEKU,           // pbEncoded
                        &rgExtension[iExt].Value.cbData))
                {
                    goto ErrorEncodeEnhKeyUsage;
                }
                if (NULL != pbEKU)
                {
                    //got it, done
                    rgExtension[iExt].Value.pbData = pbEKU;
                    break;
                }
                pbEKU = (BYTE *)LocalAlloc(LMEM_FIXED,
                                           rgExtension[iExt].Value.cbData);
                if (NULL == pbEKU)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
            }
            iExt++;
        }
    }

    assert(EndExt >= iExt);

    // now add all of the user defined extensions
    pExtCur = NULL;
    while(NULL != (pExtCur =  EnumStackExtension(pExtCur, m_fNewRequestMethod)) ) {
        rgExtension[iExt] = *pExtCur;
        iExt++;
    }

    // fill in the extensions structure
    Extensions.cExtension = iExt;
    Extensions.rgExtension = rgExtension;

    // encode the extensions
    reqInfo.cAttribute = 0;
    reqInfo.rgAttribute = rgAttribute;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_EXTENSIONS,
                &Extensions,
                blobExt.pbData,           // pbEncoded
                &blobExt.cbData))
        {
            goto ErrorEncodeExtensions;
        }
        if (NULL != blobExt.pbData)
        {
            //got it, done
            break;
        }
        blobExt.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, blobExt.cbData);
        if (NULL == blobExt.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    
    if (m_fOID_V2)
    {
        //use new rsa oid
        rgAttribute[reqInfo.cAttribute].pszObjId = szOID_RSA_certExtensions;
    }
    else
    {
        //use microsoft oid for w2k clients
        rgAttribute[reqInfo.cAttribute].pszObjId = szOID_CERT_EXTENSIONS;
    }
    rgAttribute[reqInfo.cAttribute].cValue = 1;
    rgAttribute[reqInfo.cAttribute].rgValue = &blobExt;

    // put in the CSP attribute
    if( !GetSignatureFromHPROV(
       hProv,
       &CSPProvider.Signature.pbData,
       &CSPProvider.Signature.cbData
       ) )
        goto ErrorGetSignatureFromHPROV;

    CSPProvider.pwszProviderName    = m_keyProvInfo.pwszProvName;
    CSPProvider.dwKeySpec           = m_keyProvInfo.dwKeySpec;

    while (TRUE)
    {
        if( !CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                szOID_ENROLLMENT_CSP_PROVIDER,
                &CSPProvider,
                blobCSPAttr.pbData,           // pbEncoded
                &blobCSPAttr.cbData))
        {
            goto ErrorEncodeCSPAttr;
        }
        if (NULL != blobCSPAttr.pbData)
        {
            //got it, done
            break;
        }
        blobCSPAttr.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, blobCSPAttr.cbData);
        if (NULL == blobCSPAttr.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    reqInfo.cAttribute++;
    rgAttribute[reqInfo.cAttribute].pszObjId = szOID_ENROLLMENT_CSP_PROVIDER;
    rgAttribute[reqInfo.cAttribute].cValue = 1;
    rgAttribute[reqInfo.cAttribute].rgValue = &blobCSPAttr;

    // get the OSVersion
    osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionExA(&osvInfo))
        goto ErrorGetVersionEx;
        
    wsprintfA(szVersion, "%d.%d.%d.%d", 
        osvInfo.dwMajorVersion,
        osvInfo.dwMinorVersion,
        osvInfo.dwBuildNumber,
        osvInfo.dwPlatformId);

    cnvOSVer.dwValueType = CERT_RDN_IA5_STRING;
    cnvOSVer.Value.cbData = strlen(szVersion);
    cnvOSVer.Value.pbData = (BYTE *) szVersion;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_ANY_STRING,
                &cnvOSVer,
                blobOSVAttr.pbData,           // pbEncoded
                &blobOSVAttr.cbData))
        {
            goto ErrorEncodeOSVAttr;
        }
        if (NULL != blobOSVAttr.pbData)
        {
            //got it, done
            break;
        }
        blobOSVAttr.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, blobOSVAttr.cbData);
        if (NULL == blobOSVAttr.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    reqInfo.cAttribute++;
    rgAttribute[reqInfo.cAttribute].pszObjId = szOID_OS_VERSION;
    rgAttribute[reqInfo.cAttribute].cValue = 1;
    rgAttribute[reqInfo.cAttribute].rgValue = &blobOSVAttr;

    // put in the renewal cert if present
    if(m_pCertContextRenewal != NULL && m_fHonorRenew) {

        reqInfo.cAttribute++;

        blobRenewAttr.pbData = m_pCertContextRenewal->pbCertEncoded;
        blobRenewAttr.cbData = m_pCertContextRenewal->cbCertEncoded;

        rgAttribute[reqInfo.cAttribute].pszObjId = szOID_RENEWAL_CERTIFICATE;
        rgAttribute[reqInfo.cAttribute].cValue = 1;
        rgAttribute[reqInfo.cAttribute].rgValue = &blobRenewAttr;
    }

    if (m_fNewRequestMethod && XECI_DISABLE != m_lClientId)
    {
        //put client id as attribute
        hr = myEncodeRequestClientAttributeFromClientId(
                    m_lClientId,
                    &blobClientId.pbData,
                    &blobClientId.cbData);
        if (S_OK != hr)
        {
            //for any reasons, don't include client ID
            hr = put_ClientId(XECI_DISABLE);
            if (S_OK != hr)
            {
                goto putClientIdError;
            }
        }
        else
        {
            reqInfo.cAttribute++;
            rgAttribute[reqInfo.cAttribute].pszObjId = szOID_REQUEST_CLIENT_INFO;
            rgAttribute[reqInfo.cAttribute].cValue = 1;
            rgAttribute[reqInfo.cAttribute].rgValue = &blobClientId;
        }
    }

    // NOTE: On error we always return BAD ALGID
    // this is because sometimes we get an no more data enum error
    // that doesn't help.
    // get the signature oid
    if( !GetCapiHashAndSigAlgId(rgAlg) ) {
        SetLastError(NTE_BAD_ALGID);
        goto ErrorGetCapiHashAndSigAlgId;
    }

    // Convert to an oid
    if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_SIGN_KEY,
        (void *) rgAlg,
        CRYPT_SIGN_ALG_OID_GROUP_ID)) ) ) {
        SetLastError(NTE_BAD_ALGID);
        goto ErrorCryptFindOIDInfo;
    }

    // we always know we have at least 1 attribute, and we have been zero based, now go to 1 based.
    reqInfo.cAttribute++;
    SignatureInfo.SignatureAlgorithm.pszObjId = (char *) pOidInfo->pszOID;
#if DBG
    //SignatureInfo.ToBeSigned.pbData should be null at the first
    assert(NULL == SignatureInfo.ToBeSigned.pbData);
#endif
    // encode PKCS10
    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_CERT_REQUEST_TO_BE_SIGNED,
                &reqInfo,
                SignatureInfo.ToBeSigned.pbData,           // pbEncoded
                &SignatureInfo.ToBeSigned.cbData))
        {
            goto ErrorEncodePKCS10ToBeSigned;
        }
        if (NULL != SignatureInfo.ToBeSigned.pbData)
        {
            //done
            break;
        }
        SignatureInfo.ToBeSigned.pbData = (BYTE *)
            LocalAlloc(LMEM_FIXED, SignatureInfo.ToBeSigned.cbData);
        if (NULL == SignatureInfo.ToBeSigned.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // create the signature Info
    // Don't care if xchange or signature key in dwkeySpec because
    // we are signing with the key that is in the PKCS10
#if DBG
    assert(NULL == SignatureInfo.Signature.pbData);
#endif
    while (TRUE)
    {
        if(!CryptSignCertificate(
                hProv,
                m_keyProvInfo.dwKeySpec,
                CRYPT_ASN_ENCODING,
                SignatureInfo.ToBeSigned.pbData,
                SignatureInfo.ToBeSigned.cbData,
                &SignatureInfo.SignatureAlgorithm,
                NULL,                   // reserved
                SignatureInfo.Signature.pbData, // pbSignature
                &SignatureInfo.Signature.cbData))
        {
            goto ErrorCryptSignCertificatePKCS10;
        }
        if (NULL != SignatureInfo.Signature.pbData)
        {
            //done
            break;
        }
        SignatureInfo.Signature.pbData = (BYTE *)
            LocalAlloc(LMEM_FIXED, SignatureInfo.Signature.cbData);
        if (NULL == SignatureInfo.Signature.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // encode the final signed request
    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_CERT,
            &SignatureInfo,
            NULL,
            &pPkcs10Blob->cbData
            )                               ||
        (pPkcs10Blob->pbData = (BYTE *)
            MyCoTaskMemAlloc(pPkcs10Blob->cbData)) == NULL     ||
        !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_CERT,
            &SignatureInfo,
            pPkcs10Blob->pbData,
            &pPkcs10Blob->cbData
            ) ) {
        goto ErrorEncodePKCS10Request;
    }

    // go ahead and make the pkcs 7
    if((m_pCertContextRenewal != NULL ||
        m_pCertContextSigner  != NULL) &&
       m_fHonorRenew &&
       !m_fCMCFormat) //if CMC, don't make pkcs7
    {

        // create a pkcs7 signed by the old cert
        if(S_OK != CreatePKCS7RequestFromRequest(
            pPkcs10Blob,
            (NULL != m_pCertContextRenewal) ? m_pCertContextRenewal :
                                              m_pCertContextSigner,
            &blobPKCS7) )
            goto ErrorCreatePKCS7RARequestFromPKCS10;

        assert(pPkcs10Blob->pbData != NULL);
        MyCoTaskMemFree(pPkcs10Blob->pbData);
        *pPkcs10Blob = blobPKCS7;
        memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));

    }
 
    ssFlags = CERT_CREATE_SELFSIGN_NO_SIGN;
    if(m_wszPVKFileName[0] != 0)
        ssFlags |= CERT_CREATE_SELFSIGN_NO_KEY_INFO;

    // Get the cert extensions we wish to add to the certificate. 
    // Search for the extensions we need.  
    {
        PCERT_EXTENSION pCertExtCertTypeName = NULL; 
        while(NULL != (pCertExtCertTypeName =  EnumStackExtension(pCertExtCertTypeName, m_fNewRequestMethod)) ) {
            for (DWORD dTmp = 0; dTmp < sizeof(rgszExtensionOIDs) / sizeof(LPSTR); dTmp++) { 
                if (0 == strcmp(rgszExtensionOIDs[dTmp], pCertExtCertTypeName->pszObjId))
                    rgNeededExtensions[(ceExtensions.cExtension)++] = *pCertExtCertTypeName; 
            }
        }

        // Even if we didn't find all of the extensions we wanted, continue ... 
    }

    assert(pCertContext == NULL);
    pCertContext = MyCertCreateSelfSignCertificate(
        hProv,
        &reqInfo.Subject,
        ssFlags,
        &m_keyProvInfo,
        NULL,
        NULL,
        NULL,
        (ceExtensions.cExtension > 0) ? &ceExtensions : NULL
        );
    if (NULL == pCertContext)
        goto ErrorCertCreateSelfSignCertificate;

    // now put the pass thru data on the cert
    requestFlags.fWriteToCSP    =   (m_fWriteCertToCSP != 0);
    requestFlags.fWriteToDS     =   (m_fWriteCertToUserDS != 0);
    requestFlags.openFlags      =   m_RequestStore.dwFlags;

#if DBG
    assert(NULL == requestInfoBlob.pbData);
#endif
    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                XENROLL_REQUEST_INFO,
                &requestFlags,
                requestInfoBlob.pbData,
                &requestInfoBlob.cbData))
        {
            goto ErrorEncodeRequestInfoBlob;
        }
        if (NULL != requestInfoBlob.pbData)
        {
            //done
            break;
        }
        requestInfoBlob.pbData = (BYTE *)LocalAlloc(LMEM_FIXED, requestInfoBlob.cbData);
        if (NULL == requestInfoBlob.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // set the property on the dummy request cert.
    if( !CertSetCertificateContextProperty(
            pCertContext,
            XENROLL_PASS_THRU_PROP_ID,
            0,
            &requestInfoBlob) )
        goto ErrorCertSetCertificateContextProperty;

    if(m_pCertContextRenewal != NULL && m_fHonorRenew) {

        blobRenewalCert.pbData = m_pCertContextRenewal->pbCertEncoded;
        blobRenewalCert.cbData = m_pCertContextRenewal->cbCertEncoded;

        // set the renewal property if any
        if( !CertSetCertificateContextProperty(
                pCertContext,
                XENROLL_RENEWAL_CERTIFICATE_PROP_ID,
                0,
                &blobRenewalCert) )
            goto ErrorCertSetCertificateContextProperty;
    }

    // save the private key away if needed
    if(m_wszPVKFileName[0] != 0) {

        // open the PVK File
        if( (hFile = CreateOpenFileSafely2(m_wszPVKFileName, IDS_PVK_C, IDS_PVK_O)) == NULL )
            goto ErrorCreatePVKFile;

        assert(m_keyProvInfo.dwKeySpec == AT_SIGNATURE || m_keyProvInfo.dwKeySpec == AT_KEYEXCHANGE);

        // write out the private key
        if( !PrivateKeySave(
            hProv,
            hFile,
            m_keyProvInfo.dwKeySpec,
            NULL,
            m_wszPVKFileName,
            0
            ) )  {
            goto ErrorPrivateKeySave;
        }

        // put a different kind of propery in the store that just points to the pvk file
        keyProvInfoT = m_keyProvInfo;
        keyProvInfoT.pwszContainerName = m_wszPVKFileName;
        if( !CreatePvkProperty(&keyProvInfoT, &blobData) )
            goto ErrorCreatePvkProperty;

        // This is really not needed, it is only nice for other tools
        // like makecert or signcode to be able to look at a cert without
        // specifying a .PVK file if the cert points to the .pvk file.
        // So we don't care if this actually fail, which it will on Auth2 and
        // SP3 Crypt32.dll since Phil was so kind as to not allow any unknown property
        // to be set on the cert --- BAD PHIL!
        CertSetCertificateContextProperty(
                pCertContext,
                CERT_PVK_FILE_PROP_ID,
                0,
                &blobData);

        // only delete the keyset if the key was not pre-existing
        // this is if we write it out to a PVK file only
        // This is safe for scripting since we just generated this and we are putting it to
        // a pvk file. We really aren't deleting the key.
        if (!m_fNewRequestMethod)
        {
            //keep old behavior for createPKCS10 call
            if(!m_fUseExistingKey)
                GetProv(CRYPT_DELETEKEYSET);
        }
    }

    //set all properties from the caller
    pProp = EnumStackProperty(NULL);
    while (NULL != pProp)
    {
        //goto request cert
        if (!CertSetCertificateContextProperty(
                        pCertContext,
                        pProp->lPropId,
                        0,
                        &pProp->prop))
        {
            goto ErrorCertSetCertificateContextProperty;
        }
        pProp = EnumStackProperty(pProp);
    }

    // open the request cert store
    if( (hStore = GetStore(StoreREQUEST)) == NULL)
        goto ErrorCertOpenRequestStore;

    //if old pending request exists, free it first
    fRet = CertFreeCertificateContext(m_pCertContextPendingRequest);
#if DBG
    assert(fRet);
#endif //DBG
    m_pCertContextPendingRequest = NULL;

    // save the temp cert
    if( !CertAddCertificateContextToStore(
            hStore,
            pCertContext,
            CERT_STORE_ADD_NEW,
            &m_pCertContextPendingRequest) ) {
        goto ErrorCertAddToRequestStore;
    }

    // Remove the cached HASH. 
    if (m_hashBlobPendingRequest.pbData != NULL)
    {
        LocalFree(m_hashBlobPendingRequest.pbData);
        m_hashBlobPendingRequest.pbData = NULL;
    }

CommonReturn:

    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);
    if(hFile != NULL)
        CloseHandle(hFile);
    if(blobData.pbData != NULL)
        MyCoTaskMemFree(blobData.pbData);
    if(blobPKCS7.pbData != NULL)
        MyCoTaskMemFree(blobPKCS7.pbData);
    if(CSPProvider.Signature.pbData)
        LocalFree(CSPProvider.Signature.pbData);
    if (NULL != pbSMime)
    {
        LocalFree(pbSMime);
    }
    if (NULL != reqInfo.Subject.pbData)
    {
        LocalFree(reqInfo.Subject.pbData);
    }
    if (NULL != rgExtension)
    {
        LocalFree(rgExtension);
    }
    if (NULL != pbKU)
    {
        LocalFree(pbKU);
    }
    if (NULL != pbEKU)
    {
        LocalFree(pbEKU);
    }
    if (NULL != pszPurpose)
    {
        LocalFree(pszPurpose);
    }
    if (NULL != enhKeyUsage.rgpszUsageIdentifier)
    {
        LocalFree(enhKeyUsage.rgpszUsageIdentifier);
    }
    if (NULL != blobExt.pbData)
    {
        LocalFree(blobExt.pbData);
    }
    if (NULL != blobCSPAttr.pbData)
    {
        LocalFree(blobCSPAttr.pbData);
    }
    if (NULL != blobOSVAttr.pbData)
    {
        LocalFree(blobOSVAttr.pbData);
    }
    if (NULL != SignatureInfo.ToBeSigned.pbData)
    {
        LocalFree(SignatureInfo.ToBeSigned.pbData);
    }
    if (NULL != SignatureInfo.Signature.pbData)
    {
        LocalFree(SignatureInfo.Signature.pbData);
    }
    if (NULL != requestInfoBlob.pbData)
    {
        LocalFree(requestInfoBlob.pbData);
    }
    if (NULL != blobClientId.pbData)
    {
        LocalFree(blobClientId.pbData);
    }
    if (NULL != pbSubjectKeyHashExtension)
    {
        LocalFree(pbSubjectKeyHashExtension);
    }

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    // on error return a NULL
    if(pPkcs10Blob->pbData != NULL)
        MyCoTaskMemFree(pPkcs10Blob->pbData);
    memset(pPkcs10Blob, 0, sizeof(CRYPT_DATA_BLOB));


    goto CommonReturn;

TRACE_ERROR(ErrorGetSignatureFromHPROV);
TRACE_ERROR(ErrorEncodeCSPAttr);
TRACE_ERROR(ErrorCertSetCertificateContextProperty);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptGenKey);
TRACE_ERROR(ErrorCryptExportPublicKeyInfo);
TRACE_ERROR(ErrorCertStrToNameW);
TRACE_ERROR(ErrorEncodeKeyUsage);
TRACE_ERROR(ErrorEncodeEnhKeyUsage);
TRACE_ERROR(ErrorEncodeExtensions);
TRACE_ERROR(ErrorEncodePKCS10ToBeSigned);
TRACE_ERROR(ErrorCryptSignCertificatePKCS10);
TRACE_ERROR(ErrorEncodePKCS10Request);
TRACE_ERROR(ErrorCantConvertPurpose);
TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorCertAddToRequestStore);
TRACE_ERROR(ErrorCreatePVKFile);
TRACE_ERROR(ErrorPrivateKeySave);
TRACE_ERROR(ErrorCreatePvkProperty);
TRACE_ERROR(ErrorCertCreateSelfSignCertificate);
TRACE_ERROR(ErrorEncodeRequestInfoBlob);
TRACE_ERROR(ErrorCreatePKCS7RARequestFromPKCS10);
TRACE_ERROR(ErrorGetCapiHashAndSigAlgId);
TRACE_ERROR(ErrorCryptFindOIDInfo);
TRACE_ERROR(ErrorEncodeOSVAttr);
TRACE_ERROR(ErrorGetVersionEx);
TRACE_ERROR(ErrorRequestStoreSafeForScripting);
TRACE_ERROR(CreateSMimeExtensionError);
TRACE_ERROR(OutOfMemoryError);
TRACE_ERROR(putClientIdError);
TRACE_ERROR(myCreateSubjectKeyIdentifierExtensionError)
TRACE_ERROR(CryptGetUserKeyCancelError)
#if DBG
TRACE_ERROR(SetKeyContainerSecurityError)
#endif //DBG
}

HRESULT STDMETHODCALLTYPE CCEnroll::acceptPKCS7Blob(
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) {

    HRESULT     hr;
    HRESULT     hr2 = S_OK;
    LONG                       dwKeySpec               = 0;
    PCCERT_CONTEXT              pCertContextMy          = NULL;
    PCCERT_CONTEXT              pCertContextRequest     = NULL;
    PCCERT_CONTEXT              pCertContextEnd         = NULL;
    HANDLE                      hFile                   = NULL;
    DWORD                       cb                      = 0;
    HCRYPTPROV                  hProv                   = NULL;
    HCRYPTKEY                   hKey                    = NULL;
    HCERTSTORE                  hStoreDS                = NULL;
    HCERTSTORE                  hStoreRequest           = NULL;
    HCERTSTORE                  hStoreMy                = NULL;
    BOOL                        fRemove = TRUE;

    EnterCriticalSection(&m_csXEnroll);

    // get the end entity cert
    hr2 = GetEndEntityCert(pBlobPKCS7, TRUE, &pCertContextEnd);
    if (S_OK != hr2 && XENROLL_E_CANNOT_ADD_ROOT_CERT != hr2)
    {
        hr = hr2;
        goto ErrorGetEndEntityCert;
    }

    if(m_fDeleteRequestCert)
    {
        if ((hStoreRequest = GetStore(StoreREQUEST)) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenRequestStore;
        }

        // check to see if this is in the request store
        if ((pCertContextRequest = CertFindCertificateInStore(
                hStoreRequest,
                CRYPT_ASN_ENCODING,
                0,
                CERT_FIND_PUBLIC_KEY,
                (void *) &pCertContextEnd->pCertInfo->SubjectPublicKeyInfo,
                NULL)) != NULL)
        {
            CertDeleteCertificateFromStore(pCertContextRequest);
            pCertContextRequest = NULL;
        }
    }

    cb = 0;
    // if the cert is to be written to the CSP,
    // put it there but only if we have keys
    if (m_fWriteCertToCSP  &&
        CertGetCertificateContextProperty(
            pCertContextEnd,
            CERT_KEY_PROV_INFO_PROP_ID, NULL, &cb))
    {
        if ((hProv = GetProv(0)) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCryptAcquireContext;
        }

        // This can't fail
        get_KeySpec(&dwKeySpec);

        if (!CryptGetUserKey(
                hProv,
                dwKeySpec,
                &hKey))
        {
            hKey = NULL;
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCryptGetUserKey;
        }

        // always attempt to write the cert to the csp
        if (!CryptSetKeyParam(
                hKey,
                KP_CERTIFICATE,
                pCertContextEnd->pbCertEncoded,
                0))
        {
            // only return an error if it is a smart card error
            // otherwise ignore the error
            if (SCODE_FACILITY(GetLastError()) == FACILITY_SCARD)
            {
                //return error code from writing cert to csp
                //important to save the error code before following clean up
                hr = MY_HRESULT_FROM_WIN32(GetLastError());

                //if can't write cert back to smartcard, remove the cert from my store
                if ((hStoreMy = GetStore(StoreMY)) == NULL)
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorCertOpenMyStore;
                }

                // check to see if this is in the MY store
                if ((pCertContextMy = CertFindCertificateInStore(
                        hStoreMy,
                        CRYPT_ASN_ENCODING,
                        0,
                        CERT_FIND_PUBLIC_KEY,
                        (void *) &pCertContextEnd->pCertInfo->SubjectPublicKeyInfo,
                        NULL)) != NULL)
                {
                    //try to remove it
                    CertDeleteCertificateFromStore(pCertContextMy);
                    pCertContextMy = NULL;
                }
                if (!m_fUseExistingKey)
                {
                        GetProv(CRYPT_DELETEKEYSET);
                }
                //error any way
                goto ErrorWriteToCSP;
            }
        }
    }

    if(m_fWriteCertToUserDS)
    {
        // otherwise attempt to open the store
        if ((hStoreDS = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING,
                NULL,
                CERT_SYSTEM_STORE_CURRENT_USER,
                L"UserDS")) == NULL)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCertOpenDSStore;
        }

        if (!CertAddCertificateContextToStore(
                    hStoreDS,
                    pCertContextEnd,
                    CERT_STORE_ADD_NEW,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorAddCertificateContextToDSStore;
        }

        CertCloseStore(hStoreDS, 0);
        hStoreDS = NULL;
    }

    // determine if he wants to save the spc file
    if (m_wszSPCFileName[0] != 0)
    {
        // open the spc file
        hFile = CreateOpenFileSafely2(m_wszSPCFileName, IDS_SPC_C, IDS_SPC_O);
        if (NULL == hFile)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorCreateSPCFile;
        }

        // write the spc
        assert(pBlobPKCS7->pbData != NULL);
        cb = 0;
        if (!WriteFile(
            hFile,
            pBlobPKCS7->pbData,
            pBlobPKCS7->cbData,
            &cb,
            NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto ErrorWriteSPCFile;
        }
    }

    if (S_OK != hr2)
    {
        //return hr2 error
        hr = hr2;
    }
    else
    {
        hr = S_OK;
    }
ErrorReturn:

    if(hKey != NULL)
        CryptDestroyKey(hKey);
    if(hFile != NULL)
        CloseHandle(hFile);

    if(pCertContextEnd != NULL)
        CertFreeCertificateContext(pCertContextEnd);
    if(hStoreDS != NULL)
        CertCloseStore(hStoreDS, 0);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(ErrorWriteToCSP);
TRACE_ERROR(ErrorCreateSPCFile);
TRACE_ERROR(ErrorWriteSPCFile);
TRACE_ERROR(ErrorGetEndEntityCert);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptGetUserKey);
TRACE_ERROR(ErrorCertOpenDSStore);
TRACE_ERROR(ErrorAddCertificateContextToDSStore);
TRACE_ERROR(ErrorCertOpenRequestStore);
TRACE_ERROR(ErrorCertOpenMyStore);
}

PCCERT_CONTEXT STDMETHODCALLTYPE CCEnroll::getCertContextFromPKCS7(
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) {
    HRESULT hr;
    PCCERT_CONTEXT pCert;

    // get the end entity cert
    hr = GetEndEntityCert(pBlobPKCS7, FALSE, &pCert);
#if DBG
    if (S_OK != hr)
    {
        assert(NULL == pCert);
    }
#endif //DBG
    return pCert;
}

HRESULT STDMETHODCALLTYPE CCEnroll::enumProvidersWStr(
    /* [in] */ LONG dwIndex,
    /* [in] */ LONG dwFlags,
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    DWORD   iLast = 0;
    LONG    i;
    DWORD   dwProvType = 0;
    DWORD   cb = 0;
    HRESULT hr = S_OK;
    DWORD errBefore = GetLastError();

    assert(ppwsz != NULL);
    *ppwsz = NULL;
    SetLastError(ERROR_SUCCESS);

    EnterCriticalSection(&m_csXEnroll);

    for(i=0; i<=dwIndex; i++) {

        do {

            cb = 0;
            if( !CryptEnumProvidersU(
                           iLast,
                           0,
                           0,
                           &dwProvType,
                           NULL,
                           &cb
                           ) ) {

                // only skip if entry is bad
                if( GetLastError() != NTE_PROV_TYPE_ENTRY_BAD)
                    goto ErrorCryptEnumProvidersU;
            }
            iLast++;
        } while((CRYPT_ENUM_ALL_PROVIDERS & dwFlags) != CRYPT_ENUM_ALL_PROVIDERS  &&
                    dwProvType != m_keyProvInfo.dwProvType);
    }

    iLast--;
    if( (*ppwsz = (LPWSTR) MyCoTaskMemAlloc(cb)) == NULL  ||
        !CryptEnumProvidersU(
                       iLast,
                       0,
                       0,
                       &dwProvType,
                       *ppwsz,
                       &cb
                       )                        ) {
        goto ErrorCryptEnumProvidersU;
    }

CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if(*ppwsz != NULL)
        MyCoTaskMemFree(*ppwsz);

    goto CommonReturn;

TRACE_ERROR(ErrorCryptEnumProvidersU);
}

HRESULT STDMETHODCALLTYPE CCEnroll::enumContainersWStr(
    /* [in] */ LONG               dwIndex,
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    DWORD       errBefore   = GetLastError();
    DWORD       cb          = 0;
    LONG        i           = 0;
    char *      psz         = NULL;
    HRESULT     hr          = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    SetLastError(ERROR_SUCCESS);

    assert(ppwsz != NULL);
    *ppwsz = NULL;

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    while (TRUE)
    {
        if(!CryptGetProvParam(
                m_hVerifyProv,
                PP_ENUMCONTAINERS,
                (BYTE*)psz,
                &cb,
                CRYPT_FIRST))
        {
            goto ErrorCryptGetProvParam;
        }
        if (NULL != psz)
        {
            //done
            break;
        }
        psz = (char*)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == psz)
        {
            goto ErrorOutOfMem;
        }
    }

    for(i=1; i<=dwIndex; i++) {
        //assume 1st enum buffer size is big enough for all?
        if( !CryptGetProvParam(
            m_hVerifyProv,
            PP_ENUMCONTAINERS,
            (BYTE *) psz,
            &cb,
            0) )
            goto ErrorCryptGetProvParam;
    }

    if( (*ppwsz = WideFromMB(psz)) == NULL )
        goto ErrorOutOfMem;


CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if (NULL != psz)
    {
        LocalFree(psz);
    }
    if(*ppwsz != NULL)
        MyCoTaskMemFree(*ppwsz);
    *ppwsz = NULL;

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
TRACE_ERROR(ErrorOutOfMem);
}


HRESULT CCEnroll::PKCS10ToCert(IN   HCERTSTORE        hCertStore,
                               IN   CRYPT_DATA_BLOB   pkcs10Blob, 
                               OUT  PCCERT_CONTEXT   *ppCertContext)
{
    HRESULT            hr       = E_FAIL; 
    PCERT_REQUEST_INFO pReqInfo = NULL; 

    // Input validation: 
    if (NULL == hCertStore || NULL == pkcs10Blob.pbData || NULL == ppCertContext)
        return E_INVALIDARG;

    if( !MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                            &pkcs10Blob, 
                            CERT_QUERY_CONTENT_FLAG_PKCS10,
                            CERT_QUERY_FORMAT_FLAG_ALL,
                            CRYPT_DECODE_ALLOC_FLAG,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            (const void **) &pReqInfo) )
        goto MyCryptQueryObjectError;

    if ( NULL == (*ppCertContext = CertFindCertificateInStore
                  (hCertStore,
                   CRYPT_ASN_ENCODING, 
                   0, 
                   CERT_FIND_PUBLIC_KEY, 
                   (void *) &pReqInfo->SubjectPublicKeyInfo, 
                   NULL)) )
        goto CertFindCertificateInStoreError;

    hr = S_OK; 

CommonReturn:
    if (NULL != pReqInfo) { LocalFree(pReqInfo); } // Allocated in CryptQueryObject(). 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(CertFindCertificateInStoreError,  MY_HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(MyCryptQueryObjectError,          MY_HRESULT_FROM_WIN32(GetLastError())); 
}

HRESULT CCEnroll::PKCS7ToCert(IN  HCERTSTORE       hCertStore,
                              IN  CRYPT_DATA_BLOB  pkcs7Blob, 
                              OUT PCCERT_CONTEXT  *ppCertContext)
{
    CRYPT_DATA_BLOB            pkcs10Blob;
    CRYPT_VERIFY_MESSAGE_PARA  VerifyPara; 
    HRESULT                    hr           = E_FAIL; 

    // Init locals:
    ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 
    ZeroMemory(&VerifyPara, sizeof(VerifyPara)); 

    VerifyPara.cbSize                   = sizeof(VerifyPara); 
    VerifyPara.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING; 

    if (!MyCryptVerifyMessageSignature
        (&VerifyPara,
         0,                  // dwSignerIndex
         pkcs7Blob.pbData,
         pkcs7Blob.cbData,
         pkcs10Blob.pbData,
         &(pkcs10Blob.cbData),
         NULL                // ppSignerCert
         ) || 0 == pkcs10Blob.cbData)
        goto MyCryptVerifyMessageSignatureError;

    if (NULL == (pkcs10Blob.pbData = (PBYTE)LocalAlloc(LPTR, pkcs10Blob.cbData)))
        goto MemoryError; 

    if (!MyCryptVerifyMessageSignature
        (&VerifyPara,
         0,                  // dwSignerIndex
         pkcs7Blob.pbData,
         pkcs7Blob.cbData,
         pkcs10Blob.pbData,
         &pkcs10Blob.cbData,
         NULL                // ppSignerCert
         ))
        goto MyCryptVerifyMessageSignatureError;

    hr = this->PKCS10ToCert(hCertStore, pkcs10Blob, ppCertContext); 

CommonReturn:
    if (NULL != pkcs10Blob.pbData) { LocalFree(pkcs10Blob.pbData); } 
    return hr; 

ErrorReturn:
    goto CommonReturn;

SET_HRESULT(MemoryError,                        E_OUTOFMEMORY); 
SET_HRESULT(MyCryptVerifyMessageSignatureError, MY_HRESULT_FROM_WIN32(GetLastError()));
}

HRESULT STDMETHODCALLTYPE CCEnroll::freeRequestInfoBlob(
    /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10) {

    DWORD            dwContentType   = NULL;
    HCERTSTORE       hStoreRequest   = NULL;
    HRESULT          hr              = E_FAIL;
    PCCERT_CONTEXT   pCertContext    = NULL; 

    // We're not supposed to delete the cert anyway, so we're done!
    if (!m_fDeleteRequestCert)
        return S_OK; 

    if (NULL == pkcs7OrPkcs10.pbData)
        return E_INVALIDARG;

    EnterCriticalSection(&m_csXEnroll);

    // Step 1)  Determine if we have a PKCS7 or a PKCS10:
    //
    if( !MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                            &pkcs7OrPkcs10,
                            (CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED | CERT_QUERY_CONTENT_FLAG_PKCS10),
                            CERT_QUERY_FORMAT_FLAG_ALL,
                            0,
                            NULL,
                            &dwContentType,  // OUT:  PKCS10 or PKCS7
                            NULL,
                            NULL, 
                            NULL,
                            NULL) )
        goto MyCryptQueryObjectError;
    
    // Step 2)  Find a cert context with a matching public key in the request store: 
    // 

    if (NULL == (hStoreRequest = GetStore(StoreREQUEST)))
        goto UnexpectedError; 

    switch (dwContentType) 
    {
    case CERT_QUERY_CONTENT_PKCS7_SIGNED:
        hr = this->PKCS7ToCert(hStoreRequest, pkcs7OrPkcs10, &pCertContext);
        if (S_OK != hr)
        {
            if (CRYPT_E_NOT_FOUND == hr)
            {
                //freeRequestInfo could be called when cert is not issued
                //PKCS7 could be CMC which is signed by request key and
                //cert is not in local store yet. We try cached cert
                if (NULL != m_pCertContextPendingRequest)
                {
                    //looks we still have cached request cert handle
                    pCertContext = CertDuplicateCertificateContext(
                                        m_pCertContextPendingRequest);
                    if (NULL == pCertContext)
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto CertDuplicateCertificateContextError;
                    }
                }
                else if (NULL != m_hashBlobPendingRequest.pbData &&
                         0 < m_hashBlobPendingRequest.cbData)
                {
                    //don't have cached request handle but thumbprint exists
                    //retrieve the request cert handle from store
                    pCertContext = CertFindCertificateInStore(
                                hStoreRequest,  //request store
                                X509_ASN_ENCODING,
                                0,
                                CERT_FIND_HASH,
                                &m_hashBlobPendingRequest,
                                NULL);
                    if (NULL == pCertContext)
                    {
                        hr = MY_HRESULT_FROM_WIN32(GetLastError());
                        goto CertFindCertificateInStoreError;
                    }
                }
                else
                {
                    //sorry, don't know which cert to be free
                    //however, can try to find public key from PKCS7
                    goto PKCS7ToCertError; 
                }
            }
            else
            {
                //other errors
                goto PKCS7ToCertError; 
            }
        }
        break;
    case CERT_QUERY_CONTENT_PKCS10:
        if (S_OK != (hr = this->PKCS10ToCert(hStoreRequest, pkcs7OrPkcs10, &pCertContext)))
            goto PKCS10ToCertError; 
        break;
    default:
        goto InvalidContentTypeError; 
    }

    if (!CertDeleteCertificateFromStore(pCertContext))
    {
        // pCertContext is freed even when CertDeleteCertificateFromStore() returns an error. 
        pCertContext = NULL; 
        goto CertDeleteCertificateFromStoreError; 
    }

    hr = S_OK; 
CommonReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

ErrorReturn:
    if (NULL != pCertContext) { CertFreeCertificateContext(pCertContext); } 
    goto CommonReturn;

SET_HRESULT(CertDeleteCertificateFromStoreError,  MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(PKCS7ToCertError,                     hr);
SET_HRESULT(PKCS10ToCertError,                    hr);
SET_HRESULT(InvalidContentTypeError,              E_INVALIDARG);
SET_HRESULT(MyCryptQueryObjectError,              MY_HRESULT_FROM_WIN32(GetLastError()));
SET_HRESULT(UnexpectedError,                      E_UNEXPECTED);
TRACE_ERROR(CertDuplicateCertificateContextError)
TRACE_ERROR(CertFindCertificateInStoreError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_SPCFileNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szw) {
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_csXEnroll);
    if( (*szw = CopyWideString(m_wszSPCFileName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_SPCFileNameWStr(
    /* [in] */ LPWSTR pwsz) {

    HRESULT hr = S_OK;
 
    if(pwsz == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
        
    if( m_wszSPCFileName != wszEmpty)
        MyCoTaskMemFree(m_wszSPCFileName);
    if( (m_wszSPCFileName = CopyWideString(pwsz)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_PVKFileNameWStr(
    /* [out] */ LPWSTR __RPC_FAR *szw) {

    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if( (*szw = CopyWideString(m_wszPVKFileName)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_PVKFileNameWStr(
    /* [in] */ LPWSTR pwsz) {

    HRESULT hr = S_OK;
        
    if(pwsz == NULL)
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        
    EnterCriticalSection(&m_csXEnroll);
        
    if( m_wszPVKFileName != wszEmpty)
        MyCoTaskMemFree(m_wszPVKFileName);
    if( (m_wszPVKFileName = CopyWideString(pwsz)) == NULL )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    else
        m_dwGenKeyFlags |= CRYPT_EXPORTABLE; //why???

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
  }

HRESULT STDMETHODCALLTYPE CCEnroll::get_HashAlgorithmWStr(
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    PCCRYPT_OID_INFO            pOidInfo        = NULL;
    ALG_ID                      rgAlg[2];
    HRESULT                     hr              = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    assert(ppwsz != NULL);
    *ppwsz  = NULL;

    if( !GetCapiHashAndSigAlgId(rgAlg) )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // Convert to an oid
    else if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_ALGID_KEY,
        (void *) &rgAlg[0],
        CRYPT_HASH_ALG_OID_GROUP_ID)) ) ) {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

    else if( (*ppwsz = WideFromMB(pOidInfo->pszOID)) == NULL)
            hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_HashAlgorithmWStr(
    /* [in] */ LPWSTR pwsz) {

    HRESULT             hr          = S_OK;
    char *              szObjId     = NULL;
    PCCRYPT_OID_INFO    pOidInfo    = NULL;

    if(pwsz == NULL) {
        return(MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    if(!_wcsicmp(L"SHA1", pwsz))
        szObjId = CopyAsciiString(szOID_OIWSEC_sha1);
    else if(!_wcsicmp(L"MD5", pwsz))
        szObjId = CopyAsciiString(szOID_RSA_MD5RSA);
    else if(!_wcsicmp(L"MD2", pwsz))
        szObjId = CopyAsciiString(szOID_RSA_MD2RSA);
    else
        szObjId = MBFromWide(pwsz);

    // something went wrong
    if(szObjId == NULL)
        return(MY_HRESULT_FROM_WIN32(GetLastError()));

    // find the hashing algid
    if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        szObjId,
        0)) ) )
    {
        //XIAOHS: CryptFindOIDInfo does not set the LastError in this case.
        //AV in xEnroll.  See bug# 189320
        //hr = MY_HRESULT_FROM_WIN32(GetLastError());
        hr=NTE_BAD_ALGID;
    }

    assert(szObjId != NULL);
    MyCoTaskMemFree(szObjId);

    EnterCriticalSection(&m_csXEnroll);

    if(hr == S_OK) {
        if( pOidInfo->dwGroupId == CRYPT_HASH_ALG_OID_GROUP_ID ||
            pOidInfo->dwGroupId == CRYPT_SIGN_ALG_OID_GROUP_ID )
            m_HashAlgId = pOidInfo->Algid;
        else
            hr = CRYPT_E_NOT_FOUND;
    }

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_HashAlgID(
    LONG    hashAlgID
    ) {

    EnterCriticalSection(&m_csXEnroll);
    m_HashAlgId = hashAlgID;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_HashAlgID(
    LONG *   hashAlgID
    ) {
    EnterCriticalSection(&m_csXEnroll);
    *hashAlgID = m_HashAlgId;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_RenewalCertificate(
            /* [out] */ PCCERT_CONTEXT __RPC_FAR *ppCertContext) {

    HRESULT     hr      = S_OK;

    *ppCertContext = NULL;

    if( m_pCertContextRenewal == NULL)
        return(MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND));

    EnterCriticalSection(&m_csXEnroll);
    if( NULL == (*ppCertContext = CertDuplicateCertificateContext(m_pCertContextRenewal)) )
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_RenewalCertificate(
            /* [in] */ PCCERT_CONTEXT pCertContext)
{
    HRESULT  hr;
    PCCERT_CONTEXT  pGoodCertContext= NULL;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetGoodCertContext(pCertContext, &pGoodCertContext);
    if (S_OK != hr)
    {
        goto GetGoodCertContextError;
    }

    if(m_pCertContextRenewal != NULL)
    {
        CertFreeCertificateContext(m_pCertContextRenewal);
    }
    m_pCertContextRenewal = pGoodCertContext;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(GetGoodCertContextError);
}

BOOL
CCEnroll::CopyAndPushStackExtension(
    PCERT_EXTENSION pExt,
    BOOL            fCMC)
{

    DWORD       cb              = 0;
    DWORD       cbOid           = 0;
    PEXT_STACK  pExtStackEle    = NULL;
    PBYTE       pb              = NULL;
    PEXT_STACK  *ppExtStack = NULL;
    DWORD       *pcExtStack = NULL;

    assert(pExt != NULL);

    // allocate the space
    cbOid = POINTERROUND(strlen(pExt->pszObjId) + 1); //ia64 align
    cb = sizeof(EXT_STACK) + cbOid + pExt->Value.cbData;
    if(NULL == (pb = (PBYTE) malloc(cb))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // set my pointers
    pExtStackEle = (PEXT_STACK) pb;
    pb += sizeof(EXT_STACK);
    pExtStackEle->ext.pszObjId = (LPSTR) pb;
    pb += cbOid;
    pExtStackEle->ext.Value.pbData = pb;

    // set the values
    strcpy(pExtStackEle->ext.pszObjId, pExt->pszObjId);
    pExtStackEle->ext.fCritical     = pExt->fCritical;
    pExtStackEle->ext.Value.cbData  = pExt->Value.cbData;
    memcpy(pExtStackEle->ext.Value.pbData, pExt->Value.pbData, pExt->Value.cbData);

    // insert on the list
    EnterCriticalSection(&m_csXEnroll);
    
    ppExtStack = fCMC ? &m_pExtStackNew : &m_pExtStack;
    pcExtStack = fCMC ? &m_cExtStackNew : &m_cExtStack;
    pExtStackEle->pNext = *ppExtStack;
    *ppExtStack = pExtStackEle;
    (*pcExtStack)++;

    LeaveCriticalSection(&m_csXEnroll);

    return(TRUE);
}

PCERT_EXTENSION
CCEnroll::PopStackExtension(
    BOOL fCMC)
{

    PEXT_STACK  pExtStackEle = NULL;
    PEXT_STACK *ppExtStack = NULL;
    DWORD      *pcExtStack = NULL;

    EnterCriticalSection(&m_csXEnroll);

    ppExtStack = fCMC ? &m_pExtStackNew : &m_pExtStack;
    if(NULL != *ppExtStack)
    {
        pExtStackEle = *ppExtStack;
        *ppExtStack = (*ppExtStack)->pNext;
        pcExtStack = fCMC ? &m_cExtStackNew : &m_cExtStack;
        (*pcExtStack)--;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCERT_EXTENSION) pExtStackEle);
}

DWORD
CCEnroll::CountStackExtension(BOOL fCMC)
{
    DWORD   cExt = 0;

    EnterCriticalSection(&m_csXEnroll);
    cExt = fCMC ? m_cExtStackNew : m_cExtStack;
    LeaveCriticalSection(&m_csXEnroll);

    return(cExt);
}

PCERT_EXTENSION
CCEnroll::EnumStackExtension(
    PCERT_EXTENSION pExtLast,
    BOOL            fCMC)
{
    PEXT_STACK pExtStackEle    = (PEXT_STACK)pExtLast;

    EnterCriticalSection(&m_csXEnroll);

    if(NULL == pExtStackEle)
    {
        pExtStackEle = fCMC ? m_pExtStackNew : m_pExtStack;
    }
    else
    {
        pExtStackEle = pExtStackEle->pNext;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCERT_EXTENSION) pExtStackEle);
}

void
CCEnroll::FreeAllStackExtension(void)
{
    EnterCriticalSection(&m_csXEnroll);

    //free cmc extensions
    while(0 != m_cExtStackNew)
    {
        FreeStackExtension(PopStackExtension(TRUE));
    }

    //free old client extensions
    while(0 != m_cExtStack)
    {
        FreeStackExtension(PopStackExtension(FALSE));
    }

    LeaveCriticalSection(&m_csXEnroll);
}

void CCEnroll::FreeStackExtension(PCERT_EXTENSION pExt) {
    if(pExt != NULL)
        free(pExt);
}

//obselete call for new client
HRESULT STDMETHODCALLTYPE
CCEnroll::AddExtensionsToRequest(
    /* [in] */ PCERT_EXTENSIONS pCertExtensions)
{

    HRESULT hr  = S_OK;
    DWORD   i   = 0;

    assert(pCertExtensions != NULL);

    for(i = 0; i < pCertExtensions->cExtension; i++)
    {
        //push into old extension stack
        if(!CopyAndPushStackExtension(&pCertExtensions->rgExtension[i], FALSE))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    return(hr);
}

BOOL
CCEnroll::CopyAndPushStackAttribute(
    PCRYPT_ATTRIBUTE pAttr,
    BOOL             fCMC)
{
    DWORD       i               = 0;
    DWORD       cb              = 0;
    DWORD       cbOid           = 0;
    PATTR_STACK pAttrStackEle   = NULL;
    PBYTE       pb              = NULL;
    PATTR_STACK *ppAttrStack = NULL;
    DWORD       *pcAttrStack = NULL;

    assert(pAttr != NULL);

     // allocate the space
    cb = sizeof(ATTR_STACK);
    //make sure aligned for ia64
    cbOid = POINTERROUND(strlen(pAttr->pszObjId) + 1);
    cb += cbOid;
    cb += sizeof(CRYPT_ATTR_BLOB) * pAttr->cValue;
    for(i=0; i<pAttr->cValue; i++)
        cb += POINTERROUND(pAttr->rgValue[i].cbData); //pointer align

    if(NULL == (pb = (PBYTE) malloc(cb))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // set my pointers
    pAttrStackEle = (PATTR_STACK) pb;
    pb += sizeof(ATTR_STACK);
    pAttrStackEle->attr.pszObjId = (LPSTR) pb;
    pb += cbOid;
    strcpy(pAttrStackEle->attr.pszObjId, pAttr->pszObjId);

    pAttrStackEle->attr.cValue = pAttr->cValue;
    pAttrStackEle->attr.rgValue = (PCRYPT_ATTR_BLOB) pb;
    pb += sizeof(CRYPT_ATTR_BLOB) * pAttr->cValue;
    for(i=0; i<pAttr->cValue; i++) {
        pAttrStackEle->attr.rgValue[i].pbData = pb;
        pAttrStackEle->attr.rgValue[i].cbData = pAttr->rgValue[i].cbData;
        memcpy(pAttrStackEle->attr.rgValue[i].pbData, pAttr->rgValue[i].pbData, pAttr->rgValue[i].cbData);
        pb += POINTERROUND(pAttr->rgValue[i].cbData);
    }
    assert( pb == ((BYTE *) pAttrStackEle) + cb );

    // insert on the list
    EnterCriticalSection(&m_csXEnroll);

    ppAttrStack = fCMC ? &m_pAttrStackNew : &m_pAttrStack;
    pcAttrStack = fCMC ? &m_cAttrStackNew : &m_cAttrStack;
    pAttrStackEle->pNext = *ppAttrStack;
    *ppAttrStack = pAttrStackEle;
    (*pcAttrStack)++;

    LeaveCriticalSection(&m_csXEnroll);

    return(TRUE);
}

PCRYPT_ATTRIBUTE
CCEnroll::PopStackAttribute(BOOL fCMC)
{
    PATTR_STACK pAttrStackEle = NULL;
    PATTR_STACK *ppAttrStack = NULL;
    DWORD       *pcAttrStack = NULL;

    EnterCriticalSection(&m_csXEnroll);

    ppAttrStack = fCMC ? &m_pAttrStackNew : &m_pAttrStack;

    if(NULL != *ppAttrStack)
    {
        pAttrStackEle = *ppAttrStack;
        *ppAttrStack = (*ppAttrStack)->pNext;
        pcAttrStack = fCMC ? &m_cAttrStackNew : &m_cAttrStack;
        (*pcAttrStack)--;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCRYPT_ATTRIBUTE) pAttrStackEle);
}

DWORD
CCEnroll::CountStackAttribute(BOOL fCMC)
{
    DWORD   cAttr = 0;

    EnterCriticalSection(&m_csXEnroll);
    cAttr = fCMC ? m_cAttrStackNew : m_cAttrStack;
    LeaveCriticalSection(&m_csXEnroll);

    return(cAttr);
}

PCRYPT_ATTRIBUTE
CCEnroll::EnumStackAttribute(
    PCRYPT_ATTRIBUTE pAttrLast,
    BOOL             fCMC)
{
    PATTR_STACK pAttrStackEle    = (PATTR_STACK) pAttrLast;

    EnterCriticalSection(&m_csXEnroll);

    if(NULL == pAttrLast)
    {
        pAttrStackEle = fCMC ? m_pAttrStackNew : m_pAttrStack;
    }
    else
    {
        pAttrStackEle = pAttrStackEle->pNext;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return((PCRYPT_ATTRIBUTE) pAttrStackEle);
}

void CCEnroll::FreeAllStackAttribute(void)
{
    EnterCriticalSection(&m_csXEnroll);

    while(0 != m_cAttrStackNew)
    {
        FreeStackAttribute(PopStackAttribute(TRUE));
    }

    while(0 != m_cAttrStack)
    {
        FreeStackAttribute(PopStackAttribute(FALSE));
    }

    LeaveCriticalSection(&m_csXEnroll);
}

void CCEnroll::FreeStackAttribute(PCRYPT_ATTRIBUTE pAttr) {
    if(pAttr != NULL)
        free(pAttr);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::AddAuthenticatedAttributesToPKCS7Request(
    /* [in] */ PCRYPT_ATTRIBUTES pAttributes)
{
    HRESULT hr = S_OK;
    DWORD i;

    for(i = 0; i < pAttributes->cAttr; i++)
    {
        if(!CopyAndPushStackAttribute(&pAttributes->rgAttr[i], FALSE))
        {
            hr = (MY_HRESULT_FROM_WIN32(GetLastError()));
            break;
        }
        //put into cmc stack too
        if(!CopyAndPushStackAttribute(&pAttributes->rgAttr[i], TRUE))
        {
            hr = (MY_HRESULT_FROM_WIN32(GetLastError()));
            break;
        }
    }

    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::CreatePKCS7RequestFromRequest(
    /* [in] */  PCRYPT_DATA_BLOB pRequest,
    /* [in] */  PCCERT_CONTEXT pSigningRACertContext,
    /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob) {

    HRESULT                     hr              = S_OK;
    DWORD                       errBefore       = GetLastError();
    CRYPT_SIGN_MESSAGE_PARA     signMsgPara;
    PCCRYPT_OID_INFO            pOidInfo        = NULL;
    PCRYPT_ATTRIBUTE            pAttrCur        = NULL;
    DWORD                       i;
    ALG_ID                      rgAlg[2];
    CRYPT_KEY_PROV_INFO *pKeyProvInfo = NULL;
    DWORD                cb = 0;

    assert(pSigningRACertContext != NULL);
    assert(pRequest != NULL);
    assert(pPkcs7Blob != NULL);

    memset(&signMsgPara, 0, sizeof(CRYPT_SIGN_MESSAGE_PARA));
    memset(pPkcs7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    if( !GetCapiHashAndSigAlgId(rgAlg) )
        goto ErrorGetCapiHashAndSigAlgId;

    // find out what the oid is
    if( (NULL == (pOidInfo = xeCryptFindOIDInfo(
        CRYPT_OID_INFO_ALGID_KEY,
        (void *) &rgAlg[0],
        CRYPT_HASH_ALG_OID_GROUP_ID)) ) )
    {
        SetLastError(NTE_BAD_ALGID);
        goto ErrorCryptFindOIDInfo;
    }

    // now add all of the user defined extensions
    EnterCriticalSection(&m_csXEnroll);
    signMsgPara.cAuthAttr = CountStackAttribute(m_fNewRequestMethod);

    signMsgPara.rgAuthAttr = (PCRYPT_ATTRIBUTE)LocalAlloc(LMEM_FIXED,
                    signMsgPara.cAuthAttr * sizeof(CRYPT_ATTRIBUTE));
    if( NULL == signMsgPara.rgAuthAttr)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        LeaveCriticalSection(&m_csXEnroll);
        goto ErrorOutOfMemory;
    }

    i = 0;
    pAttrCur = NULL;
    while(NULL != (pAttrCur = EnumStackAttribute(pAttrCur, m_fNewRequestMethod)) ) {
        signMsgPara.rgAuthAttr[i] = *pAttrCur;
        i++;
    }
    LeaveCriticalSection(&m_csXEnroll);

    signMsgPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signMsgPara.dwMsgEncodingType       = PKCS_7_ASN_ENCODING;
    signMsgPara.pSigningCert            = pSigningRACertContext;
    signMsgPara.HashAlgorithm.pszObjId  = (char *) pOidInfo->pszOID;
    signMsgPara.cMsgCert                = 1;
    signMsgPara.rgpMsgCert              = &pSigningRACertContext;

    //get key prov info
    while (TRUE)
    {
        if(!CertGetCertificateContextProperty(
                pSigningRACertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo,
                &cb))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertGetCertificateContextPropertyError;
        }
        if (NULL != pKeyProvInfo)
        {
            //got it, done
            break;
        }
        pKeyProvInfo = (CRYPT_KEY_PROV_INFO*)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pKeyProvInfo)
        {
            hr = E_OUTOFMEMORY;
            goto ErrorOutOfMemory;
        }
    }
    if (0x0 != (pKeyProvInfo->dwFlags & CRYPT_SILENT))
    {
        //have to set silent through msg param
        signMsgPara.dwFlags |= CRYPT_MESSAGE_SILENT_KEYSET_FLAG;
    }


    if( !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &pRequest->pbData,
        &pRequest->cbData ,
        NULL,
        &pPkcs7Blob->cbData)                          ||
    (pPkcs7Blob->pbData = (BYTE *)
        MyCoTaskMemAlloc(pPkcs7Blob->cbData)) == NULL ||
    !CryptSignMessage(
        &signMsgPara,
        FALSE,
        1,
        (const BYTE **) &pRequest->pbData,
        &pRequest->cbData ,
        pPkcs7Blob->pbData,
        &pPkcs7Blob->cbData) )
        goto ErrorCryptSignMessage;

CommonReturn:

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if (NULL != signMsgPara.rgAuthAttr)
    {
        LocalFree(signMsgPara.rgAuthAttr);
    }
    if (NULL != pKeyProvInfo)
    {
        LocalFree(pKeyProvInfo);
    }

    // on error return a NULL
    if(pPkcs7Blob->pbData != NULL)
        MyCoTaskMemFree(pPkcs7Blob->pbData);
    memset(pPkcs7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    goto CommonReturn;

TRACE_ERROR(ErrorGetCapiHashAndSigAlgId);
TRACE_ERROR(ErrorCryptSignMessage);
TRACE_ERROR(ErrorCryptFindOIDInfo);
TRACE_ERROR(ErrorOutOfMemory);
TRACE_ERROR(CertGetCertificateContextPropertyError)
}

HRESULT STDMETHODCALLTYPE
CCEnroll::AddNameValuePairToSignatureWStr(
    /* [in] */ LPWSTR pwszName,
    /* [in] */ LPWSTR pwszValue)
{
    HRESULT hr = S_OK;

    assert(pwszName != NULL && pwszValue != NULL);

    CRYPT_ENROLLMENT_NAME_VALUE_PAIR nameValuePair = {pwszName, pwszValue};
    CRYPT_ATTR_BLOB blobAttr;
    CRYPT_ATTRIBUTE attr = {szOID_ENROLLMENT_NAME_VALUE_PAIR, 1, &blobAttr};
    CRYPT_ATTRIBUTES attrs = {1, &attr};

    memset(&blobAttr, 0, sizeof(CRYPT_ATTR_BLOB));

    hr = xeEncodeNameValuePair(
                &nameValuePair,
                &blobAttr.pbData,
                &blobAttr.cbData);
    if (S_OK != hr)
    {
        goto error;
    }

    hr = AddAuthenticatedAttributesToPKCS7Request(&attrs);

error:
    if (NULL != blobAttr.pbData)
    {
        MyCoTaskMemFree(blobAttr.pbData);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE CCEnroll::AddCertTypeToRequestWStr(
            LPWSTR szw) {

    HRESULT                     hr              = S_OK;
    DWORD                       errBefore       = GetLastError();

    CERT_NAME_VALUE  nameValue;
    CERT_EXTENSION  ext;
    CERT_EXTENSIONS exts = {1, &ext};

    memset(&ext, 0, sizeof(CERT_EXTENSION));

    nameValue.dwValueType = CERT_RDN_BMP_STRING;
    nameValue.Value.cbData = 0;
    nameValue.Value.pbData = (PBYTE) szw;

    ext.pszObjId = szOID_ENROLL_CERTTYPE_EXTENSION;

    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_UNICODE_ANY_STRING,
            &nameValue,
            NULL,
            &ext.Value.cbData
            ) )
        goto ErrorCryptEncodeObject;

    ext.Value.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, ext.Value.cbData);
    if(NULL == ext.Value.pbData)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto ErrorOutOfMemory;
    }

    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_UNICODE_ANY_STRING,
            &nameValue,
            ext.Value.pbData,
            &ext.Value.cbData
            ) )
        goto ErrorCryptEncodeObject;

    if(S_OK != AddExtensionsToRequest(&exts))
        goto ErrorAddExtensionsToRequest;

    //put cert template extension into CMC stack
    if(!CopyAndPushStackExtension(&ext, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CopyAndPushStackExtensionError;
    }

CommonReturn:

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    if (NULL != ext.Value.pbData)
    {
        LocalFree(ext.Value.pbData);
    }

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorCryptEncodeObject);
TRACE_ERROR(ErrorAddExtensionsToRequest);
TRACE_ERROR(ErrorOutOfMemory);
TRACE_ERROR(CopyAndPushStackExtensionError);
}

#if 0
BOOL
IsOlderThanWhistler(VOID)
{
    HRESULT hr;
    OSVERSIONINFO ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fOlderThanWhistler = FALSE;

    if (!s_fDone)
    {
        s_fDone = TRUE;

        // get and confirm platform info

        ovi.dwOSVersionInfoSize = sizeof(ovi);
        if (!GetVersionEx(&ovi))
        {
            hr = myHLastError();
            goto error;
        }
        if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
        {
            hr = ERROR_CANCELLED;
            goto error;
        }
        if (5 > ovi.dwMajorVersion ||
            (5 == ovi.dwMajorVersion && 1 > ovi.dwMinorVersion))
        {
            s_fOlderThanWhistler = TRUE;
        }
    }

error:
    return(s_fOlderThanWhistler);
}
#endif //0

HRESULT STDMETHODCALLTYPE CCEnroll::AddCertTypeToRequestWStrEx(
            IN  LONG            lType,
            IN  LPCWSTR         pwszOIDOrName,
            IN  LONG            lMajorVersion,
            IN  BOOL            fMinorVersion,
            IN  LONG            lMinorVersion)
{
    HRESULT hr;
    LPCSTR            lpszStructType;
    CERT_NAME_VALUE   nameValue;
    CERT_TEMPLATE_EXT Template;
    VOID             *pv;
    CERT_EXTENSION    ext; //free pbData
    DWORD             cb = 0;
    CHAR             *pszOID = NULL;

    //init
    ZeroMemory(&ext, sizeof(ext));
    ext.fCritical = FALSE;

    if (NULL == pwszOIDOrName)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

#if 0 //don't like the behavior change
    if (IsOlderThanWhistler())
    {
        //downlevel machines don't understand v2 template
        lType = XECT_EXTENSION_V1;
    }
#endif //0

    switch (lType)
    {
        case XECT_EXTENSION_V1:
            ext.pszObjId = szOID_ENROLL_CERTTYPE_EXTENSION;
            nameValue.dwValueType = CERT_RDN_BMP_STRING;
            nameValue.Value.cbData = 0;
            nameValue.Value.pbData = (BYTE*)pwszOIDOrName;
            pv = (VOID*)&nameValue;
            lpszStructType = X509_UNICODE_ANY_STRING;
        break;
        case XECT_EXTENSION_V2:
            ext.pszObjId = szOID_CERTIFICATE_TEMPLATE;
            //convert wsz OID to ansi
            while (TRUE)
            {
                cb = WideCharToMultiByte(
                            GetACP(),
                            0,
                            pwszOIDOrName,
                            -1,
                            pszOID,
                            cb,
                            NULL,
                            NULL);
                if (0 == cb)
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto WideCharToMultiByteError;
                }
                if (NULL != pszOID)
                {
                    //done
                    break;
                }
                pszOID = (CHAR*)LocalAlloc(LMEM_FIXED, cb);
                if (NULL == pszOID)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
            }

            ZeroMemory(&Template, sizeof(Template));
            Template.pszObjId = pszOID;
            Template.dwMajorVersion = lMajorVersion;
            Template.fMinorVersion =  fMinorVersion;
            Template.dwMinorVersion = lMinorVersion;
            pv = (VOID*)&Template;
            lpszStructType = X509_CERTIFICATE_TEMPLATE;
        break;
        default:
            hr = E_INVALIDARG;
            goto InvalidArgError;
        break;
    }

    while (TRUE)
    {
        if (!CryptEncodeObject(
                    X509_ASN_ENCODING,
                    lpszStructType,
                    pv,
                    ext.Value.pbData,
                    &ext.Value.cbData))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptEncodeObjectError;
        }
        if (NULL != ext.Value.pbData)
        {
            //done
            break;
        }
        ext.Value.pbData = (BYTE*)LocalAlloc(LMEM_FIXED, ext.Value.cbData);
        if (NULL == ext.Value.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    //put cert template extension into CMC stack
    if(!CopyAndPushStackExtension(&ext, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CopyAndPushStackExtensionError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pszOID)
    {
        LocalFree(pszOID);
    }
    if (NULL != ext.Value.pbData)
    {
        LocalFree(ext.Value.pbData);
    }
    return hr;

TRACE_ERROR(InvalidArgError)
TRACE_ERROR(CopyAndPushStackExtensionError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptEncodeObjectError)
TRACE_ERROR(WideCharToMultiByteError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::getProviderTypeWStr( 
    IN  LPCWSTR  pwszProvName,
    OUT LONG *   plProvType)
{
    HRESULT  hr;
    DWORD    i = 0;
    DWORD    cb;
    DWORD    dwProvType;
    WCHAR   *pwszEnumProvName = NULL;

    if (NULL == pwszProvName)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    //init
    *plProvType = -1;

    while (TRUE)
    {
        while (TRUE)
        {
            if (!CryptEnumProvidersU(
                    i,
                    NULL,
                    0,
                    &dwProvType,
                    pwszEnumProvName,
                    &cb))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                if (MY_HRESULT_FROM_WIN32(NTE_PROV_TYPE_ENTRY_BAD) == hr)
                {
                    //skip bad one and goto next
                    assert(NULL == pwszEnumProvName);
                    break; //skip this one
                }
                //error
                goto CryptEnumProvidersUError;
            }
            if (NULL != pwszEnumProvName)
            {
                //get the current csp name
                break;
            }
            pwszEnumProvName = (WCHAR*)LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pwszEnumProvName)
            {
                hr = E_OUTOFMEMORY;
                goto OutOfMemoryError;
            }
        }
        if (NULL != pwszEnumProvName)
        {
            if (0 == _wcsicmp(pwszProvName, pwszEnumProvName))
            {
                //found matched name
                *plProvType = (LONG)dwProvType;
                break; //out of outer loop
            }
        }
        //not mached, go to next one
        ++i;
        if (NULL != pwszEnumProvName)
        {
            LocalFree(pwszEnumProvName);
            pwszEnumProvName = NULL;
        }
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszEnumProvName)
    {
        LocalFree(pwszEnumProvName);
    }
    return hr;

TRACE_ERROR(InvalidArgError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptEnumProvidersUError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::InstallPKCS7Blob( 
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7)
{
    return InstallPKCS7BlobEx(pBlobPKCS7, NULL);
}

HRESULT CCEnroll::InstallPKCS7BlobEx( 
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
    /* [out] */ LONG           *plCertInstalled)
{

    HRESULT                     hr                      = S_OK;
    DWORD                       errBefore               = GetLastError();
    HCERTSTORE                  hStoreMsg               = NULL;
 
    EnterCriticalSection(&m_csXEnroll);

    if( !MyCryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                       pBlobPKCS7,
                       (CERT_QUERY_CONTENT_FLAG_CERT |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hStoreMsg,
                       NULL,
                       NULL) )
        goto ErrorCryptQueryObject;

    hr = AddCertsToStores(hStoreMsg, plCertInstalled);
    //don't treat cancel as error but return the err code
    if (S_OK != hr && MY_HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
    {
        goto ErrorAddCertsToStores;
    }

CommonReturn:

    if(hStoreMsg != NULL)
        CertCloseStore(hStoreMsg, 0);

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);
    LeaveCriticalSection(&m_csXEnroll);

    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorCryptQueryObject);
TRACE_ERROR(ErrorAddCertsToStores);
}

HRESULT STDMETHODCALLTYPE CCEnroll::InstallPKCS7( 
    /* [in] */ BSTR wszPKCS7)
{
    CRYPT_DATA_BLOB             blobPKCS7;

    assert(wszPKCS7 != NULL);

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // install the blob
    return(InstallPKCS7Blob(&blobPKCS7));
}

HRESULT STDMETHODCALLTYPE CCEnroll::InstallPKCS7Ex( 
    /* [in] */ BSTR   wszPKCS7,
    /* [out] */ LONG __RPC_FAR *plCertInstalled)
{
    CRYPT_DATA_BLOB             blobPKCS7;

    assert(wszPKCS7 != NULL);

    // just put into a blob
    memset(&blobPKCS7, 0, sizeof(CRYPT_DATA_BLOB));
    blobPKCS7.cbData = SysStringByteLen(wszPKCS7);
    blobPKCS7.pbData = (PBYTE) wszPKCS7;

    // install the blob
    return(InstallPKCS7BlobEx(&blobPKCS7, plCertInstalled));
}


// this is a scary routine. Put in for louis, use at your own risk.
HRESULT STDMETHODCALLTYPE CCEnroll::Reset(void)
{
    HRESULT hr;

    EnterCriticalSection(&m_csXEnroll);
    Destruct();
    hr = Init();
    LeaveCriticalSection(&m_csXEnroll);

    return hr;
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetSupportedKeySpec(
    LONG __RPC_FAR *pdwKeySpec) {

    DWORD               errBefore   = GetLastError();
    DWORD               hr          = S_OK;
    DWORD               cb          = sizeof(DWORD);

    SetLastError(ERROR_SUCCESS);

    assert(pdwKeySpec != NULL);
    *pdwKeySpec = 0;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    if( !CryptGetProvParam(
            m_hVerifyProv,
            PP_KEYSPEC,
            (BYTE *) pdwKeySpec,
            &cb,
            0
            ) ) 
        goto ErrorCryptGetProvParam;

CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
 
    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorCryptGetProvParam);
TRACE_ERROR(GetVerifyProvError);
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetKeyLenEx(
    LONG    lSizeSpec,
    LONG    lKeySpec,
    LONG __RPC_FAR *pdwKeySize)
{
    DWORD       hr = S_OK;
    BOOL        fKeyX;
    BOOL        fKeyInc = FALSE;
    DWORD       dwKeySize = 0xFFFFFFFF;
    DWORD       cb;

    EnterCriticalSection(&m_csXEnroll);

    switch (lKeySpec)
    {
        case XEKL_KEYSPEC_KEYX:
            fKeyX = TRUE;
            break;
        case XEKL_KEYSPEC_SIG:
            fKeyX = FALSE;
            break;
        default:
            //invalid parameter
            hr = E_INVALIDARG;
            goto InvalidArgError;
    }

    switch (lSizeSpec)
    {
        case XEKL_KEYSIZE_MIN:
        case XEKL_KEYSIZE_MAX:
        case XEKL_KEYSIZE_DEFAULT:
            break;
        case XEKL_KEYSIZE_INC:
            fKeyInc = TRUE;
            break;
        default:
            //invalid parameter
            hr = E_INVALIDARG;
            goto InvalidArgError;
    }

    if (!fKeyInc)
    {
        DWORD dwAlg = (fKeyX ? ALG_CLASS_KEY_EXCHANGE : ALG_CLASS_SIGNATURE);

        *pdwKeySize = GetKeySizeInfo(lSizeSpec, dwAlg);
    
        if(0xFFFFFFFF == *pdwKeySize)
        {
            *pdwKeySize = 0;
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto GetKeySizeInfoError;
        }
    }
    else
    {
        if ((fKeyX && (0 != m_dwXhgKeyLenInc)) ||
            (!fKeyX && (0 != m_dwSigKeyLenInc)))
        {
            //we got the cached inc size
            if (fKeyX)
            {
                *pdwKeySize = m_dwXhgKeyLenInc;
            }
            else
            {
                *pdwKeySize = m_dwSigKeyLenInc;
            }
        }
        else
        {
            hr = GetVerifyProv();
            if (S_OK != hr)
            {
                goto GetVerifyProvError;
            }

            //init
            *pdwKeySize = 0;
            cb = sizeof(dwKeySize);
            if (!CryptGetProvParam(
                    m_hVerifyProv,
                    fKeyX ? PP_KEYX_KEYSIZE_INC : PP_SIG_KEYSIZE_INC,
                    (BYTE*)&dwKeySize,
                    &cb,
                    0))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto CryptGetProvParamError;
            }            
            else
            {
                *pdwKeySize = dwKeySize;
                //cache it
                if (fKeyX)
                {
                    m_dwXhgKeyLenInc = dwKeySize;
                }
                else
                {
                    m_dwSigKeyLenInc = dwKeySize;
                }
            }
        }
    }

ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(CryptGetProvParamError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(GetKeySizeInfoError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetKeyLen(
    BOOL    fMin,
    BOOL    fExchange,
    LONG __RPC_FAR *pdwKeySize) {

    DWORD   hr = S_OK;
    LONG    lKeySizeSpec = (fMin ? XEKL_KEYSIZE_MIN : XEKL_KEYSIZE_MAX);

    if(fExchange)
        *pdwKeySize = GetKeySizeInfo(lKeySizeSpec, ALG_CLASS_KEY_EXCHANGE);
    else
        *pdwKeySize = GetKeySizeInfo(lKeySizeSpec, ALG_CLASS_SIGNATURE);
    
    if(*pdwKeySize == 0xFFFFFFFF) {
        *pdwKeySize = 0;
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

    return(hr);
}

DWORD CCEnroll::GetKeySizeInfo(
    LONG    lKeySizeSpec,
    DWORD   algClass) {

    DWORD               i;
    DWORD               cb = sizeof(PROV_ENUMALGS_EX);
    HRESULT             hr = S_OK;
    DWORD               errBefore   = GetLastError();
    DWORD               dwFlags     = CRYPT_FIRST;
    PROV_ENUMALGS_EX    algInfo;
    DWORD               dwKeySize   = 0xFFFFFFFF;
    DWORD               err         = ERROR_SUCCESS;

#ifdef DBG
    //only accept two flags
    assert(ALG_CLASS_KEY_EXCHANGE == algClass ||
           ALG_CLASS_SIGNATURE == algClass);
#endif //DBG

    SetLastError(ERROR_SUCCESS);

    memset(&algInfo, 0, sizeof(algInfo));

    EnterCriticalSection(&m_csXEnroll);

    if ((ALG_CLASS_KEY_EXCHANGE == algClass && 0 != m_dwXhgKeyLenMax) ||
        (ALG_CLASS_SIGNATURE == algClass && 0 != m_dwSigKeyLenMax))
    {
        //got cached sizes, use only KeyLenMax as check
#if DBG
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            assert(0 != m_dwXhgKeyLenMin);
            assert(0 != m_dwXhgKeyLenDef);
        }
        if (ALG_CLASS_SIGNATURE == algClass)
        {
            assert(0 != m_dwSigKeyLenMin);
            assert(0 != m_dwSigKeyLenDef);
        }
#endif //DBG
        //OK, cached, easy
    }
    else
    {
#if DBG
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            assert(0 == m_dwXhgKeyLenMin);
            assert(0 == m_dwXhgKeyLenDef);
        }
        if (ALG_CLASS_SIGNATURE == algClass)
        {
            assert(0 == m_dwSigKeyLenMin);
            assert(0 == m_dwSigKeyLenDef);
        }
#endif //DBG
        hr = GetVerifyProv();
        if (S_OK != hr)
        {
            goto GetVerifyProvError;
        }

        while (CryptGetProvParam(
                m_hVerifyProv,
                PP_ENUMALGS_EX,
                (BYTE *) &algInfo,
                &cb,
                dwFlags))
        {
            // get rid of CRYPT_FIRST flag
            dwFlags = 0;

            if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(algInfo.aiAlgid))
            {
                //cache them
                m_dwXhgKeyLenMax = algInfo.dwMaxLen;
                m_dwXhgKeyLenMin = algInfo.dwMinLen;
                m_dwXhgKeyLenDef = algInfo.dwDefaultLen;
            }
            else if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(algInfo.aiAlgid))
            {
                m_dwSigKeyLenMax = algInfo.dwMaxLen;
                m_dwSigKeyLenMin = algInfo.dwMinLen;
                m_dwSigKeyLenDef = algInfo.dwDefaultLen;
            }

            //see if we cache all sizes through single enum loop
            if (0 != m_dwXhgKeyLenMax &&
                0 != m_dwXhgKeyLenMin &&
                0 != m_dwXhgKeyLenDef &&
                0 != m_dwSigKeyLenMax &&
                0 != m_dwSigKeyLenMin &&
                0 != m_dwSigKeyLenDef)
            {
                //looks we cached all
                break;
            }
        }
    }

    // if we got here,
    // either PP_ENUMALGS_EX is not supported by CSP , should return error
    // or csp doesn't support specified algorithm, should ERROR_NO_MORE_ITEMS

    err = GetLastError();

    if (err != ERROR_SUCCESS)
    {
        if (err != ERROR_NO_MORE_ITEMS) 
        {
            goto ErrorCryptGetProvParam;
        }
        // should be ERROR_NO_MORE_ITEMS
        if ((ALG_CLASS_KEY_EXCHANGE == algClass && 0 != m_dwXhgKeyLenMax) ||
            (ALG_CLASS_SIGNATURE == algClass && 0 != m_dwSigKeyLenMax))
        {
            //we may get here because the csp is signature or exchange only
            //so we cannot cache both once
            SetLastError(ERROR_SUCCESS);
        }
        else
        {
            SetLastError(NTE_BAD_ALGID);
        }
    }
            
    //should have all sizes
    if(XEKL_KEYSIZE_MIN == lKeySizeSpec)
    {
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            dwKeySize = m_dwXhgKeyLenMin;
        }
        else
        {
            dwKeySize = m_dwSigKeyLenMin;
        }
    }
    else if (XEKL_KEYSIZE_MAX == lKeySizeSpec)
    {
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            dwKeySize = m_dwXhgKeyLenMax;
        }
        else
        {
            dwKeySize = m_dwSigKeyLenMax;
        }
    }
    else if (XEKL_KEYSIZE_DEFAULT == lKeySizeSpec)
    {
        if (ALG_CLASS_KEY_EXCHANGE == algClass)
        {
            dwKeySize = m_dwXhgKeyLenDef;
        }
        else
        {
            dwKeySize = m_dwSigKeyLenDef;
        }
    }

CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(dwKeySize);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
 
    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
}


HRESULT STDMETHODCALLTYPE CCEnroll::EnumAlgs(
    /* [in] */ LONG  dwIndex,
    /* [in] */ LONG  algMask,
    /* [out] */ LONG  __RPC_FAR *pdwAlgID) {

    DWORD           errBefore   = GetLastError();
    PROV_ENUMALGS       enumAlgs;
    DWORD           cb          = sizeof(enumAlgs);
    LONG            i           = 0;
    HRESULT         hr          = S_OK;
    DWORD           dwFlags;
    BOOL            f1st = TRUE;

    SetLastError(ERROR_SUCCESS);

    memset(&enumAlgs, 0, sizeof(enumAlgs));
    assert(pdwAlgID != NULL);
    *pdwAlgID = 0;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    if (MAXDWORD != m_dwLastAlgIndex &&
        dwIndex == m_dwLastAlgIndex + 1)
    {
        //continue enum
        dwFlags = 0;
        while (f1st || (DWORD)algMask != GET_ALG_CLASS(enumAlgs.aiAlgid))
        {
            if(!CryptGetProvParam(
                        m_hVerifyProv,
                        PP_ENUMALGS,
                        (BYTE*)&enumAlgs,
                        &cb,
                        dwFlags))
            {
                goto ErrorCryptGetProvParam;
            }
            f1st = FALSE;
        }
    }
    else
    {
        dwFlags = CRYPT_FIRST;
        for (i = 0; i <= dwIndex; i++)
        {
            if(!CryptGetProvParam(
                   m_hVerifyProv,
                   PP_ENUMALGS,
                   (BYTE*)&enumAlgs,
                   &cb,
                   dwFlags))
            {
                    goto ErrorCryptGetProvParam;
            }
            dwFlags = 0; 

            // if we have not hit something we are counting, do it again
            if ((DWORD)algMask != GET_ALG_CLASS(enumAlgs.aiAlgid)) 
            {
                i--;
            }
        }
    }
    //update cached index
    m_dwLastAlgIndex = dwIndex;

    *pdwAlgID = enumAlgs.aiAlgid;
    
CommonReturn:
    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    //error, reset index
    m_dwLastAlgIndex = MAXDWORD;

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
}


HRESULT STDMETHODCALLTYPE CCEnroll::GetAlgNameWStr(
    /* [in] */ LONG               algID,
    /* [out] */ LPWSTR __RPC_FAR *ppwsz) {

    DWORD           errBefore   = GetLastError();
    PROV_ENUMALGS       enumAlgs;
    DWORD           cb          = sizeof(enumAlgs);
    HRESULT         hr          = S_OK;
    DWORD           dwFlags     = CRYPT_FIRST;

    SetLastError(ERROR_SUCCESS);

    memset(&enumAlgs, 0, sizeof(enumAlgs));
    
    EnterCriticalSection(&m_csXEnroll);

    hr = GetVerifyProv();
    if (S_OK != hr)
    {
        goto GetVerifyProvError;
    }

    do {
   
        if( !CryptGetProvParam(
            m_hVerifyProv,
            PP_ENUMALGS,
            (BYTE *) &enumAlgs,
            &cb,
            dwFlags) )
            goto ErrorCryptGetProvParam;

        dwFlags = 0; 
        
   } while((DWORD)algID != enumAlgs.aiAlgid);

   if( (*ppwsz = WideFromMB(enumAlgs.szName)) == NULL )
        goto ErrorOutOfMem;
    
CommonReturn:

    SetLastError(errBefore);

    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(GetVerifyProvError);
TRACE_ERROR(ErrorCryptGetProvParam);
TRACE_ERROR(ErrorOutOfMem);
}

HRESULT STDMETHODCALLTYPE CCEnroll::GetAlgName(
            /* [in] */ LONG                     algID,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) {

    DWORD       errBefore   = GetLastError();
    LPWSTR      pwsz        = NULL;
    HRESULT     hr          = S_OK;

    SetLastError(ERROR_SUCCESS);

    assert(pbstr != NULL);

    if((hr = GetAlgNameWStr(algID, &pwsz)) != S_OK)
        goto ErrorgetAlgNameWStr;

    if( (*pbstr = SysAllocString(pwsz)) == NULL )
        goto ErrorSysAllocString;

CommonReturn:

    if(pwsz != NULL)
        MyCoTaskMemFree(pwsz);

    SetLastError(errBefore);
    return(hr);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS)
        SetLastError(E_UNEXPECTED);
    hr = MY_HRESULT_FROM_WIN32(GetLastError());

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    goto CommonReturn;

TRACE_ERROR(ErrorgetAlgNameWStr);
TRACE_ERROR(ErrorSysAllocString);
}

HRESULT STDMETHODCALLTYPE CCEnroll::get_ReuseHardwareKeyIfUnableToGenNew(
    /* [retval][out] */ BOOL __RPC_FAR *fBool) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fReuseHardwareKeyIfUnableToGenNew;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::put_ReuseHardwareKeyIfUnableToGenNew(
    /* [in] */ BOOL fBool) {
    EnterCriticalSection(&m_csXEnroll);
    m_fReuseHardwareKeyIfUnableToGenNew = fBool;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreMy(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csXEnroll);

    if(m_MyStore.hStore != NULL)
        hr = E_ACCESSDENIED;
        
    else {
        if(m_MyStore.wszName != wszMY)
            MyCoTaskMemFree(m_MyStore.wszName);
            
        m_MyStore.wszName = NULL;
        m_MyStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreCA(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_CAStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_CAStore.wszName != wszCA)
            MyCoTaskMemFree(m_CAStore.wszName);
            
        m_CAStore.wszName = NULL;
        m_CAStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);

    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreROOT(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RootStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RootStore.wszName != wszROOT)
            MyCoTaskMemFree(m_RootStore.wszName);
            
        m_RootStore.wszName = NULL;
        m_RootStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetHStoreRequest(
    HCERTSTORE   hStore
    ) {
    HRESULT hr = S_OK;
    
    EnterCriticalSection(&m_csXEnroll);
    
    if(m_RequestStore.hStore != NULL)
        hr = E_ACCESSDENIED;
    else {
        if(m_RequestStore.wszName != wszREQUEST)
            MyCoTaskMemFree(m_RequestStore.wszName);
            
        m_RequestStore.wszName = NULL;
        m_RequestStore.hStore = CertDuplicateStore(hStore);
    }

    LeaveCriticalSection(&m_csXEnroll);
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE  CCEnroll::put_LimitExchangeKeyToEncipherment(
    BOOL    fBool
    ) {
    
    EnterCriticalSection(&m_csXEnroll);
    m_fLimitExchangeKeyToEncipherment = fBool;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE  CCEnroll::get_LimitExchangeKeyToEncipherment(
    BOOL * fBool
    ) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fLimitExchangeKeyToEncipherment;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE  CCEnroll::put_EnableSMIMECapabilities(
    BOOL fSMIME
    )
{
    HRESULT hr;
    
    EnterCriticalSection(&m_csXEnroll);

    if (m_fKeySpecSetByClient)
    {
        //SMIME is set by the client
        if (AT_SIGNATURE == m_keyProvInfo.dwKeySpec && fSMIME)
        {
            //try to set signature key spec also SMIME
            hr = XENROLL_E_KEYSPEC_SMIME_MISMATCH;
            goto MismatchError;
        }
    }
    else
    {
        //user didn't set key spec
        //determine the spec accordingly
        m_keyProvInfo.dwKeySpec = fSMIME ? AT_KEYEXCHANGE : AT_SIGNATURE;
    }
    m_fEnableSMIMECapabilities = fSMIME;
    m_fSMIMESetByClient = TRUE;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return(hr);

TRACE_ERROR(MismatchError)
}

HRESULT STDMETHODCALLTYPE  CCEnroll::get_EnableSMIMECapabilities(
    BOOL * fBool
    ) {

    EnterCriticalSection(&m_csXEnroll);
    *fBool = m_fEnableSMIMECapabilities;
    LeaveCriticalSection(&m_csXEnroll);
    return(S_OK);
    }

//ICEnroll4

HRESULT
GetCertificateContextFromBStr(
    IN  BSTR  bstrCert,
    OUT PCCERT_CONTEXT *ppCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pCert = NULL;
    BYTE    *pbCert = NULL;
    DWORD    cbCert = 0;

    // could be any form, binary or base64
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                        (WCHAR*)bstrCert,
                        SysStringLen(bstrCert),
                        CRYPT_STRING_ANY,
                        pbCert,
                        &cbCert,
                        NULL,
                        NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbCert)
        {
            break; //done
        }
        pbCert = (BYTE*)LocalAlloc(LMEM_FIXED, cbCert);
        if (NULL == pbCert)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    pCert = CertCreateCertificateContext(
                                X509_ASN_ENCODING,
                                pbCert,
                                cbCert);
    if (NULL == pCert)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertCreateCertificateContextError;
    }
    *ppCert = pCert;
    pCert = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pbCert)
    {
        LocalFree(pbCert);
    }
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return (hr);

TRACE_ERROR(CertCreateCertificateContextError)
TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(OutOfMemoryError)
}


HRESULT STDMETHODCALLTYPE
CCEnroll::put_PrivateKeyArchiveCertificate(
    IN  BSTR  bstrCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pPrivateKeyArchiveCert = NULL;

    if (NULL != bstrCert)
    {
        hr = GetCertificateContextFromBStr(bstrCert, &pPrivateKeyArchiveCert);
        if (S_OK != hr)
        {
            goto GetCertificateContextFromBStrError;
        }
    }

    // set key archive certificate
    hr = SetPrivateKeyArchiveCertificate(pPrivateKeyArchiveCert);
    if (S_OK != hr)
    {
        goto SetPrivateKeyArchiveCertificateError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pPrivateKeyArchiveCert)
    {
        CertFreeCertificateContext(pPrivateKeyArchiveCert);
    }
    return hr;

TRACE_ERROR(GetCertificateContextFromBStrError)
TRACE_ERROR(SetPrivateKeyArchiveCertificateError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::get_PrivateKeyArchiveCertificate(
    OUT BSTR __RPC_FAR *pbstrCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pPrivateKeyArchiveCert = NULL;
    CRYPT_DATA_BLOB blobCert;

    //init
    *pbstrCert = NULL;

    pPrivateKeyArchiveCert = GetPrivateKeyArchiveCertificate();

    if (NULL != pPrivateKeyArchiveCert)
    {
        blobCert.pbData = pPrivateKeyArchiveCert->pbCertEncoded;
        blobCert.cbData = pPrivateKeyArchiveCert->cbCertEncoded;
        hr = BlobToBstring(&blobCert, CRYPT_STRING_BASE64HEADER, pbstrCert);
        if (S_OK != hr)
        {
            goto BlobToBstringError;
        }
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pPrivateKeyArchiveCert)
    {
        CertFreeCertificateContext(pPrivateKeyArchiveCert);
    }
    return hr;

TRACE_ERROR(BlobToBstringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::put_ThumbPrint(IN BSTR bstrThumbPrint) 
{ 
    CRYPT_DATA_BLOB hashBlob; 
    HRESULT         hr; 

    if (bstrThumbPrint == NULL)
        return E_INVALIDARG; 

    hashBlob.cbData = 0; 
    hashBlob.pbData = NULL;

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_BASE64,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
      goto MemoryErr; 

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_BASE64,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hr = this->put_ThumbPrintWStr(hashBlob); 

 ErrorReturn: 
    if (NULL != hashBlob.pbData) { LocalFree(hashBlob.pbData); } 
    return hr; 

SET_HRESULT(MyCryptToBinaryErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(MemoryErr,          E_OUTOFMEMORY); 
} 

HRESULT STDMETHODCALLTYPE
CCEnroll::put_ThumbPrintWStr(IN CRYPT_DATA_BLOB  hashBlob)
{
    if (hashBlob.pbData == NULL)
        return E_INVALIDARG; 
    
    if (m_hashBlobPendingRequest.pbData != NULL)
    {
        LocalFree(m_hashBlobPendingRequest.pbData); 
        m_hashBlobPendingRequest.pbData = NULL; 
    }

    m_hashBlobPendingRequest.cbData = hashBlob.cbData; 
    m_hashBlobPendingRequest.pbData = (LPBYTE)LocalAlloc(LPTR, m_hashBlobPendingRequest.cbData);
    
    if (m_hashBlobPendingRequest.pbData == NULL)
        return E_OUTOFMEMORY; 

    CopyMemory(m_hashBlobPendingRequest.pbData, hashBlob.pbData, hashBlob.cbData); 
    return S_OK; 
}
     
HRESULT STDMETHODCALLTYPE 
CCEnroll::get_ThumbPrint(OUT BSTR __RPC_FAR *pbstrThumbPrint) 
{ 
    CRYPT_DATA_BLOB hashBlob; 
    DWORD           cchThumbPrintStr; 
    HRESULT         hr; 
    WCHAR          *pwszThumbPrint = NULL; 
    int             n, i;

   // Input validation: 
    if (pbstrThumbPrint == NULL)
        return E_INVALIDARG; 

    // Initialize locals: 
    ZeroMemory(&hashBlob, sizeof(hashBlob));
    *pbstrThumbPrint  = NULL; 
     
    if (S_OK != (hr = this->get_ThumbPrintWStr(&hashBlob)))
        goto ErrorReturn; 
    
    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
        goto MemoryErr; 
        
    if (S_OK != (hr = this->get_ThumbPrintWStr(&hashBlob)))
        goto ErrorReturn; 

    // Now we have a binary thumbprint.  Convert this to base64:
    while (TRUE)
    {
        if (!MyCryptBinaryToStringW(
                        hashBlob.pbData, 
                        hashBlob.cbData, 
                        CRYPT_STRING_BASE64 | CRYPT_STRING_NOCR,
                        pwszThumbPrint,
                        &cchThumbPrintStr))
        {
            goto MyCryptToStringErr; 
        }
        if (NULL != pwszThumbPrint)
        {
            //done
            break;
        }
        pwszThumbPrint = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                          cchThumbPrintStr * sizeof(WCHAR)); 
        if (NULL == pwszThumbPrint)
        {
            goto MemoryErr; 
        }
    }

    //make sure no new line and CR
    n = wcslen(pwszThumbPrint);
    for (i = n - 1; i > -1; --i)
    {
        if (L'\r' != pwszThumbPrint[i] &&
            L'\n' != pwszThumbPrint[i])
        {
            break; //done
        }
        pwszThumbPrint[i] = L'\0'; //null it
    }

    // Ok, we've acquired the HASH.  Now copy it to the out parameter: 
    *pbstrThumbPrint = SysAllocString(pwszThumbPrint); 
    if (NULL == *pbstrThumbPrint)
    {
        goto MemoryErr; 
    }

    hr = S_OK; 
ErrorReturn:
    if (NULL != hashBlob.pbData)
    {
        LocalFree(hashBlob.pbData);
    }
    if (NULL != pwszThumbPrint)
    {
        LocalFree(pwszThumbPrint);
    } 
    return hr; 

SET_HRESULT(MyCryptToStringErr, MY_HRESULT_FROM_WIN32(GetLastError())) 
SET_HRESULT(MemoryErr, E_OUTOFMEMORY) 
} 

HRESULT STDMETHODCALLTYPE
CCEnroll::get_ThumbPrintWStr(IN OUT PCRYPT_DATA_BLOB pHashBlob) { 
    HRESULT hr = S_OK; 

    // Input validation: 
    if (NULL == pHashBlob)
        return E_INVALIDARG; 

    // TWO CASES: 
    // 
    // 1)  the thumbprint has been explicitly set by an external caller. 
    // 2)  the thumbprint _wasn't_ explicitly set.  In this case, use the thumbprint
    //     of the request generated by the last call to createPKCS10().
    //
    // CASE 1: 
    //
    if (NULL != m_hashBlobPendingRequest.pbData)
    {
        if (NULL != pHashBlob->pbData)
        {
            if (pHashBlob->cbData < m_hashBlobPendingRequest.cbData) { 
                hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
            }
            else { 
                CopyMemory(pHashBlob->pbData, m_hashBlobPendingRequest.pbData, m_hashBlobPendingRequest.cbData);
                hr = S_OK;
            }
        }

        pHashBlob->cbData = m_hashBlobPendingRequest.cbData; 
        return hr; 
    }
    // CASE 2: 
    // 
    else
    {
        if (NULL == m_pCertContextPendingRequest)
            return E_POINTER; 
     
        // Executes at most twice.  
        if (!CertGetCertificateContextProperty
            (m_pCertContextPendingRequest, 
             CERT_HASH_PROP_ID, 
             (LPVOID)(pHashBlob->pbData), 
             &(pHashBlob->cbData)))
        {
            return MY_HRESULT_FROM_WIN32(GetLastError()); 
        }

        return S_OK; 
    }
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::binaryToString(
    IN  LONG  Flags,
    IN  BSTR  strBinary,
    OUT BSTR *pstrEncoded)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobBinary;
    WCHAR            *pwszEncoded = NULL;

    blobBinary.pbData = (BYTE*)strBinary;
    blobBinary.cbData = SysStringByteLen(strBinary);

    hr = binaryBlobToString(Flags, &blobBinary, &pwszEncoded);
    if (S_OK != hr)
    {
        goto binaryBlobToStringError;
    }

    *pstrEncoded = SysAllocString(pwszEncoded);
    if (NULL == pstrEncoded)
    {
        hr = E_OUTOFMEMORY;
        goto SysAllocStringLenError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszEncoded)
    {
        MyCoTaskMemFree(pwszEncoded);
    }
    return hr;

TRACE_ERROR(binaryBlobToStringError);
TRACE_ERROR(SysAllocStringLenError);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::stringToBinary(
    IN  LONG  Flags,
    IN  BSTR  strEncoded,
    OUT BSTR *pstrBinary)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobBinary;

    ZeroMemory(&blobBinary, sizeof(blobBinary));

    hr = stringToBinaryBlob(Flags, (LPCWSTR)strEncoded, &blobBinary, NULL, NULL);
    if (S_OK != hr)
    {
        goto stringToBinaryBlobError;
    }
    *pstrBinary = SysAllocStringLen(
            (OLECHAR*)blobBinary.pbData, blobBinary.cbData);
    if (NULL == pstrBinary)
    {
        hr = E_OUTOFMEMORY;
        goto SysAllocStringLenError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobBinary.pbData)
    {
        MyCoTaskMemFree(blobBinary.pbData);
    }
    return hr;

TRACE_ERROR(stringToBinaryBlobError);
TRACE_ERROR(SysAllocStringLenError);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addExtensionToRequest(
    IN  LONG  Flags,
    IN  BSTR  strName,
    IN  BSTR  strValue)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobValue;
    DWORD  cchStrValue = SysStringLen(strValue);
    BYTE   *pbExtVal = NULL;
    DWORD  cbExtVal = 0;

    //convert to binary in case base64 etc.
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (WCHAR*)strValue,
                    cchStrValue,
                    CRYPT_STRING_ANY,
                    pbExtVal,
                    &cbExtVal,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbExtVal)
        {
            //done
            break;
        }
        pbExtVal = (BYTE*)LocalAlloc(LMEM_FIXED, cbExtVal);
        if (NULL == pbExtVal)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    blobValue.pbData = pbExtVal;
    blobValue.cbData = cbExtVal;

    hr = addExtensionToRequestWStr(Flags, strName, &blobValue);
    if (S_OK != hr)
    {
        goto addExtensionToRequestWStrError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pbExtVal)
    {
        LocalFree(pbExtVal);
    }
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(addExtensionToRequestWStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addAttributeToRequest(
    IN  LONG  Flags,
    IN  BSTR  strName,
    IN  BSTR  strValue)
{
    HRESULT hr;
    CRYPT_DATA_BLOB   blobValue;
    DWORD  cchStrValue = SysStringLen(strValue);
    BYTE   *pbAttVal = NULL;
    DWORD  cbAttVal = 0;

    //convert to binary in case base64 etc.
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (WCHAR*)strValue,
                    cchStrValue,
                    CRYPT_STRING_ANY,
                    pbAttVal,
                    &cbAttVal,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pbAttVal)
        {
            //done
            break;
        }
        pbAttVal = (BYTE*)LocalAlloc(LMEM_FIXED, cbAttVal);
        if (NULL == pbAttVal)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    blobValue.pbData = pbAttVal;
    blobValue.cbData = cbAttVal;

    hr = addAttributeToRequestWStr(Flags, strName, &blobValue);
    if (S_OK != hr)
    {
        goto addAttributeToRequestWStrError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pbAttVal)
    {
        LocalFree(pbAttVal);
    }
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(LocalAllocError)
TRACE_ERROR(addAttributeToRequestWStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addNameValuePairToRequest(
    IN  LONG  Flags, //not used
    IN  BSTR  strName,
    IN  BSTR  strValue)
{
    return addNameValuePairToRequestWStr(Flags, strName, strValue);
}

HRESULT STDMETHODCALLTYPE CCEnroll::addBlobPropertyToCertificate(
    IN  LONG   lPropertyId,
    IN  LONG   lFlags,
    IN  BSTR   strProperty)
{
    CRYPT_DATA_BLOB  blob;

    blob.pbData = (BYTE*)strProperty;
    blob.cbData = SysStringByteLen(strProperty);
    if (0x0 != (XECP_STRING_PROPERTY & lFlags))
    {
        //this is a string property, including null
        blob.cbData += sizeof(WCHAR);
    }

    return addBlobPropertyToCertificateWStr(lPropertyId, lFlags, &blob);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::put_SignerCertificate(
    IN  BSTR  bstrCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pSignerCert = NULL;

    if (NULL != bstrCert)
    {
        hr = GetCertificateContextFromBStr(bstrCert, &pSignerCert);
        if (S_OK != hr)
        {
            goto GetCertificateContextFromBStrError;
        }
    }

    // set key archive certificate
    hr = SetSignerCertificate(pSignerCert);
    if (S_OK != hr)
    {
        goto SetSignerCertificateError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pSignerCert)
    {
        CertFreeCertificateContext(pSignerCert);
    }
    return hr;

TRACE_ERROR(GetCertificateContextFromBStrError)
TRACE_ERROR(SetSignerCertificateError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::resetExtensions()
{
    HRESULT hr = S_OK;

    FreeAllStackExtension();

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::resetAttributes()
{
    HRESULT hr = S_OK;

    FreeAllStackAttribute();

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createRequest(
    IN  LONG  Flags,
    IN  BSTR  strDNName,
    IN  BSTR  strUsage,
    OUT BSTR *pstrRequest)
{
    return createRequestWStrBStr(
                Flags,
                (LPCWSTR)strDNName,
                (LPCWSTR)strUsage,
                CRYPT_STRING_BASE64REQUESTHEADER,
                pstrRequest);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFileRequest(
    IN  LONG  Flags,
    IN  BSTR  strDNName,
    IN  BSTR  strUsage,
    IN  BSTR  strRequestFileName)
{
    return createFileRequestWStr(Flags, (LPCWSTR)strDNName, (LPCWSTR)strUsage, (LPCWSTR)strRequestFileName);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptResponse(
    IN  BSTR  bstrResponse)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;
    DWORD  cchStrResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    if (NULL == bstrResponse)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //assume a string
    cchStrResponse = SysStringLen(bstrResponse);

    //convert to binary in case base64 etc.
    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (WCHAR*)bstrResponse,
                    cchStrResponse,
                    CRYPT_STRING_ANY,
                    blobResponse.pbData,
                    &blobResponse.cbData,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != blobResponse.pbData)
        {
            //done
            break;
        }
        blobResponse.pbData = (BYTE*)LocalAlloc(
                                        LMEM_FIXED, blobResponse.cbData);
        if (NULL == blobResponse.pbData)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }

    // accept the blob
    hr = acceptResponseBlob(&blobResponse);
    if (S_OK != hr)
    {
        goto acceptResponseBlobError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobResponse.pbData)
    {
        LocalFree(blobResponse.pbData);
    }
    return (hr);

TRACE_ERROR(acceptResponseBlobError)
TRACE_ERROR(InvalidParameterError)
TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(LocalAllocError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptFileResponse(
    IN  BSTR  bstrResponseFileName)
{
    return acceptFileResponseWStr((LPCWSTR)bstrResponseFileName);
}

HRESULT
CCEnroll::GetCertFromResponseBlobToBStr(
    IN  CRYPT_DATA_BLOB  *pBlobResponse,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobCert;
    PCCERT_CONTEXT pCert = NULL;

    hr = getCertContextFromResponseBlob(
                pBlobResponse,
                &pCert);
    if (S_OK != hr)
    {
        goto getCertContextFromResponseBlobError;
    }

    assert(NULL != pCert);

    blobCert.pbData = pCert->pbCertEncoded;
    blobCert.cbData = pCert->cbCertEncoded;
    hr = BlobToBstring(&blobCert, CRYPT_STRING_BASE64HEADER, pstrCert);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return hr;

TRACE_ERROR(getCertContextFromResponseBlobError)
TRACE_ERROR(BlobToBstringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertFromResponse(
    IN  BSTR  strResponse,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    if (NULL == strResponse)
    {
        hr = E_POINTER;
        goto NullPointerError;
    }

    hr = BstringToBlob(strResponse, &blobResponse);
    if (S_OK != hr)
    {
        goto BstringToBlobError;
    }

    hr = GetCertFromResponseBlobToBStr(
                &blobResponse,
                pstrCert);
    if (S_OK != hr)
    {
        goto GetCertFromResponseBlobToBStrError;
    }

    hr = S_OK;
ErrorReturn:
    return hr;

TRACE_ERROR(NullPointerError)
TRACE_ERROR(BstringToBlobError)
TRACE_ERROR(GetCertFromResponseBlobToBStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertFromFileResponse(
    IN  BSTR  strResponseFileName,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;
    CRYPT_DATA_BLOB blobCert;
    PCCERT_CONTEXT pCert = NULL;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    hr = xeStringToBinaryFromFile(
                (LPCWSTR)strResponseFileName,
                &blobResponse.pbData,
                &blobResponse.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    hr = GetCertFromResponseBlobToBStr(
                &blobResponse,
                pstrCert);
    if (S_OK != hr)
    {
        goto GetCertFromResponseBlobToBStrError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobResponse.pbData)
    {
        LocalFree(blobResponse.pbData);
    }
    return hr;

TRACE_ERROR(xeStringToBinaryFromFileError)
TRACE_ERROR(GetCertFromResponseBlobToBStrError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createPFX(
    IN  BSTR  strPassword,
    OUT BSTR *pstrPFX)
{
    return createPFXWStrBStr((LPCWSTR)strPassword, pstrPFX);
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFilePFX(
    IN  BSTR  strPassword,
    IN  BSTR  strPFXFileName)
{
    return createFilePFXWStr((LPCWSTR)strPassword, (LPCWSTR)strPFXFileName);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::setPendingRequestInfo(
    IN  LONG  lRequestID,
    IN  BSTR  strCADNS,
    IN  BSTR  strCAName,
    IN  BSTR  strFriendlyName
    )
{
    return setPendingRequestInfoWStr(
                lRequestID,
                (LPCWSTR)strCADNS,
                (LPCWSTR)strCAName,
                (LPCWSTR)strFriendlyName);
}

HRESULT STDMETHODCALLTYPE
CCEnroll::enumPendingRequest(
    IN  LONG     lIndex,
    IN  LONG     lDesiredProperty,
    OUT VARIANT *pvarProperty
    )
{
    CRYPT_DATA_BLOB  dataBlobProperty; 
    HRESULT          hr; 
    LONG             lProperty; 
    VARIANT          varProperty; 

    // See if we're initializing an enumeration.  If so, just dispatch to
    // enumPendingRequestWStr: 
    if (XEPR_ENUM_FIRST == lIndex) { 
        return enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL); 
    }

    // Input validation: 
    if (lIndex < 0 || NULL == pvarProperty)
        return E_INVALIDARG; 

    // Initialize locals: 
    memset(&varProperty,      0, sizeof(VARIANT));
    memset(&dataBlobProperty, 0, sizeof(CRYPT_DATA_BLOB)); 

    switch (lDesiredProperty) 
        { 
        case XEPR_REQUESTID: 
        case XEPR_VERSION:
            if (S_OK != (hr = enumPendingRequestWStr(lIndex, lDesiredProperty, &lProperty)))
                goto ErrorReturn;

            varProperty.vt   = VT_I4; 
            varProperty.lVal = lProperty; 
            *pvarProperty    = varProperty; 
            goto CommonReturn; 

        case XEPR_CANAME:       
        case XEPR_CAFRIENDLYNAME: 
        case XEPR_CADNS:          
        case XEPR_HASH:            
        case XEPR_V1TEMPLATENAME:  
        case XEPR_V2TEMPLATEOID:   
            dataBlobProperty.cbData = 0; 
            dataBlobProperty.pbData = NULL;

            // Determine the size of the property we desire. 
            hr = enumPendingRequestWStr(lIndex, lDesiredProperty, (LPVOID)&dataBlobProperty);
            if (S_OK != hr || 0 == dataBlobProperty.cbData)
                goto ErrorReturn; 

            dataBlobProperty.pbData = (LPBYTE)LocalAlloc(LPTR, dataBlobProperty.cbData); 
            if (NULL == dataBlobProperty.pbData)
                goto MemoryErr; 

            // Request the property, using our newly allocated buffer. 
            hr = enumPendingRequestWStr(lIndex, lDesiredProperty, (LPVOID)&dataBlobProperty);
            if (hr != S_OK)
                goto ErrorReturn; 

            varProperty.vt      = VT_BSTR; 
            varProperty.bstrVal = SysAllocStringByteLen((LPCSTR)dataBlobProperty.pbData, dataBlobProperty.cbData); 
            if (NULL == varProperty.bstrVal)
                goto MemoryErr; 

            *pvarProperty = varProperty; 
            goto CommonReturn; 

        case XEPR_DATE:            
            goto NotImplErr; 

        default: 
            goto InvalidArgErr; 
    }

 CommonReturn: 
    if (NULL != dataBlobProperty.pbData) { LocalFree(dataBlobProperty.pbData); } 
    return hr; 

 ErrorReturn:
    if (NULL != varProperty.bstrVal) { SysFreeString(varProperty.bstrVal); } 
    goto CommonReturn; 

SET_HRESULT(InvalidArgErr, E_INVALIDARG); 
SET_HRESULT(MemoryErr,     E_OUTOFMEMORY); 
SET_HRESULT(NotImplErr,    E_NOTIMPL); 
}

HRESULT STDMETHODCALLTYPE
CCEnroll::removePendingRequest(
    IN  BSTR bstrThumbPrint
    )
{
    CRYPT_DATA_BLOB hashBlob; 
    HRESULT         hr; 

    if (bstrThumbPrint == NULL)
        return E_INVALIDARG; 

    hashBlob.cbData = 0; 
    hashBlob.pbData = NULL;

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_ANY,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
      goto MemoryErr; 

    if (!MyCryptStringToBinaryW
        ((WCHAR*)bstrThumbPrint,
         SysStringLen(bstrThumbPrint),
         CRYPT_STRING_ANY,
         hashBlob.pbData, 
         &hashBlob.cbData, 
         NULL,
         NULL))
      goto MyCryptToBinaryErr; 

    hr = this->removePendingRequestWStr(hashBlob); 

 CommonReturn: 
    if (NULL != hashBlob.pbData) { LocalFree(hashBlob.pbData); } 
    return hr; 

 ErrorReturn: 
    goto CommonReturn; 

SET_HRESULT(MyCryptToBinaryErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(MemoryErr,          E_OUTOFMEMORY); 
}

//IEnroll4

HRESULT
myCertGetNameString(
    IN  PCCERT_CONTEXT pCert,
    IN  BOOL           fIssuer,
    OUT WCHAR        **ppwszName)
{
    HRESULT  hr;
    DWORD    dwFlags = fIssuer ? CERT_NAME_ISSUER_FLAG : 0;
    DWORD    dwTypePara;
    WCHAR   *pwszName = NULL;
    DWORD    cch = 0;

    while (TRUE)
    {
        cch = CertGetNameStringW(
                pCert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                dwFlags,
                (void*)&dwTypePara,
                pwszName,
                cch);
        if (0 == cch)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertGetNameStringError;
        }
        if (NULL != pwszName)
        {
            //done
            break;
        }
        pwszName = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwszName)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }
    *ppwszName = pwszName;
    pwszName = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszName)
    {
        LocalFree(pwszName);
    }
    return hr;

TRACE_ERROR(CertGetNameStringError)
TRACE_ERROR(OutOfMemoryError)
}

HRESULT CCEnroll::GetGoodCertContext(
    IN PCCERT_CONTEXT pCertContext,
    OUT PCCERT_CONTEXT *ppGoodCertContext)
{
    HRESULT hr;
    PCCERT_CONTEXT  pGoodCertContext = NULL;
    DWORD           cb;

    //init
    *ppGoodCertContext = NULL;

    if(pCertContext == NULL)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //see if the passed cert has kpi
    if(CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &cb))
    {
        //this means kpi exists, passed cert is good
        pGoodCertContext = CertDuplicateCertificateContext(pCertContext);
        if (NULL == pGoodCertContext)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertDuplicateCertificateContextError;
        }
    }

    *ppGoodCertContext = pGoodCertContext;
    pGoodCertContext = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pGoodCertContext)
    {
        CertFreeCertificateContext(pGoodCertContext);
    }
    return hr;

TRACE_ERROR(InvalidParameterError)
TRACE_ERROR(CertDuplicateCertificateContextError)
}

HRESULT STDMETHODCALLTYPE CCEnroll::SetSignerCertificate(
    IN PCCERT_CONTEXT pCertContext)
{
    HRESULT hr;
    PCCERT_CONTEXT  pCertGoodContext = NULL;

    EnterCriticalSection(&m_csXEnroll);

    hr = GetGoodCertContext(pCertContext, &pCertGoodContext);
    if (S_OK != hr)
    {
        goto GetGoodCertContextError;
    }
    if(NULL != m_pCertContextSigner)
    {
        CertFreeCertificateContext(m_pCertContextSigner);
    }
    m_pCertContextSigner = pCertGoodContext;

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(GetGoodCertContextError)
}

HRESULT
VerifyPrivateKeyArchiveCertificate(
    IN PCCERT_CONTEXT pCert)
{
    HRESULT  hr;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_POLICY_PARA ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_CONTEXT const *pCertChain = NULL;
    char *apszCAXchgOids[] = {szOID_KP_CA_EXCHANGE};
    WCHAR               *pwszSubject = NULL;
    WCHAR               *pwszIssuer = NULL;
    WCHAR               *pwszDesignedSubject = NULL;

    //easy check to make sure ca exchange cert issuer and subject
    //names are in convention
    hr = myCertGetNameString(
                pCert,
                FALSE,
                &pwszSubject);
    if (S_OK != hr)
    {
        goto myCertGetNameStringError;
    }

    hr = myCertGetNameString(
                pCert,
                TRUE,
                &pwszIssuer);
    if (S_OK != hr)
    {
        goto myCertGetNameStringError;
    }

    hr = myAddNameSuffix(
                pwszIssuer,
                wszCNXCHGSUFFIX,
                cchCOMMONNAMEMAX_XELIB,
                &pwszDesignedSubject);
    if (S_OK != hr)
    {
        goto myAddNameSuffixError;
    }

    if (0 != wcscmp(pwszSubject, pwszDesignedSubject))
    {
        //unexpected, they should match
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = apszCAXchgOids;
    ChainParams.RequestedUsage.Usage.cUsageIdentifier = ARRAYSIZE(apszCAXchgOids);

    //get cert chain 1st
    if (!MyCertGetCertificateChain(
                NULL,   //HHCE_CURRENT_USER
                pCert,   //ca exchange cert
                NULL,   //use current system time
                NULL,   //no additional stores
                &ChainParams,   //chain params
                0,   //no crl check
                NULL,   //reserved
                &pCertChain))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertGetCertificateChainError;
    }

    ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;

    //verify the chain
    if (!MyCertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_BASE,
                pCertChain,
                &ChainPolicy,
                &PolicyStatus))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertVerifyCertificateChainPolicyError;
    }

    if (S_OK != PolicyStatus.dwError)
    {
        //chain back to root fails
        hr = PolicyStatus.dwError;
        goto CertVerifyCertificateChainPolicyError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pCertChain)
    {
        MyCertFreeCertificateChain(pCertChain);
    }
    if (NULL != pwszSubject)
    {
        LocalFree(pwszSubject);
    }
    if (NULL != pwszDesignedSubject)
    {
        LocalFree(pwszDesignedSubject);
    }
    if (NULL != pwszIssuer)
    {
        LocalFree(pwszIssuer);
    }
    return hr;

TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CertVerifyCertificateChainPolicyError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(myCertGetNameStringError)
TRACE_ERROR(myAddNameSuffixError)
}

HRESULT STDMETHODCALLTYPE
CCEnroll::SetPrivateKeyArchiveCertificate(
    IN PCCERT_CONTEXT  pPrivateKeyArchiveCert)
{
    HRESULT hr;
    PCCERT_CONTEXT pCert = NULL;

    if (NULL != pPrivateKeyArchiveCert)
    {
        //duplicate the cert
        pCert = CertDuplicateCertificateContext(pPrivateKeyArchiveCert);
        if (NULL == pCert)
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertDuplicateCertificateContextError;
        }

        //verify ca exchange cert
        hr = VerifyPrivateKeyArchiveCertificate(pCert);
        if (S_OK != hr)
        {
            goto VerifyPrivateKeyArchiveCertificateError;
        }
    }

    EnterCriticalSection(&m_csXEnroll);

    if (NULL != m_PrivateKeyArchiveCertificate)
    {
        CertFreeCertificateContext(m_PrivateKeyArchiveCertificate);
    }
    m_PrivateKeyArchiveCertificate = pCert;

    LeaveCriticalSection(&m_csXEnroll);

    hr = S_OK;
ErrorReturn:
    return (hr);

TRACE_ERROR(CertDuplicateCertificateContextError)
TRACE_ERROR(VerifyPrivateKeyArchiveCertificateError)
}
                
PCCERT_CONTEXT STDMETHODCALLTYPE
CCEnroll::GetPrivateKeyArchiveCertificate(void)
{
    PCCERT_CONTEXT pCert = NULL;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL != m_PrivateKeyArchiveCertificate)
    {
        pCert = CertDuplicateCertificateContext(m_PrivateKeyArchiveCertificate);
    }
    LeaveCriticalSection(&m_csXEnroll);

    return pCert;
}
    
HRESULT STDMETHODCALLTYPE
CCEnroll::binaryBlobToString(
    IN   LONG               Flags,
    IN   PCRYPT_DATA_BLOB   pblobBinary,
    OUT  LPWSTR            *ppwszString)
{
    HRESULT hr;
    WCHAR  *pwszEncoded = NULL;
    DWORD   dwEncoded = 0;

    while (TRUE)
    {
        if (!MyCryptBinaryToStringW(
                    pblobBinary->pbData,
                    pblobBinary->cbData,
                    Flags,
                    pwszEncoded,
                    &dwEncoded))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptBinaryToStringError;
        }
        if (NULL != pwszEncoded)
        {
            //done
            break;
        }
        //dwEncoded includes null terminator
        pwszEncoded = (WCHAR*)MyCoTaskMemAlloc(dwEncoded * sizeof(WCHAR));
        if (NULL == pwszEncoded)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    *ppwszString = pwszEncoded;
    pwszEncoded = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszEncoded)
    {
        MyCoTaskMemFree(pwszEncoded);
    }
    return hr;

TRACE_ERROR(MyCoTaskMemAllocError)
TRACE_ERROR(MyCryptBinaryToStringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::stringToBinaryBlob(
    IN   LONG               Flags,
    IN   LPCWSTR            pwszString,
    OUT  PCRYPT_DATA_BLOB   pblobBinary,
    OUT  LONG              *pdwSkip,
    OUT  LONG              *pdwFlags)
{
    HRESULT  hr;

    //init
    pblobBinary->pbData = NULL;
    pblobBinary->cbData = 0;

    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    pwszString,
                    wcslen(pwszString),
                    Flags,
                    pblobBinary->pbData,
                    &pblobBinary->cbData,
                    (DWORD*)pdwSkip,
                    (DWORD*)pdwFlags))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pblobBinary->pbData)
        {
            //done
            break;
        }
        pblobBinary->pbData = (BYTE*)MyCoTaskMemAlloc(pblobBinary->cbData);
        if (NULL == pblobBinary->pbData)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    hr = S_OK;
ErrorReturn:
    return hr;

TRACE_ERROR(MyCryptStringToBinaryWError)
TRACE_ERROR(MyCoTaskMemAllocError)
}


HRESULT STDMETHODCALLTYPE 
CCEnroll::addExtensionToRequestWStr(
    IN   LONG               Flags,
    IN   LPCWSTR            pwszName,
    IN   PCRYPT_DATA_BLOB   pblobValue)
{
    HRESULT hr = S_OK;
    CERT_EXTENSION ext;
    CERT_EXTENSION *pExt = NULL; //enum 1st
    CHAR   *pszName = NULL;

    //convert wsz oid to sz oid
    hr = xeWSZToSZ(pwszName, &pszName);
    if (S_OK != hr)
    {
        goto error;
    }

    while(NULL != (pExt = EnumStackExtension(pExt, TRUE)))
    {
        if (0 == strcmp(pszName, pExt->pszObjId))
        {
            //already had the extension, can't have more than 1
            hr = MY_HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            goto error;
        }
    }
    //check to see if it is key usage extension
    if (0 == strcmp(pszName, szOID_KEY_USAGE))
    {
        EnterCriticalSection(&m_csXEnroll);
        m_fUseClientKeyUsage = TRUE;
        LeaveCriticalSection(&m_csXEnroll);
    }

    ZeroMemory(&ext, sizeof(ext));
    ext.fCritical = Flags;
    ext.pszObjId = pszName;
    ext.Value = *pblobValue;

    if(!CopyAndPushStackExtension(&ext, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

error:
    if (NULL != pszName)
    {
        MyCoTaskMemFree(pszName);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addAttributeToRequestWStr(
    IN   LONG               Flags, //not used
    IN   LPCWSTR            pwszName,
    IN   PCRYPT_DATA_BLOB   pblobValue)
{
    HRESULT hr = S_OK;
    CRYPT_ATTR_BLOB attrBlob;
    CRYPT_ATTRIBUTE attr;
    CHAR   *pszName = NULL;

    //convert wsz oid to sz oid
    hr = xeWSZToSZ(pwszName, &pszName);
    if (S_OK != hr)
    {
        goto error;
    }

    ZeroMemory(&attr, sizeof(attr));
    attrBlob = *pblobValue;
    attr.pszObjId = pszName;
    attr.cValue = 1;
    attr.rgValue = &attrBlob;

    if(!CopyAndPushStackAttribute(&attr, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

error:
    if (NULL != pszName)
    {
        MyCoTaskMemFree(pszName);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::addNameValuePairToRequestWStr(
    IN   LONG         Flags,  //not used
    IN   LPCWSTR      pwszName,
    IN   LPCWSTR      pwszValue)
{
    HRESULT hr = S_OK;

    assert(pwszName != NULL && pwszValue != NULL);

    CRYPT_ENROLLMENT_NAME_VALUE_PAIR nameValuePair =
            {const_cast<LPWSTR>(pwszName), const_cast<LPWSTR>(pwszValue)};
    CRYPT_ATTR_BLOB blobAttr;
    CRYPT_ATTRIBUTE attr = {szOID_ENROLLMENT_NAME_VALUE_PAIR, 1, &blobAttr};

    memset(&blobAttr, 0, sizeof(CRYPT_ATTR_BLOB));

    hr = xeEncodeNameValuePair(
                &nameValuePair,
                &blobAttr.pbData,
                &blobAttr.cbData);
    if (S_OK != hr)
    {
        goto error;
    }

    if(!CopyAndPushStackAttribute(&attr, TRUE))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
    }

error:
    if (NULL != blobAttr.pbData)
    {
        MyCoTaskMemFree(blobAttr.pbData);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CCEnroll::addBlobPropertyToCertificateWStr(
    IN  LONG               lPropertyId,
    IN  LONG               lFlags,
    IN  PCRYPT_DATA_BLOB   pBlobProp)
{
    HRESULT      hr;
    PPROP_STACK  pProp;
    PPROP_STACK  pPropEle = NULL;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL == pBlobProp ||
        NULL == pBlobProp->pbData ||
        0 == pBlobProp->cbData)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto InvalidParameterError;
    }

    //check if the same property exists
    pProp = EnumStackProperty(NULL);
    while (NULL != pProp)
    {
        if (pProp->lPropId == lPropertyId)
        {
            //exists already
            hr = MY_HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            goto PropertyExistError;
        }
        pProp = EnumStackProperty(pProp);
    }

    pPropEle = (PPROP_STACK)LocalAlloc(LMEM_ZEROINIT, sizeof(PROP_STACK));
    if (NULL == pPropEle)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    
    pPropEle->lPropId = lPropertyId;
    pPropEle->lFlags = lFlags;
    pPropEle->prop.pbData = (BYTE*)LocalAlloc(LMEM_FIXED, pBlobProp->cbData);
    if (NULL == pPropEle->prop.pbData)
    {
        hr = E_OUTOFMEMORY;
        goto OutOfMemoryError;
    }
    CopyMemory(pPropEle->prop.pbData, pBlobProp->pbData, pBlobProp->cbData);
    pPropEle->prop.cbData = pBlobProp->cbData;

    //put into stack
    pPropEle->pNext = m_pPropStack;
    m_pPropStack = pPropEle; //assign m_pPropStack
    m_cPropStack++; //increment of m_cPropStack
    pPropEle = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pPropEle)
    {
        if (NULL != pPropEle->prop.pbData)
        {
            LocalFree(pPropEle->prop.pbData);
        }
        LocalFree(pPropEle);
    }

    LeaveCriticalSection(&m_csXEnroll);
    return hr;

TRACE_ERROR(InvalidParameterError)
TRACE_ERROR(PropertyExistError)
TRACE_ERROR(OutOfMemoryError)
}

PPROP_STACK
CCEnroll::EnumStackProperty(PPROP_STACK pProp)
{
    EnterCriticalSection(&m_csXEnroll);

    if(NULL == pProp)
    {
        //1st one
        pProp = m_pPropStack;
    }
    else
    {
        pProp = pProp->pNext;
    }

    LeaveCriticalSection(&m_csXEnroll);

    return pProp;
}

HRESULT STDMETHODCALLTYPE CCEnroll::resetBlobProperties()
{
    PPROP_STACK  pPropEle;
    PPROP_STACK  pPropNext;

    EnterCriticalSection(&m_csXEnroll);

    pPropEle = m_pPropStack;
    while (NULL != pPropEle)
    {
        //save it to temp
        pPropNext = EnumStackProperty(pPropEle);
        //free the current ele
        if (NULL != pPropEle->prop.pbData)
        {
            LocalFree(pPropEle->prop.pbData);
        }
        LocalFree(pPropEle);
        pPropEle = pPropNext;
    }
    m_pPropStack = NULL;
    m_cPropStack = 0;
    
    LeaveCriticalSection(&m_csXEnroll);
    return S_OK;
}

HRESULT
CCEnroll::GetKeyArchivePKCS7(
    OUT CRYPT_ATTR_BLOB *pBlobKeyArchivePKCS7)
{
    HRESULT    hr;
    HCRYPTPROV hProv;
    HCRYPTKEY  hKey = NULL;
    BYTE      *pBlobPrivateKey = NULL;
    DWORD      cBlobPrivateKey = 0;
    CRYPT_ENCRYPT_MESSAGE_PARA cemp;
    ALG_ID  algId[] = {CALG_3DES, CALG_RC4, CALG_RC2, ALG_TYPE_ANY};
    CRYPT_OID_INFO const *pOidInfo = NULL;
    DWORD i = 0;

    //init
    pBlobKeyArchivePKCS7->pbData = NULL;
    pBlobKeyArchivePKCS7->cbData = 0;

    EnterCriticalSection(&m_csXEnroll);

    //make sure key archival cert is set
    assert(NULL != m_PrivateKeyArchiveCertificate);

    PCCERT_CONTEXT apCert[] = {m_PrivateKeyArchiveCertificate};

    //get user private key
    hProv = GetProv(0); //existing key container handle
    if (NULL == hProv)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CryptAcquireContextError;
    }

    if (NULL == m_hCachedKey)
    {
        //likely used existing key
        if(!CryptGetUserKey(
                    hProv,
                    m_keyProvInfo.dwKeySpec,
                    &hKey))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptGetUserKeyError;
        }
    }

    //export private key
    while (TRUE)
    {
        if (!CryptExportKey(
                NULL != hKey ? hKey : m_hCachedKey,
                NULL, //don't encrypt
                PRIVATEKEYBLOB,
                0,
                pBlobPrivateKey,
                &cBlobPrivateKey))
        {
            //map to xenroll error
            hr = XENROLL_E_KEY_NOT_EXPORTABLE;
            goto CryptExportKeyError;
        }
        if (NULL != pBlobPrivateKey)
        {
            //done
            break;
        }
        pBlobPrivateKey = (BYTE*)MyCoTaskMemAlloc(cBlobPrivateKey);
        if (NULL == pBlobPrivateKey)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    if (NULL == m_hCachedKey)
    {
        //it could be csp not supporting CRYPT_ARCHIVABLE
        //got private key, now let's take care of key permission
        if (0x0 == (m_dwGenKeyFlags & CRYPT_EXPORTABLE))
        {
            // user didn't ask exportable, turn it off
            DWORD dwFlags = 0;
            DWORD dwSize = sizeof(dwFlags);
            if (!CryptGetKeyParam(
                    hKey,
                    KP_PERMISSIONS,
                    (BYTE*)&dwFlags,
                    &dwSize,
                    0))
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto CryptGetKeyParamError;
            }
#if DBG
            assert(dwSize = sizeof(dwFlags));
            // make sure was on
            assert(0x0 != (dwFlags & CRYPT_EXPORT));
#endif
            //turn off exportable
            dwFlags = dwFlags & (~CRYPT_EXPORT);
            if (!CryptSetKeyParam(
                    hKey,
                    KP_PERMISSIONS,
                    (BYTE*)&dwFlags,
                    0))
            {
                //hr = MY_HRESULT_FROM_WIN32(GetLastError());
                //goto CryptSetKeyParamError;
                hr = S_OK; //UNDONE, even ms csps have problem with this
            }
        }
    }

    //prepare for encryption
    ZeroMemory(&cemp, sizeof(cemp)); //avoid 0 assignment
    cemp.cbSize = sizeof(cemp);
    cemp.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    hr = S_OK; //critical init for double while loop

    while (ALG_TYPE_ANY != algId[i])
    {
        pOidInfo = xeCryptFindOIDInfo(
                        CRYPT_OID_INFO_ALGID_KEY,
                        &algId[i],
                        CRYPT_ENCRYPT_ALG_OID_GROUP_ID);
        if (NULL != pOidInfo)
        {
            cemp.ContentEncryptionAlgorithm.pszObjId = 
                                const_cast<char *>(pOidInfo->pszOID);
            //encryt into pkcs7
            while (TRUE)
            {
                if (!CryptEncryptMessage(
                        &cemp,
                        sizeof(apCert)/sizeof(apCert[0]),
                        apCert,
                        pBlobPrivateKey,
                        cBlobPrivateKey,
                        pBlobKeyArchivePKCS7->pbData,
                        &pBlobKeyArchivePKCS7->cbData))
                {
                    //save the 1st error code
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
#ifdef DBG
                    assert(NULL == pBlobKeyArchivePKCS7->pbData);
#endif
                    break; //break inner while loop
                }
                if (NULL != pBlobKeyArchivePKCS7->pbData)
                {
                    //done, got encrypted blob
                    //ignore error from previous alg tries
                    hr = S_OK;
                    break;
                }
                pBlobKeyArchivePKCS7->pbData = (BYTE*)MyCoTaskMemAlloc(
                                        pBlobKeyArchivePKCS7->cbData);
                if (NULL == pBlobKeyArchivePKCS7->pbData)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
            }
            if (S_OK == hr)
            {
                //done, out of outer while loop
                break;
            }
        }
        ++i;
    }
    if (NULL == pOidInfo)
    {
        hr = CRYPT_E_NOT_FOUND;
        goto CryptElemNotFoundError;
    }

    if (S_OK != hr)
    {
        goto CryptEncryptMessageError;
    }

    hr = S_OK;
ErrorReturn:
    //now let's destroy cached key handle
    if (NULL != m_hCachedKey)
    {
        CryptDestroyKey(m_hCachedKey);
        m_hCachedKey = NULL; //critical to reset
    }
    //note, do above before leaving critical section
    LeaveCriticalSection(&m_csXEnroll);
    if (NULL != pBlobPrivateKey)
    {
        MyCoTaskMemFree(pBlobPrivateKey);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return hr;

TRACE_ERROR(CryptEncryptMessageError)
TRACE_ERROR(CryptAcquireContextError)
TRACE_ERROR(CryptGetUserKeyError)
TRACE_ERROR(CryptExportKeyError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CryptElemNotFoundError)
//TRACE_ERROR(CryptSetKeyParamError)
TRACE_ERROR(CryptGetKeyParamError)
}

HRESULT
GetKeyProvInfoFromCert(
    IN  PCCERT_CONTEXT    pCert,
    OUT DWORD            *pdwKeySpec,
    OUT HCRYPTPROV       *phProv)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pKeyProvInfo = NULL;
    DWORD                cb = 0;
    HCRYPTPROV           hProv = NULL;

    if (NULL == pCert || NULL == phProv || NULL == pdwKeySpec)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    while (TRUE)
    {
        if(!CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo,
                &cb))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertGetCertificateContextPropertyError;
        }
        if (NULL != pKeyProvInfo)
        {
            //got it, done
            break;
        }
        pKeyProvInfo = (CRYPT_KEY_PROV_INFO*)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pKeyProvInfo)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    if (!CryptAcquireContextU(
            &hProv,
            pKeyProvInfo->pwszContainerName,
            pKeyProvInfo->pwszProvName,
            pKeyProvInfo->dwProvType,
            pKeyProvInfo->dwFlags))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CryptAcquireContextUError;
    }
    *phProv = hProv;
    hProv = NULL;
    *pdwKeySpec = pKeyProvInfo->dwKeySpec;

    hr = S_OK;
ErrorReturn:
    if (NULL != pKeyProvInfo)
    {
        LocalFree(pKeyProvInfo);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;

TRACE_ERROR(CryptAcquireContextUError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(CertGetCertificateContextPropertyError)
TRACE_ERROR(InvalidArgError)
}

HRESULT
xeCreateKeyArchivalHashAttribute(
    IN  CRYPT_HASH_BLOB     *pBlobKAHash,
    OUT CRYPT_ATTR_BLOB     *pBlobKAAttr)
{
    HRESULT hr;
    BYTE   *pbData = NULL;
    DWORD   cbData = 0;

    while (TRUE)
    {
        if(!CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_OCTET_STRING,
                (void*)pBlobKAHash,
                pbData,
                &cbData))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CryptEncodeObjectError;
        }

        if (NULL != pbData)
        {
            //done
            break;
        }

        pbData = (BYTE*)LocalAlloc(LMEM_FIXED, cbData);
        if (NULL == pbData)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }
    pBlobKAAttr->pbData = pbData;
    pBlobKAAttr->cbData = cbData;
    pbData = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return hr;

TRACE_ERROR(CryptEncodeObjectError)
TRACE_ERROR(LocalAllocError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createRequestWStr(
    IN   LONG              Flags,
    IN   LPCWSTR           pwszDNName,
    IN   LPCWSTR           pwszUsage,
    OUT  PCRYPT_DATA_BLOB  pblobRequest)
{
    HRESULT hr;
    CRYPT_DATA_BLOB  blobPKCS10;
    CRYPT_ATTR_BLOB  blobKeyArchivePKCS7;
    ALG_ID           rgAlg[2];
    PCCRYPT_OID_INFO pOidInfo;
    CERT_EXTENSION  *rgExt = NULL;
    DWORD            cExt = 0;
    CERT_EXTENSION  *pExt = NULL; //for enum 1st
    CRYPT_ATTRIBUTE  *rgAttr = NULL;
    DWORD            cAttr = 0;
    CRYPT_ATTRIBUTE  *pAttr = NULL; //for enum 1st
    CRYPT_ATTRIBUTES rgAttributes;
    CRYPT_ATTRIBUTE  *rgUnauthAttr = NULL; //init
    DWORD            cUnauthAttr = 0; //init
    DWORD            cb;
    HCRYPTPROV       hProvSigner = NULL;
    DWORD            dwKeySpecSigner = 0;
    PCCERT_CONTEXT   pCertSigner = NULL; //just init, no free
    HCRYPTPROV       hRequestProv = NULL;
    BYTE            *pbSubjectKeyHash = NULL;
    DWORD            cbSubjectKeyHash = 0;
    CRYPT_HASH_BLOB  blobKAHash;
    CRYPT_ATTR_BLOB  blobKAHashAttr;
    CRYPT_ATTRIBUTE  attrKAHash =
        {szOID_ENCRYPTED_KEY_HASH, 1, &blobKAHashAttr};

    ZeroMemory(&blobPKCS10, sizeof(blobPKCS10));
    ZeroMemory(&blobKeyArchivePKCS7, sizeof(blobKeyArchivePKCS7));
    ZeroMemory(&blobKAHash, sizeof(blobKAHash));
    ZeroMemory(&blobKAHashAttr, sizeof(blobKAHashAttr));

    EnterCriticalSection(&m_csXEnroll);
    m_fNewRequestMethod = TRUE;  //critical
    m_fOID_V2 = TRUE;
    m_fCMCFormat = FALSE;
    m_fHonorIncludeSubjectKeyID = FALSE;

    switch (Flags)
    {
        case XECR_CMC:
        {
            if (NULL != m_pCertContextRenewal &&
                NULL != m_pCertContextSigner)
            {
                //don't support both on yet
                hr = MY_HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                goto NotSupportedError;
            }

            m_fCMCFormat = TRUE;
            m_fHonorIncludeSubjectKeyID = TRUE;
            // create pkcs 10 first
            hr = createPKCS10WStr(
                        pwszDNName,
                        pwszUsage,     //wszPurpose,
                        &blobPKCS10);
            if(S_OK != hr)
            {
                goto createPKCS10WStrError;
            }
            //set it back
            m_fCMCFormat = FALSE;

            //get all extensions
            cb = CountStackExtension(TRUE) * sizeof(CERT_EXTENSION);
            if (0 < cb)
            {
                rgExt = (CERT_EXTENSION*)LocalAlloc(LMEM_FIXED, cb);
                if (NULL == rgExt)
                {    
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                ZeroMemory(rgExt, cb);
                while(NULL != (pExt = EnumStackExtension(pExt, TRUE)))
                {
                    rgExt[cExt] = *pExt;
                    cExt++;
                }
            }

            //get all attributes including namevalue pair
            cb = CountStackAttribute(TRUE) * sizeof(CRYPT_ATTRIBUTE);
            if (NULL != m_PrivateKeyArchiveCertificate)
            {
                //add one more attribute to hold encrypted key hash
                cb += sizeof(CRYPT_ATTRIBUTE);
            }
            if (0 < cb)
            {
                rgAttr = (CRYPT_ATTRIBUTE*)LocalAlloc(LMEM_FIXED, cb);
                if (NULL == rgAttr)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                ZeroMemory(rgAttr, cb);
                while(NULL != (pAttr = EnumStackAttribute(pAttr, TRUE)))
                {
                    rgAttr[cAttr] = *pAttr;
                    cAttr++;
                }
                rgAttributes.rgAttr = rgAttr;
                rgAttributes.cAttr = cAttr;
            }

            if (NULL != m_PrivateKeyArchiveCertificate)
            {
                hr = GetKeyArchivePKCS7(&blobKeyArchivePKCS7);
                if (S_OK != hr)
                {
                    goto GetKeyArchivePKCS7Error;
                }
                rgUnauthAttr = (CRYPT_ATTRIBUTE*)LocalAlloc(LMEM_FIXED,
                                        sizeof(CRYPT_ATTRIBUTE));
                if (NULL == rgUnauthAttr)
                {
                    hr = E_OUTOFMEMORY;
                    goto OutOfMemoryError;
                }
                rgUnauthAttr->pszObjId = szOID_ARCHIVED_KEY_ATTR;
                rgUnauthAttr->cValue = 1;
                rgUnauthAttr->rgValue = &blobKeyArchivePKCS7;
                ++cUnauthAttr;

                //if key archival cert is set, should save the hash
                //of the encrypted private key

                hr = myCalculateKeyArchivalHash(
                            blobKeyArchivePKCS7.pbData,
                            blobKeyArchivePKCS7.cbData,
                            &blobKAHash.pbData,
                            &blobKAHash.cbData);
                if (S_OK != hr)
                {
                    goto myCalculateKeyArchivalHashError;
                }

                if (!CertSetCertificateContextProperty(
                        m_pCertContextPendingRequest, //use pending cert
                        CERT_ARCHIVED_KEY_HASH_PROP_ID,
                        0,
                        &blobKAHash))
                {
                    hr = MY_HRESULT_FROM_WIN32(GetLastError());
                    goto CertSetCertificateContextPropertyError;
                }

                hr = xeCreateKeyArchivalHashAttribute(
                            &blobKAHash,
                            &blobKAHashAttr);
                if (S_OK != hr)
                {
                    goto xeCreateKeyArchivalHashAttributeError;
                }

                //add this attribute into the array
                rgAttr[cAttr] = attrKAHash;
                cAttr++;
                rgAttributes.rgAttr = rgAttr;
                rgAttributes.cAttr = cAttr;
            }

            //client may set m_HashAlgId but it is not guaranteed
            //GetCapiHashAndSigAlgId will determine which one
            //is actually used
            if (!GetCapiHashAndSigAlgId(rgAlg))
            {
                hr = NTE_BAD_ALGID;
                goto GetCapiHashAndSigAlgIdError;
            }
            pOidInfo = xeCryptFindOIDInfo(
                            CRYPT_OID_INFO_ALGID_KEY,
                            (void*)rgAlg, //point to rgAlg[0]
                            CRYPT_HASH_ALG_OID_GROUP_ID);
            if (NULL == pOidInfo)
            {
                goto xeCryptFindOIDInfoError;
            }

            if (NULL != m_pCertContextRenewal)
            {
                pCertSigner = m_pCertContextRenewal;
            }
            if (NULL != m_pCertContextSigner)
            {
                pCertSigner = m_pCertContextSigner;
            }
            if (NULL != pCertSigner)
            {
                //get signer key prov info
                hr = GetKeyProvInfoFromCert(
                                pCertSigner,
                                &dwKeySpecSigner,
                                &hProvSigner);
                if (S_OK != hr)
                {
                    goto GetKeyProvInfoFromCertError;
                }
            }

            //this is CMC, honor anyway
            if (m_fIncludeSubjectKeyID)
            {
                hr = myGetPublicKeyHash(
                            NULL,
                            m_pPublicKeyInfo,
                            &pbSubjectKeyHash,
                            &cbSubjectKeyHash);
                if (S_OK != hr)
                {
                    goto myGetPublicKeyHashError;
                }
            }
            hRequestProv = GetProv(0);
            if (NULL == hRequestProv)
            {
                hr = MY_HRESULT_FROM_WIN32(GetLastError());
                goto GetProvError;
            }

            //ok, now call cmc create
            hr = BuildCMCRequest(
                        m_lClientId,
                        FALSE,       //fNestedCMCRequest
                        blobPKCS10.pbData,
                        blobPKCS10.cbData,
                        rgExt,
                        cExt,
                        (0 != cAttr) ? &rgAttributes : NULL,
                        (0 != cAttr) ? 1 : 0,
                        rgUnauthAttr,
                        cUnauthAttr,
                        pbSubjectKeyHash,
                        cbSubjectKeyHash,
                        hRequestProv,
                        m_keyProvInfo.dwKeySpec,
                        pOidInfo->pszOID,
                        pCertSigner,
                        hProvSigner,
                        dwKeySpecSigner,
                        NULL, //pOidInfo->pszOID, //this seems to me not necessary because we passed the cert context
                        &pblobRequest->pbData,
                        &pblobRequest->cbData);
            if (S_OK != hr)
            {
                goto BuildCMCRequestError;
            }
        }
        break;

        case XECR_PKCS7:
            if ((NULL == m_pCertContextRenewal &&
                 NULL == m_pCertContextSigner) ||
                NULL != m_PrivateKeyArchiveCertificate)
            {
                //renew cert is not set, can't make it pkcs7
                //pkcs7 can't support key archival
                hr = E_INVALIDARG;
                goto InvalidArgError;
            }
            // old method will return pkcs7
            hr = createPKCS10WStr(
                        pwszDNName,
                        pwszUsage,     //wszPurpose,
                        pblobRequest);
            if(S_OK != hr)
            {
                goto createPKCS10WStrError;
            }
        break;

        case XECR_PKCS10_V1_5:
            m_fOID_V2 = FALSE;
            //fall through
        case XECR_PKCS10_V2_0:

            if (NULL != m_PrivateKeyArchiveCertificate)
            {
                //pkcs10 can't support key archival
                hr = E_INVALIDARG;
                goto InvalidArgError;
            }
            m_fHonorRenew = FALSE; //avoid return pkcs7
            //for new PKCS10 we allow include subject key id extension
            m_fHonorIncludeSubjectKeyID = TRUE;
            // call old method
            hr = createPKCS10WStr(
                        pwszDNName,
                        pwszUsage,     //wszPurpose,
                        pblobRequest);
            if(S_OK != hr)
            {
                goto createPKCS10WStrError;
            }
        break;

        default:
            hr = E_INVALIDARG;
            goto InvalidArgError;
        break;
    }

    //in all cases, we called createPKCS10WStr
    if(m_wszPVKFileName[0] != 0 && !m_fUseExistingKey)
    {
        //we hold on this until possible cmc is created
        GetProv(CRYPT_DELETEKEYSET);
    }

    hr = S_OK;
ErrorReturn:
    m_fNewRequestMethod = FALSE; //critical
    m_fOID_V2 = FALSE; //critical for backward compatiability
    m_fHonorRenew = TRUE; //critical
    m_fHonorIncludeSubjectKeyID = TRUE; //critical for backward compt.
    LeaveCriticalSection(&m_csXEnroll);

    if (NULL != rgExt)
    {
        LocalFree(rgExt);
    }
    if (NULL != rgAttr)
    {
        LocalFree(rgAttr);
    }
    if (NULL != rgUnauthAttr)
    {
        LocalFree(rgUnauthAttr);
    }
    if (NULL != blobKeyArchivePKCS7.pbData)
    {
        MyCoTaskMemFree(blobKeyArchivePKCS7.pbData);
    }
    if (NULL != blobPKCS10.pbData)
    {
        MyCoTaskMemFree(blobPKCS10.pbData);
    }
    if (NULL != hProvSigner)
    {
        CryptReleaseContext(hProvSigner, 0);
    }
    if (NULL != pbSubjectKeyHash)
    {
        LocalFree(pbSubjectKeyHash);
    }
    if (NULL != blobKAHash.pbData)
    {
        LocalFree(blobKAHash.pbData);
    }
    if (NULL != blobKAHashAttr.pbData)
    {
        LocalFree(blobKAHashAttr.pbData);
    }
    return hr;

TRACE_ERROR(createPKCS10WStrError)
TRACE_ERROR(BuildCMCRequestError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(GetCapiHashAndSigAlgIdError)
TRACE_ERROR(GetKeyArchivePKCS7Error)
TRACE_ERROR(xeCryptFindOIDInfoError)
TRACE_ERROR(OutOfMemoryError)
TRACE_ERROR(GetKeyProvInfoFromCertError)
TRACE_ERROR(NotSupportedError)
TRACE_ERROR(GetProvError)
TRACE_ERROR(myGetPublicKeyHashError)
TRACE_ERROR(CertSetCertificateContextPropertyError)
TRACE_ERROR(myCalculateKeyArchivalHashError)
TRACE_ERROR(xeCreateKeyArchivalHashAttributeError)
}

HRESULT
CCEnroll::BlobToBstring(
    IN   CRYPT_DATA_BLOB   *pBlob,
    IN   DWORD              dwFlag,
    OUT  BSTR              *pBString)
{
    HRESULT           hr;
    WCHAR            *pwszB64;
    DWORD             cch;

    //init
    *pBString = NULL;

    // BASE64 encode blob
    pwszB64 = NULL;
    cch = 0;
    while (TRUE)
    {
        if (!MyCryptBinaryToStringW(
                pBlob->pbData,
                pBlob->cbData,
                dwFlag,
                pwszB64,
                &cch))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptBinaryToStringWError;
        }
        if (NULL != pwszB64)
        {
            //got it, done
            break;
        }
        pwszB64 = (WCHAR *)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwszB64)
        {
            hr = E_OUTOFMEMORY;
            goto OutOfMemoryError;
        }
    }

    // SysAllocStringLen
    *pBString = SysAllocStringLen(pwszB64, cch);
    if(NULL == *pBString)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto SysAllocStringLenError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != pwszB64)
    {
        LocalFree(pwszB64);
    }
    return(hr);

TRACE_ERROR(MyCryptBinaryToStringWError)
TRACE_ERROR(SysAllocStringLenError)
TRACE_ERROR(OutOfMemoryError)
}

HRESULT
CCEnroll::BstringToBlob(
    IN  BSTR               bString,
    OUT CRYPT_DATA_BLOB   *pBlob)
{
    HRESULT  hr;

    assert(NULL != pBlob);

    //init
    pBlob->pbData = NULL;
    pBlob->cbData = 0;

    while (TRUE)
    {
        if (!MyCryptStringToBinaryW(
                    (LPCWSTR)bString,
                    SysStringLen(bString),
                    CRYPT_STRING_ANY,
                    pBlob->pbData,
                    &pBlob->cbData,
                    NULL,
                    NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto MyCryptStringToBinaryWError;
        }
        if (NULL != pBlob->pbData)
        {
            break; //done
        }
        pBlob->pbData = (BYTE*)MyCoTaskMemAlloc(pBlob->cbData);
        if (NULL == pBlob->pbData)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    hr = S_OK;
ErrorReturn:
    return(hr);

TRACE_ERROR(MyCoTaskMemAllocError)
TRACE_ERROR(MyCryptStringToBinaryWError)
}

HRESULT
CCEnroll::createRequestWStrBStr(
    IN   LONG              Flags,
    IN   LPCWSTR           pwszDNName,
    IN   LPCWSTR           pwszUsage,
    IN   DWORD             dwFlag,
    OUT  BSTR __RPC_FAR   *pbstrRequest)
{
    HRESULT           hr;
    CRYPT_DATA_BLOB   blobRequest;

    memset(&blobRequest, 0, sizeof(blobRequest));

    hr = createRequestWStr(Flags, pwszDNName, pwszUsage, &blobRequest);
    if (S_OK != hr)
    {
        goto createRequestWStrError;
    }

    // convert to bstr
    hr = BlobToBstring(&blobRequest, dwFlag, pbstrRequest);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != blobRequest.pbData)
    {
        MyCoTaskMemFree(blobRequest.pbData);
    }
    return(hr);

TRACE_ERROR(createRequestWStrError)
TRACE_ERROR(BlobToBstringError)
}

HRESULT
CCEnroll::BStringToFile(
    IN BSTR         bString,
    IN LPCWSTR      pwszFileName)
{
    HRESULT hr;
    HANDLE  hFile = NULL;
    DWORD   cb = 0;
    LPSTR   sz = NULL;

    sz = MBFromWide(bString);
    if(NULL == sz)
    {
        hr = E_OUTOFMEMORY;
        goto MBFromWideError;
    }

    // open the file
    hFile = CreateFileSafely(pwszFileName);
    if (NULL == hFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CreateFileFileSafelyError;
    }

    // write the pkcs10
    if(!WriteFile(
        hFile,
        sz,
        strlen(sz),
        &cb,
        NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto WriteFileError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != hFile)
    {
        CloseHandle(hFile);
    }
    if(NULL != sz)
    {
        MyCoTaskMemFree(sz);
    }
    return(hr);

TRACE_ERROR(CreateFileFileSafelyError)
TRACE_ERROR(MBFromWideError)
TRACE_ERROR(WriteFileError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFileRequestWStr(
    IN   LONG        Flags,
    IN   LPCWSTR     pwszDNName,
    IN   LPCWSTR     pwszUsage,
    IN   LPCWSTR     pwszRequestFileName)
{
    HRESULT hr;
    BSTR    bstrRequest = NULL;

    // get the Request
    hr = createRequestWStrBStr(
                Flags,
                pwszDNName,
                pwszUsage,
                CRYPT_STRING_BASE64REQUESTHEADER,
                &bstrRequest);
    if(S_OK != hr)
    {
        goto createRequestWStrBStrError;
    }

    // save it to file
    hr = BStringToFile(bstrRequest, pwszRequestFileName);
    if (S_OK != hr)
    {
        goto BStringToFileError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != bstrRequest)
    {
        SysFreeString(bstrRequest);
    }
    return(hr);

TRACE_ERROR(createRequestWStrBStrError)
TRACE_ERROR(BStringToFileError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptResponseBlob(
    IN   PCRYPT_DATA_BLOB   pblobResponse)
{
    HRESULT hr_old = S_OK;
    HRESULT hr;
    XCMCRESPONSE *prgResponse = NULL;
    DWORD         cResponse = 0;

    EnterCriticalSection(&m_csXEnroll);

    //check in parameter
    if (NULL == pblobResponse)
    {
        hr = E_POINTER;
        goto NullPointerError;
    }
    if (NULL == pblobResponse->pbData ||
        0 == pblobResponse->cbData)
    {
        hr = E_INVALIDARG;
        goto InvalidArgError;
    }

    //make sure init archived key hash
    ZeroMemory(&m_blobResponseKAHash, sizeof(m_blobResponseKAHash));

    hr_old = ParseCMCResponse(
                pblobResponse->pbData,
                pblobResponse->cbData,
                NULL,
                &prgResponse,
                &cResponse);
    //note, if for any reasons above failed, try pkcs7
    if (S_OK == hr_old)
    {
        if (1 < cResponse)
        {
            //not supported yet
            hr = MY_HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto NotSupportedError;
        }
#if DBG
        //make sure not zero, should be 1
        assert(1 == cResponse);
#endif //DBG

        //check response status
        if (CMC_STATUS_SUCCESS != prgResponse->StatusInfo.dwStatus)
        {
            hr = prgResponse->StatusInfo.dwStatus; //take status error
            goto CMCResponseStatusError;
        }

        //some code here to get encrypted archived key hash from the response
        //and make m_blobResponseKAHash point to the hash data
        if (NULL != prgResponse->pbEncryptedKeyHash)
        {
            m_blobResponseKAHash.pbData = prgResponse->pbEncryptedKeyHash;
            m_blobResponseKAHash.cbData = prgResponse->cbEncryptedKeyHash;
        }
    }

    //note, hr_old may not be S_OK, accept the response as pkcs7
    hr = acceptPKCS7Blob(pblobResponse);
    if (S_OK != hr)
    {
        if (S_OK != hr_old)
        {
            //return old error instead of new one
            hr = hr_old;
        }
        goto acceptPKCS7BlobError;
    }

    hr = S_OK;
ErrorReturn:
    //reset hash to zero
    ZeroMemory(&m_blobResponseKAHash, sizeof(m_blobResponseKAHash));
    LeaveCriticalSection(&m_csXEnroll);
    if (NULL != prgResponse)
    {
        FreeCMCResponse(prgResponse, cResponse);
    }
    return hr;

TRACE_ERROR(acceptPKCS7BlobError)
TRACE_ERROR(CMCResponseStatusError)
TRACE_ERROR(NotSupportedError)
TRACE_ERROR(InvalidArgError)
TRACE_ERROR(NullPointerError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::acceptFileResponseWStr(
    IN   LPCWSTR     pwszResponseFileName)
{
    HRESULT     hr;
    CRYPT_DATA_BLOB  blob;

    ZeroMemory(&blob, sizeof(blob));

    hr = xeStringToBinaryFromFile(
                pwszResponseFileName,
                &blob.pbData,
                &blob.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    // accept the blob
    hr = acceptResponseBlob(&blob);

ErrorReturn:
    if (NULL != blob.pbData)
    {
        LocalFree(blob.pbData);
    }
    return(hr);

TRACE_ERROR(xeStringToBinaryFromFileError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertContextFromResponseBlob(
    IN   PCRYPT_DATA_BLOB   pblobResponse,
    OUT  PCCERT_CONTEXT    *ppCertContext)
{
    HRESULT hr;

    if (NULL == ppCertContext)
    {
        hr = E_POINTER;
        goto NullPointerError;
    }

    //???should check response status?

    //response is already in pkcs7
    hr = GetEndEntityCert(pblobResponse, FALSE, ppCertContext);
    if (S_OK != hr)
    {
        goto GetEndEntityCertError;
    }

    hr = S_OK;
ErrorReturn:
    return hr;

TRACE_ERROR(NullPointerError)
TRACE_ERROR(GetEndEntityCertError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::getCertContextFromFileResponseWStr(
    IN   LPCWSTR          pwszResponseFileName,
    OUT  PCCERT_CONTEXT  *ppCertContext)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobResponse;

    ZeroMemory(&blobResponse, sizeof(blobResponse));

    // could be any form, binary or base64
    hr = xeStringToBinaryFromFile(
                pwszResponseFileName,
                &blobResponse.pbData,
                &blobResponse.cbData,
                CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
        goto xeStringToBinaryFromFileError;
    }

    hr = getCertContextFromResponseBlob(
                &blobResponse,
                ppCertContext);
    if (S_OK != hr)
    {
        goto getCertContextFromResponseBlobError;
    }

    hr = S_OK;
ErrorReturn:
    if (NULL != blobResponse.pbData)
    {
        LocalFree(blobResponse.pbData);
    }
    return hr;

TRACE_ERROR(xeStringToBinaryFromFileError)
TRACE_ERROR(getCertContextFromResponseBlobError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createPFXWStr(
    IN   LPCWSTR           pwszPassword,
    OUT  PCRYPT_DATA_BLOB  pblobPFX)
{
    HRESULT hr;
    HCERTSTORE hMemStore = NULL;
    DWORD i;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_SIMPLE_CHAIN *pSimpleChain;

    EnterCriticalSection(&m_csXEnroll);

    if (NULL == pblobPFX)
    {
        goto EPointerError;
    }

    if (NULL == m_pCertContextStatic)
    {
        hr = E_UNEXPECTED;
        goto UnexpectedError;
    }

    // create a memory store for cert and chain
    hMemStore = CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    X509_ASN_ENCODING,
                    NULL,
                    0,
                    NULL);
    if (NULL == hMemStore)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CertOpenStoreError;
    }

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    // try to build cert and chain
    if (!MyCertGetCertificateChain(
                HCCE_CURRENT_USER,
                m_pCertContextStatic,
                NULL,
                NULL,
                &CertChainPara,
                0,
                NULL,
                &pCertChainContext))
    {
        //use 1st hr error
        hr = MY_HRESULT_FROM_WIN32(GetLastError());

        //try local machine
        if (!MyCertGetCertificateChain(
                    HCCE_LOCAL_MACHINE,
                    m_pCertContextStatic,
                    NULL,
                    NULL,
                    &CertChainPara,
                    0,
                    NULL,
                    &pCertChainContext))
        {
            //still use 1st hr
            goto MyCertGetCertificateChainError;
        }
    }

    // make sure there is at least 1 simple chain
    if (0 == pCertChainContext->cChain)
    {
        hr = MY_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto NoCertificateChainError;
    }

    //add chain to memory store
    pSimpleChain = pCertChainContext->rgpChain[0];
    for (i = 0; i < pSimpleChain->cElement; i++)
    {
        if (!CertAddCertificateContextToStore(
                hMemStore,
                pSimpleChain->rgpElement[i]->pCertContext,
                CERT_STORE_ADD_REPLACE_EXISTING,
                NULL))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto CertAddCertificateContextToStoreError;
        }
    }

    pblobPFX->pbData = NULL;
    while (TRUE)
    {
        if (!PFXExportCertStore(
                hMemStore,
                pblobPFX,
                pwszPassword,
                EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
        {
            hr = MY_HRESULT_FROM_WIN32(GetLastError());
            goto PFXExportCertStoreError;
        }
        if (NULL != pblobPFX->pbData)
        {
            //got it, done
            break;
        }
        pblobPFX->pbData = (BYTE*)MyCoTaskMemAlloc(pblobPFX->cbData);
        if (NULL == pblobPFX->pbData)
        {
            hr = E_OUTOFMEMORY;
            goto MyCoTaskMemAllocError;
        }
    }

    hr = S_OK;
ErrorReturn:
    LeaveCriticalSection(&m_csXEnroll);
    if (pCertChainContext != NULL)
    {
        MyCertFreeCertificateChain(pCertChainContext);
    }
    if (NULL != hMemStore)
    {
        CertCloseStore(hMemStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return hr;

TRACE_ERROR(UnexpectedError)
TRACE_ERROR(CertOpenStoreError)
TRACE_ERROR(PFXExportCertStoreError)
TRACE_ERROR(MyCoTaskMemAllocError)
TRACE_ERROR(CertAddCertificateContextToStoreError)
TRACE_ERROR(NoCertificateChainError)
TRACE_ERROR(MyCertGetCertificateChainError)
SET_HRESULT(EPointerError, E_POINTER)
}

HRESULT
CCEnroll::createPFXWStrBStr( 
    IN  LPCWSTR         pwszPassword,
    OUT BSTR __RPC_FAR *pbstrPFX)
{
    HRESULT           hr;
    CRYPT_DATA_BLOB   blobPFX;

    memset(&blobPFX, 0, sizeof(CRYPT_DATA_BLOB));

    hr = createPFXWStr(pwszPassword, &blobPFX);
    if (S_OK != hr)
    {
        goto createPFXWStrError;
    }

    // convert pfx to bstr
    hr = BlobToBstring(&blobPFX, CRYPT_STRING_BASE64, pbstrPFX);
    if (S_OK != hr)
    {
        goto BlobToBstringError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != blobPFX.pbData)
    {
        MyCoTaskMemFree(blobPFX.pbData);
    }
    return(hr);

TRACE_ERROR(createPFXWStrError)
TRACE_ERROR(BlobToBstringError)
}

HRESULT STDMETHODCALLTYPE 
CCEnroll::createFilePFXWStr(
    IN   LPCWSTR     pwszPassword,
    IN   LPCWSTR     pwszPFXFileName)
{
    HRESULT hr;
    HANDLE  hFile = NULL;
    DWORD   cb = 0;
    CRYPT_DATA_BLOB   blobPFX;

    memset(&blobPFX, 0, sizeof(CRYPT_DATA_BLOB));

    hr = createPFXWStr(pwszPassword, &blobPFX);
    if (S_OK != hr)
    {
        goto createPFXWStrError;
    }

    // open the file
    hFile = CreateFileSafely(pwszPFXFileName);
    if (NULL == hFile)
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto CreateFileFileSafelyError;
    }

    // write the pkcs10
    if(!WriteFile(
        hFile,
        blobPFX.pbData,
        blobPFX.cbData,
        &cb,
        NULL))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError());
        goto WriteFileError;
    }

    hr = S_OK;
ErrorReturn:
    if(NULL != hFile)
    {
        CloseHandle(hFile);
    }
    if(NULL != blobPFX.pbData)
    {
        MyCoTaskMemFree(blobPFX.pbData);
    }
    return(hr);

TRACE_ERROR(createPFXWStrError)
TRACE_ERROR(CreateFileFileSafelyError)
TRACE_ERROR(WriteFileError)
}

HRESULT STDMETHODCALLTYPE
CCEnroll::setPendingRequestInfoWStr(
    IN   LONG     lRequestID,
    IN   LPCWSTR  pwszCADNS,
    IN   LPCWSTR  pwszCAName,
    IN   LPCWSTR  pwszFriendlyName
    )
{

    //------------------------------------------------------------
    //
    // Define locally-scoped helper functions: 
    //
    //------------------------------------------------------------

    CEnrollLocalScope(SetPendingRequestInfoHelper): 
        // Finds the appropriate cert context to set pending info on using the following algorithm:
        //   1) If a hash value HAS NOT been specified, use the cached cert request.  
        //   2) If a hash value HAS been specified, search the request store for a cert with an equivalent
        //      hash value and return it.  If no such cert can be found, return an error code. 
        HRESULT GetPendingRequestCertContext(IN  HCERTSTORE       hStoreRequest,
                                             IN  CRYPT_DATA_BLOB  hashBlob, 
                                             IN  PCCERT_CONTEXT   pCertContextCachedPendingRequest,
                                             OUT PCCERT_CONTEXT  *pCertContextPendingRequest)
        {
            EquivalentHashCertContextFilter filter(hashBlob); 
            
            if (hashBlob.pbData == NULL)
            {
                // We haven't specified a particular context, use the one we've cached. 
                *pCertContextPendingRequest = CertDuplicateCertificateContext(pCertContextCachedPendingRequest); 
                return S_OK; 
            }
            else
            {
                // Returns the first certificate in the request store with a hash matching 
                // pHashBlob.  
                return FilteredCertEnumCertificatesInStore
                    (hStoreRequest, NULL, &filter, pCertContextPendingRequest); 
            }
        }


        DWORD   GetPendingInfoBlobSize(IN  LONG              lRequestID,
                                       IN  LPCWSTR           pwszCADNS,
                                       IN  LPCWSTR           pwszCAName, 
                                       IN  LPCWSTR           pwszFriendlyName)
        {
            assert(pwszCADNS != NULL && pwszCAName != NULL && pwszFriendlyName != NULL); 
            
            return  (DWORD)(sizeof(lRequestID) +                            // Request ID
                     sizeof(DWORD) +                                 // wcslen(pwszCADNS)
                     sizeof(WCHAR) * (wcslen(pwszCADNS) + 1) +       // pwszCADNS
                     sizeof(DWORD) +                                 // wcslen(pwszCAName)
                     sizeof(WCHAR) * (wcslen(pwszCAName) + 1) +      // pwszCAName
                     sizeof(DWORD) +                                 // wcslen(pwszFriendlyName)
                     sizeof(WCHAR) * (wcslen(pwszFriendlyName) + 1)  // pwszFriendlyName
                     ); 
        }


        // Combines the supplied pending request information into a CRYPT_DATA_BLOB 
        // See wincrypt.h for the format.  
        void MakePendingInfoBlob(IN  LONG              lRequestID,
                                 IN  LPCWSTR           pwszCADNS,
                                 IN  LPCWSTR           pwszCAName, 
                                 IN  LPCWSTR           pwszFriendlyName, 
                                 OUT CRYPT_DATA_BLOB   pendingInfoBlob)
        {
            DWORD   ccCADNS; 
            DWORD   ccCAName; 
            DWORD   ccFriendlyName; 
            LPBYTE  pbBlob; 

            // None of the inputs should be NULL. 
            assert(pwszCADNS != NULL && pwszCAName != NULL && pwszFriendlyName != NULL); 

            // Declare an array of the strings we wish to write to the pending info blob
            struct StringsToWrite { 
                DWORD    cc; 
                LPCWSTR  pwsz;
            } rgStrings[] = { 
                { wcslen(pwszCADNS)        + 1, pwszCADNS         }, 
                { wcslen(pwszCAName)       + 1, pwszCAName        }, 
                { wcslen(pwszFriendlyName) + 1, pwszFriendlyName  }
            }; 

            // Write the request ID to the blob
            pbBlob = pendingInfoBlob.pbData; 
            memcpy(pbBlob, &lRequestID, sizeof(lRequestID)); 
            pbBlob += sizeof(lRequestID); 

            // Write all strings to the blob
            for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) 
            { 
                memcpy(pbBlob, &rgStrings[dwIndex].cc, sizeof(rgStrings[dwIndex].cc)); 
                pbBlob += sizeof(rgStrings[dwIndex].cc);
                memcpy(pbBlob, rgStrings[dwIndex].pwsz, rgStrings[dwIndex].cc * sizeof(WCHAR)); 
                pbBlob += rgStrings[dwIndex].cc * sizeof(WCHAR); 
            }

            assert(pbBlob == (pendingInfoBlob.pbData + pendingInfoBlob.cbData)); 
        }
    CEnrollEndLocalScope; 

    //------------------------------------------------------------ 
    //
    // Begin procedure body.
    //
    //------------------------------------------------------------

    CRYPT_DATA_BLOB  pendingInfoBlob;
    DWORD cb = 1000; 
    BYTE b[1000];
    HCERTSTORE       hStoreRequest; 
    HRESULT          hr                         = S_OK; 
    PCCERT_CONTEXT   pCertContextPendingRequest = NULL; 

    ZeroMemory(&pendingInfoBlob, sizeof(pendingInfoBlob)); 

    EnterCriticalSection(&m_csXEnroll); 

    // Input validation: 
    if (lRequestID < 0 || pwszCADNS == NULL || pwszCAName == NULL)
        goto InvalidArgErr; 

    // NULL is a valid value for pwszFriendlyName.  If friendly name is NULL, replace with the empty string: 
    if (pwszFriendlyName == NULL) { pwszFriendlyName = L""; }

    if (NULL == (hStoreRequest = GetStore(StoreREQUEST)) )
        goto GetStoreErr; 

    // Use our locally-scoped helper function to acquire the appropriate certificate context. 
    if (S_OK != (hr = local.GetPendingRequestCertContext
                 (hStoreRequest,
                  m_hashBlobPendingRequest, 
                  m_pCertContextPendingRequest,
                  &pCertContextPendingRequest)))
        goto GetPendingRequestCertContextErr; 

    // Allocate memory for our pending info blob: 
    pendingInfoBlob.cbData  = local.GetPendingInfoBlobSize
        (lRequestID,
         pwszCADNS,
         pwszCAName,
         pwszFriendlyName); 
    pendingInfoBlob.pbData  = (LPBYTE)LocalAlloc(LPTR, pendingInfoBlob.cbData); 
    if (NULL == pendingInfoBlob.pbData)
        goto MemoryErr; 

    // Combine our arguments into a "pending info" blob.
    local.MakePendingInfoBlob
        (lRequestID, 
         pwszCADNS, 
         pwszCAName,
         pwszFriendlyName,
         pendingInfoBlob);
                  
    // Use our pending info blob to assign the certificate context property. 
    if (!CertSetCertificateContextProperty
        (pCertContextPendingRequest, 
         CERT_ENROLLMENT_PROP_ID, 
         0,
         &pendingInfoBlob))
    {
        // Failed to set the context property. 
        goto CertSetCertificateContextPropertyErr; 
    }

    // We've completed successfully. 
    hr = S_OK;   

 CommonReturn: 
    if (NULL != pendingInfoBlob.pbData)      { LocalFree(pendingInfoBlob.pbData); }
    if (NULL != pCertContextPendingRequest)  { CertFreeCertificateContext(pCertContextPendingRequest); } 

    LeaveCriticalSection(&m_csXEnroll); 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(CertSetCertificateContextPropertyErr,  MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(GetPendingRequestCertContextErr,       hr); 
SET_HRESULT(GetStoreErr,                           MY_HRESULT_FROM_WIN32(GetLastError())); 
SET_HRESULT(InvalidArgErr,                         E_INVALIDARG); 
SET_HRESULT(MemoryErr,                             E_OUTOFMEMORY); 
} 

HRESULT STDMETHODCALLTYPE
CCEnroll::enumPendingRequestWStr(
    IN  LONG   lIndex,
    IN  LONG   lDesiredProperty,
    OUT LPVOID ppProperty
    )
{

    //------------------------------------------------------------
    //
    // Define locally scoped helper functions.
    //
    //------------------------------------------------------------

    CEnrollLocalScope(EnumPendingRequestHelper): 
        CRYPT_DATA_BLOB dataBlob;
    
        HRESULT GetContextPropertySimple(PCCERT_CONTEXT pCertContext, DWORD dwPropID)
        {
            BOOL fDone = FALSE;
            dataBlob.pbData = NULL; 
            dataBlob.cbData = 0x150; 

            do { 
                if (dataBlob.pbData != NULL) { LocalFree(dataBlob.pbData); } 

                dataBlob.pbData = (LPBYTE)LocalAlloc(LPTR, dataBlob.cbData);
                if (dataBlob.pbData == NULL) { return E_OUTOFMEMORY; } 

                if (!CertGetCertificateContextProperty
                    (pCertContext, 
                     dwPropID, 
                     (LPVOID)dataBlob.pbData, 
                     &(dataBlob.cbData)))
                {
                    if (GetLastError() != ERROR_MORE_DATA)
                        return MY_HRESULT_FROM_WIN32(GetLastError());
                }
                else 
                {
                    fDone = TRUE;
                }
            } while (!fDone); 
                
            return S_OK;
        }

        // Extracts the next packed string from our pending info blob. 
        // If pbString is non-NULL, it must be large enough to hold the entire string.  
        LPBYTE GetNextString(IN LPBYTE pbBlob, OUT DWORD *pcbSize, OUT LPBYTE pbString) { 
            DWORD dwSize; 

            memcpy(&dwSize, pbBlob, sizeof(DWORD)); 
            dwSize *= sizeof(WCHAR); // Convert to count in bytes. 
            if (NULL != pcbSize) { 
                *pcbSize = dwSize; 
            }
            pbBlob += sizeof(DWORD); 

            if (NULL != pbString) { 
                memcpy(pbString, pbBlob, dwSize); 
            }
            pbBlob += dwSize;

            return pbBlob; 
        }

    
        HRESULT getRequestID(PCCERT_CONTEXT pCertContext, long *pplProperty) {
            HRESULT hr; 
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
                *pplProperty = *((long *)dataBlob.pbData); 
            return hr;
        }
        
        HRESULT getCAName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            DWORD    dwSize; 
            HRESULT  hr; 
            LPBYTE   pb;
            
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
            { 
                pb =  dataBlob.pbData + sizeof(DWORD);  // pb points to DNS Name blob
                pb =  GetNextString(pb, NULL, NULL);    // pb points to CA Name blob
                GetNextString(pb, &dwSize, NULL);       // dwSize = size in chars of CA Name
                
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dwSize)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        GetNextString(pb, NULL, pDataBlobProperty->pbData); 
                    }   
                }

                pDataBlobProperty->cbData = dwSize; 
            }
            
            return hr; 
        }
        
        HRESULT getCADNSName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            DWORD    dwSize; 
            HRESULT  hr; 
            LPBYTE   pb;
            
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
            { 
                pb = dataBlob.pbData + sizeof(DWORD); // pb points to DNS Name blob
                GetNextString(pb, &dwSize, NULL);     // dwSize = size in chars of CA Name
                
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dwSize)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        GetNextString(pb, NULL, pDataBlobProperty->pbData); 
                    }   
                }

                pDataBlobProperty->cbData = dwSize; 
            }
            
            return hr; 
        }
        
        HRESULT getCAFriendlyName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            DWORD    dwSize; 
            HRESULT  hr; 
            LPBYTE   pb;
            
            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_ENROLLMENT_PROP_ID))) 
            { 
                // Set pb to point to the start of the CA name blob
                pb =  dataBlob.pbData + sizeof(DWORD);        // pb points to DNS Name blob
                pb =  GetNextString(pb, NULL, NULL);          // pb points to CA Name blob
                pb =  GetNextString(pb, NULL, NULL);          // pb points to Friendly Name blob

                // dwSize <-- size in chars of CA Name
                GetNextString(pb, &dwSize, NULL);
                
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dwSize)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        GetNextString(pb, NULL, pDataBlobProperty->pbData); 
                    }   
                }

                pDataBlobProperty->cbData = dwSize; 
            }

            return hr; 
        }

        HRESULT getHash(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty) { 
            HRESULT hr;

            if (S_OK == (hr = GetContextPropertySimple(pCertContext, CERT_HASH_PROP_ID)))
            {
                // If pbData is NULL, we're just doing a size check. 
                if (pDataBlobProperty->pbData != NULL)
                {
                    if (pDataBlobProperty->cbData < dataBlob.cbData)
                    {
                        hr = MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA); 
                    }
                    else
                    {
                        memcpy(pDataBlobProperty->pbData, dataBlob.pbData, dataBlob.cbData); 
                    }
                }
                
                pDataBlobProperty->cbData = dataBlob.cbData; 
            }

            return hr; 
        }
        
        HRESULT getDate(PCCERT_CONTEXT pCertContext, PFILETIME pftProperty) { 
            *pftProperty = pCertContext->pCertInfo->NotAfter; 
            return S_OK; 
        } 

        HRESULT getTemplateName(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty)   { 
            CERT_NAME_VALUE   *pCertTemplateNameValue = NULL;
            DWORD             cbCertTemplateNameValue; 
            DWORD             cbRequired = 0; 
            HRESULT           hr                      = S_OK; 
            PCERT_EXTENSION   pCertTemplateExtension  = NULL; 

            if (NULL == (pCertTemplateExtension = CertFindExtension
                         (szOID_ENROLL_CERTTYPE_EXTENSION,
                          pCertContext->pCertInfo->cExtension,
                          pCertContext->pCertInfo->rgExtension)))
                return E_INVALIDARG; 

            if (!CryptDecodeObject
                (pCertContext->dwCertEncodingType,
                 X509_UNICODE_ANY_STRING,
                 pCertTemplateExtension->Value.pbData,
                 pCertTemplateExtension->Value.cbData,
                 0,
                 NULL, 
                 &cbCertTemplateNameValue) || (cbCertTemplateNameValue == 0))
                goto CryptDecodeObjectErr; 
                
            pCertTemplateNameValue = (CERT_NAME_VALUE *)LocalAlloc(LPTR, cbCertTemplateNameValue); 
            if (NULL == pCertTemplateNameValue)
                goto MemoryErr; 

            if (!CryptDecodeObject
                (pCertContext->dwCertEncodingType,
                 X509_UNICODE_ANY_STRING,
                 pCertTemplateExtension->Value.pbData,
                 pCertTemplateExtension->Value.cbData,
                 0,
                 (void *)(pCertTemplateNameValue), 
                 &cbCertTemplateNameValue))
                goto CryptDecodeObjectErr; 

            cbRequired = sizeof(WCHAR) * (wcslen((LPWSTR)(pCertTemplateNameValue->Value.pbData)) + 1);
            if (NULL != pDataBlobProperty->pbData)
            {
                // Make sure we've allocated a large enough buffer: 
                if (pDataBlobProperty->cbData < cbRequired) { goto MoreDataErr; } 

                // Write the template name to the OUT param: 
                wcscpy((LPWSTR)pDataBlobProperty->pbData, (LPWSTR)(pCertTemplateNameValue->Value.pbData)); 
            }
                    
            hr = S_OK;
        CommonReturn: 
            // Assign the size of the template name to the cb of the OUT param.  
            // This should be done for all code paths.
            pDataBlobProperty->cbData = cbRequired; 
            
            // Free resources: 
            if (NULL != pCertTemplateNameValue) { LocalFree(pCertTemplateNameValue); }
            return hr; 

        ErrorReturn: 
            goto CommonReturn; 

        SET_HRESULT(CryptDecodeObjectErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
        SET_HRESULT(MoreDataErr,   MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA)); 
        SET_HRESULT(MemoryErr,     E_OUTOFMEMORY); 
        }

	HRESULT getTemplateOID(PCCERT_CONTEXT pCertContext, PCRYPT_DATA_BLOB pDataBlobProperty)    { 
            CERT_TEMPLATE_EXT  *pCertTemplateExt    = NULL; 
	    DWORD               cbCertTemplateExt   = 0; 
            DWORD               cbRequired = 0; 
	    HRESULT             hr;
            LPWSTR              pwszOID             = NULL; 
	    PCERT_EXTENSION     pCertExtension      = NULL; 
            
 	    if (NULL == (pCertExtension = CertFindExtension
			 (szOID_CERTIFICATE_TEMPLATE, 
			  pCertContext->pCertInfo->cExtension,
			  pCertContext->pCertInfo->rgExtension)))
		return E_INVALIDARG; 

            if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 NULL, 
		 &cbCertTemplateExt) || (cbCertTemplateExt == 0))
                goto CryptDecodeObjectErr;
            
	    pCertTemplateExt = (CERT_TEMPLATE_EXT *)LocalAlloc(LPTR, cbCertTemplateExt); 
	    if (NULL == pCertTemplateExt)
		goto MemoryErr; 

	    if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 (void *)(pCertTemplateExt), 
		 &cbCertTemplateExt))
		goto CryptDecodeObjectErr;

            cbRequired = sizeof(WCHAR) * (strlen(pCertTemplateExt->pszObjId) + 1); 

	    // See if we're just doing a size check: 
	    if (NULL != pDataBlobProperty->pbData) 
            {
                // Make sure we've allocated a large enough buffer: 
                if (pDataBlobProperty->cbData < cbRequired) { goto MoreDataErr; }
                
                // Convert the OID to a LPWSTR:
                pwszOID = WideFromMB(pCertTemplateExt->pszObjId); 
                if (NULL == pwszOID) 
                    goto WideFromMBErr; 

                // Write the template OID to the OUT param: 
                wcscpy((LPWSTR)pDataBlobProperty->pbData, pwszOID); 
            }

            hr = S_OK; 
        CommonReturn:
            // Assign the size of the OID to the cb of the OUT param.  
            // This should be done for all code paths.
            pDataBlobProperty->cbData = cbRequired; 

            // Free resources: 
            if (NULL != pCertTemplateExt) { LocalFree(pCertTemplateExt); } 
            if (NULL != pwszOID)          { MyCoTaskMemFree(pwszOID); }

            return hr; 
        ErrorReturn:
            goto CommonReturn;

	SET_HRESULT(CryptDecodeObjectErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
        SET_HRESULT(MemoryErr,            E_OUTOFMEMORY); 
        SET_HRESULT(MoreDataErr,          MY_HRESULT_FROM_WIN32(ERROR_MORE_DATA)); 
        SET_HRESULT(WideFromMBErr,        MY_HRESULT_FROM_WIN32(GetLastError())); 
        } 
        
        HRESULT getVersion(PCCERT_CONTEXT pCertContext, long *plVersion) {
            CERT_TEMPLATE_EXT  *pCertTemplateExt    = NULL; 
	    DWORD               cbCertTemplateExt   = 0; 
	    HRESULT             hr;
	    PCERT_EXTENSION     pCertExtension      = NULL; 
            
 	    if (NULL == (pCertExtension = CertFindExtension
			 (szOID_CERTIFICATE_TEMPLATE, 
			  pCertContext->pCertInfo->cExtension,
			  pCertContext->pCertInfo->rgExtension)))
		return E_INVALIDARG; 

            if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 NULL, 
		 &cbCertTemplateExt) || (cbCertTemplateExt == 0))
		goto CryptDecodeObjectErr;
            
	    pCertTemplateExt = (CERT_TEMPLATE_EXT *)LocalAlloc(LPTR, cbCertTemplateExt); 
	    if (NULL == pCertTemplateExt)
		goto MemoryErr; 

	    if (FALSE == CryptDecodeObject
		(pCertContext->dwCertEncodingType,
		 X509_CERTIFICATE_TEMPLATE,
		 pCertExtension->Value.pbData,
		 pCertExtension->Value.cbData,
		 0,
		 (void *)(pCertTemplateExt), 
		 &cbCertTemplateExt))
		goto CryptDecodeObjectErr;

            *plVersion = (long)pCertTemplateExt->dwMajorVersion; 
            hr = S_OK; 
        CommonReturn:
            // Free resources: 
            if (NULL != pCertTemplateExt) { LocalFree(pCertTemplateExt); } 

            return hr; 
        ErrorReturn:
            goto CommonReturn;

	SET_HRESULT(CryptDecodeObjectErr, MY_HRESULT_FROM_WIN32(GetLastError())); 
        SET_HRESULT(MemoryErr,            E_OUTOFMEMORY); 
        }

        void InitLocalScope() { 
            dataBlob.cbData = 0;
            dataBlob.pbData = NULL;
        }

        void FreeLocalScope() { if (dataBlob.pbData != NULL) { LocalFree(dataBlob.pbData); } }

    CEnrollEndLocalScope;
        
    //------------------------------------------------------------
    //
    // Begin procedure body.
    //
    //------------------------------------------------------------

    // FIXME: index is 0 based, correct?
    // m_dwLastPendingRequestIndex = 0; 
    // m_pCertContextLastEnumerated

    DWORD                     dwIndex; 
    HCERTSTORE                hStoreRequest     = NULL;
    HRESULT                   hr                = S_OK; 
    PCCERT_CONTEXT            pCertContext      = NULL;

    // Input validiation:
    if (lIndex != XEPR_ENUM_FIRST && (lIndex < 0 || (ppProperty == NULL)))
        return E_INVALIDARG; 

    // Init: 
    local.InitLocalScope(); 

    EnterCriticalSection(&m_csXEnroll);
    
    if ( NULL == (hStoreRequest = GetStore(StoreREQUEST)) )
        goto ErrorCertOpenRequestStore; 

    // If we're passed the ENUM_FIRST flag, reconstruct a snapshot of the request store. 
    // 
    if (lIndex == XEPR_ENUM_FIRST)
    {
        if (NULL != this->m_pPendingRequestTable) { delete this->m_pPendingRequestTable; } 

        this->m_pPendingRequestTable = new PendingRequestTable; 
        if (NULL == this->m_pPendingRequestTable)
            goto MemoryErr; 

        if (S_OK != (hr = this->m_pPendingRequestTable->construct(hStoreRequest)))
            goto ErrorConstructPendingTable; 
        
        // All done, return.  
        goto CommonReturn; 
    }

    // We want the lIndex'th element the request store.  
    // First, ensure that the enumeration is initialized: 
    if (NULL == m_pPendingRequestTable)
        goto PointerErr; 

    // Index past the end of the table.  
    if (this->m_pPendingRequestTable->size() <= (DWORD)lIndex)
    { 
        hr = MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND);
        goto ErrorReturn; 
    }

    pCertContext = (*this->m_pPendingRequestTable)[(DWORD)lIndex]; 

    switch (lDesiredProperty)
        {
        case XEPR_REQUESTID:       return local.getRequestID      (pCertContext, (long *)ppProperty); 
        case XEPR_CANAME:          return local.getCAName         (pCertContext, (PCRYPT_DATA_BLOB)ppProperty); 
        case XEPR_CAFRIENDLYNAME:  return local.getCAFriendlyName (pCertContext, (PCRYPT_DATA_BLOB)ppProperty); 
        case XEPR_CADNS:           return local.getCADNSName      (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);
        case XEPR_DATE:            return local.getDate           (pCertContext, (PFILETIME)ppProperty); 
        case XEPR_V1TEMPLATENAME:  return local.getTemplateName   (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);
        case XEPR_V2TEMPLATEOID:   return local.getTemplateOID    (pCertContext, (PCRYPT_DATA_BLOB)ppProperty);
        case XEPR_VERSION:         return local.getVersion        (pCertContext, (long *)ppProperty);
        case XEPR_HASH:            return local.getHash           (pCertContext, (PCRYPT_DATA_BLOB)ppProperty); 
        default: 
            return E_INVALIDARG; 
        }

 CommonReturn: 
    local.FreeLocalScope(); 

    LeaveCriticalSection(&m_csXEnroll); 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

SET_HRESULT(MemoryErr, E_OUTOFMEMORY); 
SET_HRESULT(PointerErr, E_POINTER);
TRACE_ERROR(ErrorCertOpenRequestStore); 
TRACE_ERROR(ErrorConstructPendingTable);
}


HRESULT STDMETHODCALLTYPE
CCEnroll::removePendingRequestWStr
  (IN CRYPT_DATA_BLOB thumbPrintBlob
   )
{
    EquivalentHashCertContextFilter equivHashFilter(thumbPrintBlob); 
    PendingCertContextFilter        pendingCertFilter; 
    // combinedFilter now only allows PENDING requests which match the specified thumbprint. 
    CompositeCertContextFilter      combinedFilter(&equivHashFilter, &pendingCertFilter); 

    HCERTSTORE                      hStoreRequest = NULL;
    HRESULT                         hr;
    PCCERT_CONTEXT                  pCertContext  = NULL;

    // Input validation. 
    if (NULL == thumbPrintBlob.pbData)
    {
        hr = E_INVALIDARG; 
        goto ErrorReturn; 
    }


    if ( NULL == (hStoreRequest = GetStore(StoreREQUEST)) )
    {
        hr = E_UNEXPECTED; 
        goto ErrorReturn;
    }
    
    EnterCriticalSection(&m_csXEnroll); 
    
    if (S_OK != (hr = FilteredCertEnumCertificatesInStore
                 (hStoreRequest, 
                  NULL, 
                  &combinedFilter, 
                  &pCertContext))) 
        goto ErrorReturn; 

    if (!CertDeleteCertificateFromStore(pCertContext))
    {
        hr = MY_HRESULT_FROM_WIN32(GetLastError()); 
        // CertDeleteCertificateFromStore *always* deletes the cert context. 
        pCertContext = NULL; 
        goto ErrorReturn;
    }
    
    pCertContext = NULL; 
    hr = S_OK; 
    
 CommonReturn:
    LeaveCriticalSection(&m_csXEnroll); 

    return hr; 

 ErrorReturn:
    if (pCertContext != NULL) { CertFreeCertificateContext(pCertContext); } 
    goto CommonReturn; 
}


HRESULT FilteredCertEnumCertificatesInStore(IN  HCERTSTORE          hStore, 
                                            IN  PCCERT_CONTEXT      pCertContext, 
                                            IN  CertContextFilter  *pFilter, 
                                            OUT PCCERT_CONTEXT     *pCertContextNext)
{
    BOOL           fFilterResult; 
    HRESULT        hr = S_OK; 
    PCCERT_CONTEXT pCertContextPrev = pCertContext; 

    while (NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertContextPrev)))
    {
        if (S_OK != (hr = pFilter->accept(pCertContext, &fFilterResult)))
            return hr;

        if (fFilterResult) // We've found the next cert context in the filtered enumeration.  
        {
            *pCertContextNext = pCertContext; 
            return S_OK; 
        }
        pCertContextPrev = pCertContext; 
    }

    return MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND); 
}

static LPVOID MyLocalAlloc(ULONG cb) {
    return((LPVOID) LocalAlloc(LPTR, (UINT) cb));
}

static LPVOID MyLocalRealloc(LPVOID ptr, ULONG cb) {
    return((LPVOID) LocalReAlloc((HLOCAL) ptr, (UINT) cb, LMEM_MOVEABLE));
}

static void MyLocalFree(LPVOID ptr) {
    LocalFree((HLOCAL) ptr);
}


void * WINAPI PGetIEnrollNoCOM(const IID &iid) {

        void *      pvoid               = NULL;
        IClassFactory * pIClassFactory  = NULL;
        HRESULT         hr                                  = S_OK;

        MyCoTaskMemAlloc        = MyLocalAlloc;
        MyCoTaskMemFree         = MyLocalFree;
        MyCoTaskMemRealloc      = MyLocalRealloc;

        if( S_OK != (hr = DllGetClassObject(CLSID_CEnroll, IID_IClassFactory,  (void **) &pIClassFactory)) ) {
                pIClassFactory = NULL;
        }
        else if( S_OK != (hr = pIClassFactory->CreateInstance(NULL, iid, &pvoid)) ) {
        pvoid = NULL;
    }

        if(pIClassFactory != NULL) {
            pIClassFactory->Release();
            pIClassFactory = NULL;
        }

    SetLastError(hr);
        return(pvoid);
}

IEnroll * WINAPI PIEnrollGetNoCOM(void) 
{
    return( (IEnroll *) PGetIEnrollNoCOM(IID_IEnroll) );
}

IEnroll2 * WINAPI PIEnroll2GetNoCOM(void) 
{
    return( (IEnroll2 *) PGetIEnrollNoCOM(IID_IEnroll2) );
}

IEnroll4 * WINAPI PIEnroll4GetNoCOM(void) 
{
    return( (IEnroll4 *) PGetIEnrollNoCOM(IID_IEnroll4) );
}

HRESULT PendingRequestTable::resize(DWORD dwNewSize)
{
    TableElem * newTable = NULL;

    if (dwNewSize <= 0)
        return E_INVALIDARG; 

    newTable = (TableElem *)LocalAlloc(LPTR, sizeof(TableElem) * dwNewSize); 
    if (NULL == newTable)
        return E_OUTOFMEMORY; 

    if (NULL != this->table)
    {
        memcpy(newTable, this->table, this->dwElemSize * sizeof(TableElem)); 
        LocalFree(this->table);
    }

    this->dwElemSize = dwNewSize; 
    this->table      = newTable; 

    return S_OK; 
}

HRESULT PendingRequestTable::add(TableElem tePendingRequest)
{
    HRESULT hr; 

    if        (this->dwElemCount >  this->dwElemSize) { return E_UNEXPECTED; } 
    else if   (this->dwElemCount == this->dwElemSize) 
    { 
        // Need to allocate more memory: 
        DWORD dwNewSize = this->dwElemSize < 100 ? 100 : this->dwElemSize * 2; 

        if (S_OK != (hr = this->resize(dwNewSize)))
            return hr; 
    }
        
    this->table[this->dwElemCount++] = tePendingRequest; 
    return S_OK; 
}

PendingRequestTable::PendingRequestTable() : table(NULL), dwElemSize(0), dwElemCount(0)
{ }

PendingRequestTable::~PendingRequestTable()
{
    if (NULL != this->table)
    {
        for (DWORD dwIndex = 0; dwIndex < dwElemCount; dwIndex++)
        {
            CertFreeCertificateContext(this->table[dwIndex].pCertContext); 
        }

        LocalFree(this->table);
    }
}
        
        

HRESULT PendingRequestTable::construct(HCERTSTORE hStore)
{
    HRESULT                  hr                 = S_OK; 
    PendingCertContextFilter pendingFilter; 
    PCCERT_CONTEXT           pCertContext       = NULL;
    PCCERT_CONTEXT           pCertContextPrev   = NULL;
    TableElem                tePendingRequest; 

    // Enumerate all pending cert contexts, and add them to our table: 
    for (DWORD dwIndex = 0; TRUE; dwIndex++)
    {
        if (S_OK != (hr = FilteredCertEnumCertificatesInStore
                     (hStore, 
                      pCertContextPrev, 
                      &pendingFilter, 
                      &pCertContext)))
            break; 

        tePendingRequest.pCertContext = CertDuplicateCertificateContext(pCertContext); 
        this->add(tePendingRequest); 

        pCertContextPrev = pCertContext; 
    }

    return hr == MY_HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) ? S_OK : hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\ossload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ossload.cpp
//
//  Contents:   On demand loading of msoss.dll
//
//  Functions:  OssLoad
//              OssUnload
//
//  Forwarders: ossEncode
//              ossDecode
//              ossFreePDU
//              ossFreeBuf
//              ossLinkBer
//              ossSetEncodingRules
//
//  History:    24-Mar-99       philh   created
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <asn1code.h>
#include <ossglobl.h>

#define OSS_ENCODE_PROC_IDX                 0
#define OSS_DECODE_PROC_IDX                 1
#define OSS_FREE_PDU_PROC_IDX               2
#define OSS_FREE_BUF_PROC_IDX               3
#define OSS_LINK_BER_PROC_IDX               4
#define OSS_SET_ENCODING_RULES_PROC_IDX     5
#define OSS_PROC_CNT                        6

LPSTR rgpszOssProc[OSS_PROC_CNT] = {
    "ossEncode",                // 0
    "ossDecode",                // 1
    "ossFreePDU",               // 2
    "ossFreeBuf",               // 3
    "ossLinkBer",               // 4
    "ossSetEncodingRules"       // 5
};

void *rgpvOssProc[OSS_PROC_CNT];
HMODULE hmsossDll = NULL;

void OssUnload()
{
    if (hmsossDll) {
        FreeLibrary(hmsossDll);
        hmsossDll = NULL;
    }
}

BOOL OssLoad()
{
    BOOL fRet;
    DWORD i;

    if (NULL == (hmsossDll = LoadLibraryA("msoss.dll")))
        goto ErrorReturn;

    for (i = 0; i < OSS_PROC_CNT; i++) {
        if (NULL == (rgpvOssProc[i] = GetProcAddress(
                hmsossDll, rgpszOssProc[i])))
            goto ErrorReturn;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    OssUnload();
    fRet = FALSE;
    goto CommonReturn;
}

typedef int (DLL_ENTRY* pfnossEncode)(struct ossGlobal *world,
                              int              pdunum,
                              void            *input,
                              OssBuf          *output);

int  DLL_ENTRY ossEncode(struct ossGlobal *world,
				int              pdunum,
				void            *input,
				OssBuf          *output)
{
    if (hmsossDll)
        return ((pfnossEncode) rgpvOssProc[OSS_ENCODE_PROC_IDX])(
            world,
			pdunum,
			input,
			output);
    else
        return API_DLL_NOT_LINKED;
}

typedef int (DLL_ENTRY* pfnossDecode)(struct ossGlobal *world,
                              int             *pdunum,
                              OssBuf          *input,
                              void           **output);

int  DLL_ENTRY ossDecode(struct ossGlobal *world,
				int             *pdunum,
				OssBuf          *input,
				void           **output)
{
    if (hmsossDll)
        return ((pfnossDecode) rgpvOssProc[OSS_DECODE_PROC_IDX])(
            world,
			pdunum,
			input,
			output);
    else
        return API_DLL_NOT_LINKED;
}

typedef int (DLL_ENTRY* pfnossFreePDU)(struct ossGlobal *world,
                               int               pdunum,
                               void             *data);

int  DLL_ENTRY ossFreePDU(struct ossGlobal *world,
				int               pdunum,
				void             *data)
{
    if (hmsossDll)
        return ((pfnossFreePDU) rgpvOssProc[OSS_FREE_PDU_PROC_IDX])(
            world,
			pdunum,
            data);
    else
        return API_DLL_NOT_LINKED;
}

typedef void (DLL_ENTRY* pfnossFreeBuf)(struct ossGlobal *world,
                                void              *data);

void DLL_ENTRY ossFreeBuf(struct ossGlobal *world,
				void              *data)
{
    if (hmsossDll)
        ((pfnossFreeBuf) rgpvOssProc[OSS_FREE_BUF_PROC_IDX])(
            world,
            data);
}

typedef void (DLL_ENTRY* pfnossLinkBer)(OssGlobal *world);

void DLL_ENTRY ossLinkBer(OssGlobal *world)
{
    if (hmsossDll)
        ((pfnossLinkBer) rgpvOssProc[OSS_LINK_BER_PROC_IDX])(world);
}


typedef int (DLL_ENTRY* pfnossSetEncodingRules)(struct ossGlobal *world,
                    ossEncodingRules rules);

int              DLL_ENTRY ossSetEncodingRules(struct ossGlobal *world,
						ossEncodingRules rules)
{
    if (hmsossDll)
        return ((pfnossSetEncodingRules)
            rgpvOssProc[OSS_SET_ENCODING_RULES_PROC_IDX])(
                world,
                rules);
    else
        return API_DLL_NOT_LINKED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xenroll.rc
//
#define IDS_PROJNAME                    100
#define IDR_CENROLL			101
#define IDS_NOTSAFEACTION		120
#define IDS_REQ_STORE_FULL		121
#define IDS_SPC_C			122
#define IDS_SPC_O			123
#define IDS_PVK_C			124
#define IDS_PVK_O			124	 // not a bug, same as PVK_C
#define IDS_NOTSAFE_OPEN_FORMAT        125
#define IDS_NOTSAFE_WRITE_FORMAT       126
#define IDS_WITHOUTPASSWORD		127
#define IDS_CONFIRMPASSWORD		128
#define IDS_NOTSAFE_OPEN            129
#define IDS_NOTSAFE_OPEN_PREFIX     130
#define IDS_NOTSAFE_WRITE_PREFIX    131
#define IDS_CERTENROLL              132
#define IDS_OVERWRITE_FORMAT        133

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\pvk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pvk.h
//
//  Contents:   Shared types and functions
//              
//  APIs:
//
//  History:    12-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVK_H__
#define __PVK_H__

#include "pvkhlpr.h"
#include "pvkdlgs.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Pvk allocation and free routines
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    );
void PvkFree(
    IN void *pv
    );


//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
enum PASSWORD_TYPE {
    ENTER_PASSWORD = 0,
    CREATE_PASSWORD
};

BOOL WINAPI PvkDllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
		);

BOOL
WINAPI
PrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    );

BOOL
WINAPI
PrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    );


int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\pvkhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.cpp
//
//  Contents:   Private Key Helper APIs
//
//  Functions:  PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include "wincrypt.h"
#include "pvk.h"
#include "unicode.h"

#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0
#define PVK_RC4_PASSWORD_ENCRYPT        1
#define PVK_RC2_CBC_PASSWORD_ENCRYPT    2

#define MAX_PVK_FILE_LEN            4096
#define MAX_BOB_FILE_LEN            (4096*4)

typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);



//+-------------------------------------------------------------------------
//  Private key helper allocation and free functions
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
void PvkFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Read  & Write to file function
//--------------------------------------------------------------------------
static BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}

static BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL) && cbBytesRead == cb);
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pb[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

static BOOL GetPasswordKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN PASSWORD_TYPE PasswordType,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN BOOL fNoPassDlg,
    IN BYTE *pbSalt,
    IN DWORD cbSalt,
    OUT HCRYPTKEY *phEncryptKey
    )
{
    BOOL fResult;
    BYTE *pbAllocPassword = NULL;
    BYTE *pbPassword;
    DWORD cbPassword;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hEncryptKey = 0;
    BYTE rgbPwdBuffer[] = {67, 82, 65, 80};

    if (fNoPassDlg) {
        pbPassword = rgbPwdBuffer;
        cbPassword = sizeof(rgbPwdBuffer);
    } else {
        if (IDOK != PvkDlgGetKeyPassword(
                PasswordType,
                hwndOwner,
                pwszKeyName,
                &pbAllocPassword,
                &cbPassword
                )) {
            SetLastError(PVK_HELPER_PASSWORD_CANCEL);
            goto ErrorReturn;
        }
        pbPassword = pbAllocPassword;
    }

    if (cbPassword) {
        if (!CryptCreateHash(hProv, CALG_SHA, 0, 0, &hHash))
            goto ErrorReturn;
        if (cbSalt) {
            if (!CryptHashData(hHash, pbSalt, cbSalt, 0))
                goto ErrorReturn;
        }
        if (!CryptHashData(hHash, pbPassword, cbPassword, 0))
            goto ErrorReturn;
        if (!CryptDeriveKey(hProv, Algid, hHash, 0, &hEncryptKey))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
CommonReturn:
    if (pbAllocPassword)
        PvkFree(pbAllocPassword);
    if (hHash)
        CryptDestroyHash(hHash);
    *phEncryptKey = hEncryptKey;
    return fResult;
}

// Support backwards compatibility with Bob's storage file which contains
// a snap shot of the keys as they are stored in the registry. Note, for
// win95, the registry values are decrypted before being written to the file.
static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    );

static BOOL LoadKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hDecryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr))) goto BadPvkFile;
    if (Hdr.dwMagic != PVK_MAGIC)
        // Try to load as Bob's storage file containing streams for the
        // private and public keys. Bob made a copy of the cryptography
        // registry key values.
        //
        // Note, Bob now has two different formats for storing the private
        // key information. See LoadBobKey for details.
        fResult = LoadBobKey(hCryptProv, hRead, pfnRead, cbKeyData, hwndOwner,
            pwszKeyName, dwFlags, pdwKeySpec, &Hdr);
    else {
        // Treat as a "normal" private key file
        cbPvk = Hdr.cbPvk;
        if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
            Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
            cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
        goto BadPvkFile;
    
        if (pdwKeySpec) {
            DWORD dwKeySpec = *pdwKeySpec;
            *pdwKeySpec = Hdr.dwKeySpec;
            if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
                SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
                goto ErrorReturn;
            }
        }
    
        if (Hdr.cbEncryptData) {
            // Read the encrypt data
            if (NULL == (pbEncryptData = (BYTE *) PvkAlloc(Hdr.cbEncryptData)))
                goto ErrorReturn;
            if (!pfnRead(hRead, pbEncryptData, Hdr.cbEncryptData))
                goto BadPvkFile;
        }
    
        // Allocate and read the private key
        if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
            goto ErrorReturn;
        if (!pfnRead(hRead, pbPvk, cbPvk))
            goto BadPvkFile;
    
    
        // Get symmetric key to decrypt the private key
        switch (Hdr.dwEncryptType) {
            case PVK_NO_ENCRYPT:
                break;
            case PVK_RC4_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC4,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            case PVK_RC2_CBC_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC2,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            default:
                goto BadPvkFile;
        }

        // Decrypt and import the private key
        if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, hDecryptKey, dwFlags,
                &hKey))
            goto ErrorReturn;

        fResult = TRUE;
    }
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncryptData)
        PvkFree(pbEncryptData);
    if (pbPvk)
        PvkFree(pbPvk);
    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL SaveKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hEncryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;     // Not allocated
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    BYTE rgbSalt[16];

    // Initialize the header record
    memset(&Hdr, 0, sizeof(Hdr));
    Hdr.dwMagic = PVK_MAGIC;
    Hdr.dwVersion = PVK_FILE_VERSION_0;
    Hdr.dwKeySpec = dwKeySpec;

    // Generate random salt
    if (!CryptGenRandom(hCryptProv, sizeof(rgbSalt), rgbSalt))
        goto ErrorReturn;

    // Get symmetric key to use to encrypt the private key
#if 1
    if (!GetPasswordKey(hCryptProv, CALG_RC4,
#else
    if (!GetPasswordKey(hCryptProv, CALG_RC2,
#endif
            CREATE_PASSWORD, hwndOwner, pwszKeyName,
            fNoPassDlg, rgbSalt, sizeof(rgbSalt), &hEncryptKey))
        goto ErrorReturn;
    if (hEncryptKey) {
#if 1
        Hdr.dwEncryptType = PVK_RC4_PASSWORD_ENCRYPT;
#else
        Hdr.dwEncryptType = PVK_RC2_CBC_PASSWORD_ENCRYPT;
#endif
        Hdr.cbEncryptData = sizeof(rgbSalt);
        pbEncryptData = rgbSalt;
    } else
        Hdr.dwEncryptType = PVK_NO_ENCRYPT;

    // Allocate, encrypt and export the private key
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        goto ErrorReturn;
    cbPvk = 0;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, NULL,
            &cbPvk))
        goto ErrorReturn;
    if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
        goto ErrorReturn;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, pbPvk,
            &cbPvk))
        goto ErrorReturn;
    Hdr.cbPvk = cbPvk;


    // Write the header, optional encrypt data, and private key to the file
    if (!pfnWrite(hWrite, &Hdr, sizeof(Hdr)))
        goto ErrorReturn;
    if (Hdr.cbEncryptData) {
        if (!pfnWrite(hWrite, pbEncryptData, Hdr.cbEncryptData))
            goto ErrorReturn;
    }
    if (!pfnWrite(hWrite, pbPvk, cbPvk))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        PvkFree(pbPvk);
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from the file into the cryptographic provider.
//
//  If the private key was password encrypted, then, the user is first
//  presented with a dialog box to enter the password.
//
//  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
//  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
//  a mismatch. *pdwKeySpec is updated with the key type.
//
//  dwFlags is passed through to CryptImportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKey(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to the specified file.
//
//  The user is presented with a dialog box to enter an optional password to
//  encrypt the private key.
//
//  dwFlags is passed through to CryptExportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKey(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from memory into the cryptographic provider.
//
//  Except for the key being loaded from memory, identical to PrivateKeyLoad.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoadFromMemory(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKey(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to memory.
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error (also, the user isn't prompted for a password).
//
//  Except for the key being saved to memory, identical to PrivateKeySave.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySaveToMemory(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKey(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(WCHAR))


static BOOL AcquireKeyContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;
    DWORD dwKeySpec;
    RPC_STATUS  rpc_status;

    // Create a temporary keyset to load the private key into
    rpc_status = UuidCreate(&TmpContainerUuid);
    if (RPC_S_OK != rpc_status && RPC_S_UUID_LOCAL_ONLY != rpc_status)
    {
        //hr = rpc_status;
        goto ErrorReturn;
    }
    if (NULL == (pwszTmpContainer = (LPWSTR) PvkAlloc(
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES)))
        goto ErrorReturn;
    wcscpy(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKey(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pwszTmpContainer) {
        PvkFree(pwszTmpContainer);
        pwszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppwszTmpContainer = pwszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from the specified file.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoad is called to load the private key into the temporary
//  container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Functions supporting backwards compatibility with Bob's storage file
//  containing a snap shot of the keys as they are stored in the registry.
//  Note, for win95, the registry values are decrypted before being written to
//  the file.
//--------------------------------------------------------------------------

// Return the size of this stream; return 0 if an error
static DWORD CbBobSize(IStream *pStm)
{
    STATSTG stat;
    if (FAILED(pStm->Stat(&stat, STATFLAG_NONAME)))
        return 0;
    return stat.cbSize.LowPart;
}

// Allocate and read this value which has the indicated stream name from the
// storage
static BOOL LoadBobStream(
    IStorage *pStg,
    LPCWSTR pwszStm,
    BYTE **ppbValue,
    DWORD *pcbValue
    )
{
    BOOL fResult;
    HRESULT hr;
    IStream *pStm = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbRead;

    if (FAILED(hr = pStg->OpenStream(pwszStm, 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm)))
        goto HrError;

    if (0 == (cbValue = CbBobSize(pStm))) goto BadBobFile;

    if (NULL == (pbValue = (BYTE *) PvkAlloc(cbValue))) goto ErrorReturn;

    pStm->Read(pbValue, cbValue, &cbRead);
    if (cbRead != cbValue) goto BadBobFile;

    fResult = TRUE;
    goto CommonReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;
BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    if (pbValue) {
        PvkFree(pbValue);
        pbValue = NULL;
    }
    cbValue = 0;
    fResult = FALSE;
CommonReturn:
    if (pStm)
        pStm->Release();
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
}

// New "Bob" format::
//
// Allocate and read either the Exported Signature or Exchange Private 
// key stream from the storage
static BOOL LoadBobExportedPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"Exported Signature Private Key";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"Exported Exchange Private Key";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

// Old "Bob" format::
//
// Allocate and read either the Signature or Exchange Private
// key streams from the storage
static BOOL LoadBobOldPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"SPvk";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"EPvk";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Key header structures for private key construction
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.
//
//    For more info see Jeff Spellman in the crypto team or look in the
//    source to RsaBase.Dll
//

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

///////////////////////////////////////////////////////////////////////////////////////
//
//  Take a raw exported unshrowded private key from the registry and turn it
//  into a private key export blob.
//
//  This is based on the PreparePrivateKeyForExport routine from rsabase.dll
//
static BOOL ConstructPrivateKeyExportBlob(
        IN DWORD            dwKeySpec,
        IN BSAFE_PRV_KEY *  pPrvKey,            
        IN DWORD            PrvKeyLen,
        OUT PBYTE           *ppbBlob,
        OUT DWORD           *pcbBlob
        )
{
    BOOL fResult;
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = pPrvKey->bitlen / 16;
    cbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen +
        sizeof(PUBLICKEYSTRUC);

    if (NULL == (pbBlob = (BYTE *) PvkAlloc(cbBlob))) {
        fResult = FALSE;
        cbBlob = 0;
    } else {
        BYTE* pb = pbBlob;
        PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pb;
        pPubKeyStruc->bType         = PRIVATEKEYBLOB;
        pPubKeyStruc->bVersion      = 2;
        pPubKeyStruc->reserved      = 0;
        if (dwKeySpec == AT_KEYEXCHANGE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        else if (dwKeySpec == AT_SIGNATURE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_SIGN;
        else
            pPubKeyStruc->aiKeyAlg = 0;

        pb = pbBlob + sizeof(PUBLICKEYSTRUC);

        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pb;
        pExportKey->magic  = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pb + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        memcpy(pbOut, pbIn, cbHalfModLen * 2);
        pbIn += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbOut += cbHalfModLen * 2;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen * 2);

        fResult = TRUE;
    }
    *ppbBlob = pbBlob;
    *pcbBlob = cbBlob;
    return fResult;
}

static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    )
{
    BOOL fResult;
    DWORD dwErr = 0;
    HRESULT hr;
    HGLOBAL hGlobal = NULL;
    BYTE *pbBobKey;         // not allocated
    ILockBytes *pLkByt = NULL;
    IStorage *pStg = NULL;
    IStorage *pPrivStg = NULL;
    BYTE *pbPvkValue = NULL;
    DWORD cbPvkValue;
    DWORD dwKeySpec;

    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    if (cbBobKey > MAX_BOB_FILE_LEN) goto BadBobFile;

    if (NULL == (hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
            cbBobKey)))
        goto ErrorReturn;

    if (NULL == (pbBobKey = (BYTE *) GlobalLock(hGlobal)))
        goto ErrorReturn;
    memcpy(pbBobKey, (BYTE *) pHdr, sizeof(FILE_HDR));
    if (cbBobKey > sizeof(FILE_HDR))
        fResult = pfnRead(hRead, pbBobKey + sizeof(FILE_HDR),
            cbBobKey - sizeof(FILE_HDR));
    else
        fResult = TRUE;
    GlobalUnlock(hGlobal);
    if (!fResult) goto ErrorReturn;

    // FALSE => don't DeleteOnRelease
    if (FAILED(hr = CreateILockBytesOnHGlobal(hGlobal, FALSE, &pLkByt)))
        goto HrError;

    if (FAILED(hr = StgOpenStorageOnILockBytes(
            pLkByt,
            NULL,       // pStgPriority
            STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,
            NULL,    // snbExclude
            0,       // dwReserved
            &pStg
            ))) goto HrError;

    if (FAILED(pStg->OpenStorage(
            L"Plain Private Key",
            0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL,
            0,
            &pPrivStg))) goto BadBobFile;

    if (pdwKeySpec && *pdwKeySpec)
        dwKeySpec = *pdwKeySpec;
    else
        dwKeySpec = AT_SIGNATURE;

    // First, attempt to read the new format where the keys are stored in
    // the private key export format
    fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec, &pbPvkValue,
        &cbPvkValue);
    if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
        dwKeySpec = AT_KEYEXCHANGE;
        fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec,
            &pbPvkValue, &cbPvkValue);
    }
    if (fResult)
        fResult =  PrivateKeyLoadFromMemory(
            hCryptProv,
            pbPvkValue,
            cbPvkValue,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            &dwKeySpec
            );
    else {
        // Try "old" format

        if (pdwKeySpec && *pdwKeySpec)
            dwKeySpec = *pdwKeySpec;
        else
            dwKeySpec = AT_SIGNATURE;

        fResult = LoadBobOldPvk(pPrivStg, dwKeySpec, &pbPvkValue, &cbPvkValue);
        if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
            dwKeySpec = AT_KEYEXCHANGE;
            fResult = LoadBobOldPvk(pPrivStg, dwKeySpec,
                &pbPvkValue, &cbPvkValue);
        }
        if (fResult) {
            BYTE *pbExportPvk;
            DWORD cbExportPvk;
            // Convert Bob's old private key format to the new export private
            // key format
            if ((fResult = ConstructPrivateKeyExportBlob(
                    dwKeySpec,
                    (BSAFE_PRV_KEY *) pbPvkValue,
                    cbPvkValue,
                    &pbExportPvk,
                    &cbExportPvk
                    ))) {
                HCRYPTKEY hKey = 0;
                // Import the private key
                fResult = CryptImportKey(hCryptProv, pbExportPvk, cbExportPvk,
                    0, dwFlags, &hKey);
                if (hKey)
                    CryptDestroyKey(hKey);
                PvkFree(pbExportPvk);
            }
        }
    }
    
    if (fResult) goto CommonReturn;
    goto ErrorReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;

BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    dwKeySpec = 0;
    fResult = FALSE;

    // One of the following Releases may clear it out
    dwErr = GetLastError();
CommonReturn:
    if (pbPvkValue)
        PvkFree(pbPvkValue);
    if (pPrivStg)
        pPrivStg->Release();
    if (pStg)
        pStg->Release();
    if (pLkByt)
        pLkByt->Release();
    if (hGlobal)
        GlobalFree(hGlobal);

    if (pdwKeySpec)
        *pdwKeySpec = dwKeySpec;
    if (dwErr)
        SetLastError(dwErr);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\pvkdlgs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pvkdlgs.h
//
//--------------------------------------------------------------------------

#define IDC_PASSWORD0               501
#define IDC_PASSWORD1               502
#define IDC_KEY                     504
#define IDC_NONE                    505
#define IDD_ENTERKEYPASSWORD        530
#define IDD_CREATEKEYPASSWORD       540
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\pvkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkdlg.cpp
//
//  Contents:   Private Key Dialog Box APIs.
//
//  Functions:  PvkDlgGetKeyPassword
//
//  History:    12-May-96   philh created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <unicode.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "pvk.h"

#include "xenroll.h"
#include "cenroll.h"

// ENTER_PASSWORD:
//  IDC_PASSWORD0 - Password

// CREATE_PASSWORD:
//  IDC_PASSWORD0 - Password
//  IDC_PASSWORD1 - Confirm Password


typedef struct _KEY_PASSWORD_PARAM {
    PASSWORD_TYPE   PasswordType;
    LPWSTR          pwszKey;           // IDC_KEY
    LPSTR           *ppszPassword;
} KEY_PASSWORD_PARAM, *PKEY_PASSWORD_PARAM;


// Where to get the dialog resources from
static HINSTANCE hPvkInst;

// Forward reference to local functions
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            );

static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI PvkDllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        hPvkInst = hInstDLL;
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            )
{
    int nResult;
    LPSTR pszPassword = NULL;
    KEY_PASSWORD_PARAM KeyPasswordParam = {
        PasswordType,
        (LPWSTR) pwszKeyName,
        &pszPassword
    };

    LPCSTR pszTemplate = PasswordType == ENTER_PASSWORD ?
        MAKEINTRESOURCE(IDD_ENTERKEYPASSWORD) :
        MAKEINTRESOURCE(IDD_CREATEKEYPASSWORD);

    nResult = (BOOL)DialogBoxParam(
        hPvkInst,
        pszTemplate,
        hwndOwner,
        KeyPasswordDlgProc,
        (LPARAM) &KeyPasswordParam
        );

    *ppbPassword = (BYTE *) pszPassword;
    if (pszPassword)
        *pcbPassword = strlen(pszPassword);
    else
        *pcbPassword = 0;

    return nResult;
}

//+-------------------------------------------------------------------------
//  Allocate and get the password(s) from the dialog box
//
//  For no password input, returns NULL
//  pointer for the password. Otherwise, the password is PvkAlloc'ed.
//--------------------------------------------------------------------------
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            )
{
    WCHAR         *pwszString = NULL;
    LPSTR rgpszPassword[2] = {NULL, NULL};

    *ppszPassword = NULL;

    // Get the entered password(s)
    assert(PasswordType < 2);
    int i;
    for (i = 0; i <= PasswordType; i++) {
        LONG cchPassword;
        cchPassword = (LONG)SendDlgItemMessage(
            hwndDlg,
            IDC_PASSWORD0 + i,
            EM_LINELENGTH,
            (WPARAM) 0,
            (LPARAM) 0
            );
        if (cchPassword > 0) {
            rgpszPassword[i] = (LPSTR) PvkAlloc(cchPassword + 1);
            assert(rgpszPassword[i]);
            if (rgpszPassword[i])
                GetDlgItemText(
                    hwndDlg,
                    IDC_PASSWORD0 + i,
                    rgpszPassword[i],
                    cchPassword + 1
                    );
        }
    }

    if (PasswordType == ENTER_PASSWORD) {
        *ppszPassword = rgpszPassword[0];
        return IDOK;
    }

    int nResult = IDOK;
#define MSG_BOX_TITLE_LEN 128
    WCHAR wszMsgBoxTitle[MSG_BOX_TITLE_LEN];
    GetWindowTextU(hwndDlg, wszMsgBoxTitle, MSG_BOX_TITLE_LEN);

    if (rgpszPassword[0] == NULL && rgpszPassword[1] == NULL) {
        // Didn't enter a password

        xeLoadRCString(hPvkInst, IDS_WITHOUTPASSWORD, &pwszString);
        nResult = MessageBoxU(
            hwndDlg,
            pwszString,
            wszMsgBoxTitle,
            MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2
            );
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
        }
        if (nResult == IDYES)
            nResult = IDOK;
        else if (nResult == IDNO)
            nResult = IDRETRY;
    } else if (rgpszPassword[0] == NULL || rgpszPassword[1] == NULL ||
               strcmp(rgpszPassword[0], rgpszPassword[1]) != 0) {
               
        // Confirmed password didn't match
        xeLoadRCString(hPvkInst, IDS_CONFIRMPASSWORD, &pwszString);
        nResult = MessageBoxU(
            hwndDlg,
            pwszString,
            wszMsgBoxTitle,
            MB_RETRYCANCEL | MB_ICONEXCLAMATION
            );
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
        }
        if (nResult == IDRETRY) {
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 0, "");
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 1, "");
        }
    }

    if (nResult == IDOK)
        *ppszPassword = rgpszPassword[0];
    else if (rgpszPassword[0])
        PvkFree(rgpszPassword[0]);
    if (rgpszPassword[1])
        PvkFree(rgpszPassword[1]);

    if (nResult == IDRETRY)
        SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD0));
    return nResult;
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password DialogProc
//--------------------------------------------------------------------------
static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            )
{
    switch (uMsg) {
        case WM_INITDIALOG:
        {
            PKEY_PASSWORD_PARAM pKeyPasswordParam =
                (PKEY_PASSWORD_PARAM) lParam;

            char sz[128];
            WideCharToMultiByte(CP_ACP, 0, pKeyPasswordParam->pwszKey, -1,
                (LPSTR) sz, 128, NULL, NULL);

            SetDlgItemText(hwndDlg, IDC_KEY, sz);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (INT_PTR) pKeyPasswordParam);
            return TRUE;
        }
        case WM_COMMAND:
            int nResult = LOWORD(wParam);
            switch (nResult) {
                case IDOK:
                {
                    PKEY_PASSWORD_PARAM pKeyPasswordParam =
                        (PKEY_PASSWORD_PARAM) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    nResult = GetPassword(
                        hwndDlg,
                        pKeyPasswordParam->PasswordType,
                        pKeyPasswordParam->ppszPassword
                        );
                    if (nResult != IDRETRY)
                        EndDialog(hwndDlg, nResult);
                    return TRUE;
                }
                    break;
                case IDC_NONE:
                    nResult = IDOK;     // *ppszPassword == NULL
                    // Fall through
                case IDCANCEL:
                    EndDialog(hwndDlg, nResult);
                    return TRUE;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__43F8F27F_7A20_11D0_8F06_00C04FC295E1__INCLUDED_)
#define AFX_STDAFX_H__43F8F27F_7A20_11D0_8F06_00C04FC295E1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__43F8F27F_7A20_11D0_8F06_00C04FC295E1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xasn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xasn.h
//
//--------------------------------------------------------------------------

/************************************************************************/
/* Copyright (C) 1998 Open Systems Solutions, Inc.  All rights reserved.*/
/************************************************************************/
/* Generated for: Microsoft Corporation */
/* Abstract syntax: xasn */
/* Created: Tue Mar 17 17:07:17 1998 */
/* ASN.1 compiler version: 4.2.6 */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -listingfile xasn.lst -noshortennames -1990 -noconstraints
 * ..\..\..\tools\ossasn1\ASN1DFLT.ZP8 xasn.asn
 */

#ifndef OSS_xasn
#define OSS_xasn

#include "asn1hdr.h"
#include "asn1code.h"

#define          EnhancedKeyUsage_PDU 1
#define          RequestFlags_PDU 2
#define          CSPProvider_PDU 3
#define          EnrollmentNameValuePair_PDU 4

typedef struct ObjectID {
    unsigned short  count;
    unsigned long   value[16];
} ObjectID;

typedef struct BITSTRING {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} BITSTRING;

typedef struct BMPSTRING {
    unsigned int    length;
    unsigned short  *value;
} BMPSTRING;

typedef ObjectID        UsageIdentifier;

typedef struct EnhancedKeyUsage {
    unsigned int    count;
    UsageIdentifier *value;
} EnhancedKeyUsage;

typedef struct RequestFlags {
    ossBoolean      fWriteToCSP;
    ossBoolean      fWriteToDS;
    int             openFlags;
} RequestFlags;

typedef struct CSPProvider {
    int             keySpec;
    BMPSTRING       cspName;
    BITSTRING       signature;
} CSPProvider;

typedef struct EnrollmentNameValuePair {
    BMPSTRING       name;
    BMPSTRING       value;
} EnrollmentNameValuePair;


extern void *xasn;    /* encoder-decoder control table */
#endif /* OSS_xasn */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xasn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xasn.c
//
//--------------------------------------------------------------------------

/************************************************************************/
/* Copyright (C) 1998 Open Systems Solutions, Inc.  All rights reserved.*/
/************************************************************************/
/* Generated for: Microsoft Corporation */
/* Abstract syntax: xasn */
/* Created: Tue Mar 17 17:07:17 1998 */
/* ASN.1 compiler version: 4.2.6 */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -listingfile xasn.lst -noshortennames -1990 -noconstraints
 * ..\..\..\tools\ossasn1\ASN1DFLT.ZP8 xasn.asn
 */

#include   <stddef.h>
#include   "etype.h"
#include   "xasn.h"

void DLL_ENTRY_FDEF _ossinit_xasn(struct ossGlobal *world) {
    ossLinkBer(world);
}

static unsigned short _pduarray[] = {
    4, 7, 8, 9
};

static struct etype _etypearray[] = {
    {16, 0, 0, NULL, 4, 4, 4, 4, 56, 0, 26, 0},
    {-1, 2, 0, NULL, 8, 0, 4, 4, 10, 0, 3, 0},
    {-1, 4, 30, NULL, 8, 0, 4, 4, 8, 0, 53, 0},
    {16, 0, 0, NULL, 4, 4, 4, 4, 24, 0, 26, 0},
    {-1, 6, 0, NULL, 8, 68, 4, 4, 8, 3, 19, 0},
    {-1, 8, 0, NULL, 1, 0, 0, 0, 8, 0, 8, 0},
    {-1, 10, 0, NULL, 4, 0, 4, 0, 8, 0, 0, 0},
    {-1, 12, 14, NULL, 8, 3, 0, 0, 8, 0, 12, 0},
    {-1, 26, 28, NULL, 20, 3, 0, 0, 8, 3, 12, 0},
    {-1, 40, 42, NULL, 16, 2, 0, 0, 8, 6, 12, 0}
};

static struct efield _efieldarray[] = {
    {0, 5, -1, 0, 0},
    {1, 5, -1, 0, 0},
    {4, 6, -1, 0, 0},
    {0, 6, -1, 0, 0},
    {4, 2, -1, 0, 0},
    {12, 1, -1, 0, 0},
    {0, 2, -1, 0, 0},
    {8, 2, -1, 0, 0}
};

static Etag _tagarray[] = {
    1, 0x0006, 1, 0x0003, 1, 0x001e, 1, 0x0010, 1, 0x0001,
    1, 0x0002, 1, 0x0010, 17, 20, 23, 1, 0x0001, 1,
    1, 0x0001, 2, 1, 0x0002, 3, 1, 0x0010, 31, 34,
    37, 1, 0x0002, 1, 1, 0x001e, 2, 1, 0x0003, 3,
    1, 0x0010, 44, 47, 1, 0x001e, 1, 1, 0x001e, 2
};

static struct eheader _head = {_ossinit_xasn, -1, 15, 772, 4, 10,
    _pduarray, _etypearray, _efieldarray, NULL, _tagarray,
    NULL, NULL, NULL, 0};

#ifdef _OSSGETHEADER
void *DLL_ENTRY_FDEF ossGetHeader()
{
    return &_head;
}
#endif /* _OSSGETHEADER */

void *xasn = &_head;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xenroll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xenroll.cpp
//
//--------------------------------------------------------------------------

#if _MSC_VER < 1200
#pragma comment(linker,"/merge:.CRT=.data")
#endif

// xenroll.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f xenrollps.mk in the project directory.


#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "xenroll.h"
#include "CEnroll.h"
#include <pvk.h>


extern BOOL MSAsnInit(HMODULE hInst);
extern void MSAsnTerm();
extern BOOL AsnInit(HMODULE hInst);
extern void AsnTerm();
extern BOOL WINAPI I_CryptOIDInfoDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

CComModule _Module;
HINSTANCE hInstanceXEnroll = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CEnroll, CCEnroll)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern BOOL WINAPI UnicodeDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        if (!MSAsnInit(hInstance))
            AsnInit(hInstance);
		hInstanceXEnroll = hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        MSAsnTerm();
        AsnTerm();
		_Module.Term();
    }

    return( 
	    I_CryptOIDInfoDllMain(hInstance, dwReason, lpReserved)  &&
	    PvkDllMain(hInstance, dwReason, lpReserved)             &&
	    UnicodeDllMain(hInstance, dwReason, lpReserved)         &&
	    InitIE302UpdThunks(hInstance, dwReason, lpReserved));    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
   HRESULT hRes;
   // registers object, typelib and all interfaces in typelib
   hRes = _Module.RegisterServer(TRUE);

    return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT  hr = S_OK;
    
    _Module.UnregisterServer();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xmsasn.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#include <windows.h>
#include "xmsasn.h"

ASN1module_t XMSASN_Module = NULL;

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Enc_RequestFlags(ASN1encoding_t enc, ASN1uint32_t tag, RequestFlags *val);
static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_RequestFlags(ASN1decoding_t dec, ASN1uint32_t tag, RequestFlags *val);
static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val);
static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val);
static void ASN1CALL ASN1Free_Extensions(Extensions *val);
static void ASN1CALL ASN1Free_Extension(Extension *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val);
static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val);
static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val);
static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val);
static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val);
static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val);
static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val);
static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val);
static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val);
static void ASN1CALL ASN1Free_PendInfo(PendInfo *val);
static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val);
static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val);
static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_CmcData(CmcData *val);
static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val);
static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val);
static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[9] = {
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
    (ASN1EncFun_t) ASN1Enc_RequestFlags,
    (ASN1EncFun_t) ASN1Enc_CSPProvider,
    (ASN1EncFun_t) ASN1Enc_EnrollmentNameValuePair,
    (ASN1EncFun_t) ASN1Enc_CmcAddExtensions,
    (ASN1EncFun_t) ASN1Enc_CmcAddAttributes,
    (ASN1EncFun_t) ASN1Enc_CmcData,
    (ASN1EncFun_t) ASN1Enc_CmcResponseBody,
    (ASN1EncFun_t) ASN1Enc_CmcStatusInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[9] = {
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
    (ASN1DecFun_t) ASN1Dec_RequestFlags,
    (ASN1DecFun_t) ASN1Dec_CSPProvider,
    (ASN1DecFun_t) ASN1Dec_EnrollmentNameValuePair,
    (ASN1DecFun_t) ASN1Dec_CmcAddExtensions,
    (ASN1DecFun_t) ASN1Dec_CmcAddAttributes,
    (ASN1DecFun_t) ASN1Dec_CmcData,
    (ASN1DecFun_t) ASN1Dec_CmcResponseBody,
    (ASN1DecFun_t) ASN1Dec_CmcStatusInfo,
};
static const ASN1FreeFun_t freefntab[9] = {
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CSPProvider,
    (ASN1FreeFun_t) ASN1Free_EnrollmentNameValuePair,
    (ASN1FreeFun_t) ASN1Free_CmcAddExtensions,
    (ASN1FreeFun_t) ASN1Free_CmcAddAttributes,
    (ASN1FreeFun_t) ASN1Free_CmcData,
    (ASN1FreeFun_t) ASN1Free_CmcResponseBody,
    (ASN1FreeFun_t) ASN1Free_CmcStatusInfo,
};
static const ULONG sizetab[9] = {
    SIZE_XMSASN_Module_PDU_0,
    SIZE_XMSASN_Module_PDU_1,
    SIZE_XMSASN_Module_PDU_2,
    SIZE_XMSASN_Module_PDU_3,
    SIZE_XMSASN_Module_PDU_4,
    SIZE_XMSASN_Module_PDU_5,
    SIZE_XMSASN_Module_PDU_6,
    SIZE_XMSASN_Module_PDU_7,
    SIZE_XMSASN_Module_PDU_8,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1bool_t Extension_critical_default = 0;

void ASN1CALL XMSASN_Module_Startup(void)
{
    XMSASN_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 9, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x726e6578);
}

void ASN1CALL XMSASN_Module_Cleanup(void)
{
    ASN1_CloseModule(XMSASN_Module);
    XMSASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (UsageIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RequestFlags(ASN1encoding_t enc, ASN1uint32_t tag, RequestFlags *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->fWriteToCSP))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->fWriteToDS))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->openFlags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestFlags(ASN1decoding_t dec, ASN1uint32_t tag, RequestFlags *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->fWriteToCSP))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->fWriteToDS))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->openFlags))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keySpec))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->cspName).length, ((val)->cspName).value))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->keySpec))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->cspName))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val)
{
    if (val) {
	ASN1char16string_free(&(val)->cspName);
    }
}

static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->value).length, ((val)->value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->name))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val)
{
    if (val) {
	ASN1char16string_free(&(val)->name);
	ASN1char16string_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_Extension(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Extension *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Extension(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extensions(Extensions *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Extension(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Extension(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->critical)
	o[0] &= ~0x80;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->extnId))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->critical))
	    return 0;
    }
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->extnValue).length, ((val)->extnValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->extnId))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->critical))
	    return 0;
    }
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->extnValue))
	return 0;
    if (!((val)->o[0] & 0x80))
	(val)->critical = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extension(Extension *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedAttribute(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedAttribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedAttribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedAttribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedAttribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedRequest(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedRequest *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedRequest(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedRequest(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedRequest(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedContentInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedContentInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedContentInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedContentInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedContentInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedOtherMsg(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TaggedOtherMsg *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TaggedOtherMsg(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedOtherMsg(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedOtherMsg(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncU32(enc, 0x2, ((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (BodyPartID *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val)
{
    if (val) {
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->certificationRequest))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->certificationRequest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->contentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->contentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->otherMsgType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->otherMsgValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->otherMsgType))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->otherMsgValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->pendToken).length, ((val)->pendToken).value))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->pendTime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->pendToken))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->pendTime))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PendInfo(PendInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Dec_Extensions(dd, 0, &(val)->extensions))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->certReferences);
	ASN1Free_Extensions(&(val)->extensions);
    }
}

static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Enc_Attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Dec_Attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->certReferences);
	ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncU32(enc, 0x2, (val)->u.failInfo))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_PendInfo(enc, 0, &(val)->u.pendInfo))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x2:
	(val)->choice = 1;
	if (!ASN1BERDecU32Val(dec, 0x2, (ASN1uint32_t *) &(val)->u.failInfo))
	    return 0;
	break;
    case 0x10:
	(val)->choice = 2;
	if (!ASN1Dec_PendInfo(dec, 0, &(val)->u.pendInfo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_PendInfo(&(val)->u.pendInfo);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Enc_ReqSequence(enc, 0, &(val)->reqSequence))
	return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Dec_ReqSequence(dd, 0, &(val)->reqSequence))
	return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcData(CmcData *val)
{
    if (val) {
	ASN1Free_ControlSequence(&(val)->controlSequence);
	ASN1Free_ReqSequence(&(val)->reqSequence);
	ASN1Free_CmsSequence(&(val)->cmsSequence);
	ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val)
{
    if (val) {
	ASN1Free_ControlSequence(&(val)->controlSequence);
	ASN1Free_CmsSequence(&(val)->cmsSequence);
	ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TaggedCertificationRequest(enc, 0x80000000, &(val)->u.tcr))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_TaggedCertificationRequest(dec, 0x80000000, &(val)->u.tcr))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TaggedCertificationRequest(&(val)->u.tcr);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->cmcStatus))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->bodyList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->statusString).length, ((val)->statusString).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CmcStatusInfo_otherInfo(enc, 0, &(val)->otherInfo))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->cmcStatus))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->bodyList))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0xc) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecUTF8String(dd, 0xc, &(val)->statusString))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2 || t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CmcStatusInfo_otherInfo(dd, 0, &(val)->otherInfo))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->bodyList);
	if ((val)->o[0] & 0x80) {
	    ASN1utf8string_free(&(val)->statusString);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CmcStatusInfo_otherInfo(&(val)->otherInfo);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xmsasn.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _XMSASN_Module_H_
#define _XMSASN_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1bitstring_t BITSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;

typedef ObjectID UsageIdentifier;

typedef ASN1wstring_t UTF8STRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1uint32_t BodyPartID;

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 0
#define SIZE_XMSASN_Module_PDU_0 sizeof(EnhancedKeyUsage)

typedef struct RequestFlags {
    ASN1bool_t fWriteToCSP;
    ASN1bool_t fWriteToDS;
    ASN1int32_t openFlags;
} RequestFlags;
#define RequestFlags_PDU 1
#define SIZE_XMSASN_Module_PDU_1 sizeof(RequestFlags)

typedef struct CSPProvider {
    ASN1int32_t keySpec;
    BMPSTRING cspName;
    BITSTRING signature;
} CSPProvider;
#define CSPProvider_PDU 2
#define SIZE_XMSASN_Module_PDU_2 sizeof(CSPProvider)

typedef struct EnrollmentNameValuePair {
    BMPSTRING name;
    BMPSTRING value;
} EnrollmentNameValuePair;
#define EnrollmentNameValuePair_PDU 3
#define SIZE_XMSASN_Module_PDU_3 sizeof(EnrollmentNameValuePair)

typedef struct Extensions {
    ASN1uint32_t count;
    struct Extension *value;
} Extensions;

typedef struct Extension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID extnId;
#   define critical_present 0x80
    ASN1bool_t critical;
    OCTETSTRING extnValue;
} Extension;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;

typedef struct ControlSequence {
    ASN1uint32_t count;
    struct TaggedAttribute *value;
} ControlSequence;

typedef struct ReqSequence {
    ASN1uint32_t count;
    struct TaggedRequest *value;
} ReqSequence;

typedef struct CmsSequence {
    ASN1uint32_t count;
    struct TaggedContentInfo *value;
} CmsSequence;

typedef struct OtherMsgSequence {
    ASN1uint32_t count;
    struct TaggedOtherMsg *value;
} OtherMsgSequence;

typedef struct BodyPartIDSequence {
    ASN1uint32_t count;
    BodyPartID *value;
} BodyPartIDSequence;

typedef struct TaggedAttribute {
    BodyPartID bodyPartID;
    ObjectID type;
    AttributeSetValue values;
} TaggedAttribute;

typedef struct TaggedCertificationRequest {
    BodyPartID bodyPartID;
    NOCOPYANY certificationRequest;
} TaggedCertificationRequest;

typedef struct TaggedContentInfo {
    BodyPartID bodyPartID;
    NOCOPYANY contentInfo;
} TaggedContentInfo;

typedef struct TaggedOtherMsg {
    BodyPartID bodyPartID;
    ObjectID otherMsgType;
    NOCOPYANY otherMsgValue;
} TaggedOtherMsg;

typedef struct PendInfo {
    OCTETSTRING pendToken;
    ASN1generalizedtime_t pendTime;
} PendInfo;

typedef struct CmcAddExtensions {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Extensions extensions;
} CmcAddExtensions;
#define CmcAddExtensions_PDU 4
#define SIZE_XMSASN_Module_PDU_4 sizeof(CmcAddExtensions)

typedef struct CmcAddAttributes {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Attributes attributes;
} CmcAddAttributes;
#define CmcAddAttributes_PDU 5
#define SIZE_XMSASN_Module_PDU_5 sizeof(CmcAddAttributes)

typedef struct CmcStatusInfo_otherInfo {
    ASN1choice_t choice;
    union {
#	define failInfo_chosen 1
	ASN1uint32_t failInfo;
#	define pendInfo_chosen 2
	PendInfo pendInfo;
    } u;
} CmcStatusInfo_otherInfo;

typedef struct Attribute {
    ObjectID type;
    AttributeSetValue values;
} Attribute;

typedef struct CmcData {
    ControlSequence controlSequence;
    ReqSequence reqSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcData;
#define CmcData_PDU 6
#define SIZE_XMSASN_Module_PDU_6 sizeof(CmcData)

typedef struct CmcResponseBody {
    ControlSequence controlSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcResponseBody;
#define CmcResponseBody_PDU 7
#define SIZE_XMSASN_Module_PDU_7 sizeof(CmcResponseBody)

typedef struct TaggedRequest {
    ASN1choice_t choice;
    union {
#	define tcr_chosen 1
	TaggedCertificationRequest tcr;
    } u;
} TaggedRequest;

typedef struct CmcStatusInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint32_t cmcStatus;
    BodyPartIDSequence bodyList;
#   define statusString_present 0x80
    UTF8STRING statusString;
#   define otherInfo_present 0x40
    CmcStatusInfo_otherInfo otherInfo;
} CmcStatusInfo;
#define CmcStatusInfo_PDU 8
#define SIZE_XMSASN_Module_PDU_8 sizeof(CmcStatusInfo)

extern ASN1bool_t Extension_critical_default;

extern ASN1module_t XMSASN_Module;
extern void ASN1CALL XMSASN_Module_Startup(void);
extern void ASN1CALL XMSASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _XMSASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\thunks.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       thunks.cpp
//
//--------------------------------------------------------------------------

#define _CRYPT32_
#include <windows.h>
#include "unicode.h"
#include "crypthlp.h"

#include <stdlib.h>
#include <assert.h>

typedef PCCERT_CONTEXT
(WINAPI * PFNCertCreateSelfSignCertificate) (
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    );
PFNCertCreateSelfSignCertificate pfnCertCreateSelfSignCertificate = CertCreateSelfSignCertificate;

typedef PCCRYPT_OID_INFO
(WINAPI * PFNCryptFindOIDInfo) (
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    );
PFNCryptFindOIDInfo pfnCryptFindOIDInfo = CryptFindOIDInfo;    

typedef BOOL
(WINAPI * PFNCryptQueryObject) (DWORD            dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext);
PFNCryptQueryObject pfnCryptQueryObject = CryptQueryObject;

typedef BOOL
(WINAPI * PFNCertStrToNameW) (
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pwszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppwszError
    );
PFNCertStrToNameW pfnCertStrToNameW = CertStrToNameW;

typedef BOOL
(WINAPI * PFNCryptVerifyMessageSignature) 
    (IN            PCRYPT_VERIFY_MESSAGE_PARA   pVerifyPara,
     IN            DWORD                        dwSignerIndex,
     IN            BYTE const                  *pbSignedBlob,
     IN            DWORD                        cbSignedBlob,
     OUT           BYTE                        *pbDecoded,
     IN OUT        DWORD                       *pcbDecoded,
     OUT OPTIONAL  PCCERT_CONTEXT              *ppSignerCert);
PFNCryptVerifyMessageSignature pfnCryptVerifyMessageSignature = CryptVerifyMessageSignature;



BOOL
WINAPI
PFXIsPFXBlob(
    CRYPT_DATA_BLOB* pPFX)
{
    
    return FALSE;
}

// Stubs to functions called from oidinfo.cpp
BOOL WINAPI
ChainIsConnected()
{
    return(FALSE);
}

BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
     )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

extern "C" {

BOOL
WINAPI
CertAddEncodedCTLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppCtlContext
    ) {
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

BOOL
WINAPI
CertFreeCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    ) 
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

BOOL 
WINAPI 
CryptSIPLoad(
const GUID *pgSubject, 
DWORD dwFlags, 
void *psSipTable
) 
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

BOOL
WINAPI
CryptSIPRetrieveSubjectGuid(
    IN LPCWSTR FileName, 
    IN OPTIONAL HANDLE hFileIn, 
    OUT GUID *pgSubject) 
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}



}       // end of extern C



// Thunk routines for function not in IE3.02Upd

PCCERT_CONTEXT
WINAPI
MyCertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    ) 
{

    return(pfnCertCreateSelfSignCertificate(
                hProv,          
                pSubjectIssuerBlob,
                dwFlags,
                pKeyProvInfo,
                pSignatureAlgorithm,
                pStartTime,
                pEndTime,
                pExtensions));
}    

PCCRYPT_OID_INFO
WINAPI
xeCryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    )
{
    return(pfnCryptFindOIDInfo(
                dwKeyType,
                pvKey,
                dwGroupId));
}

BOOL
WINAPI
MyCryptQueryObject(DWORD                dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
    return(pfnCryptQueryObject(
                dwObjectType,
                pvObject,
                dwExpectedContentTypeFlags,
                dwExpectedFormatTypeFlags,
                dwFlags,
                pdwMsgAndCertEncodingType,
                pdwContentType,
                pdwFormatType,
                phCertStore,    
                phMsg,
                ppvContext));
}

BOOL
WINAPI
MyCertStrToNameW(
    IN DWORD                dwCertEncodingType,
    IN LPCWSTR              pwszX500,
    IN DWORD                dwStrType,
    IN OPTIONAL void *      pvReserved,
    OUT BYTE *              pbEncoded,
    IN OUT DWORD *          pcbEncoded,
    OUT OPTIONAL LPCWSTR *  ppwszError
    )
{

    return(pfnCertStrToNameW(
                dwCertEncodingType,
                pwszX500,
                dwStrType,
                pvReserved,
                pbEncoded,
                pcbEncoded,
                ppwszError));
}

BOOL
WINAPI
MyCryptVerifyMessageSignature
(IN            PCRYPT_VERIFY_MESSAGE_PARA   pVerifyPara,
 IN            DWORD                        dwSignerIndex,
 IN            BYTE const                  *pbSignedBlob,
 IN            DWORD                        cbSignedBlob,
 OUT           BYTE                        *pbDecoded,
 IN OUT        DWORD                       *pcbDecoded,
 OUT OPTIONAL  PCCERT_CONTEXT              *ppSignerCert)
{
    return pfnCryptVerifyMessageSignature
	(pVerifyPara,
	 dwSignerIndex,
	 pbSignedBlob,
	 cbSignedBlob,
	 pbDecoded,
	 pcbDecoded,
	 ppSignerCert);
}
	
extern "C"
BOOL WINAPI InitIE302UpdThunks(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

HMODULE hModCrypt32 = NULL;
FARPROC fproc;
DWORD   verCrypt32MS;
DWORD   verCrypt32LS;
DWORD   verXEnrollMS;
DWORD   verXEnrollLS;
char    szFileName[_MAX_PATH];
LPWSTR  wszFilePathCrypt32  = NULL;
LPWSTR  wszFilePathXEnroll  = NULL;

    if (dwReason == DLL_PROCESS_ATTACH) {
    
        // this can't fail because it is already loaded
        hModCrypt32 = GetModuleHandleA("Crypt32.dll");
        assert(hModCrypt32);

        // Get Filever of crypt32 and XEnroll, only copy go to crypt32 if it is newer than xenroll
        if( 0 != GetModuleFileNameA(hModCrypt32, szFileName, sizeof(szFileName))  &&
            NULL != (wszFilePathCrypt32 = MkWStr(szFileName))                       &&
            I_CryptGetFileVersion(wszFilePathCrypt32, &verCrypt32MS, &verCrypt32LS) &&
            0 != GetModuleFileNameA(hInstance, szFileName, sizeof(szFileName))    &&
            NULL != (wszFilePathXEnroll = MkWStr(szFileName))                       &&
            I_CryptGetFileVersion(wszFilePathXEnroll, &verXEnrollMS, &verXEnrollLS) &&
            (   (verCrypt32MS > verXEnrollMS)  ||
               ((verCrypt32MS == verXEnrollMS)  &&  verCrypt32LS >= verXEnrollLS) ) ) {
        
            // crypt32 must be newer, use his functions
            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CertCreateSelfSignCertificate")))
                pfnCertCreateSelfSignCertificate = (PFNCertCreateSelfSignCertificate) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CryptFindOIDInfo")))
                pfnCryptFindOIDInfo = (PFNCryptFindOIDInfo) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CryptQueryObject")))
                pfnCryptQueryObject = (PFNCryptQueryObject) fproc;

            if(NULL != (fproc = GetProcAddress(hModCrypt32, "CertStrToNameW")))
                pfnCertStrToNameW = (PFNCertStrToNameW) fproc;
	    
	    if(NULL != (fproc = GetProcAddress(hModCrypt32, "CryptVerifyMessageSignature")))
		pfnCryptVerifyMessageSignature = (PFNCryptVerifyMessageSignature) fproc; 
        }
        
        // free allocated handles
        if(wszFilePathCrypt32 != NULL)
            FreeWStr(wszFilePathCrypt32);
            
        if(wszFilePathXEnroll != NULL)
            FreeWStr(wszFilePathXEnroll);
    } 
    

return(TRUE);
}


BOOL
MyCryptStringToBinaryA(
    IN     LPCSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    )
{
    return CryptStringToBinaryA(
                pszString,
                cchString,
                dwFlags,
                pbBinary,
                pcbBinary,
                pdwSkip,
                pdwFlags);
}

BOOL
MyCryptStringToBinaryW(
    IN     LPCWSTR  pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN     BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    //OPTIONAL
    OUT    DWORD    *pdwFlags    //OPTIONAL
    )
{
    return CryptStringToBinaryW(
                pszString,
                cchString,
                dwFlags,
                pbBinary,
                pcbBinary,
                pdwSkip,
                pdwFlags);
}

BOOL
MyCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPSTR      pszString,
    IN OUT DWORD       *pcchString
    )
{
    return CryptBinaryToStringA(
                pbBinary,
                cbBinary,
                dwFlags,
                pszString,
                pcchString);
}

BOOL
MyCryptBinaryToStringW(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPWSTR      pszString,
    IN OUT DWORD       *pcchString
    )
{
    return CryptBinaryToStringW(
                pbBinary,
                cbBinary,
                dwFlags,
                pszString,
                pcchString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\activex\xenroll\xasnx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:           attrbute.cpp
//
//  Contents:   
//              Encode/Decode APIs
//
//              ASN.1 implementation uses the OSS compiler.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//
//  History:    29-Feb-96       philh   created
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>
#include <malloc.h>

#include "xenroll.h"
#include "cenroll.h"

#include "ossconv.h"      
#include "ossutil.h"
#include "asn1util.h"
#include "crypttls.h"


extern "C" 
{              
#include "xasn.h"
}  


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)


HCRYPTOSSGLOBAL hX509OssGlobal;


//+-------------------------------------------------------------------------
//  Function:  GetPog
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized OssGlobal data structure
//--------------------------------------------------------------------------
static inline POssGlobal GetPog(void)
{
    return I_CryptGetOssGlobal(hX509OssGlobal);
}


//+-------------------------------------------------------------------------
//  Cert allocation and free functions
//--------------------------------------------------------------------------
static void *CertAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void CertFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the OssX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoEncode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        GetPog(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    return OssUtilDecodeAndAllocInfo(
        GetPog(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static void OssInfoFree(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        OssUtilFreeInfo(GetPog(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 ASN.1 Set / Get functions
//
//  Called by the OSS X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL OssX509SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (OssConvToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void OssX509GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    OssConvFromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

static BOOL WINAPI OssX509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
	    IN OUT DWORD *pcbEncoded
	);

static BOOL WINAPI OssX509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
	);

static BOOL WINAPI OssRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI OssRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
        
static BOOL WINAPI OssCSPProviderEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static BOOL WINAPI OssNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

static const CRYPT_OID_FUNC_ENTRY X509EncodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, OssX509CtlUsageEncode,
    XENROLL_REQUEST_INFO,    OssRequestInfoEncode,
    szOID_ENROLLMENT_CSP_PROVIDER,  OssCSPProviderEncode,
    szOID_ENROLLMENT_NAME_VALUE_PAIR, OssNameValueEncode,
};

#define X509_ENCODE_FUNC_COUNT (sizeof(X509EncodeFuncTable) / \
                                    sizeof(X509EncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeFuncTable[] = {
    X509_ENHANCED_KEY_USAGE, OssX509CtlUsageDecode,
    XENROLL_REQUEST_INFO,    OssRequestInfoDecode
};

#define X509_DECODE_FUNC_COUNT (sizeof(X509DecodeFuncTable) / \
                                    sizeof(X509DecodeFuncTable[0]))

extern BOOL OssLoad();
extern void OssUnload();

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL AsnInit(
        HMODULE hInst)
{
    BOOL    fRet;

	if (0 == (hX509OssGlobal = I_CryptInstallOssGlobal(xasn, 0, NULL)))
            goto Error;

    if (!OssLoad())
        goto Error;

        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                X509_ENCODE_FUNC_COUNT,
                X509EncodeFuncTable,
                0))                         // dwFlags
            goto Error;
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                X509_DECODE_FUNC_COUNT,
                X509DecodeFuncTable,
                0))                         // dwFlags
            goto Error;


    return TRUE;

Error:
    return FALSE;
}

typedef BOOL (WINAPI *PFN_CRYPT_UNINSTALL_OSS_GLOBAL)(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

void AsnTerm()
{
    HMODULE hDll = NULL;

    OssUnload();

    if (hDll = GetModuleHandleA("crypt32.dll")) {
        PFN_CRYPT_UNINSTALL_OSS_GLOBAL pfnCryptUninstallOssGlobal;
        if (pfnCryptUninstallOssGlobal =
                (PFN_CRYPT_UNINSTALL_OSS_GLOBAL) GetProcAddress(
                    hDll, "I_CryptUninstallOssGlobal"))
            pfnCryptUninstallOssGlobal(hX509OssGlobal);
    }
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 ASN.1 Set / Get functions
//
//  Called by the OSS X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
static BOOL OssX509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pOss
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pOssId;

    pOss->count = 0;
    pOss->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pOssId = (UsageIdentifier *) CertAlloc(cId * sizeof(UsageIdentifier));
    if (pOssId == NULL)
        return FALSE;

    pOss->count = cId;
    pOss->value = pOssId;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pOssId++) {
        if (!OssX509SetObjId(*ppszId, pOssId))
            return FALSE;
    }

    return TRUE;
}

static void OssX509FreeCtlUsage(
        IN EnhancedKeyUsage *pOss)
{
    if (pOss->value) {
        CertFree(pOss->value);
        pOss->value = NULL;
    }
}

static void OssX509GetCtlUsage(
        IN EnhancedKeyUsage *pOss,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pOssId;
    LPSTR *ppszId;

    cId = pOss->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pOssId = pOss->value;
    for ( ; cId > 0; cId--, pOssId++, ppszId++)
        OssX509GetObjId(pOssId, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (OSS X509)
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage OssInfo;

    if (!OssX509SetCtlUsage(pInfo, &OssInfo)) {
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = OssInfoEncode(
            EnhancedKeyUsage_PDU,
            &OssInfo,
            pbEncoded,
            pcbEncoded
            );
    OssX509FreeCtlUsage(&OssInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (OSS X509)
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EnhancedKeyUsage *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!OssInfoDecodeAndAlloc(
            EnhancedKeyUsage_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    OssX509GetCtlUsage(pOssInfo, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    OssInfoFree(EnhancedKeyUsage_PDU, pOssInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Request Info Encode
//--------------------------------------------------------------------------
static BOOL WINAPI OssRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN RequestFlags *  pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    fResult = OssInfoEncode(
	        RequestFlags_PDU,
	        pInfo,
            pbEncoded,
            pcbEncoded
            );
            
    return fResult;
}



//+-------------------------------------------------------------------------
//  Request Info Decode
//--------------------------------------------------------------------------
static BOOL WINAPI OssRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
	    OUT RequestFlags * pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    RequestFlags *  pOss = NULL;

    if (NULL == pInfo || NULL == pcbInfo)
        goto ParamError;

    if(*pcbInfo < sizeof(RequestFlags))
	    goto LengthError;

    else if (!OssInfoDecodeAndAlloc(
	    RequestFlags_PDU,
        pbEncoded,
        cbEncoded,
	    (void **) &pOss) || NULL == pOss)
        goto ErrorReturn;

    memcpy(pInfo, pOss, sizeof(RequestFlags));
    fResult = TRUE;
    goto CommonReturn;

ParamError:
    SetLastError((DWORD)ERROR_INVALID_PARAMETER);
    fResult = FALSE;
    goto CommonReturn;
LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    if (NULL != pOss)
    {
        OssInfoFree(RequestFlags_PDU, pOss);
    }
    return fResult;
}

static BOOL WINAPI OssCSPProviderEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
	    IN PCRYPT_CSP_PROVIDER pCSPProvider,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;

    OssUtilSetBitString(&pCSPProvider->Signature, &CspProvider.signature.length, &CspProvider.signature.value);

    fResult = OssInfoEncode(
	        CSPProvider_PDU,
	        &CspProvider,
            pbEncoded,
            pcbEncoded
            );
 
    return fResult;
}

static BOOL WINAPI OssNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;
    
    NameValue.value.length = wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;

    fResult = OssInfoEncode(
	        EnrollmentNameValuePair_PDU,
	        &NameValue,
            pbEncoded,
            pcbEncoded
            );
 
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certexts\certextp.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    certextp.h

Abstract:

    Common header file for NTSDEXTS component source files.
    Modified version of ntsdextp.h

Author:

    Steve Wood (stevewo) 21-Feb-1995 (original ntsdextp.h)
    Phil Hallin (philh)  08-Jun-1998 (modified for certextp.h)

Revision History:

--*/

#include <windows.h>
//#include <ntsdexts.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#define move(dst, src)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}


#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PWINDBG_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
//#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG)(ULONG_PTR)(a), (b), (c), (d) ))

//#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )
#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG)(a), (LPVOID)(b), (c), (d) ))

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\certexts\certexts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       certexts.cpp
//
//  Contents:   NTSD/WINDBG certificate extensions dll
//
//              See DECLARE_API( help ) for a list of extensions
//
//
//  Functions:  help
//              store
//              context
//              ele
//              cert
//              crl
//              ctl
//              chain
//
//  History:    06-Jun-98   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_HASH_LEN  20
#define SHA1_HASH_LEN 20

#define MAX_PROP_CNT            100
#define MAX_CONTEXT_CNT         1000
#define MAX_STORE_SIBLING_CNT   100
#define MAX_STORE_NEST_CNT      100

#define MAX_SIMPLE_CHAIN_CNT    50
#define MAX_CHAIN_ELEMENT_CNT   50


WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

// Display flags
#define DISPLAY_SHORT_FLAG          0x00000001
#define DISPLAY_VERBOSE_FLAG        0x00000002
#define DISPLAY_UI_FLAG             0x00000004
#define DISPLAY_EXT_FLAG            0x00000008
#define DISPLAY_PROP_FLAG           0x00000010

// ATTENTION: the following were lifted from newstor.cpp. Should be moved
// to a shared .h file

//+-------------------------------------------------------------------------
//  Store data structure definitions
//--------------------------------------------------------------------------

// Assumes
//  0 - Certificates
//  1 - CRLs
//  2 - CTLs
#define CONTEXT_COUNT       3

typedef struct _CONTEXT_ELEMENT CONTEXT_ELEMENT, *PCONTEXT_ELEMENT;
typedef struct _PROP_ELEMENT PROP_ELEMENT, *PPROP_ELEMENT;

typedef struct _CERT_STORE CERT_STORE, *PCERT_STORE;
typedef struct _CERT_STORE_LINK CERT_STORE_LINK, *PCERT_STORE_LINK;

typedef struct _COLLECTION_STACK_ENTRY COLLECTION_STACK_ENTRY,
    *PCOLLECTION_STACK_ENTRY;

// Used to maintain collection state across context find next calls.
//
// Ref count on pStoreLink. No ref count on pCollection.
// pStoreLink may be NULL.
struct _COLLECTION_STACK_ENTRY {
    PCERT_STORE                 pCollection;
    PCERT_STORE_LINK            pStoreLink;
    PCOLLECTION_STACK_ENTRY     pPrev;
};

typedef struct _CONTEXT_CACHE_INFO {
    PPROP_ELEMENT               pPropHead;
} CONTEXT_CACHE_INFO;

typedef struct _CONTEXT_EXTERNAL_INFO {
    // For ELEMENT_FIND_NEXT_FLAG
    void                        *pvProvInfo;
} CONTEXT_EXTERNAL_INFO;

typedef struct _CONTEXT_COLLECTION_INFO {
    // For Find
    PCOLLECTION_STACK_ENTRY     pCollectionStack;
} CONTEXT_COLLECTION_INFO;

#define ELEMENT_DELETED_FLAG                    0x00010000

// Only set for external elements
#define ELEMENT_FIND_NEXT_FLAG                  0x00020000

// Set during CertCloseStore if ELEMENT_FIND_NEXT_FLAG was set.
#define ELEMENT_CLOSE_FIND_NEXT_FLAG            0x00040000

// Set if the element has a CERT_ARCHIVED_PROP_ID
#define ELEMENT_ARCHIVED_FLAG                   0x00080000

#define ELEMENT_TYPE_CACHE                      1
#define ELEMENT_TYPE_LINK_CONTEXT               2
#define ELEMENT_TYPE_EXTERNAL                   3
#define ELEMENT_TYPE_COLLECTION                 4

typedef struct _CONTEXT_NOCOPY_INFO {
    PFN_CRYPT_FREE      pfnFree;
    void                *pvFree;
} CONTEXT_NOCOPY_INFO, *PCONTEXT_NOCOPY_INFO;

// Identical contexts (having the same SHA1 hash) can share the same encoded
// byte array and decoded info data structure.
//
// CreateShareElement() creates with dwRefCnt of 1. FindShareElement() finds
// an existing and increments dwRefCnt. ReleaseShareElement() decrements
// dwRefCnt and frees when 0.
typedef struct _SHARE_ELEMENT SHARE_ELEMENT, *PSHARE_ELEMENT;
struct _SHARE_ELEMENT {
    BYTE                rgbSha1Hash[SHA1_HASH_LEN];
    DWORD               dwContextType;
    BYTE                *pbEncoded;         // allocated
    DWORD               cbEncoded;
    void                *pvInfo;            // allocated

    DWORD               dwRefCnt;
    PSHARE_ELEMENT      pNext;
    PSHARE_ELEMENT      pPrev;
};

// The CONTEXT_ELEMENT is inserted before the CERT_CONTEXT, CRL_CONTEXT or
// CTL_CONTEXT. The dwContextType used is 0 based and not 1 based. For
// example, dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1.
struct _CONTEXT_ELEMENT {
    DWORD               dwElementType;
    DWORD               dwContextType;
    DWORD               dwFlags;
    LONG                lRefCnt;

    // For ELEMENT_TYPE_CACHE, pEle points to itself. Otherwise, pEle points
    // to the element being linked to and the pEle is addRef'ed. The
    // cached element is found by iterating through the pEle's until pEle
    // points to itself.
    PCONTEXT_ELEMENT    pEle;
    PCERT_STORE         pStore;
    PCONTEXT_ELEMENT    pNext;
    PCONTEXT_ELEMENT    pPrev;
    PCERT_STORE         pProvStore;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // When nonNULL, the context's pbEncoded and pInfo aren't allocated.
    // Instead, use the shared element's pbEncoded and pInfo. When
    // context element is freed, the pSharedEle is ReleaseShareElement()'ed.
    PSHARE_ELEMENT      pShareEle;          // RefCnt'ed

    union {
        CONTEXT_CACHE_INFO      Cache;      // ELEMENT_TYPE_CACHE
        CONTEXT_EXTERNAL_INFO   External;   // ELEMENT_TYPE_EXTERNAL
        CONTEXT_COLLECTION_INFO Collection; // ELEMENT_TYPE_COLLECTION
    };
};


struct _PROP_ELEMENT {
    DWORD               dwPropId;
    DWORD               dwFlags;
    BYTE                *pbData;
    DWORD               cbData;
    PPROP_ELEMENT       pNext;
    PPROP_ELEMENT       pPrev;
};


#define STORE_LINK_DELETED_FLAG        0x00010000
struct _CERT_STORE_LINK {
    DWORD               dwFlags;
    LONG                lRefCnt;

    // Whatever is passed to CertAddStoreToCollection
    DWORD               dwUpdateFlags;
    DWORD               dwPriority;

    PCERT_STORE         pCollection;
    PCERT_STORE         pSibling;       // CertStoreDuplicate'd.
    PCERT_STORE_LINK    pNext;
    PCERT_STORE_LINK    pPrev;
};


// Store types
#define STORE_TYPE_CACHE            1
#define STORE_TYPE_EXTERNAL         2
#define STORE_TYPE_COLLECTION       3

// CACHE store may have CACHE or LINK_CONTEXT elements. Until deleted,
// the store has a reference count to.

// EXTERNAL store only has EXTERNAL elements. These elements are always
// deleted, wherein, the store doesn't hold a refCnt.

// COLLECTION store has COLLECTION elements. These elements
// are always deleted, wherein, the store doesn't hold a refCnt.


struct _CERT_STORE {
    DWORD               dwStoreType;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;
    DWORD               dwFlags;
    DWORD               dwState;
    CRITICAL_SECTION    CriticalSection;
    PCONTEXT_ELEMENT    rgpContextListHead[CONTEXT_COUNT];
    PCERT_STORE_LINK    pStoreListHead;                     // COLLECTION
    PPROP_ELEMENT       pPropHead;      // properties for entire store

    // For CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
    // Incremented for each context duplicated
    LONG                lDeferCloseRefCnt;

    // Event handle set by CertControlStore(CERT_STORE_CTRL_AUTO_RESYNC)
    HANDLE              hAutoResyncEvent;

    // Store provider info
    LONG                lStoreProvRefCnt;
    HANDLE              hStoreProvWait;
    HCRYPTOIDFUNCADDR   hStoreProvFuncAddr;
    CERT_STORE_PROV_INFO StoreProvInfo;
};

//+-------------------------------------------------------------------------
//  Store states
//--------------------------------------------------------------------------
#define STORE_STATE_DELETED         0
#define STORE_STATE_NULL            1
#define STORE_STATE_OPENING         2
#define STORE_STATE_OPEN            3
#define STORE_STATE_DEFER_CLOSING   4
#define STORE_STATE_CLOSING         5
#define STORE_STATE_CLOSED          6

inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCertContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

inline PCCERT_CONTEXT ToCertContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCERT_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}


DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("certexts help:\n\n");
        dprintf("!context {[s|v|u|x|p]} address - Dump cert, CRL or CTL context\n");
        dprintf("!ele {[s|v|u|x|p]} address     - Dump cert, CRL or CTL element\n");
        dprintf("!cert {[s|v|u|x|p]} address    - Dump encoded cert\n");
        dprintf("!crl {[s|v|u|x|p]} address     - Dump encoded crl\n");
        dprintf("!ctl {[s|v|u|x|p]} address     - Dump encoded ctl\n");
        dprintf("!store {[s|v|x|p]} address     - Dump certificate store\n");
        dprintf("!chain {[s|v|x|p]} address     - Dump certificate chain context\n");
        dprintf("!help [cmd]                    - Displays this list or gives details on command\n");
        dprintf("\n");
        dprintf("Options:\n");
        dprintf(" s - Short, brief display\n");
        dprintf(" v - Verbose display\n");
        dprintf(" u - UI display\n");
        dprintf(" x - Display eXtensions\n");
        dprintf(" p - Display Properties\n");
    } else {
        if (*lpArgumentString == '!')
            lpArgumentString++;
        if (strcmp(lpArgumentString, "xyz") == 0) {
            dprintf("!xyz      - Invalid command\n");
        } else {
            dprintf("Invalid command and/or no help available\n");
        }
    }
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintError(LPCSTR pszMsg)
{
    dprintf("%s\n", pszMsg);
}
void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    dprintf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  CertExts allocation and free routines
//--------------------------------------------------------------------------
LPVOID
WINAPI
CertExtsAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("CertExtsAlloc");
    }
    return pv;
}

LPVOID
WINAPI
CertExtsRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("CertExtsRealloc");
    }
    return pv;
}

VOID
WINAPI
CertExtsFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL)pv);
}

LPCSTR FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;

        if (st.wMilliseconds) {
            char *pch = buf + strlen(buf);
            sprintf(pch, " <milliseconds:: %03d>", st.wMilliseconds);
        }
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#define CROW 16
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) {
        dprintf("%s NO Value Bytes\n", pszHdr);
        return;
    }

    while (cbSize > 0)
    {
        dprintf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            dprintf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            dprintf("   ");
        dprintf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                dprintf("%c", pb[i]);
            else
                dprintf(".");
        pb += cb;
        dprintf("'\n");
    }
}


BOOL GetEncodedBlob(
    IN LPVOID pvAddr,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE rgbTagLength[6];
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded = 0;

    LONG lLen;
    DWORD cbLen;
    DWORD cbContent;
    const BYTE *pbContent;

    __try {
        memset(rgbTagLength, 0, sizeof(rgbTagLength));
        ReadMemory(pvAddr, rgbTagLength, sizeof(rgbTagLength), NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read encoded blob at 0x%p\n", pvAddr);
        goto ErrorReturn;
    }

    lLen = Asn1UtilExtractContent(rgbTagLength, sizeof(rgbTagLength),
        &cbContent, &pbContent);
    if (lLen <= 0 || cbContent == CMSG_INDEFINITE_LENGTH) {
        dprintf("Unable to decode ASN1 tag/length at 0x%p\n", pvAddr);
        goto ErrorReturn;
    }

    cbEncoded = (DWORD)lLen + cbContent;
    if (NULL == (pbEncoded = (BYTE *) CertExtsAlloc(cbEncoded)))
        goto ErrorReturn;

    __try {
        memset(pbEncoded, 0, cbEncoded);
        ReadMemory(pvAddr, pbEncoded, cbEncoded, NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dprintf("Unable to read encoded blob at 0x%p .. 0x%p\n", pvAddr,
            ((BYTE *) pvAddr) + cbEncoded - 1);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    CertExtsFree(pbEncoded);
    pbEncoded = NULL;
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

void DisplaySerialNumber(
    PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    DWORD cb;
    BYTE *pb;
    for (cb = pSerialNumber->cbData,
         pb = pSerialNumber->pbData + (cb - 1); cb > 0; cb--, pb--) {
        dprintf(" %02X", *pb);
    }
    dprintf("\n");
}

void DisplayThumbprint(
    LPCSTR pszHash,
    BYTE *pbHash,
    DWORD cbHash
    )
{
    dprintf("%s Thumbprint:: ", pszHash);
    if (cbHash == 0)
        dprintf("???");
    else {
        ULONG cb;

        while (cbHash > 0) {
            cb = min(4, cbHash);
            cbHash -= cb;
            for (; cb > 0; cb--, pbHash++)
                dprintf("%02X", *pbHash);
            dprintf(" ");
        }
    }
    dprintf("\n");
}

void DisplayName(
    IN PCERT_NAME_BLOB pName
    )
{
    DWORD csz;
    LPSTR psz;

    csz = CertNameToStrA(
        X509_ASN_ENCODING,
        pName,
        CERT_X500_NAME_STR + CERT_NAME_STR_REVERSE_FLAG,
        NULL,                   // psz
        0);                     // csz
    if (psz = (LPSTR) CertExtsAlloc(csz)) {
        CertNameToStrA(
            X509_ASN_ENCODING,
            pName,
            CERT_X500_NAME_STR + CERT_NAME_STR_REVERSE_FLAG,
            psz,
            csz);
        dprintf("  %s\n", psz);
        CertExtsFree(psz);
    } else
        dprintf("  ???\n");
}

//+-------------------------------------------------------------------------
//  Returns OID's name string. If not found returns L"???".
//--------------------------------------------------------------------------
LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            )) {
        if (L'\0' != pInfo->pwszName[0])
            return pInfo->pwszName;
    }

    return L"???";
}

ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            ))
        return pInfo->Algid;
    return 0;
}

void PrintExtensions(
    IN DWORD cExt,
    IN PCERT_EXTENSION pExt,
    IN DWORD dwDisplayFlags
    )
{
    DWORD i;

    if (0 == (dwDisplayFlags & (DISPLAY_VERBOSE_FLAG | DISPLAY_EXT_FLAG)))
        return;

    for (i = 0; i < cExt; i++, pExt++) {
        DWORD cbFormat;

        LPSTR pszObjId = pExt->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        LPSTR pszCritical = pExt->fCritical ? "TRUE" : "FALSE";
        dprintf("Extension[%d] %s (%S) Critical: %s::\n",
            i, pszObjId, GetOIDName(pszObjId), pszCritical);
        PrintBytes("    ", pExt->Value.pbData, pExt->Value.cbData);

        cbFormat = 0;
        if (CryptFormatObject(
                X509_ASN_ENCODING,
                0,                  // dwFormatType
                CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
                NULL,               // pFormatStruct,
                pszObjId,
                pExt->Value.pbData,
                pExt->Value.cbData,
                NULL,
                &cbFormat
                ) && cbFormat) {
            BYTE *pbFormat = NULL;
            if (pbFormat = (BYTE *) CertExtsAlloc(cbFormat)) {
                if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,                  // dwFormatType
                        CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
                        NULL,               // pFormatStruct,
                        pszObjId,
                        pExt->Value.pbData,
                        pExt->Value.cbData,
                        pbFormat,
                        &cbFormat
                        )) {
                    dprintf("--- Decoded ---\n");
                    dprintf("%S\n", pbFormat);
                }

                CertExtsFree(pbFormat);
            }
        }
    }
}

typedef struct _PROP_INFO {
    DWORD       dwPropId;
    LPCSTR      pszPropName;
} PROP_INFO, *PPROP_INFO;

const PROP_INFO rgPropInfo[] = {
    CERT_KEY_PROV_HANDLE_PROP_ID, "KeyProvHandle",
    CERT_KEY_PROV_INFO_PROP_ID, "KeyProvInfo",
    CERT_SHA1_HASH_PROP_ID, "Sha1Hash",
    CERT_MD5_HASH_PROP_ID, "MD5Hash",
    CERT_KEY_CONTEXT_PROP_ID, "KeyContext",
    CERT_KEY_SPEC_PROP_ID, "KeySpec",
    CERT_IE30_RESERVED_PROP_ID, "IE30Reserved",
    CERT_PUBKEY_HASH_RESERVED_PROP_ID, "PubKeyHashReserved",
    CERT_ENHKEY_USAGE_PROP_ID, "EnhKeyUsage",
    CERT_NEXT_UPDATE_LOCATION_PROP_ID, "NextUpdateLocation",
    CERT_FRIENDLY_NAME_PROP_ID, "FriendlyName",
    CERT_PVK_FILE_PROP_ID, "PvkFile",
    CERT_DESCRIPTION_PROP_ID, "Description",
    CERT_ACCESS_STATE_PROP_ID, "AccessState",
    CERT_SIGNATURE_HASH_PROP_ID, "SignatureHash",
    CERT_SMART_CARD_DATA_PROP_ID, "SmartCartData",
    CERT_EFS_PROP_ID, "EFS",
    CERT_FORTEZZA_DATA_PROP_ID, "FortezzaData",
    CERT_ARCHIVED_PROP_ID, "Archived",
    CERT_KEY_IDENTIFIER_PROP_ID, "KeyIdentifier",
    CERT_AUTO_ENROLL_PROP_ID, "AutoEnroll",
    CERT_STORE_LOCALIZED_NAME_PROP_ID, "LocalizedName",
    0, "???"
};

LPCSTR GetPropName(
    IN DWORD dwPropId
    )
{
    const PROP_INFO *pInfo;

    for (pInfo = rgPropInfo; pInfo->dwPropId; pInfo++) {
        if (dwPropId == pInfo->dwPropId)
            return pInfo->pszPropName;
    }

    return "???";
}

void PrintProperties(
    IN PPROP_ELEMENT pProp,
    IN DWORD dwDisplayFlags
    )
{
    DWORD i;

    if (0 == (dwDisplayFlags & (DISPLAY_VERBOSE_FLAG | DISPLAY_PROP_FLAG)))
        return;

    i = 0;
    while (pProp) {
        PROP_ELEMENT Prop;

        __try {
            memset(&Prop, 0, sizeof(Prop));
            ReadMemory((LPVOID) pProp, &Prop, sizeof(Prop), NULL);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dprintf("Unable to read Property Element at 0x%p\n", pProp);
            goto ErrorReturn;
        }

        dprintf("PropId %ld (0x%lx) %s ::\n", Prop.dwPropId, Prop.dwPropId,
            GetPropName(Prop.dwPropId));
        if (Prop.dwFlags)
            dprintf("     Property dwFlags: 0x%lx\n", Prop.dwFlags);

        if (Prop.cbData) {
            BYTE *pbData;

            if (pbData = (BYTE *) CertExtsAlloc(Prop.cbData)) {
                __try {
                    memset(pbData, 0, Prop.cbData);
                    ReadMemory((LPVOID) Prop.pbData, pbData, Prop.cbData, NULL);
                    PrintBytes("    ", pbData, Prop.cbData);
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    dprintf("Unable to read Property at 0x%p .. 0x%p\n",
                        Prop.pbData, Prop.pbData + Prop.cbData - 1);
                }

                CertExtsFree(pbData);
            }
        } else
            dprintf("     NO Property Bytes\n");

        pProp = Prop.pNext;
        if (i++ > MAX_PROP_CNT) {
            dprintf("Exceeded maximum prop count of %d\n", MAX_PROP_CNT);
            break;
        }
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
}

void DisplayCert(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwDisplayFlags
    )
{
    dprintf("Version:: %d\n", pCert->pCertInfo->dwVersion);
    dprintf("Subject::");
    DisplayName(&pCert->pCertInfo->Subject);
    dprintf("Issuer::");
    DisplayName(&pCert->pCertInfo->Issuer);
    dprintf("SerialNumber::");
    DisplaySerialNumber(&pCert->pCertInfo->SerialNumber);
    dprintf("NotBefore:: %s\n", FileTimeText(&pCert->pCertInfo->NotBefore));
    dprintf("NotAfter:: %s\n", FileTimeText(&pCert->pCertInfo->NotAfter));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;

        CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;
        ALG_ID aiPubKey;
        DWORD dwBitLen;

        pszObjId = pCert->pCertInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        dprintf("SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData) {
            dprintf("SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SignatureAlgorithm.Parameters.pbData,
                pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData);
        }

        pszObjId = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        dprintf("SubjectPublicKeyInfo.Algorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID));
        aiPubKey = GetAlgid(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData)
        {
            dprintf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
        }
        dprintf("SubjectPublicKeyInfo.PublicKey");
        if (0 != (dwBitLen = CertGetPublicKeyLength(
                X509_ASN_ENCODING,
                &pCert->pCertInfo->SubjectPublicKeyInfo)))
            dprintf(" (BitLength: %d)", dwBitLen);
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
            dprintf(" (UnusedBits: %d)",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
        dprintf("::\n");
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
            PrintBytes("    ",
     