eof (m_AppInfo));
	TCHAR *pszName;

	if (::IsValidGuid (&(pInfo->guid)))
	{
		m_AppInfo.apszStdAttrValues[ENUM_APPATTR_GUID] = &m_AppInfo.szGuid[0];
		::GetGuidString (&(pInfo->guid), &m_AppInfo.szGuid[0]);
		m_AppInfo.dwFlags |= APPOBJ_F_GUID;
	}

	if (pInfo->uOffsetName != 0)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetName);
		m_AppInfo.apszStdAttrValues[ENUM_APPATTR_NAME] = pszName;
		m_AppInfo.dwFlags |= APPOBJ_F_NAME;
	}

	if (pInfo->uOffsetMimeType != 0)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetMimeType);
		m_AppInfo.apszStdAttrValues[ENUM_APPATTR_MIME_TYPE] = pszName;
		m_AppInfo.dwFlags |= APPOBJ_F_MIME_TYPE;
	}

	return S_OK;
}


HRESULT UlsLdap_CLocalApp::CreateRegisterModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	ULONG cPrefix = m_cPrefix - 1; // skip its own app id
	TCHAR *pszPrefix = m_pszPrefix;

	ULONG cAttrs = COUNT_ENUM_APPATTR;
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = LDAP_MOD_ADD;
			ULONG AttrIdx = i - cPrefix;
			pMod->mod_type = (TCHAR *) c_apszAppStdAttrNames[AttrIdx];
			*(pMod->mod_values) = (m_AppInfo.apszStdAttrValues[AttrIdx] != NULL) ?
									m_AppInfo.apszStdAttrValues[AttrIdx] :
									(TCHAR *) &c_szEmptyString[0];
		}
	}

	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_ADD, ISBU_MODOP_ADD_APP);
	(*pppMod)[cTotal] = NULL;
	return S_OK;
}


HRESULT UlsLdap_CLocalApp::CreateUnRegisterModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	ULONG cPrefix = m_cPrefix; // do NOT skip its own app id
	TCHAR *pszPrefix = m_pszPrefix;

	ULONG cAttrs = COUNT_ENUM_APPATTR;
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			pMod->mod_values = (TCHAR **) (pMod + 1);
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = LDAP_MOD_DELETE;
			pMod->mod_type = (TCHAR *) c_apszAppStdAttrNames[i - cPrefix];
		}
	}

	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_DELETE, ISBU_MODOP_DELETE_APP);
	(*pppMod)[cTotal] = NULL;
	return S_OK;
}


HRESULT UlsLdap_CLocalApp::CreateSetStdAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	ULONG cTotal = 0;
	hr = ::FillDefStdAttrsModArr (	pppMod,
									m_AppInfo.dwFlags,
									COUNT_ENUM_APPATTR,
									&cTotal,
									ISBU_MODOP_MODIFY_APP,
									m_cPrefix,
									m_pszPrefix);
	if (hr != S_OK)
		return hr;

	// start indexing
	ULONG i = m_cPrefix;

	if (m_AppInfo.dwFlags & APPOBJ_F_GUID)
		FillModArrAttr ((*pppMod)[i++], ENUM_APPATTR_GUID);

	if (m_AppInfo.dwFlags & APPOBJ_F_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_APPATTR_NAME);

	if (m_AppInfo.dwFlags & APPOBJ_F_MIME_TYPE)
		FillModArrAttr ((*pppMod)[i++], ENUM_APPATTR_MIME_TYPE);

	MyAssert (i == cTotal);
	return S_OK;
}


VOID UlsLdap_CLocalApp::FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx )
{
	pMod->mod_type = (TCHAR *) c_apszAppStdAttrNames[AttrIdx];

	// single valued attr
	TCHAR **ppsz = (TCHAR **) (pMod + 1);
	pMod->mod_values = ppsz;
	*(pMod->mod_values) = (m_AppInfo.apszStdAttrValues[AttrIdx] != NULL) ?
				m_AppInfo.apszStdAttrValues[AttrIdx] :
				(TCHAR *) &c_szEmptyString[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\splapp.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splapp.h
	Content:	This file contains the local application object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_APPOBJ_H_
#define _ULS_SP_APPOBJ_H_

#include <pshpack8.h>

enum
{
	ENUM_APPATTR_NAME,
	ENUM_APPATTR_MIME_TYPE,
	ENUM_APPATTR_GUID,

	ENUM_APPATTR_PROT_NAME,
	ENUM_APPATTR_PROT_MIME,
	ENUM_APPATTR_PROT_PORT,

	COUNT_ENUM_APPATTR
};

#define COUNT_ENUM_STDAPPATTR	ENUM_APPATTR_PROT_NAME

#define APPOBJ_F_NAME		0x0001
#define APPOBJ_F_MIME_TYPE	0x0002
#define APPOBJ_F_GUID		0x0004


extern const TCHAR *c_apszAppStdAttrNames[COUNT_ENUM_APPATTR];

#define STR_APP_NAME	((TCHAR *) c_apszAppStdAttrNames[ENUM_APPATTR_NAME])


typedef struct
{
	DWORD	dwFlags;
	TCHAR	*apszStdAttrValues[COUNT_ENUM_APPATTR];
	TCHAR	szGuid[sizeof (GUID) * 2 + 2];
}
	APP_INFO;


#define APPOBJ_SIGNATURE	((ULONG) 0x56781234UL)


class UlsLdap_CLocalApp : public UlsLdap_CStdAttrs, public UlsLdap_CAnyAttrs
{
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CLocalApp ( UlsLdap_CLocalUser *pUser );
	~UlsLdap_CLocalApp ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG *puRespID, LDAP_APPINFO *pInfo );
	HRESULT UnRegister ( ULONG *puRespID );

	HRESULT SetStdAttrs ( ULONG *puRespID, LDAP_APPINFO *pInfo );
	HRESULT SetAnyAttrs ( ULONG *puRespID, ULONG cAttrs, TCHAR *pszAttrs );
	HRESULT RemoveAnyAttrs ( ULONG *puRespID, ULONG cAttrs, TCHAR *pszAttrs );

	VOID SetRegNone ( VOID ) { m_RegStatus = ULS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ULS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ULS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ULS_REG_STATUS_NONE &&
									 		m_pUser->IsRegistered ()); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_LOCALLY &&
											m_pUser->IsRegistered ()); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_REMOTELY &&
											m_pUser->IsRegRemotely ()); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == APPOBJ_SIGNATURE; }

protected:

	TCHAR *GetDN ( VOID ) { return m_pUser->GetDN (); }
	SERVER_INFO *GetServerInfo ( VOID ) { return m_pUser->GetServerInfo ();	}

	ULONG GetUserPrefixCount ( VOID ) { return m_pUser->GetPrefixCount (); }
	TCHAR *GetUserPrefixString ( VOID ) { return m_pUser->GetPrefixString (); }

	ULONG GetPrefixCount ( VOID ) { return m_cPrefix; }
	TCHAR *GetPrefixString ( VOID ) { return m_pszPrefix; }

private:

	HRESULT CacheInfo ( VOID *pInfo );
	HRESULT CacheAppInfo ( LDAP_APPINFO *pInfo );
	HRESULT CreateRegisterModArr ( LDAPMod ***pppMod );
	HRESULT CreateUnRegisterModArr ( LDAPMod ***pppMod );
	HRESULT CreateSetStdAttrsModArr ( LDAPMod ***pppMod );
	VOID FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx );

	ULONG				m_uSignature;
	LONG				m_cRefs;
	UlsLdap_CLocalUser	*m_pUser;

	APP_INFO			m_AppInfo;
	REG_STATUS			m_RegStatus;

	ULONG				m_cPrefix;
	TCHAR				*m_pszPrefix;
};


#include <poppack.h>

#endif // _ULS_SP_APPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\splprot.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splprot.cpp
	Content:	This file contains the local protocol object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

const TCHAR *c_apszProtStdAttrNames[COUNT_ENUM_PROTATTR] =
{
	TEXT ("sprotid"),
	TEXT ("sprotmimetype"),
	TEXT ("sport"),
};


/* ---------- public methods ----------- */


SP_CProtocol::
SP_CProtocol ( SP_CClient *pClient )
	:
	m_cRefs (0),						// Reference count
	m_uSignature (PROTOBJ_SIGNATURE)	// Protocol object's signature
{
	MyAssert (pClient != NULL);
	m_pClient = pClient;

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	::ZeroMemory (&m_ProtInfo, sizeof (m_ProtInfo));

	// Indicate this protocol is not registered yet
	//
	SetRegNone ();
}


SP_CProtocol::
~SP_CProtocol ( VOID )
{
	// Invalidate the client object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free cached strings
	//
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME]);
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE]);
}


ULONG SP_CProtocol::
AddRef ( VOID )
{
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG SP_CProtocol::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);
	::InterlockedDecrement (&m_cRefs);

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT SP_CProtocol::
Register (
	ULONG			uRespID,
	LDAP_PROTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);

	// Cache protocol info
	//
	CacheProtInfo (pInfo);

	// Get protocol name
	//
	TCHAR *pszProtName = m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME];
	if (! MyIsGoodString (pszProtName))
	{
		MyAssert (FALSE);
		return ILS_E_PARAMETER;
	}

	// Add the protocol object
	//
	return m_pClient->AddProtocol (WM_ILS_REGISTER_PROTOCOL, uRespID, this);
}


HRESULT SP_CProtocol::
UnRegister ( ULONG uRespID )
{
	// If it is not registered on the server,
	// the simply report success
	//
	if (! IsRegRemotely ())
	{
		SetRegNone ();
		PostMessage (g_hWndNotify, WM_ILS_UNREGISTER_PROTOCOL, uRespID, S_OK);
		return S_OK;
	}

	// Indicate that we are not registered at all
	//
	SetRegNone ();

	// remove the protocol object
	//
	return m_pClient->RemoveProtocol (WM_ILS_UNREGISTER_PROTOCOL, uRespID, this);
}


HRESULT SP_CProtocol::
SetAttributes (
	ULONG			uRespID,
	LDAP_PROTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);

	// Cache protocol info
	//
	CacheProtInfo (pInfo);

	// remove the protocol object
	//
	return m_pClient->UpdateProtocols (WM_ILS_SET_PROTOCOL_INFO, uRespID, this);
}


/* ---------- protected methods ----------- */


/* ---------- private methods ----------- */


VOID SP_CProtocol::
CacheProtInfo ( LDAP_PROTINFO *pInfo )
{
	MyAssert (pInfo != NULL);

	// Free previous allocations
	//
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME]);
	MemFree (m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE]);

	// Clean up the buffer
	//
	ZeroMemory (&m_ProtInfo, sizeof (m_ProtInfo));

	// Start to cache protocol standard attributes
	//

	if (pInfo->uOffsetName != INVALID_OFFSET)
	{
		m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME] =
						My_strdup ((TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetName));
		m_ProtInfo.dwFlags |= PROTOBJ_F_NAME;
	}

	if (pInfo->uPortNumber != INVALID_OFFSET)
	{
		m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_PORT_NUMBER] = &m_ProtInfo.szPortNumber[0];
		::GetLongString (pInfo->uPortNumber, &m_ProtInfo.szPortNumber[0]);
		m_ProtInfo.dwFlags |= PROTOBJ_F_PORT_NUMBER;
	}

	if (pInfo->uOffsetMimeType != INVALID_OFFSET)
	{
		m_ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE] =
						My_strdup ((TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetMimeType));
		m_ProtInfo.dwFlags |= PROTOBJ_F_MIME_TYPE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\splmtg.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splmtg.cpp
	Content:	This file contains the local meeting object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

#ifdef ENABLE_MEETING_PLACE

// Array of constant strings for user object's attribute names
//
const TCHAR *c_apszMtgStdAttrNames[COUNT_ENUM_MTGATTR] =
{
	TEXT ("CN"),				// Meeting ID
	TEXT ("ConfType"),			// Meeting Type
	TEXT ("ConfMemberType"),	// Attendee Type
	TEXT ("ConfDesc"),			// Description
	TEXT ("ConfHostName"),		// Host Name
	TEXT ("ConfHostAddress"),	// IP Address

	TEXT ("ConfMemberList"),	// Members
	TEXT ("ssecurity"),
	TEXT ("sttl"),

	TEXT ("objectClass"),
	TEXT ("o"),
	TEXT ("c"),
};


const TCHAR c_szMtgDefC[] = TEXT ("us");


/* ---------- public methods ----------- */


SP_CMeeting::
SP_CMeeting ( DWORD dwContext )
	:
	m_cRefs (0),						// Reference count
	m_uSignature (MTGOBJ_SIGNATURE),	// Mtg object's signature
	m_pszMtgName (NULL),				// Clean the meeting name
	m_pszDN (NULL),						// Clean DN
	m_pszRefreshFilter (NULL),			// Clean up the refresh search filter
	m_dwIPAddress (0),					// Clean local IP address
	m_uTTL (ILS_DEF_REFRESH_MINUTE)		// Reset time to live value (min)
{
	m_dwContext = dwContext;

	// Clean up attached server info structure
	//
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	::ZeroMemory (&m_MtgInfo, sizeof (m_MtgInfo));

	// Indicate this user is not registered yet
	//
	SetRegNone ();
}


SP_CMeeting::
~SP_CMeeting ( VOID )
{
	// Invalidate the user object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free server info structure
	//
	::IlsFreeServerInfo (&m_ServerInfo);

	// Free meeting name
	//
	MemFree (m_pszMtgName);

	// Free DN
	//
	MemFree (m_pszDN);

	// Free the refresh search filter
	//
	MemFree (m_pszRefreshFilter);

	// Release the previous prefix for extended attribute names
	//
	::IlsReleaseAnyAttrsPrefix (&(m_MtgInfo.AnyAttrs));
}


ULONG
SP_CMeeting::
AddRef ( VOID )
{
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG
SP_CMeeting::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);
	::InterlockedDecrement (&m_cRefs);

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT SP_CMeeting::
Register (
	ULONG				uRespID,
	SERVER_INFO			*pServerInfo,
	LDAP_MEETINFO		*pInfo )
{
	MyAssert (pInfo != NULL);
	MyAssert (MyIsGoodString (pServerInfo->pszServerName));

	// Cache the server info
	//
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pServerInfo);
	if (hr != S_OK)
		return hr;

	// Cache the meeting info
	// lonchanc: CacheInfo() is not a method in the meeting object
	// because we pass in meeting name in SetMeetingInfo()
	// rather than meeting object handle.
	//
	hr = ::MtgCacheInfo (pInfo, &m_MtgInfo);
	if (hr != S_OK)
		return hr;

	// If the application sets an IP address,
	//		then we will use what the app provides,
	//		otherwise, we will get the IP address via winsock.
	//
	if (pInfo->uOffsetHostIPAddress == INVALID_OFFSET)
	{
		// Get local IP address
		//
		m_dwIPAddress = 0;
		hr = ::GetLocalIPAddress (&m_dwIPAddress);
		if (hr != S_OK)
			return hr;

		// Create IP address string
		//
		m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS] = &m_MtgInfo.szIPAddress[0];
		::GetLongString (m_dwIPAddress, &m_MtgInfo.szIPAddress[0]);
	}

	// Create client signature string
	//
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CLIENT_SIG] = &m_MtgInfo.szClientSig[0];
	::GetLongString (g_dwClientSig, &m_MtgInfo.szClientSig[0]);

	// Create TTL string
	//
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_TTL] = &m_MtgInfo.szTTL[0];
	::GetLongString (m_uTTL, &m_MtgInfo.szTTL[0]);

	// Ideally, o= and c= should be read in from registiry
	// but for now, we simply hard code it
	//
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_OBJECT_CLASS] = (TCHAR *) &c_szRTConf[0];
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_O] = (TCHAR *) &c_szDefO[0];
	m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_C] = (TCHAR *) &c_szMtgDefC[0];

	// Duplicate the mtg name
	//
	m_pszMtgName = My_strdup (m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN]);
	if (m_pszMtgName == NULL)
		return ILS_E_MEMORY;

	// Build DN
	//
	m_pszDN = ::IlsBuildDN (m_ServerInfo.pszBaseDN,
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_C],
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_O],
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN],
							m_MtgInfo.apszStdAttrValues[ENUM_MTGATTR_OBJECT_CLASS]);
	if (m_pszDN == NULL)
		return ILS_E_MEMORY;

	// Build refreh filter
	//
	m_pszRefreshFilter = ::MtgCreateRefreshFilter (m_pszMtgName);
	if (m_pszRefreshFilter == NULL)
		return ILS_E_MEMORY;

	// Build modify array for ldap_add()
	//
	LDAPMod **ppMod = NULL;
	hr = CreateRegModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation
	//

	// Get the connection object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgID = ldap_add (ld, m_pszDN, ppMod);
		if (uMsgID == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}

	}

	// Free modify array
	//
	MemFree (ppMod);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_REGISTER_MEETING;
	ri.hObject = (HANDLE) this;

	// Remember the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CMeeting::
UnRegister ( ULONG uRespID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Make sure that there is not refresh scheduled for this object
	//
	if (g_pRefreshScheduler != NULL)
	{
		g_pRefreshScheduler->RemoveMtgObject (this);
	}
	else
	{
		MyAssert (FALSE);
	}

	// If it is not registered on the server,
	// the simply report success
	//
	if (! IsRegRemotely ())
	{
		SetRegNone ();
		::PostMessage (g_hWndNotify, WM_ILS_UNREGISTER_MEETING, uRespID, S_OK);
		return S_OK;
	}

	// Indicate that we are not registered at all
	//
	SetRegNone ();

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		// Get the ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		MyAssert (MyIsGoodString (m_pszDN));
		uMsgID = ::ldap_delete (ld, m_pszDN);
		if (uMsgID == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_UNREGISTER_MEETING;

	// Remember the pending request
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CMeeting::
UpdateIPAddress ( VOID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Update cached ip address
	//
	HRESULT hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Update the ip address string
	//
	::GetLongString (m_dwIPAddress, &m_MtgInfo.szIPAddress[0]);

	// Update IP address in the server
	//
	return ::IlsUpdateIPAddress (	&m_ServerInfo,
									m_pszDN,
									STR_MTG_IP_ADDR,
									&m_MtgInfo.szIPAddress[0],
									ISBU_MODOP_MODIFY_USER,
									MtgGetPrefixCount (),
									MtgGetPrefixString ());
}


/* ---------- protected methods ----------- */


HRESULT SP_CMeeting::
SendRefreshMsg ( VOID )
{
	MyAssert (m_pszRefreshFilter != NULL);

	// Get local IP address
	//
	DWORD dwIPAddress = 0;
	HRESULT hr = ::GetLocalIPAddress (&dwIPAddress);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA(Mtg): cannot get my ip address\r\n"));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify this app of the network being down
		//
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);

		// Report error
		//
		return ILS_E_NETWORK_DOWN;
	}

	// If dwIPAddress is 0, then we are not on the network any more
	// start relogon process
	//
	if (dwIPAddress == 0)
	{
		MyDebugMsg ((ZONE_KA, "KA(Mtg): ip-addr=0, network down.\r\n"));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify this app of the network being down
		//
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);

		// Report error
		//
		return ILS_E_NETWORK_DOWN;
	}
	else
	// If dwIPAddress and m_dwIPAddress, alert
	//
	if (dwIPAddress != m_dwIPAddress)
	{
		UpdateIPAddress ();
	}

	// Send a refresh message to the server and parse the new TTL value
	//
	hr = ::IlsSendRefreshMsg (	&m_ServerInfo,
								STR_DEF_MTG_BASE_DN,
								STR_MTG_TTL,
								m_pszRefreshFilter,
								&m_uTTL);
	if (hr == ILS_E_NEED_RELOGON)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NEED_RELOGON,
							(WPARAM) this, (LPARAM) m_dwContext);
	}
	else
	if (hr == ILS_E_NETWORK_DOWN)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_MEETING_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);
	}

	return hr;
}


/* ---------- private methods ----------- */


HRESULT SP_CMeeting::
CreateRegModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	// Calculate the modify array size
	//
	ULONG cStdAttrs = COUNT_ENUM_MTGATTR;
	ULONG cAnyAttrs = m_MtgInfo.AnyAttrs.cAttrsToAdd;
	ULONG cTotal = cStdAttrs + cAnyAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);

	// Allocate modify list
	//
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Lay out the modify array
	//
	LDAPMod **apMod = *pppMod;
	LDAPMod *pMod;
	TCHAR *pszName, *pszValue;
	pszName = m_MtgInfo.AnyAttrs.pszAttrsToAdd;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		pMod->mod_op = LDAP_MOD_ADD;
		apMod[i] = pMod;

		if (i < cStdAttrs)
		{
			// Put standard attributes
			//
			::MtgFillModArrAttr (pMod, &m_MtgInfo, i);
		}
		else
		{
			// Put extended attributes
			//
			pszValue = pszName + lstrlen (pszName) + 1;
			::IlsFillModifyListItem (pMod, pszName, pszValue);
			pszName = pszValue + lstrlen (pszValue) + 1;
		}
	}

	// Put null to terminate modify list
	//
	apMod[cTotal] = NULL;
	return S_OK;
}



/* ---------- helper functions ----------- */


HRESULT
MtgSetAttrs (
	SERVER_INFO			*pServerInfo,
	TCHAR				*pszMtgName,
	LDAP_MEETINFO		*pInfo,
	ULONG				uRespID )
{
	MyAssert (pServerInfo != NULL);
	MyAssert (MyIsGoodString (pszMtgName));
	MyAssert (pInfo != NULL);

	// Cannot change lMeetingPlaceType, lAttendeeType, and MeetingID
	//
	if (pInfo->lMeetingPlaceType		!= INVALID_MEETING_TYPE ||
		pInfo->lAttendeeType			!= INVALID_ATTENDEE_TYPE ||
		pInfo->uOffsetMeetingPlaceID	!= INVALID_OFFSET)
	{
		return ILS_E_PARAMETER;
	}

	// Initialize locals
	//
	TCHAR *pszDN = NULL;
	LDAPMod **ppMod = NULL;
	SP_CSession *pSession = NULL;
	ULONG uMsgID = (ULONG) -1;

	MTG_INFO MtgInfo;
	ZeroMemory (&MtgInfo, sizeof (MtgInfo));

	// Cache the meeting info
	//
	HRESULT hr = MtgCacheInfo  (pInfo, &MtgInfo);
	if (hr != S_OK)
		goto MyExit;

	// Build DN for meeting
	//
	pszDN = IlsBuildDN (pServerInfo->pszBaseDN,
						(TCHAR *) &c_szMtgDefC[0],
						(TCHAR *) &c_szDefO[0],
						pszMtgName,
						(TCHAR *) &c_szRTConf[0]);
	if (pszDN == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Build modify array for ldap_modify()
	//
	hr = MtgCreateSetAttrsModArr (&ppMod, &MtgInfo);
	if (hr != S_OK)
		goto MyExit;
	MyAssert (ppMod != NULL);

	// Get the session object
	//
	LDAP *ld;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgID = ldap_modify (ld, pszDN, ppMod);
		if (uMsgID == (ULONG) -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct pending info
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_SET_MEETING_INFO;

	// Remember the pending request
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	MemFree (pszDN);
	MemFree (ppMod);
	IlsReleaseAnyAttrsPrefix (&(MtgInfo.AnyAttrs));

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


VOID
MtgFillModArrAttr (
	LDAPMod				*pMod,
	MTG_INFO			*pMtgInfo,
	INT					nIndex )
{
	MyAssert (pMod != NULL);
	MyAssert (pMtgInfo != NULL);
	MyAssert (0 <= nIndex && nIndex <= COUNT_ENUM_MTGATTR);

	IlsFillModifyListItem (	pMod,
							(TCHAR *) c_apszMtgStdAttrNames[nIndex],
							pMtgInfo->apszStdAttrValues[nIndex]);
}


HRESULT
MtgCreateSetAttrsModArr (
	LDAPMod				***pppMod,
	MTG_INFO			*pMtgInfo )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	DWORD dwFlags = pMtgInfo->dwFlags;
	ULONG cTotal  = pMtgInfo->AnyAttrs.cAttrsToAdd +
					pMtgInfo->AnyAttrs.cAttrsToModify +
					pMtgInfo->AnyAttrs.cAttrsToRemove;

	// Lay out the modify array for modifying standard/extended attributes
	//
	hr = IlsFillDefStdAttrsModArr (pppMod,
								dwFlags,
								COUNT_ENUM_MTGINFO,
								&cTotal,
								ISBU_MODOP_MODIFY_USER,
								MtgGetPrefixCount (),
								MtgGetPrefixString ());
	if (hr != S_OK)
		return hr;

	// Start to fill standard attributes
	//
	ULONG i = MtgGetPrefixCount ();
	LDAPMod **apMod = *pppMod;

	if (dwFlags & MTGOBJ_F_NAME)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_CN);

	if (dwFlags & MTGOBJ_F_MTG_TYPE)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_MTG_TYPE);

	if (dwFlags & MTGOBJ_F_MEMBER_TYPE)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_MEMBER_TYPE);

	if (dwFlags & MTGOBJ_F_DESCRIPTION)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_DESCRIPTION);

	if (dwFlags & MTGOBJ_F_HOST_NAME)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_HOST_NAME);

	if (dwFlags & MTGOBJ_F_IP_ADDRESS)
		MtgFillModArrAttr (apMod[i++], pMtgInfo, ENUM_MTGATTR_IP_ADDRESS);

	// Start to fill extended attributes
	//
	::IlsFillModifyListForAnyAttrs (apMod, &i, &(pMtgInfo->AnyAttrs));

	MyAssert (i == cTotal);
	return S_OK;
}


HRESULT
MtgCacheInfo (
	LDAP_MEETINFO		*pInfo,
	MTG_INFO			*pMtgInfo )
{
	MyAssert (pInfo != NULL);
	MyAssert (pMtgInfo != NULL);

	// Release the previous prefix for extended attribute names
	//
	IlsReleaseAnyAttrsPrefix (&(pMtgInfo->AnyAttrs));

	// Clean up the buffer
	//
	ZeroMemory (pMtgInfo, sizeof (*pMtgInfo));

	// Start to cache mtg standard attributes
	//

	if (pInfo->lMeetingPlaceType != INVALID_MEETING_TYPE)
	{
		GetLongString (pInfo->lMeetingPlaceType, &(pMtgInfo->szMtgType[0]));
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_MTG_TYPE] = &(pMtgInfo->szMtgType[0]);
		pMtgInfo->dwFlags |= MTGOBJ_F_MTG_TYPE;
	}

	if (pInfo->lAttendeeType != INVALID_ATTENDEE_TYPE)
	{
		GetLongString (pInfo->lAttendeeType, &(pMtgInfo->szMemberType[0]));
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_MEMBER_TYPE] = &(pMtgInfo->szMemberType[0]);
		pMtgInfo->dwFlags |= MTGOBJ_F_MEMBER_TYPE;
	}

	if (pInfo->uOffsetMeetingPlaceID != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_CN] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetMeetingPlaceID);
		pMtgInfo->dwFlags |= MTGOBJ_F_NAME;
	}

	if (pInfo->uOffsetDescription != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_DESCRIPTION] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetDescription);
		pMtgInfo->dwFlags |= MTGOBJ_F_DESCRIPTION;
	}

	if (pInfo->uOffsetHostName != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_HOST_NAME] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetHostName);
		pMtgInfo->dwFlags |= MTGOBJ_F_HOST_NAME;
	}

	if (pInfo->uOffsetHostIPAddress != INVALID_OFFSET)
	{
		pMtgInfo->apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS] =
					(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetHostIPAddress);
		pMtgInfo->dwFlags |= MTGOBJ_F_IP_ADDRESS;
	}

	// Start to cache mtg extended attributes
	//

	if (pInfo->uOffsetAttrsToAdd != INVALID_OFFSET &&
		pInfo->cAttrsToAdd != 0)
	{
		pMtgInfo->AnyAttrs.cAttrsToAdd = pInfo->cAttrsToAdd;
		pMtgInfo->AnyAttrs.pszAttrsToAdd =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToAdd);
	}

	if (pInfo->uOffsetAttrsToModify != INVALID_OFFSET &&
		pInfo->cAttrsToModify != 0)
	{
		pMtgInfo->AnyAttrs.cAttrsToModify = pInfo->cAttrsToModify;
		pMtgInfo->AnyAttrs.pszAttrsToModify =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToModify);
	}

	if (pInfo->uOffsetAttrsToRemove != INVALID_OFFSET &&
		pInfo->cAttrsToRemove != 0)
	{
		pMtgInfo->AnyAttrs.cAttrsToRemove = pInfo->cAttrsToRemove;
		pMtgInfo->AnyAttrs.pszAttrsToRemove =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToRemove);
	}

	// Create prefix for extended attribute names
	//
	return IlsCreateAnyAttrsPrefix (&(pMtgInfo->AnyAttrs));
}


HRESULT
MtgUpdateMembers (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServerInfo,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	ULONG			uRespID )
{
	MyAssert (	uNotifyMsg == WM_ILS_ADD_ATTENDEE ||
				uNotifyMsg == WM_ILS_REMOVE_ATTENDEE);

	MyAssert (pServerInfo != NULL);
	MyAssert (MyIsGoodString (pszMtgName));
	MyAssert (MyIsGoodString (pszMemberNames));

	// Initialize locals
	//
	HRESULT hr = S_OK;
	TCHAR *pszDN = NULL;
	LDAPMod **ppMod = NULL;
	SP_CSession *pSession = NULL;
	ULONG uMsgID = (ULONG) -1;

	// Build DN for meeting
	//
	pszDN = IlsBuildDN (pServerInfo->pszBaseDN,
						(TCHAR *) &c_szMtgDefC[0],
						(TCHAR *) &c_szDefO[0],
						pszMtgName,
						(TCHAR *) &c_szRTConf[0]);
	if (pszDN == NULL)
		return ILS_E_MEMORY;

	// Build modify array for ldap_modify()
	//
	hr = MtgCreateUpdateMemberModArr (	uNotifyMsg,
										&ppMod,
										cMembers,
										pszMemberNames);
	if (hr != S_OK)
		goto MyExit;
	MyAssert (ppMod != NULL);

	// Get the session object
	//
	LDAP *ld;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgID = ldap_modify (ld, pszDN, ppMod);
		if (uMsgID == (ULONG) -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct pending info
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;

	// Remember the pending request
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	MemFree (pszDN);
	MemFree (ppMod);

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT
MtgCreateUpdateMemberModArr (
	ULONG				uNotifyMsg,
	LDAPMod				***pppMod,
	ULONG				cMembers,
	TCHAR				*pszMemberNames )
{
	MyAssert (pppMod != NULL);
	MyAssert (pszMemberNames != NULL);

	// Get meeting object prefix
	//
	ULONG cPrefix = MtgGetPrefixCount ();
	TCHAR *pszPrefix = MtgGetPrefixString ();

	// The total number of attributes is the number of prefix attributes
	// plus the very only ConfMemberList
	//
	ULONG cStdAttrs = 1;
	ULONG cTotal = cPrefix + cStdAttrs;

	// Calculate the modify array's total size
	//
	ULONG cbMod = IlsCalcModifyListSize (cTotal);

	// Add up for multi-valued attribute
	//
	cbMod += cStdAttrs * (cMembers - 1) * sizeof (TCHAR *);

	// Allocate the modify array
	//
	LDAPMod **apMod = *pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (apMod == NULL)
		return ILS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	BYTE *pbData = (BYTE *) apMod + (cTotal + 1) * sizeof (LDAPMod *);
	ULONG uDispPrefix = sizeof (LDAPMod) + 2 * sizeof (TCHAR *);
	ULONG uDispStdAttrs = sizeof (LDAPMod) + (cMembers + 1) * sizeof (TCHAR *);
	for (ULONG uOffset = 0, i = 0; i < cTotal; i++)
	{
		// Locate the modify structure
		//
		pMod = (LDAPMod *) (pbData + uOffset);
		apMod[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		// Fill in the modify structure
		//
		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			// Fill in attribute name
			//
			pMod->mod_op = (uNotifyMsg == WM_ILS_ADD_ATTENDEE) ?
							LDAP_MOD_ADD : LDAP_MOD_DELETE;
			pMod->mod_type = (TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBERS];

		    // Fill in multi-valued modify array
		    //
		    for (ULONG j = 0; j < cMembers; j++)
		    {
		    	(pMod->mod_values)[j++] = pszMemberNames;
		    	pszMemberNames += lstrlen (pszMemberNames) + 1;
		    }
		}

		// Calculate the modify structure's offset relative to the array's end
		//
		uOffset += (i < cPrefix) ? uDispPrefix : uDispStdAttrs;
	}

	// Fix up the first and the last ones
	//
	IlsFixUpModOp (apMod[0], LDAP_MOD_REPLACE, ISBU_MODOP_MODIFY_APP);
	apMod[cTotal] = NULL;

	return S_OK;
}


#endif // ENABLE_MEETING_PLACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\splmtg.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spmtg.h
	Content:	This file contains the meeting place object definition.
	History:
	12/9/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_MTGOBJ_H_
#define _ILS_SP_MTGOBJ_H_

#ifdef ENABLE_MEETING_PLACE

#include <pshpack8.h>

enum
{
	ENUM_MTGATTR_CN,
	ENUM_MTGATTR_MTG_TYPE,
	ENUM_MTGATTR_MEMBER_TYPE,
	ENUM_MTGATTR_DESCRIPTION,
	ENUM_MTGATTR_HOST_NAME,
	ENUM_MTGATTR_IP_ADDRESS,

	/* -- the above are resolvable -- */

	ENUM_MTGATTR_MEMBERS,
	ENUM_MTGATTR_CLIENT_SIG,
	ENUM_MTGATTR_TTL,

	/* -- the above are changeable standard attributes for RTConf -- */

	ENUM_MTGATTR_OBJECT_CLASS,
	ENUM_MTGATTR_O,
	ENUM_MTGATTR_C,

	COUNT_ENUM_MTGATTR
};

#define COUNT_ENUM_MTGINFO			(ENUM_MTGATTR_TTL + 1) // exclude uid, o, c
#define COUNT_ENUM_DIRMTGINFO		(ENUM_MTGATTR_IP_ADDRESS + 1)	// count of attrs in dir dlg
#define COUNT_ENUM_RESMTGINFO		(ENUM_MTGATTR_IP_ADDRESS + 1)	// count of attrs resolvable

extern const TCHAR *c_apszMtgStdAttrNames[COUNT_ENUM_MTGATTR];
#define STR_MTG_NAME				((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_CN])
#define STR_MTG_MEMBERS				((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBERS])
#define STR_MTG_IP_ADDR				((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_IP_ADDRESS])
#define STR_MTG_TTL					((TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_TTL])
#define STR_DEF_MTG_BASE_DN			((TCHAR *) &c_szDefMtgBaseDN[0])

#define MTGOBJ_F_NAME			0x0001
#define MTGOBJ_F_MTG_TYPE		0x0002
#define MTGOBJ_F_MEMBER_TYPE	0x0004
#define MTGOBJ_F_DESCRIPTION	0x0008
#define MTGOBJ_F_HOST_NAME		0x0010
#define MTGOBJ_F_IP_ADDRESS		0x0020

typedef struct
{
	DWORD		dwFlags;
	TCHAR		*apszStdAttrValues[COUNT_ENUM_MTGATTR];
	ANY_ATTRS	AnyAttrs;
	TCHAR		szMtgType[INTEGER_STRING_LENGTH];
	TCHAR		szMemberType[INTEGER_STRING_LENGTH];
	TCHAR		szIPAddress[INTEGER_STRING_LENGTH];
	TCHAR		szFlags[INTEGER_STRING_LENGTH];
	TCHAR		szTTL[INTEGER_STRING_LENGTH];
	TCHAR		szClientSig[INTEGER_STRING_LENGTH];
	TCHAR		szGuid[sizeof (GUID) * 2 + 2];
}
	MTG_INFO;


#define MTGOBJ_SIGNATURE	((ULONG) 0x98007206UL)


class SP_CMeeting
{
	friend class SP_CRefreshScheduler;

public:

	SP_CMeeting ( DWORD dwContext );
	~SP_CMeeting ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG uRespID, SERVER_INFO *pServerInfo, LDAP_MEETINFO *pInfo );
	HRESULT UnRegister ( ULONG uRespID );

	VOID SetRegNone ( VOID ) { m_RegStatus = ILS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ILS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ILS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ILS_REG_STATUS_NONE); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_LOCALLY); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_REMOTELY); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == MTGOBJ_SIGNATURE; }

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }

	TCHAR *GetMtgName ( VOID ) { return m_pszMtgName; }

	ULONG GetTTL ( VOID ) { return m_uTTL; }
	DWORD GetContext ( VOID ) { return m_dwContext; }

protected:

	HRESULT SendRefreshMsg ( VOID );

private:

	HRESULT CreateRegModArr ( LDAPMod ***pppMod );

	HRESULT UpdateIPAddress ( VOID );

	ULONG		m_uSignature;
	LONG		m_cRefs;

	MTG_INFO	m_MtgInfo;
	TCHAR		*m_pszMtgName;
	TCHAR		*m_pszDN;

	SERVER_INFO	m_ServerInfo;
	TCHAR		*m_pszRefreshFilter;

	REG_STATUS	m_RegStatus;

	DWORD		m_dwIPAddress;
	ULONG		m_uTTL;
	DWORD		m_dwContext;
};


#define MtgGetPrefixCount()			1
#define MtgGetPrefixString()		g_pszMtgPrefix


HRESULT MtgSetAttrs ( SERVER_INFO *pServerInfo, TCHAR *pszMtgName, LDAP_MEETINFO *pInfo, ULONG uRespID );
HRESULT MtgCreateSetAttrsModArr ( LDAPMod ***pppMod, MTG_INFO *pMtgInfo );
VOID MtgFillModArrAttr ( LDAPMod *pMod, MTG_INFO *pMtgInfo, INT nIndex );
HRESULT MtgCacheInfo ( LDAP_MEETINFO *pInfo, MTG_INFO *pMtgInfo );
HRESULT MtgUpdateMembers ( ULONG uNotifyMsg, SERVER_INFO *pServerInfo, TCHAR *pszMtgName, ULONG cMembers, TCHAR *pszMemberNames, ULONG uRespID );
HRESULT MtgCreateUpdateMemberModArr ( ULONG uNotifyMsg, LDAPMod ***pppMod, ULONG cMembers, TCHAR *pszMemberNames );

#include <poppack.h>

#endif // ENABLE_MEETING_PLACE

#endif // _ILS_SP_MTGOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\splprot.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splprot.h
	Content:	This file contains the local protocol object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_PROTOBJ_H_
#define _ILS_SP_PROTOBJ_H_

#include <pshpack8.h>

enum
{
	ENUM_PROTATTR_NAME,
	ENUM_PROTATTR_MIME_TYPE,
	ENUM_PROTATTR_PORT_NUMBER,
	COUNT_ENUM_PROTATTR
};


#define PROTOBJ_F_NAME			0x0001
#define PROTOBJ_F_MIME_TYPE		0x0002
#define PROTOBJ_F_PORT_NUMBER	0x0004


extern const TCHAR *c_apszProtStdAttrNames[];

#define STR_PROT_NAME	((TCHAR *) c_apszProtStdAttrNames[ENUM_PROTATTR_NAME])


typedef struct
{
	DWORD	dwFlags;
	TCHAR	*apszStdAttrValues[COUNT_ENUM_PROTATTR];
	TCHAR	szPortNumber[INTEGER_STRING_LENGTH];
}
	PROT_INFO;


#define PROTOBJ_SIGNATURE	((ULONG) 0xABCD1278UL)


class SP_CProtocol
{
	friend class SP_CClient;

public:

	SP_CProtocol ( SP_CClient *pClient );
	~SP_CProtocol ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG uRespID, LDAP_PROTINFO *pInfo );
	HRESULT UnRegister ( ULONG uRespID );

	HRESULT SetAttributes ( ULONG uRespID, LDAP_PROTINFO *pInfo );

	VOID SetRegNone ( VOID ) { m_RegStatus = ILS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ILS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ILS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ILS_REG_STATUS_NONE &&
									 		m_pClient->IsRegistered ()); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_LOCALLY &&
											m_pClient->IsRegistered ()); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_REMOTELY &&
											m_pClient->IsRegRemotely ()); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == PROTOBJ_SIGNATURE; }

protected:

	PROT_INFO *GetProtInfo ( VOID ) { return &m_ProtInfo; }

private:

	VOID CacheProtInfo ( LDAP_PROTINFO *pInfo );

	ULONG			m_uSignature;
	LONG			m_cRefs;
	SP_CClient		*m_pClient;

	PROT_INFO		m_ProtInfo;
	REG_STATUS		m_RegStatus;
};


#include <poppack.h>

#endif // _ILS_SP_PROTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spluser.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spluser.cpp
	Content:	This file contains the local user object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

// Array of constant strings for user object's attribute names
//
const TCHAR *c_apszUserStdAttrNames[COUNT_ENUM_USERATTR] =
{
	TEXT ("cn"),
	TEXT ("givenname"),
	TEXT ("surname"),
	TEXT ("rfc822mailbox"),
	TEXT ("location"),
#ifdef USE_DEFAULT_COUNTRY
	TEXT ("aCountryName"),
#endif
	TEXT ("comment"),
	TEXT ("sipaddress"),
	TEXT ("sflags"),
	TEXT ("c"),

	TEXT ("ssecurity"),
	TEXT ("sttl"),

	TEXT ("objectClass"),
	TEXT ("o"),
};


/* ---------- public methods ----------- */


UlsLdap_CLocalUser::
UlsLdap_CLocalUser ( VOID )
{
	// Reference count
	//
	m_cRefs = 0;

	// User object's signature
	//
	m_uSignature = USEROBJ_SIGNATURE;

	// Clean up attached server info structure
	//
	ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	ZeroMemory (&m_UserInfo, sizeof (m_UserInfo));

	// Clean up DN (old and current ones)
	m_pszDN = NULL;
	m_pszOldDN = NULL;

	// Clean up the refresh search filter
	//
	m_pszRefreshFilter = NULL;

	// Indicate this user is not registered yet
	//
	SetRegNone ();

	// Reset time to live value
	m_uTTL = ULS_DEF_REFRESH_MINUTE; // in unit of minute: no effect on current ils, but to avoid legacy issue later
	m_dwIPAddress = 0;
}


UlsLdap_CLocalUser::
~UlsLdap_CLocalUser ( VOID )
{
	// Invalidate the user object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free server info structure
	//
	::IlsFreeServerInfo (&m_ServerInfo);

	// Free DN (old and current ones)
	//
	MemFree (m_pszDN);
	MemFree (m_pszOldDN);

	// Free the refresh search filter
	//
	MemFree (m_pszRefreshFilter);
}


ULONG UlsLdap_CLocalUser::
AddRef ( VOID )
{
	InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG UlsLdap_CLocalUser::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);

	if (m_cRefs != 0)
	{
		InterlockedDecrement (&m_cRefs);
	}

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT UlsLdap_CLocalUser::
Register ( ULONG *puRespID, SERVER_INFO *pServerInfo, LDAP_USERINFO *pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	MyAssert (	pServerInfo->pszServerName != NULL &&
				pServerInfo->pszServerName[0] != TEXT ('\0'));
	MyAssert (	pServerInfo->pszBaseDN != NULL &&
				pServerInfo->pszBaseDN[0] != TEXT ('\0'));

	// cache the server info
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pServerInfo);
	if (hr != S_OK)
		return hr;

	// cache user info
	hr = CacheUserInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// get ip address
	m_dwIPAddress = 0;
	hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Create IP address string
	//
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_IP_ADDRESS] = &m_UserInfo.szIPAddress[0];
	::GetLongString (m_dwIPAddress, &m_UserInfo.szIPAddress[0]);

	// Create client signature string
	//
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CLIENT_SIG] = &m_UserInfo.szClientSig[0];
	::GetLongString (g_dwClientSig, &m_UserInfo.szClientSig[0]);

	// Create TTL string
	//
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_TTL] = &m_UserInfo.szTTL[0];
	::GetLongString (m_uTTL, &m_UserInfo.szTTL[0]);

	// ideally, o= and c= should be read in from registiry
	// but for now, we simply hard code it
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_OBJECT_CLASS] = (TCHAR *) &c_szRTPerson[0];
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_O] = (TCHAR *) &c_szDefO[0];
#ifdef USE_DEFAULT_COUNTRY
	m_UserInfo.apszStdAttrValues[ENUM_USERATTR_C] = (TCHAR *) &c_szDefC[0];
#endif

	// build DN
	hr = BuildDN ();
	if (hr != S_OK)
		return hr;

	// build refreh filter
	m_pszRefreshFilter = UserCreateRefreshFilter (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN]);
	if (m_pszRefreshFilter == NULL)
		return ULS_E_MEMORY;

	// build modify array for ldap_add()
	LDAPMod **ppMod = NULL;
	hr = CreateRegisterModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_add (ld, GetDN (), ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// construct a pending info
	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
	PendingInfo.uLdapResType = LDAP_RES_ADD;
	PendingInfo.uNotifyMsg = WM_ULS_REGISTER_USER;
	PendingInfo.hObject = (HANDLE) this;

	// queue it
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


HRESULT UlsLdap_CLocalUser::
UnRegister ( ULONG *puRespID )
{
	MyAssert (puRespID != NULL);

	// Make sure that there is not refresh scheduled for this object
	//
	if (g_pRefreshScheduler != NULL)
	{
		g_pRefreshScheduler->RemoveUserObject (this);
	}
	else
	{
		MyAssert (FALSE);
	}

	// Unregister it locally
	//
	if (! IsRegRemotely ())
	{
		*puRespID = ::GetUniqueNotifyID ();
		SetRegNone ();
		PostMessage (g_hWndNotify, WM_ULS_UNREGISTER_USER, *puRespID, S_OK);
		return S_OK;
	}

	SetRegNone ();

	// Get the session object
	//
	UlsLdap_CSession *pSession = NULL;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr != S_OK)
		return hr;
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// LONCHANC: notify global user object of this unregister user


	// send the data over the wire
	ULONG uMsgID = ldap_delete (ld, GetDN ());
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// construct a pending info
	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
	PendingInfo.uLdapResType = LDAP_RES_DELETE;
	PendingInfo.uNotifyMsg = WM_ULS_UNREGISTER_USER;

	// queue it
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


HRESULT UlsLdap_CLocalUser::
SetStdAttrs ( ULONG *puRespID, LDAP_USERINFO *pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	ULONG uMsgID_modify, uMsgID_modrdn;
	UlsLdap_CSession *pSession;
	LDAP *ld;
	HRESULT hr;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, GetServerInfo ());
	if (hr != S_OK)
		return hr;
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Change cn?
	//
	if (pInfo->uOffsetEMailName != 0)
	{
		// Cache user info such that cn is refreshed
		//
		hr = CacheUserInfo (pInfo);
		if (hr != S_OK)
		{
			pSession->Disconnect ();
			return hr;
		}

		// We have to use ldap_modrdn to modify cn and this must be
		// done before any other attribute changes
		//
		uMsgID_modrdn = ldap_modrdn2 (
							ld, GetDN (),
							m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN],
							1);
		if (uMsgID_modrdn == -1)
		{
			pSession->Disconnect ();
			hr = ::LdapError2Hresult (ld->ld_errno);
			return hr;
		}

		// Update DN
		//
		BuildDN ();
	}
	else
	{
		uMsgID_modrdn = INVALID_MSG_ID;
	}

	// Set standard attributes
	//
	hr = UlsLdap_CStdAttrs::SetStdAttrs (	NULL,
											&uMsgID_modify,
											0,
											(VOID *) pInfo,
											GetServerInfo (),
											GetDN ());
	if (hr != S_OK)
	{
		if (uMsgID_modrdn != INVALID_MSG_ID)
		{
			ldap_abandon (ld, uMsgID_modrdn);
			pSession->Disconnect ();
		}
		return hr;
	}

	// Construct a pending info
	//
	PENDING_INFO PendingInfo;
	if (uMsgID_modrdn == INVALID_MSG_ID)
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID_modify, INVALID_MSG_ID);
	else
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID_modrdn, uMsgID_modify);
	PendingInfo.uLdapResType = LDAP_RES_MODIFY;
	PendingInfo.uNotifyMsg = WM_ULS_SET_USER_INFO;
	PendingInfo.hObject = (HANDLE) this; // for DN rollback

	// Queue it
	//
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		if (uMsgID_modrdn != INVALID_MSG_ID)
		{
			ldap_abandon (ld, uMsgID_modrdn);
			pSession->Disconnect ();
		}
		ldap_abandon (ld, uMsgID_modify);
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


VOID UlsLdap_CLocalUser::
RollbackDN ( VOID )
{
	if (m_pszOldDN != NULL)
	{
		MemFree (m_pszDN);
		m_pszDN = m_pszOldDN;
		m_pszOldDN = NULL;
	}
}


HRESULT UlsLdap_CLocalUser::
UpdateIPAddress ( BOOL fPrimary )
{
	// Update cached ip address
	//
	HRESULT hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Update the ip address string
	//
	::GetLongString (m_dwIPAddress, &m_UserInfo.szIPAddress[0]);

	// Update ip address info on the server ONLY if primary
	//
	if (! fPrimary)
		return hr;

	// Update IP address on the server
	//
	return ::IlsUpdateIPAddress (	GetServerInfo (),
									GetDN (),
									(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_IP_ADDRESS],
									&m_UserInfo.szIPAddress[0],
									ISBU_MODOP_MODIFY_USER,
									GetPrefixCount (),
									GetPrefixString ());
}


/* ---------- protected methods ----------- */


HRESULT UlsLdap_CLocalUser::
SendRefreshMsg ( VOID )
{
	if (m_pszRefreshFilter == NULL)
		return ULS_E_POINTER;

	// Get local ip address
	//
	DWORD dwIPAddress = 0;
	HRESULT hr = ::GetLocalIPAddress (&dwIPAddress);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA: cannot get my ip address\r\n"));
		return hr;
	}

	// If dwIPAddress is 0, then we are not on the network any more
	// start relogon process
	//
	if (dwIPAddress == 0)
	{
		MyDebugMsg ((ZONE_KA, "KA: my ip address is null\r\n"));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify this app of the network being down
		//
		PostMessage (g_hWndHidden, WM_ULS_NETWORK_DOWN, TRUE, (LPARAM) this);

		// Report error
		//
		return ULS_E_NETWORK_DOWN;
;
	}
	else
	// If dwIPAddress and m_dwIPAddress, alert
	//
	if (dwIPAddress != m_dwIPAddress)
	{
		// Notify the com to start changing ip address
		// the actual change can happen later
		//
		PostMessage (g_hWndHidden, WM_ULS_IP_ADDRESS_CHANGED, TRUE, (LPARAM) this);
	}

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA: network down, hr=0x%lX\r\n", hr));

		// Indicate that I am not connected to the server anymore
		//
		SetRegLocally ();

		// Second, notify the com of network down
		//
		PostMessage (g_hWndHidden, WM_ULS_NETWORK_DOWN, TRUE, (LPARAM) this);

		// Report error
		//
		return ULS_E_NETWORK_DOWN;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Set attributes to return
	//
	TCHAR *apszAttrNames[3];
	apszAttrNames[0] = STR_CN;
	apszAttrNames[1] = (TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_TTL];
	apszAttrNames[2] = NULL;

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send search query
	//
	MyDebugMsg ((ZONE_KA, "KA: calling ldap_search()...\r\n"));
	ULONG uMsgID = ::ldap_search (ld, (TCHAR *) &c_szDefUserBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									m_pszRefreshFilter,
									&apszAttrNames[0],	// attrs[]
									0	// both type and value
									);
	if (uMsgID == -1)
	{
		MyDebugMsg ((ZONE_KA, "KA: ldap_search() failed\r\n"));
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// Let's wait for the result
	//
	LDAP_TIMEVAL TimeVal;
	TimeVal.tv_usec = 0;
	TimeVal.tv_sec = (m_ServerInfo.nTimeout != 0) ?
							m_ServerInfo.nTimeout :
							90;
	LDAPMessage *pLdapMsg = NULL;
	INT ResultType = ::ldap_result (ld, uMsgID, 0, &TimeVal, &pLdapMsg);

	// Deal with timeout or error
	//
	if (ResultType != LDAP_RES_SEARCH_ENTRY &&
		ResultType != LDAP_RES_SEARCH_RESULT)
	{
		MyDebugMsg ((ZONE_KA, "KA: result type mismatches!\r\n"));
		hr = ULS_E_TIMEOUT;
		goto MyExit;
	}

	if (pLdapMsg != NULL)
	{
		switch (pLdapMsg->lm_returncode)
		{
		case LDAP_NO_SUCH_OBJECT:
			MyDebugMsg ((ZONE_KA, "KA: no such object!\r\n"));

			// Indicate that I am not connected to the server anymore
			//
			SetRegLocally ();

			// Second, notify this app to relogon
			//
			PostMessage (g_hWndHidden, WM_ULS_NEED_RELOGON, TRUE, (LPARAM) this);

			// Report error
			//
			hr = ULS_E_NEED_RELOGON;
			break;

		case LDAP_SUCCESS:
			// Get the new refresh period
			//
			hr = ::IlsParseRefreshPeriod (
						ld,
						pLdapMsg,
						c_apszUserStdAttrNames[ENUM_USERATTR_TTL],
						&m_uTTL);
			break;

		default:
			MyDebugMsg ((ZONE_KA, "KA: unknown lm_returncode=%ld\r\n", pLdapMsg->lm_returncode));
			MyAssert (FALSE);
			break;
		}
	}

MyExit:

	// Free message
	//
	if (pLdapMsg != NULL)
		ldap_msgfree (pLdapMsg);

	// Free up the session
	//
	pSession->Disconnect ();
	return hr;
}


/* ---------- private methods ----------- */


HRESULT UlsLdap_CLocalUser::
CreateRegisterModArr ( LDAPMod ***pppMod )
{
	if (pppMod == NULL)
		return ULS_E_POINTER;

	ULONG cAttrs = COUNT_ENUM_USERATTR;
	ULONG cbMod = ::IlsCalcModifyListSize (cAttrs);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	LDAPMod *pMod;
	for (ULONG i = 0; i < cAttrs; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cAttrs, i);
		(*pppMod)[i] = pMod;
		pMod->mod_op = LDAP_MOD_ADD;

		FillModArrAttr (pMod, i);
	}

// the following overwrote givenname attribute
//	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_ADD);
	(*pppMod)[cAttrs] = NULL;
	return S_OK;
}


HRESULT UlsLdap_CLocalUser::
CreateSetStdAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);
	DWORD dwFlags = m_UserInfo.dwFlags;

	HRESULT hr;
	ULONG cTotal = 0;
	hr = ::FillDefStdAttrsModArr (	pppMod,
									dwFlags,
									COUNT_ENUM_USERINFO,
									&cTotal,
									ISBU_MODOP_MODIFY_USER,
									GetPrefixCount (),
									GetPrefixString ());
	if (hr != S_OK)
		return hr;

	// Start indexing
	//
	ULONG i = GetPrefixCount ();

	// Fill in standard attributes
	//
	if (dwFlags & USEROBJ_F_FIRST_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_FIRST_NAME);

	if (dwFlags & USEROBJ_F_LAST_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_LAST_NAME);

	if (dwFlags & USEROBJ_F_EMAIL_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_EMAIL_NAME);

	if (dwFlags & USEROBJ_F_CITY_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_CITY_NAME);

	if (dwFlags & USEROBJ_F_COUNTRY_NAME)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_COUNTRY_NAME);

	if (dwFlags & USEROBJ_F_COMMENT)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_COMMENT);

	if (dwFlags & USEROBJ_F_IP_ADDRESS)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_IP_ADDRESS);

	if (dwFlags & USEROBJ_F_FLAGS)
		FillModArrAttr ((*pppMod)[i++], ENUM_USERATTR_FLAGS);

	MyAssert (i == cTotal);

	return S_OK;
}


VOID UlsLdap_CLocalUser::
FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx )
{
	pMod->mod_type = (TCHAR *) c_apszUserStdAttrNames[AttrIdx];

	// single valued attr
	TCHAR **ppsz = (TCHAR **) (pMod + 1);
	pMod->mod_values = ppsz;
	*ppsz++ = (m_UserInfo.apszStdAttrValues[AttrIdx] != NULL) ?
				m_UserInfo.apszStdAttrValues[AttrIdx] :
				(TCHAR *) &c_szEmptyString[0];

	*ppsz = NULL;
}


HRESULT UlsLdap_CLocalUser::
CacheInfo ( VOID *pInfo )
{
	return CacheUserInfo ((LDAP_USERINFO *) pInfo);
}


HRESULT UlsLdap_CLocalUser::
CacheUserInfo ( LDAP_USERINFO *pInfo )
{
	ZeroMemory (&m_UserInfo, sizeof (m_UserInfo));
	TCHAR *pszName;

	if (pInfo->uOffsetName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN] = pszName;
		// m_UserInfo.dwFlags |= USEROBJ_F_NAME;
	}

	if (pInfo->uOffsetFirstName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetFirstName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_FIRST_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_FIRST_NAME;
	}

	if (pInfo->uOffsetLastName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetLastName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_LAST_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_LAST_NAME;
	}

	if (pInfo->uOffsetEMailName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetEMailName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_EMAIL_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_EMAIL_NAME;
	}

	if (pInfo->uOffsetCityName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCityName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CITY_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_CITY_NAME;
	}

	if (pInfo->uOffsetCountryName != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCountryName);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_COUNTRY_NAME] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_COUNTRY_NAME;
	}

	if (pInfo->uOffsetComment != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetComment);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_COMMENT] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_COMMENT;
	}

	if (pInfo->uOffsetIPAddress != INVALID_OFFSET)
	{
		pszName = (TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetIPAddress);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_IP_ADDRESS] = pszName;
		m_UserInfo.dwFlags |= USEROBJ_F_IP_ADDRESS;
	}

	if (pInfo->dwFlags != INVALID_USER_FLAGS)
	{
		::GetLongString (pInfo->dwFlags, &m_UserInfo.szFlags[0]);
		m_UserInfo.apszStdAttrValues[ENUM_USERATTR_FLAGS] = &m_UserInfo.szFlags[0];
		m_UserInfo.dwFlags |= USEROBJ_F_FLAGS;
	}

	return S_OK;
}


HRESULT UlsLdap_CLocalUser::
BuildDN ( VOID )
{
	MyAssert (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN] != NULL);

	TCHAR szDN[MAX_DN_LENGTH];
	szDN[0] = TEXT ('\0');

	TCHAR *pszDN = &szDN[0];

	if (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN] != NULL)
	{
		wsprintf (pszDN, TEXT ("%s=%s"),
					STR_CN, m_UserInfo.apszStdAttrValues[ENUM_USERATTR_CN]);
		pszDN += lstrlen (pszDN);
	}

	if (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_O] != NULL)
	{
		wsprintf (pszDN, TEXT (", %s=%s"),
					STR_O, m_UserInfo.apszStdAttrValues[ENUM_USERATTR_O]);
		pszDN += lstrlen (pszDN);
	}

	if (m_UserInfo.apszStdAttrValues[ENUM_USERATTR_C] != NULL)
	{
		wsprintf (pszDN, TEXT (", %s=%s"),
					STR_C, m_UserInfo.apszStdAttrValues[ENUM_USERATTR_C]);
		pszDN += lstrlen (pszDN);
	}

	wsprintf (pszDN, TEXT (", %s"), &c_szDefUserBaseDN[0]);

	TCHAR *psz = My_strdup (&szDN[0]);
	if (psz == NULL)
		return ULS_E_MEMORY;

	MemFree (m_pszOldDN);
	m_pszOldDN = m_pszDN;
	m_pszDN = psz;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spluser.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spluser.h
	Content:	This file contains the local user object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_USEROBJ_H_
#define _ULS_SP_USEROBJ_H_

#include <pshpack8.h>

enum
{
	ENUM_USERATTR_CN,
	ENUM_USERATTR_FIRST_NAME,
	ENUM_USERATTR_LAST_NAME,
	ENUM_USERATTR_EMAIL_NAME,
	ENUM_USERATTR_CITY_NAME,
#ifdef USE_DEFAULT_COUNTRY
	ENUM_USERATTR_COUNTRY_NAME,
#endif
	ENUM_USERATTR_COMMENT,
	ENUM_USERATTR_IP_ADDRESS,
	ENUM_USERATTR_FLAGS,
	ENUM_USERATTR_C,

	/* -- the above are resolvable -- */

	ENUM_USERATTR_CLIENT_SIG,
	ENUM_USERATTR_TTL,

	/* -- the above are changeable standard attributes for RTPerson -- */

	ENUM_USERATTR_OBJECT_CLASS,
	ENUM_USERATTR_O,
	COUNT_ENUM_USERATTR
};


#ifdef USE_DEFAULT_COUNTRY
#else
#define ENUM_USERATTR_COUNTRY_NAME		ENUM_USERATTR_C
#endif


#define COUNT_ENUM_USERINFO			(ENUM_USERATTR_TTL + 1) // exclude uid, o, c
#define COUNT_ENUM_DIRUSERINFO		(ENUM_USERATTR_C + 1)	// count of attrs in dir dlg
#define COUNT_ENUM_RESUSERINFO		(ENUM_USERATTR_C + 1)	// count of attrs resolvable

extern const TCHAR *c_apszUserStdAttrNames[];

#define STR_CN		(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_CN]
#define STR_O		(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_O]
#define STR_C		(TCHAR *) c_apszUserStdAttrNames[ENUM_USERATTR_C]

#define USEROBJ_F_NAME			0x0001
#define USEROBJ_F_FIRST_NAME	0x0002
#define USEROBJ_F_LAST_NAME		0x0004
#define USEROBJ_F_EMAIL_NAME	0x0008
#define USEROBJ_F_CITY_NAME		0x0010
#define USEROBJ_F_COUNTRY_NAME	0x0020
#define USEROBJ_F_COMMENT		0x0040
#define USEROBJ_F_IP_ADDRESS	0x0080
#define USEROBJ_F_FLAGS			0x0100

typedef struct
{
	DWORD	dwFlags;
	TCHAR	*apszStdAttrValues[COUNT_ENUM_USERATTR];
	TCHAR	szIPAddress[INTEGER_STRING_LENGTH];
	TCHAR	szFlags[INTEGER_STRING_LENGTH];
	TCHAR	szTTL[INTEGER_STRING_LENGTH];
	TCHAR	szClientSig[INTEGER_STRING_LENGTH];
}
	USER_INFO;


#define USEROBJ_SIGNATURE	((ULONG) 0x12345678UL)


class UlsLdap_CLocalUser : public UlsLdap_CStdAttrs
{
	friend class UlsLdap_CRefreshScheduler;
	friend class UlsLdap_CLocalApp;
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CLocalUser ( VOID );
	~UlsLdap_CLocalUser ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG *puRespID, SERVER_INFO *pServerInfo, LDAP_USERINFO *pInfo );
	HRESULT UnRegister ( ULONG *puRespID );
	HRESULT SetStdAttrs ( ULONG *puRespID, LDAP_USERINFO *pInfo );
	HRESULT UpdateIPAddress ( BOOL fPrimary );

	VOID SetRegNone ( VOID ) { m_RegStatus = ULS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ULS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ULS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ULS_REG_STATUS_NONE); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_LOCALLY); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ULS_REG_STATUS_REMOTELY); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == USEROBJ_SIGNATURE; }

	VOID RollbackDN ( VOID );

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }

	ULONG GetTTL ( VOID ) { return m_uTTL; }


protected:

	TCHAR *GetDN ( VOID ) { return m_pszDN; }

	ULONG GetPrefixCount ( VOID ) { return 1; }
	TCHAR *GetPrefixString ( VOID ) { return g_pszUserPrefix; }

	HRESULT SendRefreshMsg ( VOID );

private:

	HRESULT CacheInfo ( VOID *pInfo );
	HRESULT CacheUserInfo ( LDAP_USERINFO *pInfo );
	HRESULT CreateRegisterModArr ( LDAPMod ***pppMod );
	HRESULT CreateSetStdAttrsModArr ( LDAPMod ***pppMod );
	VOID FillModArrAttr ( LDAPMod *pMod, LONG AttrIdx );
	HRESULT BuildDN ( VOID );

	ULONG		m_uSignature;
	LONG		m_cRefs;

	USER_INFO	m_UserInfo;

	SERVER_INFO	m_ServerInfo;
	TCHAR		*m_pszDN;
	TCHAR		*m_pszOldDN;
	TCHAR		*m_pszRefreshFilter;

	REG_STATUS	m_RegStatus;

	DWORD		m_dwIPAddress;
	ULONG		m_uTTL;
};


#include <poppack.h>

#endif // _ULS_SP_USEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spnotify.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spnotify.cpp
	Content:	This file contains the notification handlers.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


typedef struct
{
	TCHAR	*pszName;
	TCHAR	*pszValue;
}
	ATTR_PAIR;

typedef struct
{
	ULONG		cMaxAttrs;
	ULONG		cCurrAttrs;
	ATTR_PAIR	aPairs[1];
}
	ATTR_PAIRS;	

typedef struct
{
	CLIENT_INFO	ClientInfo;
	ATTR_PAIRS	Attrs;
}
	CLIENT_INFO_ATTRS;


#ifdef ENABLE_MEETING_PLACE
typedef struct
{
	MTG_INFO	MtgInfo;
	ATTR_PAIRS	Attrs;
}
	MTG_INFO_ATTRS;
#endif


ULONG
GetUniqueNotifyID ( VOID )
{
	// Always positive number
	//
	if (g_uRespID & 0x80000000UL)
		g_uRespID = 1;

	return g_uRespID++;
}


BOOL
NotifyGeneric (
	HRESULT			hrServer,
	SP_CResponse	*pItem )
{
	MyAssert (pItem != NULL);

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Do not use the result (pLdapMsg)
	//

	// Check dependency such as modify/modrdn
	//
	if (pInfo->uMsgID[0] != INVALID_MSG_ID)
	{
		// Do we wait for the second result?
		// If so, remember the hr from the first result.
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
		{
			// We need two results; the first one just comes in.
			// We still need to wait for the second one
			//
			pInfo->uMsgID[0] = INVALID_MSG_ID;
			pInfo->hrDependency = hrServer;

			// Don't destroy this item
			//
			return FALSE;
		}
	}
	else
	{
		// This is the second result
		//
		MyAssert (pInfo->uMsgID[1] != INVALID_MSG_ID);

		// Propagate the hr from the first result if needed
		//
		if (pInfo->hrDependency != S_OK)
			hrServer = pInfo->hrDependency;
	}

	// Post the result to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, hrServer);

	// Destroy this pending item
	//
	return TRUE;
}


BOOL
NotifyRegister (
	HRESULT			hrServer,
	SP_CResponse	*pItem )
{
	MyAssert (pItem != NULL);

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Get the object of user/app/prot/mtg
	//
	HANDLE hObject = pInfo->hObject;
	MyAssert (hObject != NULL);

	// Do not use the result (pLdapMsg)
	//

	// Check dependency such as modify/modrdn
	//
	if (pInfo->uMsgID[0] != INVALID_MSG_ID)
	{
		// Do we wait for the second result?
		// If so, remember the hr from the first result.
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
		{
			// We need two results; the first one just comes in.
			// We still need to wait for the second one
			//
			pInfo->uMsgID[0] = INVALID_MSG_ID;
			pInfo->hrDependency = hrServer;

			// Don't destroy this item
			//
			return FALSE;
		}
	}
	else
	{
		// This is the second result
		//
		MyAssert (pInfo->uMsgID[1] != INVALID_MSG_ID);

		// Propagate the hr from the first result if needed
		//
		if (pInfo->hrDependency != S_OK)
			hrServer = pInfo->hrDependency;
	}

	// Notify the object of success/failure
	//
	SP_CClient *pClient;
	SP_CProtocol *pProt;
#ifdef ENABLE_MEETING_PLACE
	SP_CMeeting *pMtg;
#endif
	if (hrServer != S_OK)
	{
		// Release the object when failure
		//
		switch (pInfo->uNotifyMsg)
		{
		case WM_ILS_REGISTER_CLIENT:
			pClient = (SP_CClient *) hObject;
			if (pClient->IsValidObject ())
			{
				pClient->Release ();
			}
			break;
		case WM_ILS_REGISTER_PROTOCOL:
			pProt = (SP_CProtocol *) hObject;
			if (pProt->IsValidObject ())
			{
				pProt->Release ();
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_REGISTER_MEETING:
			pMtg = (SP_CMeeting *) hObject;
			if (pMtg->IsValidObject ())
			{
				pMtg->Release ();
			}
			break;
#endif
		default:
			MyAssert (FALSE);
			break;
		}
	}
	else
	{
		// Set as successful registration when success
		//
		switch (pInfo->uNotifyMsg)
		{
		case WM_ILS_REGISTER_CLIENT:
			pClient = (SP_CClient *) hObject;
			if (pClient->IsValidObject ())
			{
				pClient->SetRegRemotely ();

				if (g_pRefreshScheduler != NULL)
				{
					g_pRefreshScheduler->EnterClientObject (pClient);
				}
				else
				{
					MyAssert (FALSE);
				}
			}
			break;
		case WM_ILS_REGISTER_PROTOCOL:
			pProt = (SP_CProtocol *) hObject;
			if (pProt->IsValidObject ())
			{
				pProt->SetRegRemotely ();
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_REGISTER_MEETING:
			pMtg = (SP_CMeeting *) hObject;
			if (pMtg->IsValidObject ())
			{
				pMtg->SetRegRemotely ();

				if (g_pRefreshScheduler != NULL)
				{
					g_pRefreshScheduler->EnterMtgObject (pMtg);
				}
				else
				{
					MyAssert (FALSE);
				}
			}
			break;
#endif
		default:
			MyAssert (FALSE);
			break;
		}
	}

	// Post the result to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) hrServer);

	// Destroy this pending item
	//
	return TRUE;
}


/* =========== ENUMERATION ============ */

typedef struct
{
	ULONG		uEnumUsers; // WM_ILS_ENUM_USERS, WM_ILS_ENUM_USERINFOS, or 0
	ULONG		cItems;
	ULONG		cbEntrySize;
	BYTE		bData[8];	// data starting from here
}
	ENUM_LIST;


extern HRESULT CacheEnumInfos ( ULONG uNotifyMsg, LDAP *ld, LDAPMessage *pEntry, VOID *p );
extern VOID BuildEnumObjectNames ( LDAP_ENUM *pEnum, ENUM_LIST *pEnumList );
extern VOID BuildEnumClientInfos ( LDAP_ENUM *pEnum, ENUM_LIST *pEnumList );
extern VOID SizeEnumClientInfos ( ULONG *pcbTotalSize, CLIENT_INFO_ATTRS *pcia );
extern VOID TotalSizeEnumObjectNames ( ULONG *pcbTotalSize, ULONG cEntries, TCHAR **appszObjectNames[] );
extern VOID FreeStdAttrCache ( TCHAR *apszStdAttrValues[], ULONG cStdAttrs );
extern VOID FreeAttrPairArrayCache ( ATTR_PAIR aAttrPair[], ULONG cPairs );
extern VOID CacheAnyAttrNamesInAttrPairs ( ULONG cNames, TCHAR *pszSrcNameList, ATTR_PAIR aAttrPairs[] );
#ifdef ENABLE_MEETING_PLACE
extern VOID BuildEnumMtgInfos ( LDAP_ENUM *pEnum, ENUM_LIST *pEnumList );
extern VOID SizeEnumMtgInfos ( ULONG *pcbTotalSize, MTG_INFO_ATTRS *pmia );
#endif


BOOL NotifyEnumX (
	ULONG			uEnumType,
	HRESULT			hrServer,
	SP_CResponse	*pItem,
	TCHAR			*pszRetAttrName ) // returned attribute's name
{
	MyAssert (pItem != NULL);

#if defined (DEBUG) || defined (_DEBUG)
	// Consistency checks
	//
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTS:
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGS:
#endif
		MyAssert (pszRetAttrName != NULL && *pszRetAttrName != TEXT ('\0'));
		break;		
	case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
#endif
		MyAssert (pszRetAttrName == NULL);
		break;
	default:
		MyAssert (FALSE);
		break;
	}
#endif

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_ENUM *pEnum = NULL;
	ENUM_LIST *pEnumList = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Initialize the total size of LDAP_ENUM
	//
	ULONG cbTotalSize;
	cbTotalSize =	sizeof (LDAP_ENUM) +	// the minimal info
					sizeof (TCHAR); 		// the last null terminator

	// Let's get the count of entries in this result set
	//
	ULONG cEntries, i;
	cEntries = ldap_count_entries (ld, pLdapMsg);

	// Return now if there is nothing to handle
	//
	if (cEntries <= 0)
	{
		// I want to make sure this case happens or not
		//
		MyAssert (cEntries == 0);

		// Simply return without deleting this pending item
		//
		return FALSE;
	}

	// In the following, we only deal with the case (cEntries > 0)
	//

	// Calculate enum list size
	//
	ULONG cbEntrySize , cbSizeEnumList;
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		cbEntrySize = sizeof (CLIENT_INFO_ATTRS) +
						pInfo->cAnyAttrs * sizeof (ATTR_PAIR);
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		cbEntrySize = sizeof (MTG_INFO_ATTRS) +
						pInfo->cAnyAttrs * sizeof (ATTR_PAIR);
		break;
#endif
	default:
		cbEntrySize = sizeof (TCHAR **);
		break;
	}
	cbSizeEnumList = sizeof (ENUM_LIST) + cEntries * cbEntrySize;

	// Allocate the enum list that is a temporary cache
	// for all attributes from wldap32.dll
	//
	pEnumList = (ENUM_LIST *) MemAlloc (cbSizeEnumList);
	if (pEnumList == NULL)
	{
		// Fails probably due to insane cbSizeEnumList
		//
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in enum list
	//
	pEnumList->uEnumUsers = uEnumType;
	pEnumList->cItems = cEntries;
	pEnumList->cbEntrySize = cbEntrySize;

	// Fill in names of extended attributes if needed
	//
	if (pInfo->cAnyAttrs > 0)
	{
		switch (uEnumType)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
			for (i = 0; i < cEntries; i++)
			{
				CLIENT_INFO_ATTRS *p = (CLIENT_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);
				p->Attrs.cMaxAttrs = pInfo->cAnyAttrs;
				CacheAnyAttrNamesInAttrPairs (	pInfo->cAnyAttrs,
												pInfo->pszAnyAttrNameList,
												&(p->Attrs.aPairs[0]));
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
			for (i = 0; i < cEntries; i++)
			{
				MTG_INFO_ATTRS *p = (MTG_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);
				p->Attrs.cMaxAttrs = pInfo->cAnyAttrs;
				CacheAnyAttrNamesInAttrPairs (	pInfo->cAnyAttrs,
												pInfo->pszAnyAttrNameList,
												&(p->Attrs.aPairs[0]));
			}
			break;
#endif
		default:
			break;
		}
	}

	// Get the first entry
	//
	LDAPMessage *pEntry;
	pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Cache the attributes in the first entry
	//
	TCHAR ***appszObjectNames;
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
#endif
		hrServer = CacheEnumInfos (uEnumType, ld, pEntry, (VOID *) &(pEnumList->bData[0]));
		if (hrServer != S_OK)
		{
			MyAssert (FALSE);
			goto MyExit;
		}
		break;
	default:
		appszObjectNames = (TCHAR ***) &(pEnumList->bData[0]);
		appszObjectNames[0] = my_ldap_get_values (ld, pEntry, pszRetAttrName);
		if (appszObjectNames[0] == NULL)
		{
			MyAssert (FALSE);
			hrServer = ILS_E_MEMORY;
			goto MyExit;
		}
		break;
	} // switch (uEnumType)

	// Loop through the other entries
	//
	for (i = 1; i < cEntries; i++)
	{
		// Next entry, please
		//
		pEntry = ldap_next_entry (ld, pEntry);
		if (pEntry == NULL)
		{
			MyAssert (FALSE);

			// Failed, adjust the count to return partial result
			//
			pEnumList->cItems = cEntries = i;
			break;
		}

		// Cache the attributes in the subsequent entries
		//
		switch (uEnumType)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
#endif
			hrServer = CacheEnumInfos (uEnumType, ld, pEntry, (CLIENT_INFO_ATTRS *)
							(&(pEnumList->bData[0]) + i * cbEntrySize));
			if (hrServer != S_OK)
			{
				MyAssert (FALSE);
				goto MyExit;
			}
			break;
		default:
			appszObjectNames[i] = my_ldap_get_values (ld, pEntry, pszRetAttrName);
			if (appszObjectNames[i] == NULL)
			{
				MyAssert (FALSE);
				hrServer = ILS_E_MEMORY;
				goto MyExit;
			}
			break;
		} // switch (uEnumType)
	} // for (i = 1; i < cEntries; i++)

	// We just cache all the attribute names and values.
	// Now, we need to calculate the total size of the return buffer.
	//

	// Calculate the total size of the LDAP_ENUM structure...
	//
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		for (i = 0; i < cEntries; i++)
		{
			SizeEnumClientInfos (&cbTotalSize, (CLIENT_INFO_ATTRS *)
						(&(pEnumList->bData[0]) + i * cbEntrySize));
		}
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		for (i = 0; i < cEntries; i++)
		{
			SizeEnumMtgInfos (&cbTotalSize, (MTG_INFO_ATTRS *)
								(&(pEnumList->bData[0]) + i * cbEntrySize));
		}
		break;
#endif
	default:
		TotalSizeEnumObjectNames (&cbTotalSize, cEntries, &(appszObjectNames[0]));
		break;
	} // switch (uEnumType)

	// Allocate the returned LDAP_ENUM structure
	//
	pEnum = (LDAP_ENUM *) MemAlloc (cbTotalSize);
	if (pEnum == NULL)
	{
		// Fails probably due to insane cbTotalSize
		//
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in LDAP_ENUM common fields
	//
	pEnum->uSize = sizeof (*pEnum);
	pEnum->hResult = hrServer;
	pEnum->cItems = cEntries;
	pEnum->uOffsetItems = sizeof (*pEnum);

	// Fill in LDAP_ENUM items
	//
	switch (uEnumType)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		BuildEnumClientInfos (pEnum, pEnumList);
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		BuildEnumMtgInfos (pEnum, pEnumList);
		break;
#endif
	default:
		BuildEnumObjectNames (pEnum, pEnumList);
		break;
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free the temporary cache
	//
	if (pEnumList != NULL)
	{
		switch (uEnumType)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
			for (i = 0; i < pEnumList->cItems; i++)
			{
				CLIENT_INFO_ATTRS *p = (CLIENT_INFO_ATTRS *)
							(&(pEnumList->bData[0]) + i * cbEntrySize);

				// Free standard attributes
				//
				FreeStdAttrCache (&(p->ClientInfo.apszStdAttrValues[0]), COUNT_ENUM_DIR_CLIENT_INFO);

				// Free extended attributes
				//
				FreeAttrPairArrayCache (&(p->Attrs.aPairs[0]), pInfo->cAnyAttrs);
			}
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
			for (i = 0; i < pEnumList->cItems; i++)
			{
				MTG_INFO_ATTRS *p = (MTG_INFO_ATTRS *)
										(&(pEnumList->bData[0]) + i * cbEntrySize);

				// Free standard attributes
				//
				FreeStdAttrCache (&(p->MtgInfo.apszStdAttrValues[0]), COUNT_ENUM_DIRMTGINFO);

				// Free extended attributes
				//
				FreeAttrPairArrayCache (&(p->Attrs.aPairs[0]), pInfo->cAnyAttrs);
			}
			break;
#endif
		default:
			for (i = 0; i < pEnumList->cItems; i++)
			{
				if (appszObjectNames[i] != NULL)
					ldap_value_free (appszObjectNames[i]);
			}
			break;
		}
		MemFree (pEnumList);
	} // if

	// Clean up if failure
	//
	if (hrServer != S_OK)
	{
		// Special treatment of enum termination for wldap32.dll
		//
		if (hrServer == ILS_E_PARAMETER)
		{
			MemFree (pEnum);
			pEnum = NULL; // enum termination
		}
		else
		{
			// Make sure we have at least LDAP_ENUM buffer to return
			//
			if (pEnum != NULL)
				ZeroMemory (pEnum, sizeof (*pEnum));
			else
				pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));

			// Set up the LDAP_ENUM info
			//
			if (pEnum != NULL)
			{
				pEnum->uSize = sizeof (*pEnum);
				pEnum->hResult = hrServer;
			}
		}

		// Force to delete this pending item
		//
		cEntries = 0;
	}

	// Post a message to the com layer of this enum result
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pEnum);

	return (cEntries == 0);
}


BOOL
NotifyEnumClients (
	HRESULT				hrServer,
	SP_CResponse		*pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_CLIENTS,
						hrServer,
						pItem,
						STR_CLIENT_CN);
}


BOOL
NotifyEnumClientInfos (
	HRESULT				hrServer,
	SP_CResponse		*pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_CLIENTINFOS,
						hrServer,
						pItem,
						NULL);
}


BOOL NotifyEnumProts ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Clean up locals
	//
	LDAP_ENUM *pEnum = NULL;
	TCHAR **apszProtNames = NULL;

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	MyAssert (pLdapMsg != NULL);
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the array
	//
	apszProtNames = my_ldap_get_values (ld, pLdapMsg, STR_PROT_NAME);
	if (apszProtNames == NULL)
	{
		hrServer = ILS_E_NO_SUCH_OBJECT;
		goto MyExit;
	}

	// Initialize minimal info size
	//
	ULONG cbEnumList;
	cbEnumList = sizeof (LDAP_ENUM) +	// the minimal info
				 sizeof (TCHAR);   		// the last null terminator

	// Let's see how many strings in the array
	//
	ULONG cNames;
	for (cNames = 0; apszProtNames[cNames] != NULL; cNames++)
	{
		cbEnumList += (lstrlen (apszProtNames[cNames]) + 1) * sizeof (TCHAR);
	}

	// Allocate the enum structure
	//
	pEnum = (LDAP_ENUM *) MemAlloc (cbEnumList);
	if (pEnum == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in header
	//
	pEnum->uSize = sizeof (*pEnum);
	pEnum->hResult = hrServer;
	pEnum->cItems = cNames;
	pEnum->uOffsetItems = sizeof (*pEnum);

	// Fill in name strings
	//
	ULONG i;
	TCHAR *pszName;
	pszName = (TCHAR *) (pEnum + 1);
	for (i = 0; i < cNames; i++)
	{
		My_lstrcpy (pszName, apszProtNames[i]);
		pszName += lstrlen (pszName) + 1;
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free the array if allocated
	//
	if (apszProtNames != NULL)
		ldap_value_free (apszProtNames);

	// Post messages back to the COM layer
	//
	if (hrServer != S_OK)
	{
		// Make sure we have at least LDAP_ENUM buffer to return
		//
		if (pEnum != NULL)
			ZeroMemory (pEnum, sizeof (*pEnum));
		else
			pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));

		// Set up the LDAP_ENUM info
		//
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hrServer;
		}
	}

	// Post a message to the com layer of this enum result
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pEnum);

	// Terminate enumeration if success
	//
	if (hrServer == S_OK)
	{
		PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) NULL);
	}

	// Destroy this pending item
	//
	return TRUE;
}


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyEnumMtgs ( HRESULT hrServer, SP_CResponse *pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_MEETINGS,
						hrServer,
						pItem,
						STR_MTG_NAME);
}
#endif


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyEnumMtgInfos ( HRESULT hrServer, SP_CResponse *pItem )
{
	return NotifyEnumX (WM_ILS_ENUM_MEETINGINFOS,
						hrServer,
						pItem,
						NULL);
}
#endif


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyEnumAttendees ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_ENUM *pEnum = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Initialize the total size of LDAP_ENUM
	//
	ULONG cbTotalSize;
	cbTotalSize =	sizeof (LDAP_ENUM) +	// the minimal info
					sizeof (TCHAR); 		// the last null terminator

	// Get the first entry that we care about
	//
	LDAPMessage *pEntry;
	pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Get the Members attribute
	//
	ULONG cItems;
	cItems = 0;
	TCHAR **apszMembers;
	apszMembers = my_ldap_get_values (ld, pEntry, STR_MTG_MEMBERS);
	if (apszMembers != NULL)
	{
		// Find out how many attendees
		//
		for (TCHAR **ppsz = apszMembers; *ppsz != NULL; ppsz++)
		{
			cItems++;
			cbTotalSize += (lstrlen (*ppsz) + 1) * sizeof (TCHAR);
		}
	}

	// Allocate the returned LDAP_ENUM structure
	//
	pEnum = (LDAP_ENUM *) MemAlloc (cbTotalSize);
	if (pEnum == NULL)
	{
		// Fails probably due to insane cbTotalSize
		//
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in LDAP_ENUM common fields
	//
	pEnum->uSize = sizeof (*pEnum);
	pEnum->hResult = hrServer;
	pEnum->cItems = cItems;
	pEnum->uOffsetItems = sizeof (*pEnum);

	// Fill in LDAP_ENUM items
	//
	TCHAR *pszDst;
	ULONG i;
	pszDst = (TCHAR *) (pEnum + 1);
	for (i = 0; i < cItems; i++)
	{
		lstrcpy (pszDst, apszMembers[i]);
		pszDst += lstrlen (pszDst) + 1;
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Clean up if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have at least LDAP_ENUM buffer to return
		//
		if (pEnum != NULL)
			ZeroMemory (pEnum, sizeof (*pEnum));
		else
			pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));

		// Fill in the minimal info
		//
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hrServer;
		}
	}

	// Post a message to the com layer of this enum result
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pEnum);

	// Delete this pending item
	//
	return TRUE;
}
#endif // ENABLE_MEETING_PLACE



VOID CacheEnumClientInfoAttr (
	CLIENT_INFO_ATTRS	*puia,
	TCHAR				*pszAttrName,
	TCHAR				**ppszAttrValue )
{
	ULONG i;

	// See if this attribute is arbitrary?
	//
	if (IlsIsAnyAttrName (pszAttrName) != NULL)
	{
		// Deal with extended attributes
		//
		for (i = 0; i < puia->Attrs.cMaxAttrs; i++)
		{
			if (My_lstrcmpi (pszAttrName, puia->Attrs.aPairs[i].pszName) == 0)
			{
				puia->Attrs.aPairs[i].pszValue = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
	else
	{
		// Deal with standard attributes
		//
		for (i = 0; i < COUNT_ENUM_DIR_CLIENT_INFO; i++)
		{
			if (My_lstrcmpi (pszAttrName, c_apszClientStdAttrNames[i]) == 0)
			{
				puia->ClientInfo.apszStdAttrValues[i] = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
}


#ifdef ENABLE_MEETING_PLACE
VOID CacheEnumMtgInfoAttr (
	MTG_INFO_ATTRS		*pmia,
	TCHAR				*pszAttrName,
	TCHAR				**ppszAttrValue )
{
	ULONG i;

	// See if this attribute is arbitrary?
	//
	if (IlsIsAnyAttrName (pszAttrName) != NULL)
	{
		// Deal with extended attributes
		//
		for (i = 0; i < pmia->Attrs.cMaxAttrs; i++)
		{
			if (My_lstrcmpi (pszAttrName, pmia->Attrs.aPairs[i].pszName) == 0)
			{
				pmia->Attrs.aPairs[i].pszValue = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
	else
	{
		// Deal with standard attributes
		//
		for (i = 0; i < COUNT_ENUM_DIRMTGINFO; i++)
		{
			if (My_lstrcmpi (pszAttrName, c_apszMtgStdAttrNames[i]) == 0)
			{
				pmia->MtgInfo.apszStdAttrValues[i] = (TCHAR *) ppszAttrValue;
				break;
			}
		}
	}
}
#endif // ENABLE_MEETING_PLACE


HRESULT CacheEnumInfos (
	ULONG			uNotifyMsg,
	LDAP			*ld,
	LDAPMessage		*pEntry,
	VOID			*p )
{
	MyAssert (ld != NULL);
	MyAssert (pEntry != NULL);
	MyAssert (p != NULL);

	struct berelement *pContext = NULL;

	// Examine the first attribute
	//
	TCHAR *pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
	TCHAR **ppszAttrValue = ldap_get_values (ld, pEntry, pszAttrName);
	if (ppszAttrValue == NULL)
		return ILS_E_MEMORY;

	// Cache the first attribute
	//
	switch (uNotifyMsg)
	{
	case WM_ILS_ENUM_CLIENTINFOS:
		CacheEnumClientInfoAttr (	(CLIENT_INFO_ATTRS *) p,
									pszAttrName, ppszAttrValue);
		break;
#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_ENUM_MEETINGINFOS:
		CacheEnumMtgInfoAttr (	(MTG_INFO_ATTRS *) p,
								pszAttrName, ppszAttrValue);
		break;
#endif
	default:
		MyAssert (FALSE);
		break;
	}

	// Step through the others
	//
	while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext))
			!= NULL)
	{
		// Examine the other attributes one by one
		//
		ppszAttrValue = ldap_get_values (ld, pEntry, pszAttrName);
		if (ppszAttrValue == NULL)
			return ILS_E_MEMORY;

		// Cache the other attributes one by one
		//
		switch (uNotifyMsg)
		{
		case WM_ILS_ENUM_CLIENTINFOS:
			CacheEnumClientInfoAttr (	(CLIENT_INFO_ATTRS *) p,
										pszAttrName, ppszAttrValue);
			break;
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGINFOS:
			CacheEnumMtgInfoAttr (	(MTG_INFO_ATTRS *) p,
									pszAttrName, ppszAttrValue);
			break;
#endif
		default:
			MyAssert (FALSE);
			break;
		}
	}

	return S_OK;
}


VOID
BuildEnumObjectNames (
	LDAP_ENUM			*pEnum,
	ENUM_LIST			*pEnumList )
{
	MyAssert (pEnum != NULL);
	MyAssert (pEnumList != NULL);

	ULONG cEntries = pEnum->cItems;

	// appszObjectNames are an array of names from server
	//
	TCHAR *pszName = (TCHAR *) (pEnum + 1);
	TCHAR ***appszObjectNames = (TCHAR ***) &(pEnumList->bData[0]);
	for (ULONG i = 0; i < cEntries; i++)
	{
		TCHAR **ppsz = appszObjectNames[i];
		if (ppsz != NULL && *ppsz != NULL)
		{
			My_lstrcpy (pszName, *ppsz);
			pszName += lstrlen (pszName) + 1;
		}
		else
		{
			*pszName++ = TEXT ('\0'); // empty strings
		}
	}
}


VOID
BuildEnumClientInfos (
	LDAP_ENUM			*pEnum,
	ENUM_LIST			*pEnumList )
{
	MyAssert (pEnum != NULL);
	MyAssert (pEnumList != NULL);

	ULONG i, j;

	ULONG cEntries = pEnumList->cItems;
	ULONG cbEntrySize = pEnumList->cbEntrySize;
	LDAP_CLIENTINFO *plci = (LDAP_CLIENTINFO *) (pEnum + 1);
	TCHAR *pszStringBuffer = (TCHAR *) (plci + cEntries);
	TCHAR **ppsz;

	CLIENT_INFO_ATTRS *p;
	ULONG cAttrs;

	// Loop through all entries
	//
	for (i = 0; i < cEntries; i++, plci++)
	{
		// Get to cached structure
		//
		p = (CLIENT_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);

		// Set the size of LDAP_USERINFO
		//
		plci->uSize = sizeof (*plci);

		// Copy the User Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN];
		if (ppsz != NULL)
		{
			plci->uOffsetCN = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the First Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FIRST_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetFirstName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Last Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_LAST_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetLastName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Email Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_EMAIL_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetEMailName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the City Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CITY_NAME];
		if (ppsz != NULL)
		{
			plci->uOffsetCityName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Country Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C];
		if (ppsz != NULL)
		{
			plci->uOffsetCountryName = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Comment Name if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_COMMENT];
		if (ppsz != NULL)
		{
			plci->uOffsetComment = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the IP Address if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS];
		if (ppsz != NULL)
		{
			plci->uOffsetIPAddress = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
			GetIPAddressString (pszStringBuffer, GetStringLong (*ppsz));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Flags if needed
		//
		ppsz = (TCHAR **) p->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FLAGS];
		if (ppsz != NULL)
		{
			plci->dwFlags = (*ppsz != NULL) ?	GetStringLong (*ppsz) :
												INVALID_USER_FLAGS;
		}

		// Copy extended attributes if needed
		//
		plci->cAttrsReturned = cAttrs = p->Attrs.cMaxAttrs;
		plci->uOffsetAttrsReturned = (ULONG)((ULONG_PTR) pszStringBuffer - (ULONG_PTR) plci);
		for (j = 0; j < cAttrs; j++)
		{
			// Extended attribute name
			//
			My_lstrcpy (pszStringBuffer, IlsSkipAnyAttrNamePrefix (
							(const TCHAR *)	p->Attrs.aPairs[j].pszName));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;

			// Extended attribute value
			//
			ppsz = (TCHAR **) p->Attrs.aPairs[j].pszValue;
			if (ppsz != NULL)
			{
				My_lstrcpy (pszStringBuffer, *ppsz);
			}
			else
			{
				ASSERT(FALSE);
			}
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		} // for j
	} // for i
}


#ifdef ENABLE_MEETING_PLACE
VOID BuildEnumMtgInfos (
	LDAP_ENUM			*pEnum,
	ENUM_LIST			*pEnumList )
{
	MyAssert (pEnum != NULL);
	MyAssert (pEnumList != NULL);

	ULONG i, j;

	ULONG cEntries = pEnumList->cItems;
	ULONG cbEntrySize = pEnumList->cbEntrySize;
	LDAP_MEETINFO *plmi = (LDAP_MEETINFO *) (pEnum + 1);
	TCHAR *pszStringBuffer = (TCHAR *) (plmi + cEntries);
	TCHAR **ppsz;

	MTG_INFO_ATTRS *p;
	ULONG cAttrs;

	// Loop through all entries
	//
	for (i = 0; i < cEntries; i++, plmi++)
	{
		// Get to the cache structure
		//
		p = (MTG_INFO_ATTRS *) (&(pEnumList->bData[0]) + i * cbEntrySize);

		// Set the size of LDAP_MEETINFO
		//
		plmi->uSize = sizeof (*plmi);

		// Copy the Meeting Name if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN];
		if (ppsz != NULL)
		{
			plmi->uOffsetMeetingPlaceID = (ULONG) pszStringBuffer - (ULONG) plmi;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Meeting Type if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MTG_TYPE];
		if (ppsz != NULL)
		{
			plmi->lMeetingPlaceType = (*ppsz != NULL) ?	GetStringLong (*ppsz) :
													INVALID_MEETING_TYPE;
		}

		// Copy the Attendee Type if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MEMBER_TYPE];
		if (ppsz != NULL)
		{
			plmi->lAttendeeType = (*ppsz != NULL) ?	GetStringLong (*ppsz) :
													INVALID_ATTENDEE_TYPE;
		}

		// Copy the Description if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_DESCRIPTION];
		if (ppsz != NULL)
		{
			plmi->uOffsetDescription = (ULONG) pszStringBuffer - (ULONG) plmi;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Host Name if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_HOST_NAME];
		if (ppsz != NULL)
		{
			plmi->uOffsetHostName = (ULONG) pszStringBuffer - (ULONG) plmi;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy the Host IP Address if needed
		//
		ppsz = (TCHAR **) p->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS];
		if (ppsz != NULL)
		{
			plmi->uOffsetHostIPAddress = (ULONG) pszStringBuffer - (ULONG) plmi;
			GetIPAddressString (pszStringBuffer, GetStringLong (*ppsz));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		}

		// Copy extended attributes if needed
		//
		plmi->cAttrsReturned = cAttrs = p->Attrs.cMaxAttrs;
		plmi->uOffsetAttrsReturned = (ULONG) pszStringBuffer - (ULONG) plmi;
		for (j = 0; j < cAttrs; j++)
		{
			// Extended attribute name
			//
			My_lstrcpy (pszStringBuffer, IlsSkipAnyAttrNamePrefix (
							(const TCHAR *) p->Attrs.aPairs[j].pszName));
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;

			// Extended attribute value
			//
			ppsz = (TCHAR **) p->Attrs.aPairs[j].pszValue;
			My_lstrcpy (pszStringBuffer, *ppsz);
			pszStringBuffer += lstrlen (pszStringBuffer) + 1;
		} // for j
	} // for i
}
#endif // ENABLE_MEETING_PLACE


VOID TotalSizeEnumObjectNames (
	ULONG			*pcbTotalSize,
	ULONG			cEntries,
	TCHAR			**appszObjectNames[] )
{
	ULONG i, cbThisSize;
	TCHAR **ppsz;

	// Loop through all the entries and compute the total size
	//
	for (i = 0; i < cEntries; i++)
	{
		ppsz = appszObjectNames[i];

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		// lonchanc: BUGS BUGS the size is wrong. need to figure out the exact size
		*pcbTotalSize += sizeof (LDAP_CLIENTINFO) + cbThisSize;
	}
}


VOID SizeEnumClientInfos (
	ULONG				*pcbTotalSize,
	CLIENT_INFO_ATTRS	*pcia )
{
	ULONG i, cbThisSize;
	TCHAR **ppsz;

	// Add up user info header
	//
	*pcbTotalSize += sizeof (LDAP_CLIENTINFO);

	// Add up the total size for standard attributes
	//
	for (i = 0; i < COUNT_ENUM_DIR_CLIENT_INFO; i++)
	{
		// Get the attribute value
		//
		ppsz = (TCHAR **) pcia->ClientInfo.apszStdAttrValues[i];

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Compensate the string length if it is ip address
		//
		if (i == ENUM_CLIENTATTR_IP_ADDRESS)
			cbThisSize += 16;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}

	// Add up the total size for extended attributes
	//
	for (i = 0; i < pcia->Attrs.cMaxAttrs; i++)
	{
		// Get the extended attribute value
		//
		ppsz = (TCHAR **) pcia->Attrs.aPairs[i].pszValue;

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Get the extended attribute name
		//
		cbThisSize += lstrlen (IlsSkipAnyAttrNamePrefix ((const TCHAR *)
									pcia->Attrs.aPairs[i].pszName)) + 1;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}
}


#ifdef ENABLE_MEETING_PLACE
VOID SizeEnumMtgInfos (
	ULONG			*pcbTotalSize,
	MTG_INFO_ATTRS	*pmia )
{
	ULONG i, cbThisSize;
	TCHAR **ppsz;

	// Add up meeting info header
	//
	*pcbTotalSize += sizeof (LDAP_MEETINFO);

	// Add up the total size for standard attributes
	//
	for (i = 0; i < COUNT_ENUM_DIRMTGINFO; i++)
	{
		// Get the standard attribute value
		//
		ppsz = (TCHAR **) pmia->MtgInfo.apszStdAttrValues[i];

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Compensate the string length if it is ip address
		//
		if (i == ENUM_MTGATTR_IP_ADDRESS)
			cbThisSize += 16;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}

	// Add up the total size for extended attributes
	//
	for (i = 0; i < pmia->Attrs.cMaxAttrs; i++)
	{
		// Get the extended attribute value
		//
		ppsz = (TCHAR **) pmia->Attrs.aPairs[i].pszValue;

		// Calcualte the attribute string length
		//
		cbThisSize = 1;
		if (ppsz != NULL && *ppsz != NULL)
			cbThisSize += My_lstrlen (*ppsz);

		// Get the extended attribute name
		//
		cbThisSize += lstrlen (IlsSkipAnyAttrNamePrefix ((const TCHAR *)
									pmia->Attrs.aPairs[i].pszName)) + 1;

		// Convert string length to string size
		//
		cbThisSize *= sizeof (TCHAR);

		// Add up this entry size
		//
		*pcbTotalSize += cbThisSize;
	}
}
#endif // ENABLE_MEETING_PLACE


/* =========== RESOLVE ============ */

typedef HRESULT (INFO_HANDLER) ( VOID *, const TCHAR *, const TCHAR ** );
extern HRESULT CacheResolveClientInfoAttr ( VOID *, const TCHAR *, const TCHAR ** );
extern HRESULT CacheResolveProtInfoAttr ( VOID *, const TCHAR *, const TCHAR ** );
extern HRESULT CacheResolveMtgInfoAttr ( VOID *, const TCHAR *, const TCHAR ** );


BOOL
NotifyResolveX (
	HRESULT			hrServer,
	SP_CResponse	*pItem,
	VOID			*pInfo,
	INFO_HANDLER	*pHandler )
{
	MyAssert (pItem != NULL);
	MyAssert (pInfo != NULL);
	MyAssert (pHandler != NULL);

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg = pItem->GetResult ();
	MyAssert (pLdapMsg != NULL);
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_POINTER;
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the first entry that we care only
	//
	LDAPMessage *pEntry;
	pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize wldap32.dll context
	//
	struct berelement *pContext;
	pContext = NULL;

	// Examine the first attribute
	//
	TCHAR *pszAttrName;
	pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
	if (pszAttrName == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}
	TCHAR **ppszAttrVal;
	ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
	if (ppszAttrVal == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Cache this attribute name (if needed) and value
	//
	HRESULT hr;
	hr = (*pHandler) (pInfo, pszAttrName,(const TCHAR **) ppszAttrVal);
	ldap_value_free (ppszAttrVal);
	if (hr != S_OK)
	{
		hrServer = hr;
		goto MyExit;
	}

	// Step through the other attributes
	//
	while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext))
			!= NULL)
	{
		ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
		if (ppszAttrVal == NULL)
		{
			MyAssert (FALSE);
			hrServer = ILS_E_MEMORY;
			goto MyExit;
		}

		// Cache the other attribute names (if needed) and values
		//
		hr = (*pHandler) (pInfo, pszAttrName, (const TCHAR **) ppszAttrVal);
		ldap_value_free (ppszAttrVal);
		if (hr != S_OK)
		{
			hrServer = hr;
			goto MyExit;
		}
	}

	MyAssert (hrServer == S_OK);

MyExit:

	return hrServer;
}


BOOL
NotifyResolveClient (
	HRESULT			hrServer,
	SP_CResponse	*pItem )
{
	MyAssert (pItem != NULL);
	ULONG i;

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_CLIENTINFO_RES *pClientRes = NULL;
	CLIENT_INFO_ATTRS *pcia = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the count of attributes
	//
	ULONG cAttrs;
	cAttrs = my_ldap_count_1st_entry_attributes (ld, pLdapMsg);
	if (cAttrs == 0)
	{
		hrServer = ILS_E_NO_MORE;
		goto MyExit;
	}

	// Allocate result set holder
	//
	pcia = (CLIENT_INFO_ATTRS *) MemAlloc (
								sizeof (CLIENT_INFO_ATTRS) +
								cAttrs * sizeof (ATTR_PAIR));
	if (pcia == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize result set holder
	//
	pcia->Attrs.cMaxAttrs = cAttrs;

	// Cache resolve set
	//
	hrServer = NotifyResolveX (	hrServer,
								pItem,
								pcia,
								CacheResolveClientInfoAttr);
	if (hrServer != S_OK)
	{
		goto MyExit;
	}

	// Initialize the total size
	//
	ULONG cbTotalSize, cbThisSize;
	cbTotalSize = sizeof (LDAP_CLIENTINFO_RES);

	// Loop through all attributes in order to compute the total size
	//
	for (i = 0; i < COUNT_ENUM_RES_CLIENT_INFO; i++)
	{
		if (pcia->ClientInfo.apszStdAttrValues[i] != NULL)
		{
			// Get the string length
			//
			cbThisSize = My_lstrlen (pcia->ClientInfo.apszStdAttrValues[i]) + 1;

			// Compensate for the ip address
			//
			if (i == ENUM_CLIENTATTR_IP_ADDRESS)
				cbThisSize += 16;

			// Convert string length to string size
			//
			cbThisSize *= sizeof (TCHAR);

			// Add up to the total size
			//
			cbTotalSize += cbThisSize;
		}
	}

	// Loop through extended attributes
	//
	for (i = 0; i < pcia->Attrs.cCurrAttrs; i++)
	{
		cbThisSize = My_lstrlen (pcia->Attrs.aPairs[i].pszName) + 1;
		cbThisSize += My_lstrlen (pcia->Attrs.aPairs[i].pszValue) + 1;
		cbThisSize *= sizeof (TCHAR);
		cbTotalSize += cbThisSize;
	}

	// Allocate LDAP_USERINFO_RES structure
	//
	pClientRes = (LDAP_CLIENTINFO_RES *) MemAlloc (cbTotalSize);
	if (pClientRes == NULL)
	{
		MyAssert (FALSE); // we are in deep trouble here
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in common fields
	//
	pClientRes->uSize = sizeof (*pClientRes);
	pClientRes->hResult = hrServer;
	pClientRes->lci.uSize = sizeof (pClientRes->lci);

	// Prepare to copy strings
	//
	TCHAR *pszDst, *pszSrc;
	pszDst = (TCHAR *) (pClientRes + 1);

	// Copy user object's standard attributes
	//
	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetCN = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FIRST_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetFirstName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_LAST_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetLastName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_EMAIL_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetEMailName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CITY_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetCityName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetCountryName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_COMMENT];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetComment = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetIPAddress = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		GetIPAddressString (pszDst, GetStringLong (pszSrc));
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FLAGS];
	if (pszSrc != NULL)
	{
		pClientRes->lci.dwFlags = (pszSrc != NULL)?	GetStringLong (pszSrc) :
													INVALID_USER_FLAGS;
	}

	// Copy app object's standard attributes
	//
	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetAppName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_MIME_TYPE];
	if (pszSrc != NULL)
	{
		pClientRes->lci.uOffsetAppMimeType = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	pszSrc = pcia->ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_GUID];
	if (MyIsGoodString (pszSrc))
	{
		GetStringGuid (pszSrc, &(pClientRes->lci.AppGuid));
	}
	else
	{
		ZeroMemory (&(pClientRes->lci.AppGuid), sizeof (pClientRes->lci.AppGuid));
	}

	// Copy app object's extended attributes
	//
	pClientRes->lci.cAttrsReturned = pcia->Attrs.cCurrAttrs;
	if (pClientRes->lci.cAttrsReturned > 0)
	{
		pClientRes->lci.uOffsetAttrsReturned = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pClientRes->lci));
		for (i = 0; i < pcia->Attrs.cCurrAttrs; i++)
		{
			My_lstrcpy (pszDst, pcia->Attrs.aPairs[i].pszName);
			pszDst += lstrlen (pszDst) + 1;
			My_lstrcpy (pszDst, pcia->Attrs.aPairs[i].pszValue);
			pszDst += lstrlen (pszDst) + 1;
		}
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free temporary result set holder
	//
	if (pcia != NULL)
	{
		// Free standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_CLIENT_INFO; i++)
		{
			MemFree (pcia->ClientInfo.apszStdAttrValues[i]);
		}

		// Free arbitrary attributes
		//
		for (ULONG j = 0; j < pcia->Attrs.cCurrAttrs; j++)
		{
			MemFree (pcia->Attrs.aPairs[j].pszName);
			MemFree (pcia->Attrs.aPairs[j].pszValue);
		}

		// Free the holder itself
		//
		MemFree (pcia);
	}

	// Clean up the return structure if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have a return structure
		//
		if (pClientRes != NULL)
			ZeroMemory (pClientRes, sizeof (*pClientRes));
		else
			pClientRes = (LDAP_CLIENTINFO_RES *) MemAlloc (sizeof (LDAP_CLIENTINFO_RES));

		// Fill in the minimal info
		//
		if (pClientRes != NULL)
		{
			pClientRes->uSize = sizeof (*pClientRes);
			pClientRes->hResult = hrServer;
		}
	}

	// Post a message to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pClientRes);

	// Delete this pending item
	//
	return TRUE;
}


HRESULT CacheResolveClientInfoAttr (
	VOID			*pInfo,
	const TCHAR		*pszAttrName,
	const TCHAR		**ppszAttrVal )
{
	MyAssert (pInfo != NULL);
	MyAssert (pszAttrName != NULL);

	// Shorthand meeting info pointer
	//
	CLIENT_INFO_ATTRS *pcia = (CLIENT_INFO_ATTRS *) pInfo;

	// See if this attribute is arbitrary?
	//
	const TCHAR *pszRealAnyName = IlsIsAnyAttrName (pszAttrName);
	if (pszRealAnyName != NULL)
	{
		MyAssert (pcia->Attrs.cCurrAttrs < pcia->Attrs.cMaxAttrs);

		// Duplicate the name
		//
		pcia->Attrs.aPairs[pcia->Attrs.cCurrAttrs].pszName =
			My_strdup (pszRealAnyName);

		// Duplicate the value
		// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
		//
		if (ppszAttrVal != NULL)
		{
			pcia->Attrs.aPairs[pcia->Attrs.cCurrAttrs++].pszValue =
				My_strdup (*ppszAttrVal);
		}
		else
		{
			// ILS server bug or wldap32.dll bug
			//
			MyAssert (FALSE);
		}
	}
	else
	{
		// Loop through all standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_RES_CLIENT_INFO; i++)
		{
			// Figure out what attribute it is
			//
			if (My_lstrcmpi (c_apszClientStdAttrNames[i], pszAttrName) == 0)
			{
				// Free the previously allocated value if any
				//
				MemFree (pcia->ClientInfo.apszStdAttrValues[i]);

				// Duplicate the value
				// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
				//
				if (ppszAttrVal != NULL)
				{
					pcia->ClientInfo.apszStdAttrValues[i] = DuplicateGoodString (*ppszAttrVal);
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
				break;
			}
		}
	}

	return S_OK;
}


typedef struct
{
	PROT_INFO	ProtInfo;
	TCHAR		*pszProtNameToResolve;
	BOOL		fFindIndex;
	LONG		nIndex;
}
	PROT_INFO_EX;

enum { INVALID_INDEX = -1 };

BOOL NotifyResolveProt ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Get the pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal info
	//
	LDAP_PROTINFO_RES *pProtRes = NULL;
	PROT_INFO_EX *ppi = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Allocate result holder
	//
	ppi = (PROT_INFO_EX *) MemAlloc (sizeof (PROT_INFO_EX));
	if (ppi == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Cache the protocol name to resolve
	//
	MyAssert (pInfo->pszProtNameToResolve != NULL);
	ppi->pszProtNameToResolve = pInfo->pszProtNameToResolve;
	ppi->nIndex = INVALID_INDEX;

	// Call the common routine to find the index
	//
	ppi->fFindIndex = TRUE;
	hrServer = NotifyResolveX (hrServer, pItem, ppi, CacheResolveProtInfoAttr);
	if (hrServer != S_OK)
		goto MyExit;

	// Check to see if we found the index
	//
	if (ppi->nIndex == INVALID_INDEX)
	{
		hrServer = ILS_E_NO_SUCH_OBJECT;
		goto MyExit;
	}

	// Call the common routine AGAIN to save attribute values
	//
	ppi->fFindIndex = FALSE;
	hrServer = NotifyResolveX (hrServer, pItem, ppi, CacheResolveProtInfoAttr);
	if (hrServer != S_OK)
		goto MyExit;

	// Initialize the size
	//
	ULONG cbTotalSize, cbThisSize;
	cbTotalSize = sizeof (LDAP_PROTINFO_RES);

	// Loop through standard attrs
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_PROTATTR; i++)
	{
		if (ppi->ProtInfo.apszStdAttrValues[i] != NULL)
		{
			cbThisSize = My_lstrlen (ppi->ProtInfo.apszStdAttrValues[i]) + 1;
			cbThisSize *= sizeof (TCHAR);
			cbTotalSize += cbThisSize;
		}
	}

	// Allocate LDAP_PROTINFO_RES structure
	//
	pProtRes = (LDAP_PROTINFO_RES *) MemAlloc (cbTotalSize);
	if (pProtRes == NULL)
	{
		MyAssert (FALSE); // we are in deep trouble here
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in fields
	//
	pProtRes->uSize = sizeof (*pProtRes);
	pProtRes->hResult = hrServer;
	pProtRes->lpi.uSize = sizeof (pProtRes->lpi);
	TCHAR *pszSrc, *pszDst;
	pszDst = (TCHAR *) (pProtRes + 1);

	// Copy protocol name
	//
	pszSrc = ppi->ProtInfo.apszStdAttrValues[ENUM_PROTATTR_NAME];
	if (pszSrc != NULL)
	{
		pProtRes->lpi.uOffsetName = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pProtRes->lpi));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy protocol mime type
	//
	pszSrc = ppi->ProtInfo.apszStdAttrValues[ENUM_PROTATTR_MIME_TYPE];
	if (pszSrc != NULL)
	{
		pProtRes->lpi.uOffsetMimeType = (ULONG)((ULONG_PTR) pszDst - (ULONG_PTR) &(pProtRes->lpi));
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy protocol prot number
	//
	pszSrc = ppi->ProtInfo.apszStdAttrValues[ENUM_PROTATTR_PORT_NUMBER];
	if (pszSrc != NULL)
	{
		pProtRes->lpi.uPortNumber = GetStringLong (pszSrc);
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free temporary app result holder
	//
	if (ppi != NULL)
	{
		for (INT i = 0; i < COUNT_ENUM_PROTATTR; i++)
		{
			MemFree (ppi->ProtInfo.apszStdAttrValues[i]);
		}
		MemFree (ppi);
	}

	// Clean up the return structure if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have a valid returned structure
		//
		if (pProtRes != NULL)
			ZeroMemory (pProtRes, sizeof (*pProtRes));
		else
			pProtRes = (LDAP_PROTINFO_RES *) MemAlloc (sizeof (LDAP_PROTINFO_RES));

		// Fill in the minimal info
		//
		if (pProtRes != NULL)
		{
			pProtRes->uSize = sizeof (*pProtRes);
			pProtRes->hResult = hrServer;
		}
	}

	// Post the result to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pProtRes);

	// Destroy this pending item
	//
	return TRUE;
}


HRESULT CacheResolveProtInfoAttr (
	VOID			*pInfo,
	const TCHAR		*pszAttrName,
	const TCHAR		**ppszAttrVal )
{
	MyAssert (pInfo != NULL);
	MyAssert (pszAttrName != NULL);

	// Shorthand prot info pointer
	//
	PROT_INFO_EX *ppi = (PROT_INFO_EX *) pInfo;

	// Are we trying to find the index of the protocol to resolve?
	//
	if (ppi->fFindIndex)
	{
		// If we already located the index, then simply return
		//
		if (ppi->nIndex == INVALID_INDEX)
		{
			// Looking for "sprotid"
			//
			if (My_lstrcmpi (STR_PROT_NAME, pszAttrName) == 0)
			{
				// Get to the protocol name attribute
				//
				if (ppszAttrVal != NULL)
				{
					TCHAR *pszVal;
					for (LONG nIndex = 0;
								(pszVal = (TCHAR *) ppszAttrVal[nIndex]) != NULL;
								nIndex++)
					{
						if (My_lstrcmpi (ppi->pszProtNameToResolve, pszVal) == 0)
						{
							// Locate the same protocol name, remember the index
							//
							ppi->nIndex = nIndex;
							break;
							// return S_OK; // we should be able to return from here
						}
					}
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
			}
		}
	}
	else
	{
		// Loop through all standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_PROTATTR; i++)
		{
			// Figure out what attribute it is
			//
			if (My_lstrcmpi (c_apszProtStdAttrNames[i], pszAttrName) == 0)
			{
				// Free the previously allocated value if any
				//
				MemFree (ppi->ProtInfo.apszStdAttrValues[i]);

				// Duplicate the value
				// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
				//
				if (ppszAttrVal != NULL)
				{
					// Make sure that we do not fault when the ILS server or wldap32.dll has a bug
					//
					for (LONG nIndex = 0; nIndex <= ppi->nIndex; nIndex++)
					{
						if (ppszAttrVal[nIndex] == NULL)
						{
							// ILS server bug
							//
							MyAssert (FALSE);
							return S_OK;
						}
					}

					// Duplicate the attribute value
					//
					ppi->ProtInfo.apszStdAttrValues[i] = My_strdup (ppszAttrVal[ppi->nIndex]);
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
				break;
			}
		}
	}

	return S_OK;
}


#ifdef ENABLE_MEETING_PLACE
BOOL NotifyResolveMtg ( HRESULT hrServer, SP_CResponse *pItem )
{
	MyAssert (pItem != NULL);

	// Get pending info
	//
	RESP_INFO *pInfo = pItem->GetRespInfo ();
	MyAssert (pInfo != NULL);

	// Initialize minimal return info
	//
	LDAP_MEETINFO_RES *pMtgRes = NULL;
	MTG_INFO_ATTRS *pmia = NULL;

	// If error, simply report the error
	//
	if (hrServer != S_OK)
		goto MyExit;

	// Get the ldap result
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = pItem->GetResult ();
	if (pLdapMsg == NULL)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

	// Get ld
	//
	LDAP *ld;
	ld = pItem->GetLd ();
	if (ld == NULL)
	{
		MyAssert (FALSE);
		hrServer = ILS_E_HANDLE;
		goto MyExit;
	}

	// Get the count of attributes
	//
	ULONG cAttrs;
	cAttrs = my_ldap_count_1st_entry_attributes (ld, pLdapMsg);
	if (cAttrs == 0)
	{
		hrServer = ILS_E_NO_MORE;
		goto MyExit;
	}

	// Allocate result set holder
	//
	pmia = (MTG_INFO_ATTRS *) MemAlloc (
						sizeof (MTG_INFO_ATTRS) +
						cAttrs * sizeof (ATTR_PAIR));
	if (pmia == NULL)
	{
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize result set holder
	//
	pmia->Attrs.cMaxAttrs = cAttrs;

	// Cache resolve set
	//
	hrServer = NotifyResolveX (	hrServer,
								pItem,
								pmia,
								CacheResolveMtgInfoAttr);
	if (hrServer != S_OK)
		goto MyExit;

	// Initialize the size
	//
	ULONG cbTotalSize, cbThisSize;
	cbTotalSize = sizeof (LDAP_MEETINFO_RES);

	// Loop through standard attrs to calculate the total size
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_MTGATTR; i++)
	{
		if (pmia->MtgInfo.apszStdAttrValues[i] != NULL)
		{
			// Compute the string length
			//
			cbThisSize = My_lstrlen (pmia->MtgInfo.apszStdAttrValues[i]) + 1;

			// Compensate the string length if it is ip address
			//
			if (i == ENUM_MTGATTR_IP_ADDRESS)
				cbThisSize += 16;

			// Convert the string length to string size
			//
			cbThisSize *= sizeof (TCHAR);

			// Add up to the total size
			//
			cbTotalSize += cbThisSize;
		}
	}

	// Loop through arbitrary attrs to calculate the total size
	//
	for (i = 0; i < pmia->Attrs.cCurrAttrs; i++)
	{
		cbThisSize = My_lstrlen (pmia->Attrs.aPairs[i].pszName) + 1;
		cbThisSize += My_lstrlen (pmia->Attrs.aPairs[i].pszValue) + 1;
		cbThisSize *= sizeof (TCHAR);
		cbTotalSize += cbThisSize;
	}

	// Allocate LDAP_MTGINFO_RES structure
	//
	pMtgRes = (LDAP_MEETINFO_RES *) MemAlloc (cbTotalSize);
	if (pMtgRes == NULL)
	{
		MyAssert (FALSE); // we are in deep trouble here
		hrServer = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in common fields
	//
	pMtgRes->uSize = sizeof (*pMtgRes);
	pMtgRes->hResult = hrServer;
	pMtgRes->lmi.uSize = sizeof (pMtgRes->lmi);
	TCHAR *pszSrc, *pszDst;
	pszDst = (TCHAR *) (pMtgRes + 1);

	// Copy Meeting Name if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_CN];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetMeetingPlaceID = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy Meeting Type if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MTG_TYPE];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.lMeetingPlaceType = (pszSrc != NULL) ?	GetStringLong (pszSrc) :
														INVALID_MEETING_TYPE;
	}

	// Copy Attendee Type if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_MEMBER_TYPE];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.lAttendeeType = (pszSrc != NULL) ?	GetStringLong (pszSrc) :
														INVALID_ATTENDEE_TYPE;
	}

	// Copy Description if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_DESCRIPTION];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetDescription = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy Host Name if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_HOST_NAME];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetHostName = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		My_lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy Host IP Address if needed
	//
	pszSrc = pmia->MtgInfo.apszStdAttrValues[ENUM_MTGATTR_IP_ADDRESS];
	if (pszSrc != NULL)
	{
		pMtgRes->lmi.uOffsetHostIPAddress = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		GetIPAddressString (pszDst, GetStringLong (pszSrc));
		pszDst += lstrlen (pszDst) + 1;
	}

	// Copy extended attributes
	//
	pMtgRes->lmi.cAttrsReturned = pmia->Attrs.cCurrAttrs;
	if (pMtgRes->lmi.cAttrsReturned > 0)
	{
		pMtgRes->lmi.uOffsetAttrsReturned = (ULONG) pszDst - (ULONG) &(pMtgRes->lmi);
		for (i = 0; i < pmia->Attrs.cCurrAttrs; i++)
		{
			My_lstrcpy (pszDst, pmia->Attrs.aPairs[i].pszName);
			pszDst += lstrlen (pszDst) + 1;
			My_lstrcpy (pszDst, pmia->Attrs.aPairs[i].pszValue);
			pszDst += lstrlen (pszDst) + 1;
		}
	}

	MyAssert (hrServer == S_OK);

MyExit:

	// Free temporary result set holder
	//
	if (pmia != NULL)
	{
		// Free standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_MTGATTR; i++)
		{
			MemFree (pmia->MtgInfo.apszStdAttrValues[i]);
		}

		// Free arbitrary attributes
		//
		for (ULONG j = 0; j < pmia->Attrs.cCurrAttrs; j++)
		{
			MemFree (pmia->Attrs.aPairs[j].pszName);
			MemFree (pmia->Attrs.aPairs[j].pszValue);
		}

		// Free the holder itself
		//
		MemFree (pmia);
	}

	// Clean up the return structure if failure
	//
	if (hrServer != S_OK)
	{
		// Make sure we have a return structure
		//
		if (pMtgRes != NULL)
			ZeroMemory (pMtgRes, sizeof (*pMtgRes));
		else
			pMtgRes = (LDAP_MEETINFO_RES *) MemAlloc (sizeof (LDAP_MEETINFO_RES));

		// Fill in the minimal info
		//
		if (pMtgRes != NULL)
		{
			pMtgRes->uSize = sizeof (*pMtgRes);
			pMtgRes->hResult = hrServer;
		}
	}

	// Post a message to the com layer
	//
	PostMessage (g_hWndNotify, pInfo->uNotifyMsg, pInfo->uRespID, (LPARAM) pMtgRes);

	// Delete this pending item
	//
	return TRUE;
}
#endif // ENABLE_MEETING_PLACE


#ifdef ENABLE_MEETING_PLACE
HRESULT CacheResolveMtgInfoAttr (
	VOID			*pInfo,
	const TCHAR		*pszAttrName,
	const TCHAR		**ppszAttrVal )
{
	MyAssert (pInfo != NULL);
	MyAssert (pszAttrName != NULL);

	// Shorthand meeting info pointer
	//
	MTG_INFO_ATTRS *pmia = (MTG_INFO_ATTRS *) pInfo;

	// See if this attribute is arbitrary?
	//
	const TCHAR *pszRealAnyName = IlsIsAnyAttrName (pszAttrName);
	if (pszRealAnyName != NULL)
	{
		MyAssert (pmia->Attrs.cCurrAttrs < pmia->Attrs.cMaxAttrs);

		// Duplicate the name
		//
		pmia->Attrs.aPairs[pmia->Attrs.cCurrAttrs].pszName =
			My_strdup (pszRealAnyName);

		// Duplicate the value
		// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
		//
		if (ppszAttrVal != NULL)
		{
			pmia->Attrs.aPairs[pmia->Attrs.cCurrAttrs++].pszValue =
				My_strdup (*ppszAttrVal);
		}
		else
		{
			// ILS server bug or wldap32.dll bug
			//
			MyAssert (FALSE);
		}
	}
	else
	{
		// Loop through all standard attributes
		//
		for (INT i = 0; i < COUNT_ENUM_RESMTGINFO; i++)
		{
			// Figure out what attribute it is
			//
			if (My_lstrcmpi (c_apszMtgStdAttrNames[i], pszAttrName) == 0)
			{
				// Free the previously allocated value if any
				//
				MemFree (pmia->MtgInfo.apszStdAttrValues[i]);

				// Duplicate the value
				// BUGS: we should avoid duplicate the string here (cf. enum-user-infos)
				//
				if (ppszAttrVal != NULL)
				{
					pmia->MtgInfo.apszStdAttrValues[i] = My_strdup (*ppszAttrVal);
				}
				else
				{
					// ILS server bug or wldap32.dll bug
					//
					MyAssert (FALSE);
				}
				break;
			}
		}
	}

	return S_OK;
}
#endif // ENABLE_MEETING_PLACE


VOID FreeStdAttrCache ( TCHAR *apszStdAttrValues[], ULONG cStdAttrs )
{
	for (ULONG i = 0; i < cStdAttrs; i++)
	{
		if (apszStdAttrValues[i] != NULL)
		{
			ldap_value_free ((TCHAR **) apszStdAttrValues[i]);
		}
	}
}


VOID FreeAttrPairArrayCache ( ATTR_PAIR aAttrPair[], ULONG cPairs )
{
	if (aAttrPair != NULL)
	{
		for (ULONG j = 0; j < cPairs; j++)
		{
			if (aAttrPair[j].pszValue != NULL)
			{
				ldap_value_free ((TCHAR **) aAttrPair[j].pszValue);
			}
		}
	}
}


VOID CacheAnyAttrNamesInAttrPairs (
	ULONG			cNames,
	TCHAR			*pszSrcNameList,
	ATTR_PAIR		aPairs[] )
{
	MyAssert (cNames != 0);
	MyAssert (pszSrcNameList != NULL);
	MyAssert (aPairs != NULL);

	// Note that all these extended attribute names are already PREFIXED
	//
	for (ULONG i = 0; i < cNames; i++)
	{
		aPairs[i].pszName = pszSrcNameList;
		pszSrcNameList += lstrlen (pszSrcNameList) + 1;
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\sppqueue.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sppqueue.cpp
	Content:	This file contains the pending item/queue objects.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

// #define MEASURE_ENUM_USER_INFO	1

ULONG g_uResponseTimeout = ILS_DEF_RESP_TIMEOUT;
ULONG g_uResponsePollPeriod = ILS_DEF_RESP_POLL_PERIOD;
SP_CResponseQueue *g_pRespQueue = NULL;
SP_CRequestQueue *g_pReqQueue = NULL;
SP_CRefreshScheduler *g_pRefreshScheduler = NULL;


typedef BOOL (RESPONSE_HANDLER) ( HRESULT, SP_CResponse * );
typedef LPARAM (REQUEST_HANDLER) ( MARSHAL_REQ * );

extern RESPONSE_HANDLER *GetResponseHandler ( ULONG uNotifyMsg );
extern REQUEST_HANDLER *GetRequestHandler ( ULONG uNotifyMsg );


/* ---------- REQUEST QUEUE ----------- */


MARSHAL_REQ *
MarshalReq_Alloc (
	ULONG		uNotifyMsg,
	ULONG		cbSize,
	ULONG		cParams )
{
	// Align the chunk of data for each parameter on 4-byte boundary
	//
	cbSize += cParams * sizeof (DWORD);

	// Calculate the total size of marshal buffer
	//
	ULONG cbTotalSize = sizeof (MARSHAL_REQ) +
						cParams * sizeof (DWORD) +
						cbSize;

	// Allocate the marshal buffer
	//
	MARSHAL_REQ *p = (MARSHAL_REQ *) MemAlloc (cbTotalSize);
	if (p != NULL)
	{
		// p->next = NULL;
		p->cbTotalSize = cbTotalSize;
		p->pb = (BYTE *) ((ULONG_PTR) p + (cbTotalSize - cbSize));

		p->uRespID = GetUniqueNotifyID ();

		p->uNotifyMsg = uNotifyMsg;
		p->cParams = cParams;
	}

	return p;
}


HRESULT
MarshalReq_SetParam (
	MARSHAL_REQ		*p,
	ULONG			nIndex,
	DWORD_PTR		dwParam,
	ULONG			cbParamSize )
{
	if (p != NULL && nIndex < p->cParams)
	{
		MyAssert (p->aParams[nIndex] == 0); // not used before

		// If cbParamSize > 0, then
		// this means uParam is a pointer to a structure or
		// a pointer to a string
		//
		if (cbParamSize > 0)
		{
			// The pointer is now the one pointing to the new location
			//
			p->aParams[nIndex] = (DWORD_PTR) p->pb;

			// Copy the data chunk
			//
			CopyMemory (p->pb, (VOID *) dwParam, cbParamSize);

			// Make sure the data chunk is aligned on 4-byte boundary
			//
			if (cbParamSize & 0x3)
			{
				// Round it up
				//
				cbParamSize = (cbParamSize & (~0x3)) + 4;
			}

			// Adjust the running pointer
			//
			p->pb += cbParamSize;
		}
		else
		{
			// uParam can be an signed/unsigned integer,
			//
			p->aParams[nIndex] = dwParam;
		}
	}
	else
	{
		MyAssert (FALSE);
	}

	return S_OK;
}


DWORD_PTR
MarshalReq_GetParam (
	MARSHAL_REQ		*p,
	ULONG			nIndex )
{
	DWORD_PTR dwParam = 0;

	if (p != NULL && nIndex < p->cParams)
	{
		dwParam = p->aParams[nIndex];
	}
	else
	{
		MyAssert (FALSE);
	}

	return dwParam;
}


HRESULT
MarshalReq_SetParamServer (
	MARSHAL_REQ		*p,
	ULONG			nIndex,
	SERVER_INFO		*pServer,
	ULONG			cbServer )
{
	if (p != NULL && nIndex < p->cParams)
	{
		MyAssert (p->aParams[nIndex] == 0); // not used before
		MyAssert (cbServer > sizeof (SERVER_INFO));

		// The pointer is now the one pointing to the new location
		//
		p->aParams[nIndex] = (DWORD_PTR) p->pb;

		// Linearize the server info
		//
		IlsLinearizeServerInfo (p->pb, pServer);

		// Make sure the data chunk is aligned on 4-byte boundary
		//
		if (cbServer & 0x3)
		{
			// Round it up
			//
			cbServer = (cbServer & (~0x3)) + 4;
		}

		// Adjust the running pointer
		//
		p->pb += cbServer;
	}

	return S_OK;
}






SP_CRequestQueue::
SP_CRequestQueue ( VOID )
	:
	m_ItemList (NULL),
	m_uCurrOpRespID (INVALID_RESP_ID)
{
	// Create critical sections for thread safe access
	//
	::MyInitializeCriticalSection (&m_csReqQ);
	::MyInitializeCriticalSection (&m_csCurrOp);
}


SP_CRequestQueue::
~SP_CRequestQueue ( VOID )
{
	// when this is called, the hidden window thread exited already.
	// this is assured in UlsLdap_Deinitialize().
	//

	WriteLock ();

	// Free all the items in this list
	//
	MARSHAL_REQ *p, *next;
	for (p = m_ItemList; p != NULL; p = next)
	{
		next = p->next;
		MemFree (p);
	}
	m_ItemList = NULL;

	WriteUnlock ();

	// Delete critical sections
	//
	::MyDeleteCriticalSection (&m_csReqQ);
	::MyDeleteCriticalSection (&m_csCurrOp);
}


HRESULT SP_CRequestQueue::
Enter ( MARSHAL_REQ *p )
{
	// Make sure we have valid pointers
	//
	if (p == NULL)
	{
		MyAssert (FALSE);
		return ILS_E_POINTER;
	}
	MyAssert (! MyIsBadWritePtr (p, p->cbTotalSize));
	MyAssert (p->next == NULL);
	MyAssert (p->uRespID != 0);

	WriteLock ();

	// Append the new request
	//
	p->next = NULL;
	if (m_ItemList == NULL)
	{
		m_ItemList = p;
	}
	else
	{
		for (	MARSHAL_REQ *prev = m_ItemList;
				prev->next != NULL;
				prev = prev->next)
			;

		MyAssert (prev != NULL);
		prev->next = p;
	}

	WriteUnlock ();

	// Signal the internal request thread to pick up this request
	//
	SetEvent (g_hevNewRequest);

	return S_OK;
}


VOID SP_CRequestQueue::
Schedule ( VOID )
{
	MARSHAL_REQ *p;

	while (IsAnyReqInQueue () && ! g_fExitNow)
	{
		// Reset to null, we will use this as an indicator
		// to see if we need to process the request
		//
		p = NULL;

		// Lock request queue
		//
		WriteLock ();

		// Get a request to process
		//
		if (IsAnyReqInQueue ())
		{
			p = m_ItemList;
			m_ItemList = m_ItemList->next;
		}

		// We want to lock both request queue and CurrOp at the same time
		// because we cannot have a temporal window that either one can change.

		// Set CurrOp
		//
		if (p != NULL)
		{
			// Lock CurrOp
			//
			LockCurrOp ();

			// Set CurrOp
			//
			m_uCurrOpRespID = p->uRespID;

			// Unlock CurrOp
			//
			UnlockCurrOp ();
		}

		// Unlock request queue
		//
		WriteUnlock ();

		// Make sure we have something to process
		//
		if (p == NULL)
		{
			// Nothing to do any more
			//
			MyAssert (FALSE);
			break;
		}

		// Let's process the request
		//
		Dispatch (p);

		MemFree(p);
	}
}


HRESULT SP_CRequestQueue::
Cancel ( ULONG uRespID )
{
	HRESULT hr;
	MARSHAL_REQ *p, *next, *prev;

	// The locking order is always in
	// Lock(PendingOpQueue), Lock(RequestQueue), Lock (CurrOp)
	//
	WriteLock ();
	LockCurrOp ();

	if (m_uCurrOpRespID == uRespID)
	{
		// Invalidate the curr op.
		// When the curr op is done, then the request thread will remove it
		// from the pending op queue.
		//
		m_uCurrOpRespID = INVALID_RESP_ID;
		hr = S_OK;
	}
	else
	{
		// Look for the item with a matching response id
		//
		for (prev = NULL, p = m_ItemList; p != NULL; prev = p, p = next)
		{
			// Cache the next pointer
			//
			next = p->next;

			// See if the response id matches
			//
			if (p->uRespID == uRespID)
			{
				// It is a match
				//
				MyDebugMsg ((ZONE_REQ, "ULS: cancelled request(0x%lX) in ReqQ\r\n", p->uNotifyMsg));

				// Let's destroy this item
				//
				if (p == m_ItemList)
				{
					m_ItemList = next;
				}
				else
				{
					MyAssert (prev != NULL);
					prev->next = next;
				}

				// Free this structure
				//
				MemFree (p);

				// Get out of the loop
				//
				break;
			}
		} // for

		hr = (p == NULL) ? ILS_E_NOTIFY_ID : S_OK;
	} // else

	UnlockCurrOp ();
	WriteUnlock ();

	return hr;
}


VOID SP_CRequestQueue::
Dispatch ( MARSHAL_REQ *p )
{
	// Make sure we have a valid pointer
	//
	if (p == NULL)
	{
		MyAssert (FALSE);
		return;
	}

	// If it is keep alive, then do it
	//
	HRESULT hr;
	if (p->uNotifyMsg == WM_ILS_REFRESH)
	{
		// Keep alive handler
		//
		if (g_pRefreshScheduler != NULL)
		{
			ULONG uTTL = (ULONG) MarshalReq_GetParam (p, 0);
			hr = g_pRefreshScheduler->SendRefreshMessages (uTTL);
		}
		else
		{
			MyAssert (FALSE);
		}

		return;
	}

	// Locate the appropriate handler
	//
	REQUEST_HANDLER *pfn = ::GetRequestHandler (p->uNotifyMsg);
	if (pfn == NULL)
	{
		MyAssert (FALSE);
		return;
	}

	// Send the request to the server
	//
	MyDebugMsg ((ZONE_REQ, "ULS: sending request(0x%lX)\r\n", p->uNotifyMsg));
	ULONG uRespID = p->uRespID;
	LPARAM lParam = (*pfn) (p);
	MyDebugMsg ((ZONE_REQ, "ULS: sent request(0x%lX), lParam=0x%lX\r\n", p->uNotifyMsg, lParam));
	if (lParam != 0)
	{
		::PostMessage (g_hWndNotify, p->uNotifyMsg, p->uRespID, lParam);
		return;
	}
	// BUGBUG: this is a workaround for a server bug which results in lost requests if several
	// are sent very quickly.  Remove this Sleep() as soon as the bug is fixed!!!
//	Sleep(100);

	// Lock CurrOp again
	//
	LockCurrOp ();

	// Is this request cancelled
	//
	BOOL fCancelled = (m_uCurrOpRespID == INVALID_RESP_ID) ? TRUE : FALSE;

	// Clean up CurrOp
	//
	m_uCurrOpRespID = INVALID_RESP_ID;

	// Unlock CurrOp
	//
	UnlockCurrOp ();

	// If this request was cancelled, then remove it from the pending op queue
	//
	if (fCancelled)
	{
		// Redirect the call to the pending op queue object
		//
		if (g_pRespQueue != NULL)
		{
			g_pRespQueue->Cancel (uRespID);
		}
		else
		{
			MyAssert (FALSE);
		}
	}
}


/* ---------- RESPONSE ITEM ----------- */

/* ---------- public methods ----------- */


SP_CResponse::
SP_CResponse ( VOID )
	:
	m_pSession (NULL),			// Clean up session pointer
	m_pLdapMsg (NULL),			// Clean up ldap msg pointer
	m_next (NULL)				// Clean up the pointer to the next pending item
{
	// Clean up pending info structure
	//
	::ZeroMemory (&m_ri, sizeof (m_ri));

	// Fill in creation time
	//
	UpdateLastModifiedTime ();
	m_tcTimeout = g_uResponseTimeout;
}


SP_CResponse::
~SP_CResponse ( VOID )
{
	// Release the session if needed
	//
	if (m_pSession != NULL)
		m_pSession->Disconnect ();

	// Free the ldap msg if needed
	//
	if (m_pLdapMsg != NULL)
		::ldap_msgfree (m_pLdapMsg);

	// Free extended attribute name list
	//
	::MemFree (m_ri.pszAnyAttrNameList);

	// Free protocol names to resolve
	//
	::MemFree (m_ri.pszProtNameToResolve);
}


/* ---------- protected methods ----------- */


VOID SP_CResponse::
EnterResult ( LDAPMessage *pLdapMsg )
{
	// Free the old ldap msg if needed
	//
	if (m_pLdapMsg != NULL)
		::ldap_msgfree (m_pLdapMsg);

	// Keep the new ldap msg
	//
	m_pLdapMsg = pLdapMsg;
}


/* ---------- private methods ----------- */




/* ---------- RESPONSE QUEUE ----------- */


/* ---------- public methods ----------- */


SP_CResponseQueue::
SP_CResponseQueue ( VOID )
	:
	m_ItemList (NULL)		// Clean up the item list
{
	// Create a critical section for thread safe access
	//
	::MyInitializeCriticalSection (&m_csRespQ);
}


SP_CResponseQueue::
~SP_CResponseQueue ( VOID )
{
	// when this is called, the hidden window thread exited already.
	// this is assured in UlsLdap_Deinitialize().
	//

	WriteLock ();

	// Free all the items in this list
	//
	SP_CResponse *pItem, *next;
	for (pItem = m_ItemList; pItem != NULL; pItem = next)
	{
		next = pItem->GetNext ();
		delete pItem;
	}
	m_ItemList = NULL;

	WriteUnlock ();

	// Delete the critical section
	//
	::MyDeleteCriticalSection (&m_csRespQ);
}


HRESULT SP_CResponseQueue::
EnterRequest (
	SP_CSession		*pSession,
	RESP_INFO		*pInfo )
{
	// Make sure we have valid pointers
	//
	if (pSession == NULL || pInfo == NULL)
	{
		MyAssert (FALSE);
		return ILS_E_POINTER;
	}

	// Sanity checks
	//
	MyAssert (! MyIsBadWritePtr (pInfo, sizeof (*pInfo)));
	MyAssert (! MyIsBadWritePtr (pSession, sizeof (*pSession)));
	MyAssert (pInfo->ld != NULL && pInfo->uMsgID[0] != INVALID_MSG_ID);
	MyAssert (pInfo->uRespID != 0);

	// Create a new pending item
	//
	SP_CResponse *pItem = new SP_CResponse;
	if (pItem == NULL)
		return ILS_E_MEMORY;

	// Remember the contents of pending info
	//
	pItem->EnterRequest (pSession, pInfo);

	WriteLock ();

	// If this is the first item on the list, then
	// let's start the timer
	//
	if (m_ItemList == NULL)
		::SetTimer (g_hWndHidden, ID_TIMER_POLL_RESULT, g_uResponsePollPeriod, NULL);

	// Append the new pending op
	//
	pItem->SetNext (NULL);
	if (m_ItemList == NULL)
	{
		m_ItemList = pItem;
	}
	else
	{
		for (	SP_CResponse *prev = m_ItemList;
				prev->GetNext () != NULL;
				prev = prev->GetNext ())
			;

		MyAssert (prev != NULL);
		prev->SetNext (pItem);
	}

	WriteUnlock ();

	return S_OK;
}


HRESULT SP_CResponseQueue::
PollLdapResults ( LDAP_TIMEVAL *pTimeout )
{
	MyAssert (pTimeout != NULL);

	SP_CResponse *pItem, *next, *prev;
	INT RetCode;
	RESP_INFO *pInfo;
	LDAPMessage *pLdapMsg;
	HRESULT hr;
	RESPONSE_HANDLER *pfn;
	ULONG uResultSetType;

	::KillTimer (g_hWndHidden, ID_TIMER_POLL_RESULT); // avoid overrun

	WriteLock ();

	// Enumerate all the items to get available results for them
	//
	for (prev = NULL, pItem = m_ItemList; pItem != NULL; pItem = next)
	{
		// Cache the next pointer
		//
		next = pItem->GetNext ();

		// Get the pinding info structure
		//
		pInfo = pItem->GetRespInfo ();

		// Clean up ldap msg pointer
		//
		pLdapMsg = NULL;

		// Make sure ew have valid ld and msg id
		//
		MyAssert (pInfo->ld != NULL);
		MyAssert (pInfo->uMsgID[0] != INVALID_MSG_ID ||
					pInfo->uMsgID[1] != INVALID_MSG_ID);

		// Check integrity in pending info
		//
		MyAssert (pInfo->uRespID != 0);

		// Set the result set type
		//
		switch (pInfo->uNotifyMsg)
		{
		case WM_ILS_ENUM_CLIENTS:
		case WM_ILS_ENUM_CLIENTINFOS:
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_ENUM_MEETINGS:
		case WM_ILS_ENUM_MEETINGINFOS:
#endif
			uResultSetType = LDAP_MSG_RECEIVED;	// partial result set
			break;
		default:
			uResultSetType = LDAP_MSG_ALL;		// complete result set
			break;
		}

#ifdef _DEBUG
		if (MyIsBadWritePtr (pInfo->ld, sizeof (*(pInfo->ld))))
		{
			MyDebugMsg ((ZONE_CONN, "ILS:: poll result, bad ld=0x%p\r\n", pInfo->ld));
			MyAssert (FALSE);
		}
		if (pInfo->ld != pItem->GetSession()->GetLd())
		{
			MyDebugMsg ((ZONE_CONN, "ILS:: poll result, inconsistent pInfo->ld=0x%p, pItem->pSession->ld=0x%p\r\n", pInfo->ld, pItem->GetSession()->GetLd()));
			MyAssert (FALSE);
		}
#endif // _DEBUG

		// If primary msg id is valid
		//
		if (pInfo->uMsgID[0] != INVALID_MSG_ID)
			RetCode = ::ldap_result (pInfo->ld,
									pInfo->uMsgID[0],
									uResultSetType,
									pTimeout,
									&pLdapMsg);
		else
		// If secondary msg id is valid
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
			RetCode = ::ldap_result (pInfo->ld,
									pInfo->uMsgID[1],
									uResultSetType,
									pTimeout,
									&pLdapMsg);

		// If timeout, ignore this item
		//
		if (RetCode == 0)
		{
			// Let's see if this item is expired
			//
			if (! pItem->IsExpired ())
			{
				// Not timed out, next please!
				//
				prev = pItem;
				continue;
			}

			// Timed out
			//
			hr = ILS_E_TIMEOUT;
		}

		// If error, delete this request item
		//
		if (RetCode == -1)
		{
			// Convert the error
			//
			hr = ::LdapError2Hresult (pInfo->ld->ld_errno);
		}
		else
		// If not timed out
		//
		if (RetCode != 0)
		{
			// It appears to be successful!
			//
			MyAssert (pLdapMsg != NULL);

			// Cache the ldap msg pointer
			pItem->EnterResult (pLdapMsg);

			// Get the ldap error code
			//
			hr = (pLdapMsg != NULL) ? ::LdapError2Hresult (pLdapMsg->lm_returncode) :
										S_OK;
		}

		// Get the result handler based on uNotifyMsg
		//
		pfn = ::GetResponseHandler (pInfo->uNotifyMsg);
		if (pfn == NULL)
		{
			prev = pItem;
			continue;
		}

		// Check integrity in pending info
		//
		MyAssert (pInfo->uRespID != 0);

		// Deal with the result or error
		//
		MyDebugMsg ((ZONE_RESP, "ULS: response(0x%lX), hr=0x%lX\r\n", pInfo->uNotifyMsg, hr));
		if ((*pfn) (hr, pItem))
		{
			// Let's destroy this item
			//
			if (pItem == m_ItemList)
			{
				m_ItemList = next;
			}
			else
			{
				MyAssert (prev != NULL);
				prev->SetNext (next);
			}
			delete pItem; // SP_CSession::Disconnect() and ldap_msgfree() will be called in destructor
		}
		else
		{
			// Let's keep this item around.
			// There are pending results coming in.
			//
			pItem->UpdateLastModifiedTime ();

			// Update the pointer
			//
			prev = pItem;
		}
	} // for

	// If there is no more items on the list, then stop the timer
	//
	if (m_ItemList != NULL)
		::SetTimer (g_hWndHidden, ID_TIMER_POLL_RESULT, g_uResponsePollPeriod, NULL);

	WriteUnlock ();

	return S_OK;
}


HRESULT SP_CResponseQueue::
Cancel ( ULONG uRespID )
{
	SP_CResponse *pItem, *next, *prev;
	RESP_INFO *pInfo;
	BOOL fNeedCleanup = FALSE;

	WriteLock ();

	// Look for the item with a matching response id
	//
	for (prev = NULL, pItem = m_ItemList; pItem != NULL; prev = pItem, pItem = next)
	{
		// Cache the next pointer
		//
		next = pItem->GetNext ();

		// Get the pinding info structure
		//
		pInfo = pItem->GetRespInfo ();
		MyAssert (pInfo != NULL);

		// See if the response id matches
		//
		if (pInfo->uRespID == uRespID)
		{
			// It is a match
			//
			SP_CSession *pSession = pItem->GetSession ();
			MyAssert (pSession != NULL);

			// Make sure we have a valid ldap session
			//
			MyAssert (pInfo->ld != NULL);

			// If we are NOT in the request thread, then we need to marshal it
			// to the request thread!!! Exit and report success!!!
			//
			if (GetCurrentThreadId () != g_dwReqThreadID)
			{
				MyDebugMsg ((ZONE_RESP, "ULS: marshalling request(0x%lX) in RespQ\r\n", pInfo->uNotifyMsg));
				MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_CANCEL, 0, 1);
				if (pReq != NULL)
				{
					MarshalReq_SetParam (pReq, 0, (DWORD) uRespID, 0);
					if (g_pReqQueue != NULL)
					{
						// This means that the locking order is
						// Lock(PendingOpQueue), Lock(RequestQueue)
						//
						g_pReqQueue->Enter (pReq);
					}
					else
					{
						MyAssert (FALSE);
					}
				}

				// Exit this loop
				//
				break;
			}

			// Indicate that we need to clean up item. Why?
			// because we should not have any network operation inside critical section.
			// this is to avoid any possible network blocking.
			//
			fNeedCleanup = TRUE;

			// Let's destroy this item
			//
			if (pItem == m_ItemList)
			{
				m_ItemList = next;
			}
			else
			{
				MyAssert (prev != NULL);
				prev->SetNext (next);
			}

			// Get out of the loop
			//
			break;
		} // if matched
	} // for

	// If there is no more items on the list, then stop the timer
	//
	if (m_ItemList == NULL)
		::KillTimer (g_hWndHidden, ID_TIMER_POLL_RESULT);

	WriteUnlock ();

	if (fNeedCleanup && pItem != NULL)
	{
		MyDebugMsg ((ZONE_RESP, "ULS: cancelled request(0x%lX) in RespQ\r\n", pInfo->uNotifyMsg));

		// Get resp info pointer
		//
		pInfo = pItem->GetRespInfo ();
		MyAssert (pInfo != NULL);

		// Abandon the primary response if needed
		//
		if (pInfo->uMsgID[1] != INVALID_MSG_ID)
			::ldap_abandon (pInfo->ld, pInfo->uMsgID[1]);

		// Abandon the secondary response if needed
		//
		if (pInfo->uMsgID[0] != INVALID_MSG_ID)
			::ldap_abandon (pInfo->ld, pInfo->uMsgID[0]);

		// SP_CSession::Disconnect() and ldap_msgfree() will be called in destructor
		//
		delete pItem;
	}

	return ((pItem == NULL) ? ILS_E_NOTIFY_ID : S_OK);
}


/* ---------- protected methods ----------- */


/* ---------- private methods ----------- */



/* ==================== utilities ====================== */


VOID
FillDefRespInfo (
	RESP_INFO		*pInfo,
	ULONG			uRespID,
	LDAP			*ld,
	ULONG			uMsgID,
	ULONG			u2ndMsgID )
{
	// Clean up
	//
	ZeroMemory (pInfo, sizeof (*pInfo));

	// Cache the ldap session
	//
	pInfo->ld = ld;

	// Generate a unique notify id
	//
	pInfo->uRespID = uRespID;

	// Store the primary and seconary msg ids
	//
	pInfo->uMsgID[0] = uMsgID;
	pInfo->uMsgID[1] = u2ndMsgID;
}



/* ---------- REFRESH SCHEDULER ----------- */


/* ---------- public methods ----------- */


SP_CRefreshScheduler::
SP_CRefreshScheduler ( VOID )
	:
	m_ListHead (NULL)		// Initialize the item list
{
	// Create a critical section for thread safe access
	//
	::MyInitializeCriticalSection (&m_csRefreshScheduler);
}


SP_CRefreshScheduler::
~SP_CRefreshScheduler ( VOID )
{
	WriteLock ();

	// Clean up the item list
	//
	REFRESH_ITEM *p, *next;
	for (p = m_ListHead; p != NULL; p = next)
	{
		next = p->next;
		MemFree (p);
	}
	m_ListHead = NULL;

	WriteUnlock ();

	// Delete the critical section
	//
	::MyDeleteCriticalSection (&m_csRefreshScheduler);
}


HRESULT SP_CRefreshScheduler::
SendRefreshMessages ( UINT uTimerID )
{
	SP_CClient *pClient;
#ifdef ENABLE_MEETING_PLACE
	SP_CMeeting *pMtg;
#endif
	REFRESH_ITEM *prev, *curr;
	INT nIndex;

	// Lock the lists
	//
	ReadLock ();

	// Locate this object in the list
	//
	nIndex = TimerID2Index (uTimerID);
	for (prev = NULL, curr = m_ListHead;
			curr != NULL;
			curr = (prev = curr)->next)
	{
		if (curr->nIndex == nIndex)
		{
			// Find it. Let's send a refresh message for this object
			//
			switch (curr->ObjectType)
			{
			case CLIENT_OBJ:
				pClient = (SP_CClient *) curr->pObject;

				// Make sure this object is not deleted already
				//
				if (! MyIsBadWritePtr (pClient, sizeof (*pClient)) &&
					pClient->IsValidObject ())
				{
					// Make sure this object is valid and registered
					//
					if (pClient->IsRegistered ())
					{
						MyDebugMsg ((ZONE_KA, "KA: send refresh msg for client\r\n"));

						// Let's send a refresh message for this client object
						// and update the new ttl value
						//
						pClient->AddRef ();
						pClient->SendRefreshMsg ();
						curr->uTTL = pClient->GetTTL ();
						pClient->Release ();
					}
				}
				else
				{
					MyAssert (FALSE);
				}
				break;

#ifdef ENABLE_MEETING_PLACE
			case MTG_OBJ:
				pMtg = (SP_CMeeting *) curr->pObject;

				// Make sure this object is not deleted already
				//
				if (! MyIsBadWritePtr (pMtg, sizeof (*pMtg)) &&
					pMtg->IsValidObject ())
				{
					// Make sure this object is valid and registered
					//
					if (pMtg->IsRegistered ())
					{
						MyDebugMsg ((ZONE_KA, "KA: send refresh msg for mtg\r\n"));

						// Let's send a refresh message for this user object
						// and update the new ttl value
						//
						pMtg->AddRef ();
						pMtg->SendRefreshMsg ();
						curr->uTTL = pMtg->GetTTL ();
						pMtg->Release ();
					}
				}
				else
				{
					MyAssert (FALSE);
				}
				break;
#endif

			default:
				MyAssert (FALSE);
				break;
			}

			// Start the timer again and exit
			// Note that curr->uTTL is the new TTL value from the server
			// Also note that uTTL is in unit of minute
			//
			MyDebugMsg ((ZONE_KA, "KA: new ttl=%lu\r\n", curr->uTTL));
			::SetTimer (g_hWndHidden, uTimerID, Minute2TickCount (curr->uTTL), NULL);
			break;
		} // if
	} // for

	ReadUnlock ();
	return S_OK;
}


HRESULT SP_CRefreshScheduler::
EnterClientObject ( SP_CClient *pClient )
{
	if (pClient == NULL)
		return ILS_E_POINTER;

	return EnterObject (CLIENT_OBJ, (VOID *) pClient, pClient->GetTTL ());
}


#ifdef ENABLE_MEETING_PLACE
HRESULT SP_CRefreshScheduler::
EnterMtgObject ( SP_CMeeting *pMtg )
{
	if (pMtg == NULL)
		return ILS_E_POINTER;

	return EnterObject (MTG_OBJ, (VOID *) pMtg, pMtg->GetTTL ());
}
#endif


VOID *SP_CRefreshScheduler::
AllocItem ( BOOL fNeedLock )
{
	REFRESH_ITEM *p, *curr, *prev;
	INT nIndex, nLargestIndex;
	BOOL fGotTheNewIndex;

	// Allocate the structure
	//
	p = (REFRESH_ITEM *) MemAlloc (sizeof (REFRESH_ITEM));
	if (p != NULL)
	{
		if (fNeedLock)
			WriteLock ();

		// Find out what should be the index for the new item
		//
		nLargestIndex = -1; // Yes, it is -1 for the case m_ListHead==NULL
		fGotTheNewIndex = FALSE;
		for (nIndex = 0, prev = NULL, curr = m_ListHead;
				curr != NULL;
					nIndex++, curr = (prev = curr)->next)
		{
			if (curr->nIndex > nIndex)
			{
				p->nIndex = nIndex;
				fGotTheNewIndex = TRUE;
				break;
			}

			nLargestIndex = curr->nIndex;
		}

		// Put the new item in the list in its appropriate position
		//
		if (fGotTheNewIndex)
		{
			if (prev == NULL)
			{
				// The new one must be the first one
				//
				MyAssert (p->nIndex == 0);
				p->next = m_ListHead;
				m_ListHead = p;
			}
			else
			{
				// The new one in the middle of the list
				//
				MyAssert (prev->nIndex < p->nIndex && p->nIndex < curr->nIndex);
				MyAssert (prev->next == curr);
				(prev->next = p)->next = curr;
			}
		}
		else
		{
			MyAssert (m_ListHead == NULL || prev != NULL);

			if (m_ListHead == NULL)
			{
				// The new one will be the only one in the list
				//
				p->nIndex = 0;
				(m_ListHead = p)->next = NULL;
			}
			else
			{
				// The new one is at the end of the list
				//
				MyAssert (prev != NULL && prev->next == NULL && curr == NULL);
				p->nIndex = nLargestIndex + 1;
				(prev->next = p)->next = curr;
			}
		}

		if (fNeedLock)
			WriteUnlock ();
	} // if (p != NULL)

	return p;
}


HRESULT SP_CRefreshScheduler::
EnterObject ( PrivateObjType ObjectType, VOID *pObject, ULONG uInitialTTL )
{
	HRESULT hr = S_OK;

	WriteLock ();

	// Enter this object to the list
	//
	REFRESH_ITEM *p = (REFRESH_ITEM *) AllocItem (FALSE);
	if (p == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Fill in fields
	//
	p->ObjectType = ObjectType;
	p->pObject = pObject;
	p->uTTL = uInitialTTL;

	// Turn on the timer
	// Note that uTTL is in unit of minutes...
	//
	::SetTimer (g_hWndHidden, Index2TimerID (p->nIndex), Minute2TickCount (p->uTTL), NULL);

MyExit:

	WriteUnlock ();

	return hr;
}


HRESULT SP_CRefreshScheduler::
RemoveObject ( VOID *pObject )
{
	REFRESH_ITEM *prev, *curr;

	WriteLock ();

	// Locate this object in the list
	//
	for (prev = NULL, curr = m_ListHead;
			curr != NULL;
			curr = (prev = curr)->next)
	{
		if (curr->pObject == pObject)
		{
			// Find it, let's kill the timer first
			//
			KillTimer (g_hWndHidden, Index2TimerID (curr->nIndex));

			// Remove it from the list
			//
			if (prev == NULL)
			{
				// This one is the first one on the list
				//
				MyAssert (m_ListHead == curr);
				m_ListHead = curr->next;
			}
			else
			{
				// This one is in the middle of the list
				//
				MyAssert (prev->next == curr);
				prev->next = curr->next;
			}
            ::MemFree(curr);

			// Exit the loop
			//
			break;
		}
	}

	WriteUnlock ();

	return (curr != NULL ? S_OK : S_FALSE);
}




extern BOOL NotifyGeneric ( HRESULT, SP_CResponse * );
extern BOOL NotifyRegister ( HRESULT, SP_CResponse * );
extern BOOL NotifyResolveClient ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumClients ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumClientInfos ( HRESULT, SP_CResponse * );
extern BOOL NotifyResolveProt ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumProts ( HRESULT, SP_CResponse * );
extern BOOL NotifyResolveMtg ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumMtgInfos ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumMtgs ( HRESULT, SP_CResponse * );
extern BOOL NotifyEnumAttendees ( HRESULT, SP_CResponse * );

extern LPARAM AsynReq_RegisterClient ( MARSHAL_REQ * );
extern LPARAM AsynReq_RegisterProtocol ( MARSHAL_REQ * );
extern LPARAM AsynReq_RegisterMeeting ( MARSHAL_REQ * );
extern LPARAM AsynReq_UnRegisterClient ( MARSHAL_REQ * );
extern LPARAM AsynReq_UnRegisterProt ( MARSHAL_REQ * );
extern LPARAM AsynReq_UnRegisterMeeting ( MARSHAL_REQ * );
extern LPARAM AsynReq_SetClientInfo ( MARSHAL_REQ * );
extern LPARAM AsynReq_SetProtocolInfo ( MARSHAL_REQ * );
extern LPARAM AsynReq_SetMeetingInfo ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumClientsEx ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumProtocols ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumMtgsEx ( MARSHAL_REQ * );
extern LPARAM AsynReq_EnumAttendees ( MARSHAL_REQ * );
extern LPARAM AsynReq_ResolveClient ( MARSHAL_REQ * );
extern LPARAM AsynReq_ResolveProtocol ( MARSHAL_REQ * );
extern LPARAM AsynReq_ResolveMeeting ( MARSHAL_REQ * );
extern LPARAM AsynReq_UpdateAttendees ( MARSHAL_REQ * );
extern LPARAM AsynReq_Cancel ( MARSHAL_REQ * );


typedef struct
{
	#ifdef DEBUG
	LONG				nMsg;
	#endif
	RESPONSE_HANDLER	*pfnRespHdl;
	REQUEST_HANDLER		*pfnReqHdl;
}
	RES_HDL_TBL;



RES_HDL_TBL g_ResHdlTbl[] =
{
	{
		#ifdef DEBUG
		WM_ILS_REGISTER_CLIENT,
		#endif
		NotifyRegister,
		AsynReq_RegisterClient
	},
	{
		#ifdef DEBUG
		WM_ILS_UNREGISTER_CLIENT,
		#endif
		NotifyGeneric,
		AsynReq_UnRegisterClient
	},
	{
		#ifdef DEBUG
		WM_ILS_SET_CLIENT_INFO,
		#endif
		NotifyGeneric,
		AsynReq_SetClientInfo
	},
	{
		#ifdef DEBUG
		WM_ILS_RESOLVE_CLIENT,
		#endif
		NotifyResolveClient,
		AsynReq_ResolveClient
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_CLIENTS,
		#endif
		NotifyEnumClients,
		AsynReq_EnumClientsEx
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_CLIENTINFOS,
		#endif
		NotifyEnumClientInfos,
		AsynReq_EnumClientsEx
	},

	{
		#ifdef DEBUG
		WM_ILS_REGISTER_PROTOCOL,
		#endif
		NotifyRegister,
		AsynReq_RegisterProtocol
	},
	{
		#ifdef DEBUG
		WM_ILS_UNREGISTER_PROTOCOL,
		#endif
		NotifyGeneric,
		AsynReq_UnRegisterProt
	},
	{
		#ifdef DEBUG
		WM_ILS_SET_PROTOCOL_INFO,
		#endif
		NotifyGeneric,
		AsynReq_SetProtocolInfo
	},
	{
		#ifdef DEBUG
		WM_ILS_RESOLVE_PROTOCOL,
		#endif
		NotifyResolveProt,
		AsynReq_ResolveProtocol
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_PROTOCOLS,
		#endif
		NotifyEnumProts,
		AsynReq_EnumProtocols
	},

#ifdef ENABLE_MEETING_PLACE
	{
		#ifdef DEBUG
		WM_ILS_REGISTER_MEETING,
		#endif
		NotifyRegister,
		AsynReq_RegisterMeeting
	},
	{
		#ifdef DEBUG
		WM_ILS_UNREGISTER_MEETING,
		#endif
		NotifyGeneric,
		AsynReq_UnRegisterMeeting
	},
	{
		#ifdef DEBUG
		WM_ILS_SET_MEETING_INFO,
		#endif
		NotifyGeneric,
		AsynReq_SetMeetingInfo
	},
	{
		#ifdef DEBUG
		WM_ILS_RESOLVE_MEETING,
		#endif
		NotifyResolveMtg,
		AsynReq_ResolveMeeting
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_MEETINGINFOS,
		#endif
		NotifyEnumMtgInfos,
		AsynReq_EnumMtgsEx
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_MEETINGS,
		#endif
		NotifyEnumMtgs,
		AsynReq_EnumMtgsEx
	},
	{
		#ifdef DEBUG
		WM_ILS_ADD_ATTENDEE,
		#endif
		NotifyGeneric,
		AsynReq_UpdateAttendees
	},
	{
		#ifdef DEBUG
		WM_ILS_REMOVE_ATTENDEE,
		#endif
		NotifyGeneric,
		AsynReq_UpdateAttendees
	},
	{
		#ifdef DEBUG
		WM_ILS_ENUM_ATTENDEES,
		#endif
		NotifyEnumAttendees,
		AsynReq_EnumAttendees
	},
#endif // ENABLE_MEETING_PLACE

	{
		#ifdef DEBUG
		WM_ILS_CANCEL,
		#endif
		NULL,
		AsynReq_Cancel
	}
};



#ifdef DEBUG
VOID DbgValidateHandlerTable ( VOID )
{
	MyAssert (ARRAY_ELEMENTS (g_ResHdlTbl) == WM_ILS_LAST_ONE - WM_ILS_ASYNC_RES + 1);

	for (LONG i = 0; i < ARRAY_ELEMENTS (g_ResHdlTbl); i++)
	{
		if (g_ResHdlTbl[i].nMsg - WM_ILS_ASYNC_RES != i)
		{
			MyAssert (FALSE);
			break;
		}
	}
}
#endif


RES_HDL_TBL *
GetHandlerTableEntry ( ULONG uNotifyMsg )
{
	ULONG nIndex = uNotifyMsg - WM_ILS_ASYNC_RES;

	if (nIndex > WM_ILS_LAST_ONE)
	{
		MyAssert (FALSE);
		return NULL;
	}

	return &g_ResHdlTbl[nIndex];
}


RESPONSE_HANDLER *
GetResponseHandler ( ULONG uNotifyMsg )
{
	RES_HDL_TBL *p = GetHandlerTableEntry (uNotifyMsg);
	return ((p != NULL) ? p->pfnRespHdl : NULL);
}


REQUEST_HANDLER *
GetRequestHandler ( ULONG uNotifyMsg )
{
	RES_HDL_TBL *p = GetHandlerTableEntry (uNotifyMsg);
	return ((p != NULL) ? p->pfnReqHdl : NULL);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\sppqueue.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sppqueue.h
	Content:	This file contains the pending item/queue objects definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_PRQUEUE_H_
#define _ILS_SP_PRQUEUE_H_

#include <pshpack8.h>


/* ------------- Request Scheduler --------------- */

#define WM_ILS_REFRESH			((ULONG) -1)

typedef struct tagReqMarshal
{
	struct tagReqMarshal	*next;
	ULONG	cbTotalSize;	// for debug checking
	BYTE	*pb;			// running pointer

	ULONG	uRespID;		// for cancel and error notification

	ULONG	uNotifyMsg;
	ULONG	cParams;
	DWORD_PTR aParams[1];
	// more data follows...
}
	MARSHAL_REQ;


MARSHAL_REQ *MarshalReq_Alloc ( ULONG uNotifyMsg, ULONG cbSize, ULONG cParams );
HRESULT MarshalReq_SetParam ( MARSHAL_REQ *p, ULONG nIndex, DWORD_PTR dwParam, ULONG cbParamSize );
DWORD_PTR MarshalReq_GetParam ( MARSHAL_REQ *p, ULONG nIndex );
HRESULT MarshalReq_SetParamServer ( MARSHAL_REQ *p, ULONG nIndex, SERVER_INFO *pServer, ULONG cbServer );


enum { INVALID_RESP_ID = -1 };


class SP_CRequestQueue
{
	friend class SP_CResponseQueue;
	friend HRESULT UlsLdap_Cancel ( ULONG );

public:

	SP_CRequestQueue ( VOID );
	~SP_CRequestQueue ( VOID );

	HRESULT Enter ( MARSHAL_REQ *p );
	VOID Schedule ( VOID );
	VOID Dispatch ( MARSHAL_REQ *p );
	HRESULT Cancel ( ULONG uRespID );

	BOOL IsEmptyQueue ( VOID ) { return (m_ItemList == NULL); }
	BOOL IsAnyReqInQueue ( VOID ) { return (m_ItemList != NULL); }

	BOOL IsCurrentRequestCancelled ( VOID ) { return (m_uCurrOpRespID == INVALID_RESP_ID); }

protected:

	VOID LockCurrOp ( VOID ) { EnterCriticalSection (&m_csCurrOp); }
	VOID UnlockCurrOp ( VOID ) { LeaveCriticalSection (&m_csCurrOp); }

	VOID WriteLock ( VOID ) { EnterCriticalSection (&m_csReqQ); }
	VOID WriteUnlock ( VOID ) { LeaveCriticalSection (&m_csReqQ); }

private:

	VOID ReadLock ( VOID ) { WriteLock (); }
	VOID ReadUnlock ( VOID ) { WriteUnlock (); }

	MARSHAL_REQ 		*m_ItemList;

	CRITICAL_SECTION	m_csReqQ;

	ULONG				m_uCurrOpRespID;
	CRITICAL_SECTION	m_csCurrOp;
};

extern SP_CRequestQueue *g_pReqQueue;


/* ------------- Response Scheduler --------------- */

#define ILS_MIN_RESP_TIMEOUT	((ULONG) (20 * 1000))	// 20 seconds
#define ILS_DEF_RESP_TIMEOUT	((ULONG) (90 * 1000))	// 90 seconds
#define ILS_BK_RESP_TIMEOUT_SEC	90						// 90 seconds
extern ULONG g_uResponseTimeout;

#define ILS_MIN_RESP_POLL_PERIOD	((ULONG) 50)	// 50 ms
#define ILS_DEF_RESP_POLL_PERIOD	((ULONG) 100)	// 100 ms per PatLam's experiment
extern ULONG g_uResponsePollPeriod;

#define Minute2TickCount(m)				((m) * 60 * 1000)
#define ILS_DEF_REFRESH_MINUTE			2
#define ILS_DEF_REFRESH_MARGIN_MINUTE	2


typedef struct
{
	// ldap specific
	LDAP		*ld;
	ULONG		uMsgID[2];
	// notification specific
	ULONG		uRespID;
	ULONG		uNotifyMsg;
	// object specific
	HANDLE		hObject;	// user, app, prot object
	// mutual dependency specific
	HRESULT		hrDependency;	// S_OK if not used
	// for extended attributes
	ULONG		cAnyAttrs;
	TCHAR		*pszAnyAttrNameList;
	// for resolving protocol
	TCHAR		*pszProtNameToResolve;
}
	RESP_INFO;

class SP_CResponse
{
	friend class SP_CResponseQueue;

public:

	SP_CResponse ( VOID );
	~SP_CResponse ( VOID );

	LDAPMessage *GetResult ( VOID ) { return m_pLdapMsg; }

	RESP_INFO *GetRespInfo ( VOID ) { return &m_ri; }

	SP_CSession *GetSession ( VOID ) { return m_pSession; }
	LDAP *GetLd ( VOID ) { return m_ri.ld; }

protected:

	VOID EnterResult ( LDAPMessage *pLdapMsg );

	VOID EnterRequest ( SP_CSession *pSession, RESP_INFO *pInfo )
	{
		m_pSession = pSession;
		m_ri = *pInfo;
		m_tcTimeout = m_pSession->GetServerTimeoutInTickCount ();
	}

	SP_CResponse *GetNext ( VOID ) { return m_next; }
	VOID SetNext ( SP_CResponse *pItem ) { m_next = pItem; }

private:

	VOID UpdateLastModifiedTime ( VOID ) { m_tcLastModifiedTime = GetTickCount (); }

	BOOL IsExpired ( VOID ) { return (GetTickCount () - m_tcLastModifiedTime >= m_tcTimeout); }

	RESP_INFO		m_ri;

	SP_CSession		*m_pSession;
	LDAPMessage		*m_pLdapMsg;
	SP_CResponse	*m_next;

	ULONG			m_tcLastModifiedTime;
	ULONG			m_tcTimeout;
};


class SP_CResponseQueue
{
	friend class SP_CRequestQueue;
	friend HRESULT UlsLdap_Cancel ( ULONG );

public:

	SP_CResponseQueue ( VOID );
	~SP_CResponseQueue ( VOID );

	HRESULT EnterRequest ( SP_CSession *pSession, RESP_INFO *pInfo );
	HRESULT PollLdapResults ( LDAP_TIMEVAL *pTimeout );

	HRESULT Cancel ( ULONG uRespID );

protected:

	VOID WriteLock ( VOID ) { EnterCriticalSection (&m_csRespQ); }
	VOID WriteUnlock ( VOID ) { LeaveCriticalSection (&m_csRespQ); }

private:

	VOID ReadLock ( VOID ) { WriteLock (); }
	VOID ReadUnlock ( VOID ) { WriteUnlock (); }

	SP_CResponse 	*m_ItemList;

	CRITICAL_SECTION m_csRespQ;
};


extern SP_CResponseQueue *g_pRespQueue;


VOID FillDefRespInfo ( RESP_INFO *pInfo, ULONG uRespID, LDAP *ld, ULONG uMsgID, ULONG u2ndMsgID );


/* ------------- Refersh Message Scheduler --------------- */

class SP_CRefreshScheduler
{
public:

	SP_CRefreshScheduler ( VOID );
	~SP_CRefreshScheduler ( VOID );

	HRESULT SendRefreshMessages ( UINT uTimerID );

	HRESULT EnterClientObject ( SP_CClient *pClient );
	HRESULT RemoveClientObject ( SP_CClient *pClient ) { return RemoveObject ((VOID *) pClient); }

#ifdef ENABLE_MEETING_PLACE
	HRESULT EnterMtgObject ( SP_CMeeting *pMtg );
	HRESULT RemoveMtgObject ( SP_CMeeting *pMtg ) { return RemoveObject ((VOID *) pMtg); }
#endif

protected:

private:

	VOID WriteLock ( VOID ) { EnterCriticalSection (&m_csRefreshScheduler); }
	VOID WriteUnlock ( VOID ) { LeaveCriticalSection (&m_csRefreshScheduler); }
	VOID ReadLock ( VOID ) { WriteLock (); }
	VOID ReadUnlock ( VOID ) { WriteUnlock (); }

	typedef enum { UNK_OBJ, CLIENT_OBJ, MTG_OBJ } PrivateObjType;
	typedef struct tagREFRESH_ITEM
	{
		INT				nIndex;
		PrivateObjType	ObjectType;
		VOID			*pObject;
		ULONG			uTTL;
		struct tagREFRESH_ITEM *next;
	}
		REFRESH_ITEM;

	INT TimerID2Index ( UINT uTimerID ) { return (INT) uTimerID - KEEP_ALIVE_TIMER_BASE; }
	UINT Index2TimerID ( INT nIndex ) { return (UINT) (nIndex + KEEP_ALIVE_TIMER_BASE); }

	VOID *AllocItem ( BOOL fNeedLock );
	HRESULT EnterObject ( PrivateObjType ObjectType, VOID *pObject, ULONG uInitialTTL );
	HRESULT RemoveObject ( VOID *pObject );

	REFRESH_ITEM	*m_ListHead;
	CRITICAL_SECTION m_csRefreshScheduler;
};


extern SP_CRefreshScheduler *g_pRefreshScheduler;


#include <poppack.h>

#endif // _ILS_SP_PRQUEUE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spserver.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spserver.cpp
	Content:	This file contains the server and its authentication.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


BOOL IlsSameServerInfo ( const SERVER_INFO *p1, const SERVER_INFO *p2 )
{
	return (p1->uTimeoutInSecond == p2->uTimeoutInSecond 				&&
			p1->AuthMethod		 == p2->AuthMethod						&&
		My_lstrcmpi (p1->pszServerName, 	p2->pszServerName) 	  == 0	&&
		My_lstrcmpi (p1->pszLogonName, 		p2->pszLogonName) 	  == 0	&&
		My_lstrcmpi (p1->pszLogonPassword, 	p2->pszLogonPassword) == 0	&&
		My_lstrcmpi (p1->pszDomain, 		p2->pszDomain) 	  	  == 0  &&
		My_lstrcmpi (p1->pszBaseDN, 		p2->pszBaseDN) 	  	  == 0  &&
		My_lstrcmpi (p1->pszCredential, 	p2->pszCredential) 	  == 0);
}


HRESULT IlsCopyServerInfo ( SERVER_INFO *pDst, const SERVER_INFO *pSrc )
{
	MyAssert (pDst != NULL && pSrc != NULL);

	SERVER_INFO si;
	ZeroMemory (&si, sizeof (si));
	si.uTimeoutInSecond = pSrc->uTimeoutInSecond;
	si.AuthMethod = pSrc->AuthMethod;
	si.pszServerName = My_strdup (pSrc->pszServerName);
	si.pszLogonName = My_strdup (pSrc->pszLogonName);
	si.pszLogonPassword = My_strdup (pSrc->pszLogonPassword);
	si.pszDomain = My_strdup (pSrc->pszDomain);
	si.pszCredential = My_strdup (pSrc->pszCredential);
	si.pszBaseDN = My_strdup (pSrc->pszBaseDN);

	if ((pSrc->pszServerName != NULL && si.pszServerName == NULL) ||
		(pSrc->pszLogonName != NULL && si.pszLogonName == NULL) ||
		(pSrc->pszLogonPassword != NULL && si.pszLogonPassword == NULL) ||
		(pSrc->pszDomain != NULL && si.pszDomain == NULL) ||
		(pSrc->pszCredential != NULL && si.pszCredential == NULL) ||
		(pSrc->pszBaseDN != NULL && si.pszBaseDN == NULL)
		)
	{
		IlsFreeServerInfo (&si);
		return ILS_E_MEMORY;
	}

	*pDst = si;
 	return S_OK;
}


VOID IlsFreeServerInfo ( SERVER_INFO *psi )
{
	if (psi != NULL)
	{
		MemFree (psi->pszServerName);
		MemFree (psi->pszLogonName);
		MemFree (psi->pszLogonPassword);
		MemFree (psi->pszDomain);
		MemFree (psi->pszCredential);
		MemFree (psi->pszBaseDN);

		ZeroMemory (psi, sizeof (*psi));
	}
}


ULONG IlsGetLinearServerInfoSize ( const SERVER_INFO *psi )
{
	ULONG cbSize = sizeof (SERVER_INFO);

	cbSize += (My_lstrlen (psi->pszServerName) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszLogonName) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszLogonPassword) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszDomain) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszCredential) + 1) * sizeof (TCHAR);
	cbSize += (My_lstrlen (psi->pszBaseDN) + 1) * sizeof (TCHAR);

	return cbSize;
}


VOID IlsLinearizeServerInfo ( BYTE *pData, const SERVER_INFO *pSrc )
{
	SERVER_INFO *p = (SERVER_INFO *) pData;
	pData = (BYTE *) (p + 1);

	CopyMemory (p, pSrc, sizeof (SERVER_INFO));

	if (pSrc->pszServerName != NULL)
	{
		p->pszServerName = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszServerName);
		pData += (lstrlen (pSrc->pszServerName) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszLogonName != NULL)
	{
		p->pszLogonName = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszLogonName);
		pData += (lstrlen (pSrc->pszLogonName) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszLogonPassword != NULL)
	{
		p->pszLogonPassword = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszLogonPassword);
		pData += (lstrlen (pSrc->pszLogonPassword) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszDomain != NULL)
	{
		p->pszDomain = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszDomain);
		pData += (lstrlen (pSrc->pszDomain) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszCredential != NULL)
	{
		p->pszCredential = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszCredential);
		pData += (lstrlen (pSrc->pszCredential) + 1) * sizeof (TCHAR);	
	}

	if (pSrc->pszBaseDN != NULL)
	{
		p->pszBaseDN = (TCHAR *) pData;
		My_lstrcpy ((TCHAR *) pData, pSrc->pszBaseDN);
		pData += (lstrlen (pSrc->pszBaseDN) + 1) * sizeof (TCHAR);	
	}
}

HRESULT IlsFillDefServerInfo ( SERVER_INFO *p, TCHAR *pszServerName )
{
	ZeroMemory (p, sizeof (*p));
	p->pszServerName = My_strdup (pszServerName);
	return ((p->pszServerName != NULL) ? S_OK : ILS_E_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spserver.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spserver.h
	Content:	This file contains the help functions for the service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_SERVER_H_
#define _ILS_SP_SERVER_H_

#include <pshpack8.h>


typedef struct
{
	ULONG					uTimeoutInSecond;
	ILS_ENUM_AUTH_METHOD	AuthMethod;

	TCHAR		*pszServerName;
	TCHAR		*pszLogonName;
	TCHAR		*pszLogonPassword;
	TCHAR		*pszDomain;
	TCHAR		*pszCredential;
	TCHAR		*pszBaseDN;
}
	SERVER_INFO;


BOOL IlsSameServerInfo ( const SERVER_INFO *p1, const SERVER_INFO *p2 );
HRESULT IlsCopyServerInfo ( SERVER_INFO *pDst, const SERVER_INFO *pSrc );
VOID IlsFreeServerInfo ( SERVER_INFO *psi );

ULONG IlsGetLinearServerInfoSize ( const SERVER_INFO *psi );
VOID IlsLinearizeServerInfo ( BYTE *pData, const SERVER_INFO *pSrc );

HRESULT IlsFillDefServerInfo ( SERVER_INFO *p, TCHAR *pszServerName );

inline BOOL MyIsBadServerInfo ( SERVER_INFO *p )
{
	return (p == NULL || MyIsBadString (p->pszServerName));
}

#include <poppack.h>

#endif // _ILS_SP_SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spstdatt.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spstdatt.cpp
	Content:	This file contains the standard-attribute object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

/* ---------- public methods ----------- */


UlsLdap_CStdAttrs::UlsLdap_CStdAttrs ( VOID )
{
}


UlsLdap_CStdAttrs::~UlsLdap_CStdAttrs ( VOID )
{
}


/* ---------- protected methods ----------- */


HRESULT UlsLdap_CStdAttrs::SetStdAttrs (
	ULONG		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	VOID		*pInfo,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN )
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (pInfo != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);

	// cache info
	//
	HRESULT hr = CacheInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// Build modify array for ldap_modify()
	//
	LDAPMod **ppMod = NULL;
	hr = CreateSetStdAttrsModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation
	//

	// Get the session object
	//
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Send the data over the wire
	//
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// If the caller requests a response id,
	// then submit this pending item.
	// else free up the session object
	//
	if (puRespID != NULL)
	{
		// Initialize pending info
		//
		PENDING_INFO PendingInfo;
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
		PendingInfo.uLdapResType = LDAP_RES_MODIFY;
		PendingInfo.uNotifyMsg = uNotifyMsg;

		// Queue it
		//
		hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
		if (hr != S_OK)
		{
			// If queueing failed, then clean up
			//
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			MyAssert (FALSE);
		}

		// Return the reponse id
		//
		*puRespID = PendingInfo.uRespID;
	}
	else
	{
		// Free up session (i.e. decrement the reference count)
		//
		pSession->Disconnect ();
	}

	if (puMsgID != NULL)
		*puMsgID = uMsgID;

	return hr;
}



HRESULT 
FillDefStdAttrsModArr (
	LDAPMod		***pppMod,
	DWORD		dwFlags,
	ULONG		cMaxAttrs,
	ULONG		*pcTotal,	// in/out parameter!!!
	LONG		IsbuModOp,
	ULONG		cPrefix,
	TCHAR		*pszPrefix )
{

	MyAssert (pppMod != NULL);
	MyAssert (pcTotal != NULL);
	MyAssert (	(cPrefix == 0 && pszPrefix == NULL) ||
				(cPrefix != 0 && pszPrefix != NULL));

	// Figure out the num of attributes
	//
	ULONG cAttrs = 0;
	for (ULONG i = 0; i < cMaxAttrs; i++)
	{
		if (dwFlags & 0x01)
			cAttrs++;
		dwFlags >>= 1;
	}

	// Allocate modify list
	//
	ULONG cTotal = *pcTotal + cPrefix + cAttrs;
	ULONG cbMod = IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ULS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	for (i = 0; i < cTotal; i++)
	{
		pMod = IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
	}

	// Fix up the last one
	//
	IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_REPLACE, IsbuModOp);
	(*pppMod)[cTotal] = NULL;

	// Return the total number of entries if needed
	//
	if (pcTotal)
		*pcTotal = cTotal;

	return S_OK;
}


/* ---------- private methods ----------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsapp.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsapp.h
//  Content:    This file contains the Application object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSAPP_H_
#define _ULSAPP_H_

#include "connpt.h"

//****************************************************************************
// CUlsApp definition
//****************************************************************************
//
class CUlsApp : public IULSApplication,
                public IConnectionPointContainer
{
private:
    ULONG                   cRef;
    LPTSTR                  szServer;
    LPTSTR                  szUser;
    GUID                    guid;
    LPTSTR                  szName;
    LPTSTR                  szMimeType;
    CAttributes             *pAttrs;
    CConnectionPoint        *pConnPt;

    // Private method
    //
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);

public:
    // Constructor and destructor
    CUlsApp (void);
    ~CUlsApp (void);
    STDMETHODIMP            Init (LPTSTR szServerName,
                                  LPTSTR szUserName,
                                  PLDAP_APPINFO pai);

    // Asynchronous response
    //
    STDMETHODIMP    GetProtocolResult (ULONG uReqID,
                                       PLDAP_PROTINFO_RES plar);
    STDMETHODIMP    EnumProtocolsResult (ULONG uReqID,
                                         PLDAP_ENUM ple);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSApplication
    STDMETHODIMP    GetID (GUID *pGUID);
    STDMETHODIMP    GetName (BSTR *pbstrAppName);
    STDMETHODIMP    GetMimeType (BSTR *pbstrMimeType);
    STDMETHODIMP    GetAttributes (IULSAttributes **ppAttributes);
    STDMETHODIMP    GetProtocol (BSTR bstrProtocolID,
    							 IULSAttributes *pAttributes,
                                 ULONG *puReqID);
    STDMETHODIMP    EnumProtocols (ULONG *puReqID);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};

#endif //_ULSAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\sputils.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sputils.h
	Content:	This file contains the help functions for the service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_UTILS_H_
#define _ILS_SP_UTILS_H_

#include <pshpack8.h>

inline BOOL MyIsBadWritePtr ( VOID *p, ULONG cb )
{
	return (p == NULL || IsBadWritePtr (p, cb));
}

inline BOOL MyIsBadReadPtr ( VOID *p, ULONG cb )
{
	return (p == NULL || IsBadReadPtr (p, cb));
}

inline BOOL MyIsBadExecPtr ( VOID *p, ULONG cb )
{
	return MyIsBadReadPtr (p, cb);
}

inline BOOL MyIsWindow ( HWND h )
{
	return (h != NULL && IsWindow (h));
}

inline BOOL MyIsGoodString ( const TCHAR *psz )
{
	return (psz != NULL && *psz != TEXT ('\0'));
}

inline BOOL MyIsBadString ( const TCHAR *psz )
{
	return (psz == NULL || *psz == TEXT ('\0'));
}


TCHAR *My_strdup ( const TCHAR *pszToDup );

inline TCHAR *DuplicateGoodString ( const TCHAR *pszSrc )
{
	return (MyIsGoodString (pszSrc) ? My_strdup (pszSrc) : NULL);
}


BOOL KeepUiResponsive ( VOID );

VOID GetGuidString ( GUID *pGuid, TCHAR *pszGuid ); // guid --> string
VOID GetStringGuid ( TCHAR *pszGuid, GUID *pGuid ); // string --> guid
INT HexChar2Val ( TCHAR c );
BOOL IsValidGuid ( GUID *pGuid );
VOID GetLongString ( LONG, TCHAR * ); // long --> string
LONG GetStringLong ( TCHAR *pszVal ); // string --> long
VOID GetIPAddressString ( TCHAR *pszIPAddress, DWORD dwIPAddress );

ULONG My_lstrlen ( const TCHAR *psz );
VOID My_lstrcpy ( TCHAR *pszDst, const TCHAR *pszSrc );
INT My_lstrcmpi ( const TCHAR *p, const TCHAR *q );
TCHAR *My_strchr ( const TCHAR *psz, TCHAR c );
BOOL My_isspace ( TCHAR ch );
BOOL IsSameMemory ( const BYTE *pb1, const BYTE *pb2, DWORD cbSize );
BYTE *MyBinDup ( const BYTE *pbToDup, ULONG cbToDup );

BOOL GetRegistrySettings ( VOID );
BOOL GetRegValueLong ( HKEY hKey, const TCHAR *pszKey, LONG	*plValue, LONG lDefValue );


#include <poppack.h>

#endif // _ILS_SP_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spstdatt.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spstdatt.h
	Content:	This file contains the standard-attribute object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_STDATTR_H_
#define _ULS_SP_STDATTR_H_

#include <pshpack8.h>


class UlsLdap_CStdAttrs
{
	friend class UlsLdap_CLocalUser;
	friend class UlsLdap_CLocalApp;
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CStdAttrs ( VOID );
	~UlsLdap_CStdAttrs ( VOID );

protected:

	HRESULT SetStdAttrs ( ULONG *puRespID, ULONG *puMsgID,
						ULONG uNotifyMsg, VOID *pInfo,
						SERVER_INFO *pServerInfo, TCHAR *pszDN );

private:

	virtual HRESULT CacheInfo ( VOID *pInfo ) = 0;
	virtual HRESULT CreateSetStdAttrsModArr ( LDAPMod ***pppMod ) = 0;

	ULONG	m_uDontCare; // avoid zero size
};

HRESULT FillDefStdAttrsModArr ( LDAPMod ***pppMod, DWORD dwFlags,
								ULONG cMaxAttrs, ULONG *pcTotal,
								LONG IsbuModOp,
								ULONG cPrefix, TCHAR *pszPrefix );


#include <poppack.h>

#endif // _ULS_SP_STDATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\sputils.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		sputils.cpp
	Content:	This file contains the utilities for service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


TCHAR c_szWindowClassName[] = TEXT ("UlsLdapSp");

BOOL g_fExitNow = FALSE;
HANDLE g_ahThreadWaitFor[NUM_THREAD_WAIT_FOR] = { 0 };


DWORD WINAPI
ReqThread ( VOID *lParam )
{
	BOOL fStayInThisThread = TRUE;
	DWORD dwExitCode = 0;
	DWORD dwResult;

	// Start WSA for subsequent host query in this service provider
	//
	WSADATA WSAData;
	if (WSAStartup (MAKEWORD (1, 1), &WSAData))
	{
		dwExitCode = ILS_E_WINSOCK;
		goto MyExit;
	}

	// Make sure that all the event are initialized
	//
	INT i;
	for (i = 0; i < NUM_THREAD_WAIT_FOR; i++)
	{
		if (g_ahThreadWaitFor[i] == NULL)
		{
			MyAssert (FALSE);
			dwExitCode = ILS_E_THREAD;
			goto MyExit;
		}
	}

	// Wait for events to happen!!!
	//
	do
	{
		dwResult = MsgWaitForMultipleObjects (	NUM_THREAD_WAIT_FOR,
												&g_ahThreadWaitFor[0],
												FALSE,		// OR logic
												INFINITE,	// infinite
												QS_ALLINPUT); // any message in queue
		switch (dwResult)
		{
		case WAIT_OBJECT_0 + THREAD_WAIT_FOR_REQUEST:
			if (g_pReqQueue != NULL)
			{
				g_pReqQueue->Schedule ();
				MyAssert (fStayInThisThread);
			}
			else
			{
				MyAssert (FALSE);
				fStayInThisThread = FALSE;
			}
			break;

		case WAIT_OBJECT_0 + THREAD_WAIT_FOR_EXIT:
		case WAIT_ABANDONED_0 + THREAD_WAIT_FOR_EXIT:
		case WAIT_ABANDONED_0 + THREAD_WAIT_FOR_REQUEST:
		case WAIT_TIMEOUT:
			// Exit this thread
			//
			fStayInThisThread = FALSE;
			break;

		default:
			// If a message in the queue, then dispatch it.
			// Right now, wldap32 does not have a message pump.
			// However, for possible update of wldap32, we need to
			// protect ourselves from being fried.
			//
			if (! KeepUiResponsive ())
				fStayInThisThread = FALSE;
			break;
		}
	}
	while (fStayInThisThread);

MyExit:

	if (dwExitCode != ILS_E_WINSOCK)
		WSACleanup ();

	// ExitThread (dwExitCode);
	return 0;
}


BOOL KeepUiResponsive ( VOID )
{
	MSG msg;
	while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
	{
		if (msg.message != WM_QUIT)
		{
			TranslateMessage (&msg);
			DispatchMessage (&msg);
		}
		else
		{
			PostQuitMessage ((int)msg.wParam);
			return FALSE;
		}
	}

	return TRUE;
}


LRESULT CALLBACK
SP_WndProc ( HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam )
{
	switch (uMsg)
	{
	case WM_CREATE:
		break;

	case WM_TIMER:
		switch (LOWORD (uParam))
		{
		case ID_TIMER_POLL_RESULT:
			if (g_pRespQueue != NULL)
			{
				// No-wait polling
				//
				LDAP_TIMEVAL PollTimeout;
				ZeroMemory (&PollTimeout, sizeof (PollTimeout));
				// PollTimeout.tv_sec = 0;
				// PollTimeout.tv_usec = 0;
				g_pRespQueue->PollLdapResults (&PollTimeout);
			}
			else
			{
				MyAssert (FALSE);
			}
			break;

		default:
			if (LOWORD (uParam) >= KEEP_ALIVE_TIMER_BASE)
			{
				// Allocate marshall request buffer
				//
				MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REFRESH, 0, 1);
				if (pReq != NULL)
				{
					HRESULT hr = ILS_E_FAIL;
					ULONG uTimerID = LOWORD (uParam);

					// Fill in parameters
					//
					MarshalReq_SetParam (pReq, 0, (DWORD) uTimerID, 0);

					// Enter the request
					//
					if (g_pReqQueue != NULL)
					{
						hr = g_pReqQueue->Enter (pReq);
					}
					else
					{
						MyAssert (FALSE);
					}

					// Avoid timer overrun if the request is submitted successfully
					//
					if (hr == S_OK)
					{
						KillTimer (hWnd, uTimerID);
					}
					else
					{
						MemFree (pReq);
					}
				}
			}
			else
			{
				MyAssert (FALSE);
			}
			break;
		} // switch (LOWORD (uParam))
		break;

	case WM_ILS_CLIENT_NEED_RELOGON:
	case WM_ILS_CLIENT_NETWORK_DOWN:
		#if 1
		MyAssert (FALSE); // we should post to com directly
		#else
		{
			// Get the local user object
			//
			SP_CClient *pClient = (SP_CClient *) lParam;

			// Make sure the parent local user object is valid
			//
			if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
				! pClient->IsValidObject () ||
				! pClient->IsRegistered ())
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Indicate this user object is not remotely connected to the server
			//
			pClient->SetRegLocally ();

			// Get the server info
			//
			SERVER_INFO *pServerInfo = pClient->GetServerInfo ();
			if (pServerInfo == NULL)
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Duplicate the server name
			//
			TCHAR *pszServerName = My_strdup (pServerInfo->pszServerName);
			if (pszServerName == NULL)
				break; // exit

			// Notify the com layer
			//
			PostMessage (g_hWndNotify, uMsg, (WPARAM) pClient, (LPARAM) pszServerName);
		}
		#endif
		break;

#ifdef ENABLE_MEETING_PLACE
	case WM_ILS_MEETING_NEED_RELOGON:
	case WM_ILS_MEETING_NETWORK_DOWN:
		#if 1
		MyAssert (FALSE); // we should post to com directly
		#else
		{
			// Get the local user object
			//
			SP_CMeeting *pMtg = (SP_CMeeting *) lParam;

			// Make sure the parent local user object is valid
			//
			if (MyIsBadWritePtr (pMtg, sizeof (*pMtg)) ||
				! pMtg->IsValidObject () ||
				! pMtg->IsRegistered ())
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Indicate this user object is not remotely connected to the server
			//
			pMtg->SetRegLocally ();

			// Get the server info
			//
			SERVER_INFO *pServerInfo = pMtg->GetServerInfo ();
			if (pServerInfo == NULL)
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Duplicate the server name
			//
			TCHAR *pszServerName = My_strdup (pServerInfo->pszServerName);
			if (pszServerName == NULL)
				break; // exit

			// Notify the com layer
			//
			PostMessage (g_hWndNotify, uMsg, (WPARAM) pMtg, (LPARAM) pszServerName);
		}
		#endif
		break;
#endif // ENABLE_MEETING_PLACE

#if 0
	case WM_ILS_IP_ADDRESS_CHANGED:
		{
			// Get the local user object
			//
			SP_CClient *pClient = (SP_CClient *) lParam;

			// Make sure the parent local user object is valid
			//
			if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
				! pClient->IsValidObject () ||
				! pClient->IsRegistered ())
			{
				MyAssert (FALSE);
				break; // exit
			}

			// Change IP address now
			//
			pClient->UpdateIPAddress ();
		}
		break;
#endif

	case WM_CLOSE:
		DestroyWindow (hWnd);
		break;

	case WM_DESTROY:
		g_hWndHidden = NULL;
#ifdef USE_HIDDEN_THREAD
		PostQuitMessage (0);
#endif
		break;

	default:
		return DefWindowProc (hWnd, uMsg, uParam, lParam);
	}

	return 0;
}


BOOL MyCreateWindow ( VOID )
{
	WNDCLASS	wc;

	// do the stuff to create a hidden window
	ZeroMemory (&wc, sizeof (wc));
	// wc.style = 0;
	wc.lpfnWndProc = (WNDPROC) SP_WndProc;
	// wc.cbClsExtra = 0;
	// wc.cbWndExtra = 0;
	// wc.hIcon = NULL;
	wc.hInstance = g_hInstance;
	// wc.hCursor = NULL;
	// wc.hbrBackground = NULL;
	// wc.lpszMenuName =  NULL;
	wc.lpszClassName = c_szWindowClassName;

	// register the class
	// it is ok, if the class is already registered by another app
	RegisterClass (&wc);

	// create a window for socket notification
	g_hWndHidden = CreateWindow (
		wc.lpszClassName,
		NULL,
		WS_POPUP,		   /* Window style.   */
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL,			   /* the application window is the parent. */
		NULL,				/* hardcoded ID		 */
		g_hInstance,		   /* the application owns this window.	*/
		NULL);			  /* Pointer not needed.				*/

	return (g_hWndHidden != NULL);
}


HRESULT
GetLocalIPAddress ( DWORD *pdwIPAddress )
{
	MyAssert (pdwIPAddress != NULL);

	// get local host name
	CHAR szLocalHostName[MAX_PATH];
	szLocalHostName[0] = '\0';
	gethostname (&szLocalHostName[0], MAX_PATH);

	// get the host entry by name
	PHOSTENT phe = gethostbyname (&szLocalHostName[0]);
	if (phe == NULL)
		return ILS_E_WINSOCK;

	// get info from the host entry
	*pdwIPAddress = *(DWORD *) phe->h_addr;
	return S_OK;
}


// guid --> string
VOID
GetGuidString ( GUID *pGuid, TCHAR *pszGuid )
{
	MyAssert (! MyIsBadWritePtr (pGuid, sizeof (GUID)));
	MyAssert (pszGuid != NULL);

	CHAR *psz = (CHAR *) pGuid;

	for (ULONG i = 0; i < sizeof (GUID); i++)
	{
		wsprintf (pszGuid, TEXT ("%02x"), (0x0FF & (ULONG) *psz));
		pszGuid += 2;
		psz++;
	}
	*pszGuid = TEXT ('\0');
}


// string --> guid
VOID
GetStringGuid ( TCHAR *pszGuid, GUID *pGuid )
{
	ULONG cchGuid = lstrlen (pszGuid);

	MyAssert (cchGuid == 2 * sizeof (GUID));
	MyAssert (! MyIsBadWritePtr (pGuid, sizeof (GUID)));

	// Clean up target GUID structure
	//
	ZeroMemory (pGuid, sizeof (GUID));

	// Translate guid string to guid
	//
	CHAR *psz = (CHAR *) pGuid;
	cchGuid >>= 1;
	for (ULONG i = 0; i < cchGuid; i++)
	{
		*psz++ = (CHAR) ((HexChar2Val (pszGuid[0]) << 4) |
						HexChar2Val (pszGuid[1]));
		pszGuid += 2;
	}
}


INT
HexChar2Val ( TCHAR c )
{
	INT Val;
	if (TEXT ('0') <= c && c <= TEXT ('9'))
		Val = c - TEXT ('0');
	else
	if (TEXT ('a') <= c && c <= TEXT ('f'))
		Val = c - TEXT ('a') + 10;
	else
	if (TEXT ('A') <= c && c <= TEXT ('F'))
		Val = c - TEXT ('A') + 10;
	else
		Val = 0;

	MyAssert (0 <= Val && Val <= 15);
	return Val & 0x0F;
}


INT
DecimalChar2Val ( TCHAR c )
{
	INT Val;
	if (TEXT ('0') <= c && c <= TEXT ('9'))
		Val = c - TEXT ('0');
	else
		Val = 0;

	MyAssert (0 <= Val && Val <= 9);
	return Val & 0x0F;
}


BOOL
IsValidGuid ( GUID *pGuid )
{
	DWORD *pdw = (DWORD *) pGuid;

	return (pdw[0] != 0 || pdw[1] != 0 || pdw[2] != 0 || pdw[3] != 0);
}


// long --> string
VOID
GetLongString ( LONG Val, TCHAR *pszVal )
{
	MyAssert (pszVal != NULL);
	wsprintf (pszVal, TEXT ("%lu"), Val);
}


// string --> long
LONG
GetStringLong ( TCHAR *pszVal )
{
	MyAssert (pszVal != NULL);

	LONG Val = 0;
	for (INT i = 0; i < INTEGER_STRING_LENGTH && *pszVal != TEXT ('\0'); i++)
	{
		Val = 10 * Val + DecimalChar2Val (*pszVal++);
	}

	return Val;
}


// it is the caller's responsibility to make sure
// the buffer is sufficient and
// the ip address is in network order
VOID
GetIPAddressString ( TCHAR *pszIPAddress, DWORD dwIPAddress )
{
	BYTE temp[4];

	*(DWORD *) &temp[0] = dwIPAddress;
	wsprintf (pszIPAddress, TEXT ("%u.%u.%u.%u"),
				(UINT) temp[0], (UINT) temp[1],
				(UINT) temp[2], (UINT) temp[3]);
}


ULONG
My_lstrlen ( const TCHAR *psz )
{
	return ((psz != NULL) ? lstrlen (psz) : 0);
}


VOID
My_lstrcpy ( TCHAR *pszDst, const TCHAR *pszSrc )
{
	if (pszDst != NULL)
	{
		if (pszSrc != NULL)
		{
			lstrcpy (pszDst, pszSrc);
		}
		else
		{
			*pszDst = TEXT ('\0');
		}
	}
}


INT
My_lstrcmpi ( const TCHAR *p, const TCHAR *q )
{
	INT retcode;

	if (p == q)
	{
		retcode = 0;
	}
	else
	if (p == NULL)
	{
		retcode = -1;
	}
	else
	if (q == NULL)
	{
		retcode = 1;
	}
	else
	{
		retcode = lstrcmpi (p, q);
	}

	return retcode;
}


TCHAR *
My_strdup ( const TCHAR *pszToDup )
{
	TCHAR *psz = NULL;

	if (pszToDup != NULL)
	{
		psz = (TCHAR *) MemAlloc ((lstrlen (pszToDup) + 1) * sizeof (TCHAR));
		if (psz != NULL)
		{
			lstrcpy (psz, pszToDup);
		}
	}

	return psz;
}


TCHAR *
My_strchr ( const TCHAR *psz, TCHAR c )
{
	TCHAR *pszFound = NULL;

	if (psz)
	{
		while (*psz)
		{
			if (*psz == c)
			{
				pszFound = (TCHAR *) psz;
				break;
			}

			psz++;
		}
	}

	return pszFound;
}


BOOL
My_isspace ( TCHAR ch )
{
	return (ch == TEXT (' ')  || ch == TEXT ('\t') ||
			ch == TEXT ('\r') || ch == TEXT ('\n'));
}


BOOL
IsSameMemory ( const BYTE *pb1, const BYTE *pb2, DWORD cbSize )
{
	while (cbSize--)
	{
		if (*pb1++ != *pb2++)
		{
			return FALSE;
		}
	}

	return TRUE;
}



BYTE *
MyBinDup ( const BYTE *pbToDup, ULONG cbToDup )
{
	BYTE *pb = NULL;

	if (pbToDup)
	{
		pb = (BYTE *) MemAlloc (cbToDup);
		if (pb)
		{
			CopyMemory (pb, pbToDup, cbToDup);
		}
	}

	return pb;
}


/* ---------- registry ------------- */


const TCHAR c_szUlsLdapSpReg[] = TEXT("Software\\Microsoft\\User Location Service\\LDAP Provider");
const TCHAR c_szResponseTimeout[] = TEXT("Response Timeout");
const TCHAR c_szResponsePollPeriod[] = TEXT("Response Poll Period");
const TCHAR c_szClientSig[] = TEXT ("Client Signature");

BOOL
GetRegistrySettings ( VOID )
{
	// Open the LDAP Provider settings
	//
	HKEY hKey;
	if (RegOpenKeyEx (	HKEY_CURRENT_USER,
						&c_szUlsLdapSpReg[0],
						0,
						KEY_READ,
						&hKey) != NOERROR)
	{
		// The folder does not exist
		//
		g_uResponseTimeout = ILS_MIN_RESP_TIMEOUT;
		g_uResponsePollPeriod = ILS_DEF_RESP_POLL_PERIOD;
		g_dwClientSig = (ULONG) -1;
	}
	else
	{
		// Get response timeout
		//
		GetRegValueLong (	hKey,
							&c_szResponseTimeout[0],
							(LONG *) &g_uResponseTimeout,
							ILS_DEF_RESP_TIMEOUT);

		// Make sure the value is within the range
		//
		if (g_uResponseTimeout < ILS_MIN_RESP_TIMEOUT)
			g_uResponseTimeout = ILS_MIN_RESP_TIMEOUT;

		// Get response poll period
		//
		GetRegValueLong (	hKey,
							&c_szResponsePollPeriod[0],
							(LONG *) &g_uResponsePollPeriod,
							ILS_DEF_RESP_POLL_PERIOD);
		
		// Make sure the value is within the range
		//
		if (g_uResponsePollPeriod < ILS_MIN_RESP_POLL_PERIOD)
			g_uResponsePollPeriod = ILS_MIN_RESP_POLL_PERIOD;

		// Get client signature
		//
		GetRegValueLong (	hKey,
							&c_szClientSig[0],
							(LONG *) &g_dwClientSig,
							(LONG) -1);

		RegCloseKey (hKey);
	}

	// Make sure this value is not -1
	//
	if (g_dwClientSig == (ULONG) -1)
	{
		// The client signature does not exist.
		// We need to generate a new one
		//
		g_dwClientSig = GetTickCount ();

		// Save it back to the registry
		//
		DWORD dwDontCare;
		if (RegCreateKeyEx (HKEY_CURRENT_USER,
							&c_szUlsLdapSpReg[0],
							0,
							TEXT (""),
							REG_OPTION_NON_VOLATILE,
							KEY_READ | KEY_WRITE,
							NULL,
							&hKey,
							&dwDontCare) == NOERROR)
		{
			RegSetValueEx (	hKey,
							&c_szClientSig[0],
							0,
							REG_DWORD,
							(BYTE *) &g_dwClientSig,
							sizeof (&g_dwClientSig));
		}
	}

	return TRUE;
}


BOOL
GetRegValueLong (
	HKEY		hKey,
	const TCHAR	*pszKey,
	LONG		*plValue,
	LONG		lDefValue )
{
	MyAssert (hKey != NULL);
	MyAssert (pszKey != NULL);
	MyAssert (plValue != NULL);

	*plValue = lDefValue;

	DWORD dwType;
	ULONG cb;
	TCHAR szText[MAX_PATH];

	cb = sizeof (szText);

	if (RegQueryValueEx (	hKey,
							pszKey,
							NULL,
							&dwType,
							(BYTE *) &szText[0],
							&cb)
		== ERROR_SUCCESS)
	{
		switch (dwType)
		{
		case REG_DWORD:
		case REG_BINARY:
			*plValue = *(LONG *) &szText[0];
			break;
		case REG_SZ:
			*plValue = GetStringLong (&szText[0]);
			break;
		default:
			return FALSE;
		}
	}

	return TRUE;
}


/* ------- LDAP error codes ---------- */

const LONG c_LdapErrToHrShort[] =
{
	// End of search (per AndyHe info)
	LDAP_PARAM_ERROR,				ILS_E_PARAMETER,
	// Keep alive fails
	LDAP_NO_SUCH_OBJECT,			ILS_E_NO_SUCH_OBJECT,
	// Logon with conflicting email name
	LDAP_ALREADY_EXISTS,			ILS_E_NAME_CONFLICTS,

	LDAP_OPERATIONS_ERROR,			ILS_E_LDAP_OPERATIONS_ERROR,
	LDAP_PROTOCOL_ERROR,			ILS_E_LDAP_PROTOCOL_ERROR,
	LDAP_TIMELIMIT_EXCEEDED,		ILS_E_LDAP_TIMELIMIT_EXCEEDED,
	LDAP_SIZELIMIT_EXCEEDED,		ILS_E_LDAP_SIZELIMIT_EXCEEDED,
	LDAP_COMPARE_FALSE,				ILS_E_LDAP_COMPARE_FALSE,
	LDAP_COMPARE_TRUE,				ILS_E_LDAP_COMPARE_TRUE,
	LDAP_AUTH_METHOD_NOT_SUPPORTED,	ILS_E_LDAP_AUTH_METHOD_NOT_SUPPORTED,
	LDAP_STRONG_AUTH_REQUIRED,		ILS_E_LDAP_STRONG_AUTH_REQUIRED,
	LDAP_REFERRAL_V2,				ILS_E_LDAP_REFERRAL_V2,
	LDAP_PARTIAL_RESULTS,			ILS_E_LDAP_PARTIAL_RESULTS,
	LDAP_REFERRAL,					ILS_E_LDAP_REFERRAL,
	LDAP_ADMIN_LIMIT_EXCEEDED,		ILS_E_LDAP_ADMIN_LIMIT_EXCEEDED,
	LDAP_UNAVAILABLE_CRIT_EXTENSION,ILS_E_LDAP_UNAVAILABLE_CRIT_EXTENSION,

	LDAP_NO_SUCH_ATTRIBUTE,			ILS_E_LDAP_NO_SUCH_ATTRIBUTE,
	LDAP_UNDEFINED_TYPE,			ILS_E_LDAP_UNDEFINED_TYPE,
	LDAP_INAPPROPRIATE_MATCHING,	ILS_E_LDAP_INAPPROPRIATE_MATCHING,
	LDAP_CONSTRAINT_VIOLATION,		ILS_E_LDAP_CONSTRAINT_VIOLATION,
	LDAP_ATTRIBUTE_OR_VALUE_EXISTS,	ILS_E_LDAP_ATTRIBUTE_OR_VALUE_EXISTS,
	LDAP_INVALID_SYNTAX,			ILS_E_LDAP_INVALID_SYNTAX,

	LDAP_ALIAS_PROBLEM,				ILS_E_LDAP_ALIAS_PROBLEM,
	LDAP_INVALID_DN_SYNTAX,			ILS_E_LDAP_INVALID_DN_SYNTAX,
	LDAP_IS_LEAF,					ILS_E_LDAP_IS_LEAF,
	LDAP_ALIAS_DEREF_PROBLEM,		ILS_E_LDAP_ALIAS_DEREF_PROBLEM,

	LDAP_INAPPROPRIATE_AUTH,		ILS_E_LDAP_INAPPROPRIATE_AUTH,
	LDAP_INVALID_CREDENTIALS,		ILS_E_LDAP_INVALID_CREDENTIALS,
	LDAP_INSUFFICIENT_RIGHTS,		ILS_E_LDAP_INSUFFICIENT_RIGHTS,
	LDAP_BUSY,						ILS_E_LDAP_BUSY,
	LDAP_UNAVAILABLE,				ILS_E_LDAP_UNAVAILABLE,
	LDAP_UNWILLING_TO_PERFORM,		ILS_E_LDAP_UNWILLING_TO_PERFORM,
	LDAP_LOOP_DETECT,				ILS_E_LDAP_LOOP_DETECT,

	LDAP_NAMING_VIOLATION,			ILS_E_LDAP_NAMING_VIOLATION,
	LDAP_OBJECT_CLASS_VIOLATION,	ILS_E_LDAP_OBJECT_CLASS_VIOLATION,
	LDAP_NOT_ALLOWED_ON_NONLEAF,	ILS_E_LDAP_NOT_ALLOWED_ON_NONLEAF,
	LDAP_NOT_ALLOWED_ON_RDN,		ILS_E_LDAP_NOT_ALLOWED_ON_RDN,
	LDAP_NO_OBJECT_CLASS_MODS,		ILS_E_LDAP_NO_OBJECT_CLASS_MODS,
	LDAP_RESULTS_TOO_LARGE,			ILS_E_LDAP_RESULTS_TOO_LARGE,
	LDAP_AFFECTS_MULTIPLE_DSAS,		ILS_E_LDAP_AFFECTS_MULTIPLE_DSAS,

	LDAP_OTHER,						ILS_E_LDAP_OTHER,
	LDAP_SERVER_DOWN,				ILS_E_LDAP_SERVER_DOWN,
	LDAP_LOCAL_ERROR,				ILS_E_LDAP_LOCAL_ERROR,
	LDAP_ENCODING_ERROR,			ILS_E_LDAP_ENCODING_ERROR,
	LDAP_DECODING_ERROR,			ILS_E_LDAP_DECODING_ERROR,
	LDAP_TIMEOUT,					ILS_E_LDAP_TIMEOUT,
	LDAP_AUTH_UNKNOWN,				ILS_E_LDAP_AUTH_UNKNOWN,
	LDAP_FILTER_ERROR,				ILS_E_LDAP_FILTER_ERROR,
	LDAP_USER_CANCELLED,			ILS_E_LDAP_USER_CANCELLED,
	LDAP_NO_MEMORY,					ILS_E_LDAP_NO_MEMORY,
};


HRESULT
LdapError2Hresult ( ULONG uLdapError )
{
	HRESULT	hr;

	switch (uLdapError)
	{
	case LDAP_SUCCESS:
		hr = S_OK;
		break;

	default:
		// If nothing appears to be appropriate
		//
		hr = ILS_E_SERVER_EXEC;

		// Go through the loop to find a matching error code
		//
		for (	INT i = 0;
				i < ARRAY_ELEMENTS (c_LdapErrToHrShort);
				i += 2)
		{
			if (c_LdapErrToHrShort[i] == (LONG) uLdapError)
			{
				hr = (HRESULT) c_LdapErrToHrShort[i+1];
				break;
			}
		}

		MyAssert (hr != ILS_E_SERVER_EXEC);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsapp.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsapp.cpp
//  Content:    This file contains the Application object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "ulsapp.h"
#include "ulsprot.h"
#include "attribs.h"
#include "callback.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IULSApplicationNotify*)pUnk)->GetProtocolResult(pobjri->uReqID,
                                                      (IULSAppProtocol *)pobjri->pv,
                                                      pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum  = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    if (SUCCEEDED(hr))
    {
        // Create a Application enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IULSApplicationNotify*)pUnk)->EnumProtocolsResult(peri->uReqID,
                                                        penum != NULL ? 
                                                        (IEnumULSNames *)penum :
                                                        NULL,
                                                        hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CUlsApp::CUlsApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsApp::CUlsApp (void)
{
    cRef        = 0;
    szServer    = NULL;
    szUser      = NULL;
    guid        = GUID_NULL;
    szName      = NULL;
    szMimeType  = NULL;
    pAttrs      = NULL;
    pConnPt     = NULL;

    return;
}

//****************************************************************************
// CUlsApp::~CUlsApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsApp::~CUlsApp (void)
{
    if (szServer != NULL)
        FreeLPTSTR(szServer);
    if (szUser != NULL)
        FreeLPTSTR(szUser);
    if (szName != NULL)
        FreeLPTSTR(szName);
    if (szMimeType != NULL)
        FreeLPTSTR(szMimeType);

    // Release attribute object
    //
    if (pAttrs != NULL)
    {
        pAttrs->Release();
    };

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::Init (LPTSTR szServerName, LPTSTR szUserName, PLDAP_APPINFO pai)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::Init (LPTSTR szServerName, LPTSTR szUserName, PLDAP_APPINFO pai)
{
    HRESULT hr;

    // Validate parameter
    //
    if ((pai->uSize != sizeof(*pai))    ||
//      (pai->guid  == GUID_NULL)       || // Allow null GUID for http register
        (pai->uOffsetName       == 0)   ||
        (pai->uOffsetMimeType  == 0))
    {
        return ULS_E_PARAMETER;
    };

    if ((pai->cAttributes != 0) && (pai->uOffsetAttributes == 0))
    {
        return ULS_E_PARAMETER;        
    };

    // Remember application GUID
    //
    guid = pai->guid;

    // Remember the server name
    //
    hr = SetLPTSTR(&szServer, szServerName);

    if (SUCCEEDED(hr))
    {
        hr = SetLPTSTR(&szUser, szUserName);

        if (SUCCEEDED(hr))
        {
            hr = SetLPTSTR(&szName,
                           (LPCTSTR)(((PBYTE)pai)+pai->uOffsetName));

            if (SUCCEEDED(hr))
            {
                hr = SetLPTSTR(&szMimeType,
                               (LPCTSTR)(((PBYTE)pai)+pai->uOffsetMimeType));

                if (SUCCEEDED(hr))
                {
                    CAttributes *pNewAttrs;

                    // Build the attribute object
                    //
                    pNewAttrs = new CAttributes (ULS_ATTRACCESS_NAME_VALUE);

                    if (pNewAttrs != NULL)
                    {
                        if (pai->cAttributes != 0)
                        {
                            hr = pNewAttrs->SetAttributePairs((LPTSTR)(((PBYTE)pai)+pai->uOffsetAttributes),
                                                              pai->cAttributes);
                        };

                        if (SUCCEEDED(hr))
                        {
                            pAttrs = pNewAttrs;
                            pNewAttrs->AddRef();
                        }
                        else
                        {
                            delete pNewAttrs;
                        };
                    }
                    else
                    {
                        hr = ULS_E_MEMORY;
                    };
                };
            };
        };
    };

    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        pConnPt = new CConnectionPoint (&IID_IULSApplicationNotify,
                                        (IConnectionPointContainer *)this);
        if (pConnPt != NULL)
        {
            ((IConnectionPoint*)pConnPt)->AddRef();
            hr = NOERROR;
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSApplication || riid == IID_IUnknown)
    {
        *ppv = (IULSUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsApp::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsApp::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsApp::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsApp::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetID (GUID *pGUID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetID (GUID *pGUID)
{
    // Validate parameter
    //
    if (pGUID == NULL)
    {
        return ULS_E_POINTER;
    };
    
    *pGUID = guid;

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetName (BSTR *pbstrAppName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetName (BSTR *pbstrAppName)
{
    // Validate parameter
    //
    if (pbstrAppName == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrAppName, szName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetMimeType (BSTR *pbstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetMimeType (BSTR *pbstrMimeType)
{
    // Validate parameter
    //
    if (pbstrMimeType == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrMimeType, szMimeType);
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetAttributes (IULSAttributes **ppAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetAttributes (IULSAttributes **ppAttributes)
{
    // Validate parameter
    //
    if (ppAttributes == NULL)
    {
        return ULS_E_POINTER;
    };

    *ppAttributes = pAttrs;
    pAttrs->AddRef();

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetProtocol (BSTR bstrProtocolID, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetProtocol (BSTR bstrProtocolID, IULSAttributes *pAttributes, ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    LPTSTR pszID;
    HRESULT hr;

    // Validate parameter
    //
    if (bstrProtocolID == NULL || puReqID == NULL)
        return ULS_E_POINTER;

	// Convert protocol name
	//
    hr = BSTR_to_LPTSTR(&pszID, bstrProtocolID);
	if (hr != S_OK)
		return hr;

	// Get arbitrary attribute name list if any
	//
	ULONG cAttrNames = 0;
	ULONG cbNames = 0;
	TCHAR *pszAttrNameList = NULL;
	if (pAttributes != NULL)
	{
		hr = ((CAttributes *) pAttributes)->GetAttributeList (&pszAttrNameList, &cAttrNames, &cbNames);
		if (hr != S_OK)
			return hr;
	}

	hr = ::UlsLdap_ResolveProtocol (szServer, szUser, szName, pszID,
										pszAttrNameList, cAttrNames, &ldai);
	if (hr != S_OK)
		goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
	REQUESTINFO ri;
	ZeroMemory (&ri, sizeof (ri));
	ri.uReqType = WM_ULS_RESOLVE_PROTOCOL;
	ri.uMsgID = ldai.uMsgID;
	ri.pv     = (PVOID) this;
	ri.lParam = NULL;

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest(&ri);
	if (SUCCEEDED(hr))
	{
	    // Make sure the objects do not disappear before we get the response
	    //
	    this->AddRef();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	};

MyExit:

	if (pszAttrNameList != NULL)
		FreeLPTSTR (pszAttrNameList);

	if (pszID != NULL)
		FreeLPTSTR(pszID);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
{
    CUlsProt *pp;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = ppir->hResult;

    if (SUCCEEDED(objri.hResult))
    {
        // The server returns PROTINFO, create a Application object
        //
        pp = new CUlsProt;

        if (pp != NULL)
        {
            objri.hResult = pp->Init(szServer, szUser, szName, &ppir->lpi);
            if (SUCCEEDED(objri.hResult))
            {
                pp->AddRef();
            }
            else
            {
                delete pp;
                pp = NULL;
            };
        }
        else
        {
            objri.hResult = ULS_E_MEMORY;
        };
    }
    else
    {
        pp = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pp == NULL ? NULL : (IULSAppProtocol *)pp);
    NotifySink((void *)&objri, OnNotifyGetProtocolResult);

    if (pp != NULL)
    {
        pp->Release();
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::EnumProtocols (ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::EnumProtocols (ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (puReqID == NULL)
    {
        return ULS_E_POINTER;
    };

    hr = ::UlsLdap_EnumProtocols(szServer, szUser, szName, &ldai);

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ULS_ENUM_PROTOCOLS;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)NULL;

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;
    eri.hResult = ple->hResult;
    eri.cItems  = ple->cItems;
    eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    NotifySink((void *)&eri, OnNotifyEnumProtocolsResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ULS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CUlsApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ULS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ULS_E_NO_INTERFACE;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsldap.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsldap.h
//  Content:    This file contains the declaration for LDAP function calls
//  History:
//      Tue 08-Oct-1996 08:54:45  -by-  Lon-Chan Chu [lonchanc]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ILS_LDAP_H_
#define _ILS_LDAP_H_

#include <pshpack8.h>

//
// Asynchronous request result:
//
// **********************************************************************************
//      Message                                                 wParam  lParam
// **********************************************************************************
//
#define WM_ILS_ASYNC_RES                (WM_USER+0x1001)

// client object
#define WM_ILS_REGISTER_CLIENT          (WM_ILS_ASYNC_RES+0) // uMsgID  hResult
#define WM_ILS_UNREGISTER_CLIENT        (WM_ILS_ASYNC_RES+1) // uMsgID  hResult
#define WM_ILS_SET_CLIENT_INFO          (WM_ILS_ASYNC_RES+2) // uMsgID  hResult
#define WM_ILS_RESOLVE_CLIENT           (WM_ILS_ASYNC_RES+3)// uMsgID  PLDAP_USERINFO_RES
#define WM_ILS_ENUM_CLIENTS             (WM_ILS_ASYNC_RES+4)// uMsgID  PLDAP_ENUM
#define WM_ILS_ENUM_CLIENTINFOS         (WM_ILS_ASYNC_RES+5)// uMsgID  PLDAP_ENUM

// protocol object
#define WM_ILS_REGISTER_PROTOCOL        (WM_ILS_ASYNC_RES+6) // uMsgID  hResult
#define WM_ILS_UNREGISTER_PROTOCOL      (WM_ILS_ASYNC_RES+7) // uMsgID  hResult
#define WM_ILS_SET_PROTOCOL_INFO        (WM_ILS_ASYNC_RES+8) // uMsgID  hResult
#define WM_ILS_RESOLVE_PROTOCOL         (WM_ILS_ASYNC_RES+9)// uMsgID  PLDAP_PROTINFO_RES
#define WM_ILS_ENUM_PROTOCOLS           (WM_ILS_ASYNC_RES+10)// uMsgID  PLDAP_ENUM

#ifdef ENABLE_MEETING_PLACE
// meeting object
#define WM_ILS_REGISTER_MEETING         (WM_ILS_ASYNC_RES+11)
#define WM_ILS_UNREGISTER_MEETING       (WM_ILS_ASYNC_RES+12)
#define WM_ILS_SET_MEETING_INFO         (WM_ILS_ASYNC_RES+13)
#define WM_ILS_RESOLVE_MEETING          (WM_ILS_ASYNC_RES+14)
#define WM_ILS_ENUM_MEETINGINFOS        (WM_ILS_ASYNC_RES+15)
#define WM_ILS_ENUM_MEETINGS            (WM_ILS_ASYNC_RES+16)
#define WM_ILS_ADD_ATTENDEE             (WM_ILS_ASYNC_RES+17)
#define WM_ILS_REMOVE_ATTENDEE          (WM_ILS_ASYNC_RES+18)
#define WM_ILS_ENUM_ATTENDEES           (WM_ILS_ASYNC_RES+19)
#define WM_ILS_CANCEL                   (WM_ILS_ASYNC_RES+20)
#else
#define WM_ILS_CANCEL                   (WM_ILS_ASYNC_RES+11)
#endif

#define WM_ILS_LAST_ONE                 WM_ILS_CANCEL

// client notification
#define WM_ILS_CLIENT_NEED_RELOGON      (WM_ILS_ASYNC_RES+51)// fPrimary  pszServerName
#define WM_ILS_CLIENT_NETWORK_DOWN      (WM_ILS_ASYNC_RES+52)// fPrimary  pszServerName

#ifdef ENABLE_MEETING_PLACE
// meeting notification
#define WM_ILS_MEETING_NEED_RELOGON     (WM_ILS_ASYNC_RES+61)
#define WM_ILS_MEETING_NETWORK_DOWN     (WM_ILS_ASYNC_RES+62)
#endif


//
// Constants
//
#define INVALID_OFFSET			0
#define INVALID_USER_FLAGS		-1	// used in LDAP_USERINFO dwFlags

#ifdef ENABLE_MEETING_PLACE
#define INVALID_MEETING_FLAGS	0	// used in LDAP_MEETINFO dwFlags
#define INVALID_MEETING_TYPE	0	// used in LDAP_MEETINFO lMeetingType
#define INVALID_ATTENDEE_TYPE	0	// used in LDAP_MEETINFO lAttendeeType
#endif

//
// Asynchronous response info structures
//
typedef struct tagLDAPAsyncInfo
{
    ULONG           uMsgID;
}
    LDAP_ASYNCINFO, *PLDAP_ASYNCINFO;

typedef struct tagLDAPEnum
{
    ULONG           uSize;
    HRESULT         hResult;
    ULONG           cItems;
    ULONG           uOffsetItems;
}
    LDAP_ENUM, *PLDAP_ENUM;

typedef struct tagLDAPClientInfo
{
    ULONG           uSize;
    // user object attributes
    ULONG           uOffsetCN;
    ULONG           uOffsetFirstName;
    ULONG           uOffsetLastName;
    ULONG           uOffsetEMailName;
    ULONG           uOffsetCityName;
    ULONG           uOffsetCountryName;
    ULONG           uOffsetComment;
    ULONG           uOffsetIPAddress;
    DWORD           dwFlags;        // 0, private; 1, public
    // app object attributes
    ULONG           uOffsetAppName;
    ULONG           uOffsetAppMimeType;
    GUID            AppGuid;
    // app extended attributes to add, modify, and remove
    ULONG           cAttrsToAdd;
    ULONG           uOffsetAttrsToAdd;
    ULONG           cAttrsToModify;
    ULONG           uOffsetAttrsToModify;
    ULONG           cAttrsToRemove;
    ULONG           uOffsetAttrsToRemove;
	// for notification of enum-user-infos
	ULONG			cAttrsReturned;
	ULONG			uOffsetAttrsReturned;
}
	LDAP_CLIENTINFO, *PLDAP_CLIENTINFO;


typedef struct tagLDAPClientInfoRes
{
    ULONG           uSize;
    HRESULT         hResult;
    LDAP_CLIENTINFO lci;
}
	LDAP_CLIENTINFO_RES, *PLDAP_CLIENTINFO_RES;

typedef struct tagLDAPProtocolInfo
{
    ULONG           uSize;
	// protocol standard attributes
    ULONG           uOffsetName;
    ULONG           uPortNumber;
    ULONG           uOffsetMimeType;
}
    LDAP_PROTINFO, *PLDAP_PROTINFO;

typedef struct tagLDAPProtInfoRes
{
    ULONG           uSize;
    HRESULT         hResult;
    LDAP_PROTINFO   lpi;
}
    LDAP_PROTINFO_RES, *PLDAP_PROTINFO_RES;

#ifdef ENABLE_MEETING_PLACE
typedef struct tagLDAPMeetingInfo
{
    ULONG           uSize;
	// meeting standard attributes
    LONG            lMeetingPlaceType;
    LONG            lAttendeeType;
    ULONG           uOffsetMeetingPlaceID;
    ULONG           uOffsetDescription;
    ULONG           uOffsetHostName;
    ULONG           uOffsetHostIPAddress;
    // meeting extended attributes to add, modify, and remove
    ULONG           cAttrsToAdd;
    ULONG           uOffsetAttrsToAdd;
    ULONG           cAttrsToModify;
    ULONG           uOffsetAttrsToModify;
    ULONG           cAttrsToRemove;
    ULONG           uOffsetAttrsToRemove;
	// for notification of enum-meeting-infos
	ULONG			cAttrsReturned;
	ULONG			uOffsetAttrsReturned;
}
    LDAP_MEETINFO, *PLDAP_MEETINFO;
#endif


#ifdef ENABLE_MEETING_PLACE
typedef struct tagLDAPMeetingInfoRes
{
    ULONG               uSize;
    HRESULT             hResult;
    LDAP_MEETINFO       lmi;
}
    LDAP_MEETINFO_RES, *PLDAP_MEETINFO_RES;
#endif


// Initialization

HRESULT UlsLdap_Initialize (
    HWND            hwndCallback);

HRESULT UlsLdap_Deinitialize (void);

HRESULT UlsLdap_Cancel (
    ULONG           uMsgID);


// Clients related

HRESULT UlsLdap_RegisterClient (
    DWORD_PTR           dwContext,
    SERVER_INFO         *pServer,
    PLDAP_CLIENTINFO    pCleintInfo,
    PHANDLE             phClient,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_UnRegisterClient (
    HANDLE              hClient,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_SetClientInfo (
    HANDLE              hClient,
    PLDAP_CLIENTINFO    pInfo,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_EnumClients (
    SERVER_INFO         *pServer,
    LPTSTR              pszFilter,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_ResolveClient (
    SERVER_INFO         *pServer,
    LPTSTR              pszUserName,
    LPTSTR              pszAppName,
    LPTSTR              pszProtName,
    LPTSTR              pszAttrNameList,
    ULONG               cAttrNames,
    PLDAP_ASYNCINFO     pAsyncInfo );

HRESULT UlsLdap_EnumClientInfos (
    SERVER_INFO         *pServer,
    LPTSTR              pszAttrNameList,
    ULONG               cAttrNames,
    LPTSTR              pszFilter,
    PLDAP_ASYNCINFO     pAsyncInfo );


// Protocols related

HRESULT UlsLdap_RegisterProtocol (
    HANDLE          hApp,
    PLDAP_PROTINFO  pProtInfo,
    PHANDLE         phProt,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_UnRegisterProtocol (
    HANDLE          hProt,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_VirtualUnRegisterProtocol (
    HANDLE          hProt );

HRESULT UlsLdap_SetProtocolInfo (
    HANDLE          hProt,
    PLDAP_PROTINFO  pInfo,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_EnumProtocols (
    SERVER_INFO     *pServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_ResolveProtocol (
    SERVER_INFO     *pServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    LPTSTR          pszProtName,
    LPTSTR          pszAnyAttrNameList,
    ULONG           cAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo );


#ifdef ENABLE_MEETING_PLACE
// Meetings related

HRESULT UlsLdap_RegisterMeeting(
    DWORD           dwContext,
    SERVER_INFO     *pServer,
    PLDAP_MEETINFO  pMeetInfo,
    PHANDLE         phMeeting,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_UnRegisterMeeting(
    HANDLE          hMeeting,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_EnumMeetingInfos(
    SERVER_INFO     *pServer,
    LPTSTR          pszAnyAttrNameList,
    ULONG           cAnyAttrNames,
    LPTSTR          pszFilter,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_EnumMeetings(
    SERVER_INFO     *pServer,
    LPTSTR          pszFilter,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_ResolveMeeting(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    LPTSTR          pszAnyAttrNameList,
    ULONG           cAnyAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_SetMeetingInfo(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    PLDAP_MEETINFO  pMeetInfo,
    PLDAP_ASYNCINFO pAsyncInfo );

HRESULT UlsLdap_AddAttendee(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    ULONG           cAttendees,
    LPTSTR          pszAttendeeID,
    PLDAP_ASYNCINFO pAsyncInfo  );

HRESULT UlsLdap_RemoveAttendee(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    ULONG           cAttendees,
    LPTSTR          pszAttendeeID,
    PLDAP_ASYNCINFO pAsyncInfo  );

HRESULT UlsLdap_EnumAttendees(
    SERVER_INFO     *pServer,
    LPTSTR          pszMeetingID,
    LPTSTR          pszFilter,
    PLDAP_ASYNCINFO pAsyncInfo  );

#endif // ENABLE_MEETING_PLACE



const TCHAR *UlsLdap_GetStdAttrNameString (
    ILS_STD_ATTR_NAME StdName );

const TCHAR *UlsLdap_GetExtAttrNamePrefix ( VOID );


#include <poppack.h>

#endif // _ILS_LDAP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsp.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsp.h
//  Content:    This file contains the declaration for ULS.DLL
//  History:
//      Tue 08-Oct-1996 08:54:45  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSP_H_
#define _ULSP_H_

// LonChanC: ENABLE_MEETING_PLACE is to enable the meeting place code.
// The meeting place code is disabled for NM 2.0 Beta 4.
//
// #define ENABLE_MEETING_PLACE

//****************************************************************************
// Global Include File
//****************************************************************************

#define _INC_OLE

#include <windows.h>        // also includes windowsx.h
#include <tchar.h>          // Unicode-aware code
#include <ole2.h>
#include <olectl.h>

#include <stock.h>          // Standard NetMeeting definitions
#include <ulsreg.h>         // Registry key/value definitions for ULS
#include <memtrack.h>

#include "uls.h"            // User Location Services COM object


#include "utils.h"


//****************************************************************************
// Class Forward Definitions
//****************************************************************************

class CEnumConnectionPoints;
class CConnectionPoint;
class CEnumConnections;
class CEnumNames;
class CIlsMain;
class CIlsServer;
class CAttributes;
class CLocalProt;
class CIlsUser;
class CIlsMeetingPlace;

class CFilter;
class CFilterParser;

#include "debug.h"
#include "request.h"

//****************************************************************************
// Constant Definitions
//****************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

//****************************************************************************
// Macros
//****************************************************************************

#define ARRAYSIZE(x)        (sizeof(x)/sizeof(x[0]))

//****************************************************************************
// Global Parameters
//****************************************************************************

extern  HINSTANCE           g_hInstance;
extern  CRITICAL_SECTION    g_ULSSem;
extern  CIlsMain            *g_pCIls;
extern  CReqMgr             *g_pReqMgr;

//****************************************************************************
// Global routine
//****************************************************************************

void DllLock(void);
void DllRelease(void);

#ifdef __cplusplus
}
#endif

//****************************************************************************
// Local Header Files
//****************************************************************************

#include "sputils.h"
#include "spserver.h"
#include "ulsldap.h"


#endif  //_ULSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsprot.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsprot.cpp
//  Content:    This file contains the Protocol object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "ulsprot.h"
#include "attribs.h"

//****************************************************************************
// CUlsProt::CUlsProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsProt::CUlsProt (void)
{
    cRef        = 0;
    szServer    = NULL;
    szUser      = NULL;
    szApp       = NULL;
    szName      = NULL;
    szMimeType  = NULL;
    uPort       = 0;
    pAttrs      = NULL;

    return;
}

//****************************************************************************
// CUlsProt::~CUlsProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsProt::~CUlsProt (void)
{
    if (szServer != NULL)
        FreeLPTSTR(szServer);
    if (szUser != NULL)
        FreeLPTSTR(szUser);
    if (szApp != NULL)
        FreeLPTSTR(szApp);
    if (szName != NULL)
        FreeLPTSTR(szName);
    if (szMimeType != NULL)
        FreeLPTSTR(szMimeType);

    // Release attribute object
    //
    if (pAttrs != NULL)
    {
        pAttrs->Release();
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::Init (LPTSTR szServerName, LPTSTR szUserName, 
//                 LPTSTR szAppName, PLDAP_PROTINFO ppi)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::Init (LPTSTR szServerName, LPTSTR szUserName, 
                LPTSTR szAppName, PLDAP_PROTINFO ppi)
{
    HRESULT hr;

    // Validate parameter
    //
    if ((ppi->uSize != sizeof(*ppi))    ||
        (ppi->uPortNumber == 0)         ||
        (ppi->uOffsetName == 0)   ||
        (ppi->uOffsetMimeType  == 0))
    {
        return ULS_E_PARAMETER;
    };

    if ((ppi->cAttributes != 0) && (ppi->uOffsetAttributes == 0))
    {
        return ULS_E_PARAMETER;        
    };

    // Remember port name
    //
    uPort = ppi->uPortNumber;

    // Remember the server name
    //
    hr = SetLPTSTR(&szServer, szServerName);

    if (SUCCEEDED(hr))
    {
        hr = SetLPTSTR(&szUser, szUserName);

        if (SUCCEEDED(hr))
        {
            hr = SetLPTSTR(&szApp, szAppName);

            if (SUCCEEDED(hr))
            {
                hr = SetLPTSTR(&szName,
                               (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetName));

                if (SUCCEEDED(hr))
                {
                    hr = SetLPTSTR(&szMimeType,
                                   (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetMimeType));

                    if (SUCCEEDED(hr))
                    {
                        CAttributes *pNewAttrs;

                        // Build the attribute object
                        //
                        pNewAttrs = new CAttributes (ULS_ATTRACCESS_NAME_VALUE);

                        if (pNewAttrs != NULL)
                        {
                            if (ppi->cAttributes != 0)
                            {
                                hr = pNewAttrs->SetAttributePairs((LPTSTR)(((PBYTE)ppi)+ppi->uOffsetAttributes),
                                                                  ppi->cAttributes);
                            };

                            if (SUCCEEDED(hr))
                            {
                                pAttrs = pNewAttrs;
                                pNewAttrs->AddRef();
                            }
                            else
                            {
                                delete pNewAttrs;
                            };
                        }
                        else
                        {
                            hr = ULS_E_MEMORY;
                        };
                    };
                };
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSAppProtocol || riid == IID_IUnknown)
    {
        *ppv = (IULSUser *) this;
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsProt::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsProt::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsProt::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsProt::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetID (BSTR *pbstrID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetID (BSTR *pbstrID)
{
    // Validate parameter
    //
    if (pbstrID == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrID, szName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetPortNumber (ULONG *puPortNumber)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetPortNumber (ULONG *puPortNumber)
{
    // Validate parameter
    //
    if (puPortNumber == NULL)
    {
        return ULS_E_POINTER;
    };
    
    *puPortNumber = uPort;

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetMimeType (BSTR *pbstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetMimeType (BSTR *pbstrMimeType)
{
    // Validate parameter
    //
    if (pbstrMimeType == NULL)
    {
        return ULS_E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrMimeType, szMimeType);
}

//****************************************************************************
// STDMETHODIMP
// CUlsProt::GetAttributes (IULSAttributes **ppAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsProt::GetAttributes (IULSAttributes **ppAttributes)
{
    // Validate parameter
    //
    if (ppAttributes == NULL)
    {
        return ULS_E_POINTER;
    };

    *ppAttributes = pAttrs;
    pAttrs->AddRef();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsmeet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ulsmeet.cpp
//
//  Contents:   MeetingPlace Object implementation
//
//  Classes:    CIlsMeetingPlace, CEnumMeetingPlace, CIlsAttendee, CEnumAttendee
//
//  Functions:  
//
//  History:    11/25/96 Shishir Pardikar [shishirp] Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "ulsp.h"

#ifdef ENABLE_MEETING_PLACE

#include "ulsmeet.h"
#include "callback.h"
#include "filter.h"



/***************************************************************************
Notification functions.
These functions are called by the general purpose connectionpoint object.
These are called for each Sink object attached to the connection point using
"Advise" member function of the IConnectionPoint interface
****************************************************************************/

//****************************************************************************
//
// HRESULT OnNotifyRegisterMeetingPlaceResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyRegisterMeetingPlaceResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->RegisterResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyUnregisterMeetingPlaceResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyUnregisterMeetingPlaceResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->RegisterResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyUpdateMeetingPlaceResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyUpdateMeetingPlaceResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->UpdateResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyAddAttendeeResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyAddAttendeeResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->AttendeeChangeResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;

}

//****************************************************************************
//
// HRESULT OnNotifyRemoveAttendeeResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT
OnNotifyRemoveAttendeeResult(IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsMeetingPlaceNotify *)pUnk)->AttendeeChangeResult(pobjri->uReqID, pobjri->hResult);

    return S_OK;
}

//****************************************************************************
//
// HRESULT OnNotifyEnumAttendeeNamesResult(IUnknown *pUnk, void *pv) 
// 
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
//  Notes:
//
//****************************************************************************
HRESULT OnNotifyEnumAttendeeNamesResult(IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum   = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    // Create the enumerator only when there is anything to be enumerated
    //
    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create an AttendeeName enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsMeetingPlaceNotify*)pUnk)->EnumAttendeeNamesResult(peri->uReqID,
                                             penum != NULL ? 
                                             (IEnumIlsNames *)penum :
                                             NULL,
                                             hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}


//****************************************************************************
//
//CIlsMeetingPlace class implementation
//
//****************************************************************************



//****************************************************************************
// Method:  CIlsMeetingPlace::CIlsMeetingPlace (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CIlsMeetingPlace::
CIlsMeetingPlace ( VOID )
:m_cRef (0),
 m_ulState (NULL),
 m_pszMeetingPlaceID (NULL),
 m_lMeetingPlaceType (UNDEFINED_TYPE),
 m_lAttendeeType (UNDEFINED_TYPE),
 m_pszHostName (NULL),
 m_pszHostIPAddress (NULL),
 m_pszDescription (NULL),
 m_hMeetingPlace (NULL),
 m_dwFlags (0),
 m_pIlsServer (NULL),
 m_pConnectionPoint (NULL)
{
	m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
}


//****************************************************************************
// CIlsMeetingPlace::~CIlsMeetingPlace (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CIlsMeetingPlace::
~CIlsMeetingPlace ( VOID )
{
	::MemFree (m_pszMeetingPlaceID);
    ::MemFree (m_pszHostName);
    ::MemFree (m_pszHostIPAddress);
    ::MemFree (m_pszDescription);

    // Release the connection point
    //
    if (m_pConnectionPoint != NULL)
    {
        m_pConnectionPoint->ContainerReleased();
        ((IConnectionPoint*)m_pConnectionPoint)->Release();
    }

    // Free up the server object
    //
    if (m_pIlsServer != NULL)
    	m_pIlsServer->Release ();
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::AllocMeetInfo(PLDAP_MEETINFO *ppMeetInfo, ULONG ulMask)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::AllocMeetInfo(PLDAP_MEETINFO *ppMeetInfo, ULONG ulMask)
{
    HRESULT hr = NOERROR;

    PLDAP_MEETINFO pMeetInfo = NULL;
    LPBYTE  pBuffRunning;
    DWORD   cbT, cbAttribSize, cntAttrs;
    DWORD   cbTotalSize = sizeof(LDAP_MEETINFO);
    TCHAR   *pszPairs = NULL;

    ASSERT(m_pIlsServer != NULL);
    ASSERT(m_pszMeetingPlaceID != NULL);

    cbTotalSize += lstrlen(m_pszMeetingPlaceID)+1;
    cbTotalSize +=  (
                    (((ulMask & ILS_MEET_FLAG_DESCRIPTION_MODIFIED) 
                        && m_pszDescription)?(lstrlen(m_pszDescription)+1):0)
                    +(((ulMask & ILS_MEET_FLAG_HOST_NAME_MODIFIED) 
                        && m_pszHostName)?(lstrlen(m_pszHostName)+1):0)
                    +(((ulMask & ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED) 
                        && m_pszHostIPAddress)?(lstrlen(m_pszHostIPAddress)+1):0)
                    );

    cbTotalSize *= sizeof(TCHAR);

    // if we need to send in the extended attributes, do that

    cbAttribSize = 0;
    if ((ulMask & ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED)) {

        hr = m_ExtendedAttrs.GetAttributePairs(&pszPairs, &cntAttrs, &cbAttribSize);            

        if (!SUCCEEDED(hr)) {

            goto bailout;

        }        

    }

    
    cbTotalSize += cbAttribSize;

    // zeroized buffer
    pMeetInfo = (PLDAP_MEETINFO) ::MemAlloc (cbTotalSize);

    if (pMeetInfo == NULL) {

        hr = ILS_E_MEMORY;
        goto bailout;

    }    

    pMeetInfo->uSize = cbTotalSize;

    pMeetInfo->lMeetingPlaceType = m_lMeetingPlaceType;
    pMeetInfo->lAttendeeType = m_lAttendeeType;

    pBuffRunning = (LPBYTE)(pMeetInfo+1);

    memcpy(pBuffRunning, m_pszMeetingPlaceID, cbT = (lstrlen(m_pszMeetingPlaceID)+1)*sizeof(TCHAR));
    pMeetInfo->uOffsetMeetingPlaceID = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
    pBuffRunning += cbT;

    if ((ulMask & ILS_MEET_FLAG_DESCRIPTION_MODIFIED) && m_pszDescription) {

        memcpy(pBuffRunning, m_pszDescription, cbT = (lstrlen(m_pszDescription)+1)*sizeof(TCHAR));
        pMeetInfo->uOffsetDescription = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
        pBuffRunning += cbT;

    }

    if ((ulMask & ILS_MEET_FLAG_HOST_NAME_MODIFIED) && m_pszHostName) {

        memcpy(pBuffRunning, m_pszHostName, cbT = (lstrlen(m_pszHostName)+1)*sizeof(TCHAR));
        pMeetInfo->uOffsetHostName = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
        pBuffRunning += cbT;

    }

    if ((ulMask & ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED) && m_pszHostIPAddress) {

        memcpy(pBuffRunning, m_pszHostIPAddress, cbT = lstrlen(m_pszHostIPAddress)+1);
        pMeetInfo->uOffsetHostIPAddress = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
        pBuffRunning += cbT;

    }

    if((ulMask & ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED)) {

        if (pszPairs) {

            memcpy(pBuffRunning, pszPairs, cbAttribSize);
            pMeetInfo->uOffsetAttrsToAdd = (ULONG)((LPBYTE)pBuffRunning - (LPBYTE)pMeetInfo);
            pMeetInfo->cAttrsToAdd = cntAttrs;

            pBuffRunning += cbAttribSize;
        }

    }

    *ppMeetInfo = pMeetInfo;


bailout:

    if (!SUCCEEDED(hr)) {

        if (pMeetInfo) {

            ::MemFree (pMeetInfo);

        }

    }

    // the attribute pairs list needs to be freed 
    // whether we succeeded or not
    if (pszPairs) {
        
        ::MemFree (pszPairs);

    }

    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Init(BSTR bstrMeetingPlaceID, LONG lMeetingPlaceType
//                            , LONG lAttendeeType)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::Init(
        BSTR bstrMeetingPlaceID,
        LONG lMeetingPlaceType,
        LONG lAttendeeType)
{
    HRESULT hr;

    if (bstrMeetingPlaceID==NULL){
        return (ILS_E_PARAMETER);
    }

    ASSERT(m_ulState == ILS_UNREGISTERED);

    ASSERT(m_pIlsServer == NULL);

    ASSERT(m_pszMeetingPlaceID == NULL);

    hr = BSTR_to_LPTSTR(&m_pszMeetingPlaceID, bstrMeetingPlaceID);

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    // Make the single connection point
    // When enumerating the ConnectionPointContainer
    // he is the single guy we will give out

    if (SUCCEEDED(hr)) {
        m_pConnectionPoint = new CConnectionPoint (&IID_IIlsMeetingPlaceNotify,
                                    (IConnectionPointContainer *)this);
        if (m_pConnectionPoint != NULL)
        {
            ((IConnectionPoint*)m_pConnectionPoint)->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = ILS_E_MEMORY;
        }
    }
    
    if (SUCCEEDED(hr)) {
        m_lMeetingPlaceType = lMeetingPlaceType;
        m_lAttendeeType = lAttendeeType;
    }

bailout:
    if (!SUCCEEDED(hr)) {

        // do cleanup

        if (m_pszMeetingPlaceID) {
            ::MemFree (m_pszMeetingPlaceID);
            m_pszMeetingPlaceID = NULL; // general paranoia
        }

        if (m_pConnectionPoint) {
            delete m_pConnectionPoint;
            m_pConnectionPoint = NULL;
        }        
    }

    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Init(LPTSTR lpszServer, PLDAP_MEETINFO pmi);
//
// Synopsis: This initializes the MeetingPlace object based on the MEETINFO structure
//           This is used to stuff data into the meeting object from
//           the response obtained from the server to the query _MEETINFO
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::Init(
        CIlsServer *pIlsServer,
        PLDAP_MEETINFO  pmi
    )
{
    HRESULT hr;

    ASSERT(NULL==m_pszMeetingPlaceID);
    ASSERT(NULL==m_pIlsServer);

    //validate bstrMeetingPlaceID

    hr = SafeSetLPTSTR(&m_pszMeetingPlaceID, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetMeetingPlaceID));

    if (!SUCCEEDED(hr)){
        goto bailout;
    }

    // set the state to registered

    m_ulState =  ILS_REGISTERED;

    // set the server field
	m_pIlsServer = pIlsServer;
	pIlsServer->AddRef ();

    hr = SafeSetLPTSTR(&m_pszDescription, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetDescription));

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    hr = SafeSetLPTSTR(&m_pszHostName, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetHostName));

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    hr = SafeSetLPTSTR(&m_pszHostIPAddress, (LPCTSTR)(((PBYTE)pmi)+pmi->uOffsetHostIPAddress));

    if (!SUCCEEDED(hr)) {
        goto bailout;
    }

    // Make the single connection point
    // When enumerating the ConnectionPointContainer
    // he is the single guy we will give out

    m_pConnectionPoint = new CConnectionPoint (&IID_IIlsMeetingPlaceNotify,
                                (IConnectionPointContainer *)this);
    if (m_pConnectionPoint != NULL)
    {
        ((IConnectionPoint*)m_pConnectionPoint)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    }
    if (SUCCEEDED(hr)) {

        m_lMeetingPlaceType =  pmi->lMeetingPlaceType;
        m_lAttendeeType = pmi->lAttendeeType;

    }

bailout:
    if (!SUCCEEDED(hr)) {

        // do cleanup

        if (m_pIlsServer != NULL)
        {
        	m_pIlsServer->Release ();
        	m_pIlsServer = NULL;
        }

        if (m_pszMeetingPlaceID) {
            ::MemFree (m_pszMeetingPlaceID);
            m_pszMeetingPlaceID = NULL; // general paranoia
        }

        if (m_pszDescription) {
            ::MemFree (m_pszDescription);
            m_pszDescription = NULL; // general paranoia
        }

        if (m_pszHostName) {
            ::MemFree (m_pszHostName);
            m_pszHostName = NULL;
        }

        if (m_pszHostIPAddress) {
            ::MemFree (m_pszHostIPAddress);
            m_pszHostIPAddress = NULL;
        }

        if (m_pConnectionPoint) {
            delete m_pConnectionPoint;
            m_pConnectionPoint = NULL;
        }        
        m_ulState = ILS_UNREGISTERED;
    }
    else {
        m_ulState = ILS_IN_SYNC;
    }

    return (hr);
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::QueryInterface (REFIID riid, void **ppv)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsMeetingPlace || riid == IID_IUnknown)
    {
        *ppv = (IIlsUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMeetingPlace::AddRef (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMeetingPlace::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsMeetingPlace::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMeetingPlace::Release (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMeetingPlace::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsMeetingPlace::Release: ref=%ld\r\n", m_cRef));
    if(::InterlockedDecrement (&m_cRef) == 0)
    {
	    delete this;
	    return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (m_pConnectionPoint != NULL)
    {
        hr = m_pConnectionPoint->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetState (ULONG *pulState)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 12/10/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::GetState (ULONG *pulState)
{

    // Validate parameter
    //

    *pulState = m_ulState;

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetMeetingPlaceType (LONG *plMeetingPlaceType)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::GetMeetingPlaceType (LONG *plMeetingPlaceType)
{

    // Validate parameter
    //

    *plMeetingPlaceType = m_lMeetingPlaceType;

    return NOERROR;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetAttendeeType (LONG *plAttendeeType)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::GetAttendeeType (LONG *plAttendeeType)
{

    // Validate parameter
    //

    *plAttendeeType = m_lAttendeeType;

    return NOERROR;

}


//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR *pbstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::GetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                *pbstrStdAttr
)
{
    LPTSTR lpszAttr = NULL;
    BOOL    fValid = TRUE;
    HRESULT hr;

    if (pbstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }
    switch(stdAttr) {

    case ILS_STDATTR_MEETING_ID:
        lpszAttr = m_pszMeetingPlaceID;
        break;
    case ILS_STDATTR_MEETING_HOST_NAME:
        lpszAttr = m_pszHostName;
        break;

    case ILS_STDATTR_MEETING_HOST_IP_ADDRESS:
        lpszAttr = m_pszHostIPAddress;
        break;

    case ILS_STDATTR_MEETING_DESCRIPTION:
        lpszAttr = m_pszDescription;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        if (lpszAttr){

            hr = LPTSTR_to_BSTR(pbstrStdAttr, lpszAttr);
        }
        else {

            *pbstrStdAttr = NULL;
            hr = NOERROR;

        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::SetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR bstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::SetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                bstrStdAttr
)
{
    LPTSTR *ppszAttr = NULL, pszNewAttr;
    BOOL    fValid = TRUE;
    ULONG   ulModBit = 0;
    HRESULT hr;

    if (bstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }

    switch(stdAttr) {

    case ILS_STDATTR_MEETING_HOST_NAME:
        ppszAttr = &m_pszHostName;
        ulModBit = ILS_MEET_FLAG_HOST_NAME_MODIFIED;
        break;

    case ILS_STDATTR_MEETING_HOST_IP_ADDRESS:
        ppszAttr = &m_pszHostIPAddress;
        ulModBit = ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED;
        break;

    case ILS_STDATTR_MEETING_DESCRIPTION:
        ppszAttr = &m_pszDescription;
        ulModBit = ILS_MEET_FLAG_DESCRIPTION_MODIFIED;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        // Duplicate the string
        //
        hr = BSTR_to_LPTSTR (&pszNewAttr, bstrStdAttr);

        if (SUCCEEDED(hr))
        {
            ::MemFree (*ppszAttr);
            *ppszAttr = pszNewAttr;
            m_dwFlags |= ulModBit;
        };
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::SetExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue )
{
	m_dwFlags |= ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED;
	return m_ExtendedAttrs.SetAttribute (bstrName, bstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RemoveExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
RemoveExtendedAttribute ( BSTR bstrName )
{
	m_dwFlags |= ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED;
	return m_ExtendedAttrs.SetAttribute (bstrName, NULL);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsMeetingPlace::
GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
	return m_ExtendedAttrs.GetAttribute (bstrName, pbstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::GetAllExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsMeetingPlace::
GetAllExtendedAttributes ( IIlsAttributes **ppAttributes )
{
    if (ppAttributes == NULL)
        return ILS_E_PARAMETER;

    return m_ExtendedAttrs.CloneNameValueAttrib((CAttributes **) ppAttributes);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Register (
//  BSTR    bstrServerName,
//  BSTR    bstrAuthInfo,
//  ILS_ENUM_AUTH_TYPE  ulsAuthInfo,
//  ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//          pulID - ID to identify the asynchronous transaction
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
Register (
	IIlsServer		*pServer,
	ULONG			*pulID )
{
    HRESULT hr;
    LDAP_ASYNCINFO ldai; 

    ASSERT(m_pszMeetingPlaceID != NULL);

    // Validate parameters
    //
	if (::MyIsBadServer (pServer) || pulID == NULL)
        return ILS_E_POINTER;

	// Make sure we have not done registration before
	//
	if (m_pIlsServer != NULL)
		return ILS_E_FAIL;

	// Clone ther server object
	//
	CIlsServer *pis = ((CIlsServer *) pServer)->Clone ();
	if (pis == NULL)
		return ILS_E_MEMORY;

	// Free the old server object if any
	//
	::MemFree (m_pIlsServer);

	// Keep the new server object
	//
	m_pIlsServer = pis;

    // Allocate memory for LDAP_MEETINFO structure
    //
    PLDAP_MEETINFO pMeetInfo = NULL;
    hr = AllocMeetInfo(&pMeetInfo, ILS_MEET_ALL_MODIFIED);
    if (SUCCEEDED(hr))
    {
        ASSERT(m_hMeetingPlace == NULL);
    
        hr = ::UlsLdap_RegisterMeeting ((DWORD) this,
        								m_pIlsServer->GetServerInfo (),
        								pMeetInfo,
        								&m_hMeetingPlace,
        								&ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_REGISTER_MEETING;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
                
        };
    }
    ::MemFree (pMeetInfo);

    if (FAILED (hr))
    {
		m_pIlsServer->Release ();
		m_pIlsServer = NULL;
    }
    else
    {
        m_ulState = ILS_REGISTERING;
    }

    return hr;
}



//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Unregister (ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::Unregister (ULONG *pulID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr = ILS_E_NOT_REGISTERED;
    
    ASSERT(m_pszMeetingPlaceID != NULL);

    // BUGBUG how about ILS_MEETING_PLACE_IN_SYNC

    if (m_ulState == ILS_REGISTERED)
    {
        ASSERT(m_pIlsServer != NULL);
        ASSERT(m_hMeetingPlace != NULL);

        hr = ::UlsLdap_UnRegisterMeeting(m_hMeetingPlace, &ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_UNREGISTER_MEETING;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };

            m_ulState = ILS_UNREGISTERING;
        }
    }
    else
    {
        hr = ILS_E_NOT_REGISTERED;
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::Update (ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
Update ( ULONG *pulID )
{
    HRESULT hr;
    LDAP_ASYNCINFO ldai; 
    PLDAP_MEETINFO pMeetInfo = NULL;

    if ((m_ulState!=ILS_REGISTERED) 
        &&(m_ulState!=ILS_IN_SYNC)) {

        return (ILS_E_NOT_REGISTERED);

    }

    ASSERT(m_pIlsServer != NULL);

    if (!(m_dwFlags & ILS_MEET_MODIFIED_MASK)) {

        return NOERROR;

    }

    // allocate memory for LDAP_MEETINFO structure
    pMeetInfo = NULL;

    hr = AllocMeetInfo(&pMeetInfo, m_dwFlags & ILS_MEET_MODIFIED_MASK);

    if (SUCCEEDED(hr)) {

        ASSERT(m_hMeetingPlace != NULL);

        pMeetInfo->uOffsetMeetingPlaceID = 
        pMeetInfo->uOffsetDescription = INVALID_OFFSET;
        
        pMeetInfo->lMeetingPlaceType = INVALID_MEETING_TYPE;
        pMeetInfo->lAttendeeType = INVALID_ATTENDEE_TYPE;
    
        hr = ::UlsLdap_SetMeetingInfo ( m_pIlsServer->GetServerInfo (),
										m_pszMeetingPlaceID,
										pMeetInfo,
										&ldai);
    
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_SET_MEETING_INFO;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);

            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
                
        };
    }

    ::MemFree (pMeetInfo);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::AddAttendee (BSTR  bstrAttendeeID, ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//          pbstrAttendeeID - ID of the Attendee to be added, should conform to Attendeetype
//          pulID - ID to identify the asynchronous transaction
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
AddAttendee ( BSTR bstrAttendeeID, ULONG *pulID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;
    LPTSTR pszAttendeeID = NULL;

    if ((m_ulState != ILS_REGISTERED)&&
        (m_ulState != ILS_IN_SYNC))
    {
        return(ILS_E_FAIL); // BUGBUG refine the error
    }

    ASSERT(NULL != m_pIlsServer);
    ASSERT(NULL != m_pszMeetingPlaceID);

    hr = BSTR_to_LPTSTR(&pszAttendeeID, bstrAttendeeID);
    if (SUCCEEDED(hr))
    {
        hr = ::UlsLdap_AddAttendee (m_pIlsServer->GetServerInfo (),
        							m_pszMeetingPlaceID,
        							1,
        							pszAttendeeID,
        							&ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If the request was successfully sent to the server
            // wait for the response

            ri.uReqType = WM_ILS_ADD_ATTENDEE;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
            
        }

        ::MemFree (pszAttendeeID);
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RemoveAttendee (BSTR  bstrAttendeeID, ULONG *pulID)
//
// Synopsis:
//
// Arguments:
//          pbstrAttendeeID - ID of the Attendee to be removed, should conform to Attendeetype
//          pulID - ID to identify the asynchronous transaction
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
RemoveAttendee ( BSTR bstrAttendeeID, ULONG *pulID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;
    LPTSTR pszAttendeeID = NULL;
    
    if ((m_ulState != ILS_REGISTERED)&&
        (m_ulState != ILS_IN_SYNC))
    {
        return(ILS_E_FAIL); // BUBGUG refine
    }

    ASSERT(NULL != m_pIlsServer);
    ASSERT(NULL != m_pszMeetingPlaceID);

    hr = BSTR_to_LPTSTR (&pszAttendeeID, bstrAttendeeID);
    if (SUCCEEDED(hr))
    {
        hr = ::UlsLdap_RemoveAttendee ( m_pIlsServer->GetServerInfo (),
        								m_pszMeetingPlaceID,
        								1,
        								pszAttendeeID,
        								&ldai);
        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If the request was successfully sent to the server
            // wait for the response

            ri.uReqType = WM_ILS_REMOVE_ATTENDEE;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetMeeting (&ri, this);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *pulID = ri.uReqID;
            };
            
        }

        ::MemFree (pszAttendeeID);
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::EnumAttendeeNames(IIlsFilter *pFilter, ULONG *pulID)
//
// Synopsis: enumerate attendees in a meeting based on a filter
//
// Arguments: 
//          [pFilter]           specifies the filter to be used by the server
//                              NULL => no filter
//          [pulID]             request ID returned for keeping track of the
//                              asynchronous operation
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP CIlsMeetingPlace::
EnumAttendeeNames ( IIlsFilter *pFilter, ULONG *pulID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    if ((m_ulState != ILS_REGISTERED)&&
        (m_ulState != ILS_IN_SYNC))
    {
        return(ILS_E_FAIL);
    }

	// Create a ldap-like filter
	//
	TCHAR *pszFilter = NULL;
	hr = ::FilterToLdapString ((CFilter *) pFilter, &pszFilter);
	if (hr != S_OK)
		return hr;

	// Send the request over the wire
	//
    hr = ::UlsLdap_EnumAttendees (	m_pIlsServer->GetServerInfo (),
    								m_pszMeetingPlaceID,
    								pszFilter,
    								&ldai);
    ::MemFree (pszFilter);
    if (SUCCEEDED(hr))
    {
        // If the request was successfully sent to the server
        // wait for the response
        //
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        ri.uReqType = WM_ILS_ENUM_ATTENDEES;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetMeeting (&ri, this);

		// Enter the request
		//
        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *pulID = ri.uReqID;
        };
    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RegisterResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::RegisterResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    if (SUCCEEDED(hr)) {

        m_dwFlags |= ILS_MEET_FLAG_REGISTERED;
        m_ulState = ILS_REGISTERED;

    }        
    else {

        ASSERT(!(m_dwFlags & ILS_MEET_FLAG_REGISTERED));

        m_hMeetingPlace = NULL;  // null out the service provider's handle
        m_ulState = ILS_UNREGISTERED;

    }

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyRegisterMeetingPlaceResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::UnregisterResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::UnregisterResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    if (SUCCEEDED(hr)) {
        m_dwFlags &= ~ILS_MEET_FLAG_REGISTERED;
        m_ulState = ILS_UNREGISTERED;
    }        
    else {
        // BUGBUG, we need an m_oldState variable

        m_ulState = ILS_REGISTERED;
    }

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyUnregisterMeetingPlaceResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::UpdateResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::UpdateResult(ULONG ulID, HRESULT hr)
{
    OBJRINFO objri;

    objri.uReqID = ulID;
    objri.hResult = hr;
    objri.pv = NULL;

    if (SUCCEEDED(hr)) {

        m_dwFlags &= ~ILS_MEET_MODIFIED_MASK;

    }

    NotifySink((VOID *)&objri, OnNotifyUpdateMeetingPlaceResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::AttendeeChangeResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::AddAttendeeResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyAddAttendeeResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::RemoveAttendeeResult(ULONG ulID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::RemoveAttendeeResult(ULONG uReqID, HRESULT hr)
{
    OBJRINFO objri;

    objri.uReqID = uReqID;
    objri.hResult = hr;
    objri.pv = NULL;
    
    NotifySink((VOID *)&objri, OnNotifyRemoveAttendeeResult);

    return NOERROR;    
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::EnumAttendeeNamesResult(ULONG ulID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::EnumAttendeeNamesResult(ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;

    // PLDAP_ENUM is NULL when the enumeration is terminated successfully
    //
    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        eri.cItems  = ple->cItems;
        eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    }
    else
    {
        eri.hResult = S_FALSE;
        eri.cItems  = 0;
        eri.pv      = NULL;
    };
    NotifySink((void *)&eri, OnNotifyEnumAttendeeNamesResult);
    return NOERROR;

}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CIlsMeetingPlace::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)m_pConnectionPoint);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMeetingPlace::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************
STDMETHODIMP
CIlsMeetingPlace::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (m_pConnectionPoint != NULL)
    {
        hr = m_pConnectionPoint->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)m_pConnectionPoint;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}


//****************************************************************************
//
//CEnumMeetingPlaces class implementation
//
//****************************************************************************


//****************************************************************************
// CEnumMeetingPlaces::CEnumMeetingPlaces (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CEnumMeetingPlaces::CEnumMeetingPlaces (void)
{
    m_cRef    = 0;
    m_ppMeetingPlaces     = NULL;
    m_cMeetingPlaces  = 0;
    m_iNext   = 0;
    return;
}

//****************************************************************************
// CEnumMeetingPlaces::~CEnumMeetingPlaces (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

CEnumMeetingPlaces::~CEnumMeetingPlaces (void)
{
    ULONG i;

    if (m_ppMeetingPlaces != NULL)
    {
        for (i = 0; i < m_cMeetingPlaces; i++)
        {
            m_ppMeetingPlaces[i]->Release();
        };
        ::MemFree (m_ppMeetingPlaces);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Init (CIlsMeetingPlace **ppMeetingPlacesList, ULONG cMeetingPlaces)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Init (CIlsMeetingPlace **ppMeetingPlacesList, ULONG cMeetingPlaces)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cMeetingPlaces != 0)
    {
        ASSERT(ppMeetingPlacesList != NULL);

        // Allocate the snapshot buffer
        //
        m_ppMeetingPlaces = (CIlsMeetingPlace **) ::MemAlloc (cMeetingPlaces*sizeof(CIlsMeetingPlace *));

        if (m_ppMeetingPlaces != NULL)
        {
            ULONG i;

            // Snapshot the object list
            //
            for (i =0; i < cMeetingPlaces; i++)
            {
                m_ppMeetingPlaces[i] = ppMeetingPlacesList[i];
                m_ppMeetingPlaces[i]->AddRef();
            };
            m_cMeetingPlaces = cMeetingPlaces;
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::QueryInterface (REFIID riid, void **ppv)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsMeetingPlaces || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsMeetingPlaces *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumMeetingPlaces::AddRef (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumMeetingPlaces::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumMeetingPlaces::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement ((LONG *) &m_cRef);
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumMeetingPlaces::Release (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumMeetingPlaces::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumMeetingPlaces::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement ((LONG *) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumMeetingPlaces::Next (ULONG cMeetingPlaces, IIlsMeetingPlace **rgpm, ULONG *pcFetched)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP 
CEnumMeetingPlaces::Next (ULONG cMeetingPlaces, IIlsMeetingPlace **rgpm, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpm == NULL) {

        return E_POINTER;
    }

    // Validate the parameters
    //
    if ((cMeetingPlaces == 0) ||
        ((cMeetingPlaces > 1) && (pcFetched == NULL))) {

        return ILS_E_PARAMETER;
    }

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more attribute names
    //
    while ((cCopied < cMeetingPlaces) &&
           (m_iNext < this->m_cMeetingPlaces))
    {
        m_ppMeetingPlaces[m_iNext]->AddRef();
        rgpm[cCopied++] = m_ppMeetingPlaces[m_iNext++];
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cMeetingPlaces == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Skip (ULONG cMeetingPlaces)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Skip (ULONG cMeetingPlaces)
{
    ULONG iNewIndex;

    // Validate the parameters
    //
    if (cMeetingPlaces == 0){

        return ILS_E_PARAMETER;
    }

    // Check the enumeration index limit
    //
    iNewIndex = m_iNext+cMeetingPlaces;
    if (iNewIndex <= m_cMeetingPlaces)
    {
        m_iNext = iNewIndex;
        return S_OK;
    }
    else
    {
        m_iNext = m_cMeetingPlaces;
        return S_FALSE;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Reset (void)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Reset (void)
{
    m_iNext = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumMeetingPlaces::Clone(IEnumIlsMeetingPlaces **ppEnum)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 11/25/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

STDMETHODIMP
CEnumMeetingPlaces::Clone(IEnumIlsMeetingPlaces **ppEnum)
{
    CEnumMeetingPlaces *pEnumMeetingPlaces;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pEnumMeetingPlaces = new CEnumMeetingPlaces;

    if (pEnumMeetingPlaces == NULL) {

        return ILS_E_MEMORY;
    }

    // Clone the information
    //
    hr = pEnumMeetingPlaces->Init(m_ppMeetingPlaces, m_cMeetingPlaces);

    if (SUCCEEDED(hr))
    {
        pEnumMeetingPlaces->m_iNext = m_iNext;

        // Return the cloned enumerator
        //
        pEnumMeetingPlaces->AddRef();
        *ppEnum = pEnumMeetingPlaces;
    }
    else
    {
        delete pEnumMeetingPlaces;
    };
    return hr;
}




#endif // ENABLE_MEETING_PLACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsprot.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsprot.h
//  Content:    This file contains the Protocol object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSPROT_H_
#define _ULSPROT_H_

//****************************************************************************
// CUlsProt definition
//****************************************************************************
//
class CUlsProt : public IULSAppProtocol
{
private:
    ULONG                   cRef;
    LPTSTR                  szServer;
    LPTSTR                  szUser;
    LPTSTR                  szApp;
    LPTSTR                  szName;
    LPTSTR                  szMimeType;
    ULONG                   uPort;
    CAttributes             *pAttrs;

public:
    // Constructor and destructor
    CUlsProt (void);
    ~CUlsProt (void);
    STDMETHODIMP            Init (LPTSTR szServerName,
                                  LPTSTR szUserName,
                                  LPTSTR szAppName,
                                  PLDAP_PROTINFO ppi);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSAppProtocol
    STDMETHODIMP    GetID (BSTR *pbstrID);
    STDMETHODIMP    GetPortNumber (ULONG *puPortNumber);
    STDMETHODIMP    GetMimeType (BSTR *pbstrMimeType);
    STDMETHODIMP    GetAttributes (IULSAttributes **ppAttributes);
};

#endif //_ULSPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsmeet.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsmeet.h
//  Content:    This file contains the MeetingPlace object definition.
//  History:
//              Mon 11-Nov-96 -by-  Shishir Pardikar    [shishirp]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSMEET_H_
#define _ULSMEET_H_

#ifdef ENABLE_MEETING_PLACE

#include "connpt.h"
#include "attribs.h"
#include "culs.h"

class CIlsMeetingPlace: public IIlsMeetingPlace,
                        public IConnectionPointContainer
{
#define UNDEFINED_TYPE  -1
#define ILS_MEET_FLAG_REGISTERED            0x00000001

#define ILS_MEET_MODIFIED_MASK                      0xffff0000
#define ILS_MEET_FLAG_HOST_NAME_MODIFIED            0x00010000
#define ILS_MEET_FLAG_HOST_ADDRESS_MODIFIED         0x00020000
#define ILS_MEET_FLAG_DESCRIPTION_MODIFIED          0x00040000
#define ILS_MEET_FLAG_EXTENDED_ATTRIBUTES_MODIFIED  0x00080000

#define ILS_MEET_ALL_MODIFIED                       ILS_MEET_MODIFIED_MASK

    private:

        LONG    m_cRef;             // ref count on this object

        
        // members to keep track of properties
        ULONG   m_ulState;              // the current state of this object
                                        // as defined by ULSState enum type
        LPTSTR  m_pszMeetingPlaceID;    // globally unique ID for the MeetingPlace 
        LONG    m_lMeetingPlaceType;    // meetingtype, eg: netmeeting, doom etc.
        LONG    m_lAttendeeType;        // type of Attendees, eg: urls, rtperson DNs etc.   

        LPTSTR  m_pszHostName;          // Host who registered this MeetingPlace
        LPTSTR  m_pszHostIPAddress;     // IP address of the host
        LPTSTR  m_pszDescription;       // description eg: discussing ski trip
        CAttributes m_ExtendedAttrs;          // User defined attributes
        HANDLE  m_hMeetingPlace;             // handle from ulsldap_register
        CConnectionPoint *m_pConnectionPoint;

        // bookkeeping
        DWORD   m_dwFlags;              // Always a good idea

		// server object
		CIlsServer	*m_pIlsServer;


        STDMETHODIMP AllocMeetInfo(PLDAP_MEETINFO *ppMeetInfo, ULONG ulMask);

    public:                         

        // Constructor        
        CIlsMeetingPlace();

        // destructor
        ~CIlsMeetingPlace(VOID);

        STDMETHODIMP Init(BSTR bstrMeetingPlaceID, LONG lMeetingPlaceType, LONG lAttendeeType);
        STDMETHODIMP Init(CIlsServer *pIlsServer, PLDAP_MEETINFO pMeetInfo);

        STDMETHODIMP NotifySink(VOID *pv, CONN_NOTIFYPROC pfn);

        STDMETHODIMP RegisterResult(ULONG ulRegID, HRESULT hr);
        STDMETHODIMP UnregisterResult(ULONG ulRegID, HRESULT hr);
        STDMETHODIMP UpdateResult(ULONG ulUpdateID, HRESULT hr);
        STDMETHODIMP AddAttendeeResult(ULONG ulID, HRESULT hr);
        STDMETHODIMP RemoveAttendeeResult(ULONG ulID, HRESULT hr);
        STDMETHODIMP EnumAttendeeNamesResult(ULONG ulEnumAttendees, PLDAP_ENUM ple);



        // IUnknown members

        STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
        STDMETHODIMP_(ULONG)    AddRef (void);
        STDMETHODIMP_(ULONG)    Release (void);


        // IIlsMeetingPlace Interface members

        // Interfaces related to attributes
        // all these operate locally on the object and generate
        // no net traffic.


        // Get the type of meeting and Attendee
        // these are not changeable once the
        // meeting is registered

        STDMETHODIMP GetState(ULONG *ulState);

        STDMETHODIMP GetMeetingPlaceType(LONG *plMeetingPlaceType);
        STDMETHODIMP GetAttendeeType(LONG *plAttendeeType);

        STDMETHODIMP GetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                *pbstrStdAttr);

        STDMETHODIMP SetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                pbstrStdAttr);

	    STDMETHODIMP GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue );
	    STDMETHODIMP SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue );
	    STDMETHODIMP RemoveExtendedAttribute ( BSTR bstrName );
	    STDMETHODIMP GetAllExtendedAttributes ( IIlsAttributes **ppAttributes );

        // Registers a meeting with the server
        STDMETHODIMP Register ( IIlsServer *pServer, ULONG *pulRegID );

        // The following 5 interfaces work only on an object that has been
        // a) used to register a meeting
        // or b) obtained from IIls::EnumMeetingPlaces


        STDMETHODIMP Unregister(ULONG *pulUnregID);

        STDMETHODIMP Update(ULONG *pulUpdateID);

        STDMETHODIMP AddAttendee(BSTR bstrAttendeeID, ULONG *pulAddAttendeeID);
        STDMETHODIMP RemoveAttendee(BSTR bstrAttendeeID, ULONG *pulRemoveAttendeeID);

        STDMETHODIMP EnumAttendeeNames(IIlsFilter *pFilter, ULONG *pulEnumAttendees);


        // Connection point container. It has only one
        // connection interface, and that is to notify
        
        // IConnectionPointContainer
        STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
        STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};

//****************************************************************************
// CEnumMeetingPlaces definition
//****************************************************************************
//
class CEnumMeetingPlaces : public IEnumIlsMeetingPlaces
{
private:
    LONG                    m_cRef;
    CIlsMeetingPlace        **m_ppMeetingPlaces;
    ULONG                   m_cMeetingPlaces;
    ULONG                   m_iNext;

public:
    // Constructor and Initialization
    CEnumMeetingPlaces (void);
    ~CEnumMeetingPlaces (void);
    STDMETHODIMP            Init (CIlsMeetingPlace **ppMeetingPlacesList, ULONG cMeetingPlaces);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsMeetingPlaces
    STDMETHODIMP            Next(ULONG cMeetingPlaces, IIlsMeetingPlace **rgpMeetingPlaces,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cMeetingPlaces);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsMeetingPlaces **ppEnum);
};

#endif // ENABLE_MEETING_PLACE

#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsuser.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsuser.h
//  Content:    This file contains the User object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _ULSUSER_H_
#define _ULSUSER_H_

#include "connpt.h"

//****************************************************************************
// CUlsUser definition
//****************************************************************************
//
class CUlsUser : public IULSUser,
                 public IConnectionPointContainer 
{
private:
    ULONG                   cRef;
    LPTSTR                  szServer;
    LPTSTR                  szID;
    LPTSTR                  szFirstName;
    LPTSTR                  szLastName;
    LPTSTR                  szEMailName;
    LPTSTR                  szCityName;
    LPTSTR                  szCountryName;
    LPTSTR                  szComment;
    LPTSTR                  szIPAddr;
    DWORD					m_dwFlags;
    CConnectionPoint        *pConnPt;

    // Private method
    //
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);

public:
    // Constructor and destructor
    CUlsUser (void);
    ~CUlsUser (void);
    STDMETHODIMP            Init (LPTSTR szServerName,
                                  PLDAP_USERINFO pui);

    // Asynchronous response
    //
    STDMETHODIMP    GetApplicationResult (ULONG uReqID,
                                          PLDAP_APPINFO_RES plar);
    STDMETHODIMP    EnumApplicationsResult (ULONG uReqID,
                                            PLDAP_ENUM ple);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSUser
    STDMETHODIMP    GetID (BSTR *pbstrID);
    STDMETHODIMP    GetFirstName (BSTR *pbstrName);
    STDMETHODIMP    GetLastName (BSTR *pbstrName);
    STDMETHODIMP    GetEMailName (BSTR *pbstrName);
    STDMETHODIMP    GetCityName (BSTR *pbstrName);
    STDMETHODIMP    GetCountryName (BSTR *pbstrName);
    STDMETHODIMP    GetComment (BSTR *pbstrComment);
    STDMETHODIMP    GetFlags (DWORD *pdwFlags);
    STDMETHODIMP    GetIPAddress (BSTR *pbstrIPAddress);
    STDMETHODIMP    GetApplication (BSTR bstrAppName,
    								IULSAttributes *pAttributes,
                                    ULONG *puReqID);
    STDMETHODIMP    EnumApplications (ULONG *puReqID);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};

//****************************************************************************
// CEnumUsers definition
//****************************************************************************
//
class CEnumUsers : public IEnumULSUsers
{
private:
    ULONG                   cRef;
    CUlsUser                **ppu;
    ULONG                   cUsers;
    ULONG                   iNext;

public:
    // Constructor and Initialization
    CEnumUsers (void);
    ~CEnumUsers (void);
    STDMETHODIMP            Init (CUlsUser **ppuList, ULONG cUsers);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumULSAttributes
    STDMETHODIMP            Next(ULONG cUsers, IULSUser **rgpu,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cUsers);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumULSUsers **ppEnum);
};

#endif //_ULSUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ulsuser.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ulsuser.cpp
//  Content:    This file contains the User object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "ulsuser.h"
#include "ulsapp.h"
#include "culs.h"
#include "attribs.h"
#include "callback.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyGetApplicationResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetApplicationResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IULSUserNotify*)pUnk)->GetApplicationResult(pobjri->uReqID,
                                                  (IULSApplication *)pobjri->pv,
                                                  pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumApplicationsResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumApplicationsResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum  = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    if (SUCCEEDED(hr))
    {
        // Create a Application enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IULSUserNotify*)pUnk)->EnumApplicationsResult(peri->uReqID,
                                                    penum != NULL ? 
                                                    (IEnumULSNames *)penum :
                                                    NULL,
                                                    hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CUlsUser::CUlsUser (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsUser::CUlsUser (void)
{
    cRef        = 0;
    szServer    = NULL;
    szID        = NULL;
    szFirstName = NULL;
    szLastName  = NULL;
    szEMailName = NULL;
    szCityName  = NULL;
    szCountryName= NULL;
    szComment   = NULL;
    szIPAddr    = NULL;
	m_dwFlags   = 0;
    pConnPt     = NULL;

    return;
}

//****************************************************************************
// CUlsUser::~CUlsUser (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CUlsUser::~CUlsUser (void)
{
    if (szServer != NULL)
        FreeLPTSTR(szServer);
    if (szID != NULL)
        FreeLPTSTR(szID);
    if (szFirstName != NULL)
        FreeLPTSTR(szFirstName);
    if (szLastName != NULL)
        FreeLPTSTR(szLastName);
    if (szEMailName != NULL)
        FreeLPTSTR(szEMailName);
    if (szCityName != NULL)
        FreeLPTSTR(szCityName);
    if (szCountryName != NULL)
        FreeLPTSTR(szCountryName);
    if (szComment != NULL)
        FreeLPTSTR(szComment);
    if (szIPAddr != NULL)
        FreeLPTSTR(szIPAddr);

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::Init (LPTSTR szServerName, PLDAP_USERINFO *pui)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::Init (LPTSTR szServerName, PLDAP_USERINFO pui)
{
    HRESULT hr;

    // Validate parameter
    //
    if ((pui->uSize != sizeof(*pui))    ||
        (pui->uOffsetName       == 0))
    {
        return ULS_E_PARAMETER;
    };

    // Remember the server name
    //
    hr = SafeSetLPTSTR(&szServer, szServerName);

    if (SUCCEEDED(hr))
    {
        hr = SafeSetLPTSTR(&szID, (LPCTSTR)(((PBYTE)pui)+pui->uOffsetName));

        if (SUCCEEDED(hr))
        {
            hr = SafeSetLPTSTR(&szFirstName,
                           (LPCTSTR)(((PBYTE)pui)+pui->uOffsetFirstName));

            if (SUCCEEDED(hr))
            {
                hr = SafeSetLPTSTR(&szLastName,
                               (LPCTSTR)(((PBYTE)pui)+pui->uOffsetLastName));

                if (SUCCEEDED(hr))
                {
                    hr = SafeSetLPTSTR(&szEMailName,
                                   (LPCTSTR)(((PBYTE)pui)+pui->uOffsetEMailName));

                    if (SUCCEEDED(hr))
                    {
                        hr = SafeSetLPTSTR(&szCityName,
                                       (LPCTSTR)(((PBYTE)pui)+pui->uOffsetCityName));

                        if (SUCCEEDED(hr))
                        {
                            hr = SafeSetLPTSTR(&szCountryName, (LPCTSTR)(((PBYTE)pui)+
                                                           pui->uOffsetCountryName));

                            if (SUCCEEDED(hr))
                            {
                                hr = SafeSetLPTSTR(&szComment, (LPCTSTR)(((PBYTE)pui)+
                                                           pui->uOffsetComment));

                                if (SUCCEEDED(hr))
                                {
                                    hr = SafeSetLPTSTR(&szIPAddr, (LPCTSTR)(((PBYTE)pui)+
                                                              pui->uOffsetIPAddress));
                                    m_dwFlags = pui->dwFlags;
                                };
                            };
                        };
                    };
                };
            };
        };
    };

    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        pConnPt = new CConnectionPoint (&IID_IULSUserNotify,
                                        (IConnectionPointContainer *)this);
        if (pConnPt != NULL)
        {
            ((IConnectionPoint*)pConnPt)->AddRef();
            hr = NOERROR;
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSUser || riid == IID_IUnknown)
    {
        *ppv = (IULSUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsUser::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsUser::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CUlsUser::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CUlsUser::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetID (BSTR *pbstrID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetID (BSTR *pbstrID)
{
    // Validate parameter
    //
    if (pbstrID == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrID, szID);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetFirstName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetFirstName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szFirstName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetLastName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetLastName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szLastName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetEMailName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetEMailName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szEMailName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetCityName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetCityName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szCityName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetCountryName (BSTR *pbstrName)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetCountryName (BSTR *pbstrName)
{
    // Validate parameter
    //
    if (pbstrName == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrName, szCountryName);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetComment (BSTR *pbstrComment)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetComment (BSTR *pbstrComment)
{
    // Validate parameter
    //
    if (pbstrComment == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrComment, szComment);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetFlags ( DWORD *pdwFlags )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetFlags ( DWORD *pdwFlags )
{
    // Validate parameter
    //
    if (pdwFlags == NULL)
        return ULS_E_POINTER;

	*pdwFlags = m_dwFlags;
	return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetIPAddress (BSTR *pbstrAddr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetIPAddress (BSTR *pbstrAddr)
{
    // Validate parameter
    //
    if (pbstrAddr == NULL)
    {
        return E_POINTER;
    };

    return LPTSTR_to_BSTR(pbstrAddr, szIPAddr);
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetApplication (REFGUID rguid, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetApplication (BSTR bstrAppName, IULSAttributes *pAttributes, ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    LPTSTR pszAppName;
    HRESULT hr;

    // Validate parameter
    //
    if (bstrAppName == NULL || puReqID == NULL)
        return E_POINTER;

	// Convert application name
	//
    hr = BSTR_to_LPTSTR (&pszAppName, bstrAppName);
    if (hr != S_OK)
    	return hr;

	// Get arbitrary attribute name list if any
	//
	ULONG cAttrNames = 0;
	ULONG cbNames = 0;
	TCHAR *pszAttrNameList = NULL;
	if (pAttributes != NULL)
	{
		hr = ((CAttributes *) pAttributes)->GetAttributeList (&pszAttrNameList, &cAttrNames, &cbNames);
		if (hr != S_OK)
			return hr;
	}

    hr = ::UlsLdap_ResolveApp (szServer, szID, pszAppName,
    							pszAttrNameList, cAttrNames, &ldai);
    if (hr != S_OK)
    	goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
	REQUESTINFO ri;
	ZeroMemory (&ri, sizeof (ri));
	ri.uReqType = WM_ULS_RESOLVE_APP;
	ri.uMsgID = ldai.uMsgID;
	ri.pv     = (PVOID) this;
	ri.lParam = NULL;

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest (&ri);
	if (SUCCEEDED(hr))
	{
	    // Make sure the objects do not disappear before we get the response
	    //
	    this->AddRef();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	}

MyExit:

	if (pszAttrNameList != NULL)
		FreeLPTSTR (pszAttrNameList);

	if (pszAppName != NULL)
		FreeLPTSTR(pszAppName);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::GetApplicationResult (ULONG uReqID, PLDAP_APPINFO_RES pair)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::GetApplicationResult (ULONG uReqID, PLDAP_APPINFO_RES pair)
{
    CUlsApp *pa;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = pair->hResult;

    if (SUCCEEDED(objri.hResult))
    {
        // The server returns APPINFO, create a Application object
        //
        pa = new CUlsApp;

        if (pa != NULL)
        {
            objri.hResult = pa->Init(szServer, szID, &pair->lai);
            if (SUCCEEDED(objri.hResult))
            {
                pa->AddRef();
            }
            else
            {
                delete pa;
                pa = NULL;
            };
        }
        else
        {
            objri.hResult = ULS_E_MEMORY;
        };
    }
    else
    {
        pa = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pa == NULL ? NULL : (IULSApplication *)pa);
    NotifySink((void *)&objri, OnNotifyGetApplicationResult);

    if (pa != NULL)
    {
        pa->Release();
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::EnumApplications (ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::EnumApplications (ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (puReqID == NULL)
    {
        return E_POINTER;
    };

    hr = ::UlsLdap_EnumApps(szServer, szID, &ldai);

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ULS_ENUM_APPS;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)NULL;

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::EnumApplicationsResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::EnumApplicationsResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;
    eri.hResult = ple->hResult;
    eri.cItems  = ple->cItems;
    eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    NotifySink((void *)&eri, OnNotifyEnumApplicationsResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ULS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CUlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CUlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ULS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ULS_E_NO_INTERFACE;
    };

    return hr;
}

//****************************************************************************
// CEnumUsers::CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::CEnumUsers (void)
{
    cRef    = 0;
    ppu     = NULL;
    cUsers  = 0;
    iNext   = 0;
    return;
}

//****************************************************************************
// CEnumUsers::~CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::~CEnumUsers (void)
{
    ULONG i;

    if (ppu != NULL)
    {
        for (i = 0; i < cUsers; i++)
        {
            ppu[i]->Release();
        };
        LocalFree(ppu);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Init (CUlsUser **ppuList, ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Init (CUlsUser **ppuList, ULONG cUsers)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cUsers != 0)
    {
        ASSERT(ppuList != NULL);

        // Allocate the snapshot buffer
        //
        ppu = (CUlsUser **)LocalAlloc(LPTR, cUsers*sizeof(CUlsUser *));

        if (ppu != NULL)
        {
            ULONG i;

            // Snapshot the object list
            //
            for (i =0; i < cUsers; i++)
            {
                ppu[i] = ppuList[i];
                ppu[i]->AddRef();
            };
            this->cUsers = cUsers;
        }
        else
        {
            hr = ULS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumULSUsers || riid == IID_IUnknown)
    {
        *ppv = (IEnumULSUsers *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP 
// CEnumUsers::Next (ULONG cUsers, IULSUser **rgpu, ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumUsers::Next (ULONG cUsers, IULSUser **rgpu, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpu == NULL)
        return E_POINTER;

    // Validate the parameters
    //
    if ((cUsers == 0) ||
        ((cUsers > 1) && (pcFetched == NULL)))
        return ULS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more attribute names
    //
    while ((cCopied < cUsers) &&
           (iNext < this->cUsers))
    {
        ppu[iNext]->AddRef();
        rgpu[cCopied++] = ppu[iNext++];
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cUsers == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Skip (ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Skip (ULONG cUsers)
{
    ULONG iNewIndex;

    // Validate the parameters
    //
    if (cUsers == 0) 
        return ULS_E_PARAMETER;

    // Check the enumeration index limit
    //
    iNewIndex = iNext+cUsers;
    if (iNewIndex <= this->cUsers)
    {
        iNext = iNewIndex;
        return S_OK;
    }
    else
    {
        iNext = this->cUsers;
        return S_FALSE;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Reset (void)
{
    iNext = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Clone(IEnumULSUsers **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Clone(IEnumULSUsers **ppEnum)
{
    CEnumUsers *peu;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    peu = new CEnumUsers;
    if (peu == NULL)
        return ULS_E_MEMORY;

    // Clone the information
    //
    hr = peu->Init(ppu, cUsers);

    if (SUCCEEDED(hr))
    {
        peu->iNext = iNext;

        // Return the cloned enumerator
        //
        peu->AddRef();
        *ppEnum = peu;
    }
    else
    {
        delete peu;
    };
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\published\dload\enduserpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\utils.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       utils.h
//  Content:    Declaration utiltity functions and classes
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

//****************************************************************************
// Global Utilities
//****************************************************************************
//

#ifdef _DEBUG
extern LONG g_cCritSec;
#endif

inline VOID MyInitializeCriticalSection ( LPCRITICAL_SECTION pcs )
{
	InitializeCriticalSection (pcs);
#ifdef _DEBUG
	g_cCritSec++;
#endif
}

inline VOID MyDeleteCriticalSection ( LPCRITICAL_SECTION pcs )
{
	DeleteCriticalSection (pcs);
#ifdef _DEBUG
	g_cCritSec--;
#endif
}


HRESULT     SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName);
HRESULT     SafeSetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName);
HRESULT		SetOffsetString ( TCHAR **ppszDst, BYTE *pSrcBase, ULONG uSrcOffset );
HRESULT     LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz);
HRESULT     BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr);
BOOL IsLegalEmailName ( TCHAR *pszName );

//****************************************************************************
// CList definition
//****************************************************************************
//
typedef struct  tagpNode {
    struct  tagpNode    *pNext;
    LPVOID              pv;
} NODE, *PNODE;

class   CList
{
private:
    PNODE   pHead;
    PNODE   pTail;

public:
    CList(void);
    ~CList(void);

    HRESULT Insert      (LPVOID pv);
    HRESULT Append      (LPVOID pv);
    HRESULT Remove      (LPVOID pv);

    HRESULT Find        (LPVOID pv);
    HRESULT FindStorage (LPVOID *ppv, LPVOID pv);

    HRESULT Enumerate   (HANDLE *phEnum);
    HRESULT Next        (HANDLE *phEnum, LPVOID *ppv);
    HRESULT NextStorage (HANDLE *phEnum, LPVOID *ppv);
    
    HRESULT Flush       (void);

    HRESULT Clone       (CList *pList, HANDLE *phEnum);
};

//****************************************************************************
// CEnumNames definition
//****************************************************************************
//
class CEnumNames : public IEnumIlsNames
{
private:

    ULONG                   cRef;
    LPTSTR                  pNext;
    LPTSTR                  pszNames;
    ULONG                   cbSize;

public:
    // Constructor and Initialization
    CEnumNames (void);
    ~CEnumNames (void);
    STDMETHODIMP            Init (LPTSTR pList, ULONG cNames);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsAttributes
    STDMETHODIMP            Next(ULONG cNames, BSTR *rgpbstrName,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cNames);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsNames **ppEnum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\utils.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       utils.cpp
//  Content:    Miscellaneous utility functions and classes
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"

//****************************************************************************
// HRESULT
// SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
//
// Purpose: Clone the provided string into a newly allocated buffer.
//
// Parameters:
//  ppszName        The buffer to receive a newly allocated string buffer.
//  pszUserName     The provided name string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_MEMORY   if the string cannot be cloned.
//****************************************************************************

HRESULT
SetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
{
	HRESULT hr;

    TCHAR *pszNew = My_strdup (pszUserName);
    if (pszNew != NULL)
    {
        // Free the old name
        //
        ::MemFree (*ppszName);
        *ppszName = pszNew;
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    }

    return hr;
}

//****************************************************************************
// HRESULT
// SafeSetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
//
// Purpose: Clone the provided string into a newly allocated buffer.
//          It is ok that the provided string is NULL.
//
// Parameters:
//  ppszName        The buffer to receive a newly allocated string buffer.
//  pszUserName     The provided name string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_MEMORY   if the non-null string cannot be cloned.
//****************************************************************************

HRESULT
SafeSetLPTSTR (LPTSTR *ppszName, LPCTSTR pszUserName)
{
	if (pszUserName == NULL)
	{
		MemFree (*ppszName);
		*ppszName = NULL;
		return S_FALSE;
	}

	return SetLPTSTR (ppszName, pszUserName);
}

//****************************************************************************
// HRESULT
// SetOffsetString ( TCHAR **ppszDst, BYTE *pSrcBase, ULONG uSrcOffset )
//
// Purpose: Clone the provided string into a newly allocated buffer.
//			If the source string is null or empty, the destination string
//			will be null.
//
// Parameters:
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  S_FALSE			the destination string is null
//  ILS_E_MEMORY   if the string cannot be cloned.
//****************************************************************************

HRESULT
SetOffsetString ( TCHAR **ppszDst, BYTE *pSrcBase, ULONG uSrcOffset )
{
	HRESULT hr = S_FALSE;
	TCHAR *pszNew = NULL;

	if (uSrcOffset != INVALID_OFFSET)
	{
		TCHAR *pszSrc = (TCHAR *) (pSrcBase + uSrcOffset);
		if (*pszSrc != TEXT ('\0'))
		{
			pszNew = My_strdup (pszSrc);
			hr = (pszNew != NULL) ? S_OK : ILS_E_MEMORY;
		}
	}

	if (SUCCEEDED (hr))
	{
		::MemFree (*ppszDst);
	     *ppszDst = pszNew;
    }

    return hr;
}

//****************************************************************************
// HRESULT
// LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz)
//
// Purpose: Make a BSTR string from an LPTSTR string
//
// Parameters:
//  pbstr       The buffer to receive a newly allocated BSTR string.
//  psz         The LPTSTR string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_FAIL          cannot convert the string to BSTR
//  ILS_E_MEMORY   cannot allocate enough memory for the BSTR string.
//****************************************************************************

HRESULT
LPTSTR_to_BSTR (BSTR *pbstr, LPCTSTR psz)
{
#ifndef _UNICODE

    BSTR bstr;
    int i;
    HRESULT hr;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0)
    {
        return ILS_E_FAIL;
    };

    // allocate the widestr, +1 for terminating null
    //
    bstr = SysAllocStringLen(NULL, i-1); // SysAllocStringLen adds 1

    if (bstr != NULL)
    { 
        MultiByteToWideChar(CP_ACP, 0, psz, -1, (LPWSTR)bstr, i);
        ((LPWSTR)bstr)[i - 1] = 0;
        *pbstr = bstr;
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;

#else

    BSTR bstr;

    bstr = SysAllocString(psz);

    if (bstr != NULL)
    {
        *pbstr = bstr;
        return S_OK;
    }
    else
    {
        return ILS_E_MEMORY;
    };

#endif // _UNICODE
}

//****************************************************************************
// HRESULT
// BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr)
//
// Purpose: Make a LPTSTR string from an BSTR string
//
// Parameters:
//  ppsz        The buffer to receive a newly allocated LPTSTR string.
//  bstr        The BSTR string.
//
// Return Value:  
//  S_OK            success if the string can be cloned.
//  ILS_E_FAIL          cannot convert the string to BSTR
//  ILS_E_MEMORY   cannot allocate enough memory for the BSTR string.
//****************************************************************************

HRESULT
BSTR_to_LPTSTR (LPTSTR *ppsz, BSTR bstr)
{
#ifndef _UNICODE

    LPTSTR psz;
    int i;
    HRESULT hr;

    // compute the length of the required BSTR
    //
    i =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
    if (i <= 0)
    {
        return ILS_E_FAIL;
    };

    // allocate the widestr, +1 for terminating null
    //
    psz = (TCHAR *) ::MemAlloc (i * sizeof (TCHAR));
    if (psz != NULL)
    { 
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, i, NULL, NULL);
        *ppsz = psz;
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;

#else

    LPTSTR psz = NULL;
    HRESULT hr;

    hr = SetLPTSTR(&psz, (LPTSTR)bstr);

    if (hr == S_OK)
    {
        *ppsz = psz;
    };
    return hr;

#endif // _UNICODE
}

//****************************************************************************
// CList::CList (void)
//
// Purpose: Constructor for the CList class
//
// Parameters: None
//****************************************************************************

CList::CList (void)
{
    pHead = NULL;
    pTail = NULL;
    return;
}

//****************************************************************************
// CList::~CList (void)
//
// Purpose: Constructor for the CList class
//
// Parameters: None
//****************************************************************************

CList::~CList (void)
{
    Flush();
    return;
}

//****************************************************************************
// HRESULT
// CList::Insert (LPVOID pv)
//
// Purpose: Insert an object at the beginning of the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Insert (LPVOID pv)
{
    PNODE pNode;

    pNode        = new NODE;
    if (pNode == NULL)
    {
        return ILS_E_MEMORY;
    };

    pNode->pNext = pHead;
    pNode->pv    = pv;
    pHead        = pNode;

    if (pTail == NULL)
    {
        // This is the first node
        //
        pTail = pNode;
    };
    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Append (LPVOID pv)
//
// Purpose: Append an object to the end of the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Append (LPVOID pv)
{
    PNODE pNode;

    pNode        = new NODE;
    if (pNode == NULL)
    {
        return ILS_E_MEMORY;
    };

    pNode->pNext = NULL;
    pNode->pv    = pv;
    
    if (pHead == NULL)
    {
        pHead = pNode;
    };

    if (pTail != NULL)
    {
        pTail->pNext = pNode;
    };
    pTail        = pNode;

    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Remove (LPVOID pv)
//
// Purpose: Append an object to the end of the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Remove (LPVOID pv)
{
    PNODE pNode, pPrev;
    HRESULT hr;

    pNode = pHead;
    pPrev = NULL;
    while (pNode != NULL)
    {
        // Matching the requested node
        //
        if (pNode->pv == pv)
        {
            break;  // found!!!
        };

        pPrev = pNode;
        pNode = pNode->pNext;
    };

    if (pNode != NULL)
    {
        // We found the node to remove
        // Update relevant pointer
        //
        if (pTail == pNode)
        {
            pTail = pPrev;
        };

        if (pPrev != NULL)
        {
            pPrev->pNext = pNode->pNext;
        }
        else
        {
            pHead = pNode->pNext;
        };
        delete pNode;
        hr = NOERROR;
    }
    else
    {
        hr = S_FALSE;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::Find (LPVOID pv)
//
// Purpose: Find an object in the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Find (LPVOID pv)
{
    PNODE pNode;

    pNode = pHead;
    while (pNode != NULL)
    {
        // Matching the requested node
        //
        if (pNode->pv == pv)
        {
            break;  // found!!!
        };
        pNode = pNode->pNext;
    };

    return (pNode != NULL ? NOERROR : S_FALSE);
}

//****************************************************************************
// HRESULT
// CList::FindStorage (LPVOID *ppv, LPVOID pv)
//
// Purpose: Find an object in the list and returns the object storage.
//          This call is useful for search-and-replace operations.
//
// Parameters: None
//****************************************************************************

HRESULT
CList::FindStorage (LPVOID *ppv, LPVOID pv)
{
    PNODE pNode;
    HRESULT hr;

    pNode = pHead;
    while (pNode != NULL)
    {
        // Matching the requested node
        //
        if (pNode->pv == pv)
        {
            break;  // found!!!
        };
        pNode = pNode->pNext;
    };

    if (pNode != NULL)
    {
        *ppv = &(pNode->pv);
        hr = NOERROR;
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::Enumerate (HANDLE *phEnum)
//
// Purpose: Start object enumeration
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Enumerate (HANDLE *phEnum)
{
    *phEnum = (HANDLE)pHead;
    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Next (HANDLE *phEnum, LPVOID *ppv)
//
// Purpose: Obtain the next enumerated object
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Next (HANDLE *phEnum, LPVOID *ppv)
{
    PNODE pNext;
    HRESULT hr;

    pNext = (PNODE)*phEnum;

    if (pNext == NULL)
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    else
    {
        *ppv = pNext->pv;
        *phEnum = (HANDLE)(pNext->pNext);
        hr = NOERROR;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::NextStorage (HANDLE *phEnum, LPVOID *ppv)
//
// Purpose: Obtain the storage of the next enumerated object. This call is
//          useful for search-and-replace operations.
//
// Parameters: None
//****************************************************************************

HRESULT
CList::NextStorage (HANDLE *phEnum, LPVOID *ppv)
{
    PNODE pNext;
    HRESULT hr;

    pNext = (PNODE)*phEnum;

    if (pNext == NULL)
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    else
    {
        *ppv = &(pNext->pv);
        *phEnum = (HANDLE)(pNext->pNext);
        hr = NOERROR;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CList::Flush (void)
//
// Purpose: Flush all the nodes in the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Flush (void)
{
    PNODE pNode;

    while (pHead != NULL)
    {
        pNode = pHead;
        pHead = pHead->pNext;
        delete pNode;
    };
    return NOERROR;
}

//****************************************************************************
// HRESULT
// CList::Clone (CList *pList, HANDLE *phEnum)
//
// Purpose: Flush all the nodes in the list
//
// Parameters: None
//****************************************************************************

HRESULT
CList::Clone (CList *pList, HANDLE *phEnum)
{
    PNODE pNode;
    HRESULT hr;

    // Only allow a null list to be cloned
    //
    if (pHead != NULL)
    {
        return ILS_E_FAIL;
    };

    // Traverse the source list
    //
    hr = S_OK; // lonchanc: in case of null list
    pNode = pList->pHead;
    while(pNode != NULL)
    {
        // Use append to maintain the order
        //
        hr = Append(pNode->pv);
        if (FAILED(hr))
        {
            break;
        };

        // Get the enumerator info
        //
        if ((phEnum != NULL) &&
            (*phEnum == (HANDLE)pNode))
        {
            *phEnum = (HANDLE)pTail;
        };
        pNode = pNode->pNext;
    };
    return hr;
}

//****************************************************************************
// CEnumNames::CEnumNames (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumNames::CEnumNames (void)
{
    cRef = 0;
    pNext = NULL;
    pszNames = NULL;
    cbSize = 0;
    return;
}

//****************************************************************************
// CEnumNames::~CEnumNames (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumNames::~CEnumNames (void)
{
    if (pszNames != NULL)
    {
        ::MemFree (pszNames);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Init (LPTSTR pList, ULONG cNames)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Init (LPTSTR pList, ULONG cNames)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cNames != 0)
    {
        LPTSTR pNextSrc;
        ULONG i, cLen, cbSize;

        ASSERT(pList != NULL);

        // Calculate the list size
        //
        pNextSrc = pList;

        for (i = 0, cbSize = 0; i < cNames; i++)
        {
            cLen = lstrlen(pNextSrc)+1;
            pNextSrc += cLen;
            cbSize += cLen;
        };

        // Allocate the snapshot buffer with the specified length
        // plus one for doubly null-termination
        //
        pszNames = (TCHAR *) ::MemAlloc ((cbSize+1) * sizeof (TCHAR));
        if (pszNames != NULL)
        {
            // Snapshot the name list
            //
            CopyMemory(pszNames, pList, cbSize*sizeof(TCHAR));
            pszNames[cbSize] = '\0';
            pNext = pszNames;
            this->cbSize = cbSize+1;
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsNames || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsNames *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumNames::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumNames::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumNames::AddRef: ref=%ld\r\n", cRef));
	::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumNames::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumNames::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumNames::Release: ref=%ld\r\n", cRef));
	if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumNames::Next (ULONG cNames, BSTR *rgpbstrName, ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumNames::Next (ULONG cNames, BSTR *rgpbstrName, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpbstrName == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cNames == 0) ||
        ((cNames > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    if (pNext != NULL)
    {
        // Can copy if we still have more names
        //
        while ((cCopied < cNames) &&
               (*pNext != '\0'))
        {
            if (SUCCEEDED(LPTSTR_to_BSTR(&rgpbstrName[cCopied], pNext)))
            {
                cCopied++;
            };
            pNext += lstrlen(pNext)+1;
        };
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cNames == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Skip (ULONG cNames)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Skip (ULONG cNames)
{
    ULONG cSkipped;

    // Validate the parameters
    //
    if (cNames == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    cSkipped = 0;

    if (pNext != NULL)
    {
        // Can skip only if we still have more attributes
        //
        while ((cSkipped < cNames) &&
               (*pNext != '\0'))
        {
            pNext += lstrlen(pNext)+1;
            cSkipped++;
        };
    };

    return (cNames == cSkipped ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Reset (void)
{
    pNext = pszNames;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumNames::Clone(IEnumIlsNames **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumNames::Clone(IEnumIlsNames **ppEnum)
{
    CEnumNames *peun;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    peun = new CEnumNames;
    if (peun == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    hr = NOERROR;
    peun->cbSize = cbSize;
    if (cbSize != 0)
    {
        peun->pszNames = (TCHAR *) ::MemAlloc (cbSize * sizeof (TCHAR));
        if (peun->pszNames != NULL)
        {
            CopyMemory(peun->pszNames, pszNames, cbSize*sizeof(TCHAR));
            peun->pNext = peun->pszNames+(pNext-pszNames);
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    }
    else
    {
        peun->pNext = NULL;
        peun->pszNames = NULL;
    };

    if (SUCCEEDED(hr))
    {
        // Return the cloned enumerator
        //
        peun->AddRef();
        *ppEnum = peun;
    }
    else
    {
        delete peun;
    };
    return hr;
}

/*  F  L E G A L  E M A I L  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailSz

    RobD created
		A legal email name contains only ANSI characters.
		"a-z, A-Z, numbers 0-9 and some common symbols"
		It cannot include extended characters or < > ( ) /

	loncahnc modified
		IsLegalEmailName ( TCHAR *pszName ).
		A legal email name contains RFC 822 compliant characters.
-------------------------------------------------------------------------*/

BOOL IsLegalEmailName ( TCHAR *pszName )
{
	// Null string is not legal
	//
	if (pszName == NULL)
    	return FALSE;

	TCHAR ch;
	while ((ch = *pszName++) != TEXT ('\0'))
    {
		switch (ch)
		{
		default:
			// Check if ch is in the range
			//
			if (ch > TEXT (' ') && ch <= TEXT ('~'))
				break;

			// Fall thru to error code
			//

		case TEXT ('('): case TEXT (')'):
		case TEXT ('<'): case TEXT ('>'):
		case TEXT ('['): case TEXT (']'):
		case TEXT ('/'): case TEXT ('\\'):
		case TEXT (','):
		case TEXT (';'):
		case TEXT (':'):
		case TEXT ('\"'):
			return FALSE;
		}
	} // while

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\published\dload\odbc32.c ===
#include "enduserpch.h"
#pragma hdrstop

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>


static
SQLRETURN  SQL_API SQLDisconnect(SQLHDBC ConnectionHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLExecute(SQLHSTMT StatementHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLAllocHandle(SQLSMALLINT HandleType,
           SQLHANDLE InputHandle, SQLHANDLE *OutputHandle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLSetConnectAttr(SQLHDBC ConnectionHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLBindParameter(
    SQLHSTMT           hstmt,
    SQLUSMALLINT       ipar,
    SQLSMALLINT        fParamType,
    SQLSMALLINT        fCType,
    SQLSMALLINT        fSqlType,
    SQLULEN            cbColDef,
    SQLSMALLINT        ibScale,
    SQLPOINTER         rgbValue,
    SQLLEN             cbValueMax,
    SQLLEN     		   *pcbValue)
{
    return SQL_ERROR;
}

static
SQLRETURN  SQL_API SQLSetEnvAttr(SQLHENV EnvironmentHandle,
           SQLINTEGER Attribute, SQLPOINTER Value,
           SQLINTEGER StringLength)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLErrorW(
    SQLHENV            henv,
    SQLHDBC            hdbc,
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlState,
    SQLINTEGER     *pfNativeError,
    SQLWCHAR        *szErrorMsg,
    SQLSMALLINT        cbErrorMsgMax,
    SQLSMALLINT    *pcbErrorMsg)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLPrepareW(
    SQLHSTMT           hstmt,
    SQLWCHAR        *szSqlStr,
    SQLINTEGER         cbSqlStr)
{
    return SQL_ERROR;
}

static
SQLRETURN SQL_API SQLDriverConnectW(
    SQLHDBC            hdbc,
    SQLHWND            hwnd,
    SQLWCHAR        *szConnStrIn,
    SQLSMALLINT        cbConnStrIn,
    SQLWCHAR        *szConnStrOut,
    SQLSMALLINT        cbConnStrOutMax,
    SQLSMALLINT    *pcbConnStrOut,
    SQLUSMALLINT       fDriverCompletion)
{
    return SQL_ERROR;
}



//
// !! WARNING !! The entries below must be in order by ORDINAL
//

DEFINE_ORDINAL_ENTRIES(odbc32)
{
    DLOENTRY(9,SQLDisconnect)
    DLOENTRY(12,SQLExecute)
    DLOENTRY(24,SQLAllocHandle)
    DLOENTRY(31,SQLFreeHandle)
    DLOENTRY(39,SQLSetConnectAttr)
    DLOENTRY(72,SQLBindParameter)
    DLOENTRY(75,SQLSetEnvAttr)
    DLOENTRY(110,SQLErrorW)
    DLOENTRY(119,SQLPrepareW)
    DLOENTRY(141,SQLDriverConnectW)
};

DEFINE_ORDINAL_MAP(odbc32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\verhead.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "SAPI 5"
#define VER_INTERNALNAME_STR        "SAPI5"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\vertail.h ===
#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\guidsep\precomp.c ===
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\automatebuild\builda.cpp ===
#include <windows.h>
#include <process.h>
#include <stdio.h>

void main (void)
{
    SYSTEMTIME LocalTime;

    system("cls" );
    printf(".");

    while(1)
    {
        GetLocalTime( &LocalTime );

        // no Saturday or Sunday builds
        if( LocalTime.wDayOfWeek > 0 && LocalTime.wDayOfWeek < 6 )
        {
            // Kick off build within the first 6 minutes after midnight
            if( LocalTime.wHour == 0 && LocalTime.wMinute <= 5 ) 
            {
                system("buildalpha.cmd" );
                system("cls" );
            }
        }
        Sleep( 5*60*1000 );     // Sleep for 5 minutes
        printf(".");            // just some visual feedback to tell us we're doing something
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\automatebuild\build.cpp ===
#include <windows.h>
#include <process.h>
#include <stdio.h>

void main (void)
{
    SYSTEMTIME LocalTime;

    system("cls" );
    printf(".");

    while(1)
    {
        GetLocalTime( &LocalTime );

        // no Saturday or Sunday builds
        if( LocalTime.wDayOfWeek > 0 && LocalTime.wDayOfWeek < 6 )
        {
            // Kick off build within the first 6 minutes after midnight
            if( LocalTime.wHour == 0 && LocalTime.wMinute <= 5 ) 
            {
                system("buildx86.cmd" );
                system("cls" );
            }
        }
        Sleep( 5*60*1000 );     // Sleep for 5 minutes
        printf(".");            // just some visual feedback to tell us we're doing something
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\guidsep\precomp.h ===
#include <wtypes.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\guidsep\guidsep.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <process.h> // for system()
void ProcessGuidFile( char *pszFileName, DWORD*, BOOL );
CHAR* ProcessChunk( CHAR*, CHAR*, int* );

int main(void)
{
    CHAR *pbuff = NULL, *pStart;
    HANDLE hFile, hChecksumFile, hExistingFile;
    DWORD dwSize, dw, i;
    DWORD dwOrigCheckSum, dwNewCheckSum = 0;
    CHAR szCurDir[512], szBuildDir[512], *pDir;

    // Change the current directory to the build directory
    dw = GetCurrentDirectory( 512, szCurDir );
    if( !dw ) return -1;
    strcpy( szBuildDir, szCurDir );

	strcat(szBuildDir, "\\..\\..\\build");
/*
    // 1st try to find a "build" directory below the root and 1st level 
    pDir = szBuildDir;
    i = 0;
    while( pDir < &szBuildDir[dw] )
    {
        if( *pDir++ == '\\' )
        {
            i++;
            if( i == 2 ) break;
        }
    }

    strcpy( pDir, "build" );
    *(pDir+5) = '\0';
*/
    if( !SetCurrentDirectory( szBuildDir ) )
    {
        // now search for a build directory under "sapi" or "sapi5"
        strcpy( szBuildDir, szCurDir );
        _strlwr( szBuildDir );
        pDir = strstr( szBuildDir, "sapi" );
        if( !pDir )
        {
            return -1;
        }
        else
        {
            if( *(pDir+4) == '5' )
            {
                strcpy( pDir+5, "\\build" );
                *(pDir+11) = '\0';
            }
            else
            {
                strcpy( pDir+4, "\\build" );
                *(pDir+10) = '\0';
            }
            if( !SetCurrentDirectory( szBuildDir ) )
            {
                return -1;
            }
        }
    }

    // read checksum information if available
    hChecksumFile = CreateFile( "checksum.bin", GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN, NULL );
    if( hChecksumFile != INVALID_HANDLE_VALUE )
    {
        ReadFile( hChecksumFile, &dwOrigCheckSum, sizeof(dwOrigCheckSum), &dw, NULL );
        CloseHandle( hChecksumFile );

        // make sure sapiguid.lib exists - BUGBUG - change to i386 for intel
        hExistingFile = CreateFile( "..\\sdk\\lib\\i386\\sapiguid.lib", GENERIC_READ,
            FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hExistingFile == INVALID_HANDLE_VALUE )
        {
            dwOrigCheckSum = 0;
        }
        else
        {
            CloseHandle( hExistingFile );
        }
    }
    else
    {
        dwOrigCheckSum = 0;
    }

    // open file that contains the list of files to process
    hFile = CreateFile( "guidfiles.txt", GENERIC_READ,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile != INVALID_HANDLE_VALUE )
    {
        dwSize = GetFileSize( hFile, NULL );
        if( dwSize != 0xFFFFFFFF )
        {
            pbuff = new CHAR [dwSize];
        }

        if( pbuff )
        {
            // read the names of the files we want to process
            ReadFile( hFile, pbuff, dwSize, &dw, NULL );
            pStart = pbuff;
            for( i = 0; i < dwSize; i++ )
            {
                // parse file names form the file and process each one
                if( *(pbuff+i) == 13 )
                {
                    *(pbuff+i) = '\0';
                    ProcessGuidFile( pStart, &dwNewCheckSum, true );
                    pStart = pbuff + i + 2;
                }
            }

            if( dwOrigCheckSum != dwNewCheckSum )
            {
                pStart = pbuff;
                for( i = 0; i < dwSize; i++ )
                {
                    // parse file names form the file and process each one
                    if( *(pbuff+i) == '\0' )
                    {
                        ProcessGuidFile( pStart, 0, false );
                        pStart = pbuff + i + 2;
                    }
                }
                hChecksumFile = CreateFile( "checksum.bin", GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL );
                if( hChecksumFile != INVALID_HANDLE_VALUE )
                {
                    WriteFile( hChecksumFile, &dwNewCheckSum, sizeof(dwNewCheckSum), &dw, NULL );
                    CloseHandle( hChecksumFile );
                }
                system( "cl /c /Ycprecomp.h GuidSep\\precomp.c" );
                system( "cl /c /Zl /Yuprecomp.h GuidSep\\*.c" );
                system( "link /lib *.obj /out:..\\sdk\\lib\\i386\\sapiguid.lib" );  // BUGBUG - change this to i386 for intel
                system( "del *.obj" );
                system( "del *.pch" );
                system( "del GuidSep\\SAPI5_guid_*.c" );
            }
            delete [] pbuff;
        }
	CloseHandle( hFile );

    }

    // reset working directory
    SetCurrentDirectory( szCurDir );
    return 0;
}

void ProcessGuidFile( char *pszFileName, DWORD *pdwCheckSum, BOOL bDoCheckSum )
{
    static int count = 0;
    CHAR *pbuff = NULL, *pTmp, *pEndStream;
    HANDLE hFile;
    DWORD dwSize, dw, i;
    hFile = CreateFile( pszFileName, GENERIC_READ,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile != INVALID_HANDLE_VALUE )
    {
        dwSize = GetFileSize( hFile, NULL );
        if( dwSize != 0xFFFFFFFF )
        {
            pbuff = new CHAR [dwSize];
        }

        if( pbuff )
        {
            pEndStream = pbuff + dwSize;
            ReadFile( hFile, pbuff, dwSize, &dw, NULL );
            if( bDoCheckSum )
            {
                for( i = 0; i < dwSize; i++ )
                {
                    // checksum must skip over comments because midl places a time stamp
                    // in generated files
                    if( *(pbuff+i) == '/' )
                    {
                        if( *(pbuff+i+1) == '*' )
                        {
                            i+=2;
                            if( i >= dwSize ) break;
                            do
                            {
                                while( *(pbuff+i) != '*' )
                                    i++;
                                if( i >= dwSize ) break;
                            } while (*(pbuff+i+1) != '/' );
                            i += 2;
                        }
                    }
                    (*pdwCheckSum) += *(pbuff + i);
                }
            }
            else
            {
                pTmp = pbuff;
                while( pTmp = ProcessChunk( pTmp, pEndStream, &count ) )
                    ;
            }
            delete [] pbuff;
        }
	CloseHandle( hFile );
    }
}

CHAR* ProcessChunk( CHAR* pStream, CHAR * pEndStream, int *pCount )
{
    if( pStream >= pEndStream ) return NULL;
    CHAR *pTmp = pStream;
    CHAR szOutputName[50];
    HANDLE hOutputFile;
    DWORD dw;

    // remove leading or trailing white space
    while( *pTmp == ' ' || *pTmp == '\t' || *pTmp == 10 || *pTmp == 13 )
        pTmp++;
    if( pStream >= pEndStream ) return NULL;

    // search for the keyword "const"
    if( !strncmp( pTmp, "const ", 6 ) )
    {
        pTmp += 6;
        // remove additional white space
        while( *pTmp == ' ' || *pTmp == '\t' )
            pTmp++;

        // search for keywords "IID" or "CLSID" or "GUID"
        if( !strncmp( pTmp, "IID ", 4 ) || !strncmp( pTmp, "CLSID ", 6 ) || !strncmp( pTmp, "GUID ", 5 ) )
        {
            sprintf( szOutputName,"GuidSep\\SAPI5_guid_%03d.c", *pCount );
            (*pCount)++;
            hOutputFile = CreateFile( szOutputName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL );
            if( hOutputFile != INVALID_HANDLE_VALUE )
            {
                WriteFile( hOutputFile, "#include \"precomp.h\"\n", strlen("#include \"precomp.h\"\n"), &dw, NULL );
                while( *pTmp != ';' )
                {
                    pTmp++;
                    if( pTmp > pEndStream ) return NULL;
                }
                WriteFile( hOutputFile, pStream, pTmp - pStream + 1, &dw, NULL );
                CloseHandle( hOutputFile );
                while( *pTmp != 10 )
                    *pTmp++;
                pTmp++;
            }
        }
        else
        {
            // next line
            while( *pTmp != 10 )
                *pTmp++;
            pTmp++;
        }
    }
    else
    {
        // next line
        while( *pTmp != '\n' )
        {
            // eliminate any comment blocks
            if( *pTmp == '/' )
            {
                if( pTmp+1 <= pEndStream && (*(pTmp+1) == '*') )
                {
                    pTmp += 2;
                    do
                    {
                        while( *pTmp != '*' )
                            pTmp++;
                        if( pTmp > pEndStream ) return NULL;
                    } while (*(pTmp+1) != '/' );
                    pTmp+=2;
                    continue;
                }
            }
            pTmp++;
            if( pTmp > pEndStream ) return NULL;
        }
    }
    return pTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\x86env\x86env.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
int main(int argc, char* argv[])
{
    CHAR buff[256];
    CHAR FileName[256];
    SYSTEMTIME st;
    HANDLE hFile;
    if( argc == 1 )
    {
        printf("\nNeed command line arg for destination of env.bat\n");
        return 1;   // error
    }

    GetLocalTime( &st );
    int YearNumber = st.wYear - 1999;
    if( YearNumber < 0 )
    {
        printf("Invalid year %d - please validate system time.\n", st.wYear);
        return 1;
    }

    st.wYear %= 100;
    sprintf( buff,"set build_date=%02d%02d%02d\nset BUILDNO=%02d%02d",
    st.wYear, st.wMonth, st.wDay, st.wMonth + YearNumber*12, st.wDay );

    strcpy( FileName, argv[1] );

//    DWORD dwSize = GetEnvironmentVariable( _T("_NTROOT"),FileName,256);
    strcat( FileName, _T("\\env.bat") );
    hFile = CreateFile( FileName, GENERIC_READ | GENERIC_WRITE,
	    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile != INVALID_HANDLE_VALUE )
    {
	DWORD dw;
	WriteFile( hFile, buff, strlen(buff), &dw, NULL );
	CloseHandle( hFile );
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\mmio\mmio.c ===
/*-------------------------------------------------------------------*\
 *
 * mmio.c
 *
 * Basic MMIO functions.
 *
\*-------------------------------------------------------------------*/

/*--------------------------------------------------------------------*/
/* Revision history:
 * a-davlip: Jan 00 Ported to APC.
 * LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
 * StephenE: Apr 92 Enabled UNICODE.
 */
/*--------------------------------------------------------------------*/


/*--------------------------------------------------------------------*/
/* Implementation notes:
 *
 * An HMMIO is in fact a PMMIO i.e. a pointer to a MMIOINFO.
 * This causes the code to be littered with casts.
 * Whoever exported MMIOINFO should learn about encapsulation and
 * all that stuff.  sigh.
 *
 * The "current disk offset" is the disk offset (i.e. the location
 * in the disk file) that the next MMIOM_READ or MMIOM_WRITE will
 * read from or write to.  The I/O procedure maintains the
 * <lDiskOffset> field of the file's MMIO structure so that
 * <lDiskOffset> is equal to the current disk offset.
 *
 * The "current buffered offset" is the disk offset that the next
 * mmioRead() or mmioWrite() call would read from or write to.
 * The current buffered offset is defined as
 *
 *  <lBufOffset> + (<pchNext> - <pchBuffer>)
 *
 * since <lBufOffset> is the disk offset of the start of the buffer
 * and <pchNext> corresponds to the current buffered offset.
 *
 * If the file is unbuffered, then <pchBuffer>, <pchNext>,
 * <pchEndRead> and <pchEndWrite> will always be NULL, and
 * <lBufOffset> will always be considered the "current buffered
 * offset", i.e. mmioRead() and mmioWrite() will read/write
 * at this offset.
 *
 *
 * Except right at the beginning of mmioOpen(), the MMIO_ALLOCBUF
 * flag is set if and only if the pchBuffer field points to a block
 * of global memory that MMIO has allocated.
 */
/*--------------------------------------------------------------------*/

#include "winmmi.h"
#include "mmioi.h"
#pragma warning (disable: 4715)

HANDLE hHeap;
PHNDL pHandleList;
CRITICAL_SECTION HandleListCritSec;

/*--------------------------------------------------------------------*\
 * Local function prototypes
\*--------------------------------------------------------------------*/
static void NEAR PASCAL SetIOProc( LPCWSTR szFileName, LPMMIOINFO lpmmio);
static LPMMIOPROC NEAR PASCAL RemoveIOProc(FOURCC fccIOProc, HANDLE htask);
static LONG NEAR PASCAL mmioDiskIO(PMMIO pmmio, UINT uMsg, LPSTR pch, LONG cch);
static UINT NEAR PASCAL mmioExpandMemFile(PMMIO pmmio, LONG lExpand);
static LPMMIOPROC mmioInternalInstallIOProc( FOURCC fccIOProc,
                                             LPMMIOPROC pIOProc,
                                             DWORD dwFlags);
FOURCC APIENTRY mmioStringToFOURCCW( LPCWSTR sz, UINT uFlags );

/*--------------------------------------------------------------------*/
/* The I/O procedure map is a linked list of IOProcMapEntry structures.
 * The head of the list, <gIOProcMapHead> is a pointer node to the last
 * entry registered.  The first few elements of the list are the predefined
 * global IO procedures below -- these all have <hTask> equal to NULL so
 * that no task can unregister them.
 *
 */

typedef struct IOProcMapEntryTag
{
        FOURCC          fccIOProc;      // ID of installed I/O procedure
        LPMMIOPROC      pIOProc;        // I/O procedure address
        HANDLE          hTask;          // task that called mmioRegisterIOProc()
        struct IOProcMapEntryTag *pNext;  // pointer to next IOProc entry
} IOProcMapEntry, *pIOProcMapEntry;

// MMIOPROC is defined in the public MMSYSTEM.H
// typedef LONG (APIENTRY MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg, LONG lParam1, LONG lParam2);

MMIOPROC mmioDOSIOProc, mmioMEMIOProc; // standard I/O procedures

static IOProcMapEntry gIOProcMaps[] = {
    { FOURCC_DOS, mmioDOSIOProc, NULL,  &gIOProcMaps[1] },
    { FOURCC_MEM, mmioMEMIOProc, NULL,  NULL }
};

//
// Global head of list
//

static pIOProcMapEntry gIOProcMapHead = gIOProcMaps;




/* Call the IOProc in the info structure and return the result.
   Take due account of whether it is a 16 or 32 bit IOProc.
*/
static LRESULT IOProc(LPMMIOINFO lpmmioinfo, UINT uMsg, LONG lParam1, LONG lParam2)
{
    /*  just pass the call on */
    return ((LPMMIOPROC)(lpmmioinfo->pIOProc)) ((LPSTR)lpmmioinfo, uMsg, lParam1, lParam2);
} /* IOProc */

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   LPMMIOPROC | FindIOProc | This function locates the IOProcMapEntry
    for a previously installed IO procedure .
*/
/*--------------------------------------------------------------------*/
static pIOProcMapEntry
                  FindIOProc(FOURCC fccIOProc, HANDLE htask)
{
    IOProcMapEntry *pEnt;       // an entry in linked list

    /* walk through the linked list, first looking for an entry with
     * identifier <fccIOProc> that was added by the current task, then
     * looking for global entries.
     */

    for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
        if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask))
            return pEnt;

    for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
        if ( (pEnt->fccIOProc == fccIOProc)
                                           // ?? && (pEnt->hTask ==NULL)  ??
           )
            return pEnt;

    return NULL;
}

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   LPMMIOPROC | RemoveIOProc | This function removes previously installed
    IO procedure.
*/
/*--------------------------------------------------------------------*/
static LPMMIOPROC PASCAL NEAR
                  RemoveIOProc(FOURCC fccIOProc, HANDLE htask)
{
    IOProcMapEntry *pEnt;       // an entry in linked list
    IOProcMapEntry *pEntPrev;   // the entry before <pEnt>

    /* walk through the linked list, looking for an entry with
     * identifier <fccIOProc> that was added by the current task
     */
    for ( pEntPrev = NULL, pEnt = gIOProcMapHead
        ; pEnt
        ; pEntPrev = pEnt, pEnt = pEnt->pNext
        )
        if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask)) {
            LPMMIOPROC  pIOProc;

            pIOProc = pEnt->pIOProc;
            if (pEntPrev)
                pEntPrev->pNext = pEnt->pNext;
            else
                gIOProcMapHead = pEnt->pNext;
            FreeHandle((HMMIO) pEnt);
            return pIOProc;
        }
    return NULL;
}

/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   void | SetIOProc | This function sets the physical IO procedure
    based on either the file name or the parameters within the
    <p lpmmioinfo> structure passed.

@parm   LPCWSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to open. If no I/O procedure is

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f SetIOProc> in determining the IO procedure to use.  The
    <e MMIOINFO.pIOProc> element is set to the procedure found.

@rdesc  Nothing.
*/
/*--------------------------------------------------------------------*/
static void NEAR PASCAL
            SetIOProc( LPCWSTR szFileName, LPMMIOINFO lpmmio)
{
    IOProcMapEntry *pEnt;       // the entry in linked list

    /* If the IOProc is not given, see if the file name implies that
     * <szFileName> is either a RIFF compound file or some kind of
     * other registered storage system -- look for the last CFSEPCHAR in
     * the name, e.g. '+' in "foo.bnd+bar.hlp+blorg.dib", and figure
     * that the IOProc ID is the extension of the compound file name,
     * e.g. the extension of "foo.bnd+bar.hlp", i.e. 'HLP '.
     *
     * Alternatively, if <szFileName> is NULL, then assume that
     * <lpmmio->adwInfo[0]> is a DOS file handle.
    */
    if (lpmmio->pIOProc == NULL)
    {
        if (lpmmio->fccIOProc == 0)
        {
            if (szFileName != NULL)
            {
                LPWSTR   pch;

                /* see if <szFileName> contains CFSEPCHAR */
                if ((pch = wcsrchr(szFileName, CFSEPCHAR)) != 0)
                {
                    /* find the extension that precedes CFSEPCHAR,
                     * e.g. "hlp" in "foo.bnd+bar.hlp+blorg.dib"
                    */
                    while (  (pch > szFileName)
                          && (*pch != L'.')
                          && (*pch != L':')
                          && (*pch != L'\\')
                          )
                        pch--;
                    if (*pch == L'.')
                    {
                        WCHAR    aszFour[sizeof(FOURCC)+1];
                        int i;

                        for (i = 0, pch++; i < sizeof(FOURCC); i++)
                            if (*pch == CFSEPCHAR)
                                aszFour[i] = L'\0';
                            else
                                aszFour[i] = *pch++;
                        aszFour[sizeof(FOURCC)] = L'\0';
                        lpmmio->fccIOProc = mmioStringToFOURCCW(aszFour, MMIO_TOUPPER);
                    }
                }
            }
            /* if the caller didn't specify an IOProc, and the code above
             * didn't determine an IOProc ID, then the default is the DOS
             * IOProc.
            */
            if (lpmmio->fccIOProc == 0)
                lpmmio->fccIOProc = FOURCC_DOS;
        }

        /* unless an IOProc address is specified explicitly, look up the
         * IOProc in the global IOProc ID-to-address table -- the default
         * is 'DOS' since we'll assume that custom storage system I/O
         * procedures would have been installed
        */
        pEnt = FindIOProc( lpmmio->fccIOProc
                         ,   lpmmio->htask
                           ? lpmmio->htask
                           : (HANDLE)GetCurrentThreadId()
                         );
        if (pEnt && pEnt->pIOProc) {
            lpmmio->pIOProc = pEnt -> pIOProc;
        }
        else {
            lpmmio->pIOProc = mmioDOSIOProc;
            lpmmio->dwReserved1 = 0;
        }
    }
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@func   void | mmioCleanupIOProcs | removes from the linked list entries
    installed with the given task handle

@parm   HANDLE | hTask | Specifies the task to clean up for

@rdesc  Nothing.

@comm  This will only be called to clean up a WOW task.
*/
/*--------------------------------------------------------------------*/
void mmioCleanupIOProcs(HANDLE hTask)
{
     IOProcMapEntry *pEnt;
     IOProcMapEntry *pEntPrev;

     for (pEntPrev = NULL, pEnt = gIOProcMapHead; pEnt;) {

        if (pEnt->hTask == hTask) {
            DEBUGMSG(1, (TEXT("MMIOPROC handle (%04X) not closed."), pEnt));
            if (pEntPrev) {
                pEntPrev->pNext = pEnt->pNext;
                FreeHandle((HMMIO)pEnt);
                pEnt = pEntPrev->pNext;
            } else {
                gIOProcMapHead = pEnt->pNext;
                FreeHandle((HMMIO)pEnt);
                pEnt = gIOProcMapHead;
            }
        } else {
            pEntPrev = pEnt;
            pEnt = pEnt->pNext;
        }
     }
}



/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    UINT | mmioRename | This function renames the specified file.

@parm   LPCTSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to rename.

@parm   LPCTSTR | szNewFileName | Specifies a pointer to a string
containing the new filename.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f mmioRename>.

    If <p lpmmioinfo> is not NULL, all unused fields of the
    <t MMIOINFO> structure it references must be set to zero, including the
    reserved fields.

@parm   DWORD | dwRenameFlags | Specifies option flags for the rename
    operation.  This should be set to zero.

@rdesc  The return value is zero if the file was renamed.  Otherwise, the
return value is an error code returned from <f mmioRename> or from the I/O
procedure.
*/
/*--------------------------------------------------------------------*/
UINT APIENTRY
     mmioRenameW( LPCWSTR        szFileName
                , LPCWSTR        szNewFileName
                , LPCMMIOINFO    lpmmioinfo
                , DWORD          fdwRename
                )
{
    MMIOINFO    mmioinfo;

    memset(&mmioinfo, 0, sizeof(MMIOINFO));

    V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    if (lpmmioinfo) {
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
        mmioinfo = *lpmmioinfo;
    }

    SetIOProc(szFileName, &mmioinfo);

    if ( (mmioinfo.dwFlags & MMIO_UNICODEPROC )
      || (mmioinfo.pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (mmioinfo.pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /*------------------------------------------------------------*\
         * We have an unicode IO Proc so use the given file names
         * without any conversion.
        \*------------------------------------------------------------*/
        return IOProc( &mmioinfo, MMIOM_RENAME,
                       (LONG)szFileName, (LONG)szNewFileName );
    }
    else
        DEBUGMSG(1, (TEXT("mmio: ERROR -- ASCII IO proc desired")));

}



/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    HMMIO | mmioOpen | This function opens a file for unbuffered
    or buffered I/O. The file can be a DOS file, a memory file, or an
    element of a custom storage system.

@parm   LPTSTR | szFilename | Specifies a pointer to a string
containing the filename of the file to open. If no I/O procedure is
specified to open the file, then the filename determines how the file
is opened, as follows:

    -- If the filename does not contain "+", then it is assumed
    to be the name of a DOS file.

    -- If the filename is of the form "foo.ext+bar", then the
    extension "EXT " is assumed to identify an installed I/O procedure
    which is called to perform I/O on the file (see <f mmioInstallIOProc>).

    -- If the filename is NULL and no I/O procedure is given, then
    <e MMIOINFO.adwInfo[0]> is assumed to be the DOS file handle
    of a currently open file.

    The filename should not be longer than 128 bytes, including the
    terminating NULL.

    When opening a memory file, set <p szFilename> to NULL.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure containing extra parameters used by
    <f mmioOpen>. Unless you are opening a memory file, specifying the
    size of a buffer for buffered I/O, or specifying an uninstalled I/O
    procedure to open a file, this parameter should be NULL.

    If <p lpmmioinfo> is not NULL, all unused fields of the
    <t MMIOINFO> structure it references must be set to zero, including the
    reserved fields.

@parm   DWORD | dwOpenFlags | Specifies option flags for the open
    operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are
    mutually exclusive--only one should be specified. The MMIO_COMPAT,
    MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags
    are DOS file-sharing flags, and can only be used after the DOS
    command SHARE has been executed.

    @flag   MMIO_READ | Opens the file for reading only.  This is the
        default, if MMIO_WRITE and MMIO_READWRITE are not specified.

    @flag   MMIO_WRITE | Opens the file for writing.  You should not
        read from a file opened in this mode.

    @flag   MMIO_READWRITE | Opens the file for both reading and writing.

    @flag   MMIO_CREATE | Creates a new file.
        If the file already exists, it is truncated to zero length.
        For memory files, MMIO_CREATE indicates the end of the file
        is initially at the start of the buffer.

    @flag   MMIO_DELETE | Deletes a file. If this flag is specified,
        <p szFilename> should not be NULL. The return
        value will be TRUE (cast to HMMIO) if the file was deleted
        successfully, FALSE otherwise.  Do not call <f mmioClose>
        for a file that has been deleted.  If this flag is specified,
        all other file opening flags are ignored.

    @flag   MMIO_PARSE | Creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
        will be TRUE (cast to HMMIO) if the qualification was
        successful, FALSE otherwise. The file is not opened, and the function
        does not return a valid MMIO file handle, so do not attempt to
        close the file. If this flag is specified, all other file
        opening flags are ignored.

    @flag   MMIO_EXIST | Determines whether the specified file exists
        and creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
        will be TRUE (cast to HMMIO) if the qualification was
        successful and the file exists, FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.

    @flag   MMIO_ALLOCBUF | Opens a file for buffered I/O.
        To allocate a buffer larger or smaller than the default
        buffer size (8K), set the <e MMIOINFO.cchBuffer> field of the
        <t MMIOINFO> structure to the desired buffer size. If
        <e MMIOINFO.cchBuffer> is zero, then the default buffer size
        is used. If you are providing your own I/O buffer, then the
        MMIO_ALLOCBUF flag should not be used.

    @flag   MMIO_COMPAT | Opens the file with compatibility mode,
        allowing any process on a given machine to open the file
        any number of times.  <f mmioOpen> fails if the file has
        been opened with any of the other sharing modes.

    @flag   MMIO_EXCLUSIVE | Opens the file with exclusive mode,
        denying other processes both read and write access to the file.
        <f mmioOpen> fails if the file has been opened in any other
        mode for read or write access, even by the current process.

    @flag   MMIO_DENYWRITE | Opens the file and denies other
        processes write access to the file.  <f mmioOpen> fails
        if the file has been opened in compatibility or for write
        access by any other process.

    @flag   MMIO_DENYREAD | Opens the file and denies other
        processes read access to the file.  <f mmioOpen> fails if the
        file has been opened in compatibility mode or for read access
        by any other process.

    @flag   MMIO_DENYNONE | Opens the file without denying other
        processes read or write access to the file.  <f mmioOpen>
        fails if the file has been opened in compatibility mode
        by any other process.

    @flag   MMIO_GETTEMP | Creates a temporary filename, optionally
        using the parameters passed in <p szFileName> to determine
        the temporary name. For example, you can specify "C:F" to
        create a temporary file residing on drive C, starting with
        letter "F". The resulting filename is placed in the buffer
        pointed to by <p szFileName>.  The return value will be TRUE
        (cast to HMMIO) if the temporary filename was created successfully,
        FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.
        This flag overrides all other flags.

@rdesc  The return value is a handle to the opened file. This handle
    is not a DOS file handle--do not use it with any file I/O functions
    other than MMIO functions.

    If the file cannot be opened, the return value is NULL.  If
    <p lpmmioinfo> is not NULL, then its <e MMIOINFO.wErrorRet> field
    will contain extended error information returned by the I/O
    procedure.

@comm   If <p lpmmioinfo> references an <t MMIOINFO> structure, set
up the fields as described below. All unused fields must be set to
zero, including reserved fields.

-- To request that a file be opened with an installed I/O
procedure, set the <e MMIOINFO.fccIOProc> field
to the four-character code of the I/O procedure,
and set the <e MMIOINFO.pIOProc> field to NULL.

-- To request that a file be opened with an uninstalled I/O procedure,
set the <e MMIOINFO.pIOProc> field to
point to the I/O procedure, and set <e MMIOINFO.fccIOProc> to NULL.

-- To request that <f mmioOpen> determine which I/O procedure to use
to open the file based on the filename contained in <p szFilename>,
set both <e MMIOINFO.fccIOProc> and <e MMIOINFO.pIOProc> to NULL.
This is the default behavior if no <t MMIOINFO> structure is specified.

-- To open a memory file using an internally allocated and managed
buffer, set the <e MMIOINFO.pchBuffer> field to NULL,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the initial size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. This memory file will automatically be expanded in increments of
<e MMIOINFO.adwInfo[0]> bytes when necessary. Specify the MMIO_CREATE
flag for the <p dwOpenFlags> parameter to initially set the end of
the file to be the beginning of the buffer.

-- To open a memory file using a caller-supplied buffer, set
the <e MMIOINFO.pchBuffer> field to point to the memory buffer,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. The expansion size in <e MMIOINFO.adwInfo[0]> should only
be non-zero if <e MMIOINFO.pchBuffer> is a pointer obtained by calling
<f GlobalAlloc> and <f GlobalLock>, since <f GlobalReAlloc> will be called to
expand the buffer.  In particular, if <e MMIOINFO.pchBuffer> points to a
local or global array, a block of memory in the local heap, or a block
of memory allocated by <f GlobalDosAlloc>, <e MMIOINFO.adwInfo[0]> must
be zero.
Specify the MMIO_CREATE flag for the <p dwOpenFlags> parameter to
initially set the end of the file to be the beginning of the buffer;
otherwise, the entire block of memory will be considered readable.

-- To use a currently open DOS file handle with MMIO, set the
<e MMIOINFO.fccIOProc> field to FOURCC_DOS,
<e MMIOINFO.pchBuffer> to NULL, and <e MMIOINFO.adwInfo[0]> to the
DOS file handle.  Note that offsets within the file will be relative to
the beginning of the file, and will not depend on the DOS file position
at the time <f mmioOpen> is called; the initial MMIO offset will be the same
as the DOS offset when <f mmioOpen> is called.
Later, to close the MMIO file handle without closing the DOS
file handle, pass the MMIO_FHOPEN flag to <f mmioClose>.

You must call <f mmioClose> to close a file opened with <f mmioOpen>.
Open files are not automatically closed when an application exits.

@xref   mmioClose
*/

/* these are the changes to mmioOpen() to support compound files... */

/* @doc CFDOC

@api    HMMIO | mmioOpen | ...The file can be a DOS file, a memory file,
    an element of a RIFF compound file...

@parm   LPTSTR | szFilename | ...

    -- If <p szFilename> is of the form "foo+bar", then <f mmioOpen>
    opens the compound file element named "bar" that is stored inside
    the RIFF compound file named "foo".

    -- If <p szFilename> is of the form "foo.ext+bar", then the
    extension "ext" is assumed to identify the installed I/O procedure
    (see <f mmioInstallIOProc>).  The extension "bnd", and any extensions
    that have not been installed, are assumed to refer to a RIFF compound
    file.

@parm   LPMMIOINFO | lpmmioinfo | ...

@parm   DWORD | dwOpenFlags | ...

@rdesc  ...

@comm   ...

    The following I/O procedure identifiers (type FOURCC) are predefined:

    ...

    FOURCC_BND: <p szFilename> is assumed to be the name of
    a RIFF compound file element, and <p adwInfo[0]> should
    contain the HMMCF of the compound file.  Alternatively,
    <p szFilename> can include the name of the compound file
    (e.g. "foo.bnd+bar.dib" as described above), and <p adwInfo[0]>
    should be NULL, to automatically open the compound file.

    ...

    The easy way to open an element of a RIFF compound file: just
    include the name of the compound file in <p szFilename> preceded
    by a "+" as described above.  For example, opening
    "c:\data\bar.bnd+blorg.dib" opens the compound file element
    named "blorg.dib" in the compound file "c:\data\bar.bnd".
    <p lpmmioinfo> can be null in this case -- set <p dwOpenFlags>
    as described above.  You can use this same method to open an
    element of a custom storage system, if the file extension of the
    compound file ("bnd" in the above example) corresponds to an
    installed I/O procedure -- see <f mmioInstallIOProc> for details.

    To open an element of a RIFF compound file that was opened using
    <f mmioCFAccess> or <f mmioCFOpen>: set <p szFilename>
    to be the name of the compound file element; set <p fccIOProc>
    to FOURCC_BND; set <p adwInfo[0]> to the HMMCF of the open compound
    file; set <p dwOpenFlags> and <p cchBuffer> as described above;
    set all other fields of <p lpmmioinfo> to zero.

    ...
*/
/*--------------------------------------------------------------------*/
HMMIO APIENTRY
      mmioOpen( LPWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags )
{
    PMMIO       pmmio;      // MMIO status block
    LPSTR       hpBuffer;
    UINT        w;          // an MMRESULT or a LRESULT from an IOPROC

	hHeap = GetProcessHeap();

    V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
    V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

    if (lpmmioinfo) {
        lpmmioinfo->wErrorRet = 0;
        V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
    }

    /* allocate MMIO status information block */
    if ( (pmmio = (PMMIO)(NewHandle(TYPE_MMIO, sizeof(MMIOINFO)))) == NULL)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
        }
        return NULL;
    }

    /*----------------------------------------------------------------*\
     * NewHandle does not zero the allocated storage so we had better do
     * it now.
    \*----------------------------------------------------------------*/
    memset(pmmio, 0, sizeof(MMIOINFO));

    /* if user supplied <lpmmioinfo>, copy it to <pmmio> */
    if (lpmmioinfo != NULL) {
        *pmmio = *lpmmioinfo;
    }

    /* <dwOpenFlags> always takes precedence over contents of <pmmio> */
    pmmio->dwFlags = dwOpenFlags;
    pmmio->hmmio = ((HMMIO)pmmio);

    /* MMIO_ALLOCBUF in the flags means that the user wants a buffer
     * allocated for buffered I/O, but after this point it means that
     * a buffer *was* allocated, so turn off the flag until the buffer
     * is actually allocated (which is done by mmioSetBuffer() below)
     */
    if (pmmio->dwFlags & MMIO_ALLOCBUF)
    {
        /* if a buffer size is not specified, use the default */
        if (pmmio->cchBuffer == 0) {
            pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
        }
        pmmio->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Set the pIOProc function as determined by the file name or the
     * parameters in the pmmio structure.
     */
    SetIOProc(szFileName, pmmio);

    /* The pmmio structure hasn't been set up for buffering, so we must
     * explicitly make sure that pchBuffer is NULL.
     */
    hpBuffer = pmmio->pchBuffer;
    pmmio->pchBuffer = NULL;

    /* set up buffered I/O however the user requested it */
    w = mmioSetBuffer(((HMMIO)pmmio), hpBuffer, pmmio->cchBuffer, 0);
    if (w)
    {
        if (lpmmioinfo) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if ( (pmmio->dwFlags & MMIO_UNICODEPROC)    // a Unicode IO Proc
      || (pmmio->pIOProc == mmioDOSIOProc )     // or the DOS file IO Proc
      || (pmmio->pIOProc == mmioMEMIOProc ) ) { // or a memory file IO Proc

        /* let the I/O procedure open/delete/qualify the file */
        w = IOProc( pmmio, MMIOM_OPEN, (LONG)szFileName, 0L );

    } else

        DEBUGMSG(1, (TEXT("mmio: ERROR -- cleaning up IO proc w/ ASCII name")));


    /* If this is non-zero, return it to the user */
    if (w != 0)
    {
        if (lpmmioinfo != NULL) {
            lpmmioinfo->wErrorRet = w;
        }
        FreeHandle(((HMMIO)pmmio));
        return NULL;
    }

    if (pmmio->dwFlags & (MMIO_DELETE| MMIO_PARSE| MMIO_EXIST| MMIO_GETTEMP))
    {
        /* if the file is being deleted/parsed/name gotten, exit
         * QUICKLY because the file handle (or whatever) in <pmmio>
         * is not valid.
         */
        mmioSetBuffer(((HMMIO)pmmio), NULL, 0L, 0);
        FreeHandle(((HMMIO)pmmio));
        return (HMMIO) TRUE;
    }

    /* the initial "current buffered offset" will be equal to the initial
     * "current disk offset"
     */
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return ((HMMIO)pmmio);
}




/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioClose | This function closes a file opened with
    <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file to
    close.

@parm   UINT | uFlags | Specifies options for the close operation.

    @flag   MMIO_FHOPEN | If the file was opened by passing the DOS
        file handle of an already-opened file to <f mmioOpen>, then
        using this flag tells <f mmioClose> to close the MMIO file
        handle, but not the DOS file handle.  (This is done by the
        I/O Proc).

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value is an error code, either from
    <f mmioFlush> or from the I/O procedure. The error code can be
    one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTCLOSE | There was a DOS file system error when
    the I/O Proc attempted to close the DOS file.

@xref   mmioOpen mmioFlush
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
        mmioClose(HMMIO hmmio, UINT uFlags)
{
    UINT w;                /* either an LRESULT from an IOProc or an MMRESULT */

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);

    if ((w = mmioFlush(hmmio, 0)) != 0)
        return w;

    w = IOProc( (PMMIO)hmmio, MMIOM_CLOSE, (LONG)(DWORD) uFlags, (LONG) 0);
    if (w != 0) return w;

    /* free the buffer if necessary */
    mmioSetBuffer(hmmio, NULL, 0L, 0);

    FreeHandle(hmmio);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioRead | This function reads a specified number of
    bytes from a file opened with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file to be
    read.

@parm   LPSTR | pch | Specifies a pointer to a buffer to contain
    the data read from the file.

@parm   LONG | cch | Specifies the number of bytes to read from the
    file.

@rdesc  The return value is the number of bytes actually read. If the
    end of the file has been reached and no more bytes can be read, the
    return value is zero. If there is an error reading from the file, the
    return value is -1.

@comm  On 16 bit windows pch is a huge pointer.  On 32 bit windows there is no
    distinction between huge pointers and long pointers.

@xref   mmioWrite
*/
/*--------------------------------------------------------------------*/
LRESULT APIENTRY
mmioRead(HMMIO hmmio, LPSTR pch, LONG cch)
{
    LONG        lTotalBytesRead = 0L;   // total no. bytes read
    LONG        lBytes;         // no. bytes that can be read
    PMMIO       pmmio=(PMMIO)hmmio; //local copy hmmio - avoid casting, simplify debug

    V_HANDLE(hmmio, TYPE_MMIO, -1);
    V_WPOINTER(pch, cch, -1);

    for(;;)
    {
        /* calculate the number of bytes that can be read */
        lBytes = pmmio->pchEndRead - pmmio->pchNext;

        /* can only read at most <cch> bytes from buffer */
        if (lBytes > cch)
            lBytes = cch;

        if (lBytes > 0)
        {
            /* this is where some performance improvements can
             * be made, especially for small reads...?
             */
            memcpy(pch, pmmio->pchNext, lBytes);
            pmmio->pchNext += lBytes;
            pch += lBytes;
            cch -= lBytes;
            lTotalBytesRead += lBytes;
        }

        /* cannot do MMIOM_READ from memory files */
        if (pmmio->fccIOProc == FOURCC_MEM)
            return lTotalBytesRead;

        if (cch == 0)           // no more to read?
            return lTotalBytesRead;

        /* we need to read beyond this buffer; if we have at least
         * another bufferful to read, just call the I/O procedure
         */
        if (cch > pmmio->cchBuffer)
            break;

        /* read the next bufferful and loop around */
        if (mmioAdvance(hmmio, NULL, MMIO_READ) != 0)
            return -1;

        /* if mmioAdvance() couldn't read any more data, we must be
         * at the end of the file
         */
        if (pmmio->pchNext == pmmio->pchEndRead)
            return lTotalBytesRead;
    }

    /* flush and empty the I/O buffer and manipulate <lBufOffset>
     * directly to change the current file position
     */
    if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
        return -1;

    /* call the I/O procedure to do the rest of the reading */
    lBytes = mmioDiskIO(pmmio, MMIOM_READ, pch, cch);
    pmmio->lBufOffset = pmmio->lDiskOffset;

    return (lBytes == -1L) ? -1L : lTotalBytesRead + lBytes;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioWrite | This function writes a specified number of
    bytes to a file opened with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPSTR | pch | Specifies a pointer to the buffer to be
    written to the file.

@parm   LONG | cch | Specifies the number of bytes to write to the
    file.

@rdesc  The return value is the number of bytes actually written. If
    there is an error writing to the file, the return value is -1.

@comm   The current file position is incremented by the number of
    bytes written.   On 16 bit windows pch is a huge pointer.
    On 32 bit windows there is no distinction between huge pointers
    and long pointers.

@xref   mmioRead
*/
/*--------------------------------------------------------------------*/
LRESULT APIENTRY
mmioWrite(HMMIO hmmio, LPCSTR pch, LONG cch)
{
    LONG        lTotalBytesWritten = 0L; // total no. bytes written
    LONG        lBytes;         // no. bytes that can be written
    // "pch" is LPCSTR which is correct, but
    // we pass it to a polymorphic routine
    // which needs LPSTR.

    V_HANDLE(hmmio, TYPE_MMIO, -1);
    V_RPOINTER(pch, cch, -1);

    for(;;)
    {
        /* calculate the number of bytes that can be written */
        lBytes = ((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext;

        if ((cch > lBytes) && (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM))
        {
            /* this is a memory file -- expand it */
            if (mmioExpandMemFile(((PMMIO)hmmio), cch - lBytes) != 0)
                return -1;  // cannot expand
            lBytes = ((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext;
        }

        /* can only write at most <cch> bytes into the buffer */
        if (lBytes > cch)
            lBytes = cch;

        /* this is where some performance improvements can
         * be made, especially for small writes... should
         * special-case cases when segment boundaries are
         * not crossed (or maybe hmemcpy() should do that)
         */
        if (lBytes > 0)
        {
            memcpy(((PMMIO)hmmio)->pchNext, pch, lBytes);
            ((PMMIO)hmmio)->dwFlags |= MMIO_DIRTY;
            ((PMMIO)hmmio)->pchNext += lBytes;
            pch += lBytes;
            cch -= lBytes;
            lTotalBytesWritten += lBytes;
        }

        /* validate <pchEndRead>, i.e. re-enforce the invariant that
         * <pchEndRead> points past the last valid byte in the buffer
         */
        if (((PMMIO)hmmio)->pchEndRead < ((PMMIO)hmmio)->pchNext)
            ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchNext;

        if (cch == 0)           // no more to write?
            return lTotalBytesWritten;

        /* we need to read beyond this buffer; if we have at least
         * another bufferful to read, just call the I/O procedure
         */
        if (cch > ((PMMIO)hmmio)->cchBuffer)
            break;

        /* write this buffer (if needed) and read the next
         * bufferful (if needed)
         */
        if (mmioAdvance(hmmio, NULL, MMIO_WRITE) != 0)
            return -1;
    }

    /* we should never need to do MMIOM_WRITE with memory files */

    /* flush and empty the I/O buffer and manipulate <lBufOffset>
     * directly to change the current file position
     */
    if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
        return -1;

    /* call the I/O procedure to do the rest of the writing
     * mmioDiskIO is a polymorphic routine, hence we need to cast
     * our LPCSTR input pointer to LPTSTR.
     */
    lBytes = mmioDiskIO(((PMMIO)hmmio), MMIOM_WRITE, (LPSTR)pch, cch);
    ((PMMIO)hmmio)->lBufOffset = ((PMMIO)hmmio)->lDiskOffset;

    return (lBytes == -1L) ? -1L : lTotalBytesWritten + lBytes;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioSeek | This function changes the current file
    position in a file opened with <f mmioOpen>. The current file
    position is the location in the file where data is read or written.

@parm   HMMIO | hmmio | Specifies the file handle of the file to seek
    in.

@parm   LONG | lOffset | Specifies an offset to change the file position.

@parm   int | iOrigin | Specifies how the offset specified by
    <p lOffset> is interpreted. Contains one of the following flags:

    @flag   SEEK_SET | Seeks to <p lOffset> bytes from the beginning
        of the file.

    @flag   SEEK_CUR | Seeks to <p lOffset> bytes from the current
        file position.

    @flag   SEEK_END | Seeks to <p lOffset> bytes from the end
        of the file.

@rdesc  The return value is the new file position in bytes, relative
    to the beginning of the file. If there is an error, the return value
    is -1.

@comm   Seeking to an invalid location in the file, such as past the
    end of the file, may cause <f mmioSeek> to not return an error,
    but may cause subsequent I/O operations on the file to fail.

    To locate the end of a file, call <f mmioSeek> with <p lOffset>
    set to zero and <p iOrigin> set to SEEK_END.
*/
/*--------------------------------------------------------------------*/
LRESULT APIENTRY
mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
{
    LONG        lCurOffset; // disk offset of <pchNext>
    LONG        lEndBufOffset;  // disk offset of end of buffer
    LONG        lNewOffset; // new disk offset


    V_HANDLE(hmmio, TYPE_MMIO, -1);

    /* careful! all this buffer pointer manipulation is fine, but keep
     * in mind that buffering may be disabled (in which case <pchEndRead>
     * and <pchBuffer> will both be NULL, so the buffer will appear to
     * be zero bytes in size)
     */

    /* <((PMMIO)hmmio)->lBufOffset> is the disk offset of the start of the
     * start of the buffer; determine <lCurOffset>, the offset of <pchNext>,
     * and <lEndBufOffset>, the offset of the end of the valid part
     * of the buffer
     */
    lCurOffset = ((PMMIO)hmmio)->lBufOffset +
        (((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer);
    lEndBufOffset = ((PMMIO)hmmio)->lBufOffset +
        (((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer);

    /* determine <lNewOffset>, the offset to seek to */
    switch (iOrigin)
    {
    case SEEK_SET:      // seek relative to start of file

        lNewOffset = lOffset;
        break;

    case SEEK_CUR:      // seek relative to current location

        lNewOffset = lCurOffset + lOffset;
        break;

    case SEEK_END:      // seek relative to end of file

        if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
            lNewOffset = lEndBufOffset - lOffset;
        else
        {
            LONG    lEndFileOffset;

            /* find out where the end of the file is */
            lEndFileOffset
                 = IOProc( (PMMIO)hmmio, MMIOM_SEEK, (LONG) 0, (LONG) SEEK_END);
            if (lEndFileOffset == -1)
                return -1;
            /* Check that we don't have buffered data not yet written */

            if (lEndBufOffset > lEndFileOffset) {
                lEndFileOffset = lEndBufOffset;
            }

            lNewOffset = lEndFileOffset - lOffset;
        }
        break;
    default: lNewOffset = 0;
        {
          DEBUGMSG(1, (TEXT("Invalid seek type %d\n"),iOrigin));
          DEBUGCHK(FALSE);
        }
    }

    if ( (lNewOffset >= ((PMMIO)hmmio)->lBufOffset)
       && (lNewOffset <= lEndBufOffset)
       )
    {
        /* seeking within the valid part of the buffer
         * (possibly including seeking to <lEndBufOffset>)
         */
        ((PMMIO)hmmio)->pchNext = ((PMMIO)hmmio)->pchBuffer +
            (lNewOffset - ((PMMIO)hmmio)->lBufOffset);
    }
    else
    {
        /* seeking outside the buffer */
        if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
            return -1;  // can't seek outside mem. file buffer
        if (mmioFlush(hmmio, 0) != 0)
            return -1;

        /* the current "buffered file position" (same as <lDiskOffset>
         * for unbuffered files) equals <lBufOffset> +
         * (<pchNext> - <pchBuffer>); we'll move the current buffered
         * file position (and empty the buffer, since it becomes
         * invalid when <lBufOffset> changes) as follows...
         */
        ((PMMIO)hmmio)->lBufOffset = lNewOffset;
        ((PMMIO)hmmio)->pchNext
            = ((PMMIO)hmmio)->pchEndRead
            = ((PMMIO)hmmio)->pchBuffer;

        /* don't need to actually seek right now, since the next
         * MMIOM_READ or MMIOM_WRITE will have to seek anyway
         */
    }

    return lNewOffset;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioGetInfo | This function retrieves information
    about a file opened with <f mmioOpen>. This information allows the
    caller to directly access the I/O buffer, if the file is opened
    for buffered I/O.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to a
    caller-allocated <t MMIOINFO> structure that <f mmioGetInfo>
    fills with information about the file. See the <t MMIOINFO> structure
    and the <f mmioOpen> function for information about the fields in
    this structure.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.

@comm   To directly access the I/O buffer of a file opened for
    buffered I/O, use the following fields of the <t MMIOINFO> structure
    filled by <f mmioGetInfo>:

    -- The <e MMIOINFO.pchNext> field points to the next byte in the
    buffer that can be read or written. When you read or write, increment
    <e MMIOINFO.pchNext> by the number of bytes read or written.

    -- The <e MMIOINFO.pchEndRead> field points to one byte past the
    last valid byte in the buffer that can be read.

    -- The <e MMIOINFO.pchEndWrite> field points to one byte past the
    last location in the buffer that can be written.

    Once you read or write to the buffer and modify
    <e MMIOINFO.pchNext>, do not call any MMIO function except
    <f mmioAdvance> until you call <f mmioSetInfo>. Call <f mmioSetInfo>
    when you are finished directly accessing the buffer.

    When you reach the end of the buffer specified by
    <e MMIOINFO.pchEndRead> or <e MMIOINFO.pchEndWrite>, call
    <f mmioAdvance> to fill the buffer from the disk, or write
    the buffer to the disk. The <f mmioAdvance> function
    will update the <e MMIOINFO.pchNext>, <e MMIOINFO.pchEndRead>, and
    <e MMIOINFO.pchEndWrite> fields in the <t MMIOINFO> structure for the
    file.

    Before calling <f mmioAdvance> or <f mmioSetInfo> to flush a
    buffer to disk, set the MMIO_DIRTY flag in the <e MMIOINFO.dwFlags>
    field of the <t MMIOINFO> structure for the file. Otherwise, the
    buffer will not get written to disk.

    Do not decrement <e MMIOINFO.pchNext> or modify any fields in the
    <t MMIOINFO> structure other than <e MMIOINFO.pchNext> and
    <e MMIOINFO.dwFlags>. Do not set any flags in <e MMIOINFO.dwFlags>
    except MMIO_DIRTY.

@xref   mmioSetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
mmioGetInfo(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT uFlags)
{
    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);

    *lpmmioinfo = *((PMMIO)hmmio);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioSetInfo | This function updates the information
    retrieved by <f mmioGetInfo> about a file opened with <f mmioOpen>.
    Use this function to terminate direct buffer access of a file opened
    for buffered I/O.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPMMIOINFO | lpmmioinfo | Specifies a pointer to an
    <t MMIOINFO> structure filled with information with
    <f mmioGetInfo>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.

@comm   If you have written to the file I/O buffer, set the
    MMIO_DIRTY flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO>
    structure before calling <f mmioSetInfo> to terminate direct buffer
    access. Otherwise, the buffer will not get flushed to disk.

@xref   mmioGetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
mmioSetInfo(HMMIO hmmio, LPCMMIOINFO lpmmioinfo, UINT fuInfo)
{
    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    V_RPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
    V_WPOINTER0( lpmmioinfo->pchBuffer
               , lpmmioinfo->cchBuffer
               , MMSYSERR_INVALPARAM
               );
    V_CALLBACK((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);

    /* copy the relevant information from <lpmmioinfo> back into <hmmio> */
    *((PMMIO)hmmio) = *lpmmioinfo;

    /* validate <pchEndRead>, i.e. re-enforce the invariant that
     * <pchEndRead> points past the last valid byte in the buffer
     */
    if (((PMMIO)hmmio)->pchEndRead < ((PMMIO)hmmio)->pchNext)
        ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchNext;

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioSetBuffer | This function enables or disables
    buffered I/O, or changes the buffer or buffer size for a file opened
    with <f mmioOpen>.

@parm   HMMIO | hmmio | Specifies the file handle of the file.

@parm   LPSTR | pchBuffer | Specifies a pointer to a
    caller-supplied buffer to use for buffered I/O. If NULL,
    <f mmioSetBuffer> allocates an internal buffer for buffered I/O.

@parm   LONG | cchBuffer | Specifies the size of the caller-supplied
    buffer, or the size of the buffer for <f mmioSetBuffer> to allocate.

@parm   UINT | fuInfo | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. If an error
    occurs, the file handle remains valid. The error code can be one
    of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the old buffer could
    not be written to disk, so the operation was aborted.

    @flag MMIOERR_OUTOFMEMORY | The new buffer could not be allocated,
    probably due to a lack of available memory.

@comm   To enable buffering using an internal buffer, set
    <p pchBuffer> to NULL and <p cchBuffer> to the desired buffer size.

    To supply your own buffer, set <p pchBuffer> to point to the buffer,
    and set <p cchBuffer> to the size of the buffer.

    To disable buffered I/O, set <p pchBuffer> to NULL and
    <p cchBuffer> to zero.

    If buffered I/O is already enabled using an internal buffer, you
    can reallocate the buffer to a different size by setting
    <p pchBuffer> to NULL and <p cchBuffer> to the new buffer size. The
    contents of the buffer may be changed after resizing.
 */
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
         mmioSetBuffer( HMMIO hmmio
                      , LPSTR pchBuffer
                      , LONG cchBuffer
                      , UINT uFlags
                      )
{
    MMRESULT mmr;
    HANDLE hMem;

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    // Validate the buffer - for READ/WRITE as appropriate
    if (((PMMIO)hmmio)->dwFlags & (MMIO_WRITE | MMIO_READWRITE)) {
	V_WPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
    } else {
	V_RPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
    }

    if ((((PMMIO)hmmio)->dwFlags & MMIO_ALLOCBUF) &&
        (pchBuffer == NULL) && (cchBuffer > 0))
    {
        /* grow or shrink buffer in-place */
        LPSTR       pch;
        LONG        lDeltaNext;
        LONG        lDeltaEndRead;

        /* Since the ALLOCBUF flag is set, we must have a buffer */

        /* write the buffer to disk, but don't empty it */
        if ((mmr = mmioFlush(hmmio, 0)) != 0)
            return mmr;

        for(;;)
        {
            /* remember where <pchNext> and <pchEndRead> are
             * in the buffer
             */
            lDeltaNext = ((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer;
            lDeltaEndRead
                    = ((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer;

            if (cchBuffer >= lDeltaNext)
                break;

            /* caller wants to truncate the part of the buffer
             * that contains <pchNext> -- handle this by
             * emptying the buffer, recalculating <lDeltaNext>
             * and <lDeltaEndRead>, and continuing below
             */
            if ((mmr = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
                return mmr;
        }

        /* reallocate buffer */
	{
	HANDLE hTemp;

        hTemp =  LocalHandle( ((PMMIO)hmmio)->pchBuffer );

        LocalUnlock( hTemp );
        hMem = LocalReAlloc( hTemp
                            , cchBuffer
                            , LMEM_MOVEABLE
                            );
        pch = LocalLock(hMem);
		DEBUGMSG(1, (TEXT("mmioSetBuffer reallocated ptr %8x, handle %8x, to ptr %8x (handle %8x)\n"), 
		((PMMIO)hmmio)->pchBuffer, hTemp, pch, hMem));

	}

        /* If we cannot allocate the new buffer, exit with no
         *   harm done.
         */
        if (pch == NULL)
            return MMIOERR_OUTOFMEMORY; // out of memory

        /* transfer pointers to new buffer */
        ((PMMIO)hmmio)->cchBuffer = cchBuffer;
        ((PMMIO)hmmio)->pchBuffer = pch;
        ((PMMIO)hmmio)->pchNext = pch + lDeltaNext;
        ((PMMIO)hmmio)->pchEndRead = pch + lDeltaEndRead;

        /* <pchEndWrite> always points to the end of the buf. */
        ((PMMIO)hmmio)->pchEndWrite = ((PMMIO)hmmio)->pchBuffer + cchBuffer;

        /* check if the reallocation truncated valid data */
        if (lDeltaEndRead > cchBuffer)
            ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchEndWrite;

        return 0;
    }

    /* write the buffer to disk and stop using the buffer */
    if ((mmr = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
        return mmr;

    if (((PMMIO)hmmio)->dwFlags & MMIO_ALLOCBUF)
    {
        hMem = LocalHandle( ((PMMIO)hmmio)->pchBuffer);
        LocalUnlock( hMem );
        LocalFree( hMem );
        ((PMMIO)hmmio)->dwFlags &= ~MMIO_ALLOCBUF;
    }

    /* Initially, no error. */
    mmr = 0;

    if ((pchBuffer == NULL) && (cchBuffer > 0))
    {
        hMem = LocalAlloc(LMEM_MOVEABLE, cchBuffer);
        if (hMem)
            pchBuffer = LocalLock(hMem);
        //else pchBuffer = NULL;

        /* If there is an error, change the file to be un-buffered
         * and return an error code.  The file is still valid.
         * (Just for a little extra security.)
         */
        if (pchBuffer == NULL)
        {   mmr = MMIOERR_OUTOFMEMORY;
            cchBuffer = 0L;
        }
        else
          ((PMMIO)hmmio)->dwFlags |= MMIO_ALLOCBUF;
    }

    /* invariant: <pchEndRead> points past the end of the "valid" portion
     * of the buffer, and <pchEndWrite> points past the last byte that
     * can be written into; <pchNext> points to the next byte to read
     * or write; <lBufOffset> is the current disk offset of the start
     * of the buffer, and it will not change
     */
    ((PMMIO)hmmio)->pchBuffer = pchBuffer;
    ((PMMIO)hmmio)->cchBuffer = cchBuffer;
    ((PMMIO)hmmio)->pchNext
                     = ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchBuffer;
    ((PMMIO)hmmio)->pchEndWrite = ((PMMIO)hmmio)->pchBuffer + cchBuffer;

    return mmr;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioFlush | This function writes the I/O buffer of a
    file to disk, if the I/O buffer has been written to.

@parm   HMMIO | hmmio | Specifies the file handle of a file opened
    with <f mmioOpen>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

@comm   Closing a file with <f mmioClose> will automatically flush
    its buffer.

    If there is insufficient disk space to write the
    buffer, <f mmioFlush> will fail, even if the preceding <f mmioWrite>
    calls were successful.
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
    mmioFlush(HMMIO hmmio, UINT uFlags)
{
    LONG        lBytesAsk;      // no. bytes to write
    LONG        lBytesWritten;      // no. bytes actually written

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);

    if (  ( ((PMMIO)hmmio)->fccIOProc
          == FOURCC_MEM
          )
       || ( ((PMMIO)hmmio)->pchBuffer == NULL )
       )
        return 0;       // cannot flush memory files

    /* if the file is unbuffered then the dirty flag should not be set */
    if (((PMMIO)hmmio)->dwFlags & MMIO_DIRTY)
    {
        /* figure out how many bytes need to be flushed */
        lBytesAsk = ((PMMIO)hmmio)->pchEndRead - ((PMMIO)hmmio)->pchBuffer;

        /* write the buffer to disk */
        lBytesWritten = mmioDiskIO(((PMMIO)hmmio), MMIOM_WRITEFLUSH,
            ((PMMIO)hmmio)->pchBuffer, lBytesAsk);
        if (lBytesWritten != lBytesAsk)
            return MMIOERR_CANNOTWRITE;
        ((PMMIO)hmmio)->dwFlags &= ~MMIO_DIRTY; // buffer is clean now
    }

    if (uFlags & MMIO_EMPTYBUF)
    {
        /* empty the I/O buffer, and update <lBufOffset> to reflect
         * what the current file position is
         */
        ((PMMIO)hmmio)->lBufOffset
                    += (((PMMIO)hmmio)->pchNext - ((PMMIO)hmmio)->pchBuffer);
        ((PMMIO)hmmio)->pchNext
                    = ((PMMIO)hmmio)->pchEndRead = ((PMMIO)hmmio)->pchBuffer;
    }

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    MMRESULT | mmioAdvance | This function advances the I/O buffer of
    a file set up for direct I/O buffer access with <f mmioGetInfo>. If
    the file is opened for reading, the I/O buffer is filled from the
    disk.  If the file is opened for writing and the MMIO_DIRTY flag is
    set in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure,
    the buffer is written to disk.  The <e MMIOINFO.pchNext>,
    <e MMIOINFO.pchEndRead>, and <e MMIOINFO.pchEndWrite> fields of the
    <t MMIOINFO> structure are updated to reflect the new state of
    the I/O buffer.

@parm   HMMIO | hmmio | Specifies the file handle for a file opened
    with <f mmioOpen>.

@parm   LPMMIOINFO | lpmmioinfo | Optionally specifies a pointer to the
    <t MMIOINFO> structure obtained with <f mmioGetInfo>, which is used to
    set the current file information, then updated after the buffer is
    advanced.

@parm   UINT | uFlags | Specifies options for the operation.
    Contains exactly one of the following two flags:

    @flag   MMIO_READ | The buffer is filled from the file.

    @flag   MMIO_WRITE | The buffer is written to the file.

@rdesc  The return value is zero if the operation is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTREAD | An error occurred while re-filling
    the buffer.

    @flag MMIOERR_UNBUFFERED | The specified file is not opened
    for buffered I/O.

    @flag MMIOERR_CANNOTEXPAND | The specified memory file cannot
    be expanded, probably because the <e MMIOINFO.adwInfo[0]> field
    was set to zero in the initial call to <f mmioOpen>.

    @flag MMIOERR_OUTOFMEMORY | There was not enough memory to expand
    a memory file for further writing.


@comm   If the specified file is opened for writing or for both
    reading and writing, the I/O buffer will be flushed to disk before
    the next buffer is read. If the I/O buffer cannot be written to disk
    because the disk is full, then <f mmioAdvance> will return
    MMIOERR_CANNOTWRITE.

    If the specified file is only open for writing, the MMIO_WRITE
    flag must be specified.

    If you have written to the I/O buffer, you must set the MMIO_DIRTY
    flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure
    before calling <f mmioAdvance>. Otherwise, the buffer will not be
    written to disk.

    If the end of file is reached, <f mmioAdvance> will still return
    success, even though no more data can be read.  Thus, to check for
    the end of the file, it is necessary to see if the
    <e MMIOINFO.pchNext> and <e MMIOINFO.pchEndRead> fields of the
    <t MMIOINFO> structure are equal after calling <f mmioAdvance>.

@xref   mmioGetInfo MMIOINFO
*/
/*--------------------------------------------------------------------*/
MMRESULT APIENTRY
         mmioAdvance(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT uFlags)
{
    LONG        lBytesRead;     // bytes actually read
    UINT        w;

    V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
    if (((PMMIO)hmmio)->pchBuffer == NULL)
        return MMIOERR_UNBUFFERED;
    if (lpmmioinfo != NULL) {
        V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
        mmioSetInfo(hmmio, lpmmioinfo, 0);
    }

    if (((PMMIO)hmmio)->fccIOProc == FOURCC_MEM)
    {
        /* this is a memory file:
         *   -- if the caller is reading, cannot advance
         *   -- if the caller is writing, then advance by expanding
         *      the buffer (if possible) if the there is less than
         *  <adwInfo[0]> bytes left in the buffer
         */
        if (!(uFlags & MMIO_WRITE))
            return MMIOERR_CANNOTREAD;
        if ( (DWORD)(((PMMIO)hmmio)->pchEndWrite - ((PMMIO)hmmio)->pchNext)
           >= ((PMMIO)hmmio)->adwInfo[0]
           )
            return MMIOERR_CANNOTEXPAND;
        if ((w = mmioExpandMemFile(((PMMIO)hmmio), 1L)) != 0)
            return w;   // out of memory, or whatever
        goto GETINFO_AND_EXIT;
    }

    /* empty the I/O buffer, which will effectively advance the
     * buffer by (<pchNext> - <pchBuffer>) bytes
     */
    if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
        return w;

    /* if MMIO_WRITE bit is not set in uFlags, fill the buffer  */
    if (!(uFlags & MMIO_WRITE))
    {
        /* read the next bufferful from the file */
        lBytesRead = mmioDiskIO(((PMMIO)hmmio), MMIOM_READ,
            ((PMMIO)hmmio)->pchBuffer, ((PMMIO)hmmio)->cchBuffer);
        if (lBytesRead == -1)
            return MMIOERR_CANNOTREAD;

        /* reading zero bytes should not be treated as an error
         * condition -- e.g. open a new file R+W and call
         * mmioAdvance(), and MMIOM_READ will return zero bytes
         * because the file started off empty
         */
        ((PMMIO)hmmio)->pchEndRead += lBytesRead;
    }

GETINFO_AND_EXIT:

    /* copy <hmmio> back to <lpmmioinfo> if <lpmmioinfo> is provided */
    if (lpmmioinfo != NULL)
        mmioGetInfo(hmmio, lpmmioinfo, 0);

    return 0;
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    FOURCC | mmioStringToFOURCC | This function converts a
    null-terminated string to a four-character code.

@parm   LPCTSTR | sz | Specifies a pointer to a null-terminated
    string to a four-character code.

@parm   UINT | uFlags | Specifies options for the conversion:

    @flag   MMIO_TOUPPER | Converts all characters to uppercase.

@rdesc  The return value is the four character code created from the
    given string.

@comm   This function does not check to see if the string referenced
    by <p sz> follows any conventions regarding which characters to
    include in a four-character code.  The string is
    simply copied to a four-character code and padded with blanks or
    truncated to four characters if required.

@xref   mmioFOURCC
*/
/*--------------------------------------------------------------------*/
FOURCC APIENTRY mmioStringToFOURCCW( LPCWSTR sz, UINT uFlags )
{

    FOURCC  fcc;
    PBYTE   pByte;  // ascii version of szFileName
    ULONG   cbDst;  // character count of szFileName

    int cchSrc;


//    V_STRING(sz, -1, 0);

    /*------------------------------------------------------------*\
     * Convert the given unicode string into ascii and then call
     * the ascii version of mmioStringToFOURCCW
    \*------------------------------------------------------------*/
    cbDst = ((cchSrc = wcslen( sz )) * sizeof(WCHAR)) + sizeof(WCHAR);
    pByte = HeapAlloc( hHeap, 0, cbDst );
    if ( pByte == (PBYTE)NULL ) {
        return (FOURCC)NULL;
    }

    cbDst = WideCharToMultiByte(GetACP(), 0, sz, cchSrc, pByte, cbDst, NULL, NULL);


    /* Do it ourselves...it's not that hard */
    if (cbDst > 0) {
        int i = sizeof(FOURCC);
        char *pchSrc = pByte, *pchDst = (char *)&fcc;
    
        while (i-- > 0)
            {
            if (*pchSrc)
                {
                if (uFlags & MMIO_TOUPPER)
                    *pchDst++ = (char)CharUpper((LPTSTR)*pchSrc++);
                else
                    *pchDst++ = *pchSrc++;
                }
            else
                *pchDst++ = ' ';
            }
    } else {
        fcc = (FOURCC)NULL;
    }


    HeapFree( hHeap, 0, pByte );
    return (FOURCC)fcc;
}




/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LPMMIOPROC | mmioInstallIOProc | This function installs or
    removes a custom I/O procedure. It will also locate an installed I/O
    procedure, given its corresponding four-character code.

@parm   FOURCC | fccIOProc | Specifies a four-character code
    identifying the I/O procedure to install, remove, or locate. All
    characters in this four-character code should be uppercase characters.

@parm   LPMMIOPROC | pIOProc | Specifies the address of the I/O
    procedure to install. To remove or locate an I/O procedure, set this
    parameter to NULL.

@parm   DWORD | dwFlags | Specifies one of the following flags
    indicating whether the I/O procedure is being installed, removed, or
    located:

    @flag   MMIO_INSTALLPROC | Installs the specified I/O procedure.

    @flag   MMIO_GLOBALPROC | This flag is a modifier to the install flag,
        and indicates the I/O procedure should be installed for global
        use.  This flag is ignored on removal or find.

    @flag   MMIO_REMOVEPROC | Removes the specified I/O procedure.

    @flag   MMIO_FINDPROC | Searches for the specified I/O procedure.

@rdesc  The return value is the address of the I/O procedure
    installed, removed, or located. If there is an error, the return value
    is NULL.

@comm   If the I/O procedure resides in the application, use
    <f MakeProcInstance> for compatibility with 16 bit windows
    to get a procedure-instance address and specify
    this address for <p pIOProc>. You don't need to get a procedure-instance
    address if the I/O procedure resides in a DLL.

@cb LONG FAR PASCAL | IOProc | <f IOProc> is a placeholder for the
    application-supplied function name. The actual name must be exported
    by including it in a EXPORTS statement in the application's
    module-definitions file.

    @parm   LPSTR | lpmmioinfo | Specifies a pointer to an
        <t MMIOINFO> structure containing information about the open
        file.  The I/O procedure must maintain the <e MMIOINFO.lDiskOffset>
        field in this structure to indicate the file offset to the
        next read or write location. The I/O procedure can use the
        <e MMIOINFO.adwInfo[]> field to store state information. The
        I/O procedure should not modify any other fields of the
        <t MMIOINFO> structure.


    @parm   UINT | wMsg | Specifies a message indicating the
        requested I/O operation. Messages that can be received include
        <m MMIOM_OPEN>, <m MMIOM_CLOSE>, <m MMIOM_READ>, <m MMIOM_WRITE>,
        and <m MMIOM_SEEK>.

    @parm   LONG | lParam1 | Specifies a parameter for the message.

    @parm   LONG | lParam2 | Specifies a parameter for the message.

@rdesc  The return value depends on the message specified by
    <p wMsg>. If the I/O procedure does not recognize a message, it should
    return zero.

@comm   The four-character code specified by the
    <e MMIOINFO.fccIOProc> field in the <t MMIOINFO> structure
    associated with a file identifies a filename extension for a custom
    storage system. When an application calls <f mmioOpen> with a
    filename such as "foo.xyz!bar", the I/O procedure associated with the
    four-character code "XYZ " is called to open the "bar" element of the
    file "foo.xyz".

    The <f mmioInstallIOProc> function maintains a separate list of
    installed I/O procedures for each Windows application. Therefore,
    different applications can use the same I/O procedure identifier for
    different I/O procedures without conflict.  Installing an I/O procedure
    globally however enables any process to use the procedure.

    If an application calls <f mmioInstallIOProc> more than once to
    register the same I/O procedure, then it must call
    <f mmioInstallIOProc> to remove the procedure once for each time it
    installed the procedure.

    <f mmioInstallIOProc> will not prevent an application from
    installing two different I/O procedures with the same identifier, or
    installing an I/O procedure with one of the predefined identifiers
    ("DOS ", "MEM "). The most recently installed procedure
    takes precedence, and the most recently installed procedure is the
    first one to get removed.

    When searching for a specified I/O procedure, local procedures are
    searched first, then global procedures.

@xref   mmioOpen
 */

/*--------------------------------------------------------------------*/
LPMMIOPROC APIENTRY
mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{
    V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

    dwFlags |= MMIO_UNICODEPROC;
    return mmioInternalInstallIOProc( fccIOProc, pIOProc, dwFlags);
}

static LPMMIOPROC mmioInternalInstallIOProc(
                     FOURCC      fccIOProc,   // I/O Proc 4 char id
                     LPMMIOPROC  pIOProc,     // pointer to any I/O proc to install
                     DWORD       dwFlags      // flags from caller
                     )
{
    IOProcMapEntry  *pEnt;          // an entry in linked list
    HANDLE          hTaskCurrent;   // current Windows task handle



    if (fccIOProc == 0L)
        return NULL;

    hTaskCurrent = (HANDLE)GetCurrentThreadId();

    if (dwFlags & MMIO_INSTALLPROC)
    {
        /* install I/O procedure -- always add at the beginning of
         * the list, so it overrides any other I/O procedures
         * with the same identifier installed by the same task
         */
        V_CALLBACK((FARPROC)pIOProc, NULL);
        if ((pEnt = (IOProcMapEntry NEAR *)
            NewHandle(TYPE_MMIO, sizeof(IOProcMapEntry))) == NULL)
                return NULL;        // out of memory
        pEnt->fccIOProc = fccIOProc;
        pEnt->pIOProc = pIOProc;
        pEnt->hTask = hTaskCurrent;
        pEnt->pNext = gIOProcMapHead;
        gIOProcMapHead = pEnt;


        return pIOProc;
    }

    if (!pIOProc)
        if (dwFlags & MMIO_REMOVEPROC)
            return RemoveIOProc(fccIOProc, hTaskCurrent);
        else if (dwFlags & MMIO_FINDPROC)
        {   pIOProcMapEntry pEnt;
            pEnt = FindIOProc(fccIOProc, hTaskCurrent);
            return ( pEnt==NULL
                   ? NULL
                   : pEnt->pIOProc
                   );
        }
    return NULL;        // couldn't find requested I/O procedure
}


/*--------------------------------------------------------------------*/
/* @doc EXTERNAL

@api    LRESULT | mmioSendMessage | This function sends a message to the
    I/O procedure associated with the specified file.

@parm   HMMIO | hmmio | Specifies the file handle for a file opened
    with <f mmioOpen>.

@parm   UINT | wMsg | Specifies the message to send to the I/O procedure.

@parm   LONG | lParam1 | Specifies a parameter for the message.

@parm   LONG | lParam2 | Specifies a parameter for the message.

@rdesc  The return value depends on the message. If the I/O procedure
    does not recognize the message, the return value is zero.

@comm   Use this function to send custom user-defined messages. Do
    not use it to send the <m MMIOM_OPEN>, <m MMIOM_CLOSE>,
    <m MMIOM_READ>, <m MMIOM_WRITE>, <m MMIOM_WRITEFLUSH>, or
    <m MMIOM_SEEK> messages. Define
    custom messages to be greater than or equal to the MMIOM_USER constant.

@xref   mmioInstallIOProc
*/
/*--------------------------------------------------------------------*/
LRESULT APIENTRY
mmioSendMessage(HMMIO hmmio, UINT uMsg, LONG lParam1, LONG lParam2)
{
    V_HANDLE(hmmio, TYPE_MMIO, (LRESULT)0);
    return IOProc( (PMMIO)hmmio, uMsg, lParam1, lParam2);
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LONG | mmioDiskIO | Perform an unbuffered read or write.
    Do not assume where the current disk offset <p lDiskOffset> will be.

@parm   PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm   UINT | wMsg | MMIOM_READ if <f mmioDiskIO> should read from the disk,
    or MMIOM_WRITE if <f mmioDiskIO> should write to the disk,
    or MMIOM_WRITEFLUSH if <f mmioDiskIO> should flush all pending I/O.

@parm   LPSTR | pch | The buffer to read into or write from.

@parm   LONG | cch | The number of bytes to read or write.

    <f mmioDiskIO> changes the disk offset to be <p lBufOffset>
    and then performs an MMIOM_READ or MMIOM_WRITE operation as
    specified by <p wMsg>, <p pch>, and <p cch>.

    Note that if the I/O buffer is not empty at this point, this
    function may not do what you expect.

    Do not call this function for memory files.
*/
/*--------------------------------------------------------------------*/
static LONG NEAR PASCAL
mmioDiskIO(PMMIO pmmio, UINT uMsg, LPSTR pch, LONG cch)
{
    if (pmmio->lDiskOffset != pmmio->lBufOffset)
    {
        if (IOProc( pmmio
                  , MMIOM_SEEK
                  , (LONG) pmmio->lBufOffset
                  , (LONG) SEEK_SET
                  )
           == -1
           )
            return -1;
    }

    return IOProc( pmmio, uMsg, (LONG) pch, (LONG) cch);
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    UINT | mmioExpandMemFile | Assuming that <p pmmio> is a memory file,
    expand it by <p lExpand> bytes or <p adwInfo[0]> bytes, whichever
    is larger.  Do not disturb the contents of the buffer or change
    the current file position.

@parm   PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm   LONG | lExpand | The minimum number of bytes to expand the buffer by.

@rdesc  If the function succeeds, zero is returned.  If the function fails,
    an error code is returned.  In particular, MMIOERR_OUTOFMEMORY is
    returned if memory reallocation failed.

@comm   Only call this function for memory files.
*/
/*--------------------------------------------------------------------*/
static UINT NEAR PASCAL
mmioExpandMemFile(PMMIO pmmio, LONG lExpand)
{
    MMIOMEMINFO *   pInfo = (MMIOMEMINFO *) pmmio->adwInfo;
    DWORD       dwFlagsTemp;
    UINT        w;

    /* make sure buffer can be expanded */
    /* Note: we used to check ALLOC_BUF here, we don't now. */
    if (pInfo->lExpand == 0)
        return MMIOERR_CANNOTEXPAND;    // cannot grow file

    /* how much should the buffer be expanded by? */
    if (lExpand < pInfo->lExpand)
        lExpand = pInfo->lExpand;

    dwFlagsTemp = pmmio->dwFlags;
    pmmio->dwFlags |= MMIO_ALLOCBUF;
    w = mmioSetBuffer(((HMMIO)pmmio), NULL,
                     pmmio->cchBuffer + lExpand, 0);
    pmmio->dwFlags = dwFlagsTemp;
    return w;
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LRESULT | mmioDOSIOProc | The 'DOS' I/O procedure, which handles I/O
    on ordinary DOS files.

@parm   LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
    contains information about the open file.

@parm   UINT | uMsg | The message that the I/O procedure is being
    asked to execute.

@parm   LONG | lParam1 | Specifies additional message information.

@parm   LONG | lParam2 | Specifies additional message information.

@rdesc  Return value depends on <p wMsg>.
*/
/*--------------------------------------------------------------------*/
LRESULT
     mmioDOSIOProc(LPSTR lpmmioStr, UINT uMsg, LONG lParam1, LONG lParam2)
{
    PMMIO       pmmio  = (PMMIO)lpmmioStr;              // only in DLL!
    MMIODOSINFO *pInfo = (MMIODOSINFO *)pmmio->adwInfo;
    LONG        lResult;

    WCHAR       szPath[ MAX_PATH ];

    switch (uMsg) {

    case MMIOM_OPEN:
        /*
         * The extra info parameter optionally contains a
         * sequence number to pass.
         */
        if ( pmmio->dwFlags & MMIO_GETTEMP )
        {

            DEBUGMSG(1, (TEXT("Temp files not supported under UNDER_CE!")));
            return (LRESULT)MMIOERR_FILENOTFOUND;

        }


        /*------------------------------------------------------------*\
         * <lParam1> is either a file name or NULL; if it is
         * NULL, then <adwInfo[0]>, which is actually <pInfo->fh>,
         * should already contain an open DOS file handle.
         *
         * Does lParam1 point to a file name ?
         *
         * if so then either:
         *
         *  delete the file,
         *  check the existance of the file,
         *  parse the file name, or
         *  open the file name
         *
        \*------------------------------------------------------------*/
        if ( lParam1 != 0 ) {

            if ( pmmio->dwFlags & MMIO_DELETE ) {

                return DeleteFileW( (LPWSTR)lParam1 )
                       ? (LRESULT)0
                       : (LRESULT)MMIOERR_FILENOTFOUND;
            }

            if ( pmmio->dwFlags & MMIO_EXIST ) {
                if ( !(pmmio->dwFlags & MMIO_CREATE) ) {
#ifdef LATER
      I think this should be using SearchPath (with lpszPath==lParam1)
      as the definition of MMIO_EXIST states that a fully qualified
      filename is returned.  OR tweak the flags to turn MMIO_PARSE ON
      and execute the next section.
#endif
                    if ( GetFileAttributesW( (LPWSTR)lParam1 ) == -1 ) {
                        return (LRESULT)MMIOERR_FILENOTFOUND;
                    }
                    return (LRESULT)0;
                }
            }

            if ( pmmio->dwFlags & MMIO_PARSE ) {
                DEBUGMSG(1, (TEXT("Filename parsing not supported under UNDER_CE!")));
                return (LRESULT)MMIOERR_FILENOTFOUND;
            }

            {
                DWORD   dwAccess        = 0;
                DWORD   dwSharedMode    = 0;
                DWORD   dwCreate        = 0;
                DWORD   dwFlags         = FILE_ATTRIBUTE_NORMAL;

                /*----------------------------------------------------*\
                 * Look at the access flags
                \*----------------------------------------------------*/
                if ( pmmio->dwFlags & MMIO_WRITE ) {
                    dwAccess = GENERIC_WRITE;
                } else {
                    dwAccess = GENERIC_READ;
                }

                if ( pmmio->dwFlags & MMIO_READWRITE ) {
                    dwAccess |= (GENERIC_WRITE | GENERIC_READ);
                }

                /*----------------------------------------------------*\
                 * Set dwSharedMode from the share flags
                \*----------------------------------------------------*/

                {   /* owing to some crappy design in WIN3.1, the share flags are
                    *  exclusive  = 10
                    *  deny write = 20
                    *  deny read  = 30
                    *  deny none  = 40
                    *  so deny read looks like exclusive + deny write.  Sigh.
                    *  00 is taken as being DENYNONE (probably correct)
                    *  So is 50, 60 and 70 (which is probably bogus).
                    *  As we need to support the DOS flags for WOW, we need this
                    *  code somewhere, so might as well leave the flag definitions
                    *  as they are.  First pull out all the share mode bits.
                    */
                    DWORD dwShare = MMIO_DENYWRITE | MMIO_DENYREAD
                                  | MMIO_DENYNONE | MMIO_EXCLUSIVE;
                    dwShare &= pmmio->dwFlags;

                    switch (dwShare)
                    {   case MMIO_DENYWRITE:
                           dwSharedMode = FILE_SHARE_READ;
                        break;
                        case MMIO_DENYREAD:
                           dwSharedMode = FILE_SHARE_WRITE;
                        break;
                        case MMIO_EXCLUSIVE:
                           dwSharedMode = 0;
                        break;
                        case MMIO_DENYNONE:
                        default:
                           dwSharedMode = FILE_SHARE_WRITE | FILE_SHARE_READ;
                        break;
#ifdef later
   Generate an error for invalid flags?
#endif
                    }
                }

                /*----------------------------------------------------*\
                 * Look at the create flags
                \*----------------------------------------------------*/
                if ( (pmmio->dwFlags) & MMIO_CREATE) {
                    dwCreate = CREATE_ALWAYS;
                    wcscpy( szPath, (LPWSTR)lParam1 );

                } else {
                    dwCreate = OPEN_EXISTING;

                    /* Under UNDER_CE, better specify the correct filename */
                    wcscpy(szPath, (LPWSTR)lParam1);

                }

                pInfo->fh = CreateFileW( szPath,
                                              dwAccess,
                                              dwSharedMode,
                                              NULL,
                                              dwCreate,
                                              dwFlags /*| FILE_FLAG_SEQUENTIAL_SCAN*/,
                                              NULL );

                if ( pInfo->fh == INVALID_HANDLE_VALUE ) {
                    return (LRESULT)MMIOERR_FILENOTFOUND;
                }

                if ( pmmio->dwFlags & MMIO_EXIST ) {
                    CloseHandle( (HANDLE)pInfo->fh );
                    return (LRESULT)0;
                }

            }

        }
        /* check the current file offset */
        pmmio->lDiskOffset = SetFilePointer(pInfo->fh, 0L, NULL, FILE_CURRENT);
        return (LRESULT)0;

    case MMIOM_CLOSE:
        /* MMIO_FHOPEN flag means keep the DOS file handle open */
        if (  !((DWORD)lParam1 & MMIO_FHOPEN)
           && (CloseHandle(pInfo->fh) == HFILE_ERROR) ) {

            return (LRESULT) MMIOERR_CANNOTCLOSE;
        }
        return (LRESULT) 0;

    case MMIOM_READ:
        if (ReadFile(pInfo->fh, (LPVOID)lParam1, (DWORD)lParam2, &lResult, NULL) && lResult > 0) {
            pmmio->lDiskOffset += lResult;
            return (LRESULT) lResult;
        } else
            return (LRESULT) HFILE_ERROR;

    case MMIOM_WRITE:
    case MMIOM_WRITEFLUSH:

        if (WriteFile(pInfo->fh, (LPVOID)lParam1, (DWORD)lParam2, &lResult, NULL) && lResult > 0) {
            pmmio->lDiskOffset += lResult;
            return (LRESULT) lResult;
        }

#ifdef DOSCANFLUSH
        if (uMsg == MMIOM_WRITEFLUSH)
        {
            /* Issue hardware flush command */
        }
#endif
        return (LRESULT) HFILE_ERROR;

    case MMIOM_SEEK:
        lResult = SetFilePointer(pInfo->fh, (LONG)lParam1, NULL, (int)(LONG)lParam2);
        if (lResult != -1L) {
            pmmio->lDiskOffset = lResult;
        }
        return (LRESULT) lResult;

    case MMIOM_RENAME:
        if (!MoveFileW((LPWSTR)lParam1, (LPWSTR)lParam2)) {
            return (LRESULT) MMIOERR_FILENOTFOUND;
            /* ??? There are other errors too? e.g. target exists? */
        }
        break;

    }

    return (LRESULT) 0;
}


/*--------------------------------------------------------------------*/
/* @doc INTERNAL

@api    LRESULT | mmioMEMIOProc | The 'MEM' I/O procedure, which handles I/O
    on memory files.

@parm   LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
    contains information about the open file.

@parm   UINT | uMsg | The message that the I/O procedure is being
    asked to execute.

@parm   LONG | lParam1 | Specifies additional message information.

@parm   LONG | lParam2 | Specifies additional message information.

@rdesc  Return value depends on <p uMsg>.
*/
/*--------------------------------------------------------------------*/
LRESULT
      mmioMEMIOProc(LPSTR lpmmioStr, UINT uMsg, LONG lParam1, LONG lParam2)
{
    PMMIO       pmmio = (PMMIO) lpmmioStr; // only in DLL!

    switch (uMsg)
    {

        case MMIOM_OPEN:

        if ( pmmio->dwFlags
           & ~(MMIO_CREATE
              | MMIO_READWRITE
              | MMIO_WRITE
              | MMIO_EXCLUSIVE
              | MMIO_DENYWRITE
              | MMIO_DENYREAD
              | MMIO_DENYNONE
              | MMIO_ALLOCBUF
              )
           )
            return (LRESULT) MMSYSERR_INVALFLAG;

        /* all the data in the buffer is valid */
        if (!(pmmio->dwFlags & MMIO_CREATE))
            pmmio->pchEndRead = pmmio->pchEndWrite;
        return (LRESULT) 0;

    case MMIOM_CLOSE:

        /* nothing special to do on close */
        return (LRESULT) 0;

    case MMIOM_READ:
    case MMIOM_WRITE:
    case MMIOM_WRITEFLUSH:
    case MMIOM_SEEK:
                return (LRESULT) -1;
    }

    return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\mmio\mmio.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:mmsystem.h -- Include file for Multimedia API's  

 *    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *      MMNOSOUND       Sound support
 *      MMNOWAVE        Waveform support
 *
 */

#ifndef _INC_MMIO
#define _INC_MMIO   // to prevent multiple inclusion of mmsystem.h

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif  // __cplusplus


#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
        ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
        ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))

#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

extern HANDLE hHeap;
//extern PHNDL pHandleList;
extern CRITICAL_SECTION HandleListCritSec;

#ifndef MMNOMMIO
/****************************************************************************

            Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef LPSTR           HPSTR;         /* a huge str pointer (old) */
typedef DWORD           FOURCC;         /* a four character code */
//DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
    /* general fields */
    DWORD           dwFlags;        /* general status flags */
    FOURCC          fccIOProc;      /* pointer to I/O procedure */
    LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
    UINT            wErrorRet;      /* place for error to be returned */
    HTASK           htask;          /* alternate local task */

    /* fields maintained by MMIO functions during buffered I/O */
    LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
    LPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
    LPSTR           pchNext;        /* pointer to next byte to read/write */
    LPSTR           pchEndRead;     /* pointer to last valid byte to read */
    LPSTR           pchEndWrite;    /* pointer to last byte to write */
    LONG            lBufOffset;     /* disk offset of start of buffer */

    /* fields maintained by I/O procedure */
    LONG            lDiskOffset;    /* disk offset of next read or write */
    DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

    /* other fields maintained by MMIO */
    DWORD           dwReserved1;    /* reserved for MMIO use */
    DWORD           dwReserved2;    /* reserved for MMIO use */
    HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;
typedef const MMIOINFO FAR *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
    FOURCC          ckid;           /* chunk ID */
    DWORD           cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    DWORD           dwDataOffset;   /* offset of data portion of chunk */
    DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_UNICODEPROC    0x01000000  /* mmioInstallIOProc: Unicode MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */
#define MMIOM_RENAME            6       /* rename specified file */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

/* MMIO function prototypes */
FOURCC      WINAPI mmioStringToFOURCC(LPCTSTR sz, UINT uFlags);
LPMMIOPROC  WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO       WINAPI mmioOpen(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
MMRESULT    WINAPI mmioRename(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);

MMRESULT    WINAPI mmioClose(       HMMIO hmmio, UINT fuClose);
LONG        WINAPI mmioRead(        HMMIO hmmio, LPSTR pch, LONG cch);
LONG        WINAPI mmioWrite(       HMMIO hmmio, LPCSTR pch, LONG cch);
LONG        WINAPI mmioSeek(        HMMIO hmmio, LONG lOffset, int iOrigin);
MMRESULT    WINAPI mmioGetInfo(     HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
MMRESULT    WINAPI mmioSetInfo(     HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
MMRESULT    WINAPI mmioSetBuffer(   HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer);
MMRESULT    WINAPI mmioFlush(       HMMIO hmmio, UINT fuFlush);
MMRESULT    WINAPI mmioAdvance(     HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
LRESULT     WINAPI mmioSendMessage( HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
MMRESULT    WINAPI mmioDescend(     HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
MMRESULT    WINAPI mmioAscend(      HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
MMRESULT    WINAPI mmioCreateChunk( HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef MMNOMMIO */




#ifdef __cplusplus
}                       // End of extern "C" {
#endif  // __cplusplus

#include "poppack.h"        /* Revert to default packing */



#endif // _INC_MMSYSTEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\webupdate\webupdate.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <tchar.h>
#include <ctype.h>
#include <spdebug.h>
#include <sphelper.h>

#define TEST   (0)
#define HEADERSRC "\\\\b11nlbuilds\\sapi5\\"
#define BUILDDEST "\\\\b11nlbuilds\\sapi5\\"
#if TEST
#define TESTDEST "c:\\"
#else
#define TESTDEST "\\\\b11nlbuilds\\sapi5\\"
#endif
const int c_NoLog = -202;
const int c_Toast = -201;

struct FILETOCOPY
{
    char *  szRelativePath;
    char *  szDescription;
    char *  szColor;
};

FILETOCOPY g_aSAPIfiles[] =
                        {
                            {"release\\msi\\x86\\setup.exe", "Install SDK", "#00fefe"},
                            {"release\\msm\\x86", "Retail Merge Module drop directory", "#00fefe"},
                            {"debug\\msi\\x86\\setup.exe", "Install SDK", "#aaaaaa"},
                            {"debug\\msm\\x86", "Debug Merge Module drop directory", "#aaaaaa"},
                        };

FILETOCOPY g_aSRfiles[] =
                        {
//                            {"release\\cab\\x86\\mscsr5.EXE", "SAPI5", "#aaaaaa"},
//                            {"debug\\cab\\x86\\mscsr5.EXE", "SAPI5", "#ffff00"},
                            {"srd1033.EXE", "English", "#aaaaaa"},
                            {"srd1041.EXE", "Japanese", "#aaaaaa"},
                        };

#define DIM(a) (sizeof(a)/sizeof(a[0]))

int ParseBVTLogfile( CHAR* pszBuildNumber, CHAR* pszFileName , DWORD* pcTotal);

void PrintToFile(HANDLE hFile, char * szFormat, ...)
{
    DWORD dw;
    char buf[2048];

    va_list vl;
    va_start(vl, szFormat);
    int i = _vsnprintf(buf, 2048, szFormat, vl);
    va_end(vl);

    WriteFile(hFile, buf, i, &dw, NULL);
}


char * GetFileText(char * szFileName, DWORD * pdwSize)
{
    HANDLE  hFile;
    CHAR *  pbuff = NULL;
    DWORD   dwSize;

    hFile = CreateFile( szFileName, GENERIC_READ,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
        return NULL;

    dwSize = GetFileSize( hFile, NULL );
    if( dwSize == 0xffffffff )
        return NULL;

    pbuff = new CHAR [dwSize];
    if (pbuff)
        ReadFile( hFile, pbuff, dwSize, &dwSize, NULL );

    CloseHandle( hFile );

    if(pdwSize) *pdwSize = dwSize;
    return pbuff;
}

void cryAndDie(char* szError, unsigned short errCode)
{
	printf("Fatal : %s\n", szError);
	printf("Exiting ...\n");
	exit(errCode);
}


int main(void)
{
    HANDLE hFile, hFileSR, hExistingFile, hDir;
    CHAR *pbuff = NULL, szRoot[MAX_PATH], *pdirs, delBuff[MAX_PATH];
    DWORD dwSize, i, dw;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    // First create the SAPI file.
    // open file that contains the html template
    pbuff = GetFileText(HEADERSRC "Web.Files\\header.html", &dwSize);
    if( pbuff == NULL )
	{
		cryAndDie("Could not open Web.Files\\header.html", 1);
	}

    // Open the output file, write the header
    hFile = CreateFile( TESTDEST "Web.Files\\x86build.html",
        GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if( hFile != INVALID_HANDLE_VALUE )
    {
        WriteFile( hFile, pbuff, dwSize, &dw, NULL );
    }
    else
    {

        LPVOID lpMsgBuf;
        FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER |  FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf, 0, NULL );
        // Process any inserts in lpMsgBuf.
        // ...
        // Display the string.
        printf("ERROR: ");
        printf((LPTSTR) lpMsgBuf);
        printf("\n");
        // Free the buffer.
        LocalFree( lpMsgBuf );
        
        sprintf((LPTSTR) &lpMsgBuf,"Could not open %sWeb.Files\\x86build.html", TESTDEST);
        cryAndDie((LPTSTR)&lpMsgBuf, 1);
    }
    delete pbuff;

    // Now generate the SR file
    // open file that contains the html template
    pbuff = GetFileText(HEADERSRC "Web.Files\\SRheader.html", &dwSize);
    if( pbuff == NULL )
	{
		cryAndDie("Could not open Web.Files\\SRheader.html", 1);
	}

    // Write the header
    hFileSR = CreateFile( TESTDEST "Web.Files\\x86SRbld.html",
        GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if( hFileSR != INVALID_HANDLE_VALUE )
    {
        WriteFile( hFileSR, pbuff, dwSize, &dw, NULL );
    }
    else
    {
		cryAndDie("Could create file Web.Files\\x86SRbld.html", 1);
    }

    // Set registry key to ignore asserts for BVT testing (if necessary of course)
    DWORD dwFlags;
    DWORD dwSizeRet = sizeof(dwFlags);
    HKEY hkResult;
    if( RegOpenKeyEx( HKEY_CLASSES_ROOT, _T("SPDebugFlags"), 0,
        KEY_READ | KEY_SET_VALUE, &hkResult ) == ERROR_SUCCESS )
    {
        if( RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, 
            (PBYTE)&dwFlags, &dwSizeRet ) == ERROR_SUCCESS )
        {
            if( !(dwFlags & SPDBG_NOASSERTS) )
            {
                dwFlags |= SPDBG_NOASSERTS;
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&dwFlags, sizeof(dwFlags) );
            }
        }
        RegCloseKey( hkResult );
    }

    // Get a list of the currently-available builds.
    system( "dir /b /o-n " BUILDDEST "*. > dirs.txt" );
    pdirs = GetFileText("dirs.txt", &dwSize);
    if( pdirs==NULL )
	{
		cryAndDie("Could not open dirs.txt", 1);
	}

    CHAR *pTmp, *pEnd = pdirs + dwSize;
    int count = 0;

    strcpy( szRoot, BUILDDEST );
    int cchRoot = strlen(szRoot);

    // For each build...
    do
    {
        pTmp = szRoot + cchRoot;
        while( *pdirs != 13 )
        {
            *pTmp++ = *pdirs++;
        }
        *pTmp = 0;
        pdirs += 2;

        // Make sure there are no more than 10 builds in this directory.
        if( (++count > 10) && isdigit(szRoot[cchRoot]) )
        {
            i = sprintf( delBuff, "del /F /Q %s", szRoot );
            delBuff[i] = '\0';
            system( delBuff );
            continue;
        }

        hDir = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
        if( hDir != INVALID_HANDLE_VALUE )
        {
            if( GetFileInformationByHandle( hDir, &FileInfo ) )
            {
                // Write date
                if( FileTimeToLocalFileTime( &FileInfo.ftCreationTime, &FileTime ) )
                {
                    if( FileTimeToSystemTime( &FileTime, &SystemTime ) )
                    {
                        PrintToFile( hFile, "<TR>\x0d\x0a        <TD ><FONT FACE=Arial ><B>%02d/%02d/%02d</B>\x0d\x0a", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear % 100 );
                        PrintToFile( hFileSR, "<TR>\x0d\x0a        <TD ><FONT FACE=Arial ><B>%02d/%02d/%02d</B>\x0d\x0a", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear % 100 );
                    }
                }
            }
            CloseHandle( hDir );
        }
        else
        {
			CHAR pszErr[256];
			strcpy(pszErr, "Could not open ");
			strcat(pszErr, szRoot);
			cryAndDie(pszErr, 1);
        }

        // Write status line
        CHAR szFileName[MAX_PATH] = BUILDDEST;
        DWORD cTotal;
        int iBVTResult = ParseBVTLogfile( &szRoot[cchRoot], szFileName, &cTotal);

        if( iBVTResult  == c_NoLog )
        {
            PrintToFile( hFile, "        <TD ><FONT FACE=Arial ><CENTER><B>No Log</B></CENTER>\x0d\x0a" );
        }
        else if( iBVTResult  == c_Toast )
        {
            PrintToFile( hFile, "        <TD ><FONT FACE=Arial ><CENTER><B>Toast</B></CENTER>\x0d\x0a" );
        }
/*        else if ( iBVTResult <= 0 ) // Negative passed% of existing suites.  Some suite(s) missing.
        {
            PrintToFile( hFile, "        <TD ><FONT FACE=Arial ><CENTER><B><A HREF=\"%s\"> %d (Partial)</A></B></CENTER>\x0d\x0a", szFileName, -iBVTResult);
        }*/
        else
        {
            PrintToFile( hFile, "        <TD ><FONT FACE=Arial ><CENTER><B><A HREF=\"%s\">%d%% of %d</A></B></CENTER>\x0d\x0a", szFileName, iBVTResult , cTotal);
        }
        PrintToFile( hFileSR, "        <TD ><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a" );

        // Write Build number
        strcpy( szFileName, "\\\\b11nlbuilds\\sapi5\\Web.Files\\logs\\BuildAll\\BuildAllx86");
        strcat( szFileName, &szRoot[cchRoot] );
        strcat( szFileName, ".html" );
        PrintToFile( hFile, "        <TD ><CENTER><B><A HREF=\"%s\">%s</A></B></CENTER>\n", szFileName, &szRoot[cchRoot] );
        PrintToFile( hFileSR, "        <TD ><CENTER><B>%s</B></CENTER>\n", &szRoot[cchRoot] );

        *pTmp++ = '\\';

        // Write SAPI builds
        for (int j = 0; j < DIM(g_aSAPIfiles); ++j)
        {
            PrintToFile(hFile, "        <TD BGCOLOR=\"%s\"><FONT FACE=Arial >", g_aSAPIfiles[j].szColor);
            strcpy( &szRoot[cchRoot + 5], g_aSAPIfiles[j].szRelativePath );
            
            // Create link to merge module directory
            if( !strcmp( "release\\msm\\x86", g_aSAPIfiles[j].szRelativePath) || 
                !strcmp( "debug\\msm\\x86", g_aSAPIfiles[j].szRelativePath) )
            {
                PrintToFile( hFile, "<A HREF=\"FILE://%s\"><B>%s</B></A>", szRoot, g_aSAPIfiles[j].szDescription );
            }
            // Create link to msi file
            else
            {
                hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                if( hExistingFile != INVALID_HANDLE_VALUE )
                {
                    PrintToFile( hFile, "<A HREF=\"FILE://%s\"><B>%s</B></A>", szRoot, g_aSAPIfiles[j].szDescription );
                    CloseHandle( hExistingFile );
                }
                else
                {
                    PrintToFile( hFile, "<CENTER><B>N/A</B></CENTER>" );
                }
            }

            PrintToFile(hFile, "\x0d\x0a");
        }

        // Write SR builds.
        for (j = 0; j < DIM(g_aSRfiles); ++j)
        {
            PrintToFile(hFileSR, "        <TD BGCOLOR=\"%s\"><FONT FACE=Arial >", g_aSRfiles[j].szColor);
            
            strcpy( &szRoot[cchRoot + 5], g_aSRfiles[j].szRelativePath );
            hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
            if( hExistingFile != INVALID_HANDLE_VALUE )
            {
                PrintToFile( hFileSR, "<A HREF=FILE://%s><B>%s</B></A>", szRoot, g_aSRfiles[j].szDescription );
                CloseHandle( hExistingFile );
            }
            else
            {
                PrintToFile( hFileSR, "<CENTER><B>N/A</B></CENTER>" );
            }

            PrintToFile(hFileSR, "\x0d\x0a");
        }

    } while( pdirs < pEnd );

    system( "del dirs.txt" );

    PrintToFile( hFile, "</TABLE>\x0d\x0a<BR>\x0d\x0a\x0d\x0a</CENTER>\x0d\x0a</BODY></HTML>\x0d\x0a" );
    CloseHandle( hFile );
    PrintToFile( hFileSR, "</TABLE>\x0d\x0a<BR>\x0d\x0a\x0d\x0a</CENTER>\x0d\x0a</BODY></HTML>\x0d\x0a" );
    CloseHandle( hFileSR );

    return 0;
}

// Text parsing function which returns a DWORD indicating the percentage of BVT tests that
// passed. This function returns c_Toast or c_NoLog upon failure.
int ParseBVTLogfile( CHAR* pszBuildNumber, CHAR* pszFileName , DWORD* pcTotal ) // output filename
{
//    bool fDllMissing = false;
    DWORD cCrashed = 0, cPassed = 0, cSkipped = 0, cOther = 0;
    *pcTotal = 0;

    strcpy( pszFileName, BUILDDEST );
    strcat( pszFileName, pszBuildNumber );
    strcat( pszFileName, "\\release\\bvt\\x86\\bvtresults" );
    strcat( pszFileName, pszBuildNumber );
    strcat( pszFileName, ".txt" );
   
    CHAR* pszFileText = GetFileText(pszFileName, NULL);
    if(pszFileText == NULL)
    {
        pszFileName[0] = '\0';
        return c_NoLog;
    }
    _strupr(pszFileText);
/*
    const char* apszDllName[] = 
    {
        "ambvt.dll",
        "cfgengbvt.dll",
        "gramcompbvt.dll",
        "lexbvt.dll",
        "rmbvt.dll",
        "srbvt.dll",
        "ttsbvt.dll",
    };

    for(int i = 0; i < sizeof(apszDllName) / sizeof(apszDllName[0]); i++)
    {
        char szDllName[64];
        strcpy(szDllName, apszDllName[i]);
        if(strstr(pszFileText, _strupr(szDllName)) == NULL)
        {
            fDllMissing = true;
            break;
        }
    }
*/
    const char* cpszBeginCase = "BEGIN TEST:";
    const char* cpszEndCase = "END TEST:";
    CHAR* pCur;

    // Assume srengbvt runs last.  Truncate it's results.
    // TODO
    // pCur = strstr(pCur, "srengbvt.dll");
    // if(pCur) *pCur = 0;

    CHAR* pNext = NULL;
    for(pCur = strstr(pszFileText, cpszBeginCase); pCur; pCur = pNext)
    {
        pCur++;
        pNext = strstr(pCur, cpszBeginCase);
        if(pNext) *pNext = 0;

        if(strstr(pCur, "SRENGBVT.DLL")) continue;
        (*pcTotal)++;

        pCur = strstr(pCur, cpszEndCase);
        if(pCur == NULL)
        {
            cCrashed++;
            continue;
        }

        CHAR* pTemp = strstr(pCur, "TIME=");
        if(pTemp)
        {
            *pTemp = 0; // avoid accidental result
        }
        else
        {
            return c_Toast; // should never happen!
        }

        if(strstr(pCur, " PASSED, "))
        {
            cPassed++;
        }
        else if(strstr(pCur, " SKIPPED, "))
        {
            cSkipped++;
        }
        else
        {
            cOther++;
        }
    }

//    return *pcTotal ? int((fDllMissing ? -100.0 : 100.0) * cPassed / (*pcTotal - cSkipped)) : c_Toast;
    return (*pcTotal) ? int(100.0 * cPassed / ((*pcTotal) - cSkipped)) : c_Toast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\build\webupdate\webupdatea.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <tchar.h>
#include <ctype.h>

int main(void)
{
    HANDLE hFile, hFindFile, hExistingFile, hDir;
    CHAR *pbuff = NULL, szHtmlLine[MAX_PATH], szRoot[MAX_PATH], szDate[9], *pdirs, *pDirsTmp, delBuff[MAX_PATH];
    DWORD dwSize, i, dw;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    // open file that contains the list of files to process
    hFile = CreateFile( "\\\\iitdev\\builds\\sapi5\\Web.Files\\headera.html", GENERIC_READ,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY, NULL );
    if( hFile != INVALID_HANDLE_VALUE )
    {
        dwSize = GetFileSize( hFile, NULL );
        if( dwSize != 0xffffff )
        {
            pbuff = new CHAR [dwSize];
        }

        if( pbuff )
        {
            // read the .html header
            ReadFile( hFile, pbuff, dwSize, &dw, NULL );
            CloseHandle( hFile );

            hFile = CreateFile( "\\\\iitdev\\builds\\sapi5\\Web.Files\\alphabuild.html",
                GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

            if( hFile != INVALID_HANDLE_VALUE )
            {
                WriteFile( hFile, pbuff, dwSize, &dw, NULL );
            }
            else
            {
                return -1;
            }

            system( "dir /b /o-d \\\\iitdev\\builds\\sapi5\\*. > dirs.txt" );

            hFindFile = CreateFile( _T("dirs.txt"), GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

            if( hFindFile != INVALID_HANDLE_VALUE )
            {
                dwSize = GetFileSize( hFindFile, NULL );
                if( dwSize != 0xffffff )
                {
                    pdirs = new CHAR [dwSize];
                }

                if( pdirs )
                {
                    pDirsTmp = pdirs;
                    ReadFile( hFindFile, pdirs, dwSize, &dw, NULL );
                    CloseHandle( hFindFile );
                }
                else
                {
                    return -1;
                }

                CHAR *pTmp, *pEnd = pdirs + dwSize;
                int count = 0;

                strcpy( szRoot, "\\\\iitdev\\builds\\sapi5\\" );
                do
                {
                    pTmp = szRoot + 22;
                    while( *pdirs != 13 )
                    {
                        *pTmp++ = *pdirs++;
                    }
                    *pTmp = 0;
                    pdirs += 2;

                    if( (++count > 10) && isdigit(szRoot[22]) )
                    {
                        i = sprintf( delBuff, "del /F /Q %s", szRoot );
                        delBuff[i] = '\0';
                        system( delBuff );
                        continue;
                    }

                    hDir = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
                    if( hDir != INVALID_HANDLE_VALUE )
                    {
                        if( GetFileInformationByHandle( hDir, &FileInfo ) )
                        {
                            // Write date
                            if( FileTimeToLocalFileTime( &FileInfo.ftCreationTime, &FileTime ) )
                            {
                                if( FileTimeToSystemTime( &FileTime, &SystemTime ) )
                                {
                                    sprintf( szDate, "%02d/%02d/%02d", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear % 100 );
                                    i = sprintf( szHtmlLine, "<TR>\x0d\x0a        <TD ><FONT FACE=Arial ><B>%s</B>\x0d\x0a", szDate );
                                    WriteFile( hFile, szHtmlLine, i, &dw, NULL );
                                }
                            }
                        }
                        CloseHandle( hDir );
                    }
                    else
                    {
                        return -1;
                    }

                    // Write status line
                    WriteFile( hFile, "        <TD ><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a", 60, &dw, NULL );

                    // Write Build number
                    i = sprintf(szHtmlLine,"        <TD ><CENTER><B>%s</B></CENTER>\n", &szRoot[22] );
                    WriteFile( hFile, szHtmlLine, i, &dw, NULL );

                    // check for existence of the SAPI5 runtime and fill table entry
                    strcpy( &szRoot[26], "\\release\\cab\\alpha\\sapi5.EXE" );
                    szRoot[54] = '\0';
                    hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                    if( hExistingFile != INVALID_HANDLE_VALUE )
                    {
                        i = sprintf( szHtmlLine, 
                            "        <TD BGCOLOR=\"#aaaaaa\"><FONT FACE=Arial ><A HREF=FILE://%s><B>Runtime</B></A>\x0d\x0a", szRoot );
                        WriteFile( hFile, szHtmlLine, i, &dw, NULL );
                        CloseHandle( hExistingFile );
                    }
                    else
                    {
                        WriteFile( hFile, "        <TD BGCOLOR=\"#aaaaaa\"><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a", 77, &dw, NULL );
                    }

                    // check for existence of the SAPI5 runtime and symbols (retail)
                    strcpy( &szRoot[26], "\\release\\cab\\alpha\\sapi5sym.EXE" );
                    szRoot[57] = '\0';
                    hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                    if( hExistingFile != INVALID_HANDLE_VALUE )
                    {
                        i = sprintf( szHtmlLine, 
                            "        <TD BGCOLOR=\"#aaaaaa\"><FONT FACE=Arial ><A HREF=FILE://%s><B>Runtime/Symbols</B></A>\x0d\x0a",
                            szRoot );
                        WriteFile( hFile, szHtmlLine, i, &dw, NULL );
                        CloseHandle( hExistingFile );
                    }
                    else
                    {
                        WriteFile( hFile, "        <TD BGCOLOR=\"#aaaaaa\"><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a", 77, &dw, NULL );
                    }

                    // check for existence of the SAPI5 retail SDK
                    strcpy( &szRoot[26], "\\release\\cab\\alpha\\sapi5sdk.EXE" );
                    szRoot[57] = '\0';
                    hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                    if( hExistingFile != INVALID_HANDLE_VALUE )
                    {
                        i = sprintf( szHtmlLine, 
                            "        <TD BGCOLOR=\"#aaaaaa\"><FONT FACE=Arial ><A HREF=FILE://%s><CENTER><B>SDK</B></CENTER></A>\x0d\x0a", szRoot );
                        WriteFile( hFile, szHtmlLine, i, &dw, NULL );
                        CloseHandle( hExistingFile );
                    }
                    else
                    {
                        WriteFile( hFile, "        <TD BGCOLOR=\"#aaaaaa\"><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a", 77, &dw, NULL );
                    }

                    // check for existence of the SAPI5 runtime and symbols (debug)
                    strcpy( &szRoot[26], "\\debug\\cab\\alpha\\sapi5sym.EXE" );
                    szRoot[55] = '\0';
                    hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                    if( hExistingFile != INVALID_HANDLE_VALUE )
                    {
                        i = sprintf( szHtmlLine, 
                            "        <TD BGCOLOR=\"#ffff00\"><FONT FACE=Arial ><A HREF=FILE://%s><B>Runtime/Symbols</B></A>\x0d\x0a", szRoot );
                        WriteFile( hFile, szHtmlLine, i, &dw, NULL );
                        CloseHandle( hExistingFile );
                    }
                    else
                    {
                        WriteFile( hFile, "        <TD BGCOLOR=\"#ffff00\"><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a", 77, &dw, NULL );
                    }

                    // check for existence of the SAPI5 debug SDK
                    strcpy( &szRoot[26], "\\debug\\cab\\alpha\\sapi5sdk.EXE" );
                    szRoot[55] = '\0';
                    hExistingFile = CreateFile( szRoot, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                    if( hExistingFile != INVALID_HANDLE_VALUE )
                    {
                        i = sprintf( szHtmlLine, 
                            "        <TD BGCOLOR=\"#ffff00\"><FONT FACE=Arial ><A HREF=FILE://%s><CENTER><B>SDK</B></CENTER></A>\x0d\x0a", szRoot );
                        WriteFile( hFile, szHtmlLine, i, &dw, NULL );
                        CloseHandle( hExistingFile );
                    }
                    else
                    {
                        WriteFile( hFile, "        <TD BGCOLOR=\"#ffff00\"><FONT FACE=Arial ><CENTER><B>N/A</B></CENTER>\x0d\x0a", 77, &dw, NULL );
                    }

                } while( pdirs < pEnd );
                delete [] pDirsTmp;
                system( "del dirs.txt" );

                WriteFile( hFile, "</TABLE>\x0d\x0a<BR>\x0d\x0a\x0d\x0a</CENTER>\x0d\x0a</BODY></HTML>\x0d\x0a",
                    45, &dw, NULL );
                CloseHandle( hFile );

            }
            else
            {
                return -1;
            }
        }
        else
        {
            return -1;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\mmio\mmioi.h ===
/* mmioi.h
 *
 * Definitions that are internal to the MMIO library, i.e. shared by MMIO*.C
 */


/* Revision history:
 * LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
 * StephenE: Apr 92 added unicode to ascii conversion function prototypes.
 */
 

#include <mmio.h>

typedef MMIOINFO *PMMIO;                // (Win32)

typedef struct _MMIODOSINFO             // How DOS IOProc uses MMIO.adwInfo[]
{
        HANDLE          fh;             // DOS file handle
} MMIODOSINFO;

typedef struct _MMIOMEMINFO             // How MEM IOProc uses MMIO.adwInfo[]
{
        LONG            lExpand;        // increment to expand mem. files by
} MMIOMEMINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\mmio\mmioriff.c ===
/* mmioriff.c
 *
 * MMIO RIFF functions.
 */

/* Revision history:
   a-davlip: Jan 00: Ported to APC.
   LaurieGr: Jan 92 Ported from win16.  Source tree fork, not common code.
*/

//#define VALIDATE_PARMS
#include "winmmi.h"
#include "mmioi.h"

static  BYTE bPad;

/* @doc EXTERNAL

@api    MMRESULT | mmioDescend | This function descends into a chunk of a
    RIFF file opened with <f mmioOpen>. It can also search for a given
    chunk.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a
    caller-supplied  <t MMCKINFO> structure that <f mmioDescend> fills
    with the following information:

    -- The <e MMCKINFO.ckid> field is the chunk ID of the chunk.

    -- The <e MMCKINFO.cksize> field is the size of the data portion
    of the chunk. The data size includes the form type or list type (if
    any), but does not include the 8-byte chunk header or the pad byte at
    the end of the data (if any).

    -- The <e MMCKINFO.fccType> field is the form type if
    <e MMCKINFO.ckid> is "RIFF", or the list type if
    <e MMCKINFO.ckid> is "LIST". Otherwise, it is NULL.

    -- The <e MMCKINFO.dwDataOffset> field is the file offset of the
    beginning of the data portion of the chunk. If the chunk is a
    "RIFF" chunk or a "LIST" chunk, then <e MMCKINFO.dwDataOffset>
    is the offset of the form type or list type.

    -- The <e MMCKINFO.dwFlags> contains other information about the chunk.
    Currently, this information is not used and is set to zero.

    If the MMIO_FINDCHUNK, MMIO_FINDRIFF, or MMIO_FINDLIST flag is
    specified for <p uFlags>, then the <t MMCKINFO> structure is also
    used to pass parameters to <f mmioDescend>:

    -- The <e MMCKINFO.ckid> field specifies the four-character code
    of the chunk ID, form type, or list type to search for.

@parm   LPMMCKINFO | lpckParent | Specifies a pointer to an
    optional caller-supplied <t MMCKINFO> structure identifying
    the parent of the chunk being searched for.
    A parent of a chunk is the enclosing chunk--only "RIFF" and "LIST"
    chunks can be parents.  If <p lpckParent> is not NULL, then
    <f mmioDescend> assumes the <t MMCKINFO> structure it refers to
    was filled when <f mmioDescend> was called to descend into the parent
    chunk, and <f mmioDescend> will only search for a chunk within the
    parent chunk. Set <p lpckParent> to NULL if no parent chunk is
    being specified.

@parm   UINT | uFlags | Specifies search options. Contains up to one
    of the following flags. If no flags are specified,
    <f mmioDescend> descends into the chunk beginning at the current file
    position.

    @flag   MMIO_FINDCHUNK | Searches for a chunk with the specified chunk ID.

    @flag   MMIO_FINDRIFF | Searches for a chunk with chunk ID "RIFF"
        and with the specified form type.

    @flag   MMIO_FINDLIST | Searches for a chunk with chunk ID "LIST"
        and with the specified form type.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. If the end of
    the file (or the end of the parent chunk, if given) is reached before
    the desired chunk is found, the return value is
    MMIOERR_CHUNKNOTFOUND.
    Other error return values are possible, for instance MMIOERR_CANNOTSEEK.

@comm   A RIFF chunk consists of a four-byte chunk ID (type FOURCC),
    followed by a four-byte chunk size (type DWORD), followed
    by the data portion of the chunk, followed by a null pad byte if
    the size of the data portion is odd. If the chunk ID is "RIFF" or
    "LIST", the first four bytes of the data portion of the chunk are
    a form type or list type (type FOURCC).

    If <f mmioDescend> is used to search for a chunk, the file
    position should be at the beginning of a
    chunk before calling <f mmioDescend>. The search begins at the
    current file position and continues to the end of the file. If a
    parent chunk is specified, the file position should be somewhere
    within the parent chunk before calling <f mmioDescend>. In this case,
    the search begins at the current file position and continues to the
    end of the parent chunk.

    If <f mmioDescend> is unsuccessful in searching for a chunk, the
    current file position is undefined. If <f mmioDescend> is
    successful, the current file position is changed. If the chunk
    is a "RIFF" or "LIST" chunk, the new file position
    will be just after the form type or list type (12 bytes from the
    beginning of the chunk). For other chunks, the new file position will be
    the start of the data portion of the chunk (8 bytes from the
    beginning of the chunk).

    For efficient RIFF file I/O, use buffered I/O.

    @xref   mmioAscend MMCKINFO
*/
MMRESULT APIENTRY
   mmioDescend(HMMIO hmmio, LPMMCKINFO lpck, LPCMMCKINFO lpckParent, UINT uFlags)
{
    FOURCC      ckidFind;   // chunk ID to find (or NULL)
    FOURCC      fccTypeFind;    // form/list type to find (or NULL)

#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, MMIO_DESCEND_VALID, mmioDescend, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
    V_RPOINTER0(lpckParent, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif
    /* figure out what chunk id and form/list type to search for */
    if (uFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = 0;
    else
    if (uFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (uFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = 0;

    lpck->dwFlags = 0L;

    for(;;)
    {
        MMRESULT  mmr;

        /* read the chunk header */
        if (mmioRead(hmmio, (LPSTR) lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
            return MMIOERR_CHUNKNOTFOUND;

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (mmioRead(hmmio, (LPSTR) &lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = 0;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == 0) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == 0) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((mmr = mmioAscend(hmmio, lpck, 0)) != 0)
            return mmr;
    }

    return 0;
}


/* @doc EXTERNAL MMIO_RIFF

@api    MMRESULT | mmioAscend | This function ascends out of a chunk in a
    RIFF file descended into with <f mmioDescend> or created with
    <f mmioCreateChunk>.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a
    caller-supplied <t MMCKINFO> structure previously filled by
    <f mmioDescend> or <f mmioCreateChunk>.

@parm   UINT | uFlags | Is not used and should be set to zero.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | The contents of the buffer could
    not be written to disk.

    @flag MMIOERR_CANNOTSEEK | There was an error while seeking to
    the end of the chunk.

@comm   If the chunk was descended into using <f mmioDescend>, then
    <f mmioAscend> seeks to the location following the end of the
    chunk (past the extra pad byte, if any).

    If the chunk was created and descended into using
    <f mmioCreateChunk>, or if the MMIO_DIRTY flag is set in the
    <e MMCKINFO.dwFlags> field of the <t MMCKINFO> structure
    referenced by <p lpck>, then the current file position
    is assumed to be the end of the data portion of the chunk.
    If the chunk size is not the same as the value stored
    in the <e MMCKINFO.cksize> field when <f mmioCreateChunk>
    was called, then <f mmioAscend> corrects the chunk
    size in the file before ascending from the chunk. If the chunk
    size is odd, <f mmioAscend> writes a null pad byte at the end of the
    chunk. After ascending from the chunk, the current file position is
    the location following the end of the chunk (past the extra pad byte,
    if any).

@xref   mmioDescend mmioCreateChunk MMCKINFO
*/
MMRESULT APIENTRY
mmioAscend(HMMIO hmmio, LPMMCKINFO lpck, UINT uFlags)
{
    LONG lSeekPos;
    
#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, 0, mmioAscend, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif

    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by mmioCreateChunk();
         * check that the chunk size that was written when
         * mmioCreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG        lOffset;    // current offset in file
        LONG        lActualSize;    // actual size of chunk data

        if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            /* chunk size is odd -- write a null pad byte */
            if (mmioWrite(hmmio, (LPSTR) &bPad, sizeof(bPad))
                    != sizeof(bPad))
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (mmioSeek(hmmio, lpck->dwDataOffset
                - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        if (mmioWrite(hmmio, (LPSTR) &lpck->cksize,
                sizeof(DWORD)) != sizeof(DWORD))
            return MMIOERR_CANNOTWRITE;
    }

    // make sure that when we seek, we will be ADVANCING.  otherwise
    // we could get stuck in a loop trying to descend/ascend and never
    // going forward through the file
    //
    lSeekPos = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1);
    if ((LONG)lpck->dwDataOffset < 0 || lSeekPos < (LONG)lpck->dwDataOffset)
        return MMIOERR_INVALIDFILE;

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (mmioSeek(hmmio, lSeekPos, SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


/* @doc EXTERNAL MMIO_RIFF

@api    MMRESULT | mmioCreateChunk | This function creates a chunk in a
    RIFF file opened with <f mmioOpen>. The new chunk is created at the
    current file position. After the new chunk is created, the current
    file position is the beginning of the data portion of the new chunk.

@parm   HMMIO | hmmio | Specifies the file handle of an open RIFF
    file.

@parm   LPMMCKINFO | lpck | Specifies a pointer to a caller-supplied
    <t MMCKINFO> structure containing information about the chunk to be
    created. The <t MMCKINFO> structure should be set up as follows:

    -- The <e MMCKINFO.ckid> field specifies the chunk ID of the
    chunk. If <p uFlags> includes MMIO_CREATERIFF or MMIO_CREATELIST,
    this field will be filled by <f mmioCreateChunk>.

    -- The <e MMCKINFO.cksize> field specifies the size of the data
    portion of the chunk, including the form type or list type (if any).
    If this value is not correct when <f mmioAscend> is called to mark
    the end of the chunk, them <f mmioAscend> will correct the chunk
    size.

    -- The <e MMCKINFO.fccType> field specifies the form type or list
    type if the chunk is a "RIFF" or "LIST" chunk. If the chunk is not a
    "RIFF" or "LIST" chunk, this field need not be filled in.

    -- The <e MMCKINFO.dwDataOffset> field need not be filled in. The
    <f mmioCreateChunk> function will fill this field with the file
    offset of the data portion of the chunk.

    -- The <e MMCKINFO.dwFlags> field need not be filled in. The
    <f mmioCreateChunk> function will set the MMIO_DIRTY flag in
    <e MMCKINFO.dwFlags>.

@parm   UINT | uFlags | Specifies flags to optionally create either a
    "RIFF" chunk or a "LIST" chunk. Can contain one of the following
    flags:

    @flag   MMIO_CREATERIFF | Creates a "RIFF" chunk.

    @flag   MMIO_CREATELIST | Creates a "LIST" chunk.

@rdesc  The return value is zero if the function is successful.
    Otherwise, the return value specifies an error code. The error
    code can be one of the following codes:

    @flag MMIOERR_CANNOTWRITE | Unable to write the chunk header.

    @flag MMIOERR_CANNOTSEEK | Uanble to determine offset of data
    portion of the chunk.

@comm   This function cannot insert a chunk into the middle of a
    file. If a chunk is created anywhere but the end of a file,
    <f mmioCreateChunk> will overwrite existing information in the file.
*/
MMRESULT APIENTRY
mmioCreateChunk(HMMIO hmmio, LPMMCKINFO lpck, UINT uFlags)
{
    int     iBytes;         // bytes to write
    LONG        lOffset;    // current offset in file

#ifdef VALIDATE_PARMS
    V_FLAGS(uFlags, MMIO_CREATE_VALID, mmioCreateChunk, MMSYSERR_INVALFLAG);
    V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
#endif

    /* store the offset of the data part of the chunk */
    if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (uFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (uFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    /* write the chunk header */
    if (mmioWrite(hmmio, (LPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
        return MMIOERR_CANNOTWRITE;

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\mmio\debug.c ===
/****************************************************************************
    debug.c

    winmm debug support module

    Copyright (c) Microsoft Corporation 1990 - 1995. All rights reserved

    History
        10/1/92  Updated for NT by Robin Speed (RobinSp)
****************************************************************************/

#include "winmmi.h"
//#include <wchar.h>
#include <tchar.h>
#include <stdarg.h>

// BUGBUG - no REAL logging for now ! - NT doesn't have Dr Watson !
#define LogParamError(a, b)

//String constants.
#ifdef DEBUG
DBGPARAM dpCurSettings = {
    TEXT("mmio.lib"), {
    TEXT("Function"),TEXT("Warning"),TEXT("Error"),TEXT("Verbose"),
    TEXT("n/a"),TEXT("n/a"),TEXT("n/a"),TEXT("n/a"),
    TEXT("n/a"),TEXT("n/a"),TEXT("n/a"),TEXT("n/a"),
    TEXT("n/a"),TEXT("n/a"),TEXT("n/a"),TEXT("n/a") },
    0x00000006
};
#endif //DEBUG

HANDLE hHeap;
PHNDL pHandleList;
CRITICAL_SECTION HandleListCritSec;
/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | NewHandle | allocate a fixed handle in MMSYSTEM's local heap
 *
 * @parm  UINT | uType | unique id describing handle type
 * @parm  UINT | uSize | size in bytes to be allocated
 *
 * @rdesc Returns pointer/handle to memory object
 *
 * @comm a standard handle header (HNDL) will be added to the object,
 *       and it will be linked into the list of MMSYSTEM handles.
 *
 ***************************************************************************/
HANDLE NewHandle(UINT uType, UINT uSize)
{
    PHNDL pHandle;
	
	hHeap = GetProcessHeap();

    pHandle = (PHNDL)HeapAlloc(hHeap, 0, sizeof(HNDL) + uSize);

    if (pHandle == NULL) {
		UINT err = GetLastError();
        return pHandle;
    } else {
        memset(pHandle, 0, sizeof(HNDL) + uSize);
        EnterCriticalSection(&HandleListCritSec);
        pHandle->pNext = pHandleList;
        pHandle->hThread = (HANDLE)GetCurrentThreadId();        // For WOW validation
        pHandle->uType = uType;
        InitializeCriticalSection(&pHandle->CritSec);
        pHandleList = pHandle;
        LeaveCriticalSection(&HandleListCritSec);
    }
    return PHtoH(pHandle);
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | FreeHandle | free handle allocated with NewHandle
 *
 * @parm HANDLE | hUser | handle returned from NewHandle
 *
 * @comm handle will be unlinked from list, and memory will be freed
 *
 *
 ***************************************************************************/

void FreeHandle(HANDLE hUser)
{
    /* Find handle and free from list */

    PHNDL pHandle;
    PHNDL *pSearch;

    if (hUser == NULL) {
        return;
    }

    //
    // Point to our handle data
    //

    pHandle = HtoPH(hUser);

    EnterCriticalSection(&HandleListCritSec);

    pSearch = &pHandleList;

    while (*pSearch != NULL) {
        if (*pSearch == pHandle) {
            //
            // Found it
            // Remove it from the list
            //
            *pSearch = pHandle->pNext;
            LeaveCriticalSection(&HandleListCritSec);
            DeleteCriticalSection(&pHandle->CritSec);
            pHandle->uType = 0;
            pHandle->hThread = NULL;
            pHandle->pNext = NULL;
            HeapFree(hHeap, 0, (LPTSTR)pHandle);
            return;
        } else {
            pSearch = &(*pSearch)->pNext;
        }
    }

    DEBUGMSG(1, (TEXT("Freeing handle which is not in the list !")));
    DEBUGCHK(FALSE);
    LeaveCriticalSection(&HandleListCritSec);
}

#ifndef UNDER_CExxx

int winmmDebugLevel = 0;
/**************************************************************************

    @doc INTERNAL

    @api void | winmmSetDebugLevel | Set the current debug level

    @parm int | iLevel | The new level to set

    @rdesc There is no return value

**************************************************************************/

void winmmSetDebugLevel(int level)
{
#ifdef DEBUG
    winmmDebugLevel = level;
    DEBUGMSG(1, (TEXT("debug level set to %d"), winmmDebugLevel));
#endif
}

UINT inited = 0;

#ifdef DEBUG
extern int mciDebugLevel;
#endif

#ifdef DEBUG
void InitDebugLevel(void)
{
    if (!inited) {
        inited = 1;
    }
    DEBUGMSG(2, (TEXT("Starting, debug level=%d"), winmmDebugLevel));
}
#endif

#ifdef DEBUG_RETAIL

/***************************************************************************
 * @doc INTERNAL WAVE MIDI
 *
 * @func BOOL | ValidateHeader | validates a wave or midi date header
 *
 * @parm LPVOID | lpHeader| pointer to wave/midi header
 * @parm  UINT  | wSize  | size of header passed by app
 * @parm  UINT  | wType  | unique id describing header/handle type
 *
 * @rdesc Returns TRUE  if <p> is non NULL and <wSize> is the correct size
 *        Returns FALSE otherwise
 *
 * @comm  if the header is invalid an error will be generated.
 *
 ***************************************************************************/

BOOL ValidateHeader(PVOID pHdr, UINT uSize, UINT uType)
{
    // Detect bad header

    if (!ValidateWritePointer(pHdr, uSize)) {
        DebugErr(DBF_ERROR, "Invalid header pointer");
        return FALSE;
    }

    // Check type

    switch (uType) {
    case TYPE_MIDIIN:
	case TYPE_MIDIOUT:
	case TYPE_MIDISTRM:
        {
            PMIDIHDR pHeader = pHdr;

            if ((TYPE_MIDISTRM == uType) &&
                uSize < sizeof(MIDIHDR))
            {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }
            if (pHeader->dwFlags & ~MHDR_VALID) {
                LogParamError(ERR_BAD_FLAGS, ((PMIDIHDR)pHeader)->dwFlags);
                return FALSE;
            }

		/* NOTE: For Dreamcast, because we don't actually require a valid lpData
			in some cases, don't bother validating */

        }
        break;

    default:
        DEBUGCHK(FALSE);
        break;
    }

	return TRUE;
}

#ifndef USE_KERNEL_VALIDATION
/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateReadPointer | validates that a pointer is valid to
 *  read from.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/

BOOL ValidateReadPointer(PVOID pPoint, ULONG Len)
{
    // For now just check access to first and last byte

    try {
        volatile BYTE b;
        b = ((PBYTE)pPoint)[0];
        b = ((PBYTE)pPoint)[Len - 1];
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateWritePointer | validates that a pointer is valid to
 *  write to.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/
BOOL ValidateWritePointer(PVOID pPoint, ULONG Len)
{
    // For now just check read and write access to first and last byte

    try {
           volatile BYTE b;
           b = ((PBYTE)pPoint)[0];
           ((PBYTE)pPoint)[0] = b;
           b = ((PBYTE)pPoint)[Len - 1];
           ((PBYTE)pPoint)[Len - 1] = b;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}
#endif // USE_KERNEL_VALIDATION

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidDriverCallback |
 *
 *  validates that a driver callback is valid, to be valid a driver
 *  callback must be a valid window, task, or a function in a FIXED DLL
 *  code segment.
 *
 * @parm DWORD  | dwCallback | callback to validate
 * @parm DWORD  | wFlags     | driver callback flags
 *
 * @rdesc Returns 0  if <dwCallback> is a valid callback
 *        Returns error condition if <dwCallback> is not a valid callback
 ***************************************************************************/

BOOL ValidDriverCallback(HANDLE hCallback, DWORD dwFlags)
{
    switch (dwFlags & DCB_TYPEMASK) {
    case DCB_WINDOW:
        if (!IsWindow(hCallback)) {
            LogParamError(ERR_BAD_HWND, hCallback);
            return FALSE;
        }
        break;

    case DCB_EVENT:
        // BUGBUG enhance ! - how do we test that this is an event handle?
        //if (hCallback is not an event)
        //    LogParamError(ERR_BAD_CALLBACK, hCallback);
        //    return FALSE;
        //}
        break;


    case DCB_TASK:
        // BUGBUG enhance !
        //if (IsBadCodePtr((FARPROC)hCallback)) {
        //    LogParamError(ERR_BAD_CALLBACK, hCallback);
        //    return FALSE;
        //}
        break;

    case DCB_FUNCTION:
        // BUGBUG enhance !
        if (IsBadCodePtr((FARPROC)hCallback)) {
            LogParamError(ERR_BAD_CALLBACK, hCallback);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

#ifndef USE_KERNEL_VALIDATION

/* REVIEW peted: this appears to be unused */

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateStringW |
 *
 **************************************************************************/
BOOL ValidateStringW(LPCTSTR pPoint, DWORD Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile TCHAR b;
           LPCTSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}
#endif //USE_KERNEL_VALIDATION

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateHandle | validates a handle created with NewHandle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL ValidateHandle(HANDLE hLocal, UINT uType)

{
   BOOL OK;

   //
   //  if the handle is less than 64k or a mapper id then
   //  don't bother with the overhead of the try-except.
   //
   if ((UINT)hLocal < 0x10000)
   {
       LogParamError(ERR_BAD_HANDLE, hLocal);
       return FALSE;
   }

   try {
       OK = HtoPH(hLocal)->uType == uType;

    } except(EXCEPTION_EXECUTE_HANDLER) {
      LogParamError(ERR_BAD_HANDLE, hLocal);
      return FALSE;
   }

   return OK;
}


#ifdef DEBUG
char * Types[4] = {"Unknown callback type",
                   "Window callback",
                   "Task callback",
                   "Function callback"};
#endif
/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateCallbackType | validates a callback address,
 *              window handle, or task handle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL ValidateCallbackType(DWORD dwCallback, UINT uType)
{

#define DCALLBACK_WINDOW   HIWORD(CALLBACK_WINDOW)      // dwCallback is a HWND
#define DCALLBACK_TASK     HIWORD(CALLBACK_TASK)        // dwCallback is a HTASK
#define DCALLBACK_FUNCTION HIWORD(CALLBACK_FUNCTION)    // dwCallback is a FARPROC
#define DCALLBACK_EVENT    HIWORD(CALLBACK_EVENT)       // dwCallback is an EVENT

    UINT type = uType & HIWORD(CALLBACK_TYPEMASK);

#ifdef DEBUG
    if (type>5) {
        type = 0;
    }
    DEBUGMSG(3, TEXT("Validating Callback, type=%d (%hs), handle=%8x"), type, Types[type], dwCallback);
#endif
    switch (type) {
        case DCALLBACK_WINDOW:
            return(IsWindow((HWND)dwCallback));
            break;

	case DCALLBACK_EVENT:
	{
	    // ?? how to verify that this is an event handle??
	    //DWORD dwFlags;
	    //GetHandleInformation((HANDLE)dwCallback, &dwFlags);
            return TRUE;
	}
            break;

        case DCALLBACK_FUNCTION:
            return(!(IsBadCodePtr((FARPROC)dwCallback)));
            break;

        case DCALLBACK_TASK:
            if (THREAD_PRIORITY_ERROR_RETURN == GetThreadPriority((HANDLE)dwCallback)) {
                DEBUGMSG(1, TEXT("Invalid callback task handle"));
                // I suspect we do not have the correct thread handle, in
                // which case we can only return TRUE.
                //return(FALSE);
            }
            return(TRUE);
            break;

    }
    return TRUE;
}

/**************************************************************************
   @doc INTERNAL

   @func void | dout | Output debug string if debug flag is set

   @parm LPTSTR | szString
 **************************************************************************/

#ifdef DEBUG
int fDebug = 1;
#else
int fDebug = 0;
#endif

//void dout(LPTSTR szString)
//{
//    if (fDebug) {
//        OutputDebugStringA(szString);
//    }
//}

#ifdef LATER

    This routine should probably be replaced in the headers by redefining
    to use OutputDebugString

#endif

#undef OutputDebugStr
// Make our function visible
/*****************************************************************************
*   @doc EXTERNAL DDK
*
*   @api void | OutputDebugStr | This function sends a debugging message
*      directly to the COM1 port or to a secondary monochrome display
*      adapter. Because it bypasses DOS, it can be called by low-level
*      callback functions and other code at interrupt time.
*
*   @parm LPTSTR | lpOutputString | Specifies a far pointer to a
*      null-terminated string.
*
*   @comm This function is available only in the debugging version of
*      Windows. The DebugOutput keyname in the [mmsystem]
*      section of SYSTEM.INI controls where the debugging information is
*      sent. If fDebugOutput is 0, all debug output is disabled.
******************************************************************************/
#endif // DEBUG_RETAIL
#endif // !UNDER_CE


#ifdef DEBUG


/***************************************************************************

    @doc INTERNAL

    @api void | winmmDbgOut | This function sends output to the current
        debug output device.

    @parm LPTSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/
extern BOOL Quiet = FALSE;

void winmmDbgOut(LPTSTR lpszFormat, ...)

{
    TCHAR buf[512];
    UINT n;
    va_list va;

    if (Quiet) {
        return;
    }

    n = wsprintf(buf, TEXT("WINMM: (tid %x) "), GetCurrentThreadId());

    va_start(va, lpszFormat);
    n += wvsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugString(buf);
    Sleep(0);  // let terminal catch up
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPTSTR | exp | Pointer to the expression string.
    @parm LPTSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPTSTR exp, LPTSTR file, int line)
{
    DEBUGMSG(1, (TEXT("Assertion failure:")));
    DEBUGMSG(1, (TEXT("  Exp: %s"), exp));
    DEBUGMSG(1, (TEXT("  File: %s, line: %d"), file, line));
    DebugBreak();
}
#else  // Still need to export this thing to help others
void winmmDbgOut(LPTSTR lpszFormat, ...)
{
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\currver.inc ===
// This file is generated, DO NOT EDIT
#define VERSION                     "5.00.00.0000"
#define VER_FILEVERSION_STR         "5.00.00.0000 "
#define VER_FILEVERSION             5,00,00,0000
#define VER_PRODUCTVERSION_STR      "5.00.00.0000 "
#define VER_PRODUCTVERSION          5,00,00,0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\mmio\winmmi.h ===
/***************************************************************************
 *  winmmi.h
 *
 *  Copyright (c) Microsoft Corporation 1990. All rights reserved
 *
 *  private include file
 *
 *  History
 *
 *  15 Jan 92 - Robin Speed (RobinSp) and Steve Davies (SteveDav) -
 *      major NT update
 *  6  Feb 92 - LaurieGr replaced HLOCAL by HANDLE
 *
 ***************************************************************************/

/***************************************************************************


 Useful include files for winmm component


 ***************************************************************************/

#ifndef WINMMI_H
#define WINMMI_H        /* Protect against double inclusion */


#include <windows.h>
#include <string.h>
#include <stdio.h>


#include "mmsystem.h"       /* Pick up the public header */

/*--------------------------------------------------------------------*\
 * Unicode helper macros
\*--------------------------------------------------------------------*/
#define SZCODE  CHAR
#define TSZCODE TCHAR
#define WSZCODE WCHAR

#define BYTE_GIVEN_CHAR(x)  ( (x) * sizeof( WCHAR ) )
#define CHAR_GIVEN_BYTE(x)  ( (x) / sizeof( WCHAR ) )

int Iwcstombs(LPTSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCTSTR lpstr, int len);




/***********************************************************************
 *
 *    prototypes from "mmiomisc.c"
 *
 ***********************************************************************/


PBYTE AsciiStrToUnicodeStr( PBYTE pdst, PBYTE pmax, LPCTSTR psrc );
PBYTE UnicodeStrToAsciiStr( PBYTE pdst, PBYTE pmax, LPCWSTR psrc);
LPWSTR     AllocUnicodeStr( LPCTSTR lpSourceStr );
BOOL        FreeUnicodeStr( LPWSTR lpStr );
LPSTR        AllocAsciiStr( LPCWSTR lpSourceStr );
BOOL          FreeAsciiStr( LPSTR lpStr );

/***********************************************************************
 *
 *    prototypes from "mmio.c"
 *
 ***********************************************************************/

void mmioCleanupIOProcs(HANDLE hTask);

/***********************************************************************
 *
 *  Timer functions
 *
 ***********************************************************************/
#if 0   //BUGBUG - are timer functions required?
#ifndef MMNOTIMER
 BOOL TimeInit(void);
 void TimeCleanup(DWORD ThreadId);
 UINT timeSetEventInternal(UINT wDelay, UINT wResolution, LPTIMECALLBACK lpFunction, DWORD dwUser, UINT wFlags, BOOL IsWOW);
#endif // !MMNOTIMER
#endif


/***********************************************************************
 *
 *  Information structure used to play sounds
 *
 ***********************************************************************/
#define WAIT_FOREVER INFINITE

/***************************************************************************

    Memory allocation using our local heap

***************************************************************************/
PVOID winmmAlloc(DWORD cb);
PVOID winmmReAlloc(PVOID ptr, DWORD cb);
//#define winmmFree(ptr) HeapFree(hHeap, 0, (ptr))

/***************************************************************************

    LOCKING AND UNLOCKING MEMORY

***************************************************************************/

#if 0
BOOL HugePageLock(LPVOID lpArea, DWORD dwLength);
void HugePageUnlock(LPVOID lpArea, DWORD dwLength);
#else
#define HugePageLock(lpArea, dwLength)      (TRUE)
#define HugePageUnlock(lpArea, dwLength)
#endif


 /**************************************************************************
//
//**************************************************************************/
#define TYPE_UNKNOWN            0
#define TYPE_WAVEOUT            1
#define TYPE_WAVEIN             2
#define TYPE_MIDIOUT            3
#define TYPE_MIDIIN             4
#define TYPE_MMIO               5
#define TYPE_MCI                6
#define TYPE_DRVR               7
#define TYPE_MIXER              8
#define TYPE_MIDISTRM           9
#define TYPE_AUX               10



/****************************************************************************

    handle apis's

****************************************************************************/

/*
// all MMSYSTEM handles are tagged with the following structure.
//
// a MMSYSTEM handle is really a fixed local memory object.
//
// the functions NewHandle() and FreeHandle() create and release a MMSYSTEM
// handle.
//
*/
typedef struct tagHNDL {
    struct  tagHNDL *pNext; // link to next handle
    UINT    uType;          // type of handle wave, midi, mmio, ...
    HANDLE  hThread;        // task that owns it
    UINT    h16;            // Corresponding WOW handle
    CRITICAL_SECTION CritSec; // Serialize access
} HNDL, *PHNDL;
/*************************************************************************/

#define HtoPH(h)        ((PHNDL)(h)-1)
#define PHtoH(ph)       ((ph) ? (HANDLE)((PHNDL)(ph)+1) : 0)
#define HtoPT(t,h)      ((t)(h))
#define PTtoH(t,pt)     ((t)(pt))


extern PHNDL pHandleList;

//
// Handles can be tested for ownership and reserved at the same time
//

#define ENTER_MM_HANDLE(h) (EnterCriticalSection(&HtoPH(h)->CritSec))
#define LEAVE_MM_HANDLE(h) ((void)LeaveCriticalSection(&HtoPH(h)->CritSec))

/*
// all wave and midi handles will be linked into
// a global list, so we can enumerate them latter if needed.
//
// all handle structures start with a HNDL structure, that contain common 
fields
//
// pHandleList points to the first handle in the list
//
// HandleListCritSec protects the handle list
//
// the NewHandle() and FreeHandle() functions are used to add/remove
// a handle to/from the list
*/

//extern PHNDL pHandleList;
//extern CRITICAL_SECTION HandleListCritSec;

extern HANDLE NewHandle(UINT uType, UINT size);
extern void   FreeHandle(HANDLE h);

#define GetHandleType(h)        (HtoPH(h)->uType)
#define GetHandleOwner(h)       (HtoPH(h)->hThread)
#define GetHandleFirst()        (PHtoH(pHandleList))
#define GetHandleNext(h)        (PHtoH(HtoPH(h)->pNext))
#define SetHandleOwner(h,hOwn)  (HtoPH(h)->hThread = (hOwn))

#define GetWOWHandle(h)         (HtoPH(h)->h16)
#define SetWOWHandle(h, myh16)  (HtoPH(h)->h16 = (myh16))

/****************************************************************************

    user debug support

****************************************************************************/

#define DebugErr(x,y)         /* BUGBUG - put in error logging later */
#define DebugErr1(flags, sz, a)

#ifdef DEBUG_RETAIL

#define MM_GET_DEBUG        DRV_USER
#define MM_GET_DEBUGOUT     DRV_USER+1
#define MM_SET_DEBUGOUT     DRV_USER+2
#define MM_GET_MCI_DEBUG    DRV_USER+3
#define MM_SET_MCI_DEBUG    DRV_USER+4
#define MM_GET_MM_DEBUG     DRV_USER+5
#define MM_SET_MM_DEBUG     DRV_USER+6

#define MM_HINFO_NEXT       DRV_USER+10
#define MM_HINFO_TASK       DRV_USER+11
#define MM_HINFO_TYPE       DRV_USER+12
#define MM_HINFO_MCI        DRV_USER+20

#define MM_DRV_RESTART      DRV_USER+30

/*
// these validation routines can be found in DEBUG.C
*/
// The kernel validation is turned OFF because it appeared to test every page
// before use and this took over a minute for soundrec with a 10MB buffer
//
#ifdef USE_KERNEL_VALIDATION

#define  ValidateReadPointer(p, len)     (!IsBadReadPtr(p, len))
#define  ValidateWritePointer(p, len)    (!IsBadWritePtr(p, len))
#define  ValidateString(lsz, max_len)    (!IsBadStringPtrA(lsz, max_len))
#define  ValidateStringW(lsz, max_len)   (!IsBadStringPtrW(lsz, max_len))

#else

BOOL  ValidateReadPointer(LPVOID p, DWORD len);
BOOL  ValidateWritePointer(LPVOID p, DWORD len);
BOOL  ValidateString(LPCTSTR lsz, DWORD max_len);
BOOL  ValidateStringW(LPCWSTR lsz, DWORD max_len);

#endif // USE_KERNEL_VALIDATION

BOOL  ValidateHandle(HANDLE h, UINT uType);
BOOL  ValidateHeader(LPVOID p, UINT uSize, UINT uType);
BOOL  ValidateCallbackType(DWORD dwCallback, UINT uType);

/********************************************************************
* When time permits we should change to using the Kernel supplied and
* supported validation routines:
*
* BOOL  WINAPI IsBadReadPtr(CONST VOID *lp, UINT ucb );
* BOOL  WINAPI IsBadWritePtr(LPVOID lp, UINT ucb );
* BOOL  WINAPI IsBadHugeReadPtr(CONST VOID *lp, UINT ucb);
* BOOL  WINAPI IsBadHugeWritePtr(LPVOID lp, UINT ucb);
* BOOL  WINAPI IsBadCodePtr(FARPROC lpfn);
* BOOL  WINAPI IsBadStringPtrA(LPCTSTR lpsz, UINT ucchMax);
* BOOL  WINAPI IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
*
* These routines can be found in * \nt\private\WINDOWS\BASE\CLIENT\PROCESS.C
*
********************************************************************/

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define BAD_HANDLE(h, t)            ( !(ValidateHandle((h), (t))) )
#define V_HEADER(p, w, t, r)    { if (!ValidateHeader((p), (w), (t))) return (
r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((PVOID)(p), (l))) 
return (r); }
#define V_RPOINTER0(p, l, r)    { if ((p) && !ValidateReadPointer((PVOID)(p), 
(l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((PVOID)(p), (l))) 
return (r); }
#define V_WPOINTER0(p, l, r)    { if ((p) && !ValidateWritePointer((PVOID)(p)
, (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if ((d) && !ValidateCallbackType((d), (w))) 
return(r); }
//#define V_DCALLBACK(d, w, r)    0
#define V_TCALLBACK(d, r)       0
#define V_CALLBACK(f, r)        { if (IsBadCodePtr((f))) return (r); }
#define V_CALLBACK0(f, r)       { if ((f) && IsBadCodePtr((f))) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_STRING_W(s, l, r)       { if (!ValidateStringW(s,l)) return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) { return (r); }}
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {/* LogParamError(
ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t));*/ return (r); }}
#define V_MMSYSERR(e, f, t, r)  { /* LogParamError(e, (FARPROC)(f), (LPVOID)(
DWORD)(t));*/ return (r); }

#else /*ifdef DEBUG_RETAIL */

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define BAD_HANDLE(h, t)            ( !(ValidateHandle((h), (t))) )
#define V_HEADER(p, w, t, r)    { if (!(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_RPOINTER0(p, l, r)    0
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER0(p, l, r)    0
#define V_DCALLBACK(d, w, r)    { if ((d) && !ValidateCallbackType((d), (w))) return(r); }
//#define V_DCALLBACK(d, w, r)    0
#define V_TCALLBACK(d, r)       0
#define V_CALLBACK(f, r)        { if (IsBadCodePtr((f))) return (r); }
#define V_CALLBACK0(f, r)       { if ((f) && IsBadCodePtr((f))) return (r); }
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_STRING_W(s, l, r)     { if (!(s)) return (r); }
#define V_FLAGS(t, b, f, r)     0
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) return (r); }
#define V_MMSYSERR(e, f, t, r)  { return (r); }

#endif /* ifdef DEBUG_RETAIL */


/****************************************************************************

    RIFF constants used to access wave files

****************************************************************************/

#define FOURCC_FMT  mmioFOURCC('f', 'm', 't', ' ')
#define FOURCC_DATA mmioFOURCC('d', 'a', 't', 'a')
#define FOURCC_WAVE mmioFOURCC('W', 'A', 'V', 'E')


extern HWND hwndNotify;

void FAR PASCAL WaveOutNotify(DWORD wParam, LONG lParam);    // in PLAYWAV.C

/*
// Things not in Win32
*/

/*
// other stuff
*/

	 // Maximum length, including the terminating NULL, of an Scheme entry.
	 //
#define SCH_TYPE_MAX_LENGTH 64

	 // Maximum length, including the terminating NULL, of an Event entry.
	 //
#define EVT_TYPE_MAX_LENGTH 32

	 // Maximum length, including the terminating NULL, of an App entry.
	 //
#define APP_TYPE_MAX_LENGTH 64

	 // Sound event names can be a fully qualified filepath with a NULL
	 // terminator.
	 //
#define MAX_SOUND_NAME_CHARS    144

	 //  sound atom names are composed of:
	 //     <1 char id>
	 //     <reg key name>
	 //     <1 char sep>
	 //     <filepath>
	 //
#define MAX_SOUND_ATOM_CHARS    (1 + 40 + 1 + MAX_SOUND_NAME_CHARS)


#endif /* WINMMI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(new_handler);
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
	{return; }
#endif
#endif


/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#endif /* __cplusplus */

#endif /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

/*
#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif
*/

#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************.
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        unsigned long lCounts[_MAX_BLOCKS];
        unsigned long lSizes[_MAX_BLOCKS];
        unsigned long lHighWaterCount;
        unsigned long lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


//#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _CrtSetReportHook(f)                ((void)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((void)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((void)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)

#define _CrtSetDumpClient(f)                ((void)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)

#define _ASSERT(expr)   DEBUGCHK(expr)

#if 0
                  \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
             DebugBreak();              \
        }                               \
    } while (0)
#endif

//#else   /* _DEBUG */
//#endif  /* _DEBUG */

#ifdef  __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\basetsd_ce.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

    Jeff Havens (jhavens)   23-Oct-1997

Revision History:

    Boris Zverev (borisz)   11-Jul-2000     Adapted for WCE.

--*/

#ifndef _BASETSD_CE_H_
#define _BASETSD_CE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef int LONG32, *PLONG32;
typedef int INT32, *PINT32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;

//#if !defined(_W64)
//#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
//#define _W64 __w64
//#else
#define _W64
//#endif
//#endif

#ifdef _WIN64
#undef _WIN64
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

    typedef [public] __int3264 INT_PTR, *PINT_PTR;
    typedef [public] unsigned __int3264 UINT_PTR, *PUINT_PTR;

    typedef [public] __int3264 LONG_PTR, *PLONG_PTR;
    typedef [public] unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int64

#else
    typedef _W64 int INT_PTR, *PINT_PTR;
    typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef _W64 long LONG_PTR, *PLONG_PTR;
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int32

#endif
#endif // midl64

//
// HALF_PTR is half the size of a pointer it intended for use with
// within strcuture which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//

#ifdef _WIN64

#define ADDRESS_TAG_BIT 0x40000000000UI64

typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;

#pragma warning(disable:4311)   // type cast truncation
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4305)   // type cast truncation

#if !defined(__midl)
__inline
unsigned long
HandleToUlong(
    const void *h
    )
{
    return((unsigned long) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) h );
}

__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) p );
}

__inline
void *
IntToPtr(
    const int i
	)
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}

#endif // !_midl
#if _MSC_VER >= 1200
#pragma warning(pop)      // restore 4305
#endif
#pragma warning(3:4311)   // bump 4311 to a level 3

#else  // !_WIN64

#define ADDRESS_TAG_BIT 0x80000000UL

typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef _W64 unsigned long HANDLE_PTR;

//#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
//#define HandleToLong( h ) ((LONG)(LONG_PTR) (h) )
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
//#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
//#define PtrToLong( p ) ((LONG)(LONG_PTR) (p) )
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p ) ((INT)(INT_PTR) (p) )
//#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
//#define PtrToShort( p ) ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))

#endif // !_WIN64

#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui) UIntToPtr(ui)

//#define MAXUINT_PTR  (~((UINT_PTR)0))
#define MAXINT_PTR   ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR   (~MAXINT_PTR)

//#define MAXULONG_PTR (~((ULONG_PTR)0))
#define MAXLONG_PTR  ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR  (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
//#define MAXHALF_PTR  ((HALF_PTR)(MAXUHALF_PTR >> 1))
#define MINHALF_PTR  (~MAXHALF_PTR)

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

//typedef ULONG_PTR SIZE_T, *PSIZE_T;
//typedef LONG_PTR SSIZE_T, *PSSIZE_T;

//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;
typedef __int64 INT64,  *PINT64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;
typedef unsigned __int64 UINT64,  *PUINT64;

#ifdef __cplusplus
}
#endif

#endif // _BASETSD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\unknwn.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Tue Nov 16 19:00:22 1999
 */
/* Compiler settings for .\unknwn.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unknwn_h__
#define __unknwn_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IUnknown_FWD_DEFINED__
#define __IUnknown_FWD_DEFINED__
typedef interface IUnknown IUnknown;
#endif 	/* __IUnknown_FWD_DEFINED__ */


#ifndef __IClassFactory_FWD_DEFINED__
#define __IClassFactory_FWD_DEFINED__
typedef interface IClassFactory IClassFactory;
#endif 	/* __IClassFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_unknwn_0000
 * at Tue Nov 16 19:00:22 1999
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_v0_0_s_ifspec;

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUnknown
 * at Tue Nov 16 19:00:22 1999
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object][local] */ 


typedef /* [unique] */ IUnknown __RPC_FAR *LPUNKNOWN;

//////////////////////////////////////////////////////////////////
// IID_IUnknown and all other system IIDs are provided in UUID.LIB
// Link that library in with your proxies, clients and servers
//////////////////////////////////////////////////////////////////

EXTERN_C const IID IID_IUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
#if (_MSC_VER >= 1200)	// VC6 or greater
extern "C++"
{
#endif

    interface DECLSPEC_UUID("00000000-0000-0000-C000-000000000046")
    IUnknown
    {
    public:
        BEGIN_INTERFACE
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
        
#if (_MSC_VER >= 1200)	// VC6 or greater
		template <class Q>
		HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
		{
			return QueryInterface(__uuidof(Q), (void**)pp);
		}
#endif    

        END_INTERFACE
    };
    
#if (_MSC_VER >= 1200)	// VC6 or greater
} // extern "C++"
#endif
    
#else 	/* C style interface */

    typedef struct IUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnknown __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnknown __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnknown __RPC_FAR * This);
        
        END_INTERFACE
    } IUnknownVtbl;

    interface IUnknown
    {
        CONST_VTBL struct IUnknownVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy( 
    IUnknown __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IUnknown_QueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy( 
    IUnknown __RPC_FAR * This);


void __RPC_STUB IUnknown_AddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy( 
    IUnknown __RPC_FAR * This);


void __RPC_STUB IUnknown_Release_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnknown_INTERFACE_DEFINED__ */


#ifndef __IClassFactory_INTERFACE_DEFINED__
#define __IClassFactory_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IClassFactory
 * at Tue Nov 16 19:00:22 1999
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IClassFactory __RPC_FAR *LPCLASSFACTORY;


EXTERN_C const IID IID_IClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000001-0000-0000-C000-000000000046")
    IClassFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClassFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClassFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClassFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            IClassFactory __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockServer )( 
            IClassFactory __RPC_FAR * This,
            /* [in] */ BOOL fLock);
        
        END_INTERFACE
    } IClassFactoryVtbl;

    interface IClassFactory
    {
        CONST_VTBL struct IClassFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassFactory_CreateInstance(This,pUnkOuter,riid,ppvObject)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObject)

#define IClassFactory_LockServer(This,fLock)	\
    (This)->lpVtbl -> LockServer(This,fLock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);


void __RPC_STUB IClassFactory_RemoteLockServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassFactory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);


/* [call_as] */ HRESULT __stdcall IClassFactory_LockServer_Stub( 
    IClassFactory __RPC_FAR * This,
    /* [in] */ BOOL fLock);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\wincestub.h ===
#ifndef WinCEStub_h
#define WinCEStub_h

#include "winbase.h"
#include "urlmon.h"
#include "basetsd.h"
#include <spdebug.h>
#include <spcollec.h>

// winuser.h
#define InterlockedExchangePointer( pv, v)  InterlockedExchange( (long*)pv, (long)v)
#define SetWindowLongPtr                    SetWindowLong
#define GetWindowLongPtr                    GetWindowLong

// winuser.h
#define GWLP_WNDPROC    GWL_WNDPROC
#define GWLP_STYLE      GWL_STYLE
#define GWLP_EXSTYLE    GWL_EXSTYLE
#define GWLP_USERDATA   GWL_USERDATA
#define GWLP_ID         GWL_ID

// from winbase.h
#define NORMAL_PRIORITY_CLASS       0x00000020

// from winbase.h
#define LOCKFILE_FAIL_IMMEDIATELY   0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK     0x00000002

// stdlib.cpp
void *bsearch( const void *key, const void *base, size_t num, size_t width, int ( __cdecl *compare ) ( const void *elem1, const void *elem2 ) );
DWORD GetFullPathName(  WCHAR *lpFileName,  // file name
                        DWORD nBufferLength, // size of path buffer
                        WCHAR *lpBuffer,     // path buffer
                        WCHAR **lpFilePart   // address of file name in path
                      );

DWORD GetCurrentDirectory(
  DWORD nBufferLength,  // size of directory buffer
  LPTSTR lpBuffer       // directory buffer
);

// dasetsd.h
#ifdef _WIN64

__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

#else  // !_WIN64

#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))

#endif  // !_WIN64

#define UintToPtr(ui) UIntToPtr(ui)

// new.h
#ifndef NOAPC_NEWOP
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#endif // NOAPC_NEWOP

inline int lstrlenA(LPCSTR lpString)
{
	LPCSTR lpCur = lpString;
	while (lpCur != '\0')
		lpCur++;

	return (lpCur - lpString);
}

// shfolder.h
#ifndef CSIDL_APPDATA
#define CSIDL_APPDATA                   0x001a      // Application Data, new for NT4
#endif

#ifndef CSIDL_LOCAL_APPDATA

#define CSIDL_LOCAL_APPDATA             0x001C      // non roaming, user\Local Settings\Application Data
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023      // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024      // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025      // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026      // C:\Program Files
#define CSIDL_MYPICTURES                0x0027      // My Pictures, new for Win2K
#define CSIDL_PROGRAM_FILES_COMMON      0x002b      // C:\Program Files\Common 
#define CSIDL_COMMON_DOCUMENTS          0x002e      // All Users\Documents


#define CSIDL_FLAG_CREATE               0x8000      // new for Win2K, or this in to force creation of folder

#define CSIDL_COMMON_ADMINTOOLS         0x002f      // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030      // <user name>\Start Menu\Programs\Administrative Tools

#endif // CSIDL_LOCAL_APPDATA


//  Fix misaligment exception
#if defined (_M_ALPHA)||defined(_M_MRX000)||defined(_M_PPC)||defined(_SH4_)||defined(ARM)
   #undef  UNALIGNED
   #define UNALIGNED __unaligned

#define UNALIGNED_PROPERTY( propertytype, propertyname) propertytype internal_##propertyname; \
    __declspec( property( get=get_##propertyname, put=put_##propertyname ) ) propertytype propertyname; \
	inline void put_##propertyname( propertytype newvalue) { CopyMemory( &internal_##propertyname, &newvalue, sizeof(propertytype));};  \
	inline propertytype get_##propertyname ( ) { propertytype value; CopyMemory( &value, &internal_##propertyname, sizeof(propertytype)); return value;}; 

#endif

// for sapi/sapi/recognizer.h
EXTERN_C const GUID IID__ISpRecognizerBackDoor;

typedef HANDLE HPROCESS;

//tchar.h
#ifndef _T
    #define _T(x)       __TEXT(x)
#endif
#ifndef _TEXT
    #define _TEXT(x)    __TEXT(x)
#endif

#endif //WinCEStub_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\inc\mmio.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:mmio.h -- Include file for Multimedia API's  

 *    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *      MMNOSOUND       Sound support
 *      MMNOWAVE        Waveform support
 *
 */

#ifndef _INC_MMIO
#define _INC_MMIO   // to prevent multiple inclusion of mmsystem.h

#include "mmsystem.h"
#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif  // __cplusplus


#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
        ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
        ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))

#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

extern HANDLE hHeap;
//extern PHNDL pHandleList;
extern CRITICAL_SECTION HandleListCritSec;

#ifndef MMNOMMIO
/****************************************************************************

            Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef LPSTR           HPSTR;         /* a huge str pointer (old) */
typedef DWORD           FOURCC;         /* a four character code */
//DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
    /* general fields */
    DWORD           dwFlags;        /* general status flags */
    FOURCC          fccIOProc;      /* pointer to I/O procedure */
    LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
    UINT            wErrorRet;      /* place for error to be returned */
    HTASK           htask;          /* alternate local task */

    /* fields maintained by MMIO functions during buffered I/O */
    LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
    LPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
    LPSTR           pchNext;        /* pointer to next byte to read/write */
    LPSTR           pchEndRead;     /* pointer to last valid byte to read */
    LPSTR           pchEndWrite;    /* pointer to last byte to write */
    LONG            lBufOffset;     /* disk offset of start of buffer */

    /* fields maintained by I/O procedure */
    LONG            lDiskOffset;    /* disk offset of next read or write */
    DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

    /* other fields maintained by MMIO */
    DWORD           dwReserved1;    /* reserved for MMIO use */
    DWORD           dwReserved2;    /* reserved for MMIO use */
    HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;
typedef const MMIOINFO FAR *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
    FOURCC          ckid;           /* chunk ID */
    DWORD           cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    DWORD           dwDataOffset;   /* offset of data portion of chunk */
    DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_UNICODEPROC    0x01000000  /* mmioInstallIOProc: Unicode MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */
#define MMIOM_RENAME            6       /* rename specified file */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

/* MMIO function prototypes */
FOURCC      WINAPI mmioStringToFOURCC(LPCTSTR sz, UINT uFlags);
LPMMIOPROC  WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO       WINAPI mmioOpen(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
MMRESULT    WINAPI mmioRename(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);

MMRESULT    WINAPI mmioClose(       HMMIO hmmio, UINT fuClose);
LONG        WINAPI mmioRead(        HMMIO hmmio, LPSTR pch, LONG cch);
LONG        WINAPI mmioWrite(       HMMIO hmmio, LPCSTR pch, LONG cch);
LONG        WINAPI mmioSeek(        HMMIO hmmio, LONG lOffset, int iOrigin);
MMRESULT    WINAPI mmioGetInfo(     HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
MMRESULT    WINAPI mmioSetInfo(     HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
MMRESULT    WINAPI mmioSetBuffer(   HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer);
MMRESULT    WINAPI mmioFlush(       HMMIO hmmio, UINT fuFlush);
MMRESULT    WINAPI mmioAdvance(     HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
LRESULT     WINAPI mmioSendMessage( HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
MMRESULT    WINAPI mmioDescend(     HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
MMRESULT    WINAPI mmioAscend(      HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
MMRESULT    WINAPI mmioCreateChunk( HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef MMNOMMIO */




#ifdef __cplusplus
}                       // End of extern "C" {
#endif  // __cplusplus

#include "poppack.h"        /* Revert to default packing */



#endif // _INC_MMSYSTEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\mkcevoice\mkcevoice.cpp ===
/******************************************************************************
* mkvoice.cpp *
*-------------*
*   This application assembles a simple voice font for the sample TTS engine.
*
******************************************************************************/
#include "stdafx.h"
//#include <ttseng_i.c>
#include <direct.h>

int main(int argc, char* argv[])
{
    USES_CONVERSION;
    static const DWORD dwVersion = { 1 };
    ULONG ulNumWords = 0;
    HRESULT hr = S_OK;

    //--- Check args
    if( argc != 3 )
    {
        printf( "%s", "Usage: > mkvoice [[in]word list file] [[out]voice file]\n" );
    	hr = E_INVALIDARG;
    }
    else
    {
        ::CoInitialize( NULL );

        //--- Open word list file and create output voice file
        FILE* hWordList  = fopen( argv[1], "r" );
        FILE* hVoiceFile = fopen( argv[2], "wb" );

        if( hWordList && hVoiceFile )
        {
            //--- Write file version and leave space for word count
            if( !fwrite( &dwVersion, sizeof(dwVersion), 1, hVoiceFile ) ||
                 fseek( hVoiceFile, 4, SEEK_CUR ) )
            {
                hr = E_FAIL;
            }

            //--- Get each entry
            char WordFileName[MAX_PATH];
            while( SUCCEEDED( hr ) && fgets( WordFileName, MAX_PATH, hWordList ) )
            {
                ULONG ulTextLen = strlen( WordFileName );
                if( WordFileName[ulTextLen-1] == '\n' )
                {
                    WordFileName[--ulTextLen] = NULL;
                }
                //--- Include NULL character when writing to the file
                ulTextLen = (ulTextLen+1) * sizeof(WCHAR);

                if( fwrite( &ulTextLen, sizeof(ulTextLen), 1, hVoiceFile ) &&
                    fwrite( T2W(WordFileName), ulTextLen, 1, hVoiceFile ) )
                {
                    ++ulNumWords;
                    //--- Open the wav data
                    ISpStream* pStream;
                    strcat( WordFileName, ".wav" );
                    hr = SPBindToFile( WordFileName, SPFM_OPEN_READONLY, &pStream );
                    if( SUCCEEDED( hr ) )
                    {
                        CSpStreamFormat Fmt;
                        Fmt.AssignFormat(pStream);
                        if( Fmt.ComputeFormatEnum() == SPSF_11kHz16BitMono )
                        {
                            STATSTG Stat;
                            hr = pStream->Stat( &Stat, STATFLAG_NONAME );
                            ULONG ulNumBytes = Stat.cbSize.LowPart;

                            //--- Write the number of audio bytes
                            if( SUCCEEDED( hr ) &&
                                fwrite( &ulNumBytes, sizeof(ulNumBytes), 1, hVoiceFile ) )
                            {
                                BYTE* Buff = (BYTE*)alloca( ulNumBytes );
                                if( SUCCEEDED( hr = pStream->Read( Buff, ulNumBytes, NULL ) ) )
                                {
                                    //--- Write the audio samples
                                    if( !fwrite( Buff, 1, ulNumBytes, hVoiceFile ) )
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            printf( "Input file: %s has wrong wav format.", WordFileName );
                        }
                        pStream->Release();
                    }
                }
                else
                {
                	hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        //--- Write word count
        if( SUCCEEDED( hr ) )
        {
            if( fseek( hVoiceFile, sizeof(dwVersion), SEEK_SET ) ||
                !fwrite( &ulNumWords, sizeof(ulNumWords), 1, hVoiceFile ) )
            {
                hr = E_FAIL;
            }
        }
        //--- Cleanup
        if( hWordList  )
        {
            fclose( hWordList );
        }
        if( hVoiceFile )
        {
            fclose( hVoiceFile );
        }
        ::CoUninitialize();
    }
	return FAILED( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\basictts\basictts.cpp ===
/****************************************************************************
*
*   BasicTTS.cpp
*
*   Sample text-to-speech program that demonstrates the basics of using the
*   SAPI 5.0 TTS APIs.
*
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <atlbase.h>
#include <shellapi.h>
#include <sapi.h>

//--- Const Defines----------------------------------------------------------

const static WCHAR g_szMarkupDemo[] =
    L"<VOICE OPTIONAL=\"Female\">Tags can be used to change attributes such as\n"
    L"    <VOICE OPTIONAL=\"Gender=Male;Volume=Loud\">the voice font that is used,</VOICE>\n"
    L"    the <VOLUME LEVEL=\"65\">volume of the voice</VOLUME>\n"
    L"    and other attributes of speech such as pitch and rate.\n"
    L"</VOICE>\n\n";


/****************************************************************************
* MixWithWav *
*------------*
*   Description:
*       Plays an introductory audio file followed by synthetic speech.
*
*   Returns:
*       HRESULT from Speak call or
*       S_FALSE if the Intro.Wav file is not present
*
*****************************************************************************/

HRESULT MixWithWav(ISpVoice * pVoice)
{
    HRESULT hr = S_OK;
#ifndef _WIN32_WCE
    wprintf(L"Now a sample of mixed wave files and generated speech.\n\n");
#else
    OutputDebugString(L"Now a sample of mixed wave files and generated speech.\n\n");
#endif
    hr = pVoice->Speak(L"Intro.Wav", SPF_IS_FILENAME | SPF_ASYNC, NULL);
    if (hr == STG_E_FILENOTFOUND)
    {
#ifndef _WIN32_WCE
        wprintf(L"ERROR:  Can not find file Intro.Wav.  Wave file mixing sample will be skipped.\n\n");
#else
        OutputDebugStringW(L"ERROR:  Can not find file Intro.Wav.  Wave file mixing sample will be skipped.\n\n");
#endif
        hr = S_FALSE;   // Return success code so sample will continue...
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = pVoice->Speak(L"<VOICE OPTIONAL=\"Male\">one hundred eighty dollars and twenty seven cents.</VOICE>", 0, NULL );
        }
    }
    return hr;
}

/****************************************************************************
* CreateSampleFile *
*------------------*
*   Description:
*       Creates a file named Created.Wav using a TTS voice and then starts
*   the currently registered audio playback application.
*
*   Returns:
*       HRESULT
*
*****************************************************************************/

HRESULT CreateSampleFile(ISpVoice * pVoice)
{
    HRESULT hr = S_OK;
    CComPtr<ISpStream> cpWavStream;
    WAVEFORMATEX wfex;
    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.nChannels = 1;
    wfex.nSamplesPerSec = 22050;
    wfex.nAvgBytesPerSec = 22050 * 2;
    wfex.nBlockAlign = 2;
    wfex.wBitsPerSample = 16;
    wfex.cbSize = 0;
    hr = cpWavStream.CoCreateInstance(CLSID_SpStream);
    if (SUCCEEDED(hr))
    {
        hr = cpWavStream->BindToFile(L"Created.Wav", SPFM_CREATE_ALWAYS, &SPDFID_WaveFormatEx, &wfex, 0);
    }
    if (SUCCEEDED(hr))
    {
        hr = pVoice->SetOutput(cpWavStream, TRUE);
    }
    if (SUCCEEDED(hr))
    {
        hr = pVoice->Speak( L"This audio file was created using SAPI five text to speech.", 0, NULL);
        pVoice->SetOutput(NULL, TRUE);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpWavStream->Close();
    }
    if (SUCCEEDED(hr))
    {
#ifndef _WIN32_WCE
        printf("Now I'll start the media player on the created file...");
#else
        OutputDebugString(L"Now I'll start the media player on the created file...");
#endif
        pVoice->Speak( L"Press the play button to play the recorded audio.", 0, NULL);
#ifndef _WIN32_WCE
        ::ShellExecute(NULL, "open", _T("Created.Wav"), NULL, NULL, SW_SHOWNORMAL);
#endif
    }
    return hr;
}

/****************************************************************************
* SpeakWithEvents *
*-----------------*
*   Description:
*       Speaks the provided text string and displays the words when the
*   they are spoken.
*
*   Returns:
*       HRESULT
*
*****************************************************************************/

HRESULT SpeakWithEvents(ISpVoice * pVoice, const WCHAR * psz)
{
    HRESULT hr = S_OK;
    hr = pVoice->SetInterest(SPFEI(SPEI_WORD_BOUNDARY) | SPFEI(SPEI_END_INPUT_STREAM), 0);
    if (SUCCEEDED(hr))
    {
        hr = pVoice->Speak(psz, SPF_ASYNC, NULL);
    }
    ULONG i = 0;
    bool fDone = false;
    while (SUCCEEDED(hr) && (!fDone))
    {
        hr = pVoice->WaitForNotifyEvent(INFINITE);
        if (SUCCEEDED(hr))
        {
            SPVOICESTATUS Stat;
            hr = pVoice->GetStatus(&Stat, NULL);
            if (SUCCEEDED(hr) && (Stat.dwRunningState & SPRS_DONE) == 0)
            {
                while (i < Stat.ulInputWordPos + Stat.ulInputWordLen)
                {
#ifndef _WIN32_WCE
                    putwchar(psz[i++]);
#else
                    WCHAR wsz[2];
                    wsz[0] = psz[i++];
                    wsz[1] = 0;
                    OutputDebugStringW(wsz);
#endif
                }
            }
            else
            {
#ifndef _WIN32_WCE
                wprintf(L"%s\n\n", psz + i);
#else
                RETAILMSG(TRUE,(L"%s\n\n", psz + i));
#endif
                fDone = true;
            }
        }
    }
    return hr;
}

/****************************************************************************
* main *
*------*
*   Description:
*       Entry point for sample program
*
*   Returns:
*       HRESULT
*
*****************************************************************************/

int _tmain(int argc, TCHAR* argv[])
{
    HRESULT hr;
#ifndef _WIN32_WCE
    wprintf(L"SAPI 5.0 Sample TTS Application\n\n");
#else
    OutputDebugString(L"SAPI 5.0 Sample TTS Application\n\n");
#endif
    hr = ::CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        CComPtr<ISpVoice> cpVoice;
        hr = cpVoice.CoCreateInstance(CLSID_SpVoice);
        if (SUCCEEDED(hr))
        {
            hr = cpVoice->Speak(L"This sample program uses basic text to speech operations.", 0, NULL);
        }
        if (SUCCEEDED(hr))
        {
#ifndef _WIN32_WCE
            wprintf(g_szMarkupDemo);
#else
            OutputDebugString(g_szMarkupDemo);
#endif
            hr = cpVoice->Speak(g_szMarkupDemo, 0, NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = SpeakWithEvents(cpVoice, L"This is a demonstration of how words can be displayed when they are spoken.");
        }
        if (SUCCEEDED(hr))
        {
            hr = MixWithWav(cpVoice);
        }
        if (SUCCEEDED(hr))
        {
            hr = CreateSampleFile(cpVoice);
        }
        cpVoice.Release();  // Must release prior to CoUninitialize or we'll GP Fault
        CoUninitialize();
    }
    if (FAILED(hr))
    {
#ifndef _WIN32_WCE
        wprintf(L"Sample program failed with error code 0x%x\n", hr);
#else
        RETAILMSG(TRUE,(L"Sample program failed with error code 0x%x\n", hr));
#endif
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\mkcevoice\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mkvoice.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\regcevoice\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mkvoice.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\mkcevoice\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
#define AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
#include <stdio.h>
#include <SPHelper.h>
#include <ttseng.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\regcevoice\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
#define AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
#include <stdio.h>
#include <SPHelper.h>
#include <ttseng.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\mkcevoice\ttseng.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Mon Jun 19 13:29:13 2000
 */
/* Compiler settings for .\ttseng.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __ttseng_h__
#define __ttseng_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __SampleTTSEngine_FWD_DEFINED__
#define __SampleTTSEngine_FWD_DEFINED__

#ifdef __cplusplus
typedef class SampleTTSEngine SampleTTSEngine;
#else
typedef struct SampleTTSEngine SampleTTSEngine;
#endif /* __cplusplus */

#endif 	/* __SampleTTSEngine_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "sapiddk.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_ttseng_0000
 * at Mon Jun 19 13:29:13 2000
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


typedef struct  VOICEITEM
    {
    LPCWSTR pText;
    ULONG ulTextLen;
    ULONG ulNumAudioBytes;
    BYTE __RPC_FAR *pAudio;
    }	VOICEITEM;



extern RPC_IF_HANDLE __MIDL_itf_ttseng_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ttseng_0000_v0_0_s_ifspec;


#ifndef __SAMPLETTSENGLib_LIBRARY_DEFINED__
#define __SAMPLETTSENGLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SAMPLETTSENGLib
 * at Mon Jun 19 13:29:13 2000
 * using MIDL 3.02.88
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SAMPLETTSENGLib;

EXTERN_C const CLSID CLSID_SampleTTSEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("A832755E-9C2A-40b4-89B2-3A92EE705852")
SampleTTSEngine;
#endif
#endif /* __SAMPLETTSENGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\mkcevoice\ttseng_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.02.88 */
/* at Mon Jun 19 13:29:13 2000
 */
/* Compiler settings for .\ttseng.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_SAMPLETTSENGLib = {0x7192AA2F,0xF759,0x43e9,{0x91,0xE7,0x22,0x63,0x71,0xEF,0x6B,0x2F}};


const CLSID CLSID_SampleTTSEngine = {0xA832755E,0x9C2A,0x40b4,{0x89,0xB2,0x3A,0x92,0xEE,0x70,0x58,0x52}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\engines\tts\regcevoice\regcevoice.cpp ===
/******************************************************************************
* mkvoice.cpp *
*-------------*
*   This application assembles a simple voice font for the sample TTS engine.
*
******************************************************************************/
//#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <sapi.h>
#include <sphelper.h>
#include <spddkhlp.h>
#include <ttseng.h>
#include <ttseng_i.c>

int _tmain(int argc, TCHAR* argv[])
{
//    USES_CONVERSION;
//    static const DWORD dwVersion = { 1 };
//    ULONG ulNumWords = 0;
    HRESULT hr = S_OK;

    //--- Check args
    if( argc != 2 )
    {
        RETAILMSG(TRUE,( _T("%s"), _T("Usage: > s regcevoice [[in]VoiceFile]\n")));
    	hr = E_INVALIDARG;
    }
    else
    {
    ::CoInitialize( NULL );
/*
        //--- Open word list file and create output voice file
        FILE* hWordList  = fopen( argv[1], "r" );
        FILE* hVoiceFile = fopen( argv[2], "wb" );

        if( hWordList && hVoiceFile )
        {
            //--- Write file version and leave space for word count
            if( !fwrite( &dwVersion, sizeof(dwVersion), 1, hVoiceFile ) ||
                 fseek( hVoiceFile, 4, SEEK_CUR ) )
            {
                hr = E_FAIL;
            }

            //--- Get each entry
            char WordFileName[MAX_PATH];
            while( SUCCEEDED( hr ) && fgets( WordFileName, MAX_PATH, hWordList ) )
            {
                ULONG ulTextLen = strlen( WordFileName );
                if( WordFileName[ulTextLen-1] == '\n' )
                {
                    WordFileName[--ulTextLen] = NULL;
                }
                //--- Include NULL character when writing to the file
                ulTextLen = (ulTextLen+1) * sizeof(WCHAR);

                if( fwrite( &ulTextLen, sizeof(ulTextLen), 1, hVoiceFile ) &&
                    fwrite( T2W(WordFileName), ulTextLen, 1, hVoiceFile ) )
                {
                    ++ulNumWords;
                    //--- Open the wav data
                    ISpStream* pStream;
                    strcat( WordFileName, ".wav" );
                    hr = SPBindToFile( WordFileName, SPFM_OPEN_READONLY, &pStream );
                    if( SUCCEEDED( hr ) )
                    {
                        CSpStreamFormat Fmt;
                        Fmt.AssignFormat(pStream);
                        if( Fmt.ComputeFormatEnum() == SPSF_11kHz16BitMono )
                        {
                            STATSTG Stat;
                            hr = pStream->Stat( &Stat, STATFLAG_NONAME );
                            ULONG ulNumBytes = Stat.cbSize.LowPart;

                            //--- Write the number of audio bytes
                            if( SUCCEEDED( hr ) &&
                                fwrite( &ulNumBytes, sizeof(ulNumBytes), 1, hVoiceFile ) )
                            {
                                BYTE* Buff = (BYTE*)alloca( ulNumBytes );
                                if( SUCCEEDED( hr = pStream->Read( Buff, ulNumBytes, NULL ) ) )
                                {
                                    //--- Write the audio samples
                                    if( !fwrite( Buff, 1, ulNumBytes, hVoiceFile ) )
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            printf( "Input file: %s has wrong wav format.", WordFileName );
                        }
                        pStream->Release();
                    }
                }
                else
                {
                	hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        //--- Write word count
        if( SUCCEEDED( hr ) )
        {
            if( fseek( hVoiceFile, sizeof(dwVersion), SEEK_SET ) ||
                !fwrite( &ulNumWords, sizeof(ulNumWords), 1, hVoiceFile ) )
            {
                hr = E_FAIL;
            }
        }
*/
        //--- Register the new voice file
        //    The section below shows how to programatically create a token for
        //    the new voice and set its attributes.
        if( SUCCEEDED( hr ) )
        {
            CComPtr<ISpObjectToken> cpToken;
            CComPtr<ISpDataKey> cpDataKeyAttribs;
            hr = SpCreateNewTokenEx(
                    SPCAT_VOICES, 
                    L"SampleTTSVoice", 
                    &CLSID_SampleTTSEngine, 
                    L"Sample TTS Voice", 
                    0x409, 
                    L"Sample TTS Voice", 
                    &cpToken,
                    &cpDataKeyAttribs);

            //--- Set additional attributes for searching and the path to the
            //    voice data file we just created.
            if (SUCCEEDED(hr))
            {
                hr = cpDataKeyAttribs->SetStringValue(L"Gender", L"Male");
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyAttribs->SetStringValue(L"Language", L"409");
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyAttribs->SetStringValue(L"Age", L"Adult");
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
                }

                TCHAR szFullPath[MAX_PATH];
                _tcscpy(szFullPath, _T("\\windows\\"));
                _tcscat(szFullPath, argv[1]);
/*
                if (SUCCEEDED(hr) && _fullpath(szFullPath, argv[2], MAX_PATH) == NULL)
                {
                    hr = SPERR_NOT_FOUND;
                }
*/
                if (SUCCEEDED(hr))
                {
                    USES_CONVERSION;
                    hr = cpToken->SetStringValue(L"VoiceData", T2W(szFullPath));
                }
            }
        }
/*
        //--- Cleanup
        if( hWordList  )
        {
            fclose( hWordList );
        }
        if( hVoiceFile )
        {
            fclose( hVoiceFile );
        }
*/
        ::CoUninitialize();
    }
	return FAILED( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\speak\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__46EAD868_32F1_11D2_9602_00C04F8EE628__INCLUDED_)
#define AFX_STDAFX_H__46EAD868_32F1_11D2_9602_00C04F8EE628__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__46EAD868_32F1_11D2_9602_00C04F8EE628__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\talkback\talkback.cpp ===
#include <windows.h>
#include <sapi.h>
#include <stdio.h>
#include <string.h>
#include <atlbase.h>
#include "sphelper.h"
//Copyright (c) Microsoft Corporation. All rights reserved.

inline HRESULT BlockForResult(ISpRecoContext * pRecoCtxt, ISpRecoResult ** ppResult)
{
    HRESULT hr = S_OK;
	CSpEvent event;

    while (SUCCEEDED(hr) &&
           SUCCEEDED(hr = event.GetFrom(pRecoCtxt)) &&
           hr == S_FALSE)
    {
        hr = pRecoCtxt->WaitForNotifyEvent(INFINITE);
    }

    *ppResult = event.RecoResult();
    if (*ppResult)
    {
        (*ppResult)->AddRef();
    }

    return hr;
}

const WCHAR * StopWord()
{
    const WCHAR * pchStop;
    
    LANGID LangId = ::SpGetUserDefaultUILanguage();

    switch (LangId)
    {
        case MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT):
            pchStop = L"\x7d42\x4e86\\\x30b7\x30e5\x30fc\x30ea\x30e7\x30fc/\x3057\x3085\x3046\x308a\x3087\x3046";;
            break;

        default:
            pchStop = L"Stop";
            break;
    }

    return pchStop;
}
            
int _tmain(int argc, TCHAR* argv[])
{
    HRESULT hr = E_FAIL;
    bool fUseTTS = true;            // turn TTS play back on or off
    bool fReplay = true;            // turn Audio replay on or off

    TCHAR   szFileName[256];

    // Process optional arguments
    if (argc > 1)
    {
        int i;

        for (i = 1; i < argc; i++)
        {
            if (_tcsicmp(argv[i], _T("-noTTS")) == 0)
            {
                fUseTTS = false;
                continue;
            }
            if (_tcsicmp(argv[i], _T("-noReplay")) == 0)
            {
                fReplay = false;
                continue;
            }
            if (_tcsicmp(argv[i], _T("-f")) == 0)
            {
                if( ++i < argc )
                {
                    _tcscpy(szFileName, argv[i]);
                    continue;
                }
            }
#ifndef _WIN32_WCE
            printf ("Usage: %s [-noTTS] [-noReplay] \n", argv[0]);
#else
            RETAILMSG(TRUE,(_T("Usage: %s [-noTTS] [-noReplay] \n"), argv[0]));
#endif
            return hr;
        }
    }

    if (SUCCEEDED(hr = :: CoInitializeEx(NULL,COINIT_MULTITHREADED)))
    {
        {
            CComPtr<ISpRecoContext> cpRecoCtxt;
            CComPtr<ISpRecoGrammar> cpGrammar;
            CComPtr<ISpVoice> cpVoice;
            hr = cpRecoCtxt.CoCreateInstance(CLSID_SpSharedRecoContext);
            if(SUCCEEDED(hr))
            {
                hr = cpRecoCtxt->GetVoice(&cpVoice);
            }
           
            if (!cpRecoCtxt || !cpVoice)
            {
                hr = E_FAIL;
            }
            if(SUCCEEDED(hr))
            {
                hr = cpRecoCtxt->SetNotifyWin32Event();
            }
            if(SUCCEEDED(hr))
            {
                hr = cpRecoCtxt->SetInterest(SPFEI(SPEI_RECOGNITION), SPFEI(SPEI_RECOGNITION));
            }
            if(SUCCEEDED(hr))
            {
                hr = cpRecoCtxt->SetAudioOptions(SPAO_RETAIN_AUDIO, NULL, NULL);
            }
            if(SUCCEEDED(hr))
            {
                hr = cpRecoCtxt->CreateGrammar(0, &cpGrammar);
            }
            //debug
//            if(SUCCEEDED(hr))
//            {
//                hr = cpGrammar->LoadCmdFromFile( szFileName, SPLO_STATIC );
//            }
            //debug
            if(SUCCEEDED(hr))
            {
                hr = cpGrammar->LoadDictation(NULL, SPLO_STATIC);
            }
            if(SUCCEEDED(hr))
            {
                hr = cpGrammar->SetDictationState(SPRS_ACTIVE);
            }
            if(SUCCEEDED(hr))
            {
                USES_CONVERSION;
                            
                const WCHAR * const pchStop = StopWord();
                CComPtr<ISpRecoResult> cpResult;

#ifndef _WIN32_WCE
                printf( "I will repeat everything you say.\nSay \"%s\" to exit.\n", W2A(pchStop) );
#else
                RETAILMSG(TRUE,( _T("I will repeat everything you say.\nSay \"%s\" to exit.\n"), pchStop));
#endif

                while (SUCCEEDED(hr = BlockForResult(cpRecoCtxt, &cpResult)))
                {
                    cpGrammar->SetDictationState( SPRS_INACTIVE );

                    CSpDynamicString dstrText;

                    if (SUCCEEDED(cpResult->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, 
                                                    TRUE, &dstrText, NULL)))
                    {
#ifndef _WIN32_WCE
                        printf("I heard:  %s\n", W2A(dstrText));
#else
                        RETAILMSG(TRUE,( _T("I heard:  %s\n"), dstrText));
#endif

                        if (fUseTTS)
                        {
                            cpVoice->Speak( L"I heard", SPF_ASYNC, NULL);
                            cpVoice->Speak( dstrText, SPF_ASYNC, NULL );
                        }

                        if (fReplay)
                        {
                            if (fUseTTS)
                                cpVoice->Speak( L"when you said", SPF_ASYNC, NULL);
                            else
                            {
#ifndef _WIN32_WCE
                                printf ("\twhen you said...\n");
#else
                                RETAILMSG(TRUE,( _T("\twhen you said...\n")));
#endif
                            }
                            cpResult->SpeakAudio(NULL, 0, NULL, NULL);
                       }

                       cpResult.Release();
                    }
                    if (_wcsicmp(dstrText, pchStop) == 0)
                    {
                        break;
                    }
                    
                    cpGrammar->SetDictationState( SPRS_ACTIVE );
                } 
            }
        }
        ::CoUninitialize();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\regdata\regdata.cpp ===
#include <tchar.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <sphelper.h>
//#include <ms1033srmap.h>
//#include <ms1033srvendormap.h>
#include <ms1033ttsmap.h>
//#include <ms1033ltsmap.h>

// This code does not ship

// This code creates the registry entries for the vendor and lts lexicons. The lexicon
// datafiles registered here are the ones checked in the slm source tree. This is not
// done using a reg file because we need to compute the absolute path of the datafiles
// which can be different on different machines because of different root slm directories.

CSpUnicodeSupport   g_Unicode;

HRESULT AddPhoneConv(
    WCHAR *pszTokenKeyName, 
    WCHAR *pszDescription, 
    WCHAR *pszLanguage,
    WCHAR *pszAttribs, 
    const CLSID *pclsid,
    WCHAR *pszPhoneMap)
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = SpCreateNewTokenEx(
            SPCAT_PHONECONVERTERS,
            pszTokenKeyName,
            pclsid, 
            pszDescription,
            0,
            NULL,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr) && pszAttribs != NULL)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Type", pszAttribs);
    }

    if (SUCCEEDED(hr) && pszLanguage != NULL)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", pszLanguage);
    }

    if (SUCCEEDED(hr) && pszPhoneMap)
    {
        hr = cpToken->SetStringValue(L"PhoneMap", pszPhoneMap);
    }
            
    return hr;
}

int wmain()
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    CComPtr<ISpObjectTokenCategory> cpPhoneConvCategory;
    if (SUCCEEDED(hr))
    {
        hr = SpGetCategoryFromId(SPCAT_PHONECONVERTERS, &cpPhoneConvCategory, TRUE);
        if (SUCCEEDED(hr))
        {
            CComPtr<ISpDataKey> cpTokens;

            if (SUCCEEDED(cpPhoneConvCategory->OpenKey(L"Tokens", &cpTokens)))
            {
                // Delete old phone converters.
                WCHAR * pszSubKeyName = NULL;
                while (SUCCEEDED(cpTokens->EnumKeys(0, &pszSubKeyName)))
                {
                    // Since NT doesn't allow recursive delete, need to delete Attributes subkey first.
                    {
                        CComPtr<ISpDataKey> cpPhoneKey;

                        hr = cpTokens->OpenKey(pszSubKeyName, &cpPhoneKey);

                        if (SUCCEEDED(hr))
                            hr = cpPhoneKey->DeleteKey(L"Attributes");
                    }

                    if (SUCCEEDED(hr))
                        hr = cpTokens->DeleteKey(pszSubKeyName);

                    CoTaskMemFree(pszSubKeyName);

                    if (FAILED(hr))
                        break;
                }
            }
        }
    }
    cpPhoneConvCategory.Release();

    if (SUCCEEDED(hr))
        hr = AddPhoneConv(L"English", L"English Phone Converter", L"409", NULL, &CLSID_SpPhoneConverter, pszms1033ttsmap);

    CoUninitialize();

    return SUCCEEDED(hr)
                ? 0
                : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\public\sdk\samples\cpp\speak\speak.cpp ===
// speak.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "atlbase.h"
#include <sphelper.h>

int _tmain(int argc, TCHAR* argv[])
{
    HRESULT hr=S_FALSE;
    WCHAR wcBuff[MAX_PATH];
    int i;

    if( argc < 2 )
    {
        //--- Give out a helpstring
        wcscpy( wcBuff, L"This is a simple sample sentence." );
    }
    else
    {
		for( i = 1, wcBuff[0] = 0; i < argc; ++i )
		{
			wcscat( wcscat( wcBuff, argv[i] ), L" " );
		}
    }

    if( SUCCEEDED( hr = CoInitialize( NULL ) ) )
    {
        //--- Create the voice
        CComPtr<ISpVoice> cpVoice;
        hr = cpVoice.CoCreateInstance(CLSID_SpVoice);
        if( SUCCEEDED( hr ) )
        {
            hr = cpVoice->Speak(wcBuff, 0, NULL);
//            if( SUCCEEDED( hr ) )
//            {
//                hr = cpVoice->WaitUntilDone(INFINITE);
//            }
        }
        if (cpVoice)
            cpVoice.Release();

        CoUninitialize();
    }

	if (FAILED(hr)) return 1;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\mkcevoice\mkcevoice.cpp ===
/******************************************************************************
* mkvoice.cpp *
*-------------*
*   This application assembles a simple voice font for the sample TTS engine.
*
******************************************************************************/
#include "stdafx.h"
//#include <ttseng_i.c>
#include <direct.h>

int main(int argc, char* argv[])
{
    USES_CONVERSION;
    static const DWORD dwVersion = { 1 };
    ULONG ulNumWords = 0;
    HRESULT hr = S_OK;

    //--- Check args
    if( argc != 3 )
    {
        printf( "%s", "Usage: > mkvoice [[in]word list file] [[out]voice file]\n" );
    	hr = E_INVALIDARG;
    }
    else
    {
        ::CoInitialize( NULL );

        //--- Open word list file and create output voice file
        FILE* hWordList  = fopen( argv[1], "r" );
        FILE* hVoiceFile = fopen( argv[2], "wb" );

        if( hWordList && hVoiceFile )
        {
            //--- Write file version and leave space for word count
            if( !fwrite( &dwVersion, sizeof(dwVersion), 1, hVoiceFile ) ||
                 fseek( hVoiceFile, 4, SEEK_CUR ) )
            {
                hr = E_FAIL;
            }

            //--- Get each entry
            char WordFileName[MAX_PATH];
            while( SUCCEEDED( hr ) && fgets( WordFileName, MAX_PATH, hWordList ) )
            {
                ULONG ulTextLen = strlen( WordFileName );
                if( WordFileName[ulTextLen-1] == '\n' )
                {
                    WordFileName[--ulTextLen] = NULL;
                }
                //--- Include NULL character when writing to the file
                ulTextLen = (ulTextLen+1) * sizeof(WCHAR);

                if( fwrite( &ulTextLen, sizeof(ulTextLen), 1, hVoiceFile ) &&
                    fwrite( T2W(WordFileName), ulTextLen, 1, hVoiceFile ) )
                {
                    ++ulNumWords;
                    //--- Open the wav data
                    ISpStream* pStream;
                    strcat( WordFileName, ".wav" );
                    hr = SPBindToFile( WordFileName, SPFM_OPEN_READONLY, &pStream );
                    if( SUCCEEDED( hr ) )
                    {
                        CSpStreamFormat Fmt;
                        Fmt.AssignFormat(pStream);
                        if( Fmt.ComputeFormatEnum() == SPSF_11kHz16BitMono )
                        {
                            STATSTG Stat;
                            hr = pStream->Stat( &Stat, STATFLAG_NONAME );
                            ULONG ulNumBytes = Stat.cbSize.LowPart;

                            //--- Write the number of audio bytes
                            if( SUCCEEDED( hr ) &&
                                fwrite( &ulNumBytes, sizeof(ulNumBytes), 1, hVoiceFile ) )
                            {
                                BYTE* Buff = (BYTE*)alloca( ulNumBytes );
                                if( SUCCEEDED( hr = pStream->Read( Buff, ulNumBytes, NULL ) ) )
                                {
                                    //--- Write the audio samples
                                    if( !fwrite( Buff, 1, ulNumBytes, hVoiceFile ) )
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            printf( "Input file: %s has wrong wav format.", WordFileName );
                        }
                        pStream->Release();
                    }
                }
                else
                {
                	hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        //--- Write word count
        if( SUCCEEDED( hr ) )
        {
            if( fseek( hVoiceFile, sizeof(dwVersion), SEEK_SET ) ||
                !fwrite( &ulNumWords, sizeof(ulNumWords), 1, hVoiceFile ) )
            {
                hr = E_FAIL;
            }
        }
        //--- Cleanup
        if( hWordList  )
        {
            fclose( hWordList );
        }
        if( hVoiceFile )
        {
            fclose( hVoiceFile );
        }
        ::CoUninitialize();
    }
	return FAILED( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\mkcevoice\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mkvoice.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\mkcevoice\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
#define AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
#include <stdio.h>
#include <SPHelper.h>
#include <ttseng.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\regvoices\regvoices.cpp ===
#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "sapi.h"
#include "sphelper.h"
#include "spddkhlp.h"
#include "spttseng.h"
#include "spttseng_i.c"
#include "ms1033ltsmap.h" // BUGBUG: Move to somewhere... else.


#ifdef _WIN32_WCE
#define GOTO_LRETURN(hres)	{RETAILMSG(1, (_T("File: %s Line :%d, hr=%08x\n"),_T(__FILE__),__LINE__, hres)); goto LReturn;}
#define MARK(text)			{RETAILMSG(1, (_T("%s Line :%d\n"), text,__LINE__));}
#else
#define GOTO_LRETURN(hres)	{wprintf(L"Line :%d, hr=%08x\n",__LINE__, hres); goto LReturn;}
#define MARK(text)			{wprintf(L"%s Line :%d\n", text,__LINE__);}
#endif

// This code does not ship

// This code creates the registry entries for the TTS voices. The
// datafiles registered here are the ones checked in the slm source tree. This is not
// done using a reg file because we need to compute the absolute path of the datafiles
// which can be different on different machines because of different root slm directories.

#ifndef _WIN32_WCE
#define DIRS_TO_GO_BACK_VOICE      3        // Back 3 levels to 'Voices" directory
#define DIRS_TO_GO_BACK_LEX        6        // Back 3 levels to Lex Data directory
#else
#define DIRS_TO_GO_BACK_VOICE      1        // Back 3 levels to 'Voices" directory
#define DIRS_TO_GO_BACK_LEX        1        // Back 3 levels to Lex Data directory
#endif

CSpUnicodeSupport g_Unicode;

/*****************************************************************************
* CreateLexSubKey  *
*------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateLexSubKey(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    const CLSID * pclsid,
    const WCHAR * pszFilePath, 
    const WCHAR * pszLexName,
    const WCHAR * pszPhoneMap)
{
    HRESULT hr = S_OK;

    //---------------------------------------
    // Create the lex sub-key (Lex or LTS)
    //---------------------------------------
    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                cpSubToken, 
                pclsid, 
                NULL,
                0,
                NULL,
                NULL);
    }
    
    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Lex DATA file location
        //--------------------------------
        wcscpy(szLexDataPath, pszFilePath);
        wcscat(szLexDataPath, pszLexName);

        hr = cpSubToken->SetStringValue(L"DataFile", szLexDataPath);
    }

    if (SUCCEEDED(hr) && pszPhoneMap)
    {
        CComPtr<ISpObjectToken> cpPhoneToken;

        if (SUCCEEDED(hr))
            hr = SpGetSubTokenFromToken(cpSubToken, L"PhoneConverter", &cpPhoneToken, TRUE);

        if (SUCCEEDED(hr))
            hr = SpSetCommonTokenData(cpPhoneToken, &CLSID_SpPhoneConverter, NULL, 0, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = cpPhoneToken->SetStringValue(L"PhoneMap", pszPhoneMap);
    }

    return hr;
}

/*****************************************************************************
* CreateUISubKey  *
*-----------------*
*   Description:
*   Creates the UI SubKey under a voice.
*       
********************************************************************** AH ***/
HRESULT CreateUISubKey(
    ISpObjectToken * pToken,
    const CLSID * pclsid)
{
    HRESULT hr = S_OK;

    //-----------------------
    // Create the UI sub-key 
    //-----------------------
    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, L"UI", &cpSubToken, TRUE);

    //--------------------------------------
    // Create the EngineProperties sub-key
    //--------------------------------------
    CComPtr<ISpObjectToken> cpSubSubToken;
    if ( SUCCEEDED( hr ) )
    {
        hr = SpGetSubTokenFromToken( cpSubToken, L"EngineProperties", &cpSubSubToken, TRUE );
    }

    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                cpSubSubToken, 
                pclsid, 
                NULL,
                0,
                NULL,
                NULL);
    }

    return hr;
}

/*****************************************************************************
* CreateVoiceSubKey  *
*--------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateVoiceSubKey(
    const WCHAR * pszSubKeyName, 
    const WCHAR  * pszDescription,
    BOOL fVendorDefault, 
    const WCHAR * pszGender,
    const WCHAR * pszAge,
    const WCHAR * pszVoicePath, 
    const WCHAR * pszVoiceName,
    const WCHAR * pszLexPath)
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = SpCreateNewTokenEx(
            SPCAT_VOICES, 
            pszSubKeyName, 
            &CLSID_MSVoiceData, 
            pszDescription,
            0x409,
            pszDescription,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Name", pszSubKeyName);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Gender", pszGender);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Age", pszAge);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", L"409");
    }

    if (SUCCEEDED(hr) && fVendorDefault)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"VendorPreferred", L"");
    }
    
    WCHAR szVoiceDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DATA file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);
        wcscat(szVoiceDataPath, L".vdt");

        hr = cpToken->SetStringValue(L"VoiceData", szVoiceDataPath);
    }
    
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DEF file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);
        wcscat(szVoiceDataPath, L".vdf");

        hr = cpToken->SetStringValue(L"VoiceDef", szVoiceDataPath);
    }

    //------------------------------------------------
    // Register TTS lexicons
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"Lex", &CLSID_SpCompressedLexicon, pszLexPath, L"LTTS1033.LXA", NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"LTS", &CLSID_SpLTSLexicon, pszLexPath, L"r1033tts.lxa", pszms1033ltsmap);
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = CreateUISubKey( cpToken, &CLSID_SpTtsEngUI );
    }

    return hr;
}

/*****************************************************************************
* main  *
*-------*
*   Description:
*    Locate the abs path to the Mary, Mike and Sam voices
*    and register them in the system registry.
*       
********************************************************************** MC ***/
int wmain()
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);

    //----------------------------------------
    // Get the exe's location...
    //----------------------------------------
    WCHAR szVoiceDataPath[MAX_PATH];
    if (!g_Unicode.GetModuleFileName(NULL, szVoiceDataPath, MAX_PATH))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        wcscpy(szLexDataPath, szVoiceDataPath);
    }

    //----------------------------------------
    // ...and derive abs path to VOICE data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<sapi5>\Src\TTS\msttsdrv\voices\RegVoices\debug_x86\RegVoices.exe"
        // Data is at "<sapi5>\Src\TTS\msttsdrv\voices\"
        WCHAR * psz;
        psz = szVoiceDataPath;
        
        for (int i = 0; i < DIRS_TO_GO_BACK_VOICE; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szVoiceDataPath;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        wcscat(szVoiceDataPath, L"\\");
    }
#ifdef _WIN32_WCE
	MARK(szVoiceDataPath);
//    if (SUCCEEDED(hr))
//    {
//        wcscat(szVoiceDataPath, L"voices\\");
//    }
//	MARK(szVoiceDataPath);
#endif	// _WIN32_WCE

    //----------------------------------------
    // Derive abs path to LEX data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<sapi5>\Src\TTS\msttsdrv\voices\RegVoices\debug_x86\RegVoices.exe"
        // Data is at "<sapi5>\Src\lexicon\data\"
        WCHAR * psz = szLexDataPath;
        for (int i = 0; i < DIRS_TO_GO_BACK_LEX; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szLexDataPath;
            }
        }
    }
	MARK(szLexDataPath);
    if (SUCCEEDED(hr))
    {
        wcscat(szLexDataPath, L"\\");
    }
	MARK(szLexDataPath);

    //------------------------------------------------
    // ...then register the three Microsoft voices..
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSMary", 
                               L"MS Mary", 
                               TRUE,
                               L"Female",
                               L"Adult",
                               szVoiceDataPath,
                               L"Mary",
                               szLexDataPath);
    }
/*    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSMike", 
                               L"MS Mike", 
                               FALSE,
                               L"Male", 
                               L"Adult",
                               szVoiceDataPath, 
                               L"Mike",
                               szLexDataPath);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSSam", 
                               L"MS Sam", 
                               FALSE,
                               L"Male", 
                               L"Adult",
                               szVoiceDataPath, 
                               L"Sam",
                               szLexDataPath);
    }
*/
    CoUninitialize();

    if (FAILED(hr))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\rundlltest\rundll.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

int wmain(int argc, WCHAR *argv[])
{
    HRESULT hr=S_FALSE;

    WCHAR szApplication[MAX_PATH];
    WCHAR szCommandLine[MAX_PATH];

    wcscpy(szApplication, L"");
    wcscpy(szCommandLine, L"");

    for (int i=0; i<argc; i++)
    {
        RETAILMSG(1, (_T("argv[%i]=%s \n"), i, argv[i]));
    }

    if (argc<2) 
    {
        RETAILMSG(1, (_T("Usage: %s application dll,proc\n"), argv[0]));
        return 1;
    }

    wcscat(szApplication, argv[1]);

    for (i=2; i<argc; i++)
    {
        wcscat(szCommandLine, argv[i]);
        wcscat(szCommandLine, L" ");
    }

    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    PROCESS_INFORMATION pi;

    RETAILMSG(1, (_T("szApplication: %s\nszCommandLine: %s\n"), szApplication,szCommandLine));

    BOOL fProcessCreated = ::CreateProcess(
                                            szApplication, 
                                            szCommandLine,
                                            NULL,
                                            NULL,
                                            FALSE, 
                                            0,
                                            NULL,
                                            NULL,
                                            &si,
                                            &pi);
    if (!fProcessCreated)
    {
        LONG res=::GetLastError();
        hr = HRESULT_FROM_WIN32(res);
    }

    RETAILMSG(1, (_T("File: %s Line :%d, hr=%08x\n"),_T(__FILE__),__LINE__, hr));

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\regcevoice\regcevoice.cpp ===
/******************************************************************************
* mkvoice.cpp *
*-------------*
*   This application assembles a simple voice font for the sample TTS engine.
*
******************************************************************************/
//#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <sapi.h>
#include <sphelper.h>
#include <spddkhlp.h>
#include <ttseng.h>
#include <ttseng_i.c>

int _tmain(int argc, TCHAR* argv[])
{
//    USES_CONVERSION;
//    static const DWORD dwVersion = { 1 };
//    ULONG ulNumWords = 0;
    HRESULT hr = S_OK;

    //--- Check args
    if( argc != 2 )
    {
        RETAILMSG(TRUE,( _T("%s"), _T("Usage: > s regcevoice [[in]VoiceFile]\n")));
    	hr = E_INVALIDARG;
    }
    else
    {
    ::CoInitialize( NULL );
/*
        //--- Open word list file and create output voice file
        FILE* hWordList  = fopen( argv[1], "r" );
        FILE* hVoiceFile = fopen( argv[2], "wb" );

        if( hWordList && hVoiceFile )
        {
            //--- Write file version and leave space for word count
            if( !fwrite( &dwVersion, sizeof(dwVersion), 1, hVoiceFile ) ||
                 fseek( hVoiceFile, 4, SEEK_CUR ) )
            {
                hr = E_FAIL;
            }

            //--- Get each entry
            char WordFileName[MAX_PATH];
            while( SUCCEEDED( hr ) && fgets( WordFileName, MAX_PATH, hWordList ) )
            {
                ULONG ulTextLen = strlen( WordFileName );
                if( WordFileName[ulTextLen-1] == '\n' )
                {
                    WordFileName[--ulTextLen] = NULL;
                }
                //--- Include NULL character when writing to the file
                ulTextLen = (ulTextLen+1) * sizeof(WCHAR);

                if( fwrite( &ulTextLen, sizeof(ulTextLen), 1, hVoiceFile ) &&
                    fwrite( T2W(WordFileName), ulTextLen, 1, hVoiceFile ) )
                {
                    ++ulNumWords;
                    //--- Open the wav data
                    ISpStream* pStream;
                    strcat( WordFileName, ".wav" );
                    hr = SPBindToFile( WordFileName, SPFM_OPEN_READONLY, &pStream );
                    if( SUCCEEDED( hr ) )
                    {
                        CSpStreamFormat Fmt;
                        Fmt.AssignFormat(pStream);
                        if( Fmt.ComputeFormatEnum() == SPSF_11kHz16BitMono )
                        {
                            STATSTG Stat;
                            hr = pStream->Stat( &Stat, STATFLAG_NONAME );
                            ULONG ulNumBytes = Stat.cbSize.LowPart;

                            //--- Write the number of audio bytes
                            if( SUCCEEDED( hr ) &&
                                fwrite( &ulNumBytes, sizeof(ulNumBytes), 1, hVoiceFile ) )
                            {
                                BYTE* Buff = (BYTE*)alloca( ulNumBytes );
                                if( SUCCEEDED( hr = pStream->Read( Buff, ulNumBytes, NULL ) ) )
                                {
                                    //--- Write the audio samples
                                    if( !fwrite( Buff, 1, ulNumBytes, hVoiceFile ) )
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            printf( "Input file: %s has wrong wav format.", WordFileName );
                        }
                        pStream->Release();
                    }
                }
                else
                {
                	hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        //--- Write word count
        if( SUCCEEDED( hr ) )
        {
            if( fseek( hVoiceFile, sizeof(dwVersion), SEEK_SET ) ||
                !fwrite( &ulNumWords, sizeof(ulNumWords), 1, hVoiceFile ) )
            {
                hr = E_FAIL;
            }
        }
*/
        //--- Register the new voice file
        //    The section below shows how to programatically create a token for
        //    the new voice and set its attributes.
        if( SUCCEEDED( hr ) )
        {
            CComPtr<ISpObjectToken> cpToken;
            CComPtr<ISpDataKey> cpDataKeyAttribs;
            hr = SpCreateNewTokenEx(
                    SPCAT_VOICES, 
                    L"SampleTTSVoice", 
                    &CLSID_SampleTTSEngine, 
                    L"Sample TTS Voice", 
                    0x409, 
                    L"Sample TTS Voice", 
                    &cpToken,
                    &cpDataKeyAttribs);

            //--- Set additional attributes for searching and the path to the
            //    voice data file we just created.
            if (SUCCEEDED(hr))
            {
                hr = cpDataKeyAttribs->SetStringValue(L"Gender", L"Male");
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyAttribs->SetStringValue(L"Language", L"409");
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyAttribs->SetStringValue(L"Age", L"Adult");
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
                }

                TCHAR szFullPath[MAX_PATH];
                _tcscpy(szFullPath, _T("\\windows\\"));
                _tcscat(szFullPath, argv[1]);
/*
                if (SUCCEEDED(hr) && _fullpath(szFullPath, argv[2], MAX_PATH) == NULL)
                {
                    hr = SPERR_NOT_FOUND;
                }
*/
                if (SUCCEEDED(hr))
                {
                    USES_CONVERSION;
                    hr = cpToken->SetStringValue(L"VoiceData", T2W(szFullPath));
                }
            }
        }
/*
        //--- Cleanup
        if( hWordList  )
        {
            fclose( hWordList );
        }
        if( hVoiceFile )
        {
            fclose( hVoiceFile );
        }
*/
        ::CoUninitialize();
    }
	return FAILED( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\regcevoice\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mkvoice.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\regcevoice\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
#define AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
#include <stdio.h>
#include <SPHelper.h>
#include <ttseng.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__152AD93A_F366_47F7_B0EF_5E609435ECBB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\basictts\basictts.cpp ===
/****************************************************************************
*
*   BasicTTS.cpp
*
*   Sample text-to-speech program that demonstrates the basics of using the
*   SAPI 5.0 TTS APIs.
*
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <atlbase.h>
#ifndef _WIN32_WCE
#include <shellapi.h>
#endif
#include <sapi.h>

//--- Const Defines----------------------------------------------------------

const static WCHAR g_szMarkupDemo[] =
    L"<VOICE OPTIONAL=\"Female\">Tags can be used to change attributes such as\n"
    L"    <VOICE OPTIONAL=\"Male\">the voice font that is used,</VOICE>\n"
    L"    the <VOLUME LEVEL=\"65\">volume of the voice</VOLUME>\n"
    L"    and other attributes of speech such as pitch and rate.\n"
    L"</VOICE>\n\n";


/****************************************************************************
* MixWithWav *
*------------*
*   Description:
*       Plays an introductory audio file followed by synthetic speech.
*
*   Returns:
*       HRESULT from Speak call or
*       S_FALSE if the Intro.Wav file is not present
*
*****************************************************************************/

HRESULT MixWithWav(ISpVoice * pVoice)
{
    HRESULT hr = S_OK;
    OutputDebugString(L"Now a sample of mixed wave files and generated speech.\n\n");
    hr = pVoice->Speak(L"Intro.Wav", 0, SPF_IS_FILENAME | SPF_ASYNC, NULL);
    if (hr == STG_E_FILENOTFOUND)
    {
        OutputDebugStringW(L"ERROR:  Can not find file Intro.Wav.  Wave file mixing sample will be skipped.\n\n");
        hr = S_FALSE;   // Return success code so sample will continue...
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = pVoice->Speak(L"<VOICE OPTIONAL=\"Male\">one hundred eighty dollars and twenty seven cents.</VOICE>", 0, 0, NULL );
        }
    }
    return hr;
}

/****************************************************************************
* CreateSampleFile *
*------------------*
*   Description:
*       Creates a file named Created.Wav using a TTS voice and then starts
*   the currently registered audio playback application.
*
*   Returns:
*       HRESULT
*
*****************************************************************************/

HRESULT CreateSampleFile(ISpVoice * pVoice)
{
    HRESULT hr = S_OK;
    CComPtr<ISpWavStream> cpWavStream;
    hr = cpWavStream.CoCreateInstance(CLSID_SpWavStream);
    if (SUCCEEDED(hr))
    {
        hr = cpWavStream->Create(L"Created.Wav", SPDFID_22kHz16BitMono, 0);
    }
    if (SUCCEEDED(hr))
    {
        hr = pVoice->SetOutput(NULL, cpWavStream, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = pVoice->Speak( L"This audio file was created using SAPI five text to speech.", 0, 0, NULL);
        pVoice->SetOutput(NULL,  NULL, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpWavStream->Close();
    }
    if (SUCCEEDED(hr))
    {
        OutputDebugString(L"Now I'll start the media player on the created file...");
        pVoice->Speak( L"Press the play button to play the recorded audio.", 0, 0, NULL);
#ifndef _WIN32_WCE
        ::ShellExecute(NULL, "open", _T("Created.Wav"), NULL, NULL, SW_SHOWNORMAL);
#endif
    }
    return hr;
}

/****************************************************************************
* SpeakWithEvents *
*-----------------*
*   Description:
*       Speaks the provided text string and displays the words when the
*   they are spoken.
*
*   Returns:
*       HRESULT
*
*****************************************************************************/

HRESULT SpeakWithEvents(ISpVoice * pVoice, const WCHAR * psz)
{
    HRESULT hr = S_OK;
    hr = pVoice->SetNotifyWin32Event();
    if (SUCCEEDED(hr))
    {
        hr = pVoice->SetInterest(SPFEI(SPEI_WORDBOUNDARY) | SPFEI(SPEI_END_INPUT_STREAM), 0);
    }
    if (SUCCEEDED(hr))
    {
        hr = pVoice->Speak(psz, 0, SPF_ASYNC, NULL);
    }
    ULONG i = 0;
    bool fDone = false;
    while (SUCCEEDED(hr) && (!fDone))
    {
        hr = pVoice->WaitForNotifyEvent(INFINITE);
        if (SUCCEEDED(hr))
        {
            SPVOICESTATUS Stat;
            hr = pVoice->GetStatus(&Stat, NULL);
            if (SUCCEEDED(hr) && (Stat.dwRunningState & SPRS_DONE) == 0)
            {
                while (i < Stat.ulInputWordPos + Stat.ulInputWordLen)
                {
                    WCHAR sz[32];
                    sz[0] = psz[i++];
                    sz[1] = 0;
                    OutputDebugStringW(sz);
                    // putwchar(psz[i++]);
                }
            }
            else
            {
	        WCHAR sz[256];
                wsprintf(sz, L"%s\n\n", psz + i);
		OutputDebugStringW(sz);
                fDone = true;
            }
        }
    }
    return hr;
}

/****************************************************************************
* main *
*------*
*   Description:
*       Entry point for sample program
*
*   Returns:
*       HRESULT
*
*****************************************************************************/

int wmain(int argc, wchar_t* argv[])
{
	DebugBreak();

    HRESULT hr;
    OutputDebugStringW(L"SAPI 5.0 Sample TTS Application\n\n");
    hr = ::CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        CComPtr<ISpVoice> cpVoice;
        hr = cpVoice.CoCreateInstance(CLSID_SpVoice);
        if (SUCCEEDED(hr))
        {
//            hr = cpVoice->Speak(L"This sample program uses basic text to speech operations.", 0, 0, NULL);
        }

        if (SUCCEEDED(hr))
        {
            OutputDebugStringW(g_szMarkupDemo);
            hr = cpVoice->Speak(g_szMarkupDemo, 0, 0, NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = SpeakWithEvents(cpVoice, L"This is a demonstration of how words can be displayed when they are spoken.");
        }
        if (SUCCEEDED(hr))
        {
//            hr = MixWithWav(cpVoice);
        }
        if (SUCCEEDED(hr))
        {
//            hr = CreateSampleFile(cpVoice);
        }
        cpVoice.Release();  // Must release prior to CoUninitialize or we'll GP Fault
        CoUninitialize();
    }
    if (FAILED(hr))
    {
	WCHAR sz[256];
        wsprintf(sz, L"Sample program failed with error code 0x%x\n", hr);
	OutputDebugStringW(sz);
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\rundll32\rundll32.cpp ===
/*
How Rundll Works
Rundll performs the following steps: 

1. It parses the command line.


2. It loads the specified DLL via LoadLibrary().


It obtains the address of the <entrypoint> function via GetProcAddress().


It calls the <entrypoint> function, passing the command line tail which is the <optional arguments>.


When the <entrypoint> function returns, Rundll.exe unloads the DLL and exits. 
*/


// RUNDLL32.EXE SETUPX.DLL,InstallHinfSection 132 C:\WINDOWS\INF\SHELL.INF 

#include <windows.h>
#include <stdio.h>

int wmain(int argc, WCHAR *argv[])
{

    if (argc <2) return 1;

    for (int i=0; i<argc; i++)
    {
        RETAILMSG(1, (_T("argv[%i]=%s \n"), i, argv[i]));
    }

    WCHAR* wsDllName=NULL;
    if ( !(wsDllName=wcsstr(argv[1], L".dll")) && !(wsDllName=wcsstr(argv[1], L".DLL") )) return 1;

    wsDllName=argv[1];

    WCHAR* wsProcName=NULL;
    if( !(wsProcName=wcsstr(argv[1], L",") )) return 1;

    *wsProcName++ = 0;

/*    WCHAR wsParStr[MAX_PATH];

    wcscpy(wsParStr, L"");
    for(i=2; i<argc; i++)
    {
        wcscat(wsParStr, argv[i]);
        wcscat(wsParStr, L" ");
    }
*/

    RETAILMSG(1, (_T("wsDllName=%s\nwsProcName=%s\n"),wsDllName, wsProcName));

//DebugBreak();

	HRESULT hr=S_OK;
    DWORD err;

    HMODULE hModule=LoadLibrary(wsDllName);
	if (!hModule)
	{
	    err=GetLastError();
		hr=HRESULT_FROM_WIN32(err);
	}

    if(FAILED(hr)) 
    {
        RETAILMSG(1, (_T("File: %s Line :%d, hr=%08x\n"),_T(__FILE__),__LINE__, hr));
        FreeLibrary(hModule);
        return 1;
    }

    FARPROC proc=GetProcAddress( hModule, wsProcName);

    RETAILMSG(1, (_T("File: %s Line :%d, proc=%08x\n"),_T(__FILE__),__LINE__, proc));

    hr = proc();
//	hr=HRESULT_FROM_WIN32(err);

    FreeLibrary(hModule);

    if (FAILED(hr)) return (1);
    else            return (0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\setup\currver.inc ===
// This file is generated, DO NOT EDIT
#define VERSION                     "5.00.00.0000"
#define VER_FILEVERSION_STR         "5.00.00.0000 "
#define VER_FILEVERSION             5,00,00,0000
#define VER_PRODUCTVERSION_STR      "5.00.00.0000 "
#define VER_PRODUCTVERSION          5,00,00,0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\mkcevoice\makefile.inc ===
copy_files: 
#-------------------------
# Copy 
#-------------------------
    copy *.cpp     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.h       $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.dsw     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.dsp     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.wav     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.txt     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.vce     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy ..\*.c    $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy ..\*.h    $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.vce     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\mkcevoice
    copy *.vce     $(_PUBLICROOT)\$(WINCEPROJ)\oak\files\voices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\engines\tts\regcevoice\makefile.inc ===
copy_files: 
#-------------------------
# Copy 
#-------------------------
    copy *.cpp     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\regcevoice
    copy *.h       $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\regcevoice
    copy *.dsw     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\regcevoice
    copy *.dsp     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\regcevoice
    copy *.txt     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\engines\tts\regcevoice

    copy VoiceSample.reg $(_PUBLICROOT)\$(WINCEPROJ)\oak\files
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\tb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SimpleCC.rc
//
#define IDR_CMD_CFG                     129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\setup\makefile.inc ===
!if "$(_TGTOS)"=="CE"

copy_files: 
#-------------------------
# Copy 
#-------------------------
    mkdir $(_PRIVATEROOT)\$(WINCEPROJ)\setup
    mkdir $(_PRIVATEROOT)\$(WINCEPROJ)\setup\installer
    copy currver.inc     $(_PRIVATEROOT)\$(WINCEPROJ)\setup\installer\

!else # "$(_TGTOS)"=="CE"

!endif # "$(_TGTOS)"=="CE"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\speak\makefile.inc ===
copy_files: 
#-------------------------
# Copy 
#-------------------------
    copy *.cpp     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\speak
    copy *.dsp     $(_PUBLICROOT)\$(WINCEPROJ)\sdk\samples\cpp\speak
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\wcelib\wcelib.h ===
/*******************************************************************************
* wcelib.h *
*------------*
*   Description:
*       This is the header file for WCE functions implementation.
*-------------------------------------------------------------------------------
*  Creation Date: 08/14/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/
#ifndef WCELIB_H
#define WCELIB_H


#endif //WCELIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\talkback\talkback.cpp ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <sapi.h>
#include "sphelper.h"

inline HRESULT BlockForResult(ISpRecoContext * pRecoCtxt, ISpRecoResult ** ppResult)
{
    HRESULT hr = S_OK;
	CSpEvent event;

    while (SUCCEEDED(hr) &&
           SUCCEEDED(hr = event.GetFrom(pRecoCtxt)) &&
           hr == S_FALSE)
    {
        hr = pRecoCtxt->WaitForNotifyEvent(INFINITE);
    }

    *ppResult = event.RecoResult();
    if (*ppResult)
    {
        (*ppResult)->AddRef();
    }

    return hr;
}

const WCHAR * StopWord()
{
    const WCHAR * pchStop;
    
    LANGID LangId = ::SpGetUserDefaultUILanguage();

    switch (LangId)
    {
        case MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT):
            pchStop = L"\x7d42\x4e86\\\x30b7\x30e5\x30fc\x30ea\x30e7\x30fc/\x3057\x3085\x3046\x308a\x3087\x3046";;
            break;

        default:
            pchStop = L"Stop";
            break;
    }

    return pchStop;
}
            
int wmain(int argc, WCHAR* argv[])
{
    HRESULT hr = E_FAIL;
    bool fUseTTS = true;            // turn TTS play back on or off
    bool fReplay = true;            // turn Audio replay on or off

//DebugBreak();

    // Process optional arguments
    if (argc > 1)
    {
        int i;

        for (i = 1; i < argc; i++)
        {
            if (wcsicmp(argv[i], L"-noTTS") == 0)
            {
                fUseTTS = false;
                continue;
            }
            if (wcsicmp(argv[i], L"-noReplay") == 0)
            {
                fReplay = false;
                continue;
            } 
            RETAILMSG(TRUE,(_T("Usage: %s [-noTTS] [-noReplay] \n"), argv[0]));
//            printf ("Usage: %s [-noTTS] [-noReplay] \n", argv[0]);
            return hr;
        }
    }

//    ::DebugBreak();

    if (SUCCEEDED(hr = ::CoInitialize(NULL)))
    {
        {
            CComPtr<ISpRecoContext> cpRecoCtxt;
            CComPtr<ISpRecoGrammar> cpGrammar;
            CComPtr<ISpVoice> cpVoice;
            hr = cpRecoCtxt.CoCreateInstance(CLSID_SpSharedRecoContext);
            if(SUCCEEDED(hr))
            {
                hr = cpRecoCtxt->GetVoice(&cpVoice);
            }
           
            if (cpRecoCtxt && cpVoice )
            {
                if (SUCCEEDED(hr) )
                    hr = cpRecoCtxt->SetNotifyWin32Event();

                if (SUCCEEDED(hr) )
                    hr = cpRecoCtxt->SetInterest(SPFEI(SPEI_RECOGNITION), SPFEI(SPEI_RECOGNITION));

                if (SUCCEEDED(hr) )
                    hr = cpRecoCtxt->SetAudioOptions(SPAO_RETAIN_AUDIO, NULL, NULL);

                if (SUCCEEDED(hr) )
                    hr = cpRecoCtxt->CreateGrammar(0, &cpGrammar);

                if (SUCCEEDED(hr) )
                    hr = cpGrammar->LoadDictation(NULL, SPLO_STATIC);

                if (SUCCEEDED(hr) )
                    hr = cpGrammar->SetDictationState(SPRS_ACTIVE);
            }
            else
                hr=E_FAIL;

            if (SUCCEEDED(hr) )
            {
                USES_CONVERSION;
                            
                const WCHAR * const pchStop = StopWord();
                CComPtr<ISpRecoResult> cpResult;

                RETAILMSG(TRUE,( _T("I will repeat everything you say.\nSay \"%s\" to exit.\n"), pchStop));
//                printf( "I will repeat everything you say.\nSay \"%s\" to exit.\n", W2T(pchStop) );

                while (SUCCEEDED(hr = BlockForResult(cpRecoCtxt, &cpResult)))
                {
                    cpGrammar->SetDictationState( SPRS_INACTIVE );

                    CSpDynamicString dstrText;

                    if (SUCCEEDED(cpResult->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, 
                                                    TRUE, &dstrText, NULL)))
                    {
                        RETAILMSG(TRUE,( _T("I heard:  %s\n"), dstrText));
//                        printf("I heard:  %s\n", W2T(dstrText));

                        if (fUseTTS)
                        {
                            cpVoice->Speak( L"I heard", SPF_ASYNC, NULL);
                            cpVoice->Speak( dstrText, SPF_ASYNC, NULL );
                        }

                        if (fReplay)
                        {
                            if (fUseTTS)
                                cpVoice->Speak( L"when you said", SPF_ASYNC, NULL);
                            else
                                RETAILMSG(TRUE,( _T("\twhen you said...\n")));
//                                printf ("\twhen you said...\n");
                            cpResult->SpeakAudio(NULL, 0, NULL, NULL);
                       }

                       cpResult.Release();
                    }
                    if (_wcsicmp(dstrText, pchStop) == 0)
                    {
                        break;
                    }
                    
                    cpGrammar->SetDictationState( SPRS_ACTIVE );
                } 
            }
        }
        ::CoUninitialize();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\wcelib\wcelib.cpp ===
#include <windows.h>
#include "wincestub.h"
#include <streamhlp.h>
#include "wcelib.h"


void *bsearch( const void *key, const void *base, size_t num, size_t width, int ( __cdecl *compare ) ( const void *elem1, const void *elem2 ) )
{
    int     low=0,
            high=num-1,
            mid,
            res;

    while (low<=high)
    {
        mid= (low+high)>>1;

        if ( !(res=compare(key, (BYTE*)base+mid*width)) ) return (BYTE*)base+mid*width;

        if (res<0)
        {
            high=mid-1;
        }
        else
        {
            low=mid+1;
        }
    }
    return NULL;
}

DWORD GetFullPathName(WCHAR *lpFileName,  // file name
                          DWORD nBufferLength, // size of path buffer
                          WCHAR *lpBuffer,     // path buffer
                          WCHAR **lpFilePart   // address of file name in path
                          )
{
   DWORD dRes=FALSE;

   // check if we already have full name
    *lpFilePart=wcsrchr(lpFileName, L'\\');
    if (*lpFilePart)
    {
        wcsncpy(lpBuffer, lpFileName, min(wcslen(lpFileName)+1, nBufferLength));
        *lpFilePart = wcsrchr(lpBuffer, L'\\');
        (*lpFilePart)++;
        dRes=TRUE;
    }
    else
    {
        if(::GetModuleFileName(NULL,lpBuffer,nBufferLength))
        {
            *lpFilePart=wcsrchr(lpBuffer, L'\\');
            if(*lpFilePart)
            {
                *(++(*lpFilePart))=0;
            }
            DWORD uLen = wcslen(lpBuffer);
            wcsncpy(lpBuffer+uLen, lpFileName, min(wcslen(lpFileName)+1, nBufferLength-uLen));
            dRes=TRUE;
        }
    }
    return dRes;
}

DWORD GetCurrentDirectory(
  DWORD nBufferLength,  // size of directory buffer
  LPTSTR lpBuffer       // directory buffer
)
{
   DWORD dRes=FALSE;
   LPTSTR lpFilePart=NULL;

    if(::GetModuleFileName(NULL,lpBuffer,nBufferLength))
    {
        lpFilePart=wcsrchr(lpBuffer, L'\\');
        if (lpFilePart)
        {
            *lpFilePart=0;
        }
        else
        {
            if (nBufferLength>2)
            {
                wcscpy(lpBuffer, L"\\");
            }
        }
        dRes=TRUE;
    }
    return dRes;
}

HRESULT URLOpenBlockingStreamW(
    LPUNKNOWN pCaller,
    LPCWSTR szURL,
    LPSTREAM *ppStream,
    DWORD dwReserved,
    LPBINDSTATUSCALLBACK lpfnCB
)
{
    HRESULT hr=S_OK;

    if ( pCaller || dwReserved ) return E_INVALIDARG;
    if ( lpfnCB ) return E_NOTIMPL;

    CSpFileStream * pNew = new CSpFileStream(   &hr, 
                                                szURL,
                                                GENERIC_READ, 
                                                0, 
                                                OPEN_EXISTING);
    if (pNew)
    {
        if (SUCCEEDED(hr))
        {
            *ppStream = pNew;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\samples\cpp\speak\speak.cpp ===
// speak.cpp : Defines the entry point for the console application.
//

#include "atlbase.h"
extern CComModule _Module;
#include <atlcom.h>
#include "sapi.h"

int wmain(int argc, WCHAR *argv[])
{
	HRESULT hr=FALSE;
	WCHAR wcBuff[MAX_PATH];
	int i;

#ifdef _WIN32_WCE
//DebugBreak();
#endif

	if( argc == 1 )
	{
		wcscpy( wcBuff, L"This is a simple sample sentence." );
	}
	else
	{
		for( i = 1, wcBuff[0] = 0; i < argc; ++i )
		{
			wcscat( wcscat( wcBuff, argv[i] ), L" " );
		}
	}

	//--- Init COM
	hr = ::CoInitialize( NULL );

	CComPtr<ISpVoice> cpVoice;

	if ( FAILED(hr) )	goto LReturn;

	//--- Create the voice
	hr = cpVoice.CoCreateInstance(CLSID_SpVoice);
	if ( FAILED(hr) )	goto LReturn;

	hr = cpVoice->Speak(wcBuff, 0, NULL);
		
LReturn:

    if (cpVoice)
        cpVoice.Release();
	::CoUninitialize();

    return FAILED(hr)? 1: 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\wce_sapiguid\sapiguid.c ===
#include <windows.h>
#include <objbase.h>
#include <spguid.c>
#include <sapi_i.c>
#include <sapiddk_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\ce\wcelib\wcelib_i.c ===
#ifdef __cplusplus
extern "C"{
#endif 

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

// for sapi/sapi/recognizer.h
const IID IID__ISpRecognizerBackDoor = { 0x635DAEDE,0x0ACF,0x4b2e,{0xB9,0xDE,0x8C,0xD2,0xBA,0x7F,0x61,0x83}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\common.inc ===
!if "$(SPEECH_ROOT)"==""
!error SPEECH_ROOT should be defined in makefile
!endif

INCLUDES        = $(INCLUDES);$(SPEECH_ROOT)\common\include;$(SPEECH_ROOT)\sapi\include;$(SPEECH_ROOT)\setup\installer;$(SPEECH_ROOT)\common\spcommon\$(O);$(SPEECH_ROOT)\sapi\include\$(O)

386_STDCALL=0
USE_LIBCMT=1

# ****** "FINAL" should be defined only for golden builds ******
C_DEFINES       = $(C_DEFINES) -DFINAL

# ****** Automation

C_DEFINES = $(C_DEFINES) -DSAPI_AUTOMATION

!if defined(USE_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!else
# Insure that we will work on Win 95
CHICAGO_PROJECT   = 1
CHICAGO_PRODUCT   = 1
NO_NTDLL          = 1
!endif

CHECKED_ALT_DIR=1

!if "$(_BUILDTYPE)" == "fre"
FREEBUILD=1
!else
FREEBUILD=0
DEBUG_CRTS         = 1
!endif

#
# Default location for libc*.lib
#

CRT_LIB_PATH = $(SDK_LIB_PATH)

#
# Additional compiler flags
#

!if "$(BUILD_PRODUCT)" == "NT"
WIN32_WINNT_VERSION=0x500
WIN32_IE_VERSION   =0x0500
WIN32_DEFINE= -D_WIN32_WINDOWS=0x500 -D_WIN32_WINNT=0x0500
C_DEFINES          =$(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32
!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
MSC_OPTIMIZATION   = /Odi
!endif
ATL_VER            = 30
USE_STATIC_ATL     = 1
!else

!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
DEBUG_CRTS         = 1
NTDEBUG            = ntsd
NTDEBUGTYPE        = windbg
!endif

USE_PDB            = 1
USE_PDB_TO_COMPILE = 1

#
# Additional linker flags
#

LINKER_FLAGS    = $(LINKER_FLAGS) -map

#
# Get all maps and syms
#

USE_MAPSYM = 1
!endif		# BUILD_PRODUCT != NT

# Make warnings equivalent to errors

#
# Special IceCap flags
#

!if defined(SPG_BUILD_ICECAP)
CRT_LIB_PATH     = $(SPEECH_ROOT)\sr\extlibs\bbt
LINKER_FLAGS     = $(LINKER_FLAGS) /debugtype:cv,fixup
USER_C_FLAGS     = $(USER_C_FLAGS) /DICECAP /FI$(SPEECH_ROOT)\sr\include\when.h /FI$(SPEECH_ROOT)\sr\include\_icecap.h
!endif

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\globals.h ===
#ifndef __LEXEDIT_GLOBALS_H__
#define __LEXEDIT_GLOBALS_H__
		
#include "LexEdit_1.h"

// Global handles to each of the dialogs
extern HWND					g_hDlg;
extern HINSTANCE			g_hInst;

// Other global variables
extern WCHAR				g_szWFileName[256];
extern TCHAR*				g_pszFileText;

#endif // __LEXEDIT_GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\lexedit_1.cpp ===
// LexEdit_1.cpp : Defines the entry point for the application.
//

#include "StdAfx.h"
#include "resource.h"

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	

    HACCEL      hAccel;
    HWND        hWnd = NULL;
    MSG         msg;
    WNDCLASSEX  wc;
	HRESULT     hr   = S_OK;
        
    // Store the global instance
    g_hInst = hInstance;
    
    // Initialize the Win95 control library
    InitCommonControls();
    
    // Initialize COM
    CoInitialize(NULL);

    // Register the main dialog class
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize = sizeof( wc );
    GetClassInfoEx( NULL, WC_DIALOG, &wc );
    wc.lpfnWndProc      = DlgProcMain;
    wc.hInstance        = hInstance;
    wc.hCursor          = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground    = GetSysColorBrush( COLOR_3DFACE );
    wc.lpszMenuName     = NULL;
    wc.hIcon            = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_APPICON) );
    wc.hIconSm          = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_APPICON) );

    if(!RegisterClassEx(&wc))
        goto exit;

    //--- Create the default voice and get the TTS default wave format
    hr = cpVoice.CoCreateInstance( CLSID_SpVoice );
    if (FAILED(hr))
        goto exit;

   // Create the main dialog
    g_hDlg  = CreateDialog( hInstance, MAKEINTRESOURCE(IDD_MAIN),
                            NULL, (DLGPROC)DlgProcMain );
    
    // If we didn't get our dialogs, we need to bail.
    if( !g_hDlg )
        goto exit;

	// Make the main dialog visible
    ShowWindow(g_hDlg, SW_RESTORE);
    UpdateWindow(g_hDlg);

    hAccel = LoadAccelerators( hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1) );
                    
    // Enter the message loop
    while(GetMessage(&msg, NULL, 0, 0) > 0)
    {
        if (!TranslateAccelerator (g_hDlg, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }


exit:

	// Free the dialogs
    DestroyWindow(g_hDlg);
	cpVoice.Release();

	// Unload COM
    CoUninitialize();

    // Return 0
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LexEdit_1.rc
//
#define IDD_MAIN                        101
#define IDI_APPICON                     102
#define IDR_ACCELERATOR1                106
#define IDC_EDIT_ORTH                   1000
#define IDC_EDIT_POS                    1001
#define IDC_EDIT_PRONUNCIATION          1002
#define IDC_SLIDER_RATE                 1003
#define IDC_SLIDER_VOLUME               1004
#define IDC_COMBO_VOICE                 1005
#define IDC_BUTTON_PLAY                 1007
#define IDC_BUTTON_DELETE               1008
#define IDC_BUTTON_RESET                1009
#define IDC_BUTTON_NEXT                 1010
#define IDC_BUTTON_DONE                 1010
#define IDC_BUTTON_PREVIOUS             1012
#define IDC_BUTTON_OPEN                 1013
#define IDC_BUTTON_SKIP                 1017
#define IDC_EDIT_IPA1                   1024
#define IDC_EDIT_POS1A                  1025
#define IDC_EDIT_POS1B                  1026
#define IDC_EDIT_POS1C                  1027
#define IDC_EDIT_POS1D                  1028
#define IDC_EDIT_IPA2                   1029
#define IDC_EDIT_POS2A                  1030
#define IDC_EDIT_POS2B                  1031
#define IDC_EDIT_POS2C                  1032
#define IDC_EDIT_POS2D                  1033
#define IDC_BUTTON_PLAY1                1034
#define IDC_BUTTON_PLAY2                1035
#define IDC_EDIT_COMMENTS               1039

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\lexedit_1.h ===
#ifndef _INC_LEXEDIT
#define _INC_LEXEDIT

#include <windows.h>		// System includes
#include <atlbase.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include "resource.h"
//#include <stdio.h>
#include <tchar.h>
#include <olectl.h>			// Required for showing property page
#include <sapi.h>			// SAPI includes
#include <sphelper.h>
#include <spuihelp.h>


//
// Prototypes for dialog procs
//
LPARAM CALLBACK DlgProcMain(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _INC_LEXEDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	LexEdit_1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

HWND                g_hDlg              = NULL;
HINSTANCE           g_hInst		        = NULL;
CComPtr<ISpVoice>   cpVoice             = NULL;
long                g_DefaultRate       = 350;
USHORT              g_DefaultVolume     = 50;



// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\dlgmain.cpp ===
#include "StdAfx.h"

//
// Handlers for Windows messages
//
BOOL MainHandleInitDialog(HWND hWnd, HWND hwndFocus, LPARAM lParam);
void MainHandleClose(HWND hWnd);
void MainHandleDestroy(HWND hWnd);
void MainHandleCommand(HWND hWnd, int id, HWND hWndControl, UINT codeNotify);

//
// Other local functions
//
BOOL CallOpenFileDialog( HWND hWnd, LPSTR szFileName );
bool ReadLine();
void DisplayValues( HWND hWnd );
HRESULT ConvertReadableToUnicode( const char *szReadable, WCHAR *szwUnicode );

// Global variables - needed to be able to read from file...
using namespace std;
typedef vector<char*> STRINGVECTOR;

STRINGVECTOR fileVector;
int fileIndex;
FILE *fStream, *fSkip, *fDelete, *fTemp;
TCHAR szAFileName[256], tempFileName[257];
BOOL bGotFile = FALSE;
TCHAR sOrth[30], sPos1A[10], sPos1B[10], sPos1C[10], sPos1D[10], sIpa1[40];
TCHAR sPos2A[10], sPos2B[10], sPos2C[10], sPos2D[10], sIpa2[40], sComments[200];
TCHAR sCurline[100], sPrevline[100];

LPARAM CALLBACK DlgProcMain(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
     // Call the appropriate message handler
    switch(uMsg)                                                    
    {
        HANDLE_MSG( hwnd, WM_INITDIALOG, MainHandleInitDialog );
        HANDLE_MSG( hwnd, WM_CLOSE, MainHandleClose );      
        HANDLE_MSG( hwnd, WM_DESTROY, MainHandleDestroy );
        HANDLE_MSG( hwnd, WM_COMMAND, MainHandleCommand );
    }

    // Call the default message handler.
    // NOTE:    Only do this on this main dialog proc.  For any other dialogs,
    //          return TRUE, or the dialog will pop up, and not ever give up
    //          focus.
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/////////////////////////////////////////////////////////////////
void MainHandleCommand(HWND hWnd, int id, HWND hWndControl, UINT codeNotify)
/////////////////////////////////////////////////////////////////
//
// Handle each of the WM_COMMAND messages that come in, and hand them
// off to the correct function.
//
{
    char *temp, buffer[100];

	switch(id)
    {
		case IDC_BUTTON_OPEN:


            // if file already open, close it before opening a new one...
            if (bGotFile) {
                fclose(fSkip);
                fclose(fDelete);
                fileVector.clear();
            }

            // Do the Open File Dialog...
            bGotFile = CallOpenFileDialog( hWnd, szAFileName );

            if (bGotFile) {

                // DO SOME REGISTRY STUFF TO LOAD THE FIRST UNEDITED WORD...
                LONG lRetVal;
                HKEY hkResult;
                char szPosition[4] = "0";  
                DWORD size = 4;

                lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("LexiconFilePosition"), 0, NULL, 0,
                              KEY_ALL_ACCESS, NULL, &hkResult, NULL );
   
                if( lRetVal == ERROR_SUCCESS )         
                {        
                    RegQueryValueEx( hkResult, _T(szAFileName), NULL, NULL, (PBYTE)szPosition, &size );         
                    RegCloseKey( hkResult );
                }
                fileIndex = atoi(szPosition);

                strcpy(tempFileName, szAFileName);
                strcpy((tempFileName + strlen(tempFileName)), "~");

                SetDlgItemText( hWnd, IDC_EDIT_ORTH, tempFileName );

                // OPEN THE FILE, AND READ IT IN TO fileVector... (also copy it into a temporary file)
                if( (fStream = fopen( szAFileName, "r" )) != NULL &&
                    (fTemp = fopen( tempFileName, "w" )) != NULL)
                {
                    int i = 0;
                    temp = new char[100];
                    while (fgets(temp, 100, fStream) != NULL) {
                        fileVector.push_back(temp);
                        fputs(temp, fTemp);
                        temp = new char[100];
                    }
                    fclose(fTemp);
                    fclose(fStream);
                    delete [] temp;

                    // DISPLAY THE FIRST UNEDITED WORD...
                    if ( ReadLine() )
                        DisplayValues(hWnd);
                    else {
                        strcpy(sOrth, "NO WORDS!");
                        DisplayValues(hWnd);
                    }
                } 
                char fSkipFileName[100] = "";
                char fDeleteFileName[100] = "";
                strcat(fSkipFileName, szAFileName);
                strcat(fSkipFileName, "skip");
                strcat(fDeleteFileName, szAFileName);
                strcat(fDeleteFileName, "delete");
    
                fSkip = fopen(fSkipFileName, "a+");
                fDelete = fopen(fDeleteFileName, "a+");

            }


            break;

        case IDC_BUTTON_DONE:

            if (bGotFile) {

                // Check word values against their initial values...
                char sCurPos1A[10], sCurPos1B[10], sCurPos1C[10], sCurPos1D[10], sCurIpa1[40];
                char sCurPos2A[10], sCurPos2B[10], sCurPos2C[10], sCurPos2D[10], sCurIpa2[40], sCurComments[200];

                GetDlgItemText( hWnd, IDC_EDIT_POS1A, sCurPos1A, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS1B, sCurPos1B, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS1C, sCurPos1C, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS1D, sCurPos1D, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_IPA1, sCurIpa1, 40 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2A, sCurPos2A, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2B, sCurPos2B, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2C, sCurPos2C, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2D, sCurPos2D, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_IPA2, sCurIpa2, 40 );
                GetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sCurComments, 200 );

                if ((strcmp(sPos1A, sCurPos1A) != 0) ||
                    (strcmp(sPos1B, sCurPos1B) != 0) ||
                    (strcmp(sPos1C, sCurPos1C) != 0) ||
                    (strcmp(sPos1D, sCurPos1D) != 0) ||
                    (strcmp(sIpa1, sCurIpa1) != 0)   ||
                    (strcmp(sPos2A, sCurPos2A) != 0) ||
                    (strcmp(sPos2B, sCurPos2B) != 0) ||
                    (strcmp(sPos2C, sCurPos2C) != 0) ||
                    (strcmp(sPos2D, sCurPos2D) != 0) ||
                    (strcmp(sIpa2, sCurIpa2) != 0)   ||
                    (strcmp(sComments, sCurComments) != 0)) {
                    
                    // LINE WAS EDITED
                    strcpy(buffer, "");
                    strcat(buffer, sOrth);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1A);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1B);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1C);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1D);
                    strcat(buffer, ",");
                    strcat(buffer, sCurIpa1);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2A);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2B);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2C);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2D);
                    strcat(buffer, ",");
                    strcat(buffer, sCurIpa2);
                    strcat(buffer, ",");
                    strcat(buffer, sCurComments);
                    strcat(buffer, "\n");

                    char *temp = fileVector.at(fileIndex - 1);
                    strcpy(temp, buffer);

                } else {
                    // LINE WAS NOT EDITED
                }

                // Display next word...
                // First get rid of the previous word values...
                strcpy(sPos1A, "");
                strcpy(sPos1B, "");
                strcpy(sPos1C, "");
                strcpy(sPos1D, "");
                strcpy(sIpa1, "");
                strcpy(sPos2A, "");
                strcpy(sPos2B, "");
                strcpy(sPos2C, "");
                strcpy(sPos2D, "");
                strcpy(sIpa2, "");
                strcpy(sComments, "");

                if ( ReadLine() ) 
                    DisplayValues(hWnd);
                else {
                    strcpy(sOrth, "NO WORDS LEFT!");
                    DisplayValues(hWnd);
                }
            }    
            break;

        case IDC_BUTTON_RESET:

            DisplayValues(hWnd);
            break;

        case IDC_BUTTON_PREVIOUS:

            // First get rid of the previous word values...
            strcpy(sPos1A, "");
            strcpy(sPos1B, "");
            strcpy(sPos1C, "");
            strcpy(sPos1D, "");
            strcpy(sIpa1, "");
            strcpy(sPos2A, "");
            strcpy(sPos2B, "");
            strcpy(sPos2C, "");
            strcpy(sPos2D, "");
            strcpy(sIpa2, "");
            strcpy(sComments, "");

            fileIndex -= 2;
            ReadLine();
            DisplayValues(hWnd);
            break;

        case IDC_BUTTON_PLAY1:
        
            WCHAR sWIpa1[40];
            char sCurIpa1[40];
            GetDlgItemText( hWnd, IDC_EDIT_IPA1, sCurIpa1, 40 );

            wcscpy(sWIpa1, L"<PRON IPA=\"");
            ConvertReadableToUnicode(sCurIpa1, sWIpa1+11);
            wcscpy((sWIpa1 + wcslen(sWIpa1)), L"\"/>a</PRON>");

            cpVoice->Speak( sWIpa1, SPF_USEGLOBALDOC, NULL );
            break;

        case IDC_BUTTON_PLAY2:

            WCHAR sWIpa2[40];
            char sCurIpa2[40];
            GetDlgItemText( hWnd, IDC_EDIT_IPA2, sCurIpa2, 40 );

            wcscpy(sWIpa2, L"<PRON IPA=\"");
            ConvertReadableToUnicode(sCurIpa2, sWIpa2+11);
            wcscpy((sWIpa2 + wcslen(sWIpa2)), L"\"/>a</PRON>");

            cpVoice->Speak( sWIpa2, SPF_USEGLOBALDOC, NULL );
            break;

        case IDC_BUTTON_SKIP:

            GetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sComments, 200 );

            strcpy(buffer, "");
            strcat(buffer, sOrth);
            strcat(buffer, ",");
            strcat(buffer, sPos1A);
            strcat(buffer, ",");
            strcat(buffer, sPos1B);
            strcat(buffer, ",");
            strcat(buffer, sPos1C);
            strcat(buffer, ",");
            strcat(buffer, sPos1D);
            strcat(buffer, ",");
            strcat(buffer, sIpa1);
            strcat(buffer, ",");
            strcat(buffer, sPos2A);
            strcat(buffer, ",");
            strcat(buffer, sPos2B);
            strcat(buffer, ",");
            strcat(buffer, sPos2C);
            strcat(buffer, ",");
            strcat(buffer, sPos2D);
            strcat(buffer, ",");
            strcat(buffer, sIpa2);
            strcat(buffer, ",");
            strcat(buffer, sComments);
            strcat(buffer, "\n");

            fputs(buffer, fSkip);

            // Display next word...
            // First get rid of the previous word values...
            strcpy(sPos1A, "");
            strcpy(sPos1B, "");
            strcpy(sPos1C, "");
            strcpy(sPos1D, "");
            strcpy(sIpa1, "");
            strcpy(sPos2A, "");
            strcpy(sPos2B, "");
            strcpy(sPos2C, "");
            strcpy(sPos2D, "");
            strcpy(sIpa2, "");
            strcpy(sComments, "");

            if ( ReadLine() ) 
                DisplayValues(hWnd);
            else {
                strcpy(sOrth, "NO WORDS LEFT!");
                DisplayValues(hWnd);
            }

            break;

        case IDC_BUTTON_DELETE:

            GetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sComments, 200 );

            strcpy(buffer, "");
            strcat(buffer, sOrth);
            strcat(buffer, ",");
            strcat(buffer, sPos1A);
            strcat(buffer, ",");
            strcat(buffer, sPos1B);
            strcat(buffer, ",");
            strcat(buffer, sPos1C);
            strcat(buffer, ",");
            strcat(buffer, sPos1D);
            strcat(buffer, ",");
            strcat(buffer, sIpa1);
            strcat(buffer, ",");
            strcat(buffer, sPos2A);
            strcat(buffer, ",");
            strcat(buffer, sPos2B);
            strcat(buffer, ",");
            strcat(buffer, sPos2C);
            strcat(buffer, ",");
            strcat(buffer, sPos2D);
            strcat(buffer, ",");
            strcat(buffer, sIpa2);
            strcat(buffer, ",");
            strcat(buffer, sComments);
            strcat(buffer, "\n");

            fputs(buffer, fDelete);

            // Display next word...
            // First get rid of the previous word values...
            strcpy(sPos1A, "");
            strcpy(sPos1B, "");
            strcpy(sPos1C, "");
            strcpy(sPos1D, "");
            strcpy(sIpa1, "");
            strcpy(sPos2A, "");
            strcpy(sPos2B, "");
            strcpy(sPos2C, "");
            strcpy(sPos2D, "");
            strcpy(sIpa2, "");
            strcpy(sComments, "");

            if ( ReadLine() ) 
                DisplayValues(hWnd);
            else {
                strcpy(sOrth, "NO WORDS LEFT!");
                DisplayValues(hWnd);
            }

            break;
    }
	
	return;
}


///////////////////////
void DisplayValues(HWND hWnd)
///////////////////////

{
	SetDlgItemText( hWnd, IDC_EDIT_ORTH, sOrth );
    SetDlgItemText( hWnd, IDC_EDIT_POS1A, sPos1A );
    SetDlgItemText( hWnd, IDC_EDIT_POS1B, sPos1B );
    SetDlgItemText( hWnd, IDC_EDIT_POS1C, sPos1C );
    SetDlgItemText( hWnd, IDC_EDIT_POS1D, sPos1D );
    SetDlgItemText( hWnd, IDC_EDIT_POS2A, sPos2A );
    SetDlgItemText( hWnd, IDC_EDIT_POS2B, sPos2B );
    SetDlgItemText( hWnd, IDC_EDIT_POS2C, sPos2C );
    SetDlgItemText( hWnd, IDC_EDIT_POS2D, sPos2D );
    SetDlgItemText( hWnd, IDC_EDIT_IPA1, sIpa1 );
    SetDlgItemText( hWnd, IDC_EDIT_IPA2, sIpa2 );
    SetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sComments );
}

////////////////////////////////
bool ReadLine()
////////////////////////////////

{ 
    char *linePtr, sLine[100], temp[100];

    linePtr = fileVector.at(fileIndex);
    strcpy(sLine, linePtr);
    fileIndex++;

    // Get Orthography...
    sscanf(sLine, "%[^,],%s", sOrth, sLine);

    // Get Pos1A
    sscanf(sLine, "%[^,],%s", sPos1A, temp);
    if (strcmp(sPos1A, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos1B
    sscanf(sLine, "%[^,],%s", sPos1B, temp);
    if (strcmp(sPos1B, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos1C
    sscanf(sLine, "%[^,],%s", sPos1C, temp);
    if (strcmp(sPos1C, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos1D
    sscanf(sLine, "%[^,],%s", sPos1D, temp);
    if (strcmp(sPos1D, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);
 
    // Get Ipa1
    sscanf(sLine, "%[^,],%s", sIpa1, temp);
    if (strcmp(sIpa1, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2A
    sscanf(sLine, "%[^,],%s", sPos2A, temp);
    if (strcmp(sPos2A, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2B
    sscanf(sLine, "%[^,],%s", sPos2B, temp);
    if (strcmp(sPos2B, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2C
    sscanf(sLine, "%[^,],%s", sPos2C, temp);
    if (strcmp(sPos2C, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2D
    sscanf(sLine, "%[^,],%s", sPos2D, temp);
    if (strcmp(sPos2D, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Ipa2
    sscanf(sLine, "%[^,],%s", sIpa2, temp);
    if (strcmp(sIpa2, "") == 0)
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    sscanf(sLine, "%[^,],%s", sComments, temp);
    return true;
}

//////////////////////////////////////////////////////////////////////
HRESULT ConvertReadableToUnicode( const char *szReadable, WCHAR *szwUnicode )
//////////////////////////////////////////////////////////////////////
{

    char cFirst, cSecond;
    int iRIndex = 0, iUIndex = 0;

    if ( szReadable == NULL )
        return E_INVALIDARG;
    if ( szwUnicode == NULL )
        return E_POINTER;

    cFirst = szReadable[iRIndex];

    while (cFirst) {

        if (('a' <= cFirst) && (cFirst <= 'z')) {
           
            switch (cFirst) 
            {
            case 'b':
                szwUnicode[iUIndex] = 0x62;
                break;
            case 'p':
                szwUnicode[iUIndex] = 0x70;
                break;
            case 'd':
                szwUnicode[iUIndex] = 0x64;
                break;
            case 't':
                szwUnicode[iUIndex] = 0x74;
                break;
            case 'g':
                szwUnicode[iUIndex] = 0x261;
                break;
            case 'k':
                szwUnicode[iUIndex] = 0x6b;
                break;
            case 'f':
                szwUnicode[iUIndex] = 0x66;
                break;
            case 'v':
                szwUnicode[iUIndex] = 0x76;
                break;
            case 's':
                szwUnicode[iUIndex] = 0x73;
                break;
            case 'z':
                szwUnicode[iUIndex] = 0x7a;
                break;
            case 'l':
                szwUnicode[iUIndex] = 0x6c;
                break;
            case 'r':
                szwUnicode[iUIndex] = 0x27b;
                break;
            case 'y':
                szwUnicode[iUIndex] = 0x6a;
                break;
            case 'w':
                szwUnicode[iUIndex] = 0x77;
                break;
            case 'h':
                szwUnicode[iUIndex] = 0x266;
                break;
            case 'm':
                szwUnicode[iUIndex] = 0x6d;
                break;
            case 'n':
                szwUnicode[iUIndex] = 0x6e;
                break;
            case 'j':
                szwUnicode[iUIndex] = 0x2a3;
                break;
            default:
                return E_FAIL;
            }
            iRIndex++;
            iUIndex++;

        } else if (('A' <= cFirst) && (cFirst <= 'Z')) {

            cSecond = szReadable[++iRIndex];
            switch (cFirst) 
            {
            case 'A':
                switch (cSecond)
                {
                case 'A':
                    szwUnicode[iUIndex] = 0x61;
                    break;
                case 'E':
                    szwUnicode[iUIndex] = 0xe6;
                    break;
                case 'O':
                    szwUnicode[iUIndex] = 0x254;
                    break;
                case 'X':
                    szwUnicode[iUIndex] = 0x259;
                    break;
                case 'Y':
                    szwUnicode[iUIndex] = 0x61;
                    szwUnicode[++iUIndex] = 0x26a;
                    break;
                case 'W':
                    szwUnicode[iUIndex] = 0x61;
                    szwUnicode[++iUIndex] = 0x28a;
                    break;
                default:
                    return E_FAIL;
                }
                break;
            case 'E':
                switch (cSecond)
                {
                case 'H':
                    szwUnicode[iUIndex] = 0x25b;
                    break;
                case 'R':
                    szwUnicode[iUIndex] = 0x25a;
                    break;
                case 'Y':
                    szwUnicode[iUIndex] = 0x65;
                    break;
                default:
                    return E_FAIL;
                }
                break;
           case 'I':
               switch (cSecond)
               {
               case 'H':
                   szwUnicode[iUIndex] = 0x26a;
                   break;
               case 'Y':
                   szwUnicode[iUIndex] = 0x69;
                   break;
               case 'X':
                   szwUnicode[iUIndex] = 0x268;
                   break;
               default:
                   return E_FAIL;
               }
               break;
           case 'U':
               switch (cSecond)
               {
               case 'H':
                   szwUnicode[iUIndex] = 0x28a;
                   break;
               case 'W':
                   szwUnicode[iUIndex] = 0x75;
                   break;
               case 'X':
                    szwUnicode[iUIndex] = 0x28c;
                    break;
               default:
                   return E_FAIL;
               }
               break;
           case 'O':
               switch (cSecond)
               {
               case 'Y':
                   szwUnicode[iUIndex] = 0x254;
                   szwUnicode[++iUIndex] = 0x26a;
                   break;
               case 'W':
                   szwUnicode[iUIndex] = 0x6f;
                   szwUnicode[++iUIndex] = 0x28a;
                   break;
               default:
                   return E_FAIL;
               }
               break;
           case 'D':
                switch (cSecond)
                {
                case 'H':
                    szwUnicode[iUIndex] = 0xf0;
                    break;
                case 'X':
                    szwUnicode[iUIndex] = 0x74;
                    break;
                default:
                    return E_FAIL;
                }
                break;
            case 'T':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x3b8;
                    break;
                } else {
                    return E_FAIL;
                }
            case 'S':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x283;
                    break;
                } else {
                    return E_FAIL;
                }
            case 'Z':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x292;
                    break;
                } else {
                    return E_FAIL;
                }
            case 'C':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x2a7;
                    break;
                } else {
                    return E_FAIL;
                }
            default:
                return E_FAIL;
            }
            iRIndex++;
            iUIndex++;

        } else {
            switch (cFirst)
            {
            case '1':
                szwUnicode[iUIndex] = 0x2c8;
                break;
            case '2':
                szwUnicode[iUIndex] = 0x2cc;
                break;
            case '-':
                szwUnicode[iUIndex] = 0x2d;
                break;
            default:
                return E_FAIL;
            }
            iRIndex++;
            iUIndex++;
        }

        cFirst = szReadable[iRIndex];

    }
    szwUnicode[iUIndex] = 0;
    return S_OK;
}


/////////////////////////////////////////////////////////////////
BOOL CallOpenFileDialog( HWND hWnd, LPSTR szFileName )  
/////////////////////////////////////////////////////////////////

{
    OPENFILENAME    ofn;
	BOOL            bRetVal     = TRUE;
    LONG            lRetVal;
    HKEY            hkResult;
    TCHAR           szPath[256]       = _T("");
    DWORD           size = 256;

	// Open the last directory used by this app (stored in registry)
    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("PathTTSDataFiles"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegQueryValueEx( hkResult, _T("TTSFiles"), NULL, NULL, (PBYTE)szPath, &size );
    
        RegCloseKey( hkResult );
    }

    ofn.lStructSize       = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner         = hWnd;    
	ofn.lpstrFilter       = "TXT (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";
    ofn.lpstrCustomFilter = NULL;    
	ofn.nFilterIndex      = 1;    
	ofn.lpstrInitialDir   = szPath;
	ofn.lpstrFile         = szFileName;  
	ofn.nMaxFile          = 256;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;    
	ofn.lpstrDefExt       = NULL;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_READONLY | OFN_PATHMUSTEXIST;

	// Pop the dialog
    bRetVal = GetOpenFileName( &ofn );

    // Write the directory path you're in to the registry
    TCHAR   pathstr[256] = _T("");
    strcpy( pathstr, szFileName );

    int i=0; 
    while( pathstr[i] != NULL )
    {
        i++;
    }
    while( pathstr[i] != '\\' )
    {
        i --;
    }
    pathstr[i] = NULL;

    // Now write the string to the registry
    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("PathTTSDataFiles"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegSetValueEx( hkResult, _T("TTSFiles"), NULL, REG_EXPAND_SZ, (PBYTE)pathstr, strlen(pathstr)+1 );
    
        RegCloseKey( hkResult );
    }

    return bRetVal;
}

/////////////////////////////////////////////////////////////////
BOOL MainHandleInitDialog(HWND hWnd, HWND hwndFocus, LPARAM lParam)
/////////////////////////////////////////////////////////////////
{
	// Store this as the "Main Dialog"
	g_hDlg  = hWnd;
    strcpy(sCurline, "");

	return TRUE;
}

/////////////////////////////////////////////////////////////////
void MainHandleClose(HWND hWnd)
/////////////////////////////////////////////////////////////////
{
    LONG lRetVal;
    HKEY hkResult;
    char buffer[10], *temp;
    itoa(fileIndex, buffer, 10); 

    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("LexiconFilePosition"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegSetValueEx( hkResult, _T(szAFileName), NULL, REG_EXPAND_SZ, (PBYTE)buffer, strlen(buffer)+1 );    
        RegCloseKey( hkResult );
    }


    if (bGotFile) {
        // Save new information back to file in a SAFE manner...
        if ((fStream = fopen( szAFileName, "w" )) != NULL) {
            int i = 0;
            while (i < fileVector.size()) {
                temp = fileVector.at(i);
                fputs(temp, fStream);
                i++;
            }
            fclose(fStream);
            DeleteFile(tempFileName);
        }
    
        fclose(fDelete);
        fclose(fSkip);
    }

    // Terminate the app
    PostQuitMessage(0);

    // Return success
    return;
}

/////////////////////////////////////////////////////////////////
void MainHandleDestroy(HWND hWnd)
/////////////////////////////////////////////////////////////////
{

    LONG lRetVal;
    HKEY hkResult;
    char buffer[10];
    itoa(fileIndex, buffer, 10);

    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("LexiconFilePosition"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegSetValueEx( hkResult, _T(szAFileName), NULL, REG_EXPAND_SZ, (PBYTE)buffer, strlen(buffer)+1 );    
        RegCloseKey( hkResult );
    }

    // Return success
    return;                                                           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\lexedit\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>
#include <windows.h>
#include <atlbase.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include "resource.h"
//#include <stdio.h>
#include <tchar.h>
#include <olectl.h>			// Required for showing property page
#include <sapi.h>			// SAPI includes
#include <sphelper.h>
#include <spuihelp.h>


//
// Prototypes for dialog procs
//
LPARAM CALLBACK DlgProcMain(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);



// Global handles to each of the dialogs
extern HWND					g_hDlg;
extern HINSTANCE			g_hInst;
extern CComPtr<ISpVoice> cpVoice;
extern long g_DefaultRate;
extern USHORT g_DefaultVolume;


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\resetusr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <atlbase.h>
#include <sapi.h>
#include <sphelper.h>
#include <stdlib.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\resetusr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spuser.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\resetusr\resetusr.h ===
/****************************************************************************
*	spuser.h
*		<put description here>
*
*	Owner: cthrash
*	Copyright  1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Forward and External Declarations -------------------------------------

BOOL    ParseCmdLine(char *, char **);
HRESULT ResetUser(char *);
HRESULT Report(char * lpMsg, HRESULT hr);

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\resetusr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	spuser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\cdlg.c ===
/*
 * CDLG.C
 *
 */
#include <windows.h>
#include <commdlg.h>
#include "cdlg.h"
#include "prtdoc.h"
#include "rerror.h"

/****************************************************************************/

BOOL OpenCommonDlg(HWND hwnd, HANDLE hInst, LPSTR lpszFile, LPSTR lpszTitle)
{
   OPENFILENAME   ofn;
   char     lpstrFilter[] = "All Files (*.*) *.* ";


   lpstrFilter[15] = 0;
   lpstrFilter[19] = 0;

   ofn.lStructSize      = sizeof(ofn);
   ofn.hwndOwner        = hwnd;
   ofn.hInstance        = hInst;
   ofn.lpstrFilter      = lpstrFilter;
   ofn.lpstrCustomFilter= 0;
   ofn.nMaxCustFilter   = 0;
   ofn.nFilterIndex     = 0;
   ofn.lpstrFile        = lpszFile;
   ofn.nMaxFile         = 511;
   ofn.lpstrFileTitle   = 0;
   ofn.nMaxFileTitle    = 0;
   ofn.lpstrInitialDir  = 0;
   ofn.lpstrTitle       = lpszTitle;
   ofn.Flags            = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
   ofn.nFileOffset      = 0;  //passing 0 in lpszFile right now
   ofn.nFileExtension   = 0;
   ofn.lpstrDefExt      = 0;
   ofn.lCustData        = 0;
   ofn.lpfnHook         = 0;
   ofn.lpTemplateName   = 0;

   return   GetOpenFileName(&ofn);
}

/****************************************************************************/

BOOL FontCommonDlg(HWND hwnd, HANDLE hInst, LOGFONT FAR* lf)
{
   CHOOSEFONT  cf;

   cf.lStructSize    = sizeof(cf);
   cf.hwndOwner      = hwnd;
   cf.hDC            = 0;     // not doing printer fonts
   cf.lpLogFont      = lf;    // give initial font
   cf.iPointSize     = 0;     // they set
   cf.Flags          = CF_INITTOLOGFONTSTRUCT | CF_FORCEFONTEXIST |
                        CF_SCREENFONTS;
   cf.rgbColors      = 0;     // with CF_EFFECTS
   cf.lCustData      = 0;     // for Hook Function
   cf.lpfnHook       = 0;
   cf.lpTemplateName = 0;
   cf.hInstance      = hInst;
   cf.lpszStyle      = 0;
   cf.nFontType      = 0;
   cf.nSizeMin       = 5;     // arbitrary
   cf.nSizeMax       = 500;   // "

   return   ChooseFont(&cf);
}

/****************************************************************************/

BOOL PrinterFontCommonDlg(HWND hwnd, HANDLE hInst, LOGFONT FAR* lf)
{
   CHOOSEFONT  cf;
   HDC         hdc;
   BOOL        bRet;

// Get the printer DC.  (Code is pirated from prtdoc.c.)

   if (!ParseDeviceLine())
      return FALSE;
   hdc = GetPrtDC(0);
   if (!hdc)
      return FALSE;

// Get the logfont for the printer font.

   cf.lStructSize    = sizeof(cf);
   cf.hwndOwner      = hwnd;
   cf.hDC            = hdc;
   cf.lpLogFont      = lf;    // give initial font
   cf.iPointSize     = 0;     // they set
   cf.Flags          = CF_INITTOLOGFONTSTRUCT | CF_FORCEFONTEXIST |
                        CF_PRINTERFONTS;
   cf.rgbColors      = 0;     // with CF_EFFECTS
   cf.lCustData      = 0;     // for Hook Function
   cf.lpfnHook       = 0;
   cf.lpTemplateName = 0;
   cf.hInstance      = hInst;
   cf.lpszStyle      = 0;
   cf.nFontType      = 0;
   cf.nSizeMin       = 5;     // arbitrary
   cf.nSizeMax       = 500;   // "

   bRet = ChooseFont(&cf);

// Delete the DC.

   DeleteDC(hdc);

   return bRet;
}

/****************************************************************************/

BOOL SaveCommonDlg(HWND hwnd, HANDLE hInst, LPSTR lpszFile, LPSTR lpszTitle)
{
   OPENFILENAME ofn;
   char     lpstrFilter[] = "All Files (*.*) *.* ";

   *lpszFile = 0;
   lpstrFilter[15] = 0;
   lpstrFilter[19] = 0;

   ofn.lStructSize      = sizeof(ofn);
   ofn.hwndOwner        = hwnd;
   ofn.hInstance        = hInst;
   ofn.lpstrFilter      = lpstrFilter;
   ofn.lpstrCustomFilter= 0;
   ofn.nMaxCustFilter   = 0;
   ofn.nFilterIndex     = 0;
   ofn.lpstrFile        = lpszFile;
   ofn.nMaxFile         = 511;
   ofn.lpstrFileTitle   = 0;
   ofn.nMaxFileTitle    = 0;
   ofn.lpstrInitialDir  = 0;
   ofn.lpstrTitle       = lpszTitle;
   ofn.Flags            = OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT |
                           OFN_PATHMUSTEXIST;
   ofn.nFileOffset      = 0;  //passing 0 in lpszFile right now
   ofn.nFileExtension   = 0;
   ofn.lpstrDefExt      = 0;
   ofn.lCustData        = 0;
   ofn.lpfnHook         = 0;
   ofn.lpTemplateName   = 0;

   return   GetSaveFileName(&ofn);
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\cdlg.h ===
/*
 * CDLG.H
 *
 */


BOOL OpenCommonDlg(HWND hwnd, HANDLE hInst, LPSTR lpszFile, LPSTR lpszTitle);
BOOL SaveCommonDlg(HWND hwnd, HANDLE hInst, LPSTR lpszFile, LPSTR lpszTitle);
BOOL FontCommonDlg(HWND hwnd, HANDLE hInst, LOGFONT FAR* lf);
BOOL PrinterFontCommonDlg(HWND hwnd, HANDLE hInst, LOGFONT FAR* lf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\gdiff.c ===
/*
 * GDIFF.C
 *
 */


#include <windows.h>
#include "cdlg.h"
#include "dlg.h"
#include "junk.h"
#include "load.h"
#include "mem.h"
#include "rerror.h"
#include "id.h"
#include "inifile.h"
#include "prtdoc.h"

/****************************************************************************/

#define     HSCROLL_MAX     247

HMENU       hMenu;
HANDLE      hInst;
HWND        hwnd;
ALLYOUNEED  all;
char        szScompDir[256];
char        szScompFile[256];
char        szCmdLine[256];

int         gwMouseScroll = 0;      // Do we provide that funky mouse scrolling?

char  szIniFile[] = "gdiff.ini";
char  szSection[] = "Settings";
char  szSectionPrt[] = "Printer";

char  szMaxFiles[] = "The maximum number of files has been reached.";

char  szFile1[256];  // For the Diff strings.
char  szFile2[256];

/****************************************************************************/

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void VScrollLogic(HANDLE hwnd, int nVScrollInc);
void Flail(LPSTR lp);

/****************************************************************************/

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpszCmdParam, int nCmdShow)
{
   static char szAppName[] = "GDiff";
   MSG      msg;
   WNDCLASS wndclass;

   hInst = hInstance;

   if (!hPrevInst) {
      wndclass.style          = CS_HREDRAW | CS_VREDRAW;
      wndclass.lpfnWndProc    = WndProc;
      wndclass.cbClsExtra     = 0;
      wndclass.cbWndExtra     = 0;
      wndclass.hInstance      = hInst;
      wndclass.hIcon          = LoadIcon(hInst, szAppName);
      wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
      wndclass.hbrBackground  = NULL;
      wndclass.lpszMenuName   = NULL;
      wndclass.lpszClassName  = szAppName;

      RegisterClass(&wndclass);
   }

   hMenu = LoadMenu(hInst, szAppName);

   hwnd = CreateWindow(szAppName,
            "GDiff",
            WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            0,
            hMenu,
            hInst,
            0);

   // Reads and displays the window.
   vReadWindowPos(hwnd, nCmdShow, szIniFile, szSection);

   // If there is a command line file, we dump it into szScompFile.
   // Then we do a serious hack to load the Scomp.
   PatchCommandLine(hwnd, lpszCmdParam);

   while(GetMessage(&msg, 0, 0, 0)) {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
   }

   return msg.wParam;
}

/****************************************************************************/

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   int            ret;

   HDC            hdc;
   PAINTSTRUCT    ps;
   RECT           rect;
   int            nVScrollInc;
   int            nHScrollInc;
   HCURSOR        hCursor;
   int            i;
   BYTE           temp;


   switch(message) {
      case WM_PAINT:
         hdc = BeginPaint(hwnd, &ps);
         SelectObject(hdc, all.hFont);
         if (all.bits & ALL_INVALID)
            PaintBlank(hdc, &ps);
         else
            PaintEverything(hdc, &ps);
         EndPaint(hwnd, &ps);
         return 0;

      case WM_SIZE:
         if (LOWORD(lParam) != 0) {
            all.cxBar = MulDiv(LOWORD(lParam), all.cxBar, all.cxClient);
            all.cxClient = LOWORD(lParam);
            all.cyClient = HIWORD(lParam);
            all.nLinesPerPage = all.cyClient / all.yHeight;

            if (all.bits & ALL_INVALID)
               return 0;

            all.lpFileData[all.iFile].nVScrollMax = max(0,
                  all.lpFileData[all.iFile].nTLines - all.nLinesPerPage);
            all.lpFileData[all.iFile].nVScrollPos = min(
                  all.lpFileData[all.iFile].nVScrollPos,
                  all.lpFileData[all.iFile].nVScrollMax);

            if (all.bits & ALL_VSCROLL)
			{
				SCROLLINFO si;
				si.cbSize = sizeof(SCROLLINFO);
				si.fMask = SIF_PAGE | SIF_RANGE;
				si.nMin = 0;
                si.nMax = all.lpFileData[all.iFile].nTLines;
				si.nPage = all.nLinesPerPage;
				SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
                //SetScrollRange(hwnd, SB_VERT, 0, all.lpFileData[all.iFile].nVScrollMax, FALSE);
			}
            SetScrollPos(hwnd, SB_VERT, all.lpFileData[all.iFile].nVScrollPos, TRUE);
            if (all.bits & ALL_HSCROLL)
			{
				SetScrollRange(hwnd, SB_HORZ, 0, HSCROLL_MAX, 0);
			}
            SetScrollPos(hwnd, SB_HORZ, all.lpFileData[all.iFile].nHScrollPos, 1);
         }
         return 0;

      case WM_HSCROLL:
         if (all.bits & ALL_INVALID)
            return 0;

         switch(LOWORD(wParam)) {

         case SB_LEFT:
            nHScrollInc = -all.lpFileData[all.iFile].nHScrollPos;
            break;

         case SB_RIGHT:
            nHScrollInc = HSCROLL_MAX - all.lpFileData[all.iFile].nHScrollPos;
            break;

         case SB_LINELEFT:
            nHScrollInc = -1;
            break;

         case SB_LINERIGHT:
            nHScrollInc = 1;
            break;

         case SB_PAGELEFT:
            nHScrollInc = -8;
            break;

         case SB_PAGERIGHT:
            nHScrollInc = 8;
            break;

         case SB_THUMBTRACK:
         case SB_THUMBPOSITION:
            nHScrollInc = HIWORD(wParam) - all.lpFileData[all.iFile].nHScrollPos;
            break;

         default:
            nHScrollInc = 0;
            break;
         }
         if (nHScrollInc = max(-all.lpFileData[all.iFile].nHScrollPos,  min(
               nHScrollInc, HSCROLL_MAX - all.lpFileData[all.iFile].nHScrollPos))) {
            all.lpFileData[all.iFile].nHScrollPos += nHScrollInc;
            all.lpFileData[all.iFile].xHScroll = all.lpFileData[all.iFile].nHScrollPos * all.tm.tmAveCharWidth;
            SetScrollPos(hwnd, SB_HORZ, all.lpFileData[all.iFile].nHScrollPos, 1);
            InvalidateRect(hwnd, 0, 0);
         }
         return 0;


      case WM_VSCROLL:
         if (all.bits & ALL_INVALID)
            return 0;

         switch(LOWORD(wParam)) {

         case SB_TOP:
            nVScrollInc = -all.lpFileData[all.iFile].nVScrollPos;
            break;

         case SB_BOTTOM:
            nVScrollInc = all.lpFileData[all.iFile].nVScrollMax - all.lpFileData[all.iFile].nVScrollPos;
            break;

         case SB_LINEUP:
            nVScrollInc = -1;
            break;

         case SB_LINEDOWN:
            nVScrollInc = 1;
            break;

         case SB_PAGEUP:
            nVScrollInc = min(-1, -all.nLinesPerPage);
            break;

         case SB_PAGEDOWN:
            nVScrollInc = max(1, all.nLinesPerPage);
            break;

         case SB_THUMBPOSITION:
         case SB_THUMBTRACK:
            nVScrollInc = HIWORD(wParam) - all.lpFileData[all.iFile].nVScrollPos;
            break;

         default:
            nVScrollInc = 0;
            break;
         }
         VScrollLogic(hwnd, nVScrollInc);
         return 0;

      case WM_KEYDOWN:
         switch(LOWORD(wParam)) {
         case VK_HOME:
            SendMessage(hwnd, WM_VSCROLL, SB_TOP, 0L);
            break;

         case VK_END:
            SendMessage(hwnd, WM_VSCROLL, SB_BOTTOM, 0L);
            break;

         case VK_PRIOR:
            SendMessage(hwnd, WM_VSCROLL, SB_PAGEUP, 0L);
            break;

         case VK_NEXT:
            SendMessage(hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L);
            break;

         case VK_UP:
            SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, 0L);
            break;

         case VK_DOWN:
            SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, 0L);
            break;

         case VK_LEFT:
            if (GetKeyState(VK_CONTROL) < 0)
                SendMessage(hwnd, WM_HSCROLL, SB_LEFT, 0L);
			else
				SendMessage(hwnd, WM_HSCROLL, SB_PAGELEFT, 0L);
            break;

         case VK_RIGHT:
            if (GetKeyState(VK_CONTROL) < 0)
                SendMessage(hwnd, WM_HSCROLL, SB_RIGHT, 0L);
			else
				SendMessage(hwnd, WM_HSCROLL, SB_PAGERIGHT, 0L);
            break;
         }

         if ((wParam >= VK_F1) && (wParam <= VK_F12)) {
            i = wParam - VK_F1;     // now 0-11
            switch(all.Function[i]) {
            case 1:
               SendMessage(hwnd, WM_COMMAND, IDM_NEXT, 0);
               break;
            case 2:
               SendMessage(hwnd, WM_COMMAND, IDM_PREV, 0);
               break;
            case 3:
            case 4:
               all.iFileLast = all.iFile;
               if (all.iFileLast != NMAXFILES) {
                  if (all.Function[i] == 3)
                     temp = (all.iFile + 1) % all.nFiles;
                  else
                     temp = (all.iFile)?(all.iFile - 1):(all.nFiles - 1);
                  all.bits &= ~ALL_INVALID;
                  ret = ChangeFile(temp);
                  if (!ret) {
                     all.iFile = all.iFileLast;
                     ret = ReLoadCurrentFile();
                     if (!ret) {
                        XXX("\n\rHOSED!!!");
                        all.bits |= ALL_INVALID;
                     }
                  }
                  else {
                     UpdateMenu(hwnd);
                  }
                  InvalidateRect(hwnd, 0, 0);
                  SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
                     (((LPARAM) all.cyClient)<<16) | all.cxClient);
                  UpdateWindow(hwnd);
               }
               break;
            case 5:
               temp = all.iFile;
               if (all.iFileLast != NMAXFILES) {
                  all.bits &= ~ALL_INVALID;
                  ret = ChangeFile(all.iFileLast);
                  if (!ret) {
                     all.iFile = temp;
                     ret = ReLoadCurrentFile();
                     if (!ret) {
                        XXX("\n\rHOSED!!!");
                        all.bits |= ALL_INVALID;
                     }
                  }
                  else {
                     all.iFileLast = temp;
                     UpdateMenu(hwnd);
                  }
                  InvalidateRect(hwnd, 0, 0);
                  SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
                     (((LPARAM) all.cyClient)<<16) | all.cxClient);
                  UpdateWindow(hwnd);
               }
               break;
            case 6:
               SendMessage(hwnd, WM_COMMAND, IDM_OPEN, 0);
               break;
            }
         }
         return 0;

      case WM_RBUTTONDOWN:
         all.cxBar = LOWORD(lParam);
         InvalidateRect(hwnd, 0, 0);
         return 0;

      case WM_LBUTTONDOWN:
         if (gwMouseScroll) {
            if ((int)(short)HIWORD(lParam) > all.cyClient/2)
               SendMessage(hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L);
            else
               SendMessage(hwnd, WM_VSCROLL, SB_PAGEUP, 0L);
         }
         return 0;


      case WM_COMMAND:
         switch(LOWORD(wParam)) {
         case IDM_ABOUT:
            ShellAbout(hwnd, (LPCSTR)"GDiff 1.10",
                       (LPCSTR)"by Raymond E. Endres",
                       LoadIcon(hInst, (LPCSTR)"GDiff"));
            break;

         case IDM_SCOMP:
            if (all.nFiles == NMAXFILES) {
               MessageBox(hwnd, szMaxFiles, 0, MB_OK | MB_ICONEXCLAMATION);
               break;
            }

            {
               OFSTRUCT    ofstr;
               ofstr.cBytes = sizeof(ofstr);
               if (OpenFile(szScompFile, &ofstr, OF_EXIST) == HFILE_ERROR)
                  szScompFile[0] = 0;
            }

            if (OpenCommonDlg(hwnd, hInst, szScompFile, "Open Scomp File")) {
               MakeScompDirectory();
            }
            else {
               return 0;
            }
//            if (~all.bits & ALL_SCOMPLD) {
               all.bits |= ALL_SCOMPLD;
               hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
               all.bits &= ~ALL_INVALID;
               all.iFileLast = all.iFile;
               ret = ReadScomp(hwnd);
               if (!ret) {
                  all.iFile = all.iFileLast;
                  ret = ReLoadCurrentFile();
                  if (!ret) {

// might want to prefix the XXX with :
// if (all.iFile != NMAXFILES) ...

                     XXX("\n\rHOSED!!!");
                     all.bits |= ALL_INVALID;
                  }
               }
               else {
                  UpdateMenu(hwnd);
               }
               SetCursor(hCursor);
               InvalidateRect(hwnd, 0, 0);
               SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
                  (((LPARAM) all.cyClient)<<16) | all.cxClient);
               UpdateWindow(hwnd);
//            }
            break;

         case IDM_OPEN:
            if (all.nFiles == NMAXFILES) {
               MessageBox(hwnd, szMaxFiles, 0, MB_OK | MB_ICONEXCLAMATION);
               break;
            }
            szFile1[0] = 0;        // want a null string
            if (OpenCommonDlg(hwnd, hInst, szFile1, "Open File")) {
               hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
               all.bits &= ~ALL_INVALID;
               all.iFileLast = all.iFile;
               ret = ReadThisFile(szFile1);
               if (!ret) {
                  all.iFile = all.iFileLast;
                  ret = ReLoadCurrentFile();
                  if (!ret) {
                     XXX("\n\rHOSED!!!");
                     all.bits |= ALL_INVALID;
                  }
               }
               else {
                  AddFileToMenu(all.iFile);
                  UpdateMenu(hwnd);
               }
               SetCursor(hCursor);
               InvalidateRect(hwnd, 0, 0);
               SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
                  (((LPARAM) all.cyClient)<<16) | all.cxClient);
               UpdateWindow(hwnd);
            }
            else
               XXX("\n\rOpenCommonDlg failed!");
            break;

         case IDM_SCREENFONT:
            if (FontCommonDlg(hwnd, hInst, &all.lf)) {
               DeleteObject(all.hFont);
               hdc = GetDC(hwnd);
               all.hFont = CreateFontIndirect(&all.lf);
               SelectObject(hdc, all.hFont);
               GetTextMetrics(hdc, &all.tm);
               all.yBorder = all.tm.tmExternalLeading;
               all.yHeight = all.tm.tmHeight + all.tm.tmExternalLeading;
               all.tabDist = all.tm.tmAveCharWidth * all.tabChars;
               if (~all.bits & ALL_INVALID)
                  all.lpFileData[all.iFile].xHScroll = all.lpFileData[all.iFile].nHScrollPos * all.tm.tmAveCharWidth;
               ReleaseDC(hwnd, hdc);
               InvalidateRect(hwnd, 0, 0);
               SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
                  (((LPARAM) all.cyClient)<<16) | all.cxClient);
               UpdateWindow(hwnd);
            }
            else
               XXX("\n\rFontCommonDlg failed!");
            break;

         case IDM_PRINTERFONT:
            PrinterFontCommonDlg(hwnd, hInst, &glfPrinter);
            break;

         case IDM_MOUSESCR:
            if (all.bits & ALL_MOUSESCR) {
               all.bits &= ~ALL_MOUSESCR;
               CheckMenuItem(hMenu, IDM_MOUSESCR, MF_UNCHECKED);
               gwMouseScroll = 0;
            }
            else {
               all.bits |= ALL_MOUSESCR;
               CheckMenuItem(hMenu, IDM_MOUSESCR, MF_CHECKED);
               gwMouseScroll = 1;
            }
            break;

         case IDM_PRINTCHANGES:
            if (all.bits & ALL_PRINTCHANGES) {
               all.bits &= ~ALL_PRINTCHANGES;
               CheckMenuItem(hMenu, IDM_PRINTCHANGES, MF_UNCHECKED);
            }
            else {
               all.bits |= ALL_PRINTCHANGES;
               CheckMenuItem(hMenu, IDM_PRINTCHANGES, MF_CHECKED);
            }
            break;

         case IDM_HSCROLL:
            if (all.bits & ALL_HSCROLL) {
               all.bits &= ~ALL_HSCROLL;
               SetScrollRange(hwnd, SB_HORZ, 0, 0, 0);
               CheckMenuItem(hMenu, IDM_HSCROLL, MF_UNCHECKED);
            }
            else {
               all.bits |= ALL_HSCROLL;
               if (all.bits & ALL_INVALID)
                  SetScrollRange(hwnd, SB_HORZ, 0, 0, 0);
               else {
                  SetScrollRange(hwnd, SB_HORZ, 0, HSCROLL_MAX, 0);
                  SetScrollPos(hwnd, SB_HORZ, all.lpFileData[all.iFile].nHScrollPos, 1);
               }
               CheckMenuItem(hMenu, IDM_HSCROLL, MF_CHECKED);
            }
            break;

         case IDM_VSCROLL:
            if (all.bits & ALL_VSCROLL) {
               all.bits &= ~ALL_VSCROLL;
               SetScrollRange(hwnd, SB_VERT, 0, 0, 0);
               CheckMenuItem(hMenu, IDM_VSCROLL, MF_UNCHECKED);
            }
            else {
               all.bits |= ALL_VSCROLL;
               if (all.bits & ALL_INVALID) {
                  SetScrollRange(hwnd, SB_VERT, 0, 0, 0);
               }
               else {
                  SetScrollRange(hwnd, SB_VERT, 0, all.lpFileData[all.iFile].nVScrollMax, 0);
                  SetScrollPos(hwnd, SB_VERT, all.lpFileData[all.iFile].nVScrollPos, 1);
               }
               CheckMenuItem(hMenu, IDM_VSCROLL, MF_CHECKED);
            }
            break;

         case IDM_TAB1:
         case IDM_TAB2:
         case IDM_TAB3:
         case IDM_TAB4:
         case IDM_TAB5:
         case IDM_TAB6:
         case IDM_TAB7:
         case IDM_TAB8:
            CheckMenuItem(hMenu, IDM_TAB0 + all.tabChars, MF_UNCHECKED);
            CheckMenuItem(hMenu, LOWORD(wParam), MF_CHECKED);
            all.tabChars = LOWORD(wParam) - IDM_TAB0;
            all.tabDist = all.tm.tmAveCharWidth * all.tabChars;
            InvalidateRect(hwnd, 0, 0);
            break;

         case IDM_NEXT:
            if (all.bits & ALL_INVALID)
               return 0;

            for (i=all.lpFileData[all.iFile].nVScrollPos+2; i<all.lpFileData[all.iFile].nTLines; i++) {
               if (((LINELISTSTRUCT _huge*) all.lpFileData
               [all.iFile].hpLines)[i].flags
               & LLS_NDIFF) {
                  VScrollLogic(hwnd, i - 1 - all.lpFileData[all.iFile].nVScrollPos);
                  break;
               }
            }
            break;

         case IDM_PREV:
            if (all.bits & ALL_INVALID)
               return 0;

            for (i=all.lpFileData[all.iFile].nVScrollPos; i>=0; i--) {
               if (((LINELISTSTRUCT _huge*) all.lpFileData
               [all.iFile].hpLines)[i].flags
               & LLS_NDIFF) {
                  VScrollLogic(hwnd, i - 1 - all.lpFileData[all.iFile].nVScrollPos);
                  break;
               }
            }
            break;

         case IDM_NFILE:
            SendMessage(hwnd, WM_KEYDOWN, VK_F2, 0);
            break;

         case IDM_PFILE:
            SendMessage(hwnd, WM_KEYDOWN, VK_F1, 0);
            break;

         case IDM_SYSTEM:
            all.bits |= ALL_SYSTEM;
            GetSystemColors();
            CheckMenuItem(hMenu, IDM_SYSTEM, MF_CHECKED);
            if (all.bits & ALL_CUSTOM) {
               CheckMenuItem(hMenu, IDM_CUSTOM, MF_UNCHECKED);
               all.bits &= ~ALL_CUSTOM;
            }
            InvalidateRect(hwnd, 0, 0);
            break;

         case IDM_CUSTOM:
            {
               DLGPROC  DlgProc = (DLGPROC) MakeProcInstance(ColorProc,
                     hInst);
               ret = DialogBox(hInst, MAKEINTRESOURCE(IDD_COLOR), hwnd,
                     DlgProc);
               FreeProcInstance((FARPROC)DlgProc);
            }
            all.bits |= ALL_CUSTOM;
            GetCustomColors();
            CheckMenuItem(hMenu, IDM_CUSTOM, MF_CHECKED);
            if (all.bits & ALL_SYSTEM) {
               CheckMenuItem(hMenu, IDM_SYSTEM, MF_UNCHECKED);
               all.bits &= ~ALL_SYSTEM;
            }
            InvalidateRect(hwnd, 0, 0);
            break;

         case IDM_PRINTFILE:
            {
               HCURSOR  hCursor = SetCursor(LoadCursor(0, IDC_WAIT));
               PrintDoc(hwnd, all.iFile);
               SetCursor(hCursor);
            }
            break;

         case IDM_PRINTALL:
            {
               HCURSOR  hCursor;
               int      j;

               if (MessageBox(hwnd, "Are you sure?", "Print All", MB_YESNO)
                        == IDYES) {
                  hCursor = SetCursor(LoadCursor(0, IDC_WAIT));
                  for (j=0; j<(int)all.nFiles; j++) {
                     PrintDoc(hwnd, j);
                  }
                  SetCursor(hCursor);
               }
            }
            break;

         case IDM_EXIT:
            SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0);
            break;

         }

         /* essentially, another case statement here !!! */
         if ((LOWORD(wParam) >= IDM_V0) && (LOWORD(wParam) <= IDM_VMAX)) {
            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            all.bits &= ~ALL_INVALID;
            all.iFileLast = all.iFile;
            ret = ChangeFile((BYTE)(LOWORD(wParam) - IDM_V0));
            if (!ret) {
               all.iFile = all.iFileLast;
               ret = ReLoadCurrentFile();
               if (!ret) {
                  XXX("\n\rHOSED!!! cannot load anything.");
                  all.bits |= ALL_INVALID;
               }
            }
            SetCursor(hCursor);
            UpdateMenu(hwnd);
            InvalidateRect(hwnd, 0, 0);
            SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
               (((LPARAM) all.cyClient)<<16) | all.cxClient);
            UpdateWindow(hwnd);
         }

         return 0;

      case WM_DESTROY:
         DeleteObject(all.hFont);
         vWriteWindowPos(hwnd, szIniFile, szSection);
         vWriteDefaultFont(&all.lf, szIniFile, szSection);
         vWriteDefaultFont(&glfPrinter, szIniFile, szSectionPrt);
         vWriteIniSwitches(szIniFile, szSection);
         FreeEverything();
         PostQuitMessage(0);
         return 0;

      case WM_CREATE:
         hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
         vReadDefaultFont(&all.lf, szIniFile, szSection);
         vReadDefaultFont(&glfPrinter, szIniFile, szSectionPrt);
         ret = GMemInitialize();
         if (!ret) {
            Flail("GMemInitialize() failed.");
            PostQuitMessage(0);
            return 0;
         }

         GetClientRect(hwnd, &rect);
         all.cxBar = rect.right / 2;
         all.cxClient = rect.right;       // Need it before WM_SIZE.

         hdc = GetDC(hwnd);
         all.yDPI = GetDeviceCaps(hdc, LOGPIXELSY);
         all.hFont = CreateFontIndirect(&all.lf);
         SelectObject(hdc, all.hFont);
         GetTextMetrics(hdc, &all.tm);
         ReleaseDC(hwnd, hdc);

         vReadIniSwitches(szIniFile, szSection);
         all.bits |= ALL_INVALID;
         if (all.bits & ALL_MOUSESCR) {
            gwMouseScroll = 1;
            CheckMenuItem(hMenu, IDM_MOUSESCR, MF_CHECKED);
         }
         CheckMenuItem(hMenu, IDM_TAB0 + all.tabChars, MF_CHECKED);

         SetWindowsColors();
         DealWithFlags();

         all.yBorder = all.tm.tmExternalLeading;
         all.yHeight = all.tm.tmHeight + all.tm.tmExternalLeading;
         all.tabDist = all.tm.tmAveCharWidth * all.tabChars;

         all.iFile = NMAXFILES;
         all.iFileLast = NMAXFILES;

         SetCursor(hCursor);

         SetScrollRange(hwnd, SB_HORZ, 0, 0, 0);
         SetScrollRange(hwnd, SB_VERT, 0, 0, 0);
         return 0;
   }

   return DefWindowProc(hwnd, message, wParam, lParam);
}

/***************************************************************************/

void Flail(LPSTR lp)
{
   MessageBox(hwnd, lp, 0, MB_OK | MB_ICONEXCLAMATION);
}

/***************************************************************************/

void VScrollLogic(HANDLE hwnd, int nVScrollInc)
{
   if (nVScrollInc = max(-all.lpFileData[all.iFile].nVScrollPos, min(nVScrollInc,
            all.lpFileData[all.iFile].nVScrollMax - all.lpFileData[all.iFile].nVScrollPos))) {
         all.lpFileData[all.iFile].nVScrollPos += nVScrollInc;
         ScrollWindow(hwnd, 0, -all.yHeight * nVScrollInc, 0, 0);
         SetScrollPos(hwnd, SB_VERT, all.lpFileData[all.iFile].nVScrollPos, 1);
         UpdateWindow(hwnd);
   }
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\dlg.h ===
/*
 * DLG.H
 *
 */


BOOL CALLBACK ColorProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\resetusr\resetusr.cpp ===
/****************************************************************************
*
*	resetusr.cpp
*
*       Dev applet to change the default speech user
*
*	Owner: cthrash
*	Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

#include "stdafx.h"
#include "resetusr.h"

/**********************************************************************
* main *
*------*
*
*	Description:
*
*       Main entry point.
*
* 	Return:
*
*       S_OK, E_INVALIDARG
*
************************************************************* cthrash */

BOOL g_fVerbose = FALSE;

int APIENTRY 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    char * pszUserName;
    BOOL fReset = ParseCmdLine(lpCmdLine, &pszUserName);
    HRESULT hr;

    if (fReset)
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            hr = ResetUser(pszUserName);
                
            CoUninitialize();
        }
    }
    else
    {
        hr = Report("Usage:\tresetusr [-v] [user-name]\n"
                          "\tresetusr [-v] -default\n"
                          "\tresetusr -?\n",
                     E_INVALIDARG);
    }

	return (int)hr;
}

/**********************************************************************
* ParseCmdLine *
*--------------*
*
*	Description:
*
*       Parse the command line.  Argument can be a name, or the string
*       -default.
*
* 	Return:
*
*       TRUE -- delete the user specified,
*       FALSE -- show usage info
*
************************************************************* cthrash */

BOOL
ParseCmdLine(
    char * pszCmdLine,      // [in] Command line arguments
    char ** ppszUserName)   // [out] 
{
    BOOL fReset = FALSE;

    while (*pszCmdLine)
    {
        if (0 == strnicmp(pszCmdLine, "-v", 2))
        {
            g_fVerbose = TRUE;
        }
        else
        {
            if (0 == strnicmp(pszCmdLine, "-default", 8))
            {
                *ppszUserName = NULL;
                fReset = TRUE;
            }
            else if (0 != strnicmp(pszCmdLine, "-?", 2))
            {
                *ppszUserName = pszCmdLine;
                fReset = TRUE;
            }
            else
            {
                fReset = FALSE;
            }
            
            break;
        }

        for (pszCmdLine += 2;isspace((unsigned)(unsigned char)*pszCmdLine); pszCmdLine++);
    }

    return fReset;
}

/*****************************************************************************
* ResetUser *
*-----------*
*
*   Description:    Reset a user's AM state.
*
*   Return:         HRESULT
*
***************************************************************** cthrash ***/

HRESULT 
ResetUser(
    char * pszName)       // [in] Name; NULL implies the default user
{
    HRESULT hr, hrReturn;
    CComPtr<ISpResourceManager> cpResMgr;
    CComPtr<ISpObjectToken> cpEngineToken;
    CComPtr<ISpObjectToken> cpUserToken;
    CComPtr<ISpDataKey> cpDataKey;
    CComPtr<ISpDataKey> cpSubDataKey;
    CSpDynamicString dstrEngineGUID;
    CSpDynamicString dstrReport;
    

    hr = cpResMgr.CoCreateInstance(CLSID_SpResourceManager);

    if (SUCCEEDED(hr))
    {
        // Should we provide a mechanism to pick engine?  Currently we pick the default.

        hr = cpResMgr->GetObjectToken(SPCAT_RECOGNIZERS, &cpEngineToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpEngineToken->GetID(&dstrEngineGUID);
    }
    
    if (SUCCEEDED(hr))
    {
        const WCHAR * pch = wcsrchr(dstrEngineGUID, L'\\');

        if (pch)
        {
            pch++;
            memmove((WCHAR *)dstrEngineGUID, pch, sizeof(WCHAR) * (1 + wcslen(pch)));
        }
    }

    // Get the user token;
    if (!pszName)
    {
        if (SUCCEEDED(hr))
        {
            hr = cpResMgr->GetObjectToken(SPCAT_SPEECHUSER, &cpUserToken);
        }
    }
    else
    {
        BOOL fFoundMatch = FALSE;
        CComPtr<IEnumSpObjectTokens> cpEnum;
        ULONG celtFetched;
        CSpDynamicString dstrName = pszName;

        if (SUCCEEDED(hr))
        {
            hr = cpResMgr->EnumTokens(SPCAT_SPEECHUSER, NULL, NULL, &cpEnum);
        }
        if(hr == S_FALSE)
        {
            hr = SPERR_NOT_FOUND;
        }

        if (SUCCEEDED(hr))
        {
            hr = cpEnum->GetCount(&celtFetched);
        }

        while (!fFoundMatch && SUCCEEDED(hr))
        {
            ISpRegistryObjectToken *pRegToken = 0;

            hr = cpEnum->Next(1, (ISpObjectToken**)&pRegToken, &celtFetched);

            if (hr != S_OK)
            {
                break;
            }

            if (SUCCEEDED(hr))
            {
                CSpDynamicString dstrNameT;

                hr = SpGetDescription(pRegToken, &dstrNameT);

                fFoundMatch = 0 == wcsicmp(dstrName, dstrNameT);
            }

            if (fFoundMatch)
            {
                cpUserToken = pRegToken;
            }

            if (pRegToken)
            {
                pRegToken->Release();
            }
        }
    }

    hrReturn = hr;
    
    if (SUCCEEDED(hr))
    {
        hr = cpUserToken->OpenKey(dstrEngineGUID, &cpDataKey);
        hrReturn = (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKey->OpenKey(L"files", &cpSubDataKey);
        hrReturn = (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr;
    }

    // Nuke all the files first.
    
    if (SUCCEEDED(hr))
    {
        ULONG iKey;

        for (iKey = 0; hr == S_OK; iKey++)
        {
            CSpDynamicString dstrFileType;
            CSpDynamicString dstrFilePath;
            
            hr = cpSubDataKey->EnumValues(iKey, &dstrFileType);

            if (SUCCEEDED(hr))
            {
                hr = cpSubDataKey->GetStringValue(dstrFileType, &dstrFilePath);
            }

            if (SUCCEEDED(hr))
            {
                USES_CONVERSION;
                
                hr = DeleteFile(W2T(dstrFilePath)) ? S_OK : HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

                if (g_fVerbose)
                {
                    dstrReport.Append(L"Deleting ");
                    dstrReport.Append2(dstrFilePath, SUCCEEDED(hr) ? L" -- Success\n" : L" -- Fail\n");
                }
            }
        }

        hrReturn = hr = (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ? S_OK : hr;
    }

    // Nuke the files key
    
    if (SUCCEEDED(hr))
    {
        cpSubDataKey.Release();

        hr = cpDataKey->DeleteKey(L"files");            

        if (g_fVerbose)
        {
            CSpDynamicString dstrID;

            cpUserToken->GetID(&dstrID);

            dstrReport.Append2(L"Deleting Key ", dstrID);
            dstrReport.Append2(L"\\", dstrEngineGUID);
            dstrReport.Append2(L"\\Files", SUCCEEDED(hr) ? L" -- Success\n" : L" -- Fail\n");
        }

        hrReturn = hr;
    }
    
    if (FAILED(hrReturn))
    {
        //Report("DataCouldn't find an appropriate user", E_INVALIDARG);
    }
    else if (g_fVerbose && dstrReport)
    {
        USES_CONVERSION;

        Report(W2A(dstrReport), hr);
    }

    return hrReturn;
}

/**********************************************************************
* Report *
*--------*
*
*	Description:
*
*       Show a message box, possibly indicating an error.
*
* 	Return:
*
*       The HRESULT passed in is returned, for the convenience of
*       the caller.
*
************************************************************* cthrash */

HRESULT Report(char * lpMsg, HRESULT hr)
{
    if (hr != S_OK || g_fVerbose)
    {
        const UINT uType = MB_OK | (FAILED(hr) ? MB_ICONERROR : MB_ICONINFORMATION);

        MessageBox(HWND_DESKTOP, lpMsg, "resetusr.exe", uType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\hash.c ===
/*
 * HASH.C
 *
 */
#include <windows.h>

DWORD hashpjw(char *sz)
{
   int   i;
   DWORD h = 0;
   DWORD g;

   for (i=1; i<=sz[0]; i++) {       // assumes sz[0] is string length
      h = (h << 4) + sz[i];
      if (g = h & 0xf0000000) {
         h = h ^ (g >> 24);
         h = h ^ g;
      }
   }

   return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\dlg.c ===
/*
 * DLG.C
 *
 */
#include <windows.h>
#include "junk.h"
#include "dlg.h"
#include "id.h"

/****************************************************************************/

int   iCurText;      // for the listbox
int   iCurColor;     // for the combo-box

/****************************************************************************/

#define SendIt(aaa) SendDlgItemMessage(hwnd, IDL_TEXT, LB_ADDSTRING, 0,\
                     (LPARAM)((LPSTR)(aaa)));

#define RC_DIF    2

/****************************************************************************/

void InitControls(HWND hwnd)
{
   HWND  hwndControl;
   int   i;

   SendIt("Bar Highlight");
   SendIt("Bar Shadow");
   SendIt("Bar Face");
   SendIt("Text");
   SendIt("Add Highlight Text");
   SendIt("Del Highlight Text");
   SendIt("Cmp Highlight Text");
   SendIt("Window");
   SendIt("Add Highlight");
   SendIt("Del Highlight");
   SendIt("Cmp Highlight");
   
   SendDlgItemMessage(hwnd, IDL_TEXT, LB_SETCURSEL, iCurText, 0);
   hwndControl = GetDlgItem(hwnd, IDL_TEXT);
   // maybe select something here

   // deal with the color box
   for (i=0; i<16; i++) {
      SendDlgItemMessage(hwnd, IDC_COLOR, CB_ADDSTRING, 0, 0);
   }
   iCurColor = all.CC[iCurText];
   SendDlgItemMessage(hwnd, IDC_COLOR, CB_SETCURSEL, iCurColor, 0);
}

/****************************************************************************/

void DrawColorRect(void)
{
}

/****************************************************************************/

BOOL CALLBACK ColorProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   LPDRAWITEMSTRUCT  lpDis;
   COLORREF          clrref1;
   COLORREF          clrref2;
   RECT              rc;

   switch (msg) {
      case WM_COMMAND:
         switch (wParam) {
            case IDCANCEL:
               EndDialog(hwnd, 0);
               break;
               
            case IDOK:
               EndDialog(hwnd, 0);
               break;
               
            case IDC_COLOR:
               if ((int)HIWORD(wParam) == CBN_SELCHANGE) {
                  iCurColor = (int) SendDlgItemMessage(hwnd, IDC_COLOR,
                        CB_GETCURSEL, 0, 0);
                  all.CC[iCurText] = iCurColor;
               }
               break;

            case IDL_TEXT:
               if ((int)HIWORD(wParam) == LBN_SELCHANGE) {
                  iCurText = (int) SendDlgItemMessage(hwnd, IDL_TEXT,
                        LB_GETCURSEL, 0, 0);
                  iCurColor = all.CC[iCurText];
                  SendDlgItemMessage(hwnd, IDC_COLOR, CB_SETCURSEL, iCurColor,
                        0);
               }
               break;
         }
         break;

      case WM_DRAWITEM:
         if (wParam == IDC_COLOR) {
            lpDis = (DRAWITEMSTRUCT FAR*) lParam;
            switch (lpDis->itemAction) {
               case ODA_DRAWENTIRE:
                  clrref1 = SetBkColor(lpDis->hDC, all.WinColors[lpDis->itemID]);
                  rc.left = lpDis->rcItem.left + RC_DIF;
                  rc.right = lpDis->rcItem.right - RC_DIF;
                  rc.top = lpDis->rcItem.top + RC_DIF;
                  rc.bottom = lpDis->rcItem.bottom - RC_DIF;
                  ExtTextOut(lpDis->hDC, 0, 0, ETO_OPAQUE, &rc, 0, 0, 0);
                  SetBkColor(lpDis->hDC, clrref1);
                  return 1;
                  
               case ODA_SELECT:
                  if (lpDis->itemState == ODS_SELECTED)
                     clrref2 = GetSysColor(COLOR_HIGHLIGHT);
                  else
                     clrref2 = GetBkColor(lpDis->hDC);
                  clrref1 = SetBkColor(lpDis->hDC, clrref2);
                  ExtTextOut(lpDis->hDC, 0, 0, ETO_OPAQUE, &(lpDis->rcItem), 0, 0, 0);
                  SetBkColor(lpDis->hDC, all.WinColors[lpDis->itemID]);
                  rc.left = lpDis->rcItem.left + RC_DIF;
                  rc.right = lpDis->rcItem.right - RC_DIF;
                  rc.top = lpDis->rcItem.top + RC_DIF;
                  rc.bottom = lpDis->rcItem.bottom - RC_DIF;
                  ExtTextOut(lpDis->hDC, 0, 0, ETO_OPAQUE, &rc, 0, 0, 0);
                  SetBkColor(lpDis->hDC, clrref1);
                  return 1;
                  
               case ODA_FOCUS:
                  DrawFocusRect(lpDis->hDC, &(lpDis->rcItem));
                  return 1;
            }
         }
         break;
         
      case WM_INITDIALOG:
         InitControls(hwnd);
         return 1;
   }
   
   return 0;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\id.h ===
/*
 * ID.H
 *
 */


// File menu:

#define  IDM_OPEN       10
#define  IDM_SCOMP      11
#define  IDM_EXIT       12
#define  IDM_ABOUT      14
#define  IDM_PRINTFILE  15
#define  IDM_PRINTALL   16
#define  IDM_PRINTCHANGES  17

// Search menu:

#define  IDM_NEXT    20
#define  IDM_PREV    21
#define  IDM_NFILE   22
#define  IDM_PFILE   23

// Module menu:

#define  IDM_V0      100
#define  IDM_VMAX    300

// Options menu:

#define  IDM_HSCROLL    40
#define  IDM_VSCROLL    41
#define  IDM_SCREENFONT 45
#define  IDM_SYSTEM     46
#define  IDM_CUSTOM     47
#define  IDM_MOUSESCR   48
#define  IDM_PRINTERFONT   49

#define  IDM_TAB0       60
#define  IDM_TAB1       61
#define  IDM_TAB2       62
#define  IDM_TAB3       63
#define  IDM_TAB4       64
#define  IDM_TAB5       65
#define  IDM_TAB6       66
#define  IDM_TAB7       67
#define  IDM_TAB8       68

/****************************************************************************/

#define  IDD_COLOR   1000
#define  IDL_TEXT    1001
#define  IDC_COLOR   1002
#define  IDT_1       1003
#define  IDT_2       1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\mem.h ===
/*
 * MEM.H
 *
 */


#define GMC_FILE	0
#define GMC_DIFF	1
#define GMC_LINES	2

int GMemInitialize(void);

BYTE GetMemoryChunk(BYTE index, BYTE gmc, DWORD dwSize);
void FreeMemoryChunk(BYTE index, BYTE gmc);
void UnlockMemoryChunk(BYTE index);
BYTE LockMemoryChunk(BYTE index);

void FreeEverything(void);




/*
*	GMemInitialize(): Global Allocates a block.  Zero inits it.  Cleans
* up after itself if it cannot lock or allocate the block.  Sets all
* FileBlock bits to FD_FREE.
*/

/*
*	FreeEverything(): Meant only for WM_DESTROY.  Cleans up everything.
*/

/*
*	GetMemoryChunk(): allocates and locks selected chunk.  Cleans up.
*/

/*
*	FreeMemoryChunk(): 
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\load.h ===
/*
 * LOAD.H
 *
 */


BYTE ReadThisFile(LPSTR lpstrFile);
BYTE ReadScomp(HWND hwnd);
BYTE ChangeFile(BYTE iFileIndex);
BYTE ReLoadCurrentFile(void);
void MakeScompDirectory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\inifile.h ===
/*
 * IniFile.H
 *
 */


void vReadWindowPos(HWND hwnd, int nCmdShow, char szIniFile[], char szSection[]);
void vWriteWindowPos(HWND hwnd, char szIniFile[], char szSection[]);

void vReadDefaultFont(LOGFONT *lf, char szIniFile[], char szSection[]);
void vWriteDefaultFont(LOGFONT *lf, char szIniFile[], char szSection[]);

void vReadIniSwitches(char szIniFile[], char szSection[]);
void vWriteIniSwitches(char szIniFile[], char szSection[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\junk.h ===
/*
 * JUNK.H
 *
 */
#define  NMAXFILES   100      // Max number of files
#define  NCHPERNAME  256      // Chars per name
//#define  MYENDSEG    0xfeff   // 0xffff - 256 chars

#define LLS_A     1     // add
#define LLS_D     2     // delete
#define LLS_CL    4     // change and text on left
#define LLS_CR    8     // change and text on right
#define LLS_NDIFF 16    // marks beginning of a new diff chunk

__inline DWORD GetTextExtent(HDC hdc, LPCSTR sz, int len)
{
	SIZE	size;
	GetTextExtentPoint(hdc, sz, len, &size);
	return MAKELONG(size.cx,size.cy);
}

__inline void MoveTo(HDC hdc, int x, int y)
{
	MoveToEx(hdc, x, y, NULL);
}

typedef struct {
   BYTE FAR*   lpl;
   BYTE        nlchars;    // WORD or BYTE ???
   BYTE FAR*   lpr;
   BYTE        nrchars;
   UINT        flags;
   UINT        junk1;      // sizeof(LLS)%64k must = 0
   UINT        junk2;
} LINELISTSTRUCT;


#define FD_FREE         1     // not used
#define FD_SINGLE       2     // single file, no diff
#define FD_DIFF         4     // file with diff
#define FD_SCOMP        8     // scomp file but no alloced diff
#define FD_SCOMPWDIFF   16    // scomp file with alloced diff


typedef struct {
   UINT        bits;          // random flags

   HANDLE      hFile;         // 0 means not allocated
   BYTE _huge* hpFile;        // 0 means not locked
   int         nLines;        // lines in file

   BYTE        lpName[NCHPERNAME];
   BYTE        lpNameOff;     // offset to actual filename

   HANDLE      hDiff;
   BYTE _huge* hpDiff;
   int         nDLines;       // lines added from dif
   int         nDiffBlocks;   // number of highlighted blocks

   HANDLE      hLines;
   BYTE _huge* hpLines;       // hp to line list
   int         nTLines;       // total lines = nLines + nDLines

   int         nVScrollPos;
   int         nVScrollMax;
   int         nHScrollPos;   // char position
   int         xHScroll;      // x position
} FILEDATA;


#define ALL_INVALID     1     // NO VALID FILES LOCKED!!!
#define ALL_SCOMPLD     2     // SCOMP is loaded
#define ALL_HSCROLL     8     // have a horizontal scroll bar
#define ALL_VSCROLL     16    // have a vertical scroll bar
#define ALL_SYSTEM      32    // system colors
#define ALL_CUSTOM      64    // custom colors
#define ALL_MOUSESCR    256   // uses mouse for funky left button scrolling
#define ALL_PRINTCHANGES 512  // prints only the pages with changes


#define ALL_BARHL    0     // bar highlight
#define ALL_BARSH    1     // bar shadow
#define ALL_BARFC    2     // bar face
#define ALL_TEXT     3     // text
#define ALL_TEXTA    4     // text under add highlight
#define ALL_TEXTD    5     // text under delete highlight
#define ALL_TEXTC    6     // text under compare highlight
#define ALL_BACK     7     // background
#define ALL_ADD      8     // add highlight
#define ALL_DEL      9     // delete highlight
#define ALL_CHG      10    // change highlight


typedef struct {
   UINT        bits;

   int         yDPI;             // vertical DPI of the screen
   LOGFONT     lf;
   HFONT       hFont;
   TEXTMETRIC  tm;
   int         yBorder;
   int         yHeight;
   int         tabChars;         // the number of characters in a tab
   int         tabDist;          // tabChars * tmAveCharWidth

   BYTE        iFile;
   BYTE        iFileLast;
   BYTE        nFiles;
   FILEDATA FAR*  lpFileData;

   int         cxClient;
   int         cyClient;
   int         cxBar;            //reference for center
   int         nLinesPerPage;

   BYTE        Function[12];     // Function key mappings

   DWORD       WinColors[16];    // the sacred windows colors
   DWORD       Col[11];          // current colors
   int         CC[11];           // to save custom
} ALLYOUNEED;

extern ALLYOUNEED all;           // in gdiff.c
extern HMENU      hMenu;         // in gdiff.c
extern char       szScompDir[];
extern char       szScompFile[];

void GetSystemColors(void);
void GetCustomColors(void);
void SetWindowsColors(void);

void PaintEverything(HDC, PAINTSTRUCT *);
void PaintBlank(HDC hdc, PAINTSTRUCT *ps);

void DealWithFlags(void);
void PatchCommandLine(HWND hwnd, LPSTR lp);

void AddFileToMenu(BYTE iFileIndex);
void UpdateMenu(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\load.c ===
#include <windows.h> 
#include <stdio.h>
#include "junk.h"
#include "load.h"
#include "mem.h"
#include "rerror.h"
#include "size.h"

#define  NMAXREAD 65500    // close to _lread max

char  lpTemp[256];         // temp string for '.dif' filename

void SetDiffFileName(void);
BYTE FindMeAFileDataIndex(void);
BYTE BuildLineList(void);
BYTE BuildSingleLineList(void);
BYTE MyReadFile(void);
BYTE ReadDiff(void);
WORD ReadScompNums(HFILE hf, BYTE _huge* NEAR* lpPos, int ch);
void ReadScompDeadLines(HFILE hf, int nLines, int ch);
void ReadScompCenter(HFILE hf);
void ReadScompLines(HFILE hf, UINT nLines, BYTE _huge* NEAR* lpPos, int ch);
void ReadScompHeader(HFILE hf, BYTE iFile);
void GetDiffValues(BYTE _huge* NEAR* lpDiffPos, BYTE *ch, WORD *lb, WORD *le,
         WORD *rb, WORD *re, WORD wSet);

/**************************************************************************/

BYTE ReadThisFile(LPSTR lpstrFile)
{
   BYTE FAR*   lp;
   BYTE     ret;
   int      i;

   if (all.iFile != NMAXFILES)
      UnlockMemoryChunk(all.iFile);
   all.iFile = FindMeAFileDataIndex();
   all.nFiles++;

   lp = all.lpFileData[all.iFile].lpName;
   for (i=0; lpstrFile[i]; i++)
      lp[i] = lpstrFile[i];
   lp[i] = 0;

   while ((lp[i] != '\\') && i)     // check for beginning or '\\'
      i--;
   if (lp[i] == '\\')
      i++;
   all.lpFileData[all.iFile].lpNameOff = i;

   ret = MyReadFile();       // fails if no memory or file does not open
   if (!ret) {
      all.nFiles--;
      return 0;
   }

   SetDiffFileName();
   
   ret = ReadDiff(); // ret: 0=no mem; 1=no file or success
   if (!ret) {
      FreeMemoryChunk(all.iFile, GMC_FILE);  // free hFile
      all.nFiles--;
      return 0;
   }

   if (all.lpFileData[all.iFile].hDiff) {
      ret = BuildLineList();     // fails if no memory
      if (!ret) {
         FreeMemoryChunk(all.iFile, GMC_FILE);
         FreeMemoryChunk(all.iFile, GMC_DIFF);
         all.nFiles--;
         return 0;
      }
      else
         all.lpFileData[all.iFile].bits = FD_DIFF;
   }
   else {
      ret = BuildSingleLineList();  // fails if no memory
      if (!ret) {
         FreeMemoryChunk(all.iFile, GMC_FILE);
         all.nFiles--;
         return 0;
      }
      else
         all.lpFileData[all.iFile].bits = FD_SINGLE;
   }

   return   1;
}

/**************************************************************************/

BYTE BuildLineList(void)
{
   LINELISTSTRUCT _huge*   hp;
   BYTE _huge*    hpFilePos;
   BYTE _huge*    hpDiffPos;
   BYTE  ret;
   DWORD dwSize;

   WORD  wOldILine;  // needed to mark beginings of diff blocks
   WORD  tlines;     // total number of lines
   WORD  iline;
   WORD  lline, rline, lb, le, rb, re;
   BYTE  ch;
   WORD  i, clmax;

   tlines = all.lpFileData[all.iFile].nLines +
       all.lpFileData[all.iFile].nDLines;
   all.lpFileData[all.iFile].nTLines = tlines;
   dwSize = sizeof(LINELISTSTRUCT) * (DWORD)(tlines + 1);

/* LLS structure is aligned in 64k so nothing special needed. */
   ret = GetMemoryChunk(all.iFile, GMC_LINES, dwSize);
   if (!ret) {
      XXX("\n\rLOAD:BuildLineList:GetMemoryChunk failed.");
      return 0;
   }
   hp = (LINELISTSTRUCT _huge*) all.lpFileData[all.iFile].hpLines;
   hpFilePos = all.lpFileData[all.iFile].hpFile;
   hpDiffPos = all.lpFileData[all.iFile].hpDiff;

   iline = 0;     // total lines; index for hp
   lline = 0;     // left line index
   rline = 0;     // right line index
   GetDiffValues(&hpDiffPos, &ch, &lb, &le, &rb, &re, 0);   // 0 clears a static

   while (iline < tlines) {
      if ((ch == 'a') && (lline == lb)) {
         wOldILine = iline;
         for (i=rb; i<=re; i++) {
            hp[iline].nlchars = 0;
            hp[iline].nrchars = *hpFilePos;
            hpFilePos++;
            hp[iline].lpl = 0;
            hp[iline].lpr = (BYTE FAR*) hpFilePos;
            hp[iline].flags = LLS_A;
            hpFilePos += hp[iline].nrchars;
            //if (LOWORD(hpFilePos) > MYENDSEG)
            //   hpFilePos += (~LOWORD(hpFilePos) + 1);
            hp[iline].nrchars--;    // carriage returns
            iline++;
            rline++;
         }
         hp[wOldILine].flags |= LLS_NDIFF;
         GetDiffValues(&hpDiffPos, &ch, &lb, &le, &rb, &re, 1);
      }
      else if ((ch == 'd') && (rline == rb)) {
         wOldILine = iline;
         for (i=lb; i<=le; i++) {
            hp[iline].nlchars = *hpDiffPos;
            hp[iline].nrchars = 0;
            hpDiffPos++;
            hp[iline].lpl = (BYTE FAR*) hpDiffPos;
            hp[iline].lpr = 0;
            hp[iline].flags = LLS_D;
            hpDiffPos += hp[iline].nlchars;
            //if (LOWORD(hpDiffPos) > MYENDSEG)
            //   hpDiffPos += (~LOWORD(hpDiffPos) + 1);
            hp[iline].nlchars--;    // carriage returns
            iline++;
            lline++;
         }
         hp[wOldILine].flags |= LLS_NDIFF;
         GetDiffValues(&hpDiffPos, &ch, &lb, &le, &rb, &re, 1);
      }
      else if ((ch == 'c') && (lline + 1 == lb)) {
         clmax = max(le - lb, re - rb);
         wOldILine = iline;
         for (i=0; i<=clmax; i++) {
            if (lb + i <= le) {
               hp[iline].nlchars = *hpDiffPos;
               hpDiffPos++;
               hp[iline].lpl = (BYTE FAR*) hpDiffPos;
               hp[iline].flags = LLS_CL;
               hpDiffPos += hp[iline].nlchars;
               //if (LOWORD(hpDiffPos) > MYENDSEG)
               //   hpDiffPos += (~LOWORD(hpDiffPos) + 1);
               hp[iline].nlchars--;    // carriage returns
               lline++;
            }
            else {
               hp[iline].nlchars = 0;
               hp[iline].lpl = 0;
               hp[iline].flags = 0;
            }
            if (rb + i <= re) {
               hp[iline].nrchars = *hpFilePos;
               hpFilePos++;
               hp[iline].lpr = (BYTE FAR*) hpFilePos;
               hp[iline].flags |= LLS_CR;
               hpFilePos += hp[iline].nrchars;
               //if (LOWORD(hpFilePos) > MYENDSEG)
               //   hpFilePos += (~LOWORD(hpFilePos) + 1);
               hp[iline].nrchars--;    // carriage returns
               rline++;
            }
            else {
               hp[iline].nrchars = 0;
               hp[iline].lpr = 0;
               // flags already established as 0.
            }
            iline++;
         }
         hp[wOldILine].flags |= LLS_NDIFF;
         GetDiffValues(&hpDiffPos, &ch, &lb, &le, &rb, &re, 1);
      }
      else {
         hp[iline].nlchars = *hpFilePos;	// ??? RaymondC: *hpFilePos is bogus.
         hp[iline].nrchars = *hpFilePos;
         hpFilePos++;
         hp[iline].lpl = (BYTE FAR*) hpFilePos;
         hp[iline].lpr = (BYTE FAR*) hpFilePos;
         hp[iline].flags = 0;
         hpFilePos += hp[iline].nlchars;
         //if (LOWORD(hpFilePos) > MYENDSEG)
         //   hpFilePos += (~LOWORD(hpFilePos) + 1);
         hp[iline].nlchars--;    // carriage returns
         hp[iline].nrchars--;    // carriage returns
         iline++;
         lline++;
         rline++;
      }
   }

   hp[tlines].lpl = 0;
   hp[tlines].lpr = 0;
   hp[tlines].nlchars = 0;
   hp[tlines].nrchars = 0;
   hp[tlines].flags = 0;
   
   return 1;
}

/**************************************************************************/

void GetDiffValues(BYTE _huge* NEAR* hpDiffPos, BYTE *ch, WORD *lb, WORD *le,
         WORD *rb, WORD *re, WORD wSet)
{
   static int  iCount;
   BYTE _huge* hp;

   if (wSet == 0)       // We are beginning a new file and want to clear the
      iCount = 1;       // number of diff blocks.
   else
      iCount++;         // Increment the count of highlighted blocks.

   if (iCount > all.lpFileData[all.iFile].nDiffBlocks) {  // return bogus values
      *ch = 0;
   }
   else {
      hp = *hpDiffPos;
      *ch = *hp++;
      *lb = *((WORD _huge*)hp); hp += 2;
      *le = *((WORD _huge*)hp); hp += 2;
      *rb = *((WORD _huge*)hp); hp += 2;
      *re = *((WORD _huge*)hp); hp += 2;
      *hpDiffPos = hp;
   }
}

/**************************************************************************/

BYTE BuildSingleLineList(void)
{
   LINELISTSTRUCT _huge*   hp;
   BYTE _huge*    hpFilePos;
   BYTE  ret;
   DWORD dwSize;
   int   i;
   
   /* include space for a blank line at bottom of file.  Good for */
   /* printing the screen. */

   all.lpFileData[all.iFile].nTLines = all.lpFileData[all.iFile].nLines;
   dwSize = sizeof(LINELISTSTRUCT) * (DWORD)(all.lpFileData[all.iFile].nLines + 1);
   ret = GetMemoryChunk(all.iFile, GMC_LINES, dwSize);
   if (!ret) {
      XXX("\n\rLOAD:BuildSingleLineList:GetMemoryChunk failed.");
      return 0;
   }
   hp = (LINELISTSTRUCT _huge*) all.lpFileData[all.iFile].hpLines;
   hpFilePos = all.lpFileData[all.iFile].hpFile;

   for (i=0; i<all.lpFileData[all.iFile].nLines; i++) {
      hp[i].nlchars = *hpFilePos;
      hp[i].nrchars = *hpFilePos;
      hpFilePos++;
      hp[i].lpl = hpFilePos;
      hp[i].lpr = hpFilePos;
      hp[i].flags = 0;
      hpFilePos += hp[i].nlchars;
      //if (LOWORD(hpFilePos) > MYENDSEG)
      //   hpFilePos += (~LOWORD(hpFilePos) + 1);
      hp[i].nlchars--;  // carriage return
      hp[i].nrchars--;  // carriage return
   }
   hp[i].lpl = 0;
   hp[i].lpr = 0;
   hp[i].nlchars = 0;
   hp[i].nrchars = 0;
   hp[i].flags = 0;
   
   return 1;
}

/**************************************************************************/

BYTE MyReadFile(void)
{
   BYTE _huge* hpPos;
   BYTE _huge* hpPosCount;
   DWORD    dwSize;

   HFILE hf;
   WORD  i,j;
   int   ch;
   WORD  fTooLong = 0;

// Get the file length.

   dwSize = FindFileLength(all.lpFileData[all.iFile].lpName);
   if (!dwSize)
      return 0;

// Lines may not cross 64k boundaries so must account for the buffer space.

   dwSize += (256 * ((dwSize >> 16) + 1));

// Allocate the memory.

   if (!GetMemoryChunk(all.iFile, GMC_FILE, dwSize))
      return 0;

   hf = New_fopen(all.lpFileData[all.iFile].lpName);
   if (hf == HFILE_ERROR) {
      FreeMemoryChunk(all.iFile, GMC_FILE);
      return 0;
   }

   hpPosCount = all.lpFileData[all.iFile].hpFile;
   hpPos = hpPosCount + 1;
   i = 0;               // number of lines
   j = 0;               // chars per line

   while ((ch = New_getc(hf)) != EOF) {
      if (ch == '\n') {
         if (j > 255) {
            if (!fTooLong) {
               XXX("\n\rHOSED!!! line greater than 255 chars.");
               fTooLong = 1;
            }
            hpPos -= (j - 255);  // put it back
            j = 255;
         }
         *hpPosCount = (BYTE)j;

         /* check if too close to end of a segment. */
         //if (LOWORD(hpPos) > MYENDSEG)
         //   hpPos += (~LOWORD(hpPos) + 1);

         hpPosCount = hpPos;
         hpPos++;
         i++;
         j = 0;
      }
      else {
         *hpPos++ = ch;
         j++;
      }
   }
   *hpPosCount = (BYTE)min((j + 1), 255); // VERY IMP!!! EOF has no carriage return.
   i++;              // count the EOF line
   all.lpFileData[all.iFile].nLines = i;

   New_fclose(hf);

   YYY("\n\rLOAD:ReadFile -> %u lines", i);
   return 1;
}

/**************************************************************************/

BYTE ReadDiff(void)
{
   BYTE _huge* hpPos;
   DWORD    dwSize;
   HFILE hf;
   int   ch;
   WORD  nDLines;

   dwSize = FindFileLength(lpTemp);
   if (!dwSize)
      return 1;         // only fail if no memory !!!

   dwSize += 2;

   /* We might need extra space because of segments. */
   dwSize += (256 * (dwSize / 0xffff));   // add 256 for each segment

   if (!GetMemoryChunk(all.iFile, GMC_DIFF, dwSize))
      return 0;

   hf = New_fopen(lpTemp);
   if (hf == HFILE_ERROR) {
      FreeMemoryChunk(all.iFile, GMC_DIFF);
      return 1;
   }

   hpPos = all.lpFileData[all.iFile].hpDiff;

   nDLines = 0;         // lines to be added from diff
      
   while ((ch = New_getc(hf)) >= '0' && ch <= '9') {
      nDLines += ReadScompNums(hf, &hpPos, ch);
      all.lpFileData[all.iFile].nDiffBlocks++;             // inc the # of blks
   }

   all.lpFileData[all.iFile].nDLines = nDLines;

   New_fclose(hf);   

   return 1;
}

/**************************************************************************/

void MakeScompDirectory(void)
{
   int   i, j;

   j = -1;
   for (i=0; szScompFile[i]; i++) {
      szScompDir[i] = szScompFile[i];
      if (szScompFile[i] == '\\')      // track the last '\\'
         j = i;
   }
   szScompDir[j+1] = 0;                // null terminated, clip off file
}
               
/**************************************************************************/

#define bEOF      1     // EOF was hit
#define bNoFile   2     // No Files are left

BYTE ReadScomp(HWND hwnd)
{
   BYTE _huge* hpPos;
   DWORD    dwSize;
   HFILE    hf;
   BYTE     curFile;
   BYTE     bits = 0;
   int      ch;
   WORD     nDLines;
   BYTE     ret;

   if (all.iFile != NMAXFILES)
      UnlockMemoryChunk(all.iFile);
   all.iFile = FindMeAFileDataIndex();

   dwSize = FindFileLength(szScompFile);
   if (!dwSize)
      return 0;
   dwSize += 2;
   dwSize += (256 * (dwSize / 0xffff));   // add 256 for each segment

   if (!GetMemoryChunk(all.iFile, GMC_DIFF, dwSize))
      return 0;

   hf = New_fopen(szScompFile);
   if (hf == HFILE_ERROR) {
      FreeMemoryChunk(all.iFile, GMC_DIFF);
      return 0;
   }

   curFile = all.iFile;
   hpPos = all.lpFileData[all.iFile].hpDiff; // good: isolated hpDiff

   while ((ch = New_getc(hf)) != '-' && ch != EOF);
   if (ch == EOF)
      bits |= bEOF;

   while (!bits) {
      all.nFiles++;     // optimistic
      nDLines = 0;      // diff lines to be added to this file
      all.lpFileData[curFile].hpDiff = hpPos;
      all.lpFileData[curFile].bits = FD_SCOMP;

      ReadScompHeader(hf, curFile);
      AddFileToMenu(curFile);

      while ((ch = New_getc(hf)) >= '0' && ch <= '9') {     // stupid while !!!
         nDLines += ReadScompNums(hf, &hpPos, ch);
         all.lpFileData[curFile].nDiffBlocks++;             // inc the # of blks
      }

      all.lpFileData[curFile].nDLines = nDLines;

      while ((ch = New_getc(hf)) != '-' && ch != EOF);
      if (ch == EOF)
         bits |= bEOF;
      curFile = FindMeAFileDataIndex();
      if (all.nFiles == NMAXFILES) {
         MessageBox(hwnd, "The maximum number of files has been reached.  Only part of the Scomp was loaded.",
               0, MB_OK | MB_ICONEXCLAMATION);
         bits |= bNoFile;
      }
   }
   all.lpFileData[all.iFile].bits = FD_SCOMPWDIFF;    // done after so not erased

   New_fclose(hf);

   ret = MyReadFile();
   if (!ret) {
      /* maybe some major cleanup !!! ??? */
      return 0;
   }

   ret = BuildLineList();
   if (!ret) {
      /* maybe some major cleanup !!! ??? */
      FreeMemoryChunk(all.iFile, GMC_FILE);
      return 0;
   }

   return 1;
}

/**************************************************************************/

WORD ReadScompNums(HFILE hf, BYTE _huge* NEAR* hpPos, int ch)
{
   BYTE _huge* hp;
   WORD  nDLines;
   WORD  lb, le, rb, re;
   int   chOp;

   lb = ch - '0';
   while ((ch = New_getc(hf)) >= '0' && ch <= '9')
      lb = lb * 10 + ch - '0';

   if (ch == ',') {
      le = 0;
      while ((ch = New_getc(hf)) >= '0' && ch <= '9')
         le = le * 10 + ch - '0';
   }
   else
      le = lb;

   chOp = ch;  // Store the character operation

   rb = 0;
   while ((ch = New_getc(hf)) >= '0' && ch <= '9')
      rb = rb * 10 + ch - '0';

   if (ch == ',') {
      re = 0;
      while ((ch = New_getc(hf)) >= '0' && ch <= '9')
         re = re * 10 + ch - '0';
   }
   else
      re = rb;

   if (ch == '\r')
      ch = New_getc(hf);
if (ch != '\n')
OutputDebugString("\n\rYour ReadScompNums isn't working very well!!");


   XXX("\n\r");
   YYY("%4i",lb);
   YYY("%4i",le);
   YYY(" %c ", chOp);
   YYY("%4i",rb);
   YYY("%4i",re);

   hp = *hpPos;
   *hp = chOp;    hp++;
   *((WORD _huge*) hp) = lb;  hp += 2;
   *((WORD _huge*) hp) = le;  hp += 2;
   *((WORD _huge*) hp) = rb;  hp += 2;
   *((WORD _huge*) hp) = re;  hp += 2;
   *hpPos = hp;
   
   if (chOp == 'a') {
      nDLines = 0;
      ReadScompDeadLines(hf, re - rb + 1, ch);
   }
   else if (chOp == 'c') {
      if ((le - lb) > (re - rb))
         nDLines = (le -lb) - (re - rb);
      else
         nDLines = 0;
      ReadScompLines(hf, le - lb + 1, hpPos, ch);
      ReadScompCenter(hf);
      ReadScompDeadLines(hf, re - rb + 1, ch);
   }
   else {
      nDLines = le - lb + 1;
      ReadScompLines(hf, le - lb + 1, hpPos, ch);
   }
   return nDLines;
}

/**************************************************************************/

void ReadScompDeadLines(HFILE hf, int nLines, int ch)
{
   int  i;

   for (i=0; i<nLines; i++)
      while ((ch = New_getc(hf)) != '\n');
}

/**************************************************************************/

void ReadScompCenter(HFILE hf)
{
   int   ch;

   while ((ch = New_getc(hf)) != '\n');
}

/**************************************************************************/

void ReadScompLines(HFILE hf, UINT nLines, BYTE _huge* NEAR* hpPos, int ch)
{
   BYTE _huge* hpPosCount;
   WORD  i;
   WORD  j;

   for (i=0; i<nLines; i++) {
      New_getc(hf);        // 2 bogus chars at beginning
      New_getc(hf);
      //if (LOWORD(*hpPos) > MYENDSEG)
      //   *hpPos += (~LOWORD(*hpPos) + 1);
      hpPosCount = *hpPos;
      (*hpPos)++;
      j = 0;
      while ((ch = New_getc(hf)) != '\n') {
         **hpPos = ch;
         (*hpPos)++;
         j++;
      }

/* NOTE: check the C coding following this.  It's questionable. */

      if (j > 255) {
         XXX("\n\rReadScompLines: You're hosed !!! lines > 255");
         *hpPos -= (j - 255); // put it back
         j = 255;
      }
      *hpPosCount = (BYTE)j;
   }
}

/**************************************************************************/

void ReadScompHeader(HFILE hf, BYTE iFileIndex)
{
   BYTE FAR*   lp;
   BYTE        i, j, k;
   int         ch;
   char        szTmp[128];
   
   lp = all.lpFileData[iFileIndex].lpName;
   
   for (i=0; szScompDir[i]; i++)          // get the directory
      lp[i] = szScompDir[i];
      
   all.lpFileData[iFileIndex].lpNameOff = i; // mark the beginning of the name
   
   while ((ch = New_getc(hf)) == '-');    // remove dashes
   while ((ch = New_getc(hf)) == ' ');    // remove extra spacing

   j = 0;
   szTmp[j++] = '\\';                     // makes every word begin with '\\'
   szTmp[j++] = ch;                       // first char
   while ((ch = New_getc(hf)) != ' ') {   // read until space
      if (ch == '\\')                     // but ignore directories
         j = 0;
      szTmp[j++] = ch;
   }

   while ((ch = New_getc(hf)) != '\n');   // finish the line
      
   // Now copy the file after the directory.

   for (k=1; k<j; k++)
      lp[i++] = szTmp[k];
   lp[i] = 0;

   XXX("\n\r");
   XXX(lp);
}

/**************************************************************************/

BYTE ChangeFile(BYTE iFileIndex)          // assumes: all.iFile == all.iFileLast
{
   BYTE  ret;

   if (iFileIndex != all.iFile)
      UnlockMemoryChunk(all.iFile);
   all.iFile = iFileIndex;
   if (all.lpFileData[all.iFile].hFile)      // is it SCOMP that's
      ret = LockMemoryChunk(all.iFile);
   else
      ret = ReLoadCurrentFile();    // not loaded yet?

   return ret;
}

/**************************************************************************/

BYTE ReLoadCurrentFile(void)
{
   BYTE  ret;
   int   bits;

   if (all.iFile == NMAXFILES)   // no current file. fail.
      return 0;

   bits = all.lpFileData[all.iFile].bits;

   if (!all.lpFileData[all.iFile].hpFile) {
      FreeMemoryChunk(all.iFile, GMC_FILE);
      ret = MyReadFile();
      if (!ret)
         return 0;   // cannot load file
   }

   if ((bits & FD_DIFF) && !all.lpFileData[all.iFile].hpDiff) {
      SetDiffFileName();
      FreeMemoryChunk(all.iFile, GMC_DIFF);
      ret = ReadDiff();
      if (!ret) {
         return 0;
      }
   }

   if ((bits & FD_SCOMP) && !all.lpFileData[all.iFile].hpDiff) {
      XXX("\n\rLOAD:ReLoadCurrentFile scomp && !hpDiff");
      return 0;   // hope this situation does not occur
   }

   if ((bits & FD_SCOMPWDIFF) && !all.lpFileData[all.iFile].hpDiff) {
      XXX("\n\rLOAD:ReLoadCurrentFile scompwdiff && !hpDiff");
      return 0;   // ditto
   }
   
   if (bits & FD_SINGLE) {
      FreeMemoryChunk(all.iFile, GMC_LINES);
      ret = BuildSingleLineList();
      if (!ret)
         return 0;
   }
   if (bits & FD_DIFF) {
      FreeMemoryChunk(all.iFile, GMC_LINES);
      ret = BuildLineList();
      if (!ret)
         return 0;
   }
   if (bits & FD_SCOMP) {
      FreeMemoryChunk(all.iFile, GMC_LINES);
      ret = BuildLineList();
      if (!ret)
         return 0;
   }
   if (bits & FD_SCOMPWDIFF) {
      FreeMemoryChunk(all.iFile, GMC_LINES);
      ret = BuildLineList();
      if (!ret)
         return 0;
   }

   return 1;
}

/**************************************************************************/

BYTE FindMeAFileDataIndex(void)
{
   BYTE  i;

   for (i=0; i<NMAXFILES; i++) {
      if (all.lpFileData[i].bits & FD_FREE)
         break;
   }
   return i;
}
   
/**************************************************************************/

void SetDiffFileName(void)
{
   BYTE FAR*   lp;
   int      i;

   lp = all.lpFileData[all.iFile].lpName; // current file name
   for (i=0; lpTemp[i] = lp[i]; i++);  // copy name
   
   if ((lp[i-1] != '.') && (lp[i-2] != '.') && (lp[i-3] != '.') && (lp[i-4] != '.')) {
      lpTemp[i]   = 'd';
      lpTemp[i+1] = 'i';
      lpTemp[i+2] = 'f';
      lpTemp[i+3] = 0;
   }
   else {
      for (; lp[i] != '.'; i--); // move i to the period
      i++;
      lpTemp[i]   = 'd';
      lpTemp[i+1] = 'i';
      lpTemp[i+2] = 'f';
      lpTemp[i+3] = 0;
   }
}

/**************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\junk.c ===
/*
 * JUNK.C
 *
 */


#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "junk.h"
#include "load.h"
#include "rerror.h"
#include "id.h"


/****************************************************************************/

void BLKTabbedOut(HDC hdc, int x, int y, RECT *lprc, LPCSTR lp, int n, int rt);

/****************************************************************************/

void PaintBlank(HDC hdc, PAINTSTRUCT *ps)
{
   RECT lrc,rrc;

// Do the big background rectangle.

   lrc.left = 0;
   lrc.right = all.cxClient;
   lrc.top = 0;
   lrc.bottom = all.cyClient;
   SetBkColor(hdc, all.Col[ALL_BACK]);
   ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lrc, 0, 0, 0);

//Draw those cute lines in the center.

   rrc.left = all.cxBar - 2;
   rrc.right = rrc.left + 1;
   rrc.top = 0;
   rrc.bottom = all.cyClient;
   SetBkColor(hdc, all.Col[ALL_BARHL]);
   ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);

   if (all.Col[ALL_BACK] != all.Col[ALL_BARFC]) {
      rrc.left = all.cxBar - 1;
      rrc.right = all.cxBar + 2;
      SetBkColor(hdc, all.Col[ALL_BARFC]);
      ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);
   }

   rrc.left = all.cxBar + 2;
   rrc.right = rrc.left + 1;
   SetBkColor(hdc, all.Col[ALL_BARSH]);
   ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);
}

/****************************************************************************/

void PaintEverything(HDC hdc, PAINTSTRUCT *ps)
{
   LINELISTSTRUCT _huge*   hp;
   int      i;
   int      nFirstPaintLine, nLastPaintLine;
   RECT     lrc, rrc;
   WORD     cxOurBar;
   WORD     flags;

   if (all.lpFileData[all.iFile].bits & FD_SINGLE)
      cxOurBar = all.cxClient;
   else
      cxOurBar = all.cxBar;

   hp = (LINELISTSTRUCT _huge*) all.lpFileData[all.iFile].hpLines;

// Do the big background rectangle.

   lrc.left = 0;
   lrc.right = all.cxClient;
   lrc.top = 0;
   lrc.bottom = all.cyClient;
   SetBkColor(hdc, all.Col[ALL_BACK]);
   ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lrc, 0, 0, 0);

// Set up rects and do columns side by side.

   lrc.left = all.tm.tmAveCharWidth;
   lrc.right = cxOurBar - 3 - lrc.left;
   rrc.left = cxOurBar + 3 + lrc.left;
   rrc.right = all.cxClient - lrc.left;
   if (rrc.right < rrc.left)
      rrc.right = rrc.left;
   if (lrc.left > lrc.right)
      lrc.left = lrc.right;

   nFirstPaintLine = max(0, ps->rcPaint.top / all.yHeight);
   nLastPaintLine = min(ps->rcPaint.bottom / all.yHeight, all.lpFileData[all.iFile].nTLines);
   for(i=nFirstPaintLine; i <= nLastPaintLine; i++) {
      flags = hp[all.lpFileData[all.iFile].nVScrollPos + i].flags;

      lrc.top = all.yBorder + i * all.yHeight;
      lrc.bottom = lrc.top + all.yHeight;

      if (flags & LLS_D) {
         SetBkColor(hdc, all.Col[ALL_DEL]);
         SetTextColor(hdc, all.Col[ALL_TEXTD]);
         ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lrc, 0, 0, 0);
      }
      else if (flags & LLS_CL) {
         SetBkColor(hdc, all.Col[ALL_CHG]);
         SetTextColor(hdc, all.Col[ALL_TEXTC]);
         ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lrc, 0, 0, 0);
      }
      else {
         SetBkColor(hdc, all.Col[ALL_BACK]);
         SetTextColor(hdc, all.Col[ALL_TEXT]);
      }

   // NOTE: we cannot do opaque lines when no text is specified because
   // we moved that down to the tabbedout routines.

      if (hp[all.lpFileData[all.iFile].nVScrollPos + i].lpl) {
         BLKTabbedOut(hdc, lrc.left, all.yBorder + i * all.yHeight, &lrc,
                      hp[all.lpFileData[all.iFile].nVScrollPos + i].lpl,
                      hp[all.lpFileData[all.iFile].nVScrollPos + i].nlchars, 0);
      }

   // Now do the second rectangle.

      if (~all.lpFileData[all.iFile].bits & FD_SINGLE) {
         rrc.top = all.yBorder + i * all.yHeight;
         rrc.bottom = rrc.top + all.yHeight;

         if (flags & LLS_A) {
            SetBkColor(hdc, all.Col[ALL_ADD]);
            SetTextColor(hdc, all.Col[ALL_TEXTA]);
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);
         }
         else if (flags & LLS_CR) {
            SetBkColor(hdc, all.Col[ALL_CHG]);
            SetTextColor(hdc, all.Col[ALL_TEXTC]);
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);
         }
         else {
            SetBkColor(hdc, all.Col[ALL_BACK]);
            SetTextColor(hdc, all.Col[ALL_TEXT]);
         }

      // NOTE: we cannot do opaque lines when no text is specified because
      // we moved that down to the tabbedout routines.

         if (hp[all.lpFileData[all.iFile].nVScrollPos + i].lpr) {
            BLKTabbedOut(hdc, rrc.left, all.yBorder + i * all.yHeight, &rrc,
                         hp[all.lpFileData[all.iFile].nVScrollPos + i].lpr,
                         hp[all.lpFileData[all.iFile].nVScrollPos + i].nrchars,
                         1);
         }
      }

   }

   if (~all.lpFileData[all.iFile].bits & FD_SINGLE) {

   // Draw those cute lines in the center.

      rrc.left = cxOurBar - 2;
      rrc.right = rrc.left + 1;
      rrc.top = 0;
      rrc.bottom = all.cyClient;
      SetBkColor(hdc, all.Col[ALL_BARHL]);
      ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);

      if (all.Col[ALL_BACK] != all.Col[ALL_BARFC]) {
         rrc.left = cxOurBar - 1;
         rrc.right = cxOurBar + 2;
         SetBkColor(hdc, all.Col[ALL_BARFC]);
         ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);
      }

      rrc.left = cxOurBar + 2;
      rrc.right = rrc.left + 1;
      SetBkColor(hdc, all.Col[ALL_BARSH]);
      ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rrc, 0, 0, 0);
   }

// EXTRA:  This is no longer used!
//
//   lrc.left = all.tm.tmAveCharWidth;
//   lrc.right = cxOurBar - 3 - lrc.left;
//   for (i=0; i<all.nAllCols; i++) {
//      lrc.top = all.yBorder + i * all.yHeight;
//      lrc.bottom = lrc.top + all.yHeight;
//      SetBkColor(hdc, all.AllCols[i]);
//      ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lrc, 0, 0, 0);
//   }

}

/****************************************************************************/

void BLKTabbedOut(HDC hdc, int x, int y, RECT *lprc, LPCSTR lp, int n, int rt)
{
   int   i;
   int   bch;     // Beginning char of current string
   int   cp;      // Current position

   x -= all.lpFileData[all.iFile].xHScroll;
   bch = 0;
   cp = 0;
   for (i=0; i<n; i++) {
      if (lp[i] == '\t') {
         if (bch != i) {
            ExtTextOut(hdc, cp + x, y, ETO_CLIPPED, lprc,
               &lp[bch], i - bch, 0);
            cp += LOWORD(GetTextExtent(hdc, &lp[bch],
               i - bch));
         }
         cp += all.tabDist;
         cp -= (cp % all.tabDist);
         bch = i + 1;
      }
   }
   if (bch != i) {
      ExtTextOut(hdc, cp + x, y, ETO_CLIPPED, lprc, &lp[bch],
         i - bch, 0);
   }
}

/****************************************************************************/

void GetCustomColors(void)
{
   int   i;

   for (i=0; i<11; i++) {
      all.Col[i] = all.WinColors[all.CC[i]];
   }
}

/****************************************************************************/

void GetSystemColors(void)
{
   all.Col[ALL_DEL]     = GetSysColor(COLOR_HIGHLIGHT);
   all.Col[ALL_ADD]     = GetSysColor(COLOR_HIGHLIGHT);
   all.Col[ALL_CHG]     = GetSysColor(COLOR_HIGHLIGHT);

   all.Col[ALL_BARHL]   = GetSysColor(COLOR_BTNHIGHLIGHT);
   all.Col[ALL_BARSH]   = GetSysColor(COLOR_BTNSHADOW);
   all.Col[ALL_BARFC]   = GetSysColor(COLOR_BTNFACE);

   all.Col[ALL_BACK]    = GetSysColor(COLOR_WINDOW);

   all.Col[ALL_TEXT]    = GetSysColor(COLOR_WINDOWTEXT);
   all.Col[ALL_TEXTA]   = GetSysColor(COLOR_HIGHLIGHTTEXT);
   all.Col[ALL_TEXTD]   = GetSysColor(COLOR_HIGHLIGHTTEXT);
   all.Col[ALL_TEXTC]   = GetSysColor(COLOR_HIGHLIGHTTEXT);
}

/****************************************************************************/

void SetWindowsColors(void)
{
   all.WinColors[0]  = 0x0;         // Black
   all.WinColors[15] = 0xffffff;    // White

   all.WinColors[1]  = 0x800000;    // half Red
   all.WinColors[2]  = 0x8000;      // half Green
   all.WinColors[3]  = 0x80;        // half Blue

   all.WinColors[4]  = 0x800080;    // half Magenta
   all.WinColors[5]  = 0x8080;      // half Cyan
   all.WinColors[6]  = 0x808000;    // half Yellow

   all.WinColors[7]  = 0x808080;    // Gray
   all.WinColors[8]  = 0xc0c0c0;    // special Gray

   all.WinColors[9]  = 0xff0000;    // Red
   all.WinColors[10] = 0xff00;      // Green
   all.WinColors[11] = 0xff;        // Blue

   all.WinColors[12] = 0xff00ff;    // Magenta
   all.WinColors[13] = 0xffff;      // Cyan
   all.WinColors[14] = 0xffff00;    // Yellow
}

/****************************************************************************/

void PatchCommandLine(HWND hwnd, LPSTR lp)
{
   int   i, j;
   HCURSOR        hCursor;
   int            ret;

   for (i=0; lp[i] && (lp[i] == ' '); i++);     // strip blanks

   if (!lp[i])          // bail if the string was blanks or null
      return;

   j = 0;
   for (; lp[i] && (lp[i] != ' '); i++)         // copy file name
      szScompFile[j++] = lp[i];
   szScompFile[j] = 0;


   // Now it's hack time !!!

   {
      OFSTRUCT    ofstr;
      ofstr.cBytes = sizeof(ofstr);
      if (OpenFile(szScompFile, &ofstr, OF_EXIST) == HFILE_ERROR)
         szScompFile[0] = 0;
   }

   MakeScompDirectory();

   all.bits |= ALL_SCOMPLD;
   hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
   all.bits &= ~ALL_INVALID;
   all.iFileLast = all.iFile;
   ret = ReadScomp(hwnd);
   if (!ret) {
      all.iFile = all.iFileLast;
      ret = ReLoadCurrentFile();
      if (!ret) {
         XXX("\n\rHOSED!!!");
         all.bits |= ALL_INVALID;
      }
   }
   else {
      UpdateMenu(hwnd);
   }
   SetCursor(hCursor);
   InvalidateRect(hwnd, 0, 0);
   SendMessage(hwnd, WM_SIZE, SIZE_RESTORED,
      (((LPARAM) all.cyClient)<<16) | all.cxClient);
}

/****************************************************************************/

void DealWithFlags(void)
{
   if (all.bits & ALL_HSCROLL)
      CheckMenuItem(hMenu, IDM_HSCROLL, MF_CHECKED);
   if (all.bits & ALL_VSCROLL)
      CheckMenuItem(hMenu, IDM_VSCROLL, MF_CHECKED);

   if (all.bits & ALL_SYSTEM) {
      GetSystemColors();
      CheckMenuItem(hMenu, IDM_SYSTEM, MF_CHECKED);
   }
   if (all.bits & ALL_CUSTOM) {
      GetCustomColors();
      CheckMenuItem(hMenu, IDM_CUSTOM, MF_CHECKED);
   }
   if (all.bits & ALL_PRINTCHANGES)
      CheckMenuItem(hMenu, IDM_PRINTCHANGES, MF_CHECKED);
}

/****************************************************************************/

void AddFileToMenu(BYTE iFileIndex)
{
   if ((all.nFiles != 1) && ((all.nFiles % 20) == 1))
      InsertMenu(hMenu, IDM_VMAX, MF_BYCOMMAND | MF_STRING | MF_ENABLED |
         MF_MENUBARBREAK,
         IDM_V0 + iFileIndex, &(all.lpFileData[iFileIndex].
         lpName[all.lpFileData[iFileIndex].lpNameOff]));
   else {
      InsertMenu(hMenu, IDM_VMAX, MF_BYCOMMAND | MF_STRING | MF_ENABLED,
         IDM_V0 + iFileIndex, &(all.lpFileData[iFileIndex].
         lpName[all.lpFileData[iFileIndex].lpNameOff]));
   }
}

/****************************************************************************/

void UpdateMenu(HWND hwnd)    // and window caption
{
   char  szBuffer[64];

   /* The ORDER matters!!! Otherwise, might lose a checked file. */
   if (all.iFileLast != NMAXFILES)
      CheckMenuItem(hMenu, IDM_V0 + all.iFileLast, MF_UNCHECKED);
   if (all.iFile != NMAXFILES) {
      CheckMenuItem(hMenu, IDM_V0 + all.iFile, MF_CHECKED);
      wsprintf((LPSTR) szBuffer, "GDiff: %s", (LPSTR) &(all.
         lpFileData[all.iFile].lpName[all.lpFileData[
         all.iFile].lpNameOff]));
      SetWindowText(hwnd, (LPSTR) szBuffer);
   }
   else {
      SetWindowText(hwnd, "GDiff");
   }
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\mem.c ===
#include <windows.h>
#include "junk.h"
#include "mem.h"
#include "rerror.h"

HANDLE   hglbAll;    // need to release the GMemInitialize data

/**************************************************************************/

int GMemInitialize(void)
{
   DWORD    dw;
   FILEDATA FAR*  lp;
   int      i;

   dw = NMAXFILES * sizeof(FILEDATA);
   hglbAll = GlobalAlloc(GHND, dw);       // zero inits it.
   if (!hglbAll)
      return 0;
   
   lp = (FILEDATA FAR*) GlobalLock(hglbAll);
   if (!lp) {
      GlobalFree(hglbAll);
      return 0;
   }
   all.lpFileData = lp;

   for (i=0; i<NMAXFILES; i++)
      all.lpFileData[i].bits = FD_FREE;

   return 1;
}

/**************************************************************************/

void FreeEverything(void)
{
   BYTE  i;
   FILEDATA FAR*  lp;

   lp = all.lpFileData;
   for (i=0; i<NMAXFILES; i++) {

      lp[i].bits = FD_FREE;

      if (lp[i].hpFile) {
         GlobalUnlock(lp[i].hFile);
         YYY("\n\rMEM:FreeEverything:GlobalUnlock    %u", lp[i].hFile);
         lp[i].hpFile = 0;
      }
      if (lp[i].hFile) {
         GlobalFree(lp[i].hFile);
         YYY("\n\rMEM:FreeEverything:GlobalFree      %u", lp[i].hFile);
         lp[i].hFile = 0;
      }
      if (lp[i].hpDiff && lp[i].hDiff) {
         GlobalUnlock(lp[i].hDiff);
         YYY("\n\rMEM:FreeEverything:GlobalUnlock    %u", lp[i].hDiff);
      }
      lp[i].hpDiff = 0; // separate for SCOMPWDIFF case

      if (lp[i].hDiff) {
         GlobalFree(lp[i].hDiff);
         YYY("\n\rMEM:FreeEverything:GlobalFree      %u", lp[i].hDiff);
         lp[i].hDiff = 0;
      }
      if (lp[i].hpLines) {
         GlobalUnlock(lp[i].hLines);
         YYY("\n\rMEM:FreeEverything:GlobalUnlock    %u", lp[i].hLines);
         lp[i].hpLines = 0;
      }
      if (lp[i].hLines) {
         GlobalFree(lp[i].hLines);
         YYY("\n\rMEM:FreeEverything:GlobalFree      %u", lp[i].hLines);
         lp[i].hLines = 0;
      }
   }
   if (hglbAll) {
      GlobalUnlock(hglbAll);
      YYY("\n\rMEM:FreeEverything:GlobalUnlock    %u", hglbAll);
      GlobalFree(hglbAll);
      YYY("\n\rMEM:FreeEverything:GlobalFree      %u", hglbAll);
   }
   all.lpFileData = 0;
}

/**************************************************************************/

BYTE GetMemoryChunk(BYTE i, BYTE gmc, DWORD dwSize)
{
   BYTE _huge* hp;
   HANDLE      hglb;

   hglb = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE, dwSize);
   if (!hglb) {
      return 0;
   }
   YYY("\n\rMEM:GetMemoryChunk:GlobalAlloc     %u", hglb);

   hp = (BYTE _huge*) GlobalLock(hglb);
   if (!hp) {
      GlobalFree(hglb);
      return 0;
   }
   YYY("\n\rMEM:GetMemoryChunk:GlobalLock      %u", hglb);

dwSize = GlobalSize(hglb);
ZZZ("\n\rMEM=%lu", dwSize);

   if (gmc == GMC_FILE) {
      all.lpFileData[i].hFile = hglb;
      all.lpFileData[i].hpFile = hp;
   }
   else if (gmc == GMC_DIFF) {
      all.lpFileData[i].hDiff = hglb;
      all.lpFileData[i].hpDiff = hp;
   }
   else {   // GMC_LINES
      all.lpFileData[i].hLines = hglb;
      all.lpFileData[i].hpLines = hp;
   }

   return 1;
}

/**************************************************************************/

void FreeMemoryChunk(BYTE i, BYTE gmc)
{
   HANDLE      hglb;
   BYTE _huge* hp;

   if (gmc == GMC_FILE) {
      hglb = all.lpFileData[i].hFile;
      hp = all.lpFileData[i].hpFile;
      all.lpFileData[i].hFile = 0;
      all.lpFileData[i].hpFile = 0;
   }
   else if (gmc == GMC_DIFF) {
      hglb = all.lpFileData[i].hDiff;
      hp = all.lpFileData[i].hpDiff;
      all.lpFileData[i].hDiff = 0;
      all.lpFileData[i].hpDiff = 0;
   }
   else {
      hglb = all.lpFileData[i].hLines;
      hp = all.lpFileData[i].hpLines;
      all.lpFileData[i].hLines = 0;
      all.lpFileData[i].hpLines = 0;
   }

   if (hp && hglb) {       // both for SCOMPWDIFF
      GlobalUnlock(hglb);
      YYY("\n\rMEM:FreeMemoryChunk:GlobalUnlock   %u", hglb);
   }
   if (hglb) {
      GlobalFree(hglb);
      YYY("\n\rMEM:FreeMemoryChunk:GlobalFree     %u", hglb);
   }
}

/**************************************************************************/

void UnlockMemoryChunk(BYTE i)
{
   HANDLE hglb;

   hglb = all.lpFileData[i].hFile;
   if (all.lpFileData[i].hpFile) {
      GlobalUnlock(hglb);
      YYY("\n\rMEM:UnlockMemoryChunk:GlobalUnlock %u", hglb);
      all.lpFileData[i].hpFile = 0;
   }
   hglb = all.lpFileData[i].hDiff;
   if (all.lpFileData[i].hpDiff && hglb && (all.lpFileData[i].bits & FD_DIFF)) {    // bizarre SCOMPWDIFF
      GlobalUnlock(hglb);
      YYY("\n\rMEM:UnlockMemoryChunk:GlobalUnlock %u", hglb);
      all.lpFileData[i].hpDiff = 0;
   }
   hglb = all.lpFileData[i].hLines;
   if (all.lpFileData[i].hpLines) {
      GlobalUnlock(hglb);
      YYY("\n\rMEM:UnlockMemoryChunk:GlobalUnlock %u", hglb);
      all.lpFileData[i].hpLines = 0;
   }
}

/**************************************************************************/

BYTE LockMemoryChunk(BYTE i)
{
   HANDLE   hglb;
   BYTE  ret = 1;
   
   hglb = all.lpFileData[i].hFile;
   if (hglb && !all.lpFileData[i].hpFile) {  // mem && not locked
      all.lpFileData[i].hpFile = GlobalLock(hglb);
      if (!all.lpFileData[i].hpFile)
         ret = 0;       // failed
      else
         YYY("\n\rMEM:LockMemoryChunk:GlobalLock     %u", hglb);
   }
   hglb = all.lpFileData[i].hDiff;
   if (hglb && !all.lpFileData[i].hpDiff) {  // mem && not locked
      all.lpFileData[i].hpDiff = GlobalLock(hglb);
      if (!all.lpFileData[i].hpDiff)
         ret = 0;       // failed
      else
         YYY("\n\rMEM:LockMemoryChunk:GlobalLock     %u", hglb);
   }
   hglb = all.lpFileData[i].hLines;
   if (hglb && !all.lpFileData[i].hpLines) { // mem && not locked
      all.lpFileData[i].hpLines = GlobalLock(hglb);
      if (!all.lpFileData[i].hpLines)
         ret = 0;       // failed
      else
         YYY("\n\rMEM:LockMemoryChunk:GlobalLock     %u", hglb);
   }

   return ret;
}

/**************************************************************************/

/*********************************************************
   all.lpFileData[i].nLines   = 0;
   all.lpFileData[i].nDLines  = 0;
   all.lpFileData[i].nTLines  = 0;
   all.lpFileData[i].nVScrollPos = 0;
   all.lpFileData[i].nVScrollMax = 0;
   all.lpFileData[i].nHScrollPos = 0;
   all.lpFileData[i].xHScroll = 0;

   all.lpFileData[i].Bits     = FD_FREE;
***********************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\inifile.c ===
/*
 * IniFile.c
 *
 */


#include <windows.h>
#include "inifile.h"
#include "junk.h"
#include "rscanf.h"

/****************************************************************************/

void vReadWindowPos(HWND hwnd, int nCmdShow, char szIniFile[], char szSection[])
{
   char szEntry[]    = "Window";
   char szDefault[]  = "";
   char szBuf[129];
   WINDOWPLACEMENT wndpl;

   wndpl.length = sizeof(WINDOWPLACEMENT);
   if (GetPrivateProfileString(szSection, szEntry, szDefault, szBuf, 128,
       szIniFile))
   {
      int   iRet;

      iRet = rscanf(szBuf, "%d %d %d %d %d %d %d %d %d %d",
                    &wndpl.flags,
                    &wndpl.showCmd,
                    &wndpl.ptMinPosition.x,
                    &wndpl.ptMinPosition.y,
                    &wndpl.ptMaxPosition.x,
                    &wndpl.ptMaxPosition.y,
                    &wndpl.rcNormalPosition.left,
                    &wndpl.rcNormalPosition.top,
                    &wndpl.rcNormalPosition.right,
                    &wndpl.rcNormalPosition.bottom);

      // The launched show state should have priority over the saved state
      // but we don't want to pull a minimized window from the saved state.

      if (nCmdShow != SW_RESTORE)
         wndpl.showCmd = nCmdShow;
      else if (wndpl.showCmd == SW_SHOWMINIMIZED)
      {
         if (wndpl.flags & WPF_RESTORETOMAXIMIZED)
            wndpl.showCmd = SW_SHOWMAXIMIZED;
         else
            wndpl.showCmd = nCmdShow;
      }

      if (iRet == 10) {
         SetWindowPlacement(hwnd, &wndpl);
         return;
      }
   }

   ShowWindow(hwnd, nCmdShow);
}

/****************************************************************************/

void vWriteWindowPos(HWND hwnd, char szIniFile[], char szSection[])
{
   char szEntry[]    = "Window";
   char szBuf[129];
   WINDOWPLACEMENT wndpl;

   wndpl.length = sizeof(WINDOWPLACEMENT);
   GetWindowPlacement(hwnd, &wndpl);
   wsprintf(szBuf, "%u %u %i %i %i %i %i %i %i %i",
      wndpl.flags, wndpl.showCmd,
      wndpl.ptMinPosition.x, wndpl.ptMinPosition.y,
      wndpl.ptMaxPosition.x, wndpl.ptMaxPosition.y,
      wndpl.rcNormalPosition.left, wndpl.rcNormalPosition.top,
      wndpl.rcNormalPosition.right, wndpl.rcNormalPosition.bottom);
   WritePrivateProfileString(szSection, szEntry, szBuf, szIniFile);
}

/****************************************************************************/

void vReadDefaultFont(LOGFONT *lf, char szIniFile[], char szSection[])
{
   char szEntry1[]   = "FontName";
   char szEntry2[]   = "FontAttr";
   char szDefault[]  = "Arial";
   char szBuf[129];

   GetPrivateProfileString(szSection, szEntry1, szDefault, (LPSTR)
      lf->lfFaceName, LF_FACESIZE, szIniFile);

   if (GetPrivateProfileString(szSection, szEntry2, szDefault, szBuf, 128,
         szIniFile))
   {
      int   iRet;

      iRet = rscanf(szBuf, "%d %d %ld %ld", &lf->lfHeight, &lf->lfWeight,
                    &lf->lfItalic, &lf->lfOutPrecision);

      if (iRet == 4) {
         lf->lfWidth       = 0;
         lf->lfEscapement  = 0;
         lf->lfOrientation = 0;
         return;
      }
   }

// Fill in the attributes for Fixedsys.

   lf->lfHeight = -12;
   lf->lfWidth  = 0;
   lf->lfEscapement   = 0;
   lf->lfOrientation  = 0;
   lf->lfWeight = FW_NORMAL;
   lf->lfItalic = 0;
   lf->lfUnderline = 0;
   lf->lfStrikeOut = 0;
   lf->lfCharSet   = ANSI_CHARSET;
   lf->lfOutPrecision = OUT_STROKE_PRECIS;
   lf->lfClipPrecision   = CLIP_STROKE_PRECIS;
   lf->lfQuality   = DRAFT_QUALITY;
   lf->lfPitchAndFamily  = VARIABLE_PITCH | FF_SWISS;
}

/****************************************************************************/

void vWriteDefaultFont(LOGFONT *lf, char szIniFile[], char szSection[])
{
   char szEntry1[]   = "FontName";
   char szEntry2[]   = "FontAttr";
   char szBuf[129];

   wsprintf(szBuf, "%s", (LPSTR)lf->lfFaceName);
   WritePrivateProfileString(szSection, szEntry1, szBuf, szIniFile);

   wsprintf(szBuf, "%i %i %lu %lu", lf->lfHeight,
      lf->lfWeight, *((DWORD*)&lf->lfItalic),*((DWORD*)&lf->lfOutPrecision));
   WritePrivateProfileString(szSection, szEntry2, szBuf, szIniFile);
}

/****************************************************************************/

void vReadIniSwitches(char szIniFile[], char szSection[])
{
   char szDefault[]  = "";
   char szEntry[25];
   char szBuf[256];
   int  iRet;

   wsprintf(szEntry, "Bits");
   all.bits = GetPrivateProfileInt(szSection, szEntry, ALL_SYSTEM |
         ALL_HSCROLL | ALL_VSCROLL, szIniFile);

   wsprintf(szEntry, "Tab");
   all.tabChars = GetPrivateProfileInt(szSection, szEntry, 8, szIniFile);
   if (all.tabChars < 1 || all.tabChars > 8)
      all.tabChars = 8;

   // Hope WM_CREATE does some bit checking !!!

   wsprintf(szEntry, "ScompFile");
   iRet = GetPrivateProfileString(szSection, szEntry, szDefault, szScompFile,
          256, szIniFile);

   // HACK !!!
   all.Function[0] = 4;
   all.Function[1] = 3;
   all.Function[10] = 2;
   all.Function[11] = 1;

   wsprintf(szEntry, "Color");
   if (GetPrivateProfileString(szSection, szEntry, szDefault, szBuf, 256,
                               szIniFile))
   {
      iRet = rscanf(szBuf, "%d %d %d %d %d %d %d %d %d %d %d", &all.CC[0],
                    &all.CC[1], &all.CC[2], &all.CC[3], &all.CC[4], &all.CC[5],
                    &all.CC[6], &all.CC[7], &all.CC[8], &all.CC[9], &all.CC[10]);

      if (iRet == 11)
         return;
   }

// Use the default colors.

   all.CC[0] = 7;
   all.CC[1] = 8;
   all.CC[2] = 7;
   all.CC[3] = 0;
   all.CC[4] = 0;
   all.CC[5] = 0;
   all.CC[6] = 0;
   all.CC[7] = 15;
   all.CC[8] = 4;
   all.CC[9] = 5;
   all.CC[10] = 6;
}

/****************************************************************************/

void vWriteIniSwitches(char szIniFile[], char szSection[])
{
   char  szEntry[25];
   char  szBuf[129];
   int   ret;

   wsprintf(szEntry, "Bits");
   wsprintf(szBuf, "%u", all.bits & ~(ALL_INVALID | ALL_SCOMPLD));
   ret = WritePrivateProfileString(szSection, szEntry, szBuf, szIniFile);

   wsprintf(szEntry, "Tab");
   wsprintf(szBuf, "%u", all.tabChars);
   ret = WritePrivateProfileString(szSection, szEntry, szBuf, szIniFile);

   wsprintf(szEntry, "Color");
   wsprintf(szBuf, "%i %i %i %i %i %i %i %i %i %i %i",
      all.CC[0], all.CC[1], all.CC[2], all.CC[3],
      all.CC[4], all.CC[5], all.CC[6], all.CC[7],
      all.CC[8], all.CC[9], all.CC[10]);
   WritePrivateProfileString(szSection, szEntry, szBuf, szIniFile);

   wsprintf(szEntry, "ScompFile");
   WritePrivateProfileString(szSection, szEntry, szScompFile, szIniFile);
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\print.h ===
#pragma message("print.h")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\prtdoc.h ===
/*
 * PRTDOC.H
 *
 */


BOOL ParseDeviceLine(void);
HDC  GetPrtDC(DEVMODE FAR* lpDevMode);
int  ExtDeviceMode(HWND, LPDEVMODE, LPDEVMODE, LPSTR, WORD);
void PrintDoc(HWND, int iFile);
void DrawTheSillyStuff(HDC hdc, int iFile);
void FailPrintMB(HWND hwnd);

extern LOGFONT glfPrinter;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\rerror.c ===
/*
 * RERROR.C
 *
 */

#include <windows.h>
#include "rerror.h"

#ifdef TESTING

void XXX(LPSTR lp)
{
   OutputDebugString((LPSTR) lp);
}

void YYY(LPSTR lp, WORD w)
{
   static char szBuffer[256];

   wsprintf((LPSTR) szBuffer, (LPSTR) lp, w);
   OutputDebugString((LPCSTR) szBuffer);
}

void ZZZ(LPSTR lp, DWORD dw)
{
   static char szBuffer[256];

   wsprintf((LPSTR) szBuffer, (LPSTR) lp, dw);
   OutputDebugString((LPCSTR) szBuffer);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\rerror.h ===
/*
 * RERROR.H
 *
 */

 
#define  XXX   //
#define  YYY   //
#define  ZZZ   //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\prtdoc.c ===
#include <windows.h>
#include "prtdoc.h"
#include "junk.h"


char gszPrinter[256], *gpszModel, *gpszDriver, *gpszPort;

LOGFONT  glfPrinter;

BOOL bChangesOnThisPage(LINELISTSTRUCT _huge* hpll, int iCurrentLine, int iEndLine);

/***************************************************************************/

BOOL ParseDeviceLine(void)
{
    if (!GetProfileString("windows", "device", "", gszPrinter,
                          sizeof(gszPrinter)))
        return FALSE;

    gpszModel = gszPrinter;

    for (gpszDriver = gpszModel; *gpszDriver && *gpszDriver != ','; ++gpszDriver)
        ;

    if (!*gpszDriver)
        return FALSE;
    else
        *gpszDriver++ = '\0';

    for (gpszPort = gpszDriver; *gpszPort && *gpszPort != ','; ++gpszPort)
        ;

    if (!*gpszPort)
        return FALSE;
    else
        *gpszPort++ = '\0';

    return TRUE;
}

/***************************************************************************/

HDC GetPrtDC(DEVMODE FAR* lpDevMode)
{
    return CreateDC(gpszDriver, gpszModel, gpszPort, lpDevMode);
}

/***************************************************************************/

int ExtDeviceMode(HWND hwnd, LPDEVMODE lpDevModeOutput,
                  LPDEVMODE lpDevModeInput, LPSTR lpProfile, WORD wMode)
{
#if 0
   HANDLE hModule;
   LPFNDEVMODE lpfnExtDeviceMode;

   hModule = GetModuleHandle(gpszDriver);
   lpfnExtDeviceMode = (LPFNDEVMODE)GetProcAddress(hModule, PROC_EXTDEVICEMODE);
   if (lpfnExtDeviceMode)
      return (*lpfnExtDeviceMode)(hwnd, hModule, lpDevModeOutput, gpszModel,
                                 gpszPort, lpDevModeInput, lpProfile, wMode);
   else
#endif
      return -1;
}

/***************************************************************************/

void PrintDoc(HWND hwnd, int iFile)
{
   HDC      hPrtDC;
   DOCINFO  DocInfo;
   int      iDevModeSize;
   PDEVMODE pDevModeIn;

   /* parse the device line */
   if (!ParseDeviceLine()) {
      FailPrintMB(hwnd);
      goto cleanup1;
   }

   hPrtDC = GetPrtDC(0);

   /* get size of DEVMODE structure */
   iDevModeSize = ExtDeviceMode(hwnd, NULL, NULL, NULL, 0);
   if (iDevModeSize < 0) {
      FailPrintMB(hwnd);
      goto cleanup1;
   }

   /* allocate a local copy and fill it in with current defaults */
   pDevModeIn = (PDEVMODE)LocalAlloc(LPTR, iDevModeSize);
   if (!pDevModeIn) {
      FailPrintMB(hwnd);
      goto cleanup1;
   }
   if (ExtDeviceMode(hwnd, pDevModeIn, NULL, NULL, DM_OUT_BUFFER) < 0) {
      FailPrintMB(hwnd);
      goto cleanup1;
   }

   /* set landscape mode */
   pDevModeIn->dmFields |= DM_ORIENTATION;
   pDevModeIn->dmOrientation = DMORIENT_LANDSCAPE;

   /* fill in the DocInfo structure */
   DocInfo.cbSize = sizeof(DOCINFO);
   DocInfo.lpszDocName = "Test";
   DocInfo.lpszOutput = 0;

   StartDoc(hPrtDC, &DocInfo);

   ResetDC(hPrtDC, pDevModeIn);

   DrawTheSillyStuff(hPrtDC, iFile);   // All the work goes into this function.

   EndDoc(hPrtDC);

   DeleteDC(hPrtDC);

cleanup1:
   ;
}

/***************************************************************************/

void FailPrintMB(HWND hwnd)
{
   MessageBox(hwnd, "Printing Error.", "Error", MB_OK | MB_ICONSTOP);
}

/***************************************************************************/

void DrawTheSillyStuff(HDC hDC, int iFile)
{
   int         xMax, yMax;
   int         yHeight;
   int         xBar;
   int         iBorder = 5;      // randomly set 5 pixels as the border
   int         iLinesPP;
   int         iCurrentLine;
   int         iEndLine;
   RECT        lrc, rrc;
   TEXTMETRIC  tm;
   HFONT       hOldFont, hNewFont;
   int         i;
   char        szHeader[255];
   int         iPage;
   int         iPosTop;
   DWORD       dwgte;
   FILEDATA FAR*           lpfd;
   LINELISTSTRUCT _huge*   hpll;
   HBRUSH      hbrOld;
   int         lfHeightOld;

//   int   iHomeMadeBrush[] = { 0x7F, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF };
//   HBITMAP  hbmp  = CreateBitmap(8, 8, 1, 1, iHomeMadeBrush);
//   HBRUSH   hbr   = CreatePatternBrush(hbmp);

   HBRUSH   hbr   = CreateSolidBrush(RGB(244,244,244));

   xMax = GetDeviceCaps(hDC, HORZRES);       // get hDC extents
   yMax = GetDeviceCaps(hDC, VERTRES);

// The printer logfont was created for the screen.  We need to scale it
// to the device.  We're not scaling the width so we had better make sure
// it is zero!!!

   lfHeightOld = glfPrinter.lfHeight;
   glfPrinter.lfHeight = MulDiv(lfHeightOld, GetDeviceCaps(hDC, LOGPIXELSY),
                                all.yDPI);
   hNewFont = CreateFontIndirect(&glfPrinter);
   glfPrinter.lfHeight = lfHeightOld;
   hOldFont = SelectObject(hDC, hNewFont);   // get the text metrics
   GetTextMetrics(hDC, &tm);
   SelectObject(hDC, hOldFont);

   yHeight = tm.tmHeight + tm.tmExternalLeading;   // get font height

   iLinesPP = (yMax - yHeight - iBorder - iBorder) / yHeight;  // lines per page

   xBar = xMax / 2;                          // center bar

   lrc.left    = iBorder;                    // setup the left rect
   lrc.right   = xBar - iBorder;
   lrc.top     = yHeight + iBorder;
   lrc.bottom  = yMax - iBorder;

   rrc.left    = xBar + iBorder;             // setup the right rect
   rrc.right   = xMax - iBorder;
   rrc.top     = lrc.top;
   rrc.bottom  = lrc.bottom;

   lpfd = &(all.lpFileData[iFile]);
   hpll = (LINELISTSTRUCT _huge*) lpfd->hpLines;

   iCurrentLine = 0;
   iPage = 1;

   SetBkMode(hDC, TRANSPARENT);
   SetBkColor(hDC, RGB(244,244,244));

   while (iCurrentLine < lpfd->nTLines) {
      iEndLine = iCurrentLine + iLinesPP;
      if (iEndLine > lpfd->nTLines)
         iEndLine = lpfd->nTLines;

   // See if the use only wants to print pages with changes on them.
   // If so, decide whether to print this page or not.

      if (all.bits & ALL_PRINTCHANGES) {
         if (!bChangesOnThisPage(hpll, iCurrentLine, iEndLine)) {
            iPage++;
            iCurrentLine = iEndLine;
            goto DontPrintThisPage;
         }
      }

   // Print the page.

      StartPage(hDC);

      SelectObject(hDC, hNewFont);
      UnrealizeObject(hbr);
      hbrOld = SelectObject(hDC, hbr);

      wsprintf(szHeader, "%s    Page %i", lpfd->lpName, iPage);
      for (i=0; szHeader[i]; i++);
      dwgte = GetTextExtent(hDC, szHeader, i);
      ExtTextOut(hDC, (xMax/2 - LOWORD(dwgte)/2), 0, 0, 0, szHeader, i, 0);

      iPosTop = yHeight + iBorder;

      for (i=iCurrentLine; i<iEndLine; i++) {
         if (hpll[i].flags & (LLS_D | LLS_CL)) {
            PatBlt(hDC, lrc.left, iPosTop, (lrc.right - lrc.left), yHeight,
                  PATCOPY);
         }

         {           // TABBED LEFT TEXT
            int   ii;
            int   bch = 0;       // Beginning char of current string
            int   cp = 0;        // Current char position

            for (ii=0; ii<(int)(hpll[i].nlchars); ii++) {
               if (hpll[i].lpl[ii] == '\t') {
                  if (bch != ii) {
                     ExtTextOut(hDC, cp+lrc.left, iPosTop, ETO_CLIPPED, &lrc,
                        &(hpll[i].lpl[bch]), ii-bch, 0);
                     cp += LOWORD(GetTextExtent(hDC, &(hpll[i].lpl[bch]),
                        ii-bch));
                  }
                  cp += all.tabDist;
                  cp -= (cp % all.tabDist);
                  bch = ii + 1;
               }
            }
            if (bch != ii) {
               ExtTextOut(hDC, cp+lrc.left, iPosTop, ETO_CLIPPED, &lrc,
                  &(hpll[i].lpl[bch]), ii-bch, 0);
            }
         }

         if ((~lpfd->bits & FD_SINGLE) && (hpll[i].flags & (LLS_A | LLS_CR))) {
            PatBlt(hDC, rrc.left, iPosTop, (rrc.right - rrc.left), yHeight,
                  PATCOPY);
         }

         if (~lpfd->bits & FD_SINGLE) {      // TABBED RIGHT TEXT
            int   ii;
            int   bch = 0;       // Beginning char of current string
            int   cp = 0;        // Current char position

            for (ii=0; ii<(int)(hpll[i].nrchars); ii++) {
               if (hpll[i].lpr[ii] == '\t') {
                  if (bch != ii) {
                     ExtTextOut(hDC, cp+rrc.left, iPosTop, ETO_CLIPPED, &rrc,
                        &(hpll[i].lpr[bch]), ii-bch, 0);
                     cp += LOWORD(GetTextExtent(hDC, &(hpll[i].lpr[bch]),
                        ii-bch));
                  }
                  cp += all.tabDist;
                  cp -= (cp % all.tabDist);
                  bch = ii + 1;
               }
            }
            if (bch != ii) {
               ExtTextOut(hDC, cp+rrc.left, iPosTop, ETO_CLIPPED, &rrc,
                  &(hpll[i].lpr[bch]), ii-bch, 0);
            }
         }

         iPosTop += yHeight;
      }

      iCurrentLine = i;
      iPage++;

      MoveTo(hDC, 0, yHeight + iBorder);
      LineTo(hDC, xMax, yHeight + iBorder);
      MoveTo(hDC, xBar, yHeight + iBorder);
      LineTo(hDC, xBar, yMax-1);
      MoveTo(hDC, 0, yHeight + iBorder);
      LineTo(hDC, 0, yMax-1);
      LineTo(hDC, xMax-1, yMax-1);
      LineTo(hDC, xMax-1, yHeight + iBorder);

      EndPage(hDC);

DontPrintThisPage:
      ;

   }  // while: end of all the pages

   SelectObject(hDC, hOldFont);
   DeleteObject(hNewFont);
   SelectObject(hDC, hbrOld);
   DeleteObject(hbr);
//   DeleteObject(hbmp);
}

/***************************************************************************/

BOOL bChangesOnThisPage(LINELISTSTRUCT _huge* hpll, int iCurrentLine, int iEndLine)
{
   int   i;

   for (i=iCurrentLine; i<iEndLine; i++)
      if (hpll[i].flags)
         return 1;

   return 0;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\r.h ===
/*
 * RERROR.H
 *
 */

 
void XXX(LPSTR pch);
void YYY(LPSTR lp, WORD w);
void ZZZ(LPSTR lp, DWORD dw);

#define TESTING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\rr.h ===
/*
 * RERROR.H
 *
 */

 
#define  XXX   //
#define  YYY   //
#define  ZZZ   //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\spuser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spuser.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\spuser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	spuser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\spuser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <atlbase.h>
#include <sapi.h>
#include <sphelper.h>
#include <stdlib.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\rscanf.c ===
/****************************Module*Header***********************************\
* Module Name: RSCANF.C
*
* Module Descripton: Small substitute for library function sscanf().
*
* Warnings:
*
* Created: 15 July 1993
*
* Author: Raymond E. Endres   [rayen@microsoft.com]
\****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>           // !!! This shouldn't pull in any run-time libs.
#include "rscanf.h"

char achWhiteSpace[128];      // !!! Must be initialized.

void vInitWhiteSpace(void);
BOOL bScanfD(const char **, int *);
BOOL bScanfLD(const char **, long *);
BOOL bScanfS(const char **, char *);
BOOL bScanfU(const char **, UINT *);

/****************************************************************************\
* rscanf
*
*  rscanf reads from szBuffer under control of szFormat, and assigns converted
*  values through subsequent arguments, each of which must be a pointer.
*  It returns when format is exhausted.  rscanf returns EOF if end of szBuffer
*  or an error occurs before any conversion; otherwise it returns the
*  number of input items converted and assigned.
*
*  Conversion specifications supported:
*     %d    decimal integer
*     %ld   long decimal integer
*		%u		unsigned integer  (!!! This only does decimals.)
*     %s    string
\****************************************************************************/

int rscanf(const char *szBuffer, const char *szFormat, ...)
{
   va_list  ap;            // Argument pointer: will point to each unnamed arg.
   int      cItems = 0;    // Count of items converted.

   vInitWhiteSpace();      // !!! We might want to call this elsewhere.

   va_start(ap, szFormat); // Init argument pointer.

// Walk szFormat.

   while (TRUE) {
      while (achWhiteSpace[*szFormat])       // Find non-white space character.
         szFormat++;

      if (*szFormat == 0)                    // Success.  End of szFormat.
         break;

      if (*szFormat != '%') {
         cItems = EOF;
         break;
      }
      szFormat++;

      if (*szFormat == 'd') {                // decimal integer
         if (bScanfD(&szBuffer, (int *)va_arg(ap, int *))) {
            cItems++;
         }
         else {
            cItems = EOF;
            break;
         }
         szFormat++;
      }
      else if (*szFormat == 'l' && szFormat[1] == 'd') {    // decimal long
         if (bScanfLD(&szBuffer, (long *)va_arg(ap, long *))) {
            cItems++;
         }
         else {
            cItems = EOF;
            break;
         }
         szFormat += 2;
      }
      else if (*szFormat == 'u') {           // unsigned integer (!!! decimal)
         if (bScanfU(&szBuffer, (int *)va_arg(ap, int *))) {
            cItems++;
         }
         else {
            cItems = EOF;
            break;
         }
         szFormat++;
      }
      else if (*szFormat == 's') {           // string
         if (bScanfS(&szBuffer, (char *)va_arg(ap, char *))) {
            cItems++;
         }
         else {
            cItems = EOF;
            break;
         }
         szFormat++;
      }
      else {
         cItems = EOF;
         break;
      }
   }

   va_end(ap);             // Clean up argument pointer.

   return cItems;
}

/****************************************************************************/

void vInitWhiteSpace(void)
{
   int   i;

   for (i=0; i<128; i++)
      achWhiteSpace[i] = 0;

   achWhiteSpace[' ']  = 1;      // blanks
   achWhiteSpace['\t'] = 1;      // tabs
   achWhiteSpace['\n'] = 1;      // newlines
   achWhiteSpace['\r'] = 1;      // carriage returns
   achWhiteSpace['\v'] = 1;      // vertical tabs
   achWhiteSpace['\f'] = 1;      // form feeds
}

/****************************************************************************/

BOOL bScanfS(const char **pszBuffer, char *psz)
{
   int   i = 0;      // Index of the destination buffer.

// Advance *pszBuffer to the first non-white space character.  This will
// also terminate when zero is found.

   while (achWhiteSpace[**pszBuffer])
      (*pszBuffer)++;

// Return failure if zero was found.

   if (**pszBuffer == 0)
      return FALSE;

// Copy the string until we hit a white space character or a zero.

   while (**pszBuffer && !achWhiteSpace[**pszBuffer]) {
      psz[i++] = **pszBuffer;
      (*pszBuffer)++;
   }

// Terminate the destination string with a zero.

   psz[i] = 0;

// NOTE: If **pszBuffer equals zero right now, do we return TRUE or FALSE?
// I'm doing what makes the most sense to me. !!!

   return TRUE;
}

/****************************************************************************/

BOOL bScanfD(const char **pszBuffer, int *pi)
{
   int   iSign = 1;        // Set to 1 or -1.
   int   iValue = 0;

// Advance *pszBuffer to the first non-white space character.  This will
// also terminate when zero is found.

   while (achWhiteSpace[**pszBuffer])
      (*pszBuffer)++;

// Return failure if zero was found.

   if (**pszBuffer == 0)
      return FALSE;

// Is it negative?

   if (**pszBuffer == '-') {
      iSign = -1;
      (*pszBuffer)++;
   }

// Are we at the beginning of a valid decimal integer?

   if (**pszBuffer < '0' || **pszBuffer > '9')
      return FALSE;

// Compute the value of the decimal integer.  This will terminate at the
// first non-decimal character, including zero.
// !!! This could be a little faster if we used another table.

   while (**pszBuffer >= '0' && **pszBuffer <= '9') {
      iValue *= 10;
      iValue += **pszBuffer - '0';
      (*pszBuffer)++;
   }

// Return the decimal integer.

   *pi = iValue * iSign;
   return TRUE;
}

/****************************************************************************/

BOOL bScanfLD(const char **pszBuffer, long *pl)
{
   long  iSign = 1;        // Set to 1 or -1.
   long  iValue = 0;

// Advance *pszBuffer to the first non-white space character.  This will
// also terminate when zero is found.

   while (achWhiteSpace[**pszBuffer])
      (*pszBuffer)++;

// Return failure if zero was found.

   if (**pszBuffer == 0)
      return FALSE;

// Is it negative?

   if (**pszBuffer == '-') {
      iSign = -1;
      (*pszBuffer)++;
   }

// Are we at the beginning of a valid decimal long?

   if (**pszBuffer < '0' || **pszBuffer > '9')
      return FALSE;

// Compute the value of the decimal long.  This will terminate at the
// first non-decimal character, including zero.
// !!! This could be a little faster if we used another table.

   while (**pszBuffer >= '0' && **pszBuffer <= '9') {
      iValue *= 10;
      iValue += **pszBuffer - '0';
      (*pszBuffer)++;
   }

// Return the decimal long.

   *pl = iValue * iSign;
   return TRUE;
}

/****************************************************************************/

BOOL bScanfU(const char **pszBuffer, UINT *pu)
{
   UINT	uValue = 0;

// Advance *pszBuffer to the first non-white space character.  This will
// also terminate when zero is found.

   while (achWhiteSpace[**pszBuffer])
      (*pszBuffer)++;

// Return failure if zero was found.

   if (**pszBuffer == 0)
      return FALSE;

// Are we at the beginning of a valid decimal integer?

   if (**pszBuffer < '0' || **pszBuffer > '9')
      return FALSE;

// Compute the value of the decimal integer.  This will terminate at the
// first non-decimal character, including zero.
// !!! This could be a little faster if we used another table.

   while (**pszBuffer >= '0' && **pszBuffer <= '9') {
      uValue *= 10;
      uValue += **pszBuffer - '0';
      (*pszBuffer)++;
   }

// Return the decimal integer.

   *pu = uValue;
   return TRUE;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\size.h ===
/*
 * SIZE.H
 *
 */

 
DWORD FindFileLength(LPCSTR lp);

int New_getc(HFILE hf);
HFILE New_fopen(LPCSTR lpszFileName);
void New_fclose(HFILE hf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\rscanf.h ===
/****************************Module*Header***********************************\
* Module Name: RSCANF.C
*
* Module Descripton: Small substitute for library function sscanf().
*
* Warnings:
*
* Created: 15 July 1993
*
* Author: Raymond E. Endres   [rayen@microsoft.com]
\****************************************************************************/

int rscanf(const char *, const char *, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\spuser\spuser.h ===
/****************************************************************************
*	spuser.h
*		<put description here>
*
*	Owner: cthrash
*	Copyright  1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

enum SearchOption_t
{
    eSearchByName,
    eSearchByLcid,
    eHelp,
    eNone
};

struct SearchArgument_t
{
    CSpDynamicString dstrName;
    LCID             lcid;
};

struct NameValuePair
{
    char *  pszName;
    LCID    lcid;
};

//--- Forward and External Declarations -------------------------------------

SearchOption_t  ParseCmdLine(LPSTR, SearchArgument_t *);
HRESULT         ShowDefaultUser();
HRESULT         SwitchDefaultUser(SearchOption_t, SearchArgument_t *);
void            ShowUserName(WCHAR * pszName);
HRESULT         Report(char * lpMsg, HRESULT hr);

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\source\gdiff\size.c ===
#include <windows.h>
#include <stdio.h>
#include "size.h"
#include "rerror.h"

#define  NLOCALBYTES 2048

PBYTE gpb;
UINT  gcount, gpos, gread;

/*************************************************************************/

DWORD FindFileLength(LPCSTR lp)
{
   static char    szBuffer[256];
   DWORD    dw;
   long     len;
   HFILE    hf;
   OFSTRUCT of;

   hf = OpenFile(lp, &of, OF_READ);
   if (hf == HFILE_ERROR) {
      XXX("\n\rSIZE:FindFileLength:open failed.");
      return 0;
   }
   len = _llseek(hf, 0L, 2);
   dw = len;
   if (len == HFILE_ERROR) {
      XXX("\n\rSIZE:FindFileLength:lseek failed.");
      return 0;
   }
   _lclose(hf);

   wsprintf((LPSTR) szBuffer, "%lu", dw);
   XXX("\n\r");
   XXX(lp);
   XXX("  ");
   XXX((LPCSTR) szBuffer);

   return dw;
}

/*************************************************************************/

int New_getc(HFILE hf)
{
   int   ret;

   if (gread) {
      gread = 0;
      gpos = 0;
      gcount = _lread(hf, gpb, NLOCALBYTES);
      if (gcount == HFILE_ERROR)
         return EOF;
      if (!gcount)
         return EOF;
   }
   if (gpos < gcount) {
      ret = gpb[gpos];
      gpos++;
   }
   else           // only get here when file is done
      ret = EOF;

   if (gpos == NLOCALBYTES)   // load next chunk
      gread = 1;
   
   return ret;
}

/*************************************************************************/

HFILE New_fopen(LPCSTR lpszFileName)
{
   HFILE hf;
   OFSTRUCT of;

   hf = OpenFile(lpszFileName, &of, OF_READ);
if (hf == HFILE_ERROR)
XXX("\n\rSIZE:New_fopen:OpenFile failed.");

   if (!gpb) {
      gpb = (PBYTE) LocalAlloc(LMEM_FIXED, NLOCALBYTES);
      gread = 1;
   }

   return hf;
}

/*************************************************************************/

void New_fclose(HFILE hf)
{
   HFILE ret;

   ret = _lclose(hf);
if (ret == HFILE_ERROR)
XXX("\n\rSIZE:New_fclose:_lclose failed.");

   if (gpb) {
      LocalFree((HLOCAL) gpb);
      gpb = 0;
   }
}

/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\spuser\spuser.cpp ===
/****************************************************************************
*
*	spuser.cpp
*
*       Dev applet to change the default speech user
*
*	Owner: cthrash
*	Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

#include "stdafx.h"
#include "spuser.h"

/**********************************************************************
* main *
*------*
*
*	Description:
*
*       Main entry point.
*
* 	Return:
*
*       S_OK, E_INVALIDARG
*
************************************************************* cthrash */

BOOL g_fVerbose = FALSE;

int APIENTRY 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    SearchArgument_t SearchArgument;
    SearchOption_t SearchOption = ParseCmdLine(lpCmdLine, &SearchArgument);
    HRESULT hr;

    if (SearchOption != eHelp)
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            if (SearchOption == eNone)
            {
                hr = ShowDefaultUser();
            }
            else
            {
                hr = SwitchDefaultUser(SearchOption, &SearchArgument);
            }
                
            CoUninitialize();
        }
    }
    else
    {
        hr = Report("Usage:\tspuser [-v] {user-name}\n"
                          "\tspuser [-v] -{local-id}\n"
                          "\tspuser -?\n",
                     E_INVALIDARG);
    }

	return (int)hr;
}

/**********************************************************************
* ParseCmdLine *
*--------------*
*
*	Description:
*
*       Parse the command line.  Argument can be a name, or a locale
*       specification preceeded by a dash.  Locale specifications can
*       be one of the stock names, or a a numeric LCID.
*
* 	Return:
*
*       One of the SearchOption_t enumerated types
*
************************************************************* cthrash */

const struct NameValuePair aNameValuePair[] = 
{
    { "ameng",      1033 },
    { "enu",        1033 },
    { "japanese",   1041 },
    { "jpn",        1041 },
    { "chs",        2051 }
};

SearchOption_t
ParseCmdLine(
    LPSTR pszCmdLine,
    SearchArgument_t *pSearchArgument)
{
    SearchOption_t SearchOption;

    if (*pszCmdLine)
    {
        // Check first for the 'verbose' option.
        
        if (0 == strnicmp(pszCmdLine, "-v", 2))
        {
            g_fVerbose = TRUE;
            for (pszCmdLine += 2;isspace((unsigned)(unsigned char)*pszCmdLine); pszCmdLine++);
        }

        // A dash means the user specified a locale.

        if (*pszCmdLine == '-')
        {
            if (pszCmdLine[1] == '?')
            {
                SearchOption = eHelp;
            }
            else
            {
                LCID lcid = 0;

                pszCmdLine++;

                // first check the names we recognize

                for (int i=sizeof(aNameValuePair) / sizeof(aNameValuePair[0]); i--;)
                {
                    if (0 == lstrcmpA(aNameValuePair[i].pszName, pszCmdLine))
                    {
                        lcid = aNameValuePair[i].lcid;
                        break;
                    }
                }

                // next see if it was specified numerically

                if (!lcid)
                {
                    lcid = atoi(pszCmdLine);
                }

                pSearchArgument->lcid = lcid;
                SearchOption = pSearchArgument->lcid ? eSearchByLcid : eHelp;
            }
        }
        else
        {
            USES_CONVERSION;

            pSearchArgument->dstrName = A2W(pszCmdLine);
            SearchOption = eSearchByName;
        }
    }
    else
    {
        SearchOption = eNone;
    }

    return SearchOption;
}

/**********************************************************************
* ShowDefaultUser *
*-----------------*
*
*	Description:
*
*       Show the default user's name.
*
* 	Return:
*
*       HRESULT
*
************************************************************* cthrash */

HRESULT
ShowDefaultUser()
{
    HRESULT hr;

    CComPtr<ISpResourceManager> cpResMgr;
    CComPtr<ISpObjectToken> cpToken;
    CSpDynamicString dstrName;

    hr = cpResMgr.CoCreateInstance(CLSID_SpResourceManager);

    if (SUCCEEDED(hr))
    {
        hr = cpResMgr->GetObjectToken(SPCAT_SPEECHUSER, &cpToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = SpGetDescription(cpToken, &dstrName);
    }                

    if (SUCCEEDED(hr))
    {
        ShowUserName(dstrName);
    }
    
    return hr;
}

/**********************************************************************
* SwitchDefaultUser *
*-------------------*
*
*	Description:
*
*       Parse the command line.  Argument can be a name, or a locale
*       specification preceeded by a dash.  Locale specifications can
*       be one of the stock names, or a a numeric LCID.
*
* 	Return:
*
*       One of the SearchOption_t enumerated types
*
************************************************************* cthrash */

HRESULT
SwitchDefaultUser(
    SearchOption_t SearchOption,
    SearchArgument_t * pSearchArgument)
{
    HRESULT hr;
    CComPtr<ISpResourceManager> cpResMgr;
    CComPtr<IEnumSpObjectTokens> cpEnum;
    ULONG celtFetched;
    BOOL fFoundMatch = 0;
    CSpDynamicString dstrName;

    hr = cpResMgr.CoCreateInstance(CLSID_SpResourceManager);

    if (SUCCEEDED(hr))
    {
        hr = cpResMgr->EnumTokens(SPCAT_SPEECHUSER, NULL, NULL, &cpEnum);
    }
    if(hr == S_FALSE)
    {
        hr = SPERR_NOT_FOUND;
    }

    if (SUCCEEDED(hr))
    {
        hr = cpEnum->GetCount(&celtFetched);
    }

    while (!fFoundMatch && SUCCEEDED(hr))
    {
        ISpRegistryObjectToken *pRegToken = 0;
        CSpDynamicString dstrID;
        ISpUser * pSpUser = 0;

        hr = cpEnum->Next(1, (ISpObjectToken**)&pRegToken, &celtFetched);

        if (hr != S_OK)
        {
            break;
        }

        hr = pRegToken->GetID(&dstrID);

        if (SUCCEEDED(hr))
        {
            hr = pRegToken->CreateInstance(NULL, CLSCTX_INPROC_SERVER, IID_ISpUser, (void**)&pSpUser);
        }

        if (SUCCEEDED(hr))
        {
            BOOL fSwitch;
            CSpDynamicString dstrNameT;

            hr = SpGetDescription(pRegToken, &dstrNameT);

            switch (SearchOption)
            {
                case eSearchByName:
                    {
                        fSwitch = SUCCEEDED(hr) && (0 == wcsicmp(pSearchArgument->dstrName, dstrNameT));
                    }
                    break;

                case eSearchByLcid:
                    {
                        SPUSERINFO UserInfo;

                        hr = pSpUser->GetInfo(&UserInfo);

                        fSwitch = SUCCEEDED(hr) && (UserInfo.cLanguages > 0) && (UserInfo.aLanguage[0] == pSearchArgument->lcid);
                    }
                    break;

                default:
                    fSwitch = FALSE; // in case somebody adds an enum
                    break;
            }

            if (fSwitch)
            {
                dstrName = dstrNameT;
                
                if (SUCCEEDED(hr))
                {
                    hr = cpResMgr->SetDefault(pRegToken);
                }

                if (SUCCEEDED(hr))
                {
                    fFoundMatch = 1;
                }
            }
        }

        if (pSpUser)
        {
            pSpUser->Release();
        }

        if (pRegToken)
        {
            pRegToken->Release();
        }
    }

    hr = SUCCEEDED(hr) ? (fFoundMatch ? S_OK : E_INVALIDARG) : hr;
    
    if (FAILED(hr))
    {
        Report("Couldn't find an appropriate user", E_INVALIDARG);
    }
    else if (g_fVerbose)
    {
        ShowUserName(dstrName);
    }

    return hr;
}

void
ShowUserName(WCHAR * pszName)
{
    USES_CONVERSION;

    CSpDynamicString dstrOutput;

    dstrOutput = "Current default user: ";
    dstrOutput.Append(pszName);

    g_fVerbose = TRUE;

    Report(W2T(dstrOutput), S_FALSE);
}

/**********************************************************************
* Report *
*--------*
*
*	Description:
*
*       Show a message box, possibly indicating an error.
*
* 	Return:
*
*       The HRESULT passed in is returned, for the convenience of
*       the caller.
*
************************************************************* cthrash */

HRESULT Report(char * lpMsg, HRESULT hr)
{
    if (hr != S_OK || g_fVerbose)
    {
        const UINT uType = MB_OK | (FAILED(hr) ? MB_ICONERROR : MB_ICONINFORMATION);

        MessageBox(HWND_DESKTOP, lpMsg, "spuser.exe", uType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\templates\class.h ===
/****************************************************************************
* <>
********************************************************************<>*/
class 
{
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\templates\template.h ===
/****************************************************************************
*   <>.h
*       <>
*
*   Owner: <>
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\templates\template.cpp ===
/****************************************************************************
*   <>.cpp
*       <>
*
*   Owner: <>
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#include "stdafx.h"
#include ".h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\bin\templates\function.cpp ===
/****************************************************************************
* *
*-----------------*
*   Description:  
*       <>
*
*   Return:
*   <>
********************************************************************<>*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\commonlx.h ===
/*******************************************************************************
* CommonLx.h
*   This is the header file for the defines and constants used by sapi lexicon
*   and the tools
*
*  Owner: yunusm                                                Date: 07/01/99
*
*  Copyright (c) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include <stdio.h>
#include "sapi.h"
#include "spddkhlp.h"

// Phone converter defines for the SpPhoneConverter class
const static DWORD g_dwMaxLenPhone = 7; // Maximum number of unicode characters in phone string
const static DWORD g_dwMaxLenId = 3;    // Maximum number of ids that can be run together per phone string.
                                            // This number is 1 for SAPI converters but SR, TTS use this to encode one string into several ids
                                            // using in the form "aa 01235678".

// The following defines used by the compression code for Lookup/Vendor lexicons
#define MAXTOTALCBSIZE     9  // = CBSIZE + MAXELEMENTSIZE
#define MAXELEMENTSIZE     5  // = greater of (LTSINDEXSIZE, POSSIZE)
#define CBSIZE             4  // = LASTINFOFLAGSIZE + WORDINFOTYPESIZE
#define LASTINFOFLAGSIZE   1
#define WORDINFOTYPESIZE   3
#define LTSINDEXSIZE       4
#define POSSIZE            5 // a maximum of 32 parts of speech

typedef enum tagSPLexWordInfoType
{
   ePRON = 1,
   ePOS = 2
} SPLEXWORDINFOTYPE;

/*
Control block layout

struct CB
{
   BYTE fLast : LASTINFOFLAGSIZE; // Is this the last Word Information piece
   BYTE WordInfoType : WORDINFOTYPESIZE;  // Allow for 8 types
};
*/

typedef struct tagLookupLexInfo
{
   GUID  guidValidationId;
   GUID  guidLexiconId;
   LANGID LangID;
   WORD  wReserved;
   DWORD nNumberWords;
   DWORD nNumberProns;
   DWORD nMaxWordInfoLen;
   DWORD nLengthHashTable;
   DWORD nBitsPerHashEntry;
   DWORD nCompressedBlockBits;
   DWORD nWordCBSize;
   DWORD nPronCBSize;
   DWORD nPosCBSize;
} LOOKUPLEXINFO, *PLOOKUPLEXINFO;

typedef struct tagLtsLexInfo
{
   GUID        guidValidationId;
   GUID        guidLexiconId;
   LANGID      LangID;
} LTSLEXINFO, *PLTSLEXINFO;

// The following two typedefs used in Japanese and Chinese phone converters

typedef struct SYLDIC 
{
    char *pKey;
    WCHAR *pString;
} SYLDIC;

typedef struct SYLDICW 
{
    WCHAR *pwKey;
    char *pString;
} SYLDICW;

//--- Validation functions ----------------------------------------------------

inline BOOL SpIsBadLexType(DWORD dwFlag)
{
    if (dwFlag != eLEXTYPE_USER &&
        dwFlag != eLEXTYPE_APP &&
        !(dwFlag >= eLEXTYPE_PRIVATE1 && dwFlag <= eLEXTYPE_PRIVATE20))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

inline BOOL SPIsBadPartOfSpeech(SPPARTOFSPEECH ePartOfSpeech)
{
    SPPARTOFSPEECH eMask = (SPPARTOFSPEECH)~0xfff;
    SPPARTOFSPEECH ePOS = (SPPARTOFSPEECH)(ePartOfSpeech & eMask);
    if (ePartOfSpeech != SPPS_NotOverriden &&
        ePartOfSpeech != SPPS_Unknown &&
        ePOS != SPPS_Noun &&
        ePOS != SPPS_Verb &&
        ePOS != SPPS_Modifier &&
        ePOS != SPPS_Function &&
        ePOS != SPPS_Interjection)
    {
        return TRUE;
    }
    return FALSE;
}


inline BOOL SPIsBadLexWord(const WCHAR *pszWord)
{
    return (SPIsBadStringPtr(pszWord) || !*pszWord || wcslen(pszWord) >= SP_MAX_WORD_LENGTH);
}


inline BOOL SPIsBadLexPronunciation(CComPtr<ISpPhoneConverter> spPhoneConv, const WCHAR *pszPronunciation)
{
    HRESULT hr = S_OK;
    WCHAR szPhone[SP_MAX_PRON_LENGTH * (g_dwMaxLenPhone + 1)]; // we will not fail for lack of space

    if (SPIsBadStringPtr(pszPronunciation) || !*pszPronunciation ||
        (wcslen(pszPronunciation) >= SP_MAX_PRON_LENGTH))
    {
        return TRUE;
    }
    if (spPhoneConv)
    {
        hr = spPhoneConv->IdToPhone(pszPronunciation, szPhone);
    }
    return (FAILED(hr));
}


inline BOOL SPIsBadWordPronunciationList(SPWORDPRONUNCIATIONLIST *pWordPronunciationList)
{
    return (SPIsBadWritePtr(pWordPronunciationList, sizeof(SPWORDPRONUNCIATIONLIST)) ||
            SPIsBadWritePtr(pWordPronunciationList->pvBuffer, pWordPronunciationList->ulSize));
}


inline BOOL SPIsBadWordList(SPWORDLIST *pWordList)
{
    return (SPIsBadWritePtr(pWordList, sizeof(SPWORDLIST)) ||
            SPIsBadWritePtr(pWordList->pvBuffer, pWordList->ulSize));
}

inline HRESULT SPCopyPhoneString(const WCHAR *pszSource, WCHAR *pszTarget)
{
	HRESULT hr = S_OK;

	if (SPIsBadWritePtr(pszTarget, (wcslen(pszSource) + 1) * sizeof(WCHAR)))
    {
		hr = E_INVALIDARG;
    }
	else
    {
		wcscpy(pszTarget, pszSource);
    }
	return hr;
}

/*****************************************************************************
* GetWordHashValue *
*------------------*
*
*   Description:
*       Hash function for the Word hash tables. This hash function tries to create
*       a word hash value very dependant on the word text. The mean collison rate
*       on hash tables populated with this hash function is 1 per word access. This
*       result was when collisions were resolved using linear probing when
*       populating the hash table. Using non-linear probing might yield an even lower
*       mean collision rate.
*
*   Return:
*       hash value
**********************************************************************YUNUSM*/
inline DWORD GetWordHashValue(PCWSTR pwszWord,         // word string
                              DWORD nLengthHash        // length of hash table
                              )
{
   DWORD dHash = *pwszWord++;
   
   WCHAR c;
   WCHAR cPrev = (WCHAR)dHash;

   for (; *pwszWord; pwszWord++)
   {
      c = *pwszWord;
      dHash += ((c << (cPrev & 0x1F)) + (cPrev << (c & 0x1F)));

      cPrev = c;
   }
   return (((dHash << 16) - dHash) % nLengthHash);
}

/*******************************************************************************
* ReallocSPWORDPRONList *
*-----------------------*
*   Description:
*       Grow a SPWORDPRONUNCIATIONLIST if necessary 
*
*   Return: 
*       S_OK
*       E_OUTOFMEMORY
/**************************************************************** YUNUSM ******/
inline HRESULT ReallocSPWORDPRONList(SPWORDPRONUNCIATIONLIST *pSPList,   // buffer to grow
                                     DWORD dwSize                        // length to grow to
                                     )
{
    SPDBG_FUNC("ReallocSPWORDPRONList");

    HRESULT hr = S_OK;
    if (pSPList->ulSize < dwSize)
    {
        BYTE *p = (BYTE *)CoTaskMemRealloc(pSPList->pvBuffer, dwSize);
        if (!p)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pSPList->pvBuffer = p;
            pSPList->pFirstWordPronunciation = (SPWORDPRONUNCIATION *)p;
            pSPList->ulSize = dwSize;
        }
    }
    else
    {
        pSPList->pFirstWordPronunciation = (SPWORDPRONUNCIATION *)(pSPList->pvBuffer);
    }
    return hr;
}

/*******************************************************************************
* ReallocSPWORDList *
*-----------------------*
*   Description:
*       Grow a SPWORDLIST if necessary 
*
*   Return: 
*       S_OK
*       E_OUTOFMEMORY
/**************************************************************** YUNUSM ******/
inline HRESULT ReallocSPWORDList(SPWORDLIST *pSPList,   // buffer to grow
                                 DWORD dwSize           // length to grow to
                                 )
{
    SPDBG_FUNC("ReallocSPWORDList");

    HRESULT hr = S_OK;
    if (pSPList->ulSize < dwSize)
    {
        BYTE *p = (BYTE *)CoTaskMemRealloc(pSPList->pvBuffer, dwSize);
        if (!p)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pSPList->pvBuffer = p;
            pSPList->pFirstWord = (SPWORD *)p;
            pSPList->ulSize = dwSize;
        }
    }
    else
    {
        pSPList->pFirstWord = (SPWORD *)(pSPList->pvBuffer);
    }
    return hr;
}

inline size_t PronSize(const WCHAR * const pwszPron)
{
    // NB - SPWORDPRONUNCIATION struct size includes space for one SPPHONEID

    const size_t cb = sizeof(SPWORDPRONUNCIATION) + (wcslen(pwszPron) * sizeof(SPPHONEID));

    return (cb + sizeof(void *) - 1) & ~(sizeof(void *) - 1);
}


inline size_t WordSize(const WCHAR * const pwszWord)
{
    // SPWORD struct size with the aligned word size

    const size_t cb = sizeof(SPWORD) + ((wcslen(pwszWord) + 1) * sizeof(WCHAR));

    return (cb + sizeof(void *) - 1) & ~(sizeof(void *) - 1);
}

/*******************************************************************************
* CreateNextPronunciation *
*-------------------------*
*   Description:
*       Returns a pointer to the location in the pronunciation array
*       where the next pronunciation in the list should start.
*       This function should be used only when creating the list.
*       Once the list is created, access the next pronunciation 
*       through the ->pNextWordPronunciation member.
*
/**************************************************************** PACOGG ******/
inline SPWORDPRONUNCIATION* CreateNextPronunciation(SPWORDPRONUNCIATION *pSpPron)
{
    return (SPWORDPRONUNCIATION *)((BYTE *)pSpPron + PronSize(pSpPron->szPronunciation));
}

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\sapiarray.h ===
/*******************************************************************************
* SapiArray.h *
*------------*
*   Description:
*       This is the header file for SAPI internal array stuff.
*
*   Copyright 1998-2000 Microsoft Corporation All Rights Reserved.
*
*******************************************************************************/

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

template <class T>
HRESULT CopyAndExpandArray(T ** ppArraySrc, ULONG CurSize, T ** ppArrayDest, ULONG NewSize, BOOL fZeroMem = true)
{
    T * pNew = new T[NewSize];

    if (pNew && ( CurSize < NewSize ))
    {
        if (CurSize)
        {
            memcpy(pNew, *ppArraySrc, sizeof(T) * CurSize);
        }
        if (fZeroMem)
        {
            memset(pNew + CurSize, 0, sizeof(T) * (NewSize - CurSize));
        }
        *ppArrayDest = pNew;
        return S_OK;
    }
    else if( pNew )
    {
        if( CurSize )
        {
            memcpy( pNew, *ppArraySrc, sizeof(T) * NewSize );
        }
        else if( fZeroMem )
        {
            memset( pNew , 0, sizeof(T) * NewSize );
        }
        *ppArrayDest = pNew;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
HRESULT ReallocateArray(T ** ppArray, ULONG CurSize, ULONG NewSize, BOOL fZeroMem = true)
{
    T * pNew = new T[NewSize];
    SPDBG_ASSERT(CurSize <= NewSize);
    if (pNew)
    {
        if (CurSize)
        {
            memcpy(pNew, *ppArray, sizeof(T) * CurSize);
        }
        if (fZeroMem)
        {
            memset(pNew + CurSize, 0, sizeof(T) * (NewSize - CurSize));
        }
        delete[] *ppArray;
        *ppArray = pNew;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
HRESULT AllocateArray(T ** ppArray, ULONG Size, BOOL fZeroMem = true)
{
    SPDBG_ASSERT(*ppArray == NULL);
    *ppArray = new T[Size];
    if (*ppArray)
    {
        if (fZeroMem)
        {
            memset(*ppArray, 0, sizeof(T) * Size);
        }
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\assertwithstack.h ===
//----------------------------------------------------------------------------- 
// Copyright (c) Microsoft Corporation. All rights reserved.
//----------------------------------------------------------------------------- 

#pragma once

#ifdef ASSERT_WITH_STACK
#ifndef _WIN64

#include <windows.h>
#include <imagehlp.h>
#include <crtdbg.h>

//
//--- Constants ---------------------------------------------------------------
//

const UINT cchMaxAssertModuleLen = 12;
const UINT cchMaxAssertSymbolLen = 257;
const UINT cfrMaxAssertStackLevels = 20;
const UINT cchMaxAssertExprLen = 257;

const UINT cchMaxAssertStackLevelStringLen = 
    (2 * 8) + cchMaxAssertModuleLen + cchMaxAssertSymbolLen + 12;
    // 2 addresses of at most 8 char, module, symbol, and the extra chars:
    // 0x<address>: <module>! <symbol> + 0x<offset>\n

//
//--- Prototypes --------------------------------------------------------------
//

/****************************************************************************
* MagicDeinit *
*-------------*
*   Description:  
*       Cleans up for the symbol loading code. Should be called before
*       exiting in order to free the dynamically loaded imagehlp.dll
****************************************************************************/
void MagicDeinit(void);

/****************************************************************************
* GetStringFromStackLevels *
*--------------------------*
*   Description:  
*       Retrieves a string from the stack frame. If more than one frame, they
*       are separated by newlines. Each fram appears in this format:
*
*           0x<address>: <module>! <symbol> + 0x<offset>
****************************************************************************/
void GetStringFromStackLevels(UINT ifrStart, UINT cfrTotal, CHAR *pszString);

/****************************************************************************
* GetAddrFromStackLevel *
*-----------------------*
*   Description:  
*       Retrieves the address of the next instruction to be executed on a
*       particular stack frame.
*
*   Return:
*       The address as a DWORD.
****************************************************************************/
DWORD GetAddrFromStackLevel(UINT ifrStart);

/****************************************************************************
* GetStringFromAddr *
*-------------------*
*   Description:  
*       Builds a string from an address in the format:
*
*           0x<address>: <module>! <symbol> + 0x<offset>
****************************************************************************/
void GetStringFromAddr(DWORD dwAddr, TCHAR *szString);

//
//--- _ASSERTE replacement ----------------------------------------------------
//

/****************************************************************************
* _ASSERTE *
*----------*
*   Description:  
*       A replacement for the CRT runtime's version of _ASSERTE that also
*       includes stack information in the assert.
****************************************************************************/
#undef _ASSERTE
#define _ASSERTE(expr) \
        do \
        { \
            if (!(expr)) \
            { \
                char *pszExprWithStack = \
                    (char*)_alloca( \
                        cchMaxAssertStackLevelStringLen * \
                            cfrMaxAssertStackLevels + cchMaxAssertExprLen + 50 + 1); \
                strcpy(pszExprWithStack, #expr); \
                strcat(pszExprWithStack, "\n\n"); \
                GetStringFromStackLevels(0, 10, pszExprWithStack + strlen(pszExprWithStack)); \
                strcat(pszExprWithStack, "\n"); \
                SYSTEMTIME sysTime; \
                GetLocalTime(&sysTime); \
                CHAR pszDateTime[50]; \
                sprintf(pszDateTime, "\n%d.%d.%d %02d:%02d:%02d", \
                                     sysTime.wMonth,sysTime.wDay,sysTime.wYear, \
                                     sysTime.wHour,sysTime.wMinute,sysTime.wSecond); \
                strcat(pszExprWithStack, pszDateTime); \
                if (1 == _CrtDbgReport(_CRT_ASSERT, \
                                       __FILE__, \
                                       __LINE__, \
                                       NULL, pszExprWithStack)) \
                    _CrtDbgBreak(); \
            } \
        } while (0) \

#endif // _WIN64
#endif // ASSERT_WITH_STACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\spautoobjectlock.h ===
#pragma once

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

class CSPAutoObjectLock
{
  protected:
    CComObjectRootEx<CComMultiThreadModel>* m_pObject;

  public:
    CSPAutoObjectLock(CComObjectRootEx<CComMultiThreadModel> * const pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CSPAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define SPAUTO_OBJ_LOCK CSPAutoObjectLock lck(this)
#define SPAUTO_OBJ_LOCK_OBJECT( t ) CSPAutoObjectLock lck##__LINE__(t)

#endif // __ATLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\spautocritseclock.h ===
#pragma once

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

class CSPAutoCritSecLock
{
  protected:
    CComAutoCriticalSection* m_pSec;

  public:
    CSPAutoCritSecLock(CComAutoCriticalSection* pSec)
    {
        m_pSec = pSec;
        m_pSec->Lock();
    };

    ~CSPAutoCritSecLock()
    {
        m_pSec->Unlock();
    };
};

#define SPAUTO_SEC_LOCK( s ) CSPAutoCritSecLock lck##__LINE__(s);

#endif // __ATLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\assertwithstack.cpp ===
//----------------------------------------------------------------------------- 
// Copyright (c) Microsoft Corporation. All rights reserved.
//----------------------------------------------------------------------------- 

#ifdef ASSERT_WITH_STACK
#ifndef _WIN64

#include "AssertWithStack.h"

//
//--- Macros ------------------------------------------------------------------
//

#define COUNT_OF(x)    (sizeof(x) / sizeof(x[0]))

//
// Types and Constants --------------------------------------------------------
//

struct __SYMBOL_INFO
{
    DWORD       dwOffset;
    char        achModule[cchMaxAssertModuleLen];
    char        achSymbol[cchMaxAssertSymbolLen];
};

//--- Function Pointers to APIs in IMAGEHLP.DLL. Loaded dynamically. ---------

typedef LPAPI_VERSION (__stdcall *pfnImgHlp_ImagehlpApiVersionEx)(
    LPAPI_VERSION AppVersion
    );

typedef BOOL (__stdcall *pfnImgHlp_StackWalk)(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetModuleInfo)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    );

typedef LPVOID (__stdcall *pfnImgHlp_SymFunctionTableAccess)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetSymFromAddr)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PDWORD              pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    );

typedef BOOL (__stdcall *pfnImgHlp_SymInitialize)(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     fInvadeProcess
    );

typedef BOOL (__stdcall *pfnImgHlp_SymUnDName)(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );

typedef BOOL (__stdcall *pfnImgHlp_SymLoadModule)(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );

struct IMGHLPFN_LOAD
{
    LPSTR   pszFnName;
    LPVOID * ppvfn;
};

//
// Globals --------------------------------------------------------------------
//

static BOOL      g_fLoadedImageHlp = FALSE;          // set to true on success
static BOOL      g_fLoadedImageHlpFailed = FALSE;    // set to true on failure
static HINSTANCE g_hinstImageHlp   = NULL;
static HANDLE    g_hProcess = NULL;

pfnImgHlp_ImagehlpApiVersionEx    _ImagehlpApiVersionEx;
pfnImgHlp_StackWalk               _StackWalk;
pfnImgHlp_SymGetModuleInfo        _SymGetModuleInfo;
pfnImgHlp_SymFunctionTableAccess  _SymFunctionTableAccess;
pfnImgHlp_SymGetSymFromAddr       _SymGetSymFromAddr;
pfnImgHlp_SymInitialize           _SymInitialize;
pfnImgHlp_SymUnDName              _SymUnDName;
pfnImgHlp_SymLoadModule           _SymLoadModule;

IMGHLPFN_LOAD ailFuncList[] =
{
    { "ImagehlpApiVersionEx",   (LPVOID*)&_ImagehlpApiVersionEx },
    { "StackWalk",              (LPVOID*)&_StackWalk },
    { "SymGetModuleInfo",       (LPVOID*)&_SymGetModuleInfo },
    { "SymFunctionTableAccess", (LPVOID*)&_SymFunctionTableAccess },
    { "SymGetSymFromAddr",      (LPVOID*)&_SymGetSymFromAddr },
    { "SymInitialize",          (LPVOID*)&_SymInitialize },
    { "SymUnDName",             (LPVOID*)&_SymUnDName },
    { "SymLoadModule",          (LPVOID*)&_SymLoadModule },
};

//
//--- Forward declarations ----------------------------------------------------
//

static int Dummy1();
static int Dummy2();

/****************************************************************************
* Dummy1 *
*--------*
*   Description:  
*       A placeholder function used to determine if addresses being retrieved
*       are for functions in this compilation unit or not.
*
*       WARNING!! This function must be the first function in this
*       compilation unit
****************************************************************************/
static int Dummy1()
{
    return 1;
}

/****************************************************************************
* IsWin95 *
*---------*
*   Description:  
*       Are we running on Win95 or not. Some of the logic contained here
*       differs on Windows 9x.
*
*   Return:
*   TRUE - If we're running on a Win 9x platform
*   FALSE - If we're running on a non-Win 9x platform
****************************************************************************/
static BOOL IsWin95()
{
    return GetVersion() & 0x80000000;
}

/****************************************************************************
* MagicInit *
*-----------*
*   Description:  
*       Initializes the symbol loading code. Currently called (if necessary)
*       at the beginning of each method that might need ImageHelp to be
*       loaded.
****************************************************************************/
void MagicInit()
{
    if (g_fLoadedImageHlp || g_fLoadedImageHlpFailed)
    {
        return;
    }

    g_hProcess = GetCurrentProcess();
    
    //
    // Try to load imagehlp.dll
    //
    g_hinstImageHlp = LoadLibraryA("imagehlp.dll");
    _ASSERT(g_hinstImageHlp);

    if (NULL == g_hinstImageHlp)
    {
        g_fLoadedImageHlpFailed = TRUE;
        return;
    }

    //
    // Try to get the API entrypoints in imagehlp.dll
    //
    for (int i = 0; i < COUNT_OF(ailFuncList); i++)
    {
        *(ailFuncList[i].ppvfn) = GetProcAddress(
                g_hinstImageHlp, 
                ailFuncList[i].pszFnName);
        _ASSERT(*(ailFuncList[i].ppvfn));
        
        if (!*(ailFuncList[i].ppvfn))
        {
            g_fLoadedImageHlpFailed = TRUE;
            return;
        }
    }

    API_VERSION AppVersion = { 4, 0, API_VERSION_NUMBER, 0 };
    LPAPI_VERSION papiver = _ImagehlpApiVersionEx(&AppVersion);

    //
    // We assume any version 4 or greater is OK.
    //
    _ASSERT(papiver->Revision >= 4);
    if (papiver->Revision < 4)
    {
        g_fLoadedImageHlpFailed = TRUE;
        return;
    }

    g_fLoadedImageHlp = TRUE;
    
    //
    // Initialize imagehlp.dll
    //
    _SymInitialize(g_hProcess, NULL, FALSE);

    return;
}


/****************************************************************************
* FillSymbolInfo *
*----------------*
*   Description:  
*       Fills in a __SYMBOL_INFO structure
****************************************************************************/
void FillSymbolInfo
(
__SYMBOL_INFO *psi,
DWORD dwAddr
)
{
    if (!g_fLoadedImageHlp)
    {
        return;
    }

    _ASSERT(psi);
    memset(psi, 0, sizeof(__SYMBOL_INFO));

    IMAGEHLP_MODULE  mi;
    mi.SizeOfStruct = sizeof(mi);
    
    if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
    {
        strncpy(psi->achModule, "<no module>", sizeof(psi->achModule)-1);
    }
    else
    {
        strncpy(psi->achModule, mi.ModuleName, sizeof(psi->achModule)-1);
        strupr(psi->achModule);
    }

    CHAR rgchUndec[256];
    CHAR * pszSymbol = NULL;

    // Name field of IMAGEHLP_SYMBOL is dynamically sized.
    // Pad with space for 255 characters.
    union
    {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddr;
        sym.MaxNameLength = 255;

        if (_SymGetSymFromAddr(g_hProcess, dwAddr, &psi->dwOffset, &sym))
        {
            pszSymbol = sym.Name;

            if (_SymUnDName(&sym, rgchUndec, COUNT_OF(rgchUndec)-1))
            {
                pszSymbol = rgchUndec;
            }
        }
        else
        {
            pszSymbol = "<no symbol>";
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";
        psi->dwOffset = dwAddr - mi.BaseOfImage;
    }

    strncpy(psi->achSymbol, pszSymbol, COUNT_OF(psi->achSymbol)-1);
}

/****************************************************************************
* FunctionTableAccess *
*---------------------*
*   Description:  
*       Helper for imagehlp's StackWalk API.
****************************************************************************/
LPVOID __stdcall FunctionTableAccess
(
HANDLE hProcess,
DWORD dwPCAddr
)
{
    return _SymFunctionTableAccess( hProcess, dwPCAddr );
}

/****************************************************************************
* GetModuleBase *
*---------------*
*   Description:  
*       Helper for imagehlp's StackWalk API. Retrieves the base address of 
*       the module containing the giving virtual address.
*
*       NOTE: If the module information for the given module hasnot yet been
*       loaded, then it is loaded on this call.
*
*   Return:
*       Base virtual address where the module containing ReturnAddress is
*       loaded, or 0 if the address cannot be determined.
****************************************************************************/
DWORD __stdcall GetModuleBase
(
HANDLE hProcess,
DWORD dwAddr
)
{
    IMAGEHLP_MODULE ModuleInfo;
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
    
    if (_SymGetModuleInfo(hProcess, dwAddr, &ModuleInfo))
    {
        return ModuleInfo.BaseOfImage;
    }
    else
    {
        MEMORY_BASIC_INFORMATION mbi;
        
        if (VirtualQueryEx(hProcess, (LPVOID)dwAddr, &mbi, sizeof(mbi)))
        {
            if (IsWin95() || (mbi.Type & MEM_IMAGE))
            {
                char achFile[MAX_PATH] = {0};
                DWORD cch;
                
                cch = GetModuleFileNameA(
                        (HINSTANCE)mbi.AllocationBase,
                        achFile,
                        MAX_PATH);

                // Ignore the return code since we can't do anything with it.
                _SymLoadModule(
                    hProcess,
                    NULL,
                    ((cch) ? achFile : NULL),
                    NULL,
                    (DWORD)mbi.AllocationBase,
                    0);

                return (DWORD)mbi.AllocationBase;
            }
        }
    }

    return 0;
}


/****************************************************************************
* GetStackBacktrace *
*-------------------*
*   Description:  
*       Gets a stacktrace of the current stack, including symbols.
*
*   Return:
*       The number of elements actually retrieved.
****************************************************************************/
UINT GetStackBacktrace
(
UINT ifrStart,          // How many stack elements to skip before starting.
UINT cfrTotal,          // How many elements to trace after starting.
DWORD *pdwEip,          // Array to be filled with stack addresses.
__SYMBOL_INFO *psiSymbols // This array is filled with symbol information.
                        // It should be big enough to hold cfrTotal elts.
                        // If NULL, no symbol information is stored.
)
{
    DWORD * pdw = pdwEip;
    __SYMBOL_INFO * psi = psiSymbols;

    MagicInit();

    memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

    if (psiSymbols)
    {
        memset(psiSymbols, 0, cfrTotal * sizeof(__SYMBOL_INFO));
    }

    if (!g_fLoadedImageHlp)
    {
        return 0;
    }

    HANDLE hThread;
    hThread = GetCurrentThread();

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME stkfrm;
        memset(&stkfrm, 0, sizeof(STACKFRAME));

        stkfrm.AddrPC.Mode      = AddrModeFlat;

        DWORD dwMachType;

#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter

        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (unsigned long) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif
#error("Unknown Target Machine");
#endif

        // Ignore this function (GetStackBackTrace)
        ifrStart += 1;

        for (UINT i = 0; i < ifrStart + cfrTotal; i++)
        {
            if (!_StackWalk(dwMachType,
                            g_hProcess,
                            hThread,
                            &stkfrm,
                            &context,
                            NULL,
                            FunctionTableAccess,
                            GetModuleBase,
                            NULL))
            {
                break;
            }
            if (i >= ifrStart &&
                ((void*)stkfrm.AddrPC.Offset < (void*)Dummy1 ||
                (void*)stkfrm.AddrPC.Offset > (void*)Dummy2))
            {
                *pdw++ = stkfrm.AddrPC.Offset;

                if (psi)
                {
                    FillSymbolInfo(psi++, stkfrm.AddrPC.Offset);
                }   
            }
        }
    }

    return pdw - pdwEip;
}


/****************************************************************************
* GetStringFromSymbolInfo *
*-------------------------*
*   Description:  
*       Actually prints the info into the string for the symbol.
****************************************************************************/
void GetStringFromSymbolInfo
(
DWORD dwAddr,
__SYMBOL_INFO *psi,   // @parm Pointer to __SYMBOL_INFO. Can be NULL.
CHAR *pszString     // @parm Place to put string.
)
{
    _ASSERT(pszString);

    // <module>! <symbol> + 0x<offset> 0x<addr>\n

    if (psi)
    {
        wsprintfA(pszString,
                 "%s! %s + 0x%X (0x%08X)",
                 (psi->achModule[0]) ? psi->achModule : "<no module>",
                 (psi->achSymbol[0]) ? psi->achSymbol : "<no symbol>",
                 psi->dwOffset,
                 dwAddr);
    }
    else
    {
        wsprintfA(pszString, "<symbols not available> (0x%08X)", dwAddr);
    }

    _ASSERT(strlen(pszString) < cchMaxAssertStackLevelStringLen);
}

/****************************************************************************
* GetStringFromStackLevels *
*--------------------------*
*   Description:  
*       Retrieves a string from the stack frame. If more than one frame, they
*       are separated by newlines
****************************************************************************/
void GetStringFromStackLevels
(
UINT ifrStart,      // @parm How many stack elements to skip before starting.
UINT cfrTotal,      // @parm How many elements to trace after starting.
                    //  Can't be more than cfrMaxAssertStackLevels.
CHAR *pszString     // @parm Place to put string.
                    //  Max size will be cchMaxAssertStackLevelStringLen * cfrTotal.
)
{
    _ASSERT(pszString);
    _ASSERT(cfrTotal < cfrMaxAssertStackLevels);

    *pszString = '\0';

    if (cfrTotal == 0)
    {
        return;
    }

    DWORD rgdwStackAddrs[cfrMaxAssertStackLevels];
    __SYMBOL_INFO rgsi[cfrMaxAssertStackLevels];

    // Ignore this function (GetStringFromStackLevels)
    ifrStart += 1;

    UINT uiRetrieved =
            GetStackBacktrace(ifrStart, cfrTotal, rgdwStackAddrs, rgsi);

    // First level
    CHAR aszLevel[cchMaxAssertStackLevelStringLen];
    GetStringFromSymbolInfo(rgdwStackAddrs[0], &rgsi[0], aszLevel);
    strcpy(pszString, aszLevel);

    // Additional levels
    for (UINT i = 1; i < uiRetrieved; ++i)
    {
        strcat(pszString, "\n");
        GetStringFromSymbolInfo(rgdwStackAddrs[i],
                        &rgsi[i], aszLevel);
        strcat(pszString, aszLevel);
    }

    _ASSERT(strlen(pszString) <= cchMaxAssertStackLevelStringLen * cfrTotal);
}


/****************************************************************************
* GetAddrFromStackLevel *
*-----------------------*
*   Description:  
*       Retrieves the address of the next instruction to be executed on a
*       particular stack frame.
*
*   Return:
*       The address of the next instruction,
*       0 if there's an error.
****************************************************************************/
DWORD GetAddrFromStackLevel
(
UINT ifrStart       // How many stack elements to skip before starting.
)
{
    MagicInit();

    if (!g_fLoadedImageHlp)
    {
        return 0;
    }

    HANDLE hThread;
    hThread  = GetCurrentThread();

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME stkfrm;
        memset(&stkfrm, 0, sizeof(STACKFRAME));

        stkfrm.AddrPC.Mode      = AddrModeFlat;

        DWORD dwMachType;
        
#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter

        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (unsigned long) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif
#error("Unknown Target Machine");
#endif

        // Ignore this function (GetStackBackTrace) and the one below
        ifrStart += 2;

        for (UINT i = 0; i < ifrStart; i++)
        {
            if (!_StackWalk(dwMachType,
                            g_hProcess,
                            hThread,
                            &stkfrm,
                            &context,
                            NULL,
                            FunctionTableAccess,
                            GetModuleBase,
                            NULL))
            {
                break;
            }
        }

        return stkfrm.AddrPC.Offset;
    }

    return 0;
}


/****************************************************************************
* GetStringFromAddr *
*-------------------*
*   Description:  
*       Returns a string from an address.
****************************************************************************/
void GetStringFromAddr
(
DWORD dwAddr,
CHAR *szString // Place to put string.
               // Buffer must hold at least cchMaxAssertStackLevelStringLen.
)
{
    _ASSERT(szString);

    __SYMBOL_INFO si;
    FillSymbolInfo(&si, dwAddr);

    wsprintfA(szString,
             "%s! %s + 0x%X (0x%08X)",
             (si.achModule[0]) ? si.achModule : "<no module>",
             (si.achSymbol[0]) ? si.achSymbol : "<no symbol>",
             si.dwOffset,
             dwAddr);
}

/****************************************************************************
* MagicDeinit *
*-------------*
*   Description:  
*       Cleans up for the symbol loading code. Should be called before exit
*       to free the dynamically loaded imagehlp.dll.
****************************************************************************/
void MagicDeinit(void)
{
    if (g_hinstImageHlp)
    {
        FreeLibrary(g_hinstImageHlp);

        g_hinstImageHlp   = NULL;
        g_fLoadedImageHlp = FALSE;
    }
}

static int Dummy2()
{
    return 2;
}

#endif // _WIN64
#endif // ASSERT_WITH_STACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\sapiver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "SAPI 5"
#endif
#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        "SAPI5"
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\sapisvrver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "SAPISVR 5"
#define VER_INTERNALNAME_STR        "SAPISVR5"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#include "currver.inc"


#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\spsapiserverhelper.inl ===
/****************************************************************************
* SpSapiServerHelper.inl *
*------------------------*
*   Include file with definition and implementation of some of the 
*   SpSapiServer functions
***************************************************************** BeckyW ***/

#define SERVER_IS_ALIVE_EVENT_NAME      _T("SapiServerIsAlive")
#define SERVER_IS_ALIVE_EVENT_TIMEOUT   30000

HRESULT SpCreateIsServerAliveEvent(HANDLE * phevent)
{
    SPDBG_FUNC("SpCreateIsServerAliveEvent");
    HRESULT hr = S_OK;

    *phevent = CreateEvent(NULL, TRUE, FALSE, SERVER_IS_ALIVE_EVENT_NAME);
    if (*phevent == NULL)
    {
        hr = SpHrFromLastWin32Error();
        SPDBG_ASSERT(FAILED(hr));
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}   /* SpCreateIsServerAliveEvent */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\spsatellite.h ===
/****************************************************************************
*
*   satellite.h
*
*       Support for satellite resource DLLs.
*
*   Owner: cthrash
*
*   Copyright  1999-2000 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include <sphelper.h>

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

class CSpSatelliteDLL
{
    private:

        enum LoadState_t
        {
            LoadState_NotChecked,
            LoadState_Loaded,
            LoadState_NotFound  
        };

#pragma pack(push, LANGANDCODEPAGE, 2)
        struct LangAndCodePage_t
        {
            WORD wLanguage;
            WORD wCodePage;
        };
#pragma pack(pop, LANGANDCODEPAGE)

    private:

        LoadState_t m_eLoadState;
        HINSTANCE   m_hinstRes;   // cached so FreeLibrary can be called;

    public:

        CSpSatelliteDLL() { m_eLoadState = LoadState_NotChecked; m_hinstRes = 0; }
        ~CSpSatelliteDLL() { if (m_hinstRes) { FreeLibrary(m_hinstRes); } }

    public:

        BOOL Checked() const { return LoadState_NotChecked != m_eLoadState; }
        
    public:

        HINSTANCE Load(
            HINSTANCE hinstModule,      // [in] Instance handle of core DLL
            LPCTSTR lpszSatelliteName)  // [in] Satellite DLL name
        {
            HINSTANCE   hinstRes = hinstModule;
            LANGID      langidUI = SpGetUserDefaultUILanguage();
            LANGID      langidModule = 0;
            TCHAR       achPath[MAX_PATH];
            DWORD       cch = GetModuleFileName(hinstModule, achPath, sp_countof(achPath));

            if (cch)
            {
                //
                // First check the locale of the module;
                // If it's the same as the UI, assume it contains language-appropriate resources
                //

                DWORD dwHandle;
                DWORD dwVerInfoSize = GetFileVersionInfoSize(achPath, &dwHandle);

                if (dwVerInfoSize)
                {
                    void * lpBuffer = malloc(dwVerInfoSize);

                    if (lpBuffer)
                    {
                        if (GetFileVersionInfo(achPath, dwHandle, dwVerInfoSize, lpBuffer))
                        {
                            LangAndCodePage_t *pLangAndCodePage;
                            UINT cch;

                            if (VerQueryValue(lpBuffer, TEXT("\\VarFileInfo\\Translation"), (LPVOID *)&pLangAndCodePage, &cch) && cch)
                            {
                                // pay attention only to first entry

                                langidModule = (LANGID)pLangAndCodePage->wLanguage;                        
                            }
                        }

                        free(lpBuffer);
                    }
                }

                //
                // If the languages don't match, look for a resource DLL
                //

                if (langidUI != langidModule)
                {
                    DWORD cchDir;
                    HINSTANCE hinst;

                    // Look for {path}\{lcid}\{dll-name}

                    while (cch && achPath[--cch] != TEXT('\\'));

                    hinst = CheckDLL(achPath, achPath + cch + 1, langidUI, lpszSatelliteName);

                    if (hinst)
                    {
                        hinstRes = hinst; // Found!
                    }
                    else
                    {
                        //
                        // Couldn't find for specified UI langid; try default/netural sublangs.
                        //

                        if (SUBLANGID(langidUI) != SUBLANG_DEFAULT)
                        {
                            hinst = CheckDLL(achPath, achPath + cch + 1, MAKELANGID(PRIMARYLANGID(langidUI), SUBLANG_DEFAULT), lpszSatelliteName);
                        }

                        if (hinst)
                        {
                            hinstRes = hinst; // Found for SUBLANG_DEFAULT!
                        }
                        else if (SUBLANGID(langidUI) != SUBLANG_NEUTRAL)
                        {
                            hinst = CheckDLL(achPath, achPath + cch + 1, MAKELANGID(PRIMARYLANGID(langidUI), SUBLANG_NEUTRAL), lpszSatelliteName);

                            if (hinst)
                            {
                                hinstRes = hinst; // Found for SUBLANG_NEUTRAL!
                            }
                        }
                    }
                }
            }

            if (hinstModule != hinstRes)
            {
                m_hinstRes = hinstRes; // Cache it so the dtor can call FreeLibrary
            }
            
            return hinstRes;
        }

        HINSTANCE Detach(void)
        {
            HINSTANCE hinstRes = m_hinstRes;
            m_hinstRes = NULL;
            return hinstRes;
        }

    private:

        //
        // Check if satellite DLL exist for a particular LANGID
        //
        
        HINSTANCE CheckDLL(
            TCHAR * achPath,            // [in] Complete path of module
            TCHAR * pchDir,             // [in] Path to directory of module (including backslash)
            LANGID langid,              // [in] Language of Satellite DLL
            LPCTSTR lpszSatelliteName)  // [in] Satellite DLL name
        {
            TCHAR * pchSubDir;

            size_t cch;

            // TODO: Verify that the versions are in sync with core DLL?
            
            _itot(langid, pchDir, 10);

            pchSubDir = pchDir + _tcslen(pchDir);

            *pchSubDir++ = TEXT('\\');

            _tcscpy(pchSubDir, lpszSatelliteName);

            return LoadLibrary(achPath);
        }

};

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\sphash.h ===
/****************************************************************************
*	SPHash.h
*       This is modified from sr/include/hash_n.h to minimize dependencies on
*       application specific headers.  
*
*	Owner: bohsu
*	Copyright 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

//--- Includes --------------------------------------------------------------
#include <windows.h>
#include <math.h>
#include <crtdbg.h>
#ifdef _DEBUG
#include <stdio.h>
#endif _DEBUG

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

/***********************************************************************
* CSPHash Class
*   This is a templated hash table class.  Note that the base CSPHash class 
*   does not allocate or free the Keys and Values.  To define a hash class
*   that manages its Keys and Values, derive a subclass an overload Add() 
*   and ...
*****************************************************************bohsu*/
template<class KEY, class VALUE>
class CSPHash
{
public:
    // Constructor
    CSPHash(
        VALUE   ValueNIL = NULL,                // Value representing NIL
        UINT32  uInitialSize = 0);              // Initial hash table size

    // Destructor
    virtual ~CSPHash();

    // Returns number of (Key, Value) entries used in the hash table.
    inline UINT32 GetNumEntries(void) const { return m_uNumEntriesUsed; }

    // Returns the next entry starting at the given index.  Set puIndex = 0 for the first entry.
    VALUE GetNextEntry(
        UINT32 *puIndex,                        // Index to start looking for the next entry
        KEY    *pKey = NULL) const;             // [out] Key of the next entry found

    // Resets the content hash table.
    virtual void Reset(void);

    // Adds a (Key, Value) entry to the hash table.
    HRESULT Add(
        KEY     Key,                            // Key to add
        VALUE   Val);                           // Value associated with the Key

    // Lookup a Value based on the Key.  If not found, ValueNIL is returned.
    VALUE Lookup(
        KEY     Key) const;                     // Key to lookup

#ifdef _DEBUG
    // Dumps the hash table statistics to file handle.
    void    DumpStat(
        FILE       *hFile = NULL,               // Output file handle.  NULL -> DebugWindow
        const char *strHeader = NULL) const;    // Trace header
#endif _DEBUG

protected:
    // Data structure containing (Key, Value) pair
    struct ENTRY
    {
        KEY     Key;
        VALUE   Value;
    };

    // Find the index corresponding to the given Key.
    int FindIndex(
        KEY     Key) const;                     // Key to search for

    static UINT32 NextPrime(UINT32 Val);

protected:
    //---------------------------------------------------------------
    //--- The following functions can be overloaded by subclasses ---
    //---------------------------------------------------------------
    //  If Destroy*() is overloaded, you MUST overload the destructor with:
    //      virtual ~CSPDerivedHash() { Reset(); }
    //  Calling Reset() in the base class destructor has no effect because 
    //  the derived subclass will have been destroyed already by the time it
    //  gets to the base class destructor.  Thus, the correct DestroyKey() and
    //  DestroyValue() will never be called.

    // Hash function mapping the Key to a UINT32 index.
    virtual UINT32 HashKey(KEY Key) const          { return (UINT32)Key; }

    // Compare if two Keys are equal.
    virtual bool   AreKeysEqual(KEY Key1, KEY Key2) const { return Key1 == Key2; }

    // Hash function used to determine the skip count.
    virtual UINT32 HashKey2(KEY Key) const         { return 1; }

    // Overload if a deep copy of the Key needs to be made in Add().
    virtual KEY    CopyKey(KEY Key) const          { return Key; }

    // Overload if a deep copy of the Key needs to be made in Add().
    virtual VALUE  CopyValue(VALUE Value) const    { return Value;  }

    // Overload if the Key needs to be destroyed.
    virtual void   DestroyKey(KEY Key) const       { }

    // Overload if the Value needs to be destroyed.
    virtual void   DestroyValue(VALUE Value) const { }

    //------------------------
    //--- Member Variables ---
    //------------------------
protected:
    ENTRY  *m_aTable;                           // Hash table containing (Key, Value) pairs
    VALUE   m_ValueNIL;                         // Value representing NIL
    UINT32  m_uNumEntries;                      // Current size of hash table
    UINT32  m_uNumEntriesInit;                  // Initial size of hash table
    UINT32  m_uNumEntriesUsed;                  // Current number of entries used in hash table

#ifdef _DEBUG
    UINT32  m_uAccess;                          // Number of times a Key is looked up
    UINT32  m_uSearch;                          // Number of times a entry in the table is searched
    UINT32  m_uRegrow;                          // Number of times the hash table regrew
#endif _DEBUG
};


/***********************************************************************
* CSPStringHashW Class
*   CSPStringHashW is a hash of UNICODE strings to VALUEs.  The UNICODE string
*   is treated as a constant.  It is neither copied during Add() nor deleted
*   during destructor.  Likewise, VALUE is treated as a simple data type and
*   is neither copied nor destroyed.  If the application wants the class to 
*   manage its own copy of the string key or VALUE, derive a subclass and 
*   overload Copy*() and/or Destroy().
*****************************************************************bohsu*/
template<class VALUE> class CSPStringHashW : public CSPHash<const WCHAR *, VALUE> 
{ 
protected:
    UINT32 StringHashW(const WCHAR *wcsKey, UINT32 uPrime) const
    {
        UINT32  uHashIndex = 0;
	    for(const WCHAR *pwch = wcsKey; *pwch != NULL; pwch++)
            uHashIndex = uHashIndex * uPrime + *pwch;
        return uHashIndex;
    }

    //--- Overloaded functions ---
protected:
    virtual UINT32 HashKey(const WCHAR* wcsKey) const  { return StringHashW(wcsKey, 65599); }
    virtual UINT32 HashKey2(const WCHAR* wcsKey) const { return StringHashW(wcsKey, 257); }
    virtual bool AreKeysEqual(const WCHAR* wcsKey1, const WCHAR* wcsKey2) const
    { 
        return wcscmp(wcsKey1, wcsKey2) == 0; 
    }
};
 
/***********************************************************************
* CSPGUIDHash Class
*   CSPGUIDHash is a hash of GUIDs to VALUEs.  The GUID pointer is treated 
*   as a constant.  It is neither copied during Add() nor deleted
*   during destructor.  Likewise, VALUE is treated as a simple data type and
*   is neither copied nor destroyed.  If the application wants the class to 
*   manage its own copy of the GUID key or VALUE, derive a subclass and 
*   overload Copy*() and/or Destroy().
*****************************************************************bohsu*/
template<class VALUE> class CSPGUIDHash : public CSPHash<const GUID *, VALUE> 
{ 
    //--- Overloaded functions ---
protected:
    virtual UINT32 HashKey(const GUID *pguidKey) const  { return pguidKey->Data1; }
    virtual UINT32 HashKey2(const GUID *pguidKey) const { return pguidKey->Data2; }
    virtual bool AreKeysEqual(const GUID *pguidKey1, const GUID *pguidKey2) const
    { 
        // It is annoying that operator== for GUIDs return int (BOOL) instead of bool.
        return (*pguidKey1 == *pguidKey2) != 0; 
    }
};

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------

/**********************************************************************
* CSPHash::CSPHash *
*------------------*
*	Description:  
*       Constructor.
****************************************************************bohsu*/
template<class KEY, class VALUE>
CSPHash<KEY, VALUE>::CSPHash(
    VALUE   ValueNIL,                       // Value representing NIL
    UINT32  uInitialSize)                   // Initial hash table size
{
    m_ValueNIL        = ValueNIL;
    m_aTable          = 0;
    m_uNumEntries     = 0;
    m_uNumEntriesInit = uInitialSize;       // Estimated final number of entries to be stored.
    m_uNumEntriesUsed = 0;

#ifdef _DEBUG
    m_uAccess = 0;
    m_uSearch = 0;
    m_uRegrow = 0;
#endif _DEBUG
}

/**********************************************************************
* CSPHash::~CSPHash *
*-------------------*
*	Description:  
*       Destructor.  This does not free KEY and VALUE.
*       If Destroy*() is overloaded, call Reset() in the subclass destructor.
****************************************************************bohsu*/
template<class KEY, class VALUE>
CSPHash<KEY, VALUE>::~CSPHash()
{
    delete [] m_aTable;
}

/**********************************************************************
* CSPHash::GetNextEntry *
*-----------------------*
*	Description:  
*       Returns the next entry starting at the given index.  Set puIndex = 0 for the first entry.
****************************************************************bohsu*/
template<class KEY, class VALUE>
VALUE CSPHash<KEY, VALUE>::GetNextEntry(
    UINT32 *puIndex,                        // Index to start looking for the next entry
    KEY    *pKey) const                     // [out] Key of the next entry found
{
    while (*puIndex < m_uNumEntries)
    {
        if (m_aTable[*puIndex].Value != m_ValueNIL)
        {
            if(pKey) *pKey = m_aTable[*puIndex].Key;
            return m_aTable[(*puIndex)++].Value;
        }
        ++*puIndex;
    }
    return m_ValueNIL;
}

/**********************************************************************
* CSPHash::Reset *
*----------------*
*	Description:  
*       Resets the content hash table.
****************************************************************bohsu*/
template<class KEY, class VALUE>
void CSPHash<KEY, VALUE>::Reset()
{
    for (UINT32 i=0; i < m_uNumEntries; i++)
    {
        if(m_aTable[i].Value != m_ValueNIL)
        {
            DestroyKey(m_aTable[i].Key);
            DestroyValue(m_aTable[i].Value);
            m_aTable[i].Value = m_ValueNIL;
        }
    }
    
    m_uNumEntriesUsed = 0;
#ifdef _DEBUG
    m_uAccess = m_uSearch = m_uRegrow = 0;    
#endif _DEBUG
}

/**********************************************************************
* CSPHash::Add *
*--------------*
*	Description:  
*       Adds a (Key, Value) entry to the hash table.
****************************************************************bohsu*/
template<class KEY, class VALUE>
HRESULT CSPHash<KEY, VALUE>::Add(
    KEY     Key,                            // Key to add
    VALUE   Val)                            // Value associated with the Key
{
    int ientry;

    // Implementation uses Val==m_ValueNIL to detect empty entries.
    _ASSERTE(Val != m_ValueNIL);

    // Grow if allowed and we're more than half full.
    // (Also handles initial alloc)
    if (m_uNumEntriesUsed * 2 >= m_uNumEntries)
    {
        /* half-full, too crowded ==> regrow */
        ENTRY * oldtable = m_aTable;
        UINT32 oldentry = m_uNumEntries;
        UINT32 prime = NextPrime(max(m_uNumEntriesUsed * 3 + 17, m_uNumEntriesInit));

#ifdef _DEBUG
        m_uRegrow++;
#endif _DEBUG

        // Alloc new table.
        m_aTable = new ENTRY[prime];
        if (m_aTable == NULL)
        {
            m_aTable = oldtable;
            return E_OUTOFMEMORY;
        }

        for (UINT32 i=0; i < prime; i++)
        {
            m_aTable[i].Value = m_ValueNIL;
        }

        m_uNumEntries = prime;

        for (i = 0; i < oldentry; i++)
        {
            if (oldtable[i].Value != m_ValueNIL)
            {
                ientry = FindIndex(oldtable[i].Key);
                _ASSERTE(ientry >= 0 && m_aTable[ientry].Value == m_ValueNIL);
                m_aTable[ientry] = oldtable[i];
            }
        }
        delete [] oldtable;
    }

    // Find out where this element should end up.
    ientry = FindIndex(Key);
    if (ientry < 0)
        return E_FAIL;  // Too full

    if (m_aTable[ientry].Value == m_ValueNIL)
    {
        // Not already there.  Add it.
        m_aTable[ientry].Key = CopyKey(Key);
        m_aTable[ientry].Value = CopyValue(Val);

        m_uNumEntriesUsed++;
    }
    else
    {
        return S_FALSE; // It was already there.
    }

    return S_OK;
}

/**********************************************************************
* CSPHash::Lookup *
*-----------------*
*	Description:  
*       Lookup a Value based on the Key.  If not found, ValueNIL is returned.
****************************************************************bohsu*/
template<class KEY, class VALUE>
VALUE CSPHash<KEY, VALUE>::Lookup(
    KEY     Key) const                      // Key to lookup
{
    int ientry = FindIndex(Key);
    if (ientry < 0)
        return m_ValueNIL;

    return m_aTable[ientry].Value;
}

#ifdef _DEBUG
/**********************************************************************
* CSPHash::DumpStat *
*-------------------*
*	Description:  
*       Dumps the hash table statistics to file handle.
****************************************************************bohsu*/
template<class KEY, class VALUE>
void CSPHash<KEY, VALUE>::DumpStat(
    FILE       *hFile,                      // Output file handle.
    const char *strHeader) const            // Trace header
{
    if(hFile == NULL)
    {
        char buf[100];

        sprintf(buf, "(%s) hash statistics:\n", strHeader ? strHeader : "");
        OutputDebugString(buf);
        sprintf(buf, "load=%d/%d = %.3g, regrow = %d\n", m_uNumEntriesUsed, m_uNumEntries,
               (m_uNumEntries == 0) ? 0 : (float)m_uNumEntriesUsed/(float)m_uNumEntries, m_uRegrow);
        OutputDebugString(buf);
        sprintf(buf, "access %d/%d = %g\n\n", m_uSearch, m_uAccess,
               (m_uAccess == 0) ? 0 :
               (float) m_uSearch / (float) m_uAccess);
        OutputDebugString(buf);
    }
    else
    {
        fprintf(hFile, "(%s) hash statistics:\n", strHeader ? strHeader : "");
        fprintf(hFile, "load=%d/%d = %.3g, regrow = %d\n", m_uNumEntriesUsed, m_uNumEntries,
               (m_uNumEntries == 0) ? 0 : (float)m_uNumEntriesUsed/(float)m_uNumEntries, m_uRegrow);
        fprintf(hFile, "access %d/%d = %g\n\n", m_uSearch, m_uAccess,
               (m_uAccess == 0) ? 0 :
               (float) m_uSearch / (float) m_uAccess);
    }
}
#endif _DEBUG

/**********************************************************************
* CSPHash::FindIndex *
*--------------------*
*	Description:  
*       Find the index corresponding to the given Key.
****************************************************************bohsu*/
template<class KEY, class VALUE>
int CSPHash<KEY, VALUE>::FindIndex(
    KEY     Key) const
{
#ifdef _DEBUG
    // Hack: Violate const declaration for statistics member variables
    const_cast<CSPHash *>(this)->m_uAccess++;
#endif _DEBUG

    if (m_uNumEntries == 0)
        return -1;

    UINT32 start = HashKey(Key) % m_uNumEntries;
    UINT32 index = start;

    UINT32 skip = 0;

    do
    {
#ifdef _DEBUG
        // Hack: Violate const declaration for statistics member variables
        const_cast<CSPHash *>(this)->m_uSearch++;
#endif _DEBUG

        // Not in table; return index where it should be placed.
        if (m_aTable[index].Value == m_ValueNIL)
            return index;

        if (AreKeysEqual(m_aTable[index].Key, Key))
            return index;

        if (skip == 0)
        {
            skip = HashKey2(Key);

            // Limit skip amount to non-zero and less than hash table size.
            // Since m_uNumEntries is prime, they are relatively prime and so we're guaranteed
            // to visit every bucket.
            if (m_uNumEntries > 1)
                skip = skip % (m_uNumEntries - 1) + 1;
        }

        index += skip;
        if (index >= m_uNumEntries)
            index -= m_uNumEntries;
    } while (index != start);

    _ASSERTE(m_uNumEntriesUsed == m_uNumEntries);
    return -1; /* all full and not found */
}

/**********************************************************************
* CSPHash::NextPrime *
*--------------------*
*	Description:  
*	    Return a prime number greater than or equal to Val.
*       If overflow occurs, return 0.
*
*   To Do: This function can be optimized significantly.
****************************************************************bohsu*/
template<class KEY, class VALUE>
UINT32 CSPHash<KEY, VALUE>::NextPrime(UINT32 Val) 
{
    UINT32      maxFactor;
    UINT32      i;
    
    if (Val < 2) return 2;                          // the smallest prime number    
    while(Val < 0xFFFFFFFF) 
    {        
        maxFactor = (UINT32) sqrt ((double) Val);   // Is Val a prime number?
        
        for (i = 2; i <= maxFactor; i++)            // Is i a factor of Val?
            if (Val % i == 0) break;
            
        if (i > maxFactor) return (Val);            
        Val++;
    };
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\spunicode.h ===
/*******************************************************************************
* SPUnicode.H *
*--------------*
*   Description:
*       This is the header file for core helper functions implementation.
*       It is internal to Microsoft and is NOT shipped with the SDK since
*       many of the functions contatined in this file have not been fully
*       tested and therefore should not be exposed in the SDK.    
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/


#ifndef __SPUNICODE_H__
#define __SPUNICODE_H__

#ifndef SPHelper_h
#include <sphelper.h>
#endif

template <const int i = MAX_PATH>
class CSpToAnsiString
{
private:
    CHAR *  m_pStr;
    CHAR    m_aString[i];
public:
    CSpToAnsiString(const WCHAR * psz)
    {
        if (psz)
        {
            m_pStr = m_aString;
            ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        }
        else
        {
            m_pStr = NULL;
        }
    }
    operator CHAR *() { return m_pStr; }
    CHAR * operator =(const WCHAR * psz)
    {
        if (psz)
        {
            m_pStr = m_aString;
            ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        }
        else
        {
            m_pStr = NULL;
        }
        return m_pStr;
    }
};



#ifndef _WIN32_WCE

//
//  The compiler will automatically throw out the inline functions if _UNICODE is defined and simply
//  directly call the Win32 function.  Unfortunately, this requires two classes since simply defining
//  const m_bUnicodeSupport does not force the functions to be inlined when built with _UNICODE.
//
template <BOOL bUnicodeOnly>
class CSpUnicodeSupportT
{
    BOOL    m_bUnicodeSupport;
public:
    CSpUnicodeSupportT()
    {
        if (!bUnicodeOnly)
        {
            m_bUnicodeSupport = ::IsWindowUnicode(::GetDesktopWindow());
        }
    }
    CSpUnicodeSupportT(BOOL bUnicodeSupport)
    {
        if (bUnicodeOnly)
        {
            SPDBG_ASSERT(bUnicodeSupport);
        }
        else
        {
            m_bUnicodeSupport = bUnicodeSupport;
        }
    }
    BOOL UnicodeSystem(void) const 
    {
        if (bUnicodeOnly)
        {
            return TRUE;
        }
        else
        {
            return m_bUnicodeSupport; 
        }
    }
    HANDLE CreateFile(const WCHAR * lpFileName,      
                      DWORD dwDesiredAccess,       
                      DWORD dwShareMode,           
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes,  
                      HANDLE hTemplateFile) const         
    {
        if (UnicodeSystem())
        {
            return ::CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                                 dwFlagsAndAttributes, hTemplateFile);
        }
        else
        {
            return ::CreateFileA(CSpToAnsiString<>(lpFileName), dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                                 dwFlagsAndAttributes, hTemplateFile);
        }
    }
    DWORD GetFullPathName(WCHAR *lpFileName,  // file name
                          DWORD nBufferLength, // size of path buffer
                          WCHAR *lpBuffer,     // path buffer
                          WCHAR **lpFilePart   // address of file name in path
                          )
    {
        if (UnicodeSystem())
        {
            return ::GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        }
        else
        {
            CHAR szTemp[MAX_PATH];
            CHAR *szTempFilePart;
            DWORD tmp = ::GetFullPathNameA(CSpToAnsiString<>(lpFileName), sp_countof(szTemp), szTemp, &szTempFilePart);
            if (tmp)
            {
                tmp = ::MultiByteToWideChar(CP_ACP, 0, szTemp, -1, lpBuffer, nBufferLength);
                lpBuffer[tmp] = 0;
                *lpFilePart = lpBuffer + (szTempFilePart - szTemp);
            }
            return tmp;
        }
    }

    BOOL DeleteFile(LPCWSTR lpFileName)
    {
        if (UnicodeSystem())
        {
            return ::DeleteFileW(lpFileName);
        }
        else
        {
            return ::DeleteFileA(CSpToAnsiString<>(lpFileName));
        }
    }
    BOOL MoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
    {
        if (UnicodeSystem())
        {
            return ::MoveFileW(lpExistingFileName, lpNewFileName);
        }
        else
        {
            return ::MoveFileA(CSpToAnsiString<>(lpExistingFileName), CSpToAnsiString<>(lpNewFileName));
        }
    }
    BOOL CopyFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
    {
        if (UnicodeSystem())
        {
            return ::CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
        }
        else
        {
            return ::CopyFileA(CSpToAnsiString<>(lpExistingFileName), CSpToAnsiString<>(lpNewFileName), bFailIfExists);
        }
    }
    BOOL CreateDirectory(const WCHAR * lpPathName,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes) const
    {
        if (UnicodeSystem())
        {
            return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
        }
        else
        {
            return ::CreateDirectoryA(CSpToAnsiString<>(lpPathName), lpSecurityAttributes);
        }
    }
    BOOL RemoveDirectory(const WCHAR * lpPathName) const
    {
        if (UnicodeSystem())
        {
            return ::RemoveDirectoryW(lpPathName);
        }
        else
        {
            return ::RemoveDirectoryA(CSpToAnsiString<>(lpPathName));
        }
    }
    HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect,
                             DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const WCHAR *lpName)
    {
        if (UnicodeSystem())
        {
            return ::CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                        dwMaximumSizeLow, lpName);
        }
        else
        {
            return ::CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                        dwMaximumSizeLow, CSpToAnsiString<>(lpName));
        }
    }
    BOOL SetFileAttributes(LPCWSTR lpFileName, DWORD dwFileAttributes)
    {
        if (UnicodeSystem())
        {
            return ::SetFileAttributesW(lpFileName, dwFileAttributes);
        }
        else
        {
            return ::SetFileAttributesA(CSpToAnsiString<>(lpFileName), dwFileAttributes);
        }
    }
    DWORD GetFileAttributes(LPCWSTR lpFileName)
    {
        if (UnicodeSystem())
        {
            return ::GetFileAttributesW(lpFileName);
        }
        else
        {
            return ::GetFileAttributesA(CSpToAnsiString<>(lpFileName));
        }
    }
    LONG RegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) const
    {
        if (UnicodeSystem())
        {
            return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        }
        else
        {
            return ::RegOpenKeyExA(hKey, CSpToAnsiString<>(lpSubKey), ulOptions, samDesired, phkResult);
        }
    }
    LONG RegCreateKeyEx(HKEY hk, LPCWSTR lpSubKey, DWORD dwReserved, LPCWSTR lpClass, DWORD dwOptions,
                        REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
                        LPDWORD lpdwDisposition) const
    {
        if (UnicodeSystem())
        {
            return ::RegCreateKeyExW(hk, lpSubKey, dwReserved, const_cast<WCHAR *>(lpClass), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        }
        else
        {
            return ::RegCreateKeyExA(hk, CSpToAnsiString<>(lpSubKey), dwReserved, CSpToAnsiString<>(lpClass), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        }
    }
    LONG RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey) const
    {
        if (UnicodeSystem())
        {
            return ::RegDeleteKeyW(hKey, lpSubKey);
        }
        else
        {
            return ::RegDeleteKeyA(hKey, CSpToAnsiString<>(lpSubKey));
        }
    }
    LONG RegDeleteValue(HKEY hKey, LPCWSTR lpSubKey) const
    {
        if (UnicodeSystem())
        {
            return ::RegDeleteValueW(hKey, lpSubKey);
        }
        else
        {
            return ::RegDeleteValueA(hKey, CSpToAnsiString<>(lpSubKey));
        }
    }
    //
    //  Use RegQueryStringValue for strings.  Use this for binary data.
    //
    LONG RegQueryValueEx(HKEY hk, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) const
    {
        if (UnicodeSystem())
        {
            return ::RegQueryValueExW(hk, lpValueName, NULL, lpType, lpData, lpcbData);
        }
        else
        {
            return ::RegQueryValueExA(hk, CSpToAnsiString<>(lpValueName), NULL, lpType, lpData, lpcbData);
        }
    }
    //
    //  NOTE:  The size parameter is in CHARACTERS!  Even though the registry API sizes are
    //         in bytes, this function uses character counts.
    //
    LONG RegQueryStringValue(HKEY hKey, LPCWSTR lpValueName, LPWSTR lpData, LPDWORD lpcchData) const
    {
        DWORD dwType;
        LONG rr;
        if (UnicodeSystem())
        {
            *lpcchData *= sizeof(WCHAR);
            rr = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (BYTE *)lpData, lpcchData);
            *lpcchData /= sizeof(WCHAR);
        }
        else
        {
            DWORD dwOrigCharCount = *lpcchData;
            char * pszScratch = lpData ? (char *)_alloca(dwOrigCharCount) : NULL;
            rr = ::RegQueryValueExA(hKey, CSpToAnsiString<>(lpValueName), NULL, &dwType, (BYTE *)pszScratch, lpcchData);
            if (lpData)
            {
                if (rr == ERROR_SUCCESS)
                {
                    DWORD dwReturnedChars = *lpcchData;
                    *lpcchData = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, dwReturnedChars, lpData, dwOrigCharCount);
                    if (*lpcchData == 0)
                    {
                        rr = ::GetLastError();
                        *lpcchData = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, dwReturnedChars, NULL, 0);
                    }
                }
            }
        }
        if (rr == ERROR_SUCCESS && dwType == REG_MULTI_SZ && lpData && *lpcchData)
        {
            // This is used by Whistler setup to overcome string size limits for REG_SZ.
            // Unfortunately, leaves a zero-byte inbetween concatenated strings.
            // Must remove these entries. Can do this in situ.
            LPWSTR lpTo   = lpData;
            LPWSTR lpFrom = lpData;
            while ( static_cast<UINT>(lpFrom-lpData) < ((*lpcchData)-1) )
            {
                if ( *lpFrom == 0 )
                {
                    lpFrom ++;
                }
                // This will copy the 2nd zero of a double null-terminated string.
                *lpTo = *lpFrom;
                lpTo ++;
                lpFrom ++;
            }
            if ( static_cast<UINT>(lpFrom-lpData) < (*lpcchData) )
            {
                // This will copy the final null-terminating byte of a single-zero terminated string.
                *lpTo = *lpFrom;
            }
            // Update character count to match new string including null-terminator.
            *lpcchData = static_cast<UINT>(lpTo-lpData) + 1;
        }
        SPDBG_ASSERT((rr != ERROR_SUCCESS) || (dwType == REG_SZ) || (dwType == REG_MULTI_SZ));
        return rr;
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumKeyEx, we chose to simply
    //         implement the ReqEnumKey functionality since the Ex functionality is not used
    //         by most programs (this saves a bunch of string conversion code).
    //
    LONG RegEnumKey(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        if (UnicodeSystem())
        {
            return ::RegEnumKeyExW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        }
        else
        {
            DWORD dwSize = *lpcchName;
            char * pszScratch = lpName ? (char *)_alloca(dwSize) : NULL;
            LONG rr = ::RegEnumKeyExA(hk, dwIndex, pszScratch, &dwSize, NULL, NULL, NULL, NULL);
            if (lpName)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpName, *lpcchName);
                    if (*lpcchName == 0)
                    {
                        *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                        rr = ::GetLastError();
                    }
                    *lpcchName *= sizeof(WCHAR);
                }
            }
            else
            {
                *lpcchName = dwSize;
            }
            return rr;
        }
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumValue
    //         it will only return the names, not the data.  cbValueName is the count of characters
    //
    LONG RegEnumValueName(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        if (UnicodeSystem())
        {
            return ::RegEnumValueW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        }
        else
        {
            DWORD dwSize = *lpcchName;
            char * pszScratch = lpName ? (char *)_alloca(dwSize) : NULL;
            LONG rr = ::RegEnumValueA(hk, dwIndex, pszScratch, &dwSize, NULL, NULL, NULL, NULL);
            if (lpName)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpName, *lpcchName);
                    if (*lpcchName == 0)
                    {
                        *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                        rr = ::GetLastError();
                    }
                    *lpcchName *= sizeof(WCHAR);
                }
            }
            else
            {
                *lpcchName = dwSize;
            }
            return rr;
        }
    }
    //
    //  Don't use this for strings.  Use RegSetStringValue instead.
    //
    LONG RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE * lpData, DWORD cbData) const
    {
        if (UnicodeSystem())
        {
            return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        }
        else
        {
            return ::RegSetValueExA(hKey, CSpToAnsiString<>(lpValueName), Reserved, dwType, lpData, cbData);
        }
    }
    LONG RegSetStringValue(HKEY hKey, LPCWSTR lpValueName, LPCWSTR lpData) const
    {
        LONG rr;
        DWORD dwSize = (wcslen(lpData)+1) * sizeof(WCHAR);
        if (UnicodeSystem())
        {
            rr = ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
        }
        else
        {
            char * pszScratch = (char *)_alloca(dwSize);
            dwSize = ::WideCharToMultiByte(CP_ACP, 0, lpData, -1, pszScratch, dwSize, NULL, NULL);
            rr = ::RegSetValueExA(hKey, CSpToAnsiString<>(lpValueName), NULL, REG_SZ, (BYTE *)pszScratch, dwSize);
        }
        return rr;
    }
    HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName) const
    {
        if (UnicodeSystem())
        {
            return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
        }
        else
        {
            return ::CreateEventA(lpEventAttributes, bManualReset, bInitialState, CSpToAnsiString<>(lpName)); 
        }
    }
    HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName) const
    {
        if (UnicodeSystem())
        {
            return ::CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
        }
        else
        {
            return ::CreateMutexA(lpMutexAttributes, bInitialOwner, CSpToAnsiString<>(lpName)); 
        }
    }
    int LoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBuffer) const
    {
        if (bUnicodeOnly)   // NOTE:  If the DLL is built ANSI then use ANSI load!
        {
            return ::LoadStringW(hInstance, uID, lpBuffer, nBuffer);
        }
        else
        {
            char * pszScratch = (char *)_alloca(nBuffer * 2);
            int r = ::LoadStringA(hInstance, uID, pszScratch, nBuffer * 2);
            if (r)
            {
                r = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpBuffer, nBuffer);
            }
            else
            {
                *lpBuffer = 0;
            }
            return r;
        }
    }
    HMODULE LoadLibrary( LPCWSTR lpLibFileName )
    {
        if ( UnicodeSystem() )
        {
            return ::LoadLibraryW( lpLibFileName );
        }
        else
        {
            return ::LoadLibraryA( CSpToAnsiString<>(lpLibFileName) );
        }
    }
    HMODULE LoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        if (UnicodeSystem())
        {
            return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags);
        }
        else
        {
            return ::LoadLibraryExA(CSpToAnsiString<>(lpLibFileName), hFile, dwFlags);
        }
    }
    HRSRC FindResourceEx(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
    {
        if (UnicodeSystem())
        {
            return ::FindResourceExW(hModule, lpType, lpName, wLanguage);
        }
        else
        {
            return ::FindResourceExA(hModule,
                                     HIWORD(lpType) ? CSpToAnsiString<>(lpType) : (const CHAR *) lpType,
                                     HIWORD(lpName) ? CSpToAnsiString<>(lpName) : (const CHAR *) lpName,
                                     wLanguage);
        }
    }
    DWORD GetModuleFileName(HMODULE hModule, LPWSTR lpFileName, DWORD nSize) const
    {
        if (UnicodeSystem())
        {
            return ::GetModuleFileNameW(hModule, lpFileName, nSize);
        }
        else
        {
            CHAR szFileName[MAX_PATH];
            DWORD r = ::GetModuleFileNameA(hModule, szFileName, sp_countof(szFileName));
            if (r)
            {
                r = ::MultiByteToWideChar(CP_ACP, 0, szFileName, r, lpFileName, nSize - 1);
                lpFileName[r] = 0;
            }
            return r;
        }
    }
    UINT GetSystemDirectory( LPWSTR lpBuffer, UINT uSize )
    {
        if (UnicodeSystem())
        {
            return ::GetSystemDirectoryW( lpBuffer, uSize );
        }
        else
        {
            CHAR szSystemDirectory[ MAX_PATH ];
            DWORD r = ::GetSystemDirectoryA(szSystemDirectory, sp_countof( szSystemDirectory ));
            if ( r )
            {
                r = ::MultiByteToWideChar( CP_ACP, 0, szSystemDirectory, r, lpBuffer, uSize - 1 );
                lpBuffer[r] = 0;
            }
            return r;
        }
    }
    DWORD SearchPath( LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart )
    {
        if (UnicodeSystem())
        {
            return ::SearchPathW( lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart );
        }
        else
        {
            CHAR szFoundFile[ MAX_PATH ];
            LPSTR lpaFilePart = NULL;
            LPSTR lpaPath = strdup( CSpToAnsiString<>(lpPath) );
            LPSTR lpaFileName = strdup( CSpToAnsiString<>(lpFileName) );

            DWORD r = ::SearchPathA( CSpToAnsiString<>(lpPath), CSpToAnsiString<>(lpFileName), 
                CSpToAnsiString<>(lpExtension), sp_countof( szFoundFile ), szFoundFile, &lpaFilePart );
            if ( r )
            {
                r = ::MultiByteToWideChar( CP_ACP, 0, szFoundFile, r, lpBuffer, nBufferLength - 1 );
                lpBuffer[r] = 0;
            }
            if ( r )
            {
                // Find out how many wide characters are in the file part
                int cchFilePartW = ::MultiByteToWideChar( CP_ACP, 0, lpaFilePart, 
                    strlen( szFoundFile ) - (lpaFilePart - szFoundFile),
                    NULL, 0 );
                *lpFilePart = lpBuffer + wcslen( lpBuffer ) - cchFilePartW;
            }

            if ( lpaPath )
            {
                free( lpaPath );
            }
            if ( lpaFileName )
            {
                free( lpaFileName );
            }

            return r;
        }
    }
    int CompareString(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2)
    {
        if (UnicodeSystem())
        {
            return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        }
        else
        {
            return ::CompareStringA(Locale, dwCmpFlags, CSpToAnsiString<>(lpString1), cchCount1, 
                                    CSpToAnsiString<>(lpString2), cchCount2);
        }
    }

    BOOL SetWindowText( HWND hWnd, LPCWSTR lpString )
    {
        if ( UnicodeSystem() )
        {
            return ::SetWindowTextW( hWnd, lpString );
        }
        else
        {
            return ::SetWindowTextA( hWnd, CSpToAnsiString<>(lpString) );
        }
    }

    BOOL SetDlgItemText(HWND hDlg, int nIDDlgItem, LPCWSTR lpString )
    {
        if ( UnicodeSystem() )
        {
            return ::SetDlgItemTextW( hDlg, nIDDlgItem, lpString );
        }
        else
        {
            return ::SetDlgItemTextA( hDlg, nIDDlgItem, CSpToAnsiString<>(lpString) );
        }
    }

    int MessageBox( HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType )
    {
        if ( UnicodeSystem() )
        {
            return ::MessageBoxW( hWnd, lpText, lpCaption, uType );
        }
        else
        {
            return ::MessageBoxA( hWnd, CSpToAnsiString<>(lpText), 
                CSpToAnsiString<>(lpCaption), uType );
        }   
    }

    int GetLocaleInfo( LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData )
    {
        if ( UnicodeSystem() )
        {
            return ::GetLocaleInfoW( Locale, LCType, lpLCData, cchData );
        }
        else
        {
            int cchNeeded = ::GetLocaleInfoA( Locale, LCType, NULL, 0 );

            CHAR *pszLCData = new CHAR[ cchNeeded ];
            int r = ::GetLocaleInfoA( Locale, LCType, pszLCData, cchNeeded );
            if ( r ) 
            {
                if ( lpLCData )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszLCData, r, lpLCData, cchData - 1);
                    lpLCData[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszLCData, r, NULL, 0 ) + 1;
                }
            }

            delete[] pszLCData;
            return r;
        }
    }

    int GetTimeFormat( LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime )
    {
        if ( UnicodeSystem() )
        {
            return ::GetTimeFormatW( Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime );
        }
        else
        {
            LPSTR lpaFormat = strdup( CSpToAnsiString<>(lpFormat) );

            int cchNeeded = ::GetTimeFormatA( Locale, dwFlags, lpTime, lpaFormat, NULL, 0 );

            CHAR *pszTime = new CHAR[ cchNeeded ];
            int r = ::GetTimeFormatA( Locale, dwFlags, lpTime, lpaFormat, pszTime, cchNeeded );
            if ( r ) 
            {
                if ( lpTimeStr )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszTime, r, lpTimeStr, cchTime - 1);
                    lpTimeStr[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszTime, r, NULL, 0 ) + 1;
                }
            }

            delete[] pszTime;

            if ( lpaFormat )
            {
                free( lpaFormat );
            }

            return r;
        }
    }

    int GetNumberFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST NUMBERFMTW *lpFormat,
        LPWSTR lpNumberStr, int cchNumber )
    {
        if ( UnicodeSystem() )
        {
            return ::GetNumberFormatW( Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber );
        }
        else
        {
            // Convert the NUMBERFMTW into a NUMBERFMTA
            NUMBERFMTA nmfmtA;
            nmfmtA.NumDigits = lpFormat->NumDigits;
            nmfmtA.LeadingZero = lpFormat->LeadingZero;
            nmfmtA.Grouping = lpFormat->Grouping;
            nmfmtA.NegativeOrder = lpFormat->NegativeOrder;
            nmfmtA.lpDecimalSep = strdup( CSpToAnsiString<>(lpFormat->lpDecimalSep) );
            nmfmtA.lpThousandSep = strdup( CSpToAnsiString<>(lpFormat->lpThousandSep) );

            LPSTR lpaValue = strdup( CSpToAnsiString<>(lpValue) );

            int cchNeeded = ::GetNumberFormatA( Locale, dwFlags, lpaValue, &nmfmtA, NULL, 0 );

            CHAR *pszNumber = new CHAR[ cchNeeded ];
            int r = ::GetNumberFormatA( Locale, dwFlags, lpaValue,
                &nmfmtA, pszNumber, cchNeeded );
            if ( r ) 
            {
                if ( lpNumberStr )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszNumber, r, lpNumberStr, cchNumber - 1);
                    lpNumberStr[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszNumber, r, NULL, 0 ) + 1;
                }
            }

            delete[] pszNumber;

            if ( nmfmtA.lpDecimalSep )
            {
                free( nmfmtA.lpDecimalSep );
            }
            if ( nmfmtA.lpThousandSep )
            {
                free( nmfmtA.lpThousandSep );
            }
            if ( lpaValue )
            {
                free( lpaValue );
            }

            return r;
        }
    }

    int GetCurrencyFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST CURRENCYFMTW *lpFormat, 
        LPWSTR lpCurrencyStr, int cchCurrency )
    {
        if ( UnicodeSystem() )
        {
            return ::GetCurrencyFormatW( Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, 
                cchCurrency );
        }
        else
        {
            // Convert the CURRENCYFMTW into a CURRENCYFMTA
            CURRENCYFMTA cyfmtA;
            cyfmtA.NumDigits = lpFormat->NumDigits;
            cyfmtA.LeadingZero = lpFormat->LeadingZero;
            cyfmtA.Grouping = lpFormat->Grouping;
            cyfmtA.NegativeOrder = lpFormat->NegativeOrder;
            cyfmtA.PositiveOrder = lpFormat->PositiveOrder;
            cyfmtA.lpDecimalSep = strdup( CSpToAnsiString<>(lpFormat->lpDecimalSep) );
            cyfmtA.lpThousandSep = strdup( CSpToAnsiString<>(lpFormat->lpThousandSep) );
            cyfmtA.lpCurrencySymbol = strdup( CSpToAnsiString<>(lpFormat->lpCurrencySymbol) );

            LPSTR lpaValue = strdup( CSpToAnsiString<>(lpValue) );

            int cchNeeded = ::GetCurrencyFormatA( Locale, dwFlags, lpaValue, &cyfmtA, NULL, 0 );

            CHAR *pszCurrency = new CHAR[ cchNeeded ];
            int r = ::GetCurrencyFormatA( Locale, dwFlags, lpaValue,
                &cyfmtA, pszCurrency, cchNeeded );
            if ( r ) 
            {
                if ( lpCurrencyStr )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszCurrency, r, lpCurrencyStr, cchCurrency - 1);
                    lpCurrencyStr[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszCurrency, r, NULL, 0 ) + 1;
                }
            }
            delete[] pszCurrency;

            if ( cyfmtA.lpDecimalSep )
            {
                free( cyfmtA.lpDecimalSep );
            }
            if ( cyfmtA.lpThousandSep )
            {
                free( cyfmtA.lpThousandSep );
            }
            if ( cyfmtA.lpCurrencySymbol )
            {
                free( cyfmtA.lpCurrencySymbol );
            }
            if ( lpaValue )
            {
                free( lpaValue );
            }

            return r;
        }

    }
    
    LONG_PTR GetWindowLongPtr( HWND hWnd, int nIndex )
    {
        if ( UnicodeSystem() )
        {
            return ::GetWindowLongPtrW( hWnd, nIndex );
        }
        else
        {
            return ::GetWindowLongPtrA( hWnd, nIndex );
        }
    }

    LONG_PTR SetWindowLongPtr( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
    {
        if ( UnicodeSystem() )
        {
            return ::SetWindowLongPtrW( hWnd, nIndex, dwNewLong );
        }
        else
        {
            return ::SetWindowLongPtrA( hWnd, nIndex, dwNewLong );
        }
    }

    INT_PTR DialogBoxParam( HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam )
    {
        if ( UnicodeSystem() )
        {
            return ::DialogBoxParamW( hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
        }
        else
        {
            return ::DialogBoxParamA( hInstance, (LPCTSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
        }
    }

    LRESULT SendDlgItemMessage(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam )
    {
        if ( UnicodeSystem() )
        {
            return ::SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam );
        }
        else
        {
            return ::SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam );
        }
    }

#ifdef __HTMLHELP_H__
    HWND WINAPI HtmlHelp( HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData )
    {
        if ( UnicodeSystem() )
        {
            return ::HtmlHelpW( hwndCaller, pszFile, uCommand, dwData );
        }
        else
        {
            return ::HtmlHelpA( hwndCaller, CSpToAnsiString<> (pszFile), uCommand, dwData );
        }
    }
#endif  // __HTMLHELP_H__

    BOOL GetUserName(LPWSTR lpBuffer, LPDWORD pnSize)
    {
        if (UnicodeSystem())
        {
            return ::GetUserNameW(lpBuffer, pnSize);
        }
        else
        {
            DWORD cchWideCharBuff = *pnSize;
            CHAR * psz = (CHAR *)_alloca(cchWideCharBuff * sizeof(CHAR)); 
            BOOL fWorked = ::GetUserNameA(psz, pnSize);
            if (fWorked)
            {
                *pnSize = ::MultiByteToWideChar(CP_ACP, 0, psz, -1, lpBuffer, cchWideCharBuff);
                if (*pnSize == 0)
                {
                    fWorked = FALSE;
                    *pnSize = ::MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
                }
            }
            return fWorked;
        }
    }

#if defined(mmioOpen)
    HMMIO mmioOpen(LPCWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags) const
    {
        if (UnicodeSystem())
        {
            return ::mmioOpenW((WCHAR *)szFileName, lpmmioinfo, dwOpenFlags);
        }
        else
        {
            return ::mmioOpenA(CSpToAnsiString<>(szFileName), lpmmioinfo, dwOpenFlags);
        }
    }
    MMRESULT waveOutGetDevCaps(UINT uDeviceId, LPWAVEOUTCAPSW pwoc, UINT cbwoc) const
    {
        // Some drivers overwrite the WAVEINCAPS buffer by a DWORD. So they probably do it for
        // WAVEOUTCAPS too
        MMRESULT mmr = MMSYSERR_NOERROR;
        if (UnicodeSystem())
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEOUTCAPSW) + sizeof(DWORD)];
            WAVEOUTCAPSW *pwocw = reinterpret_cast<WAVEOUTCAPSW *>(pBuffer);
            if (pwocw)
            {
                mmr = ::waveOutGetDevCapsW(uDeviceId, pwocw, cbwoc);
                if (mmr == MMSYSERR_NOERROR)
                {
                    *pwoc = *pwocw;
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        else
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEOUTCAPSA) + sizeof(DWORD)];
            WAVEOUTCAPSA *pwoca = reinterpret_cast<WAVEOUTCAPSA *>(pBuffer);
            if (pwoca)
            {
                mmr = ::waveOutGetDevCapsA(uDeviceId, pwoca, sizeof(*pwoca));
                if (mmr == MMSYSERR_NOERROR)
                {
                    pwoc->wMid = pwoca->wMid;
                    pwoc->wPid = pwoca->wPid;
                    pwoc->vDriverVersion = pwoca->vDriverVersion;
                    pwoc->dwFormats = pwoca->dwFormats;
                    pwoc->wChannels = pwoca->wChannels;
                    pwoc->wReserved1 = pwoca->wReserved1;
                    pwoc->dwSupport = pwoca->dwSupport;
                    ::MultiByteToWideChar(CP_ACP, 0, pwoca->szPname, -1, pwoc->szPname, sp_countof(pwoc->szPname));
                }
                else
                {
                    mmr = MMSYSERR_ERROR;
                }
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        return mmr;
    }
    MMRESULT waveInGetDevCaps(UINT uDeviceId, LPWAVEINCAPSW pwic, UINT cbwic) const
    {
        // Some drivers overwrite the WAVEINCAPS buffer by a DWORD
        MMRESULT mmr = MMSYSERR_NOERROR;
        if (UnicodeSystem())
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEINCAPSW) + sizeof(DWORD)];
            WAVEINCAPSW *pwicw = reinterpret_cast<WAVEINCAPSW *>(pBuffer);
            if (pwicw)
            {
                mmr = ::waveInGetDevCapsW(uDeviceId, pwicw, cbwic);
                if (mmr == MMSYSERR_NOERROR)
                {
                    *pwic = *pwicw;
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        else
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEINCAPSA) + sizeof(DWORD)];
            WAVEINCAPSA *pwica = reinterpret_cast<WAVEINCAPSA *>(pBuffer);
            if (pwica)
            {
                mmr = ::waveInGetDevCapsA(uDeviceId, pwica, sizeof(*pwica));
                if (mmr == MMSYSERR_NOERROR)
                {
                    pwic->wMid = pwica->wMid;
                    pwic->wPid = pwica->wPid;
                    pwic->vDriverVersion = pwica->vDriverVersion;
                    pwic->dwFormats = pwica->dwFormats;
                    pwic->wChannels = pwica->wChannels;
                    pwic->wReserved1 = pwica->wReserved1;
                    ::MultiByteToWideChar(CP_ACP, 0, pwica->szPname, -1, pwic->szPname, sp_countof(pwic->szPname));
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        return mmr;
    }
#endif  // defined(mmioOpen)
};

#ifdef _UNICODE
typedef CSpUnicodeSupportT<TRUE> CSpUnicodeSupport;
#else
typedef CSpUnicodeSupportT<FALSE> CSpUnicodeSupport;
#endif

#else //_WIN32_WCE

class CSpUnicodeSupport
{
public:
    HANDLE CreateFile(const WCHAR * lpFileName,      
                      DWORD dwDesiredAccess,       
                      DWORD dwShareMode,           
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes,  
                      HANDLE hTemplateFile) const         
    {
        return ::CreateFile(
                    lpFileName, 
                    dwDesiredAccess, 
                    dwShareMode, 
                    lpSecurityAttributes, 
                    dwCreationDisposition,                           
                    dwFlagsAndAttributes, 
                    hTemplateFile);
    }
    HANDLE CreateFileForMapping(const WCHAR * lpFileName,      
                                DWORD dwDesiredAccess,       
                                DWORD dwShareMode,           
                                LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                DWORD dwCreationDisposition, 
                                DWORD dwFlagsAndAttributes,  
                                HANDLE hTemplateFile) const         
    {
        return ::CreateFileForMappingW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition,
                                       dwFlagsAndAttributes, hTemplateFile);
    }
    DWORD GetFullPathName(WCHAR *lpFileName,  // file name
                          DWORD nBufferLength, // size of path buffer
                          WCHAR *lpBuffer,     // path buffer
                          WCHAR **lpFilePart   // address of file name in path
                          )
    {
        return ::GetFullPathName(lpFileName, nBufferLength, lpBuffer, lpFilePart);
    }
    BOOL DeleteFile(LPCWSTR lpFileName)
    {
        return ::DeleteFileW(lpFileName);
    }
    BOOL MoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
    {
        return ::MoveFileW(lpExistingFileName, lpNewFileName);
    }
    BOOL CopyFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
    {
        return ::CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
    }
    BOOL CreateDirectory(const WCHAR * lpPathName,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes) const
    {
        return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }
    BOOL RemoveDirectory(const WCHAR * lpPathName) const
    {
        return ::RemoveDirectoryW(lpPathName);
    }
    HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect,
                             DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const WCHAR *lpName)
    {
        return ::CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                    dwMaximumSizeLow, lpName);
    }
    BOOL SetFileAttributes(LPCWSTR lpFileName, DWORD dwFileAttributes)
    {
        return ::SetFileAttributesW(lpFileName, dwFileAttributes);
    }
    DWORD GetFileAttributes(LPCWSTR lpFileName)
    {
        return ::GetFileAttributesW(lpFileName);
    }
    LONG RegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && phkResult;
        LONG lRet = ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
#endif
    }
    LONG RegCreateKeyEx(HKEY hk, LPCWSTR lpSubKey, DWORD dwReserved, LPCWSTR lpClass, DWORD dwOptions,
                        REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
                        LPDWORD lpdwDisposition) const
    {
        return ::RegCreateKeyExW(hk, lpSubKey, dwReserved, (WCHAR *)lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
    }
    LONG RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpSubKey;
        LONG lRet = ::RegDeleteKeyW(hKey, lpSubKey);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegDeleteKeyW(hKey, lpSubKey);
#endif
    }
    LONG RegDeleteValue(HKEY hKey, LPCWSTR lpSubKey) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE);
        LONG lRet = ::RegDeleteValueW(hKey, lpSubKey);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegDeleteValueW(hKey, lpSubKey);
#endif
    }
    LONG RegQueryValueEx(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && ((lpData && lpcbData) || (!lpData && !lpcbData));
        LONG lRet = ::RegQueryValueExW(hKey, lpValueName, NULL, lpType, lpData, lpcbData);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegQueryValueExW(hKey, lpValueName, NULL, lpType, lpData, lpcbData);
#endif
    }
    //
    //  NOTE:  The size parameter is in CHARACTERS!  Even though the registry API sizes are
    //         in bytes, this function uses character counts.
    //
    LONG RegQueryStringValue(HKEY hKey, LPCWSTR lpValueName, LPWSTR lpData, LPDWORD lpcchData) const
    {
        DWORD dwType;
        *lpcchData *= sizeof(WCHAR);
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpData;
#endif
        LONG lRet = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (BYTE *)lpData, lpcchData);
        *lpcchData /= sizeof(WCHAR);
#ifdef _WIN32_WCE_BUG_10655
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return lRet;
#endif
    }
    //
    //  NOTES: Size is in bytes.  Although this function uses RegEnumKeyEx, we chose to simply
    //         implement the ReqEnumKey functionality since the Ex functionality is not used
    //         by most programs (this saves a bunch of string conversion code).
    //
    LONG RegEnumKey(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpName && lpcbName;
        LONG lRet = ::RegEnumKeyExW(hKey, dwIndex, lpName, lpcbName, NULL, NULL, NULL, NULL);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegEnumKeyExW(hKey, dwIndex, lpName, lpcbName, NULL, NULL, NULL, NULL);
#endif
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumValue
    //         it will only return the names, not the data.  cbValueName is the count of characters
    //
    LONG RegEnumValueName(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpName && lpcchName;
        LONG lRet = ::RegEnumValueW(hKey, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegEnumValueW(hKey, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
#endif
    }
    LONG RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE * lpData, DWORD cbData) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpData;
        LONG lRet = ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
#endif
    }
    LONG RegSetStringValue(HKEY hKey, LPCWSTR lpValueName, LPCWSTR lpData) const
    {
        DWORD dwSize = (wcslen(lpData)+1) * sizeof(WCHAR);
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpData;
        LONG lRet = ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
#endif
    }
    HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName) const
    {
        return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
    }
    HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName) const
    {
        return ::CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
    }
    int LoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBuffer) const
    {
        return ::LoadStringW(hInstance, uID, lpBuffer, nBuffer);
    }
    HMODULE LoadLibrary(LPCWSTR lpLibFileName)
    {
        return ::LoadLibraryW(lpLibFileName);
    }
    HMODULE LoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags);
    }
    HRSRC FindResource(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
    {
        return ::FindResource(hModule, lpName, lpType);
    }
    DWORD GetModuleFileName(HMODULE hModule, LPWSTR lpFileName, DWORD nSize) const
    {
        return ::GetModuleFileNameW(hModule, lpFileName, nSize);
    }
// WCE does not support GetSystemDirectory
#if 0
    UINT GetSystemDirectory( LPWSTR lpBuffer, UINT uSize )
    {
        return ::GetSystemDirectoryW( lpBuffer, uSize );
    }
#endif
    int CompareString(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2)
    {
        return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
    }
    BOOL SetWindowText( HWND hWnd, LPCWSTR lpString )
    {
        return ::SetWindowTextW( hWnd, lpString );
    }
    BOOL SetDlgItemText( HWND hDlg, int nIDDlgItem, LPCWSTR lpString )
    {
        return ::SetDlgItemTextW( hDlg, nIDDlgItem, lpString );
    }
    int MessageBox( HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType )
    {
        return ::MessageBoxW( hWnd, lpText, lpCaption, uType );
    }
    int GetLocaleInfo( LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData )
    {
        return ::GetLocaleInfoW( Locale, LCType, lpLCData, cchData );
    }
    int GetTimeFormat( LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime )
    {
        return ::GetTimeFormatW( Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime );
    }
    int GetNumberFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST NUMBERFMTW *lpFormat,
        LPWSTR lpNumberStr, int cchNumber )
    {
        return ::GetNumberFormatW( Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber );
    int GetCurrencyFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST CURRENCYFMTW *lpFormat, 
        LPWSTR lpCurrencyStr, int cchCurrency )
    {
        return ::GetCurrencyFormatW( Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency );
    }
    LONG_PTR GetWindowLongPtr( HWND hWnd, int nIndex )
    {
        return ::GetWindowLongPtr( hWnd, nIndex );
    }
    LONG_PTR SetWindowLongPtr( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
    {
        return ::SetWindowLongPtr( hWnd, nIndex, dwNewLong );
    }
    INT_PTR DialogBoxParamCE( HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam )
    {
        return ::DialogBoxParamW( hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
    }
    LRESULT SendDlgItemMessage(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam )
    {
        return ::SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam );
    }

#ifdef __HTMLHELP_H__
    HWND WINAPI HtmlHelp( HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData )
    {
        return HtmlHelpW( hwndCaller, pszFile, uCommand, dwData );
    }
#endif  // __HTMLHELP_H__
    HMMIO mmioOpen(LPCWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags) const
    {
        return ::mmioOpenW((WCHAR *)szFileName, lpmmioinfo, dwOpenFlags);
    }
    MMRESULT waveOutGetDevCaps(UINT uDeviceId, LPWAVEOUTCAPS pwoc, UINT cbwoc) const
    {
        return ::waveOutGetDevCaps(uDeviceId, pwoc, cbwoc);
    }
    MMRESULT waveInGetDevCaps(UINT uDeviceId, LPWAVEINCAPS pwic, UINT cbwic) const
    {
        return ::waveInGetDevCaps(uDeviceId, pwic, cbwic);
    }
};

#endif


//
//  Assume a global named g_Unicode
//
extern CSpUnicodeSupport g_Unicode;


#endif      // Must be the last line of file. (#ifdef __SPUNICODE_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\sptrycritsec.h ===
class CTryableCriticalSection
{
    public:

        CTryableCriticalSection();
        ~CTryableCriticalSection();

    public:

        void Lock();
        void Unlock();
        BOOL TryLock();

    private:

        BOOL TryLockPrivate(BOOL fTakeAlways);

    private:

        CRITICAL_SECTION    m_csInner;
        CRITICAL_SECTION    m_csOuter;
        LONG                m_cRefs;
};

inline CTryableCriticalSection::CTryableCriticalSection()
{
    InitializeCriticalSection(&m_csInner);
    InitializeCriticalSection(&m_csOuter);
    m_cRefs = 0;
}

inline CTryableCriticalSection::~CTryableCriticalSection()
{
    DeleteCriticalSection(&m_csOuter);
    DeleteCriticalSection(&m_csInner);
}

inline void CTryableCriticalSection::Lock()
{
    TryLockPrivate(TRUE);
}

inline void CTryableCriticalSection::Unlock()
{
    LeaveCriticalSection(&m_csInner);

    InterlockedDecrement(&m_cRefs);
}

inline BOOL CTryableCriticalSection::TryLock()
{
    return TryLockPrivate(FALSE);
}

inline BOOL CTryableCriticalSection::TryLockPrivate(BOOL fTakeAlways)
{
    BOOL fLocked = FALSE;
    
    EnterCriticalSection(&m_csOuter);

    if (fTakeAlways || !m_cRefs)
    {
        fLocked = TRUE;
        InterlockedIncrement(&m_cRefs);

        EnterCriticalSection(&m_csInner);
    }

    LeaveCriticalSection(&m_csOuter);

    return fLocked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\stringblob.h ===
/*******************************************************************************
* StringBlob.h *
*--------------*
*   Description:
*       This is the header file for the CStringBlob class used internally by SAPI.
*
*   Copyright 1998-2000 Microsoft Corporation All Rights Reserved.
*
*******************************************************************************/

#ifndef _STRINGBLOB_H_
#define _STRINGBLOB_H_ 1

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#include <math.h>

template <class XCHAR>
class CStringBlobT
{
    XCHAR *     m_pData;            // List of words, end-to-end
    ULONG       m_cchAllocated;     // Size of m_pData
    ULONG *     m_aichWords;        // Word index => offset in m_pData  [1] is index of start of second word
    ULONG       m_cwords;           // Number of words
    ULONG       m_cwordsAllocated;  // Size of m_aichWords
    ULONG *     m_aulBuckets;       // Hash table containing indices of words or 0 for empty buckets
    ULONG       m_cBuckets;         // Number of buckets in hash table

public:
    CStringBlobT()
    {
        m_pData = NULL;
        m_cchAllocated = 0;
        m_aichWords = NULL;
        m_cwords = 0;
        m_cwordsAllocated = 0;
        m_aulBuckets = NULL;
        m_cBuckets = 0;
    }

    ~CStringBlobT()
    {
        Clear();
    }

    void Detach(XCHAR **ppszWordList, ULONG *pulSize)
    {
        *ppszWordList = NULL;
        if (m_pData)
        {
            ULONG cchDesired = StringSize();
            ULONG cbSize = SerializeSize(); // byte count, ULONG multiple

            *ppszWordList = (XCHAR*)::CoTaskMemRealloc(m_pData, cbSize);
            if (*ppszWordList == NULL)
            {
                *ppszWordList = m_pData;
                cbSize = m_cchAllocated * sizeof(XCHAR);
            }
            m_pData = NULL;

            Clear();

            if (pulSize)
            {
                *pulSize = cbSize;
            }
        }
    }

    void Clear()
    {
        if (m_pData)
        {
            ::CoTaskMemFree(m_pData);
            m_pData = NULL;
        }
        m_cchAllocated = 0;

        free(m_aichWords);
        m_aichWords = NULL;
        m_cwordsAllocated = 0;
        m_cwords = 0;

        free(m_aulBuckets);
        m_aulBuckets = NULL;
        m_cBuckets = 0;
    }

    HRESULT InitFrom(const XCHAR * pszStringArray, ULONG cch)
    {
        SPDBG_ASSERT(m_pData == NULL);

        if (cch)
        {
            ULONG cbSize = (cch * sizeof(XCHAR) + 3) & ~3;
            m_pData = (XCHAR *)::CoTaskMemAlloc(cbSize);
            if (m_pData == NULL)
                return E_OUTOFMEMORY;
            m_cchAllocated = cch;

            SPDBG_ASSERT(pszStringArray[0] == 0);   // First string is always empty.

            // First pass to copy data and count strings.
            const XCHAR * pszPastEnd = pszStringArray + cch;
            const XCHAR * psz = pszStringArray;
            XCHAR * pszOut = m_pData;
            ULONG cwords = 0;

            while (psz < pszPastEnd)
            {
                if ((*pszOut++ = *psz++) == 0)
                    ++cwords;
            }

            m_aichWords = (ULONG *) malloc(sizeof(ULONG) * cwords);
            if (m_aichWords == NULL)
                return E_OUTOFMEMORY;
            m_cwordsAllocated = cwords;
            m_cwords = cwords - 1;  // Doesn't count leading 0

            HRESULT hr = SetHashSize(cwords * 2 + 1);
            if (FAILED(hr))
                return hr;

            // Second pass to fill in indices and hash table.
            psz = pszStringArray + 1;
            const WCHAR * pszWordStart = psz;
            ULONG ulID = 1;
            m_aichWords[0] = 1;
            while (psz < pszPastEnd)
            {
                if (*(psz++) == 0)
                {
                    SPDBG_ASSERT(ulID < m_cwordsAllocated);

                    m_aichWords[ulID] = (ULONG)(psz - pszStringArray); // can't have more than 4 million chars!
                
                    m_aulBuckets[FindIndex(pszWordStart)] = ulID;

                    pszWordStart = psz;
                    ++ulID;
                }
            }
        }

        return S_OK;
    }
    
    ULONG HashKey(const XCHAR * pszString, ULONG * pcchIncNull = NULL)
    {
        ULONG hash = 0;
        ULONG cchIncNull = 1;   // one for the NULL

	    for (const XCHAR * pch = pszString; *pch; ++pch, ++cchIncNull)
            hash = hash * 65599 + *pch;

        if (pcchIncNull)
            *pcchIncNull = cchIncNull;
        return hash;
    }

    // find index for string -- returns 0 if not found
    ULONG FindIndex(const XCHAR * psz)
    {
        SPDBG_ASSERT(psz);
        ULONG cchIncNull;
        ULONG start = HashKey(psz, &cchIncNull) % m_cBuckets;
        ULONG index = start;

        do
        {
            // Not in table; return index where it should be placed.
            if (m_aulBuckets[index] == 0)
                return index;

            // Compare length and if it matches compare full string.
            if (m_aichWords[m_aulBuckets[index]] - m_aichWords[m_aulBuckets[index] - 1] == cchIncNull &&
                IsEqual(m_aichWords[m_aulBuckets[index] - 1], psz))
            {
                // Found this word already in the table.
                return index;
            }

            if (++index >= m_cBuckets)
                index -= m_cBuckets;
        } while (index != start);

        SPDBG_ASSERT(m_cwords == m_cBuckets);   // Shouldn't ever get here

        return (ULONG) -1;
    }


    // Returns ID; use IndexFromId to recover string offset
    ULONG Find(const XCHAR * psz)
    {
        if (psz == NULL || m_cwords == 0)
            return 0;

        // Should always succeed in finding a bucket, since hash table is >2x larger than # of elements.
        ULONG   ibucket = FindIndex(psz);
        return m_aulBuckets[ibucket];    // May be 0 if not in table
    }


    ULONG primeNext(ULONG val)
    {
        if (val < 2)
            val = 2; /* the smallest prime number */

        for (;;)
        {
            /* Is val a prime number? */
            ULONG maxFactor = (ULONG) sqrt ((double) val);

            /* Is i a factor of val? */
            for (ULONG i = 2; i <= maxFactor; i++)
                if (val % i == 0)
                    break;

            if (i > maxFactor)
                return (val);

            val++;
        }
    }


    HRESULT SetHashSize(ULONG cbuckets)
    {
        if (cbuckets > m_cBuckets)
        {
            ULONG * oldtable = m_aulBuckets;
            ULONG oldentry = m_cBuckets;
            ULONG prime = primeNext(cbuckets);

            // Alloc new table.
            m_aulBuckets = (ULONG *) malloc(prime * sizeof(ULONG));
            if (m_aulBuckets == NULL)
            {
                m_aulBuckets = oldtable;
                return E_OUTOFMEMORY;
            }

            for (ULONG i=0; i < prime; i++)
            {
                m_aulBuckets[i] = 0;
            }

            m_cBuckets = prime;

            for (i = 0; i < oldentry; i++)
            {
                if (oldtable[i] != 0)
                {
                    ULONG ibucket = FindIndex(m_pData + m_aichWords[oldtable[i] - 1]);
                    m_aulBuckets[ibucket] = oldtable[i];
                }
            }

            free(oldtable);
        }

        return S_OK;
    }


    //
    //  The ID for a NULL string is always 0, the ID for subsequent strings is the
    //  index of the string + 1;
    //
    HRESULT Add(const XCHAR * psz, ULONG * pichOffset, ULONG *pulID = NULL)
    {
        ULONG   ID = 0;

        if (psz)
        {
            // Grow if we're more than half full.
            if (m_cwords * 2 >= m_cBuckets)
            {
                HRESULT hr = SetHashSize(m_cwords * 3 + 17);
                if (FAILED(hr))
                    return hr;
            }

            // Find out where this element should end up in hash table.
            ULONG ibucket = FindIndex(psz);

            if (m_aulBuckets[ibucket] == 0)
            {
                // Not found in hash table.  Append it to the end.

                // Grow ID=>index mapping array if necessary.
                if (m_cwords + 1 >= m_cwordsAllocated)  // 1 extra for init. zero
                {
                    void * pvNew = realloc(m_aichWords, sizeof(*m_aichWords) * (m_cwords + 100));
                    if (pvNew == NULL)
                        return E_OUTOFMEMORY;
                    m_aichWords = (ULONG *)pvNew;
                    m_cwordsAllocated = m_cwords + 100;
                    m_aichWords[0] = 1;
                }

                // Grow string storage if necessary.
                ULONG   cchIncNull = xcslen(psz);
                if (m_aichWords[m_cwords] + cchIncNull > m_cchAllocated)
                {
                    ULONG cbDesired = ((m_cchAllocated + cchIncNull) * sizeof(XCHAR) + 0x2003) & ~3;
                    void * pvNew = ::CoTaskMemRealloc(m_pData, cbDesired);
                    if (pvNew == NULL)
                    {
                        return E_OUTOFMEMORY;
                    }
                    m_pData = (XCHAR *)pvNew;

                    m_pData[0] = 0;
                    m_cchAllocated = cbDesired / sizeof(XCHAR);
                }
                memcpy(m_pData + m_aichWords[m_cwords], psz, cchIncNull * sizeof(XCHAR));

                ++m_cwords;

                m_aichWords[m_cwords] = m_aichWords[m_cwords - 1] + cchIncNull;

                // Fill in hash table entry with index of string.
                m_aulBuckets[ibucket] = m_cwords;

                ID = m_cwords;
            }
            else
            {
                // It was already there.
                ID = m_aulBuckets[ibucket];
            }
        }

        *pichOffset = ID ? m_aichWords[ID - 1] : 0;
        if (pulID)
        {
            *pulID = ID;
        }
        return S_OK;        
    }

    const ULONG GetNumItems() const
    {
        return m_cwords;
    }

    const XCHAR * String(ULONG ichOffset) const
    {
        return ichOffset ? m_pData + ichOffset : NULL;
    }

    static int xcscmp(const WCHAR * p0, const WCHAR * p1)
    {
        return wcscmp(p0, p1);
    }

    static int xcscmp(const char * p0, const char * p1)
    {
        return strcmp(p0, p1);
    }

    static int xcslen(const WCHAR * p)
    {
        return wcslen(p) + 1;
    }

    static int xcslen(const char * p)
    {
        return strlen(p) + 1;
    }

    BOOL IsEqual(ULONG ichOffset, const XCHAR * psz)
    {
        if (ichOffset)
        {
            return (psz ? (xcscmp(m_pData + ichOffset, psz) == 0) : FALSE);
        }
        else
        {
            return (psz == NULL);
        }
    }

    ULONG StringSize(void) const
    {
        return m_cwords ? m_aichWords[m_cwords] : 0;
    }

    ULONG IndexFromId(ULONG ulID) const
    {
        SPDBG_ASSERT(ulID <= m_cwords);
        if (ulID > 0)
        {
            return m_aichWords[ulID - 1];
        }
        return 0;
    }

    const XCHAR * Item(ULONG ulID) const
    {
        SPDBG_ASSERT(ulID <= m_cwords);
        if ((ulID < 1) || m_pData == NULL)
        {
            return NULL;
        }

        return m_pData + IndexFromId(ulID);
    }
    
    ULONG SerializeSize() const 
    {
        return (StringSize() * sizeof(XCHAR) + 3) & ~3;
    }

    const XCHAR * SerializeData()
    {
        ULONG cchWrite = StringSize();
        if (cchWrite)
        {
            const ULONG cb = cchWrite * sizeof(XCHAR);

            if (cb % 4)  // We know there's room since data is always DWORD aligned by
            {
                memset(m_pData + cchWrite, 0xcc, 4 - (cb & 3)); // Junk data so make sure it's not null
            }
        }
        return m_pData;
    }
};


typedef class CStringBlobT<WCHAR> CStringBlob;
typedef class CStringBlobT<WCHAR> CStringBlobW;
typedef class CStringBlobT<char>  CStringBlobA;

#endif  // _STRINGBLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\ltscart.cpp ===
/*******************************************************************************
* LtsCart.cpp *
*----------*
*
*   ** WARNING **
*   CART code for LTS. This code was created in MS Research and LiJ owns
*   the algorithm. YunusM eliminated the private heap used by this code
*   and used the new and delete operators instead.
*
*   Created By: LIJ (MS Research)                           Date: 06/18/99
*   Current Owner: Fil
*
*   Copyright (C) 1999 Microsoft Corporation. All Rights Reserved
*******************************************************************************/

//--- Includes --------------------------------------------------------------

#include "StdAfx.h"
#include "LtsCart.h"

#pragma warning(disable : 4100)

/* the following are for exceptions: single letter and NULL output */
static const char *bogus_pron_1033 = "B OW G AH S P R AH N AH N S IY EY SH AH N";
static const char *bogus_pron_1041 = "N A N I"; // what?

static const char *single_letter_pron_1033[52] =
{
    "EY",
    "B IY",
    "S IY",
    "D IY",
    "IY",
    "EH F",
    "JH IY",
    "EY CH",
    "AY",
    "JH EY",
    "K EY",
    "EH L",
    "EH M",
    "EH N",
    "OW",
    "P IY",
    "K Y UW",
    "AA R",
    "EH S",
    "T IY",
    "Y UW",
    "V IY",
    "D AH B AX L Y UW",
    "EH K S",
    "W AY",
    "Z IY",
    //
    // PLURAL SPELLINGS
    //
    "EY Z",
    "B IY Z",
    "S IY Z",
    "D IY Z",
    "IY Z",
    "EH F S",
    "JH IY Z",
    "EY CH AX Z",
    "AY Z",
    "JH EY Z",
    "K EY Z",
    "EH L Z",
    "EH M Z",
    "EH N Z",
    "OW Z",
    "P IY Z",
    "K Y UW Z",
    "AA R Z",
    "EH S AX Z",
    "T IY Z",
    "Y UW Z",
    "V IY Z",
    "D AH B AX L Y UW Z",
    "EH K S AX Z",
    "W AY Z",
    "Z IY Z"
};
static const char *single_letter_pron_1041[52] =
{
    "EE",
    "B II",
    "SH II",
    "D II",
    "II",
    "E H U",
    "J II",
    "EE CH I",
    "A I",
    "J EE",
    "K EE",
    "E R U",
    "E M U",
    "E N U",
    "OO",
    "P II",
    "K Y UU",
    "AA R U",
    "E S U",
    "T II",
    "Y UU",
    "B U I",
    "D A B U R Y UU",
    "E STOP K U S U",
    "W A I",
    "Z E STOP T O",
    //
    // PLURAL SPELLINGS
    //
    "EE Z U",
    "B II Z U",
    "SH II Z U",
    "D II Z U",
    "II Z U",
    "E H U Z U",
    "J II Z U",
    "EE CH I Z U",
    "A I Z U",
    "J EE Z U",
    "K EE Z U",
    "E R U Z U",
    "E M U Z U",
    "E N U Z U",
    "OO Z U",
    "P II Z U",
    "K Y UU Z U",
    "AA R U Z U",
    "E S U Z U",
    "T II Z U",
    "Y UU Z U",
    "B U I Z U",
    "D A B U R Y UU Z U",
    "E STOP K U S U Z U",
    "W A I Z U",
    "Z E STOP T O Z U"
};


/*
* not worthwhile to use binary search with only about 30 entries
*/
static int symbol_to_id(LTS_SYMTAB *tab, char *sym)
{
    USES_CONVERSION;
    SPDBG_FUNC("symbol_to_id");

    int i;
    for (i = 0; i < tab->n_symbols; i++)
    {
        if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            A2T(tab->storage + tab->sym_idx[i]), -1, A2T(sym), -1))
        {
            return i;
        }
    }
    return NO_SYMBOL;
} // static int symbol_to_id(LTS_SYMTAB *tab, char *sym)


static char *id_to_symbol(LTS_SYMTAB *tab, int id)
{
    SPDBG_FUNC("id_to_symbol");

    if (id < 0 || id > tab->n_symbols)
    {
        return NULL;
    }
    else
    {
        return tab->storage + tab->sym_idx[id];
    }
} // static char *id_to_symbol(LTS_SYMTAB *tab, int id)


__inline void ODS (const char *format, ...)
{
#ifdef _DEBUG
    SPDBG_FUNC("ODS");

    va_list arglist;
    va_start (arglist, format);

    char buf[2048];
    _vsnprintf(buf, 2048, format, arglist);
    OutputDebugStringA(buf);

    va_end (arglist);
#endif
}

__inline int ans_simp_question (LTS_FEATURE *feat, SIMPLE_QUESTION question,
                                LTS_SAMPLE *sample)
{
    SPDBG_FUNC("ans_simp_question");

    SYMBOL id;
    int *phones = feat[question.questype].feature[question.feature];

    SAMPLE_GET_CONTEXT(sample, question.questype, question.context,
        question.offset, id);

    return (TST_BIT(phones, id) ? TRUE : FALSE);
} // __inline int ans_simp_question (LTS_FEATURE *feat, SIMPLE_QUESTION question,


static int product_eval (LTS_FEATURE *feat, char *term, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("product_eval");

    int negate, result;
    SIMPLE_QUESTION ques;
    char *cptr;

    cptr = term;
    while (TRUE)
    {
        /* negation sign */
        if (*cptr == '~')
        {
            negate = TRUE;
            cptr++;
        }
        else
        {
            negate = FALSE;
        }

        if (!isdigit(*cptr))
        {
            //quit (-1, "Invalid product in product_eval\n");
            //      OutputDebugString("Invalid product in product_eval\n");
            return FALSE;
        }

        for (result = *cptr++ - '0'; isdigit (*cptr); cptr++)
        {
            result = result * 10 + (*cptr - '0');
        }

        QUES_DECODE(result, ques.questype, ques.context, ques.offset,
            ques.feature);
        if ((negate ^ ans_simp_question (feat, ques, sample)) == FALSE)
        {
            return FALSE;
        }

        if (*cptr == '\0')
        {
            break;
        }
        if (*cptr++ != '&')
        {
            //quit (-1, "product_eval:  syntax error in product term %s\n", term);
            /*
            char szTemp[512];

              sprintf(szTemp, "product_eval:  syntax error in product term %s\n", term);
              OutputDebugString(szTemp);
            */
            return FALSE;
        }
    }

    return TRUE;
} // static int product_eval (LTS_FEATURE *feat, char *term, LTS_SAMPLE *sample)


static int ans_comp_question(LTS_FEATURE *feat, char *prod,
                             LTS_SAMPLE *sample)
{
    SPDBG_FUNC("ans_comp_question");

    int i, num_products, limit;
    char *cptr, string[LONGEST_STR], *products[MAX_PRODUCTS];

    strcpy(string, prod);
    for (cptr = string, num_products = 1; *cptr != '\0'; cptr++)
    {
        if (*cptr == '|') num_products++;
    }

    if (num_products > MAX_PRODUCTS)
    {
        //quit(1, "please increase MAX_PRODUCTS up to %d at least\n", num_products);

        /*
        char szTemp[256];
        sprintf(szTemp, "please increase MAX_PRODUCTS up to %d at least\n", num_products);
        OutputDebugString(szTemp);
        */

        return FALSE;
    }

    for (i = 0, limit = num_products -1, cptr = string; ; i++)
    {
        products[i] = cptr++;
        if (i == limit)
        {
            break;
        }

        for (; *cptr != '|'; cptr++) {};
        *cptr++ = '\0';
    }

    for (i = 0; i < num_products; i++)
    {
        if (product_eval (feat, products[i], sample) == TRUE)
        {
            return TRUE;
        }
    }

    return FALSE;
} // static int ans_comp_question(LTS_FEATURE *feat, char *prod,


static T_NODE *find_leaf(LTS_FEATURE *feat, T_NODE *root, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("find_leaf");

    if (!root->yes_child)
    {
        return root;
    }
    else if (ans_comp_question(feat, root->prod, sample))
    {
        return find_leaf(feat, root->yes_child, sample);
    }
    else
    {
        return find_leaf(feat, root->no_child, sample);
    }
} // static T_NODE *find_leaf(LTS_FEATURE *feat, T_NODE *root, LTS_SAMPLE *sample)


static int lts_product_eval (LTS_FEATURE *feat, LTS_PROD *term,
                             LTS_SAMPLE *sample, LTS_PROD **next)
{
    SPDBG_FUNC("lts_product_eval");

    int negate, result;
    SIMPLE_QUESTION ques;
    LTS_PROD *cptr = term;

    while (TRUE)
    {
        if ((*cptr) & PROD_NEG)
        {
            negate = TRUE;
            result = (*cptr) ^ PROD_NEG;
        }
        else
        {
            negate = FALSE;
            result = (*cptr);
        }

        QUES_DECODE(result, ques.questype, ques.context, ques.offset,
            ques.feature);
        if ((negate ^ ans_simp_question (feat, ques, sample)) == FALSE)
        {
            while (*cptr != PROD_TERM && *cptr != QUES_TERM)
            {
                cptr++;
            }
            if (*cptr == QUES_TERM)
            {
                *next = NULL;
            }
            else
            {
                *next = cptr + 1;
            }
            return FALSE;
        }

        cptr++;
        if (*cptr == QUES_TERM)
        {
            *next = NULL;
            break;
        }
        else if (*cptr == PROD_TERM)
        {
            *next = cptr + 1;
            break;
        }
    }

    return TRUE;
} // static int lts_product_eval (LTS_FEATURE *feat, LTS_PROD *term,


static int lts_ans_comp_question(LTS_TREE UNALIGNED *tree, LTS_FEATURE *feat,
                                 int idx, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("lts_ans_comp_question");

    LTS_PROD *next, *term = (LTS_PROD *) ((char *) tree->p_prod + idx);

    while (TRUE)
    {
        if (lts_product_eval (feat, term, sample, &next) == TRUE)
        {
            return TRUE;
        }
        if (next == NULL)
        {
            break;
        }
        term = next;
    }

    return FALSE;
} // static int lts_ans_comp_question(LTS_TREE *tree, LTS_FEATURE *feat,


static LTS_NODE *lts_find_leaf(LTS_TREE UNALIGNED *tree, LTS_FEATURE *feat,
                               LTS_NODE *root, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("lts_find_leaf");

    if (IS_LEAF_NODE(root))
    {
        return root;
    }
    else if (lts_ans_comp_question(tree, feat, ((LTS_NODE UNALIGNED *)root)->idx, sample))
    {
        return lts_find_leaf(tree, feat, root + ((LTS_NODE UNALIGNED *)root)->yes, sample);
    }
    else
    {
        return lts_find_leaf(tree, feat, root + ((LTS_NODE UNALIGNED *)root)->yes + 1, sample);
    }
} // static LTS_NODE *lts_find_leaf(LTS_TREE *tree, LTS_FEATURE *feat,


static LTS_DIST *lts_find_leaf_count(LTS_FOREST *l_forest, SYMBOL *pIn,
                                     SYMBOL *pOut)
{
    SPDBG_FUNC("lts_find_leaf_count");

    LTS_TREE UNALIGNED *tree = l_forest->tree[*pIn];
    LTS_NODE UNALIGNED *leaf;
    LTS_SAMPLE sample;

    /*
    * construct a sample in order to share all the code with training
    */
    sample.pIn = pIn;
    sample.pOut = pOut;

    /* *pOut cannot be NULL_SYMBOL_ID */
    *pOut = NULL_SYMBOL_ID + 1;

    leaf = lts_find_leaf(tree, l_forest->features, &(tree->nodes[0]), &sample);
    return (LTS_DIST *) ((char *)tree->p_dist + leaf->idx);
} // static LTS_DIST *lts_find_leaf_count(LTS_FOREST *l_forest, SYMBOL *pIn,

static LTS_OUT_RESULT *allocate_out_result(LTS_FOREST *l_forest)
{
    SPDBG_FUNC("allocate_out_result");

    LTS_OUT_RESULT *res = new LTS_OUT_RESULT;
    if (res)
    {
        res->out_strings = new LTS_OUT_STRING *[MAX_ALT_STRINGS];
        if (res->out_strings)
        {
            res->num_allocated_strings = MAX_ALT_STRINGS;
            res->num_strings = 0;
        }
        else
        {
            delete res;
            res = NULL;
        }
    }

    return res;
} // static LTS_OUT_RESULT *allocate_out_result(LTS_FOREST *l_forest)

static void free_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res)
{
    SPDBG_FUNC("free_out_result");

    int i;

    for (i = 0; i < res->num_strings; i++)
    {
        delete res->out_strings[i];
    }
    if (res->num_allocated_strings == MAX_ALT_STRINGS)
    {
        delete res->out_strings;
    }
    else
    {
        free(res->out_strings);  /* dirty */
    }

    delete res;
} // static void free_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res)


static bool reallocate_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,
                                  int min)
{
    SPDBG_FUNC("reallocate_out_result");

    int s = res->num_allocated_strings, old_size = s;
    LTS_OUT_STRING **p;

    while (s < min)
        s += INC_ALT_STRINGS;
    p = res->out_strings;

    res->out_strings = (LTS_OUT_STRING **)
        calloc(s, sizeof(LTS_OUT_STRING *));
    if (!res->out_strings)
    {
        return false;
    }

    memcpy(res->out_strings, p, old_size * sizeof(LTS_OUT_STRING *));

    if (old_size == MAX_ALT_STRINGS)
    {
        delete p;
    }
    else
    {
        free(p);
    }

    res->num_allocated_strings = s;
    ODS("increased out_strings to %d in order to meet %d\n", s, min);

    return true;
} // static void reallocate_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,


static bool grow_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,
                            SYMBOL i, int count, float inv_sum,
                            LTS_OUT_RESULT *tmpRes)
{
    SPDBG_FUNC("grow_out_result");

    int j;

    if (res->num_strings + tmpRes->num_strings >= res->num_allocated_strings)
    {
        if (!reallocate_out_result(l_forest, res,
            res->num_strings + tmpRes->num_strings))
        {
            return false;
        }
    }
    for (j = 0; j < tmpRes->num_strings; j++)
    {
        SYMBOL *psrc = tmpRes->out_strings[j]->psym;
        SYMBOL *ptgt;
        res->out_strings[res->num_strings + j] = new LTS_OUT_STRING;
        if (!res->out_strings)
        {
            return false;
        }

        ptgt = res->out_strings[res->num_strings + j]->psym;
        *ptgt++ = i;
        while (*psrc != NULL_SYMBOL_ID)
        {
            *ptgt++ = *psrc++;
        }
        *ptgt++ = NULL_SYMBOL_ID;
        res->out_strings[res->num_strings + j]->prob = count * inv_sum *
            tmpRes->out_strings[j]->prob;
    }
    res->num_strings += tmpRes->num_strings;
    free_out_result(l_forest, tmpRes);

    return true;
} // static void grow_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,


static LTS_OUT_RESULT *gen_one_output(LTS_FOREST *l_forest, int len,
                                      SYMBOL *input_id, int in_index,
                                      SYMBOL *output_id, float cutoff)
{
    SPDBG_FUNC("gen_one_output");

    SYMBOL out[SP_MAX_WORD_LENGTH], *pOut;
    LTS_OUT_RESULT *res = allocate_out_result(l_forest);
    if (!res)
    {
        return NULL;
    }

    int sum, i, dim;
    LTS_DIST UNALIGNED *pdf;
    LTS_PAIR UNALIGNED *l_pair, *lp;
    float cut, inv_sum;

    /*
    * copy output_id to local
    */
    SYMBOL *psrc = output_id - 1, *ptgt = out;
    while (*psrc != NULL_SYMBOL_ID) psrc--;
    while (psrc != output_id)
        *ptgt++ = *psrc++;
    pOut = ptgt;
    /* sanity check */
    if (pOut - out != in_index + 1)
    {
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        int *z=0;
        z[0]=z[1];
    }

    if (in_index == len - 1)
    {
        pdf = lts_find_leaf_count(l_forest, input_id + in_index, pOut);
        l_pair = &(pdf->p_pair);
        dim = pdf->c_dists;
        for (lp = l_pair, sum = 0, i = 0; i < dim; i++, lp++)
        {
            sum += lp->cnt;
        }
        SPDBG_ASSERT(sum > 0);
        inv_sum = 1.0f / sum;
        cut = cutoff * sum;
        for (lp = l_pair, i = 0; i < dim; i++, lp++)
        {
            if ((float)(lp->cnt) > cut)
            {
                res->out_strings[res->num_strings] = new LTS_OUT_STRING;
                if (NULL == res->out_strings[res->num_strings])
                {
                    return NULL;
                }
                res->out_strings[res->num_strings]->psym[0] = (SYMBOL) lp->id;
                res->out_strings[res->num_strings]->psym[1] = NULL_SYMBOL_ID;
                res->out_strings[res->num_strings]->prob = lp->cnt * inv_sum;
                res->num_strings++;
            } /* cut */
        }
    }
    else
    {
        LTS_OUT_RESULT *tmpRes;

        pdf = lts_find_leaf_count(l_forest, input_id + in_index, pOut);
        dim = pdf->c_dists;
        l_pair = &(pdf->p_pair);
        for (lp = l_pair, sum = 0, i = 0; i < dim; i++, lp++)
        {
            sum += lp->cnt;
        }
        SPDBG_ASSERT(sum > 0);

        inv_sum = 1.0f / sum;
        cut = cutoff * sum;
        for (lp = l_pair, i = 0; i < dim; i++, lp++)
        {
            if ((float)(lp->cnt) > cut)
            {
                SYMBOL *pTmpOut = pOut + 1;
                *pOut = (SYMBOL) lp->id;
                tmpRes = gen_one_output(l_forest, len, input_id, in_index + 1, pTmpOut, cutoff);
                if (!tmpRes)
                {
                    return NULL;
                }

                if (!grow_out_result(l_forest, res, (SYMBOL)(lp->id), lp->cnt,
                    inv_sum, tmpRes))
                {
                    return NULL;
                }
            }
        } /* i */
    } /* else */

    return res;
} // static LTS_OUT_RESULT *gen_one_output(LTS_FOREST *l_forest, int len,


static int comp_out_result_prob(const void *vp1, const void *vp2)
{
    SPDBG_FUNC("comp_out_result_prob");

    LTS_OUT_STRING **p1 = (LTS_OUT_STRING **) vp1,
        **p2 = (LTS_OUT_STRING **) vp2;

    if ((*p1)->prob > (*p2)->prob)
    {
        return -1;
    }
    else if ((*p1)->prob < (*p2)->prob)
    {
        return 1;
    }
    else
    {
        return 0;
    }
} // static int comp_out_result_prob(const void *vp1, const void *vp2)


static void lts_fill_out_buffer(LTS_FOREST *l_forest, LTS_OUT_RESULT *out,
                                char *word)
{
    SPDBG_FUNC("lts_fill_out_buffer");

    int i, j, n;
    float inv_sum, sum = 0.0f;
    char phnstr[LONGEST_STR];
    char *tmp;
    LTS_SYMTAB *tab = l_forest->symbols;

    if (out == NULL)
    {
        return;
    }

    if (word)
    {
        strcpy(l_forest->out.word, word);
    }
    else
    {
        l_forest->out.word[0] = 0;
    }

    /* normalize probabilities */
    for (i = 0; i < out->num_strings; i++)
    {
        sum += out->out_strings[i]->prob;
    }
    inv_sum = 1.0f / sum;
    for (i = 0; i < out->num_strings; i++)
    {
        out->out_strings[i]->prob *= inv_sum;
    }

    /*
    * sort them according to the prob field
    */
    qsort(out->out_strings, out->num_strings, sizeof(LTS_OUT_STRING *),
        &comp_out_result_prob);

    if (out->num_strings > MAX_OUTPUT_STRINGS - l_forest->out.num_prons)
    {
        n = MAX_OUTPUT_STRINGS - l_forest->out.num_prons;
        for (sum = 0.0f, i = 0; i < n; i++)
        {
            sum += out->out_strings[i]->prob;
        }
        inv_sum = 1.0f / sum;
        for (i = 0; i < n; i++)
        {
            out->out_strings[i]->prob *= inv_sum;
        }
    }
    else
    {
        n = out->num_strings;
    }

    for (j = l_forest->out.num_prons, i = 0; i < n; i++)
    {
        SYMBOL *p = out->out_strings[i]->psym;
        char *psrc, *ptgt;

        if (out->out_strings[i]->prob < MIN_OUT_PROB)
        {
            continue;
        }

        phnstr[0] = 0;
        l_forest->out.pron[j].prob = out->out_strings[i]->prob;

        while (*p != NULL_SYMBOL_ID)
        {
            tmp = id_to_symbol(&(tab[OUTPUT]), *p++);
            SPDBG_ASSERT(tmp);
            if (tmp)
            {
                strcat(phnstr, tmp);
                strcat(phnstr, " ");
            }
        }

        psrc = phnstr;
        ptgt = l_forest->out.pron[j].pstr;
        while (*psrc)
        {
            if (*psrc != '#' && *psrc != '_')
            {
                *ptgt++ = *psrc++;
            }
            else if (*psrc == '_')
            {
                *ptgt++ = ' ';
                psrc++;
            }
            else
            {
                psrc += 2; /* skip an extra space */
            }
            /* extreme case, truncate it */
            if (ptgt - l_forest->out.pron[j].pstr >= SP_MAX_PRON_LENGTH)
            {
                for (ptgt--; !isspace(*ptgt); ptgt--) {}; /* never output partial phone */
                ptgt++;
                break;
            }
        }
        // output could contain only '# '
        if (ptgt > l_forest->out.pron[j].pstr && *(ptgt - 1) == ' ')
        {
            *(ptgt - 1) = 0; /* remove the last space */
        }
        else
        {
            *ptgt = 0; /* shouldn't happen unless ptgt didn't move */
        }
        if (ptgt > l_forest->out.pron[j].pstr)
        {
            j++;
        }
    } /* i */

    if (j <= MAX_OUTPUT_STRINGS)
    {
        l_forest->out.num_prons = j;
    }
    else
    {
        l_forest->out.num_prons = MAX_OUTPUT_STRINGS; // should never happen
    }

    free_out_result(l_forest, out);
} // static void lts_fill_out_buffer(LTS_FOREST *l_forest, LTS_OUT_RESULT *out,


void assign_a_fixed_pron(LTS_OUTPUT *out, const char *pron, char *word)
{
    SPDBG_FUNC("assign_a_fixed_pron");

    out->num_prons = 1;
    strcpy(out->word, word);
    out->pron[0].prob = 1.0f;
    if (strlen(pron) < SP_MAX_PRON_LENGTH)
    {
        strcpy(out->pron[0].pstr, pron);
    }
    else
    {
        char *p;
        strncpy(out->pron[0].pstr, pron, SP_MAX_PRON_LENGTH);
        p = &(out->pron[0].pstr[SP_MAX_PRON_LENGTH - 1]);
        while (!isspace(*p))
        {
            p--; /* truncate the last partial phoneme */
        }
        *p = 0;
    }
} // void assign_a_fixed_pron(LTS_OUTPUT *out, char *pron, char *word)

inline BOOL IsCharInRangeA(int ch, int chMin, int chMax)
{
    return (unsigned)(ch - chMin) <= (unsigned)(chMax - chMin);
}

void assign_a_spelling_pron(LTS_OUTPUT *out, const char * single_letter_pron[52], char *word)
{
    SPDBG_FUNC("assign_a_spelling_pron");

    char *p;
    int cchPron = 0;

    strcpy(out->word, word);
    if (ispunct(*word))
    {
        p = word + 1;
    }
    else
    {
        p = word;
    }

    out->num_prons = 1;
    out->pron[0].prob = 1.0f;
    out->pron[0].pstr[0] = 0;

    char * pchPron = out->pron[0].pstr;

    while (*p)
    {
        int cPOffset = 0;   // 0 for single letter, 26 for plurals
        int c = *p++;

        // Lowercaseify, and skip over non-letters
        if (IsCharInRangeA(c, 'A', 'Z'))
        {
            c += 'a' - 'A';
        }
        else if (!IsCharInRangeA(c, 'a', 'z'))
        {
            continue;
        }

        // Check if the next two characters are 'S (apostrophe S).  Include the following cases: words ending in 's 'S s' S'
        // If they are we use a the plural pronunciation for the letter and skip over the letter and 'S
        if ((p[0] == '\'') && ((0 == p[1] && 's' == c) || 's' == p[1] || 'S' == p[1]))
        {
            cPOffset = 26;
            p += p[1] ? 1 : 0;         // skip 'S
        }

        //  Make sure the string isn't too long accounting for the new phone and seperator
        const char * const pchPronT = single_letter_pron[cPOffset + c - 'a'];
        const int cchPronT = strlen(pchPronT);

        if ((cchPron + 1 + cchPronT) < (SP_MAX_PRON_LENGTH - 1)) // +1 for separating space, -1 for terminating NUL
        {
            strcpy(pchPron + cchPron, pchPronT);

            cchPron += cchPronT;

            pchPron[cchPron++] = ' ';
        }
        else
        {
            break;
        }
    }

    if (cchPron)
    {
        pchPron[cchPron - 1] = 0; // trim trailing space char
    }
}


HRESULT LtscartGetPron(LTS_FOREST *l_forest, char *word, LTS_OUTPUT **ppLtsOutput)
{
    SPDBG_FUNC("LtscartGetPron");

    HRESULT hr = S_OK;
    LTS_OUT_RESULT *pres = NULL;
    char *p, *base;
    SYMBOL buffer[LONGEST_STR], *pbuf = buffer + 1;
    int len, id, hasvowel = 0, allcapital = 1;

    l_forest->out.num_prons = 0;
    buffer[0] = NULL_SYMBOL_ID;
    len = 0;


    if (word == NULL || (base = strtok(word, " \t\n")) == NULL)
    {
        assign_a_fixed_pron(&(l_forest->out), l_forest->bogus_pron, "NUL");
        *ppLtsOutput = &(l_forest->out);
        return S_FALSE;
    }
    else
    {
        base = strtok(word, " \t\n");
        if (ispunct(*base))
        {
            for (p = base; *p && ispunct(*p); p++) {};
        }
        else
        {
            p = base;
        }
    }

    char ach[2];
    ach[1] = 0;

    while (*p)
    {
        const int d = *p++;
        const int c = tolower(d);

        if (!hasvowel && (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'))
        {
            hasvowel = 1;
        }
        if (allcapital && d == c)
        {
            allcapital = 0;
        }

        ach[0] = (char)c;

        if ((id = symbol_to_id (&(l_forest->symbols[INPUT]), ach)) == NO_SYMBOL || id == NULL_SYMBOL_ID)
        {
            ODS("cannot find the symbol %c, skip!\n", c);
            continue;
        }

        pbuf[len++] = (SYMBOL) id;
    }

    pbuf[len] = NULL_SYMBOL_ID;
    if (len >= SP_MAX_WORD_LENGTH || len <= 0)
    {
        // fill in bogus pron below
    }
    else if (len == 1)
    {
        LTS_SYMTAB *tab = l_forest->symbols;
        char *p = id_to_symbol(&(tab[INPUT]), pbuf[0]);
        int c = tolower(p[0]);
        if (c >= 'a' && c <= 'z')
        {
            assign_a_fixed_pron(&(l_forest->out), l_forest->single_letter_pron[c - 'a'], word);
        }
    }
    else if (!hasvowel)
    {
        assign_a_spelling_pron(&(l_forest->out), l_forest->single_letter_pron, word);
    }
    else
    {
        if (allcapital)
        {
            assign_a_spelling_pron(&(l_forest->out), l_forest->single_letter_pron, word);
        }
        pres = gen_one_output(l_forest, len, pbuf, 0, pbuf, DEFAULT_PRUNE);
        if (!pres)
        {
            return E_OUTOFMEMORY;
        }

        lts_fill_out_buffer(l_forest, pres, word);
    }

    if (l_forest->out.num_prons == 0)
    {
        hr = S_FALSE;

        assign_a_fixed_pron(&(l_forest->out), l_forest->bogus_pron, word);
    }

    *ppLtsOutput = &(l_forest->out);

    SPDBG_RETURN(hr);
} /* LtscartGetPron */


LTS_FOREST *LtscartReadData (LCID lcid, PBYTE map_addr)
{
    SPDBG_FUNC("LtscartReadData");

    int i;
    LTS_FOREST *l_forest;
    LTS_SYMTAB *tab;
    LTS_FEATURE *feat;
    int output = 0;

    l_forest = (LTS_FOREST *) calloc(1, sizeof(LTS_FOREST));
    if (!l_forest)
    {
        return NULL;
    }

    if (lcid == 1033)
    {
        l_forest->bogus_pron = bogus_pron_1033;
        l_forest->single_letter_pron = single_letter_pron_1033;
    }
    else if (lcid == 1041)
    {
        l_forest->bogus_pron = bogus_pron_1041;
        l_forest->single_letter_pron = single_letter_pron_1041;
    }
    else
    {
        return NULL;
    }

    //read in the symbol table
    l_forest->symbols = (LTS_SYMTAB *) calloc(2, sizeof(LTS_SYMTAB));
    if (!l_forest->symbols)
    {
        return NULL;
    }

    tab = &(l_forest->symbols[INPUT]);
    CopyMemory(&(tab->n_symbols), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->sym_idx = (int *)(map_addr + output);
    output += tab->n_symbols * sizeof(int);

    CopyMemory(&(tab->n_bytes), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->storage = (char*)(map_addr + output);
    output += tab->n_bytes * sizeof(char);

    tab = &(l_forest->symbols[OUTPUT]);
    CopyMemory(&(tab->n_symbols), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->sym_idx = (int*)(map_addr + output);
    output += tab->n_symbols * sizeof(int);
    CopyMemory(&(tab->n_bytes), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->storage = (char*)(map_addr + output);
    output += tab->n_bytes * sizeof(char);

    // read in the feature vector
    l_forest->features = (LTS_FEATURE *) calloc(2, sizeof(LTS_FEATURE));
    if (!l_forest->features)
    {
        return NULL;
    }

    feat = &(l_forest->features[INPUT]);

    CopyMemory(&(feat->n_feat), map_addr + output, sizeof(int));
    output += sizeof(int);

    CopyMemory(&(feat->dim), map_addr + output, sizeof(int));
    output += sizeof(int);

    feat->feature = (int **) calloc(feat->n_feat, sizeof(int *));
    if (!feat->feature)
    {
        return NULL;
    }

    for (i = 0; i < feat->n_feat; i++)
    {
        feat->feature[i] = (int*)(map_addr + output);
        output += feat->dim * sizeof(int);
    }

    feat = &(l_forest->features[OUTPUT]);
    CopyMemory(&(feat->n_feat), map_addr + output, sizeof(int));
    output += sizeof(int);

    CopyMemory(&(feat->dim), map_addr + output, sizeof(int));
    output += sizeof(int);

    feat->feature = (int **) calloc(feat->n_feat, sizeof(int *));
    if (!feat->feature)
    {
        return NULL;
    }

    for (i = 0; i < feat->n_feat; i++)
    {
        feat->feature[i] = (int*)(map_addr + output);
        output += feat->dim * sizeof(int);
    }

    /*
    * read in the tree
    */
    l_forest->tree = (LTS_TREE **) calloc(l_forest->symbols[INPUT].n_symbols,
					   sizeof(LTS_TREE *));
    if (!l_forest->tree)
    {
        return NULL;
    }

    for (i = 1; i < l_forest->symbols[INPUT].n_symbols; i++)
    {
        LTS_TREE *l_root;
        l_forest->tree[i] = l_root = (LTS_TREE *) calloc(1, sizeof(LTS_TREE));
        if (!l_root)
        {
            return NULL;
        }

        CopyMemory(&(l_root->n_nodes), map_addr + output, sizeof(int));
        output += sizeof(int);

        l_root->nodes = (LTS_NODE*)(map_addr + output);
        output += l_root->n_nodes * sizeof(LTS_NODE);

        CopyMemory(&(l_root->size_dist), map_addr + output, sizeof(int));
        output += sizeof(int);

        l_root->p_dist = (LTS_DIST*)(map_addr + output);
        output += l_root->size_dist * sizeof(char);

        CopyMemory(&(l_root->size_prod), map_addr + output, sizeof(int));
        output += sizeof(int);

        if (l_root->size_prod > 0)
        {
            l_root->p_prod = (LTS_PROD*)(map_addr + output);
            output += l_root->size_prod * sizeof(char);
        }
    }

    return l_forest;
} // LTS_FOREST *LtscartReadData(char *forest_image, HANDLE *hFile1,


void LtscartFreeData(LTS_FOREST *l_forest)
{
    SPDBG_FUNC("LtscartFreeData");

    for (int i = 1; i < l_forest->symbols[INPUT].n_symbols; i++)
    {
        free(l_forest->tree[i]);
    }
    free(l_forest->tree);

    free(l_forest->features[INPUT].feature);
    free(l_forest->features[OUTPUT].feature);
    free(l_forest->features);

    free(l_forest->symbols);

    free(l_forest);
} // void LtscartFreeData(LTS_FOREST *l_forest, HANDLE m_hFile,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\include\streamhlp.h ===
#pragma once

#include <spunicode.h>

/****************************************************************************
* SpGenericCopyTo *
*-----------------*
*   Description:
*       This function is used by stream implementations to implement the CopyTo method of IStream.
*       Note that the source stream is not parameter validated since it will be the "this" pointer
*       of the object that is calling this function.
*
*   Returns:
*
*****************************************************************************/
inline HRESULT SpGenericCopyTo(IStream * pSrc, IStream * pDest, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr = S_OK;
    if (::IsBadReadPtr(pDest, sizeof(*pDest)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if ((pcbRead && ::IsBadWritePtr(pcbRead, sizeof(*pcbRead))) ||
            (pcbWritten && ::IsBadWritePtr(pcbWritten, sizeof(*pcbWritten))))
        {
            hr = E_POINTER;
        }
        else
        {
            BYTE aBuffer[0x1000];   // Do 4k reads
            while (cb.QuadPart)
            {
                ULONG cbThisRead = cb.QuadPart > sizeof(aBuffer) ? sizeof(aBuffer) : cb.LowPart;
                ULONG cbActuallyRead = 0;
                hr = pSrc->Read(aBuffer, cbThisRead, &cbActuallyRead);
                if (pcbRead)
                {
                    pcbRead->QuadPart += cbActuallyRead;
                }
                if (FAILED(hr) || cbActuallyRead == 0)
                {
                    break;
                }
                ULONG cbActuallyWritten = 0;
                hr = pDest->Write(aBuffer, cbActuallyRead, &cbActuallyWritten);
                if (pcbWritten)
                {
                    pcbWritten->QuadPart += cbActuallyWritten;
                }
                if (FAILED(hr))
                {
                    break;
                }
                cb.QuadPart -= cbActuallyRead;
            }
        }
    }
    return hr;
}


/****************************************************************************
* SPCreateStreamOnHGlobal *
*-------------------------*
*   Description:
*       Similar to CreateStreamOnHGlobal Win32 API, but allows a stream to be
*   created 
*
*   Returns:
*
*****************************************************************************/

inline HRESULT SPCreateStreamOnHGlobal(
                    HGLOBAL hGlobal,            //Memory handle for the stream object
                    BOOL fDeleteOnRelease,      //Whether to free memory when the object is released
                    REFGUID rguidFormatId,      //Format ID for stream
                    const WAVEFORMATEX * pwfex, //WaveFormatEx for stream
                    ISpStream ** ppStream)      //Address of variable to receive ISpStream pointer
{
    HRESULT hr;
    IStream * pMemStream;
    *ppStream = NULL;
    hr = ::CreateStreamOnHGlobal(hGlobal, fDeleteOnRelease, &pMemStream);
    if (SUCCEEDED(hr))
    {
        hr = ::CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
        if (SUCCEEDED(hr))
        {
            hr = (*ppStream)->SetBaseStream(pMemStream, rguidFormatId, pwfex);
            if (FAILED(hr))
            {
                (*ppStream)->Release();
                *ppStream = NULL;
            }
        }
        pMemStream->Release();
    }
    return hr;
}



/****************************************************************************
* CSpFileStream *
*---------------*
*   Description:
*       This C++ class can be used by applications to turn a Win32 file into
*   a COM stream.  Usually it is easier to use the CLSD_SpStream implementation
*   than to use this class directly, but this class allows for more fine-grained
*   control over various attributes, such as security attributes.  You can also
*   use this class to create a stream from an existing file handle.  Note that
*   if you want to use this class on an existing Win32 file handle, you should
*   either "give ownership" of that handle to this class (and allow this class
*   to close the handle) or else you will need to use DuplicateHandle to create
*   a handle that can be closed by this class.
*
*   NOTE:
*       Upon creation of this class, the ref count is set to 1.
*
*****************************************************************************/

class CSpFileStream : public IStream
{
private:
    HANDLE      m_hFile;
    ULONG       m_ulRef;
public:
    CSpFileStream(HANDLE hFile) : m_hFile(hFile), m_ulRef(1) {}

    CSpFileStream(HRESULT * pHR, const TCHAR * pFileName, DWORD dwDesiredAccess = GENERIC_READ, DWORD dwShareMode = FILE_SHARE_READ, DWORD dwCreationDisposition = OPEN_EXISTING,
                  LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL, DWORD dwFlagsAndAttrib = 0, HANDLE hTemplate = NULL)
    {
        m_hFile = ::CreateFile(pFileName, dwDesiredAccess, dwShareMode, lpSecurityAttrib, dwCreationDisposition, dwFlagsAndAttrib, hTemplate);
        m_ulRef = 1;
        *pHR = (m_hFile != INVALID_HANDLE_VALUE) ? S_OK : SpHrFromLastWin32Error();
    }

#ifndef _UNICODE
    CSpFileStream(HRESULT * pHR, const WCHAR * pFileName, DWORD dwDesiredAccess = GENERIC_READ, DWORD dwShareMode = FILE_SHARE_READ, DWORD dwCreationDisposition = OPEN_EXISTING,
                  LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL, DWORD dwFlagsAndAttrib = 0, HANDLE hTemplate = NULL)
    {
        CSpUnicodeSupport Unicode;
        m_hFile = Unicode.CreateFile(pFileName, dwDesiredAccess, dwShareMode, lpSecurityAttrib, dwCreationDisposition, dwFlagsAndAttrib, hTemplate);
        m_ulRef = 1;
        *pHR = (m_hFile != INVALID_HANDLE_VALUE) ? S_OK : SpHrFromLastWin32Error();
    }
#endif

    ~CSpFileStream()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(m_hFile);
        }
    }


    HANDLE FileHandle()
    {
        return m_hFile;
    }

    HRESULT Close(void)
    {
        HRESULT hr = S_OK;
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            if (!::CloseHandle(m_hFile))
            {
                hr = SpHrFromLastWin32Error();
            }
            m_hFile = INVALID_HANDLE_VALUE;
        }
        else
        {
            hr = SPERR_UNINITIALIZED;
        }
        return hr;
    }
            

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IStream) ||
            riid == IID_ISequentialStream ||
            riid == __uuidof(IUnknown))
        {
            *ppv = (IStream *)this;
            m_ulRef++;
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_ulRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        --m_ulRef;
        if (m_ulRef)
        {
            return m_ulRef;
        }
        delete this;
        return 0;
    }

    STDMETHODIMP Read(void * pv, ULONG cb, ULONG * pcbRead)
    {
        ULONG ulRead;
        if (::ReadFile(m_hFile, pv, cb, &ulRead, NULL))
        {
            if (pcbRead) *pcbRead = ulRead;
            return S_OK;
        }
        return SpHrFromLastWin32Error();
    }
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG * pcbWritten)
    {
        ULONG ulWritten;
        if (::WriteFile(m_hFile, pv, cb, &ulWritten, NULL))
        {
            if (pcbWritten) *pcbWritten = ulWritten;
            return S_OK;
        }
        return SpHrFromLastWin32Error();
    }

    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
    {
        long lMoveHigh = dlibMove.HighPart;
        DWORD dwNewPos = ::SetFilePointer(m_hFile, dlibMove.LowPart, &lMoveHigh, dwOrigin);
        if (dwNewPos == 0xFFFFFFFF && ::GetLastError() != NO_ERROR)
        {
            return SpHrFromLastWin32Error();
        }
        if (plibNewPosition)
        {
            plibNewPosition->LowPart = dwNewPos;
            plibNewPosition->HighPart = lMoveHigh;
        }
        return S_OK;
    }

    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) 
    {
        HRESULT hr = S_OK;
        LARGE_INTEGER Move = {0};
        ULARGE_INTEGER Cur;
        hr = Seek(Move, STREAM_SEEK_CUR, &Cur);
        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER li;
            li.QuadPart = libNewSize.QuadPart;
            hr = Seek(li, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hr))
            {
                if (!::SetEndOfFile(m_hFile))
                {
                    hr = SpHrFromLastWin32Error();
                }
                li.QuadPart = Cur.QuadPart;
                Seek(li, STREAM_SEEK_SET, NULL);
            }
        }
        return hr;
    }
   
    STDMETHODIMP CopyTo(IStream *pStreamDest, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
        return SpGenericCopyTo(this, pStreamDest, cb, pcbRead, pcbWritten);
    }
        
    STDMETHODIMP Commit(DWORD /*grfCommitFlags*/)
    {
        return S_OK;    // Direct mode streams simply ignore this
    }
        
    STDMETHODIMP Revert(void) 
    {
        return S_OK;    // Direct mode streams simply ignore this
    }
        
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) 
    {
#ifndef _WIN32_WCE
        if (dwLockType != LOCK_WRITE && dwLockType != LOCK_EXCLUSIVE)
        {
            return STG_E_INVALIDFUNCTION;
        }
        DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;
        if (dwLockType == LOCK_EXCLUSIVE)
        {
            dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;
        }
        OVERLAPPED Overlapped;
        memset(&Overlapped, 0, sizeof(Overlapped));
        Overlapped.Offset = libOffset.LowPart;
        Overlapped.OffsetHigh = libOffset.HighPart;
        if (::LockFileEx(m_hFile, dwFlags, 0, cb.LowPart, cb.HighPart, &Overlapped))
        {
            return S_OK;
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (dwErr == ERROR_LOCK_VIOLATION)
            {
                return STG_E_LOCKVIOLATION;
            }
            return SpHrFromWin32(dwErr);
        }
#else //  _WIN32_WCE
    return E_NOTIMPL;
#endif // _WIN32_WCE
    }
    
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
#ifndef _WIN32_WCE
        if (dwLockType != LOCK_WRITE && dwLockType != LOCK_EXCLUSIVE)
        {
            return STG_E_INVALIDFUNCTION;
        }
        OVERLAPPED Overlapped;
        memset(&Overlapped, 0, sizeof(Overlapped));
        Overlapped.Offset = libOffset.LowPart;
        Overlapped.OffsetHigh = libOffset.HighPart;
        if (::UnlockFileEx(m_hFile, 0, cb.LowPart, cb.HighPart, &Overlapped))
        {
            return S_OK;
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (dwErr == ERROR_LOCK_VIOLATION)
            {
                return STG_E_LOCKVIOLATION;
            }
            return SpHrFromWin32(dwErr);
        }
#else //  _WIN32_WCE
    return E_NOTIMPL;
#endif // _WIN32_WCE
    }
        
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        HRESULT hr = S_OK;
        if (grfStatFlag & (~STATFLAG_NONAME))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            ZeroMemory(pstatstg, sizeof(*pstatstg));
            pstatstg->grfLocksSupported = LOCK_WRITE | LOCK_EXCLUSIVE;
            pstatstg->type = STGTY_STREAM;
            BY_HANDLE_FILE_INFORMATION fi;
            if (::GetFileInformationByHandle(m_hFile, &fi))
            {
                pstatstg->cbSize.LowPart = fi.nFileSizeLow;
                pstatstg->cbSize.HighPart = fi.nFileSizeHigh;
                pstatstg->mtime = fi.ftLastWriteTime;
                pstatstg->ctime = fi.ftCreationTime;
                pstatstg->atime = fi.ftLastAccessTime;
                // This implementation does not fill in the mode or the name.
            }
        }
        return hr;
    }
        
    STDMETHODIMP Clone(IStream ** ppstm)
    {
        HANDLE hDupFile;
#ifndef _WIN32_WCE
        HANDLE hProcess = ::GetCurrentProcess();
        if (::DuplicateHandle(hProcess, m_hFile, hProcess, &hDupFile, 0, TRUE, DUPLICATE_SAME_ACCESS))
        {
            *ppstm = new CSpFileStream(hDupFile);
            if (*ppstm)
            {
                return S_OK;
            }
            ::CloseHandle(hDupFile);
            return E_OUTOFMEMORY;
        }
        else
        {
            return SpHrFromLastWin32Error();
        }
#else   // _WIN32_WCE
        hDupFile = m_hFile;
        *ppstm = new CSpFileStream(hDupFile);
        if (*ppstm)
        {
            return S_OK;
        }
        return E_OUTOFMEMORY;
#endif  // _WIN32_WCE
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\ltscart.h ===
#ifndef _LTS_CART_H
#define _LTS_CART_H

#include "CommonLx.h"

#define INPUT  0
#define OUTPUT 1
#define _LEFT   2
#define _RIGHT  3

#define OUTPUT_QUES_OFFSET 20000
#define RIGHT_QUES_OFFSET 10000
#define QUESTION_CODE_RANGE 1000

#define MAX_PRODUCTS 300

#define CLR_BIT(array, n)       ((array)[(n)/32] &= ~(1<<((n)%32)))
#define SET_BIT(array, n)       ((array)[(n)/32] |=  (1<<((n)%32)))
#define TST_BIT(array, n)       ((array)[(n)/32] &   (1<<((n)%32)))

#define LONGEST_STR 1024
#define NULL_SYMBOL_ID 0
#define NO_SYMBOL -1

typedef unsigned char SYMBOL;

typedef struct 
{
  int n_symbols;
  UNALIGNED int *sym_idx;
  int n_bytes;
  char *storage;
} LTS_SYMTAB;

typedef struct
{
  SYMBOL *pIn;
  SYMBOL *pOut;
} LTS_SAMPLE;

typedef struct 
{
  int n_feat;
  int dim;
  int **feature;
} LTS_FEATURE;

typedef struct t_node 
{
  float entropy_dec;
  int n_samples;
  int *count;
  char *prod;
  int index;
  struct t_node *yes_child;
  struct t_node *no_child;
} T_NODE;

#define NO_CHILD 0
#define IS_LEAF_NODE(x) ((x)->yes == NO_CHILD)
typedef struct 
{
  unsigned short yes;   /* index to yes child, no child will always follow */
  int idx;   /* index to prod (for internal) and dist (for leaf) */     
} LTS_NODE;

typedef struct 
{
  short id;
  short cnt;
} LTS_PAIR;

typedef struct 
{
  int c_dists;
  LTS_PAIR p_pair;
} LTS_DIST;

typedef unsigned short LTS_PROD;

#define PROD_NEG  0x8000
#define MAX_PROD  0x8ffc
#define PROD_TERM 0xfffe
#define QUES_TERM 0xffff

typedef struct 
{
  int n_nodes;
  LTS_NODE *nodes;
  LTS_DIST *p_dist;
  int size_dist;
  LTS_PROD *p_prod;
  int size_prod;
} LTS_TREE;

#define MAX_ALT_STRINGS 64
#define INC_ALT_STRINGS 32
#define MAX_OUTPUT_STRINGS 10
#define MIN_OUT_PROB 0.01f
#define DEFAULT_PRUNE 0.1f

typedef struct
{
  float prob;
  char  pstr[SP_MAX_PRON_LENGTH];
} LTS_OUT_PRON;

typedef struct
{
  int num_prons;
  char word[SP_MAX_WORD_LENGTH];
  LTS_OUT_PRON pron[MAX_OUTPUT_STRINGS];
} LTS_OUTPUT;

typedef struct
{
  float prob;
  SYMBOL psym[SP_MAX_WORD_LENGTH];
} LTS_OUT_STRING;

typedef struct outresult
{
  int num_strings;
  int num_allocated_strings;
  LTS_OUT_STRING **out_strings;
} LTS_OUT_RESULT;

typedef struct 
{
  LTS_SYMTAB *symbols;
  LTS_FEATURE *features;
  LTS_TREE **tree;
  LTS_OUTPUT out;
  const char *bogus_pron;
  const char **single_letter_pron;
} LTS_FOREST;

typedef struct simp_question
{
  char questype;
  char context;
  char offset;
  short feature;
} SIMPLE_QUESTION;

#define QUES_DECODE(code, questype, context, offset, feature) \
{ \
  int c = code; \
  if (c > OUTPUT_QUES_OFFSET) { \
    questype = OUTPUT; \
    c -= OUTPUT_QUES_OFFSET; \
  } \
  else \
    questype = INPUT; \
  if (c > RIGHT_QUES_OFFSET) { \
    context = _RIGHT; \
    c -= RIGHT_QUES_OFFSET; \
  } \
  else \
    context = _LEFT; \
  offset = c / QUESTION_CODE_RANGE; \
  feature = c % QUESTION_CODE_RANGE; \
}

#define SAMPLE_GET_CONTEXT(sample, questype, context, offset, id) { \
  SYMBOL *ps, i; \
  if ((questype) == INPUT) \
    ps = (sample)->pIn; \
  else \
    ps = (sample)->pOut; \
  if ((context) == _LEFT) { \
    for (i = 0; i < (offset) && *ps != NULL_SYMBOL_ID; i++, ps--); \
    id = *ps; \
  } \
  else { \
    for (i = 0; i < (offset) && *ps != NULL_SYMBOL_ID; i++, ps++); \
    id = *ps; \
  } \
}

#ifdef __cplusplus
extern "C" {
#endif
LTS_FOREST *LtscartReadData (LCID , PBYTE);
void LtscartFreeData (LTS_FOREST *l_forest);
HRESULT LtscartGetPron(LTS_FOREST *l_forest, char *word, LTS_OUTPUT **ppLtsOutput);
#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\ltslx.cpp ===
/*******************************************************************************
* LtsLx.cpp *
*--------------*
*       Implements the LTS lexicon object.
*
*  Owner: YUNUSM                                        Date: 06/18/99
*  Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

//--- Includes ----------------------------------------------------------------
#include "StdAfx.h"
#include "LtsLx.h"
#include <initguid.h>

//--- Globals -----------------------------------------------------------------
// CAUTION: This validation GUID also defined in the tool to build LTS lexicons
// {578EAD4E-330C-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(guidLtsValidationId,
0x578ead4e, 0x330c, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

extern CSpUnicodeSupport   g_Unicode;

//--- Constructor, Initializer and Destructor functions ------------------------

/*******************************************************************************
* CLTSLexicon::CLTSLexicon *
*--------------------------*
*
*   Description:
*       Constructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
CLTSLexicon::CLTSLexicon(void)
{
    SPDBG_FUNC("CLTSLexicon::CLTSLexicon");
}

/*******************************************************************************
* CLTSLexicon::FinalConstruct *
*-----------------------------*
*
*   Description:
*       Initializes the CLTSLexicon object
*
*   Return:
*       S_OK
***************************************************************** YUNUSM ******/
HRESULT CLTSLexicon::FinalConstruct(void)
{
    SPDBG_FUNC("CLTSLexicon::FinalConstruct");

    NullMembers();

    return S_OK;
}


/*****************************************************************************
* CLTSLexicon::~CLTSLexicon *
*---------------------------*
*
*   Description:
*       Destructor
*
*   Return:
*       n/a
**********************************************************************YUNUSM*/
CLTSLexicon::~CLTSLexicon()
{
    SPDBG_FUNC("CLTSLexicon::~CLTSLexicon");

    CleanUp();
}

/*******************************************************************************
* CLTSLexicon::CleanUp *
*----------------------*
*
*   Description:
*       real destructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CLTSLexicon::CleanUp(void)
{
    SPDBG_FUNC("CLTSLexicon::CleanUp");

    if (m_pLtsData)
    {
        UnmapViewOfFile(m_pLtsData);
    }

    if (m_hLtsMap)
    {
        CloseHandle(m_hLtsMap);
    }

    if (m_hLtsFile)
    {
        CloseHandle(m_hLtsFile);
    }

    if (m_pLTSForest)
    {
        ::LtscartFreeData(m_pLTSForest);
    }

    NullMembers();
}

/*******************************************************************************
* CLTSLexicon::NullMembers *
*--------------------------*
*
*   Description:
*       null data
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CLTSLexicon::NullMembers(void)
{
    SPDBG_FUNC("CLTSLexicon::NullMembers");

    m_fInit = false;
    m_cpObjectToken = NULL;
    m_pLtsData = NULL;
    m_hLtsMap = NULL;
    m_hLtsFile = NULL;
    m_pLTSForest = NULL;
    m_pLtsLexInfo = NULL;
    m_cpPhoneConv = NULL;
}

//--- ISpLexicon methods -------------------------------------------------------

/*******************************************************************************
* GetPronunciations *
*-------------------*
*
*   Description:
*       Gets the pronunciations and POSs of a word
*
*   Return:
*       E_POINTER
*       E_INVALIDARG
*       E_OUTOFMEMORY
*       S_OK
***************************************************************** YUNUSM ******/
STDMETHODIMP CLTSLexicon::GetPronunciations(const WCHAR * pwWord,                               // word
                                            LANGID LangID,                                      // LANGID of the word
                                            DWORD dwFlags,                                      // lextype
                                            SPWORDPRONUNCIATIONLIST * pWordPronunciationList    // buffer to return info in
                                            )
{
    USES_CONVERSION;
    SPDBG_FUNC("CLTSLexicon::GetPronunciations");

    HRESULT hr = S_OK;
    LANGID LangIDPassedIn = LangID;
    BOOL fBogusPron = FALSE;

    if (!pwWord || !pWordPronunciationList)
    {
       hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        // Yuncj: Chinese SR is using English LTS, so bypass the gollowing test by replacing its LangID
        if ( 2052 == LangID )
        {
            LangID = 1033;
        }
        if (!m_fInit)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else if (SPIsBadLexWord(pwWord) ||
                (LangID != m_pLtsLexInfo->LangID && LangID) ||
                SPIsBadWordPronunciationList(pWordPronunciationList))
        {
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr) && LangID == 1041)
    {
        // Check if the string is all english chars - Japanese LTS handles only english strings
        char szWord[SP_MAX_WORD_LENGTH];
        strcpy(szWord, W2A(pwWord));
        _strlwr(szWord);

        for (int i = 0; szWord[i]; i++)
        {
            if ((szWord[i] < 'a' || szWord[i] > 'z') && (szWord[i] != '\''))
            {
                hr = SPERR_NOT_IN_LEX; // Not returning E_INVALIDARG here since that would be hard for app to interpret
                break;
            }
        }
    }
    char szWord[SP_MAX_WORD_LENGTH];
    if (SUCCEEDED(hr))
    {
        if (!WideCharToMultiByte (CP_ACP, 0, pwWord, -1, szWord, SP_MAX_WORD_LENGTH, NULL, NULL))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    size_t cbPronsLen = 0;
    WCHAR aWordsProns[MAX_OUTPUT_STRINGS][SP_MAX_PRON_LENGTH];
    LTS_OUTPUT * pLTSOutput = NULL;
    int cProns = 0;

    ZeroMemory(aWordsProns, SP_MAX_PRON_LENGTH * MAX_OUTPUT_STRINGS * sizeof(WCHAR));
    if (SUCCEEDED(hr))
    {
        hr = LtscartGetPron(m_pLTSForest, szWord, &pLTSOutput);

        fBogusPron = S_FALSE == hr;

        if (SUCCEEDED(hr))
        {
            for (int i = 0; i < pLTSOutput->num_prons; i++)
            {
                HRESULT hrPhone = m_cpPhoneConv->PhoneToId(A2W(pLTSOutput->pron[i].pstr), aWordsProns[cProns]);

                if (SUCCEEDED(hrPhone))
                {
                    cbPronsLen += PronSize(aWordsProns[cProns]);
                    cProns++;
                }
            }
        }
    }
    if (SUCCEEDED(hr) && 0 == cProns)
    {
        hr = SPERR_NOT_IN_LEX;
    }
    if (SUCCEEDED(hr))
    {
        hr = ReallocSPWORDPRONList(pWordPronunciationList, cbPronsLen);
    }
    if (SUCCEEDED(hr))
    {
        SPWORDPRONUNCIATION *p = pWordPronunciationList->pFirstWordPronunciation;
        SPWORDPRONUNCIATION **ppNext = &pWordPronunciationList->pFirstWordPronunciation;

        for (int i = 0; i < cProns; i++)
        {
            p->ePartOfSpeech = SPPS_NotOverriden;
            wcscpy(p->szPronunciation, aWordsProns[i]);
            p->eLexiconType = (SPLEXICONTYPE)dwFlags;
            p->LangID = LangIDPassedIn;

            *ppNext = p;
            ppNext = &p->pNextWordPronunciation;

            p = CreateNextPronunciation(p);
        }

        *ppNext = NULL;
    }

    hr = SUCCEEDED(hr) ? (fBogusPron ? S_FALSE : S_OK) : hr;

    SPDBG_RETURN(hr);
}

STDMETHODIMP CLTSLexicon::AddPronunciation(const WCHAR *, LANGID, SPPARTOFSPEECH, const SPPHONEID *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::RemovePronunciation(const WCHAR *, LANGID, SPPARTOFSPEECH, const SPPHONEID *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::GetGeneration(DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::GetGenerationChange(DWORD, DWORD*, SPWORDLIST *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::GetWords(DWORD, DWORD *, DWORD *, SPWORDLIST *)
{
    return E_NOTIMPL;
}

//--- ISpObjectToken methods ---------------------------------------------------

STDMETHODIMP CLTSLexicon::GetObjectToken(ISpObjectToken **ppToken)
{
    return SpGenericGetObjectToken(ppToken, m_cpObjectToken);
}

/*****************************************************************************
* CLTSLexicon::SetObjectToken *
*-----------------------------*
*   Description:
*       Initializes the CLTSLexicon object
*
*   Return:
*       E_POINTER
*       E_INVALIDARG
*       GetLastError()
*       E_OUTOFMEMORY
*       S_OK
**********************************************************************YUNUSM*/
HRESULT CLTSLexicon::SetObjectToken(ISpObjectToken * pToken // token pointer
                                    )
{
    USES_CONVERSION;

    SPDBG_FUNC("CLTSLexicon::SetObjectToken");

    HRESULT hr = S_OK;
    WCHAR *pszLexFile = NULL;
    if (!pToken)
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        if (SPIsBadInterfacePtr(pToken))
        {
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        CleanUp();
        hr = SpGenericSetObjectToken(pToken, m_cpObjectToken);
    }
    // Get the lts data file name
    if (SUCCEEDED(hr))
    {
        hr = m_cpObjectToken->GetStringValue(L"Datafile", &pszLexFile);
    }
    // Open the Lts lexicon file
    if (SUCCEEDED(hr))
    {
        m_hLtsFile = g_Unicode.CreateFile (pszLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
        if (m_hLtsFile == INVALID_HANDLE_VALUE)
        {
            hr = SpHrFromLastWin32Error(); // bad input
        }
    }
    LTSLEXINFO LtsInfo;
    DWORD dwRead;
    if (SUCCEEDED(hr))
    {
        if (!ReadFile(m_hLtsFile, &LtsInfo, sizeof(LTSLEXINFO), &dwRead, NULL) || dwRead != sizeof(LTSLEXINFO))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        if (guidLtsValidationId != LtsInfo.guidValidationId ||
            (LtsInfo.LangID != 1033 && LtsInfo.LangID != 1041))
        {
            hr = E_INVALIDARG;
        }
    }
    /** WARNINIG **/
    // It is not recommended to do ReadFile/WriteFile and CreateFileMapping
    // on the same file handle. That is why we close the file handle and open it again and
    // create the map

    // Close the file and reopen since we have read from this file
    CloseHandle(m_hLtsFile);
    
    // Get the map name - We build the map name from the lexicon file name
	OLECHAR szMapName[_MAX_PATH];
	wcscpy(szMapName, pszLexFile);
    for( int i = 0; i < _MAX_PATH-1 && szMapName[i]; i++ )
    {
        if( szMapName[i] == '\\' )
        {
            // Change backslash to underscore
            szMapName[i] = '_';
        }
    }

    // Open the Lts lexicon file
    if (SUCCEEDED(hr))
    {
#ifdef _WIN32_WCE
        m_hLtsFile = g_Unicode.CreateFileForMappingW(pszLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
#else
        m_hLtsFile = g_Unicode.CreateFile(pszLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
#endif
        if (m_hLtsFile == INVALID_HANDLE_VALUE)
        {
            hr = SpHrFromLastWin32Error(); // bad input
        }
        ::CoTaskMemFree(pszLexFile);
    }
    // Map the Lts lexicon
    if (SUCCEEDED(hr))
    {
        m_hLtsMap = g_Unicode.CreateFileMapping(m_hLtsFile, NULL, PAGE_READONLY | SEC_COMMIT, 0 , 0, szMapName);
        if (!m_hLtsMap)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pLtsData = (PBYTE) MapViewOfFile (m_hLtsMap, FILE_MAP_READ, 0, 0, 0);
        if (!m_pLtsData)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pLtsLexInfo = (LTSLEXINFO*)m_pLtsData;
    }
    DWORD nOffset = sizeof(LTSLEXINFO);
    // Create and init the converter object
    if (SUCCEEDED(hr))
    {
//        hr = SpCreatePhoneConverter(LtsInfo.LangID, L"Type=LTS", NULL, &m_cpPhoneConv);
        hr = SpCreateObjectFromSubToken(pToken, L"PhoneConverter", &m_cpPhoneConv);
    }
    if (SUCCEEDED(hr))
    {
        nOffset += strlen((char*)(m_pLtsData + nOffset)) + 1;
        m_pLTSForest = ::LtscartReadData(m_pLtsLexInfo->LangID, m_pLtsData + nOffset);
        if (!m_pLTSForest)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_fInit = true;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\spcommon.dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\ltslx.h ===
/*******************************************************************************
*   LTSLx.h
*       This is the header file for the CLTSLexicon class that implements
*       the Letter-To-Sound (LTS) lexicon
*   
*   Owner: yunusm                                               Date: 06/18/99
*   Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include "LTSCart.h"
#include "resource.h"
#include "spcommon.h"

//--- Constants ---------------------------------------------------------------

static const DWORD g_dwMaxWordsInCombo = 10;

//--- Class, Struct and Union Definitions -------------------------------------

/*******************************************************************************
*
*   CLTSLexicon
*
****************************************************************** YUNUSM *****/
class ATL_NO_VTABLE CLTSLexicon : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CLTSLexicon, &CLSID_SpLTSLexicon>,
    public ISpLexicon,
    public ISpObjectWithToken
{
//=== ATL Setup ===
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_LTSLX)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CLTSLexicon)
        COM_INTERFACE_ENTRY(ISpLexicon)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
    END_COM_MAP()

//=== Methods ===
public:
    //--- Ctor, dtor, etc
    CLTSLexicon();
    ~CLTSLexicon();
    HRESULT FinalConstruct(void);

    //--- ISpObjectWithToken members
public:
    //--- ISpLexicon
    STDMETHODIMP GetPronunciations(const WCHAR * pwWord, LANGID LangID, DWORD dwFlags, SPWORDPRONUNCIATIONLIST * pWordPronunciationList);
    STDMETHODIMP AddPronunciation(const WCHAR * pwWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciations);
    STDMETHODIMP RemovePronunciation(const WCHAR * pszWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciation);
    STDMETHODIMP GetGeneration(DWORD *pdwGeneration);
    STDMETHODIMP GetGenerationChange(DWORD dwFlags, DWORD *pdwGeneration, SPWORDLIST *pWordList);
    STDMETHODIMP GetWords(DWORD dwFlags, DWORD *pdwGeneration, DWORD *pdwCookie, SPWORDLIST *pWordList);

    //--- ISpObjectWithToken
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

//=== Private methods ===
private:
    void CleanUp(void);
    void NullMembers(void);

//=== Private data ===
private:
    bool                 m_fInit;             // true if successfully inited
    CComPtr<ISpObjectToken> m_cpObjectToken;  // Token object
    LTSLEXINFO           *m_pLtsLexInfo;      // LTS lexicon header
    BYTE                 *m_pLtsData;         // lts file in memory
    HANDLE               m_hLtsMap;           // phone map
    HANDLE               m_hLtsFile;          // lts data file
    LTS_FOREST           *m_pLTSForest;       // lts rules
    CComPtr<ISpPhoneConverter> m_cpPhoneConv; // phone convertor
};  
    
//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDR_LTSLX                       100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED_)
#define AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

//#define _ATL_DEBUG_QI

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <spunicode.h>

#ifndef _WIN32_WCE
#pragma intrinsic( strcat, strlen, strcpy, memcpy )
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\spcommon.cpp ===
// Speech.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Speechps.mk in the project directory.

#include "stdafx.h"
#include <SPDebug.h>
#include <initguid.h>
#include "resource.h"
#include "spcommon.h"
#include "spcommon_i.c"
#include "sapi_i.c"
#include "ltslx.h"
#include "AssertWithStack.cpp"

//--- Initialize static member of debug scope class

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SpLTSLexicon         , CLTSLexicon       )
END_OBJECT_MAP()


CSpUnicodeSupport   g_Unicode;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

#ifdef _WIN32_WCE
extern "C" BOOL WINAPI DllMain(HANDLE hInstance, ULONG dwReason, LPVOID)
#else
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, (HINSTANCE)hInstance, &LIBID_LTSCommLib);
#ifdef _DEBUG
        // Turn on memory leak checking
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    #ifdef _DEBUG
    static BOOL fDoneOnce = FALSE;
    if (!fDoneOnce)
    {
        fDoneOnce = TRUE;
        SPDBG_DEBUG_CLIENT_ON_START();
    }
    #endif // _DEBUG

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\common\spcommon\spcommonver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Microsoft Speech SR/TTS Common Library"
#define VER_INTERNALNAME_STR        "SPCOMMON"
#define VER_ORIGINALFILENAME_STR    "SPCOMMON.DLL"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft Speech Engine\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\external\include\tapi3.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Tue Oct 05 15:14:18 1999
 */
/* Compiler settings for tapi3.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tapi3_h__
#define __tapi3_h__

/* Forward Declarations */ 

#ifndef __ITAgent_FWD_DEFINED__
#define __ITAgent_FWD_DEFINED__
typedef interface ITAgent ITAgent;
#endif 	/* __ITAgent_FWD_DEFINED__ */


#ifndef __ITAgentSession_FWD_DEFINED__
#define __ITAgentSession_FWD_DEFINED__
typedef interface ITAgentSession ITAgentSession;
#endif 	/* __ITAgentSession_FWD_DEFINED__ */


#ifndef __ITACDGroup_FWD_DEFINED__
#define __ITACDGroup_FWD_DEFINED__
typedef interface ITACDGroup ITACDGroup;
#endif 	/* __ITACDGroup_FWD_DEFINED__ */


#ifndef __ITQueue_FWD_DEFINED__
#define __ITQueue_FWD_DEFINED__
typedef interface ITQueue ITQueue;
#endif 	/* __ITQueue_FWD_DEFINED__ */


#ifndef __ITAgentEvent_FWD_DEFINED__
#define __ITAgentEvent_FWD_DEFINED__
typedef interface ITAgentEvent ITAgentEvent;
#endif 	/* __ITAgentEvent_FWD_DEFINED__ */


#ifndef __ITAgentSessionEvent_FWD_DEFINED__
#define __ITAgentSessionEvent_FWD_DEFINED__
typedef interface ITAgentSessionEvent ITAgentSessionEvent;
#endif 	/* __ITAgentSessionEvent_FWD_DEFINED__ */


#ifndef __ITACDGroupEvent_FWD_DEFINED__
#define __ITACDGroupEvent_FWD_DEFINED__
typedef interface ITACDGroupEvent ITACDGroupEvent;
#endif 	/* __ITACDGroupEvent_FWD_DEFINED__ */


#ifndef __ITQueueEvent_FWD_DEFINED__
#define __ITQueueEvent_FWD_DEFINED__
typedef interface ITQueueEvent ITQueueEvent;
#endif 	/* __ITQueueEvent_FWD_DEFINED__ */


#ifndef __ITAgentHandlerEvent_FWD_DEFINED__
#define __ITAgentHandlerEvent_FWD_DEFINED__
typedef interface ITAgentHandlerEvent ITAgentHandlerEvent;
#endif 	/* __ITAgentHandlerEvent_FWD_DEFINED__ */


#ifndef __ITTAPICallCenter_FWD_DEFINED__
#define __ITTAPICallCenter_FWD_DEFINED__
typedef interface ITTAPICallCenter ITTAPICallCenter;
#endif 	/* __ITTAPICallCenter_FWD_DEFINED__ */


#ifndef __ITAgentHandler_FWD_DEFINED__
#define __ITAgentHandler_FWD_DEFINED__
typedef interface ITAgentHandler ITAgentHandler;
#endif 	/* __ITAgentHandler_FWD_DEFINED__ */


#ifndef __IEnumAgent_FWD_DEFINED__
#define __IEnumAgent_FWD_DEFINED__
typedef interface IEnumAgent IEnumAgent;
#endif 	/* __IEnumAgent_FWD_DEFINED__ */


#ifndef __IEnumAgentSession_FWD_DEFINED__
#define __IEnumAgentSession_FWD_DEFINED__
typedef interface IEnumAgentSession IEnumAgentSession;
#endif 	/* __IEnumAgentSession_FWD_DEFINED__ */


#ifndef __IEnumQueue_FWD_DEFINED__
#define __IEnumQueue_FWD_DEFINED__
typedef interface IEnumQueue IEnumQueue;
#endif 	/* __IEnumQueue_FWD_DEFINED__ */


#ifndef __IEnumACDGroup_FWD_DEFINED__
#define __IEnumACDGroup_FWD_DEFINED__
typedef interface IEnumACDGroup IEnumACDGroup;
#endif 	/* __IEnumACDGroup_FWD_DEFINED__ */


#ifndef __IEnumAgentHandler_FWD_DEFINED__
#define __IEnumAgentHandler_FWD_DEFINED__
typedef interface IEnumAgentHandler IEnumAgentHandler;
#endif 	/* __IEnumAgentHandler_FWD_DEFINED__ */


#ifndef __ITAMMediaFormat_FWD_DEFINED__
#define __ITAMMediaFormat_FWD_DEFINED__
typedef interface ITAMMediaFormat ITAMMediaFormat;
#endif 	/* __ITAMMediaFormat_FWD_DEFINED__ */


#ifndef __ITAllocatorProperties_FWD_DEFINED__
#define __ITAllocatorProperties_FWD_DEFINED__
typedef interface ITAllocatorProperties ITAllocatorProperties;
#endif 	/* __ITAllocatorProperties_FWD_DEFINED__ */


#ifndef __ITMSPAddress_FWD_DEFINED__
#define __ITMSPAddress_FWD_DEFINED__
typedef interface ITMSPAddress ITMSPAddress;
#endif 	/* __ITMSPAddress_FWD_DEFINED__ */


#ifndef __ITAgent_FWD_DEFINED__
#define __ITAgent_FWD_DEFINED__
typedef interface ITAgent ITAgent;
#endif 	/* __ITAgent_FWD_DEFINED__ */


#ifndef __ITAgentEvent_FWD_DEFINED__
#define __ITAgentEvent_FWD_DEFINED__
typedef interface ITAgentEvent ITAgentEvent;
#endif 	/* __ITAgentEvent_FWD_DEFINED__ */


#ifndef __ITAgentSession_FWD_DEFINED__
#define __ITAgentSession_FWD_DEFINED__
typedef interface ITAgentSession ITAgentSession;
#endif 	/* __ITAgentSession_FWD_DEFINED__ */


#ifndef __ITAgentSessionEvent_FWD_DEFINED__
#define __ITAgentSessionEvent_FWD_DEFINED__
typedef interface ITAgentSessionEvent ITAgentSessionEvent;
#endif 	/* __ITAgentSessionEvent_FWD_DEFINED__ */


#ifndef __ITACDGroup_FWD_DEFINED__
#define __ITACDGroup_FWD_DEFINED__
typedef interface ITACDGroup ITACDGroup;
#endif 	/* __ITACDGroup_FWD_DEFINED__ */


#ifndef __ITACDGroupEvent_FWD_DEFINED__
#define __ITACDGroupEvent_FWD_DEFINED__
typedef interface ITACDGroupEvent ITACDGroupEvent;
#endif 	/* __ITACDGroupEvent_FWD_DEFINED__ */


#ifndef __ITQueue_FWD_DEFINED__
#define __ITQueue_FWD_DEFINED__
typedef interface ITQueue ITQueue;
#endif 	/* __ITQueue_FWD_DEFINED__ */


#ifndef __ITQueueEvent_FWD_DEFINED__
#define __ITQueueEvent_FWD_DEFINED__
typedef interface ITQueueEvent ITQueueEvent;
#endif 	/* __ITQueueEvent_FWD_DEFINED__ */


#ifndef __ITTAPICallCenter_FWD_DEFINED__
#define __ITTAPICallCenter_FWD_DEFINED__
typedef interface ITTAPICallCenter ITTAPICallCenter;
#endif 	/* __ITTAPICallCenter_FWD_DEFINED__ */


#ifndef __ITAgentHandler_FWD_DEFINED__
#define __ITAgentHandler_FWD_DEFINED__
typedef interface ITAgentHandler ITAgentHandler;
#endif 	/* __ITAgentHandler_FWD_DEFINED__ */


#ifndef __ITAgentHandlerEvent_FWD_DEFINED__
#define __ITAgentHandlerEvent_FWD_DEFINED__
typedef interface ITAgentHandlerEvent ITAgentHandlerEvent;
#endif 	/* __ITAgentHandlerEvent_FWD_DEFINED__ */


#ifndef __ITTAPIDispatchEventNotification_FWD_DEFINED__
#define __ITTAPIDispatchEventNotification_FWD_DEFINED__
typedef interface ITTAPIDispatchEventNotification ITTAPIDispatchEventNotification;
#endif 	/* __ITTAPIDispatchEventNotification_FWD_DEFINED__ */


#ifndef __TAPI_FWD_DEFINED__
#define __TAPI_FWD_DEFINED__

#ifdef __cplusplus
typedef class TAPI TAPI;
#else
typedef struct TAPI TAPI;
#endif /* __cplusplus */

#endif 	/* __TAPI_FWD_DEFINED__ */


#ifndef __DispatchMapper_FWD_DEFINED__
#define __DispatchMapper_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispatchMapper DispatchMapper;
#else
typedef struct DispatchMapper DispatchMapper;
#endif /* __cplusplus */

#endif 	/* __DispatchMapper_FWD_DEFINED__ */


#ifndef __RequestMakeCall_FWD_DEFINED__
#define __RequestMakeCall_FWD_DEFINED__

#ifdef __cplusplus
typedef class RequestMakeCall RequestMakeCall;
#else
typedef struct RequestMakeCall RequestMakeCall;
#endif /* __cplusplus */

#endif 	/* __RequestMakeCall_FWD_DEFINED__ */


#ifndef __ITTAPIDispatchEventNotification_FWD_DEFINED__
#define __ITTAPIDispatchEventNotification_FWD_DEFINED__
typedef interface ITTAPIDispatchEventNotification ITTAPIDispatchEventNotification;
#endif 	/* __ITTAPIDispatchEventNotification_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "tapi3if.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_tapi3_0000 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */
/* Copyright (c) 1998-1999  Microsoft Corporation  */
typedef 
enum AGENT_EVENT
    {	AE_NOT_READY	= 0,
	AE_READY	= AE_NOT_READY + 1,
	AE_BUSY_ACD	= AE_READY + 1,
	AE_BUSY_INCOMING	= AE_BUSY_ACD + 1,
	AE_BUSY_OUTGOING	= AE_BUSY_INCOMING + 1,
	AE_UNKNOWN	= AE_BUSY_OUTGOING + 1
    }	AGENT_EVENT;

typedef 
enum AGENT_STATE
    {	AS_NOT_READY	= 0,
	AS_READY	= AS_NOT_READY + 1,
	AS_BUSY_ACD	= AS_READY + 1,
	AS_BUSY_INCOMING	= AS_BUSY_ACD + 1,
	AS_BUSY_OUTGOING	= AS_BUSY_INCOMING + 1,
	AS_UNKNOWN	= AS_BUSY_OUTGOING + 1
    }	AGENT_STATE;

typedef 
enum AGENT_SESSION_EVENT
    {	ASE_NEW_SESSION	= 0,
	ASE_NOT_READY	= ASE_NEW_SESSION + 1,
	ASE_READY	= ASE_NOT_READY + 1,
	ASE_BUSY	= ASE_READY + 1,
	ASE_WRAPUP	= ASE_BUSY + 1,
	ASE_END	= ASE_WRAPUP + 1
    }	AGENT_SESSION_EVENT;

typedef 
enum AGENT_SESSION_STATE
    {	ASST_NOT_READY	= 0,
	ASST_READY	= ASST_NOT_READY + 1,
	ASST_BUSY_ON_CALL	= ASST_READY + 1,
	ASST_BUSY_WRAPUP	= ASST_BUSY_ON_CALL + 1,
	ASST_SESSION_ENDED	= ASST_BUSY_WRAPUP + 1
    }	AGENT_SESSION_STATE;

typedef 
enum AGENTHANDLER_EVENT
    {	AHE_NEW_AGENTHANDLER	= 0,
	AHE_AGENTHANDLER_REMOVED	= AHE_NEW_AGENTHANDLER + 1
    }	AGENTHANDLER_EVENT;

typedef 
enum ACDGROUP_EVENT
    {	ACDGE_NEW_GROUP	= 0,
	ACDGE_GROUP_REMOVED	= ACDGE_NEW_GROUP + 1
    }	ACDGROUP_EVENT;

typedef 
enum ACDQUEUE_EVENT
    {	ACDQE_NEW_QUEUE	= 0,
	ACDQE_QUEUE_REMOVED	= ACDQE_NEW_QUEUE + 1
    }	ACDQUEUE_EVENT;


















extern RPC_IF_HANDLE __MIDL_itf_tapi3_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3_0000_v0_0_s_ifspec;

#ifndef __ITAgent_INTERFACE_DEFINED__
#define __ITAgent_INTERFACE_DEFINED__

/* interface ITAgent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5770ECE5-4B27-11d1-BF80-00805FC147D3")
    ITAgent : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAgentSessions( 
            /* [retval][out] */ IEnumAgentSession __RPC_FAR *__RPC_FAR *ppEnumAgentSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [in] */ ITACDGroup __RPC_FAR *pACDGroup,
            /* [in] */ ITAddress __RPC_FAR *pAddress,
            /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppAgentSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSessionWithPIN( 
            /* [in] */ ITACDGroup __RPC_FAR *pACDGroup,
            /* [in] */ ITAddress __RPC_FAR *pAddress,
            /* [in] */ BSTR pPIN,
            /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppAgentSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR __RPC_FAR *ppID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ BSTR __RPC_FAR *ppUser) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ AGENT_STATE AgentState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ AGENT_STATE __RPC_FAR *pAgentState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeasurementPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeasurementPeriod( 
            /* [retval][out] */ long __RPC_FAR *plPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OverallCallRate( 
            /* [retval][out] */ CURRENCY __RPC_FAR *pcyCallrate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfACDCalls( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfIncomingCalls( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfOutgoingCalls( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalACDTalkTime( 
            /* [retval][out] */ long __RPC_FAR *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalACDCallTime( 
            /* [retval][out] */ long __RPC_FAR *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalWrapUpTime( 
            /* [retval][out] */ long __RPC_FAR *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentSessions( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAgent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAgent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAgent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateAgentSessions )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ IEnumAgentSession __RPC_FAR *__RPC_FAR *ppEnumAgentSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSession )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ ITACDGroup __RPC_FAR *pACDGroup,
            /* [in] */ ITAddress __RPC_FAR *pAddress,
            /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppAgentSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSessionWithPIN )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ ITACDGroup __RPC_FAR *pACDGroup,
            /* [in] */ ITAddress __RPC_FAR *pAddress,
            /* [in] */ BSTR pPIN,
            /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppAgentSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ID )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_User )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppUser);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_State )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ AGENT_STATE AgentState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ AGENT_STATE __RPC_FAR *pAgentState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MeasurementPeriod )( 
            ITAgent __RPC_FAR * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MeasurementPeriod )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OverallCallRate )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ CURRENCY __RPC_FAR *pcyCallrate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfACDCalls )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfIncomingCalls )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfOutgoingCalls )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalACDTalkTime )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalACDCallTime )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalWrapUpTime )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AgentSessions )( 
            ITAgent __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITAgentVtbl;

    interface ITAgent
    {
        CONST_VTBL struct ITAgentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAgent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAgent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAgent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAgent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAgent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAgent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAgent_EnumerateAgentSessions(This,ppEnumAgentSession)	\
    (This)->lpVtbl -> EnumerateAgentSessions(This,ppEnumAgentSession)

#define ITAgent_CreateSession(This,pACDGroup,pAddress,ppAgentSession)	\
    (This)->lpVtbl -> CreateSession(This,pACDGroup,pAddress,ppAgentSession)

#define ITAgent_CreateSessionWithPIN(This,pACDGroup,pAddress,pPIN,ppAgentSession)	\
    (This)->lpVtbl -> CreateSessionWithPIN(This,pACDGroup,pAddress,pPIN,ppAgentSession)

#define ITAgent_get_ID(This,ppID)	\
    (This)->lpVtbl -> get_ID(This,ppID)

#define ITAgent_get_User(This,ppUser)	\
    (This)->lpVtbl -> get_User(This,ppUser)

#define ITAgent_put_State(This,AgentState)	\
    (This)->lpVtbl -> put_State(This,AgentState)

#define ITAgent_get_State(This,pAgentState)	\
    (This)->lpVtbl -> get_State(This,pAgentState)

#define ITAgent_put_MeasurementPeriod(This,lPeriod)	\
    (This)->lpVtbl -> put_MeasurementPeriod(This,lPeriod)

#define ITAgent_get_MeasurementPeriod(This,plPeriod)	\
    (This)->lpVtbl -> get_MeasurementPeriod(This,plPeriod)

#define ITAgent_get_OverallCallRate(This,pcyCallrate)	\
    (This)->lpVtbl -> get_OverallCallRate(This,pcyCallrate)

#define ITAgent_get_NumberOfACDCalls(This,plCalls)	\
    (This)->lpVtbl -> get_NumberOfACDCalls(This,plCalls)

#define ITAgent_get_NumberOfIncomingCalls(This,plCalls)	\
    (This)->lpVtbl -> get_NumberOfIncomingCalls(This,plCalls)

#define ITAgent_get_NumberOfOutgoingCalls(This,plCalls)	\
    (This)->lpVtbl -> get_NumberOfOutgoingCalls(This,plCalls)

#define ITAgent_get_TotalACDTalkTime(This,plTalkTime)	\
    (This)->lpVtbl -> get_TotalACDTalkTime(This,plTalkTime)

#define ITAgent_get_TotalACDCallTime(This,plCallTime)	\
    (This)->lpVtbl -> get_TotalACDCallTime(This,plCallTime)

#define ITAgent_get_TotalWrapUpTime(This,plWrapUpTime)	\
    (This)->lpVtbl -> get_TotalWrapUpTime(This,plWrapUpTime)

#define ITAgent_get_AgentSessions(This,pVariant)	\
    (This)->lpVtbl -> get_AgentSessions(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITAgent_EnumerateAgentSessions_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ IEnumAgentSession __RPC_FAR *__RPC_FAR *ppEnumAgentSession);


void __RPC_STUB ITAgent_EnumerateAgentSessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAgent_CreateSession_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [in] */ ITACDGroup __RPC_FAR *pACDGroup,
    /* [in] */ ITAddress __RPC_FAR *pAddress,
    /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppAgentSession);


void __RPC_STUB ITAgent_CreateSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAgent_CreateSessionWithPIN_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [in] */ ITACDGroup __RPC_FAR *pACDGroup,
    /* [in] */ ITAddress __RPC_FAR *pAddress,
    /* [in] */ BSTR pPIN,
    /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppAgentSession);


void __RPC_STUB ITAgent_CreateSessionWithPIN_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_ID_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppID);


void __RPC_STUB ITAgent_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_User_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppUser);


void __RPC_STUB ITAgent_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAgent_put_State_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [in] */ AGENT_STATE AgentState);


void __RPC_STUB ITAgent_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_State_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ AGENT_STATE __RPC_FAR *pAgentState);


void __RPC_STUB ITAgent_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAgent_put_MeasurementPeriod_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [in] */ long lPeriod);


void __RPC_STUB ITAgent_put_MeasurementPeriod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_MeasurementPeriod_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plPeriod);


void __RPC_STUB ITAgent_get_MeasurementPeriod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_OverallCallRate_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ CURRENCY __RPC_FAR *pcyCallrate);


void __RPC_STUB ITAgent_get_OverallCallRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_NumberOfACDCalls_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITAgent_get_NumberOfACDCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_NumberOfIncomingCalls_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITAgent_get_NumberOfIncomingCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_NumberOfOutgoingCalls_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITAgent_get_NumberOfOutgoingCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_TotalACDTalkTime_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTalkTime);


void __RPC_STUB ITAgent_get_TotalACDTalkTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_TotalACDCallTime_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallTime);


void __RPC_STUB ITAgent_get_TotalACDCallTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_TotalWrapUpTime_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWrapUpTime);


void __RPC_STUB ITAgent_get_TotalWrapUpTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgent_get_AgentSessions_Proxy( 
    ITAgent __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAgent_get_AgentSessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAgent_INTERFACE_DEFINED__ */


#ifndef __ITAgentSession_INTERFACE_DEFINED__
#define __ITAgentSession_INTERFACE_DEFINED__

/* interface ITAgentSession */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3147-4BCC-11d1-BF80-00805FC147D3")
    ITAgentSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Agent( 
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDGroup( 
            /* [retval][out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppACDGroup) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ AGENT_SESSION_STATE SessionState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ AGENT_SESSION_STATE __RPC_FAR *pSessionState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionStartTime( 
            /* [retval][out] */ DATE __RPC_FAR *pdateSessionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionDuration( 
            /* [retval][out] */ long __RPC_FAR *plDuration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfCalls( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalTalkTime( 
            /* [retval][out] */ long __RPC_FAR *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageTalkTime( 
            /* [retval][out] */ long __RPC_FAR *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallTime( 
            /* [retval][out] */ long __RPC_FAR *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageCallTime( 
            /* [retval][out] */ long __RPC_FAR *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalWrapUpTime( 
            /* [retval][out] */ long __RPC_FAR *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageWrapUpTime( 
            /* [retval][out] */ long __RPC_FAR *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDCallRate( 
            /* [retval][out] */ CURRENCY __RPC_FAR *pcyCallrate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongestTimeToAnswer( 
            /* [retval][out] */ long __RPC_FAR *plAnswerTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageTimeToAnswer( 
            /* [retval][out] */ long __RPC_FAR *plAnswerTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAgentSession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAgentSession __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAgentSession __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAgentSession __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAgentSession __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAgentSession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAgentSession __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Agent )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ACDGroup )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppACDGroup);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_State )( 
            ITAgentSession __RPC_FAR * This,
            /* [in] */ AGENT_SESSION_STATE SessionState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ AGENT_SESSION_STATE __RPC_FAR *pSessionState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionStartTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pdateSessionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionDuration )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plDuration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfCalls )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalTalkTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AverageTalkTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalCallTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AverageCallTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalWrapUpTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AverageWrapUpTime )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ACDCallRate )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ CURRENCY __RPC_FAR *pcyCallrate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LongestTimeToAnswer )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAnswerTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AverageTimeToAnswer )( 
            ITAgentSession __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAnswerTime);
        
        END_INTERFACE
    } ITAgentSessionVtbl;

    interface ITAgentSession
    {
        CONST_VTBL struct ITAgentSessionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAgentSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAgentSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAgentSession_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAgentSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAgentSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAgentSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAgentSession_get_Agent(This,ppAgent)	\
    (This)->lpVtbl -> get_Agent(This,ppAgent)

#define ITAgentSession_get_Address(This,ppAddress)	\
    (This)->lpVtbl -> get_Address(This,ppAddress)

#define ITAgentSession_get_ACDGroup(This,ppACDGroup)	\
    (This)->lpVtbl -> get_ACDGroup(This,ppACDGroup)

#define ITAgentSession_put_State(This,SessionState)	\
    (This)->lpVtbl -> put_State(This,SessionState)

#define ITAgentSession_get_State(This,pSessionState)	\
    (This)->lpVtbl -> get_State(This,pSessionState)

#define ITAgentSession_get_SessionStartTime(This,pdateSessionStart)	\
    (This)->lpVtbl -> get_SessionStartTime(This,pdateSessionStart)

#define ITAgentSession_get_SessionDuration(This,plDuration)	\
    (This)->lpVtbl -> get_SessionDuration(This,plDuration)

#define ITAgentSession_get_NumberOfCalls(This,plCalls)	\
    (This)->lpVtbl -> get_NumberOfCalls(This,plCalls)

#define ITAgentSession_get_TotalTalkTime(This,plTalkTime)	\
    (This)->lpVtbl -> get_TotalTalkTime(This,plTalkTime)

#define ITAgentSession_get_AverageTalkTime(This,plTalkTime)	\
    (This)->lpVtbl -> get_AverageTalkTime(This,plTalkTime)

#define ITAgentSession_get_TotalCallTime(This,plCallTime)	\
    (This)->lpVtbl -> get_TotalCallTime(This,plCallTime)

#define ITAgentSession_get_AverageCallTime(This,plCallTime)	\
    (This)->lpVtbl -> get_AverageCallTime(This,plCallTime)

#define ITAgentSession_get_TotalWrapUpTime(This,plWrapUpTime)	\
    (This)->lpVtbl -> get_TotalWrapUpTime(This,plWrapUpTime)

#define ITAgentSession_get_AverageWrapUpTime(This,plWrapUpTime)	\
    (This)->lpVtbl -> get_AverageWrapUpTime(This,plWrapUpTime)

#define ITAgentSession_get_ACDCallRate(This,pcyCallrate)	\
    (This)->lpVtbl -> get_ACDCallRate(This,pcyCallrate)

#define ITAgentSession_get_LongestTimeToAnswer(This,plAnswerTime)	\
    (This)->lpVtbl -> get_LongestTimeToAnswer(This,plAnswerTime)

#define ITAgentSession_get_AverageTimeToAnswer(This,plAnswerTime)	\
    (This)->lpVtbl -> get_AverageTimeToAnswer(This,plAnswerTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_Agent_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);


void __RPC_STUB ITAgentSession_get_Agent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_Address_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB ITAgentSession_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_ACDGroup_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppACDGroup);


void __RPC_STUB ITAgentSession_get_ACDGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAgentSession_put_State_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [in] */ AGENT_SESSION_STATE SessionState);


void __RPC_STUB ITAgentSession_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_State_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ AGENT_SESSION_STATE __RPC_FAR *pSessionState);


void __RPC_STUB ITAgentSession_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_SessionStartTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pdateSessionStart);


void __RPC_STUB ITAgentSession_get_SessionStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_SessionDuration_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plDuration);


void __RPC_STUB ITAgentSession_get_SessionDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_NumberOfCalls_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITAgentSession_get_NumberOfCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_TotalTalkTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTalkTime);


void __RPC_STUB ITAgentSession_get_TotalTalkTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_AverageTalkTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTalkTime);


void __RPC_STUB ITAgentSession_get_AverageTalkTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_TotalCallTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallTime);


void __RPC_STUB ITAgentSession_get_TotalCallTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_AverageCallTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallTime);


void __RPC_STUB ITAgentSession_get_AverageCallTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_TotalWrapUpTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWrapUpTime);


void __RPC_STUB ITAgentSession_get_TotalWrapUpTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_AverageWrapUpTime_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWrapUpTime);


void __RPC_STUB ITAgentSession_get_AverageWrapUpTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_ACDCallRate_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ CURRENCY __RPC_FAR *pcyCallrate);


void __RPC_STUB ITAgentSession_get_ACDCallRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_LongestTimeToAnswer_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAnswerTime);


void __RPC_STUB ITAgentSession_get_LongestTimeToAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSession_get_AverageTimeToAnswer_Proxy( 
    ITAgentSession __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAnswerTime);


void __RPC_STUB ITAgentSession_get_AverageTimeToAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAgentSession_INTERFACE_DEFINED__ */


#ifndef __ITACDGroup_INTERFACE_DEFINED__
#define __ITACDGroup_INTERFACE_DEFINED__

/* interface ITACDGroup */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITACDGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3148-4BCC-11d1-BF80-00805FC147D3")
    ITACDGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateQueues( 
            /* [retval][out] */ IEnumQueue __RPC_FAR *__RPC_FAR *ppEnumQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Queues( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITACDGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITACDGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITACDGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITACDGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITACDGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITACDGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITACDGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITACDGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ITACDGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateQueues )( 
            ITACDGroup __RPC_FAR * This,
            /* [retval][out] */ IEnumQueue __RPC_FAR *__RPC_FAR *ppEnumQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Queues )( 
            ITACDGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITACDGroupVtbl;

    interface ITACDGroup
    {
        CONST_VTBL struct ITACDGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITACDGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITACDGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITACDGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITACDGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITACDGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITACDGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITACDGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITACDGroup_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITACDGroup_EnumerateQueues(This,ppEnumQueue)	\
    (This)->lpVtbl -> EnumerateQueues(This,ppEnumQueue)

#define ITACDGroup_get_Queues(This,pVariant)	\
    (This)->lpVtbl -> get_Queues(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITACDGroup_get_Name_Proxy( 
    ITACDGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITACDGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITACDGroup_EnumerateQueues_Proxy( 
    ITACDGroup __RPC_FAR * This,
    /* [retval][out] */ IEnumQueue __RPC_FAR *__RPC_FAR *ppEnumQueue);


void __RPC_STUB ITACDGroup_EnumerateQueues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITACDGroup_get_Queues_Proxy( 
    ITACDGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITACDGroup_get_Queues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITACDGroup_INTERFACE_DEFINED__ */


#ifndef __ITQueue_INTERFACE_DEFINED__
#define __ITQueue_INTERFACE_DEFINED__

/* interface ITQueue */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3149-4BCC-11d1-BF80-00805FC147D3")
    ITQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeasurementPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeasurementPeriod( 
            /* [retval][out] */ long __RPC_FAR *plPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsQueued( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCallsQueued( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsAbandoned( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsFlowedIn( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsFlowedOut( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongestEverWaitTime( 
            /* [retval][out] */ long __RPC_FAR *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentLongestWaitTime( 
            /* [retval][out] */ long __RPC_FAR *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageWaitTime( 
            /* [retval][out] */ long __RPC_FAR *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FinalDisposition( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITQueue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITQueue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITQueue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITQueue __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITQueue __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITQueue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITQueue __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MeasurementPeriod )( 
            ITQueue __RPC_FAR * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MeasurementPeriod )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalCallsQueued )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentCallsQueued )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalCallsAbandoned )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalCallsFlowedIn )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalCallsFlowedOut )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LongestEverWaitTime )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentLongestWaitTime )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AverageWaitTime )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinalDisposition )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ITQueue __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        END_INTERFACE
    } ITQueueVtbl;

    interface ITQueue
    {
        CONST_VTBL struct ITQueueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITQueue_put_MeasurementPeriod(This,lPeriod)	\
    (This)->lpVtbl -> put_MeasurementPeriod(This,lPeriod)

#define ITQueue_get_MeasurementPeriod(This,plPeriod)	\
    (This)->lpVtbl -> get_MeasurementPeriod(This,plPeriod)

#define ITQueue_get_TotalCallsQueued(This,plCalls)	\
    (This)->lpVtbl -> get_TotalCallsQueued(This,plCalls)

#define ITQueue_get_CurrentCallsQueued(This,plCalls)	\
    (This)->lpVtbl -> get_CurrentCallsQueued(This,plCalls)

#define ITQueue_get_TotalCallsAbandoned(This,plCalls)	\
    (This)->lpVtbl -> get_TotalCallsAbandoned(This,plCalls)

#define ITQueue_get_TotalCallsFlowedIn(This,plCalls)	\
    (This)->lpVtbl -> get_TotalCallsFlowedIn(This,plCalls)

#define ITQueue_get_TotalCallsFlowedOut(This,plCalls)	\
    (This)->lpVtbl -> get_TotalCallsFlowedOut(This,plCalls)

#define ITQueue_get_LongestEverWaitTime(This,plWaitTime)	\
    (This)->lpVtbl -> get_LongestEverWaitTime(This,plWaitTime)

#define ITQueue_get_CurrentLongestWaitTime(This,plWaitTime)	\
    (This)->lpVtbl -> get_CurrentLongestWaitTime(This,plWaitTime)

#define ITQueue_get_AverageWaitTime(This,plWaitTime)	\
    (This)->lpVtbl -> get_AverageWaitTime(This,plWaitTime)

#define ITQueue_get_FinalDisposition(This,plCalls)	\
    (This)->lpVtbl -> get_FinalDisposition(This,plCalls)

#define ITQueue_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITQueue_put_MeasurementPeriod_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [in] */ long lPeriod);


void __RPC_STUB ITQueue_put_MeasurementPeriod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_MeasurementPeriod_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plPeriod);


void __RPC_STUB ITQueue_get_MeasurementPeriod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_TotalCallsQueued_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITQueue_get_TotalCallsQueued_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_CurrentCallsQueued_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITQueue_get_CurrentCallsQueued_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_TotalCallsAbandoned_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITQueue_get_TotalCallsAbandoned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_TotalCallsFlowedIn_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITQueue_get_TotalCallsFlowedIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_TotalCallsFlowedOut_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITQueue_get_TotalCallsFlowedOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_LongestEverWaitTime_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWaitTime);


void __RPC_STUB ITQueue_get_LongestEverWaitTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_CurrentLongestWaitTime_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWaitTime);


void __RPC_STUB ITQueue_get_CurrentLongestWaitTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_AverageWaitTime_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plWaitTime);


void __RPC_STUB ITQueue_get_AverageWaitTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_FinalDisposition_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITQueue_get_FinalDisposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueue_get_Name_Proxy( 
    ITQueue __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITQueue_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITQueue_INTERFACE_DEFINED__ */


#ifndef __ITAgentEvent_INTERFACE_DEFINED__
#define __ITAgentEvent_INTERFACE_DEFINED__

/* interface ITAgentEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314A-4BCC-11d1-BF80-00805FC147D3")
    ITAgentEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Agent( 
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ AGENT_EVENT __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAgentEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAgentEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAgentEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAgentEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAgentEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAgentEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAgentEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Agent )( 
            ITAgentEvent __RPC_FAR * This,
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITAgentEvent __RPC_FAR * This,
            /* [retval][out] */ AGENT_EVENT __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITAgentEventVtbl;

    interface ITAgentEvent
    {
        CONST_VTBL struct ITAgentEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAgentEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAgentEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAgentEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAgentEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAgentEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAgentEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAgentEvent_get_Agent(This,ppAgent)	\
    (This)->lpVtbl -> get_Agent(This,ppAgent)

#define ITAgentEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentEvent_get_Agent_Proxy( 
    ITAgentEvent __RPC_FAR * This,
    /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);


void __RPC_STUB ITAgentEvent_get_Agent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentEvent_get_Event_Proxy( 
    ITAgentEvent __RPC_FAR * This,
    /* [retval][out] */ AGENT_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITAgentEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAgentEvent_INTERFACE_DEFINED__ */


#ifndef __ITAgentSessionEvent_INTERFACE_DEFINED__
#define __ITAgentSessionEvent_INTERFACE_DEFINED__

/* interface ITAgentSessionEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentSessionEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314B-4BCC-11d1-BF80-00805FC147D3")
    ITAgentSessionEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ AGENT_SESSION_EVENT __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentSessionEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAgentSessionEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAgentSessionEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITAgentSessionEvent __RPC_FAR * This,
            /* [retval][out] */ AGENT_SESSION_EVENT __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITAgentSessionEventVtbl;

    interface ITAgentSessionEvent
    {
        CONST_VTBL struct ITAgentSessionEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentSessionEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAgentSessionEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAgentSessionEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAgentSessionEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAgentSessionEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAgentSessionEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAgentSessionEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAgentSessionEvent_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define ITAgentSessionEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSessionEvent_get_Session_Proxy( 
    ITAgentSessionEvent __RPC_FAR * This,
    /* [retval][out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB ITAgentSessionEvent_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentSessionEvent_get_Event_Proxy( 
    ITAgentSessionEvent __RPC_FAR * This,
    /* [retval][out] */ AGENT_SESSION_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITAgentSessionEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAgentSessionEvent_INTERFACE_DEFINED__ */


#ifndef __ITACDGroupEvent_INTERFACE_DEFINED__
#define __ITACDGroupEvent_INTERFACE_DEFINED__

/* interface ITACDGroupEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITACDGroupEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3032-BD11-11d1-A0A7-00805FC147D3")
    ITACDGroupEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [retval][out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppGroup) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ ACDGROUP_EVENT __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITACDGroupEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITACDGroupEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITACDGroupEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Group )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [retval][out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppGroup);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITACDGroupEvent __RPC_FAR * This,
            /* [retval][out] */ ACDGROUP_EVENT __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITACDGroupEventVtbl;

    interface ITACDGroupEvent
    {
        CONST_VTBL struct ITACDGroupEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITACDGroupEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITACDGroupEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITACDGroupEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITACDGroupEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITACDGroupEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITACDGroupEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITACDGroupEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITACDGroupEvent_get_Group(This,ppGroup)	\
    (This)->lpVtbl -> get_Group(This,ppGroup)

#define ITACDGroupEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITACDGroupEvent_get_Group_Proxy( 
    ITACDGroupEvent __RPC_FAR * This,
    /* [retval][out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppGroup);


void __RPC_STUB ITACDGroupEvent_get_Group_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITACDGroupEvent_get_Event_Proxy( 
    ITACDGroupEvent __RPC_FAR * This,
    /* [retval][out] */ ACDGROUP_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITACDGroupEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITACDGroupEvent_INTERFACE_DEFINED__ */


#ifndef __ITQueueEvent_INTERFACE_DEFINED__
#define __ITQueueEvent_INTERFACE_DEFINED__

/* interface ITQueueEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQueueEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3033-BD11-11d1-A0A7-00805FC147D3")
    ITQueueEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Queue( 
            /* [retval][out] */ ITQueue __RPC_FAR *__RPC_FAR *ppQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ ACDQUEUE_EVENT __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQueueEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITQueueEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITQueueEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITQueueEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITQueueEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITQueueEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITQueueEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITQueueEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Queue )( 
            ITQueueEvent __RPC_FAR * This,
            /* [retval][out] */ ITQueue __RPC_FAR *__RPC_FAR *ppQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITQueueEvent __RPC_FAR * This,
            /* [retval][out] */ ACDQUEUE_EVENT __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITQueueEventVtbl;

    interface ITQueueEvent
    {
        CONST_VTBL struct ITQueueEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQueueEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITQueueEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITQueueEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITQueueEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITQueueEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITQueueEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITQueueEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITQueueEvent_get_Queue(This,ppQueue)	\
    (This)->lpVtbl -> get_Queue(This,ppQueue)

#define ITQueueEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueueEvent_get_Queue_Proxy( 
    ITQueueEvent __RPC_FAR * This,
    /* [retval][out] */ ITQueue __RPC_FAR *__RPC_FAR *ppQueue);


void __RPC_STUB ITQueueEvent_get_Queue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQueueEvent_get_Event_Proxy( 
    ITQueueEvent __RPC_FAR * This,
    /* [retval][out] */ ACDQUEUE_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITQueueEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITQueueEvent_INTERFACE_DEFINED__ */


#ifndef __ITAgentHandlerEvent_INTERFACE_DEFINED__
#define __ITAgentHandlerEvent_INTERFACE_DEFINED__

/* interface ITAgentHandlerEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentHandlerEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3034-BD11-11d1-A0A7-00805FC147D3")
    ITAgentHandlerEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentHandler( 
            /* [retval][out] */ ITAgentHandler __RPC_FAR *__RPC_FAR *ppAgentHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ AGENTHANDLER_EVENT __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentHandlerEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAgentHandlerEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAgentHandlerEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AgentHandler )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [retval][out] */ ITAgentHandler __RPC_FAR *__RPC_FAR *ppAgentHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITAgentHandlerEvent __RPC_FAR * This,
            /* [retval][out] */ AGENTHANDLER_EVENT __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITAgentHandlerEventVtbl;

    interface ITAgentHandlerEvent
    {
        CONST_VTBL struct ITAgentHandlerEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentHandlerEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAgentHandlerEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAgentHandlerEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAgentHandlerEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAgentHandlerEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAgentHandlerEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAgentHandlerEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAgentHandlerEvent_get_AgentHandler(This,ppAgentHandler)	\
    (This)->lpVtbl -> get_AgentHandler(This,ppAgentHandler)

#define ITAgentHandlerEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentHandlerEvent_get_AgentHandler_Proxy( 
    ITAgentHandlerEvent __RPC_FAR * This,
    /* [retval][out] */ ITAgentHandler __RPC_FAR *__RPC_FAR *ppAgentHandler);


void __RPC_STUB ITAgentHandlerEvent_get_AgentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentHandlerEvent_get_Event_Proxy( 
    ITAgentHandlerEvent __RPC_FAR * This,
    /* [retval][out] */ AGENTHANDLER_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITAgentHandlerEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAgentHandlerEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPICallCenter_INTERFACE_DEFINED__
#define __ITTAPICallCenter_INTERFACE_DEFINED__

/* interface ITTAPICallCenter */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPICallCenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3154-4BCC-11d1-BF80-00805FC147D3")
    ITTAPICallCenter : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAgentHandlers( 
            /* [retval][out] */ IEnumAgentHandler __RPC_FAR *__RPC_FAR *ppEnumHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentHandlers( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPICallCenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTAPICallCenter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTAPICallCenter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateAgentHandlers )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [retval][out] */ IEnumAgentHandler __RPC_FAR *__RPC_FAR *ppEnumHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AgentHandlers )( 
            ITTAPICallCenter __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITTAPICallCenterVtbl;

    interface ITTAPICallCenter
    {
        CONST_VTBL struct ITTAPICallCenterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPICallCenter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTAPICallCenter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTAPICallCenter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTAPICallCenter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTAPICallCenter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTAPICallCenter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTAPICallCenter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTAPICallCenter_EnumerateAgentHandlers(This,ppEnumHandler)	\
    (This)->lpVtbl -> EnumerateAgentHandlers(This,ppEnumHandler)

#define ITTAPICallCenter_get_AgentHandlers(This,pVariant)	\
    (This)->lpVtbl -> get_AgentHandlers(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITTAPICallCenter_EnumerateAgentHandlers_Proxy( 
    ITTAPICallCenter __RPC_FAR * This,
    /* [retval][out] */ IEnumAgentHandler __RPC_FAR *__RPC_FAR *ppEnumHandler);


void __RPC_STUB ITTAPICallCenter_EnumerateAgentHandlers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPICallCenter_get_AgentHandlers_Proxy( 
    ITTAPICallCenter __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITTAPICallCenter_get_AgentHandlers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTAPICallCenter_INTERFACE_DEFINED__ */


#ifndef __ITAgentHandler_INTERFACE_DEFINED__
#define __ITAgentHandler_INTERFACE_DEFINED__

/* interface ITAgentHandler */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587E8C22-9802-11d1-A0A4-00805FC147D3")
    ITAgentHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAgent( 
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAgentWithID( 
            /* [in] */ BSTR pID,
            /* [in] */ BSTR pPIN,
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateACDGroups( 
            /* [retval][out] */ IEnumACDGroup __RPC_FAR *__RPC_FAR *ppEnumACDGroup) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateUsableAddresses( 
            /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnumAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDGroups( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsableAddresses( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAgentHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAgentHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAgentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAgentHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAgentHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAgentHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAgentHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ITAgentHandler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAgent )( 
            ITAgentHandler __RPC_FAR * This,
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAgentWithID )( 
            ITAgentHandler __RPC_FAR * This,
            /* [in] */ BSTR pID,
            /* [in] */ BSTR pPIN,
            /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateACDGroups )( 
            ITAgentHandler __RPC_FAR * This,
            /* [retval][out] */ IEnumACDGroup __RPC_FAR *__RPC_FAR *ppEnumACDGroup);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateUsableAddresses )( 
            ITAgentHandler __RPC_FAR * This,
            /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnumAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ACDGroups )( 
            ITAgentHandler __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UsableAddresses )( 
            ITAgentHandler __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITAgentHandlerVtbl;

    interface ITAgentHandler
    {
        CONST_VTBL struct ITAgentHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAgentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAgentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAgentHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAgentHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAgentHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAgentHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAgentHandler_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITAgentHandler_CreateAgent(This,ppAgent)	\
    (This)->lpVtbl -> CreateAgent(This,ppAgent)

#define ITAgentHandler_CreateAgentWithID(This,pID,pPIN,ppAgent)	\
    (This)->lpVtbl -> CreateAgentWithID(This,pID,pPIN,ppAgent)

#define ITAgentHandler_EnumerateACDGroups(This,ppEnumACDGroup)	\
    (This)->lpVtbl -> EnumerateACDGroups(This,ppEnumACDGroup)

#define ITAgentHandler_EnumerateUsableAddresses(This,ppEnumAddress)	\
    (This)->lpVtbl -> EnumerateUsableAddresses(This,ppEnumAddress)

#define ITAgentHandler_get_ACDGroups(This,pVariant)	\
    (This)->lpVtbl -> get_ACDGroups(This,pVariant)

#define ITAgentHandler_get_UsableAddresses(This,pVariant)	\
    (This)->lpVtbl -> get_UsableAddresses(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_get_Name_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITAgentHandler_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_CreateAgent_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);


void __RPC_STUB ITAgentHandler_CreateAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_CreateAgentWithID_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [in] */ BSTR pID,
    /* [in] */ BSTR pPIN,
    /* [retval][out] */ ITAgent __RPC_FAR *__RPC_FAR *ppAgent);


void __RPC_STUB ITAgentHandler_CreateAgentWithID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_EnumerateACDGroups_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [retval][out] */ IEnumACDGroup __RPC_FAR *__RPC_FAR *ppEnumACDGroup);


void __RPC_STUB ITAgentHandler_EnumerateACDGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_EnumerateUsableAddresses_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnumAddress);


void __RPC_STUB ITAgentHandler_EnumerateUsableAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_get_ACDGroups_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAgentHandler_get_ACDGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAgentHandler_get_UsableAddresses_Proxy( 
    ITAgentHandler __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAgentHandler_get_UsableAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAgentHandler_INTERFACE_DEFINED__ */


#ifndef __IEnumAgent_INTERFACE_DEFINED__
#define __IEnumAgent_INTERFACE_DEFINED__

/* interface IEnumAgent */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314D-4BCC-11d1-BF80-00805FC147D3")
    IEnumAgent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITAgent __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumAgent __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumAgent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumAgent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumAgent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumAgent __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITAgent __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumAgent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumAgent __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumAgent __RPC_FAR * This,
            /* [retval][out] */ IEnumAgent __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumAgentVtbl;

    interface IEnumAgent
    {
        CONST_VTBL struct IEnumAgentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAgent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAgent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAgent_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumAgent_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAgent_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumAgent_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAgent_Next_Proxy( 
    IEnumAgent __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITAgent __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumAgent_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgent_Reset_Proxy( 
    IEnumAgent __RPC_FAR * This);


void __RPC_STUB IEnumAgent_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgent_Skip_Proxy( 
    IEnumAgent __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumAgent_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgent_Clone_Proxy( 
    IEnumAgent __RPC_FAR * This,
    /* [retval][out] */ IEnumAgent __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumAgent_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAgent_INTERFACE_DEFINED__ */


#ifndef __IEnumAgentSession_INTERFACE_DEFINED__
#define __IEnumAgentSession_INTERFACE_DEFINED__

/* interface IEnumAgentSession */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgentSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314E-4BCC-11d1-BF80-00805FC147D3")
    IEnumAgentSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumAgentSession __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumAgentSession __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumAgentSession __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumAgentSession __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumAgentSession __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumAgentSession __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumAgentSession __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumAgentSession __RPC_FAR * This,
            /* [retval][out] */ IEnumAgentSession __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumAgentSessionVtbl;

    interface IEnumAgentSession
    {
        CONST_VTBL struct IEnumAgentSessionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgentSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAgentSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAgentSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAgentSession_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumAgentSession_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAgentSession_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumAgentSession_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAgentSession_Next_Proxy( 
    IEnumAgentSession __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITAgentSession __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumAgentSession_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgentSession_Reset_Proxy( 
    IEnumAgentSession __RPC_FAR * This);


void __RPC_STUB IEnumAgentSession_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgentSession_Skip_Proxy( 
    IEnumAgentSession __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumAgentSession_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgentSession_Clone_Proxy( 
    IEnumAgentSession __RPC_FAR * This,
    /* [retval][out] */ IEnumAgentSession __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumAgentSession_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAgentSession_INTERFACE_DEFINED__ */


#ifndef __IEnumQueue_INTERFACE_DEFINED__
#define __IEnumQueue_INTERFACE_DEFINED__

/* interface IEnumQueue */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3158-4BCC-11d1-BF80-00805FC147D3")
    IEnumQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITQueue __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumQueue __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumQueue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumQueue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumQueue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumQueue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITQueue __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumQueue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumQueue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumQueue __RPC_FAR * This,
            /* [retval][out] */ IEnumQueue __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumQueueVtbl;

    interface IEnumQueue
    {
        CONST_VTBL struct IEnumQueueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumQueue_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumQueue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumQueue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumQueue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumQueue_Next_Proxy( 
    IEnumQueue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITQueue __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumQueue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumQueue_Reset_Proxy( 
    IEnumQueue __RPC_FAR * This);


void __RPC_STUB IEnumQueue_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumQueue_Skip_Proxy( 
    IEnumQueue __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumQueue_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumQueue_Clone_Proxy( 
    IEnumQueue __RPC_FAR * This,
    /* [retval][out] */ IEnumQueue __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumQueue_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumQueue_INTERFACE_DEFINED__ */


#ifndef __IEnumACDGroup_INTERFACE_DEFINED__
#define __IEnumACDGroup_INTERFACE_DEFINED__

/* interface IEnumACDGroup */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumACDGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3157-4BCC-11d1-BF80-00805FC147D3")
    IEnumACDGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumACDGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumACDGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumACDGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumACDGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumACDGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumACDGroup __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumACDGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumACDGroup __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumACDGroup __RPC_FAR * This,
            /* [retval][out] */ IEnumACDGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumACDGroupVtbl;

    interface IEnumACDGroup
    {
        CONST_VTBL struct IEnumACDGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumACDGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumACDGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumACDGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumACDGroup_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumACDGroup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumACDGroup_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumACDGroup_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumACDGroup_Next_Proxy( 
    IEnumACDGroup __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITACDGroup __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumACDGroup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumACDGroup_Reset_Proxy( 
    IEnumACDGroup __RPC_FAR * This);


void __RPC_STUB IEnumACDGroup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumACDGroup_Skip_Proxy( 
    IEnumACDGroup __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumACDGroup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumACDGroup_Clone_Proxy( 
    IEnumACDGroup __RPC_FAR * This,
    /* [retval][out] */ IEnumACDGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumACDGroup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumACDGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumAgentHandler_INTERFACE_DEFINED__
#define __IEnumAgentHandler_INTERFACE_DEFINED__

/* interface IEnumAgentHandler */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587E8C28-9802-11d1-A0A4-00805FC147D3")
    IEnumAgentHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITAgentHandler __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumAgentHandler __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumAgentHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumAgentHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumAgentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumAgentHandler __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITAgentHandler __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumAgentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumAgentHandler __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumAgentHandler __RPC_FAR * This,
            /* [retval][out] */ IEnumAgentHandler __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumAgentHandlerVtbl;

    interface IEnumAgentHandler
    {
        CONST_VTBL struct IEnumAgentHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAgentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAgentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAgentHandler_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumAgentHandler_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAgentHandler_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumAgentHandler_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAgentHandler_Next_Proxy( 
    IEnumAgentHandler __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITAgentHandler __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumAgentHandler_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgentHandler_Reset_Proxy( 
    IEnumAgentHandler __RPC_FAR * This);


void __RPC_STUB IEnumAgentHandler_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgentHandler_Skip_Proxy( 
    IEnumAgentHandler __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumAgentHandler_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAgentHandler_Clone_Proxy( 
    IEnumAgentHandler __RPC_FAR * This,
    /* [retval][out] */ IEnumAgentHandler __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumAgentHandler_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAgentHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tapi3_0315 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */


extern RPC_IF_HANDLE __MIDL_itf_tapi3_0315_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3_0315_v0_0_s_ifspec;

#ifndef __ITAMMediaFormat_INTERFACE_DEFINED__
#define __ITAMMediaFormat_INTERFACE_DEFINED__

/* interface ITAMMediaFormat */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAMMediaFormat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0364EB00-4A77-11D1-A671-006097C9A2E8")
    ITAMMediaFormat : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaFormat( 
            /* [retval][out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppmt) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaFormat( 
            /* [in] */ const AM_MEDIA_TYPE __RPC_FAR *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAMMediaFormatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAMMediaFormat __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAMMediaFormat __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAMMediaFormat __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MediaFormat )( 
            ITAMMediaFormat __RPC_FAR * This,
            /* [retval][out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppmt);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MediaFormat )( 
            ITAMMediaFormat __RPC_FAR * This,
            /* [in] */ const AM_MEDIA_TYPE __RPC_FAR *pmt);
        
        END_INTERFACE
    } ITAMMediaFormatVtbl;

    interface ITAMMediaFormat
    {
        CONST_VTBL struct ITAMMediaFormatVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAMMediaFormat_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAMMediaFormat_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAMMediaFormat_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAMMediaFormat_get_MediaFormat(This,ppmt)	\
    (This)->lpVtbl -> get_MediaFormat(This,ppmt)

#define ITAMMediaFormat_put_MediaFormat(This,pmt)	\
    (This)->lpVtbl -> put_MediaFormat(This,pmt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAMMediaFormat_get_MediaFormat_Proxy( 
    ITAMMediaFormat __RPC_FAR * This,
    /* [retval][out] */ AM_MEDIA_TYPE __RPC_FAR *__RPC_FAR *ppmt);


void __RPC_STUB ITAMMediaFormat_get_MediaFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAMMediaFormat_put_MediaFormat_Proxy( 
    ITAMMediaFormat __RPC_FAR * This,
    /* [in] */ const AM_MEDIA_TYPE __RPC_FAR *pmt);


void __RPC_STUB ITAMMediaFormat_put_MediaFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAMMediaFormat_INTERFACE_DEFINED__ */


#ifndef __ITAllocatorProperties_INTERFACE_DEFINED__
#define __ITAllocatorProperties_INTERFACE_DEFINED__

/* interface ITAllocatorProperties */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAllocatorProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1BC3C90-BCFE-11D1-9745-00C04FD91AC0")
    ITAllocatorProperties : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAllocatorProperties( 
            /* [in] */ ALLOCATOR_PROPERTIES __RPC_FAR *pAllocProperties) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllocatorProperties( 
            /* [out] */ ALLOCATOR_PROPERTIES __RPC_FAR *pAllocProperties) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAllocateBuffers( 
            /* [in] */ BOOL bAllocBuffers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllocateBuffers( 
            /* [out] */ BOOL __RPC_FAR *pbAllocBuffers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetBufferSize( 
            /* [in] */ DWORD BufferSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBufferSize( 
            /* [out] */ DWORD __RPC_FAR *pBufferSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAllocatorPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAllocatorProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAllocatorProperties __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocatorProperties )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [in] */ ALLOCATOR_PROPERTIES __RPC_FAR *pAllocProperties);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocatorProperties )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [out] */ ALLOCATOR_PROPERTIES __RPC_FAR *pAllocProperties);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateBuffers )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [in] */ BOOL bAllocBuffers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateBuffers )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbAllocBuffers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferSize )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [in] */ DWORD BufferSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferSize )( 
            ITAllocatorProperties __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pBufferSize);
        
        END_INTERFACE
    } ITAllocatorPropertiesVtbl;

    interface ITAllocatorProperties
    {
        CONST_VTBL struct ITAllocatorPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAllocatorProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAllocatorProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAllocatorProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAllocatorProperties_SetAllocatorProperties(This,pAllocProperties)	\
    (This)->lpVtbl -> SetAllocatorProperties(This,pAllocProperties)

#define ITAllocatorProperties_GetAllocatorProperties(This,pAllocProperties)	\
    (This)->lpVtbl -> GetAllocatorProperties(This,pAllocProperties)

#define ITAllocatorProperties_SetAllocateBuffers(This,bAllocBuffers)	\
    (This)->lpVtbl -> SetAllocateBuffers(This,bAllocBuffers)

#define ITAllocatorProperties_GetAllocateBuffers(This,pbAllocBuffers)	\
    (This)->lpVtbl -> GetAllocateBuffers(This,pbAllocBuffers)

#define ITAllocatorProperties_SetBufferSize(This,BufferSize)	\
    (This)->lpVtbl -> SetBufferSize(This,BufferSize)

#define ITAllocatorProperties_GetBufferSize(This,pBufferSize)	\
    (This)->lpVtbl -> GetBufferSize(This,pBufferSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAllocatorProperties_SetAllocatorProperties_Proxy( 
    ITAllocatorProperties __RPC_FAR * This,
    /* [in] */ ALLOCATOR_PROPERTIES __RPC_FAR *pAllocProperties);


void __RPC_STUB ITAllocatorProperties_SetAllocatorProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAllocatorProperties_GetAllocatorProperties_Proxy( 
    ITAllocatorProperties __RPC_FAR * This,
    /* [out] */ ALLOCATOR_PROPERTIES __RPC_FAR *pAllocProperties);


void __RPC_STUB ITAllocatorProperties_GetAllocatorProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAllocatorProperties_SetAllocateBuffers_Proxy( 
    ITAllocatorProperties __RPC_FAR * This,
    /* [in] */ BOOL bAllocBuffers);


void __RPC_STUB ITAllocatorProperties_SetAllocateBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAllocatorProperties_GetAllocateBuffers_Proxy( 
    ITAllocatorProperties __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbAllocBuffers);


void __RPC_STUB ITAllocatorProperties_GetAllocateBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAllocatorProperties_SetBufferSize_Proxy( 
    ITAllocatorProperties __RPC_FAR * This,
    /* [in] */ DWORD BufferSize);


void __RPC_STUB ITAllocatorProperties_SetBufferSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAllocatorProperties_GetBufferSize_Proxy( 
    ITAllocatorProperties __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pBufferSize);


void __RPC_STUB ITAllocatorProperties_GetBufferSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAllocatorProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tapi3_0423 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */
typedef long __RPC_FAR *MSP_HANDLE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_tapi3_0423_0001
    {	ADDRESS_TERMINAL_AVAILABLE	= 0,
	ADDRESS_TERMINAL_UNAVAILABLE	= ADDRESS_TERMINAL_AVAILABLE + 1
    }	MSP_ADDRESS_EVENT;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_tapi3_0423_0002
    {	CALL_NEW_STREAM	= 0,
	CALL_STREAM_FAIL	= CALL_NEW_STREAM + 1,
	CALL_TERMINAL_FAIL	= CALL_STREAM_FAIL + 1,
	CALL_STREAM_NOT_USED	= CALL_TERMINAL_FAIL + 1,
	CALL_STREAM_ACTIVE	= CALL_STREAM_NOT_USED + 1,
	CALL_STREAM_INACTIVE	= CALL_STREAM_ACTIVE + 1
    }	MSP_CALL_EVENT;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_tapi3_0423_0003
    {	CALL_CAUSE_UNKNOWN	= 0,
	CALL_CAUSE_BAD_DEVICE	= CALL_CAUSE_UNKNOWN + 1,
	CALL_CAUSE_CONNECT_FAIL	= CALL_CAUSE_BAD_DEVICE + 1,
	CALL_CAUSE_LOCAL_REQUEST	= CALL_CAUSE_CONNECT_FAIL + 1,
	CALL_CAUSE_REMOTE_REQUEST	= CALL_CAUSE_LOCAL_REQUEST + 1,
	CALL_CAUSE_MEDIA_TIMEOUT	= CALL_CAUSE_REMOTE_REQUEST + 1,
	CALL_CAUSE_MEDIA_RECOVERED	= CALL_CAUSE_MEDIA_TIMEOUT + 1
    }	MSP_CALL_EVENT_CAUSE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_tapi3_0423_0004
    {	ME_ADDRESS_EVENT	= 0,
	ME_CALL_EVENT	= ME_ADDRESS_EVENT + 1,
	ME_TSP_DATA	= ME_CALL_EVENT + 1,
	ME_PRIVATE_EVENT	= ME_TSP_DATA + 1
    }	MSP_EVENT;

typedef /* [public] */ struct __MIDL___MIDL_itf_tapi3_0423_0005
    {
    DWORD dwSize;
    MSP_EVENT Event;
    MSP_HANDLE hCall;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ struct 
            {
            MSP_ADDRESS_EVENT Type;
            ITTerminal __RPC_FAR *pTerminal;
            }	MSP_ADDRESS_EVENT_INFO;
        /* [case()] */ struct 
            {
            MSP_CALL_EVENT Type;
            MSP_CALL_EVENT_CAUSE Cause;
            ITStream __RPC_FAR *pStream;
            ITTerminal __RPC_FAR *pTerminal;
            HRESULT hrError;
            }	MSP_CALL_EVENT_INFO;
        /* [case()] */ struct 
            {
            DWORD dwBufferSize;
            BYTE pBuffer[ 1 ];
            }	MSP_TSP_DATA;
        /* [case()] */ struct 
            {
            IDispatch __RPC_FAR *pEvent;
            long lEventCode;
            }	MSP_PRIVATE_EVENT_INFO;
        }	;
    }	MSP_EVENT_INFO;



extern RPC_IF_HANDLE __MIDL_itf_tapi3_0423_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3_0423_v0_0_s_ifspec;

#ifndef __ITMSPAddress_INTERFACE_DEFINED__
#define __ITMSPAddress_INTERFACE_DEFINED__

/* interface ITMSPAddress */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITMSPAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD600-3868-11D2-A045-00C04FB6809F")
    ITMSPAddress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ MSP_HANDLE hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMSPCall( 
            /* [in] */ MSP_HANDLE hCall,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD dwMediaType,
            /* [in] */ IUnknown __RPC_FAR *pOuterUnknown,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStreamControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShutdownMSPCall( 
            /* [in] */ IUnknown __RPC_FAR *pStreamControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveTSPData( 
            /* [in] */ IUnknown __RPC_FAR *pMSPCall,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][out][in] */ byte __RPC_FAR *pEventBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMSPAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITMSPAddress __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITMSPAddress __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITMSPAddress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ITMSPAddress __RPC_FAR * This,
            /* [in] */ MSP_HANDLE hEvent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Shutdown )( 
            ITMSPAddress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMSPCall )( 
            ITMSPAddress __RPC_FAR * This,
            /* [in] */ MSP_HANDLE hCall,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD dwMediaType,
            /* [in] */ IUnknown __RPC_FAR *pOuterUnknown,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStreamControl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownMSPCall )( 
            ITMSPAddress __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStreamControl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReceiveTSPData )( 
            ITMSPAddress __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pMSPCall,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEvent )( 
            ITMSPAddress __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][out][in] */ byte __RPC_FAR *pEventBuffer);
        
        END_INTERFACE
    } ITMSPAddressVtbl;

    interface ITMSPAddress
    {
        CONST_VTBL struct ITMSPAddressVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMSPAddress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITMSPAddress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITMSPAddress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITMSPAddress_Initialize(This,hEvent)	\
    (This)->lpVtbl -> Initialize(This,hEvent)

#define ITMSPAddress_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ITMSPAddress_CreateMSPCall(This,hCall,dwReserved,dwMediaType,pOuterUnknown,ppStreamControl)	\
    (This)->lpVtbl -> CreateMSPCall(This,hCall,dwReserved,dwMediaType,pOuterUnknown,ppStreamControl)

#define ITMSPAddress_ShutdownMSPCall(This,pStreamControl)	\
    (This)->lpVtbl -> ShutdownMSPCall(This,pStreamControl)

#define ITMSPAddress_ReceiveTSPData(This,pMSPCall,pBuffer,dwSize)	\
    (This)->lpVtbl -> ReceiveTSPData(This,pMSPCall,pBuffer,dwSize)

#define ITMSPAddress_GetEvent(This,pdwSize,pEventBuffer)	\
    (This)->lpVtbl -> GetEvent(This,pdwSize,pEventBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITMSPAddress_Initialize_Proxy( 
    ITMSPAddress __RPC_FAR * This,
    /* [in] */ MSP_HANDLE hEvent);


void __RPC_STUB ITMSPAddress_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITMSPAddress_Shutdown_Proxy( 
    ITMSPAddress __RPC_FAR * This);


void __RPC_STUB ITMSPAddress_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITMSPAddress_CreateMSPCall_Proxy( 
    ITMSPAddress __RPC_FAR * This,
    /* [in] */ MSP_HANDLE hCall,
    /* [in] */ DWORD dwReserved,
    /* [in] */ DWORD dwMediaType,
    /* [in] */ IUnknown __RPC_FAR *pOuterUnknown,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStreamControl);


void __RPC_STUB ITMSPAddress_CreateMSPCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITMSPAddress_ShutdownMSPCall_Proxy( 
    ITMSPAddress __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStreamControl);


void __RPC_STUB ITMSPAddress_ShutdownMSPCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITMSPAddress_ReceiveTSPData_Proxy( 
    ITMSPAddress __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pMSPCall,
    /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB ITMSPAddress_ReceiveTSPData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITMSPAddress_GetEvent_Proxy( 
    ITMSPAddress __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [size_is][out][in] */ byte __RPC_FAR *pEventBuffer);


void __RPC_STUB ITMSPAddress_GetEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITMSPAddress_INTERFACE_DEFINED__ */



#ifndef __TAPI3Lib_LIBRARY_DEFINED__
#define __TAPI3Lib_LIBRARY_DEFINED__

/* library TAPI3Lib */
/* [helpstring][version][uuid] */ 











































EXTERN_C const IID LIBID_TAPI3Lib;

#ifndef __ITTAPIDispatchEventNotification_DISPINTERFACE_DEFINED__
#define __ITTAPIDispatchEventNotification_DISPINTERFACE_DEFINED__

/* dispinterface ITTAPIDispatchEventNotification */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_ITTAPIDispatchEventNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("9f34325b-7e62-11d2-9457-00c04f8ec888")
    ITTAPIDispatchEventNotification : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIDispatchEventNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITTAPIDispatchEventNotification __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } ITTAPIDispatchEventNotificationVtbl;

    interface ITTAPIDispatchEventNotification
    {
        CONST_VTBL struct ITTAPIDispatchEventNotificationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPIDispatchEventNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTAPIDispatchEventNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTAPIDispatchEventNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTAPIDispatchEventNotification_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTAPIDispatchEventNotification_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTAPIDispatchEventNotification_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTAPIDispatchEventNotification_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ITTAPIDispatchEventNotification_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_TAPI;

#ifdef __cplusplus

class DECLSPEC_UUID("21D6D48E-A88B-11D0-83DD-00AA003CCABD")
TAPI;
#endif

EXTERN_C const CLSID CLSID_DispatchMapper;

#ifdef __cplusplus

class DECLSPEC_UUID("E9225296-C759-11d1-A02B-00C04FB6809F")
DispatchMapper;
#endif

EXTERN_C const CLSID CLSID_RequestMakeCall;

#ifdef __cplusplus

class DECLSPEC_UUID("AC48FFE0-F8C4-11d1-A030-00C04FB6809F")
RequestMakeCall;
#endif


#ifndef __TapiConstants_MODULE_DEFINED__
#define __TapiConstants_MODULE_DEFINED__


/* module TapiConstants */
/* [helpstring][dllname][uuid] */ 

const BSTR CLSID_String_VideoWindowTerm	=	L"{F7438990-D6EB-11D0-82A6-00AA00B5CA1B}";

const BSTR CLSID_String_VideoInputTerminal	=	L"{AAF578EC-DC70-11D0-8ED3-00C04FB6809F}";

const BSTR CLSID_String_HandsetTerminal	=	L"{AAF578EB-DC70-11D0-8ED3-00C04FB6809F}";

const BSTR CLSID_String_HeadsetTerminal	=	L"{AAF578ED-DC70-11D0-8ED3-00C04FB6809F}";

const BSTR CLSID_String_SpeakerphoneTerminal	=	L"{AAF578EE-DC70-11D0-8ED3-00C04FB6809F}";

const BSTR CLSID_String_MicrophoneTerminal	=	L"{AAF578EF-DC70-11D0-8ED3-00C04FB6809F}";

const BSTR CLSID_String_SpeakersTerminal	=	L"{AAF578F0-DC70-11D0-8ED3-00C04FB6809F}";

const BSTR CLSID_String_MediaStreamTerminal	=	L"{E2F7AEF7-4971-11D1-A671-006097C9A2E8}";

const BSTR TAPIPROTOCOL_String_PSTN	=	L"{831CE2D6-83B5-11D1-BB5C-00C04FB6809F}";

const BSTR TAPIPROTOCOL_String_H323	=	L"{831CE2D7-83B5-11D1-BB5C-00C04FB6809F}";

const BSTR TAPIPROTOCOL_String_Multicast	=	L"{831CE2D8-83B5-11D1-BB5C-00C04FB6809F}";

const long LINEADDRESSTYPE_PHONENUMBER	=	0x1;

const long LINEADDRESSTYPE_SDP	=	0x2;

const long LINEADDRESSTYPE_EMAILNAME	=	0x4;

const long LINEADDRESSTYPE_DOMAINNAME	=	0x8;

const long LINEADDRESSTYPE_IPADDRESS	=	0x10;

const long LINEDIGITMODE_PULSE	=	0x1;

const long LINEDIGITMODE_DTMF	=	0x2;

const long LINEDIGITMODE_DTMFEND	=	0x4;

const long TAPIMEDIATYPE_AUDIO	=	0x8;

const long TAPIMEDIATYPE_VIDEO	=	0x8000;

const long TAPIMEDIATYPE_DATAMODEM	=	0x10;

const long TAPIMEDIATYPE_G3FAX	=	0x20;

#endif /* __TapiConstants_MODULE_DEFINED__ */
#endif /* __TAPI3Lib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_tapi3_0427 */
/* [local] */ 

#define TAPI_CURRENT_VERSION 0x00030000
#include <tapi.h>
#include <tapi3err.h>


extern RPC_IF_HANDLE __MIDL_itf_tapi3_0427_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3_0427_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\external\include\tapi3err.h ===
/*****************************************************************************
*
* Copyright (c) 1998 - 1999  Microsoft Corporation
*
* Module Name:
*
*    tapi3err.h
*
* Abstract:
*
*    Error Notifications for TAPI 3.0
*
*****************************************************************************/

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __TAPI3ERR_H__
#define __TAPI3ERR_H__

//--------------------------------------------------------------------------
//     Core TAPI Error messages
//--------------------------------------------------------------------------

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: TAPI_E_NOTENOUGHMEMORY
//
// MessageText:
//
//  The buffer passed in to this method was not big enough.
//
#define TAPI_E_NOTENOUGHMEMORY           ((HRESULT)0x80040001L)

//
// MessageId: TAPI_E_NOITEMS
//
// MessageText:
//
//  No items exist that match the request.
//
#define TAPI_E_NOITEMS                   ((HRESULT)0x80040002L)

//
// MessageId: TAPI_E_NOTSUPPORTED
//
// MessageText:
//
//  This method is not supported.
//
#define TAPI_E_NOTSUPPORTED              ((HRESULT)0x80040003L)

//
// MessageId: TAPI_E_INVALIDMEDIATYPE
//
// MessageText:
//
//  The MEDIATYPE passed in to this method was invalid.
//
#define TAPI_E_INVALIDMEDIATYPE          ((HRESULT)0x80040004L)

//
// MessageId: TAPI_E_OPERATIONFAILED
//
// MessageText:
//
//  The operation failed for an unspecified reason.
//
#define TAPI_E_OPERATIONFAILED           ((HRESULT)0x80040005L)

//
// MessageId: TAPI_E_ALLOCATED
//
// MessageText:
//
//  The device is already in use.
//
#define TAPI_E_ALLOCATED                 ((HRESULT)0x80040006L)

//
// MessageId: TAPI_E_CALLUNAVAIL
//
// MessageText:
//
//  No call appearance available.
//
#define TAPI_E_CALLUNAVAIL               ((HRESULT)0x80040007L)

//
// MessageId: TAPI_E_COMPLETIONOVERRUN
//
// MessageText:
//
//  Too many call completions outstanding.
//
#define TAPI_E_COMPLETIONOVERRUN         ((HRESULT)0x80040008L)

//
// MessageId: TAPI_E_CONFERENCEFULL
//
// MessageText:
//
//  The conference is full.
//
#define TAPI_E_CONFERENCEFULL            ((HRESULT)0x80040009L)

//
// MessageId: TAPI_E_DIALMODIFIERNOTSUPPORTED
//
// MessageText:
//
//  The dial modifier is not supported.
//
#define TAPI_E_DIALMODIFIERNOTSUPPORTED  ((HRESULT)0x8004000AL)

//
// MessageId: TAPI_E_INUSE
//
// MessageText:
//
//  The device is already in use.
//
#define TAPI_E_INUSE                     ((HRESULT)0x8004000BL)

//
// MessageId: TAPI_E_INVALADDRESS
//
// MessageText:
//
//  The phone number is invalid or not properly formatted.
//
#define TAPI_E_INVALADDRESS              ((HRESULT)0x8004000CL)

//
// MessageId: TAPI_E_INVALADDRESSSTATE
//
// MessageText:
//
//  Operation not permitted in current address state.
//
#define TAPI_E_INVALADDRESSSTATE         ((HRESULT)0x8004000DL)

//
// MessageId: TAPI_E_INVALCALLPARAMS
//
// MessageText:
//
//  Invalid LINECALLPARAMS structure.
//
#define TAPI_E_INVALCALLPARAMS           ((HRESULT)0x8004000EL)

//
// MessageId: TAPI_E_INVALCALLPRIVILEGE
//
// MessageText:
//
//  Invalid call privilege.
//
#define TAPI_E_INVALCALLPRIVILEGE        ((HRESULT)0x8004000FL)

//
// MessageId: TAPI_E_INVALCALLSTATE
//
// MessageText:
//
//  Operation not permitted in current call state.
//
#define TAPI_E_INVALCALLSTATE            ((HRESULT)0x80040010L)

//
// MessageId: TAPI_E_INVALCARD
//
// MessageText:
//
//  Invalid calling card.
//
#define TAPI_E_INVALCARD                 ((HRESULT)0x80040011L)

//
// MessageId: TAPI_E_INVALCOMPLETIONID
//
// MessageText:
//
//  Invalid call completion ID.
//
#define TAPI_E_INVALCOMPLETIONID         ((HRESULT)0x80040012L)

//
// MessageId: TAPI_E_INVALCOUNTRYCODE
//
// MessageText:
//
//  Invalid country code.
//
#define TAPI_E_INVALCOUNTRYCODE          ((HRESULT)0x80040013L)

//
// MessageId: TAPI_E_INVALDEVICECLASS
//
// MessageText:
//
//  Invalid device class identifier
//
#define TAPI_E_INVALDEVICECLASS          ((HRESULT)0x80040014L)

//
// MessageId: TAPI_E_INVALDIALPARAMS
//
// MessageText:
//
//  Invalid dialing parameters
//
#define TAPI_E_INVALDIALPARAMS           ((HRESULT)0x80040015L)

//
// MessageId: TAPI_E_INVALDIGITS
//
// MessageText:
//
//  Invalid digits.
//
#define TAPI_E_INVALDIGITS               ((HRESULT)0x80040016L)

//
// MessageId: TAPI_E_INVALGROUPID
//
// MessageText:
//
//  Invalid group pickup ID.
//
#define TAPI_E_INVALGROUPID              ((HRESULT)0x80040017L)

//
// MessageId: TAPI_E_INVALLOCATION
//
// MessageText:
//
//  Invalid location ID.
//
#define TAPI_E_INVALLOCATION             ((HRESULT)0x80040018L)

//
// MessageId: TAPI_E_INVALMESSAGEID
//
// MessageText:
//
//  Invalid message ID.
//
#define TAPI_E_INVALMESSAGEID            ((HRESULT)0x80040019L)

//
// MessageId: TAPI_E_INVALPARKID
//
// MessageText:
//
//  Invalid park ID.
//
#define TAPI_E_INVALPARKID               ((HRESULT)0x8004001AL)

//
// MessageId: TAPI_E_INVALRATE
//
// MessageText:
//
//  Invalid rate.
//
#define TAPI_E_INVALRATE                 ((HRESULT)0x8004001BL)

//
// MessageId: TAPI_E_INVALTIMEOUT
//
// MessageText:
//
//  Invalid timeout value.
//
#define TAPI_E_INVALTIMEOUT              ((HRESULT)0x8004001CL)

//
// MessageId: TAPI_E_INVALTONE
//
// MessageText:
//
//  Invalid tone.
//
#define TAPI_E_INVALTONE                 ((HRESULT)0x8004001DL)

//
// MessageId: TAPI_E_INVALLIST
//
// MessageText:
//
//  Invalid list passed as a parameter
//
#define TAPI_E_INVALLIST                 ((HRESULT)0x8004001EL)

//
// MessageId: TAPI_E_INVALMODE
//
// MessageText:
//
//  Invalide mode passed as a parameter
//
#define TAPI_E_INVALMODE                 ((HRESULT)0x8004001FL)

//
// MessageId: TAPI_E_NOCONFERENCE
//
// MessageText:
//
//  The call is not part of a conference.
//
#define TAPI_E_NOCONFERENCE              ((HRESULT)0x80040020L)

//
// MessageId: TAPI_E_NODEVICE
//
// MessageText:
//
//  The device was removed, or the device class is not recognized.
//
#define TAPI_E_NODEVICE                  ((HRESULT)0x80040021L)

//
// MessageId: TAPI_E_NOREQUEST
//
// MessageText:
//
//  No Assisted Telephony requests are pending.
//
#define TAPI_E_NOREQUEST                 ((HRESULT)0x80040022L)

//
// MessageId: TAPI_E_NOTOWNER
//
// MessageText:
//
//  The application is does not have OWNER privilege on the call.
//
#define TAPI_E_NOTOWNER                  ((HRESULT)0x80040023L)

//
// MessageId: TAPI_E_NOTREGISTERED
//
// MessageText:
//
//  The application is not registered to handle requests.
//
#define TAPI_E_NOTREGISTERED             ((HRESULT)0x80040024L)

//
// MessageId: TAPI_E_REQUESTOVERRUN
//
// MessageText:
//
//  The request queue is already full.
//
#define TAPI_E_REQUESTOVERRUN            ((HRESULT)0x80040025L)

//
// MessageId: TAPI_E_TARGETNOTFOUND
//
// MessageText:
//
//  The call handoff failed because the specified target was not found.
//
#define TAPI_E_TARGETNOTFOUND            ((HRESULT)0x80040026L)

//
// MessageId: TAPI_E_TARGETSELF
//
// MessageText:
//
//  No higher priority target exists for the call handoff.
//
#define TAPI_E_TARGETSELF                ((HRESULT)0x80040027L)

//
// MessageId: TAPI_E_USERUSERINFOTOOBIG
//
// MessageText:
//
//  The amount of user-user info exceeds the maximum permitted.
//
#define TAPI_E_USERUSERINFOTOOBIG        ((HRESULT)0x80040028L)

//
// MessageId: TAPI_E_REINIT
//
// MessageText:
//
//  The operation cannot be completed until all TAPI applications shutdown and reinitialize. 
//
#define TAPI_E_REINIT                    ((HRESULT)0x80040029L)

//
// MessageId: TAPI_E_ADDRESSBLOCKED
//
// MessageText:
//
//  You are not permitted to call this number.
//
#define TAPI_E_ADDRESSBLOCKED            ((HRESULT)0x8004002AL)

//
// MessageId: TAPI_E_BILLINGREJECTED
//
// MessageText:
//
//  The calling card number or other billing information was rejected.
//
#define TAPI_E_BILLINGREJECTED           ((HRESULT)0x8004002BL)

//
// MessageId: TAPI_E_INVALFEATURE
//
// MessageText:
//
//  Invalid device-specific feature.
//
#define TAPI_E_INVALFEATURE              ((HRESULT)0x8004002CL)

//
// MessageId: TAPI_E_INVALBUTTONLAMPID
//
// MessageText:
//
//  Invalid button or lamp ID.
//
#define TAPI_E_INVALBUTTONLAMPID         ((HRESULT)0x8004002DL)

//
// MessageId: TAPI_E_INVALBUTTONSTATE
//
// MessageText:
//
//  Invalid button state.
//
#define TAPI_E_INVALBUTTONSTATE          ((HRESULT)0x8004002EL)

//
// MessageId: TAPI_E_INVALDATAID
//
// MessageText:
//
//  Invalid data segment ID.
//
#define TAPI_E_INVALDATAID               ((HRESULT)0x8004002FL)

//
// MessageId: TAPI_E_INVALHOOKSWITCHDEV
//
// MessageText:
//
//  Invalid hookswitch device ID.
//
#define TAPI_E_INVALHOOKSWITCHDEV        ((HRESULT)0x80040030L)

//
// MessageId: TAPI_E_DROPPED
//
// MessageText:
//
//  The call was disconnected.
//
#define TAPI_E_DROPPED                   ((HRESULT)0x80040031L)

//
// MessageId: TAPI_E_NOREQUESTRECIPIENT
//
// MessageText:
//
//  No program is available to handle the request.
//
#define TAPI_E_NOREQUESTRECIPIENT        ((HRESULT)0x80040032L)

//
// MessageId: TAPI_E_REQUESTQUEUEFULL
//
// MessageText:
//
//  The queue of call requests is full.
//
#define TAPI_E_REQUESTQUEUEFULL          ((HRESULT)0x80040033L)

//
// MessageId: TAPI_E_DESTBUSY
//
// MessageText:
//
//  The called number is busy.
//
#define TAPI_E_DESTBUSY                  ((HRESULT)0x80040034L)

//
// MessageId: TAPI_E_DESTNOANSWER
//
// MessageText:
//
//  The called party does not answer.
//
#define TAPI_E_DESTNOANSWER              ((HRESULT)0x80040035L)

//
// MessageId: TAPI_E_DESTUNAVAIL
//
// MessageText:
//
//  The called number could not be reached
//
#define TAPI_E_DESTUNAVAIL               ((HRESULT)0x80040036L)

//
// MessageId: TAPI_E_REQUESTFAILED
//
// MessageText:
//
//  The request failed for unspecified reasons.
//
#define TAPI_E_REQUESTFAILED             ((HRESULT)0x80040037L)

//
// MessageId: TAPI_E_REQUESTCANCELLED
//
// MessageText:
//
//  The request was cancelled.
//
#define TAPI_E_REQUESTCANCELLED          ((HRESULT)0x80040038L)

//
// MessageId: TAPI_E_INVALPRIVILEGE
//
// MessageText:
//
//  Invalid privilege.
//
#define TAPI_E_INVALPRIVILEGE            ((HRESULT)0x80040039L)

//
// MessageId: TAPI_E_INVALIDDIRECTION
//
// MessageText:
//
//  The TERMINAL_DIRECTION passed in was invalid.
//
#define TAPI_E_INVALIDDIRECTION          ((HRESULT)0x8004003AL)

//
// MessageId: TAPI_E_INVALIDTERMINAL
//
// MessageText:
//
//  The Terminal passed in was invalid for this operation.
//
#define TAPI_E_INVALIDTERMINAL           ((HRESULT)0x8004003BL)

//
// MessageId: TAPI_E_INVALIDTERMINALCLASS
//
// MessageText:
//
//  The Terminal Class is invalid.
//
#define TAPI_E_INVALIDTERMINALCLASS      ((HRESULT)0x8004003CL)

//
// MessageId: TAPI_E_NODRIVER
//
// MessageText:
//
//  The service provider was removed.
//
#define TAPI_E_NODRIVER                  ((HRESULT)0x8004003DL)

//
// MessageId: TAPI_E_MAXSTREAMS
//
// MessageText:
//
//  The maximum number of streams was reached.
//
#define TAPI_E_MAXSTREAMS                ((HRESULT)0x8004003EL)

//
// MessageId: TAPI_E_NOTERMINALSELECTED
//
// MessageText:
//
//  The operation could not be performed because it requires terminals to be selected.
//
#define TAPI_E_NOTERMINALSELECTED        ((HRESULT)0x8004003FL)

//
// MessageId: TAPI_E_TERMINALINUSE
//
// MessageText:
//
//  The operation could not be performed because the terminal is in use.
//
#define TAPI_E_TERMINALINUSE             ((HRESULT)0x80040040L)

//
// MessageId: TAPI_E_NOTSTOPPED
//
// MessageText:
//
//  The operation could not be performed because it requires the stream to be stopped.
//
#define TAPI_E_NOTSTOPPED                ((HRESULT)0x80040041L)

//
// MessageId: TAPI_E_MAXTERMINALS
//
// MessageText:
//
//  The maximum number of terminals has been reached.
//
#define TAPI_E_MAXTERMINALS              ((HRESULT)0x80040042L)

//
// MessageId: TAPI_E_INVALIDSTREAM
//
// MessageText:
//
//  The Stream passed in was invalid for this operation.
//
#define TAPI_E_INVALIDSTREAM             ((HRESULT)0x80040043L)

//
// MessageId: TAPI_E_TIMEOUT
//
// MessageText:
//
//  The call failed due to a timeout.
//
#define TAPI_E_TIMEOUT                   ((HRESULT)0x80040044L)

//--------------------------------------------------------------------------
//     Call Center Error messages
//--------------------------------------------------------------------------

//
// MessageId: TAPI_E_CALLCENTER_GROUP_REMOVED
//
// MessageText:
//
//  The ACD Proxy has removed this Group. Operations on this object are invalid.
//
#define TAPI_E_CALLCENTER_GROUP_REMOVED  ((HRESULT)0x80040045L)

//
// MessageId: TAPI_E_CALLCENTER_QUEUE_REMOVED
//
// MessageText:
//
//  The ACD Proxy has removed this Queue. Operations on this object are invalid.
//
#define TAPI_E_CALLCENTER_QUEUE_REMOVED  ((HRESULT)0x80040046L)

//
// MessageId: TAPI_E_CALLCENTER_NO_AGENT_ID
//
// MessageText:
//
//  The Agent object was created with CreateAgent. It does not have an ID, use CreateAgentWithID.
//
#define TAPI_E_CALLCENTER_NO_AGENT_ID    ((HRESULT)0x80040047L)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTID
//
// MessageText:
//
//  Invalid agent ID.
//
#define TAPI_E_CALLCENTER_INVALAGENTID   ((HRESULT)0x80040048L)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTGROUP
//
// MessageText:
//
//  Invalid agent group.
//
#define TAPI_E_CALLCENTER_INVALAGENTGROUP ((HRESULT)0x80040049L)

//
// MessageId: TAPI_E_CALLCENTER_INVALPASSWORD
//
// MessageText:
//
//  Invalid agent password.
//
#define TAPI_E_CALLCENTER_INVALPASSWORD  ((HRESULT)0x8004004AL)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTSTATE
//
// MessageText:
//
//  Invalid agent state
//
#define TAPI_E_CALLCENTER_INVALAGENTSTATE ((HRESULT)0x8004004BL)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTACTIVITY
//
// MessageText:
//
//  Invalid agent activity.
//
#define TAPI_E_CALLCENTER_INVALAGENTACTIVITY ((HRESULT)0x8004004CL)

//
// MessageId: TAPI_E_REGISTRY_SETTING_CORRUPT
//
// MessageText:
//
//  Registry Setting is Corrupt.
//
#define TAPI_E_REGISTRY_SETTING_CORRUPT  ((HRESULT)0x8004004DL)

//--------------------------------------------------------------------------
//     Terminal Specific Error messages
//--------------------------------------------------------------------------

//
// MessageId: TAPI_E_TERMINAL_PEER
//
// MessageText:
//
//  The peer for one of these bridge terminals has already been assigned.
//
#define TAPI_E_TERMINAL_PEER             ((HRESULT)0x8004004EL)

//
// MessageId: TAPI_E_PEER_NOT_SET
//
// MessageText:
//
//  The peer for this bridge terminal must be set to complete this operation.
//
#define TAPI_E_PEER_NOT_SET              ((HRESULT)0x8004004FL)


//--------------------------------------------------------------------------
//     Media Service Provider Error messages
//--------------------------------------------------------------------------
//
// MessageId: TAPI_E_NOEVENT
//
// MessageText:
//
//  There is no event in the MSP's event queue.
//
#define TAPI_E_NOEVENT                   ((HRESULT)0x80040050L)

//--------------------------------------------------------------------------
//     Core TAPI Error messages
//--------------------------------------------------------------------------

//
// MessageId: TAPI_E_INVALADDRESSTYPE
//
// MessageText:
//
//  The specified address type is not supported by this address.
//
#define TAPI_E_INVALADDRESSTYPE          ((HRESULT)0x80040051L)

//
// MessageId: TAPI_E_RESOURCEUNAVAIL
//
// MessageText:
//
//  A resource needed to fulfill the request is not available.
//
#define TAPI_E_RESOURCEUNAVAIL           ((HRESULT)0x80040052L)

#endif // #ifndef __TAPI3ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\comcat.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Thu Sep 11 10:58:53 1997
 */
/* Compiler settings for comcat.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0000
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ComCat.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//=--------------------------------------------------------------------------=
// OLE Componet Categories Interfaces.
//=--------------------------------------------------------------------------=
//




EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
typedef GUID CATID;

typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0006
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUMCATEGORYINFO;

typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E011-0000-0000-C000-000000000046")
    IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0007
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E012-0000-0000-C000-000000000046")
    ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        END_INTERFACE
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0008
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E013-0000-0000-C000-000000000046")
    ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        END_INTERFACE
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteEnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_RemoteEnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteIsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_RemoteIsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0009
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_comcat_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ]);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************.
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        unsigned long lCounts[_MAX_BLOCKS];
        unsigned long lSizes[_MAX_BLOCKS];
        unsigned long lHighWaterCount;
        unsigned long lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#undef _ASSERTE
#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _CrtSetReportHook(f)                ((void)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((void)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((void)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)

#define _CrtSetDumpClient(f)                ((void)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#define _ASSERT(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, NULL))) \
             _CrtDbgBreak(); } while (0)

//#define _ASSERTE(expr) \
//        do { if (!(expr) && \
//                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
//             _CrtDbgBreak(); } while (0)


/* Reports with no file/line info */

#define _RPT0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPT1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPT2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)

#if     defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

inline void* __cdecl operator new(unsigned int s, int, const char *, int)
        { return ::operator new(s); }

#if	_MSC_VER >= 1200
inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

_CRTIMP void * __cdecl operator new(
        unsigned int,
        int,
        const char *,
        int
        );


#if	_MSC_VER >= 1200
inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void* __cdecl operator new(unsigned int s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

#endif _MFC_OVERRIDES_NEW

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\external\include\tapi3if.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Tue Oct 05 15:14:15 1999
 */
/* Compiler settings for tapi3if.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tapi3if_h__
#define __tapi3if_h__

/* Forward Declarations */ 

#ifndef __ITTAPI_FWD_DEFINED__
#define __ITTAPI_FWD_DEFINED__
typedef interface ITTAPI ITTAPI;
#endif 	/* __ITTAPI_FWD_DEFINED__ */


#ifndef __ITMediaSupport_FWD_DEFINED__
#define __ITMediaSupport_FWD_DEFINED__
typedef interface ITMediaSupport ITMediaSupport;
#endif 	/* __ITMediaSupport_FWD_DEFINED__ */


#ifndef __ITTerminalSupport_FWD_DEFINED__
#define __ITTerminalSupport_FWD_DEFINED__
typedef interface ITTerminalSupport ITTerminalSupport;
#endif 	/* __ITTerminalSupport_FWD_DEFINED__ */


#ifndef __ITAddress_FWD_DEFINED__
#define __ITAddress_FWD_DEFINED__
typedef interface ITAddress ITAddress;
#endif 	/* __ITAddress_FWD_DEFINED__ */


#ifndef __ITAddressCapabilities_FWD_DEFINED__
#define __ITAddressCapabilities_FWD_DEFINED__
typedef interface ITAddressCapabilities ITAddressCapabilities;
#endif 	/* __ITAddressCapabilities_FWD_DEFINED__ */


#ifndef __ITBasicCallControl_FWD_DEFINED__
#define __ITBasicCallControl_FWD_DEFINED__
typedef interface ITBasicCallControl ITBasicCallControl;
#endif 	/* __ITBasicCallControl_FWD_DEFINED__ */


#ifndef __ITCallInfo_FWD_DEFINED__
#define __ITCallInfo_FWD_DEFINED__
typedef interface ITCallInfo ITCallInfo;
#endif 	/* __ITCallInfo_FWD_DEFINED__ */


#ifndef __ITTerminal_FWD_DEFINED__
#define __ITTerminal_FWD_DEFINED__
typedef interface ITTerminal ITTerminal;
#endif 	/* __ITTerminal_FWD_DEFINED__ */


#ifndef __ITBasicAudioTerminal_FWD_DEFINED__
#define __ITBasicAudioTerminal_FWD_DEFINED__
typedef interface ITBasicAudioTerminal ITBasicAudioTerminal;
#endif 	/* __ITBasicAudioTerminal_FWD_DEFINED__ */


#ifndef __ITCallHub_FWD_DEFINED__
#define __ITCallHub_FWD_DEFINED__
typedef interface ITCallHub ITCallHub;
#endif 	/* __ITCallHub_FWD_DEFINED__ */


#ifndef __ITLegacyAddressMediaControl_FWD_DEFINED__
#define __ITLegacyAddressMediaControl_FWD_DEFINED__
typedef interface ITLegacyAddressMediaControl ITLegacyAddressMediaControl;
#endif 	/* __ITLegacyAddressMediaControl_FWD_DEFINED__ */


#ifndef __ITLegacyCallMediaControl_FWD_DEFINED__
#define __ITLegacyCallMediaControl_FWD_DEFINED__
typedef interface ITLegacyCallMediaControl ITLegacyCallMediaControl;
#endif 	/* __ITLegacyCallMediaControl_FWD_DEFINED__ */


#ifndef __IEnumTerminal_FWD_DEFINED__
#define __IEnumTerminal_FWD_DEFINED__
typedef interface IEnumTerminal IEnumTerminal;
#endif 	/* __IEnumTerminal_FWD_DEFINED__ */


#ifndef __IEnumTerminalClass_FWD_DEFINED__
#define __IEnumTerminalClass_FWD_DEFINED__
typedef interface IEnumTerminalClass IEnumTerminalClass;
#endif 	/* __IEnumTerminalClass_FWD_DEFINED__ */


#ifndef __IEnumCall_FWD_DEFINED__
#define __IEnumCall_FWD_DEFINED__
typedef interface IEnumCall IEnumCall;
#endif 	/* __IEnumCall_FWD_DEFINED__ */


#ifndef __IEnumAddress_FWD_DEFINED__
#define __IEnumAddress_FWD_DEFINED__
typedef interface IEnumAddress IEnumAddress;
#endif 	/* __IEnumAddress_FWD_DEFINED__ */


#ifndef __IEnumCallHub_FWD_DEFINED__
#define __IEnumCallHub_FWD_DEFINED__
typedef interface IEnumCallHub IEnumCallHub;
#endif 	/* __IEnumCallHub_FWD_DEFINED__ */


#ifndef __IEnumBstr_FWD_DEFINED__
#define __IEnumBstr_FWD_DEFINED__
typedef interface IEnumBstr IEnumBstr;
#endif 	/* __IEnumBstr_FWD_DEFINED__ */


#ifndef __ITCallStateEvent_FWD_DEFINED__
#define __ITCallStateEvent_FWD_DEFINED__
typedef interface ITCallStateEvent ITCallStateEvent;
#endif 	/* __ITCallStateEvent_FWD_DEFINED__ */


#ifndef __ITCallMediaEvent_FWD_DEFINED__
#define __ITCallMediaEvent_FWD_DEFINED__
typedef interface ITCallMediaEvent ITCallMediaEvent;
#endif 	/* __ITCallMediaEvent_FWD_DEFINED__ */


#ifndef __ITDigitDetectionEvent_FWD_DEFINED__
#define __ITDigitDetectionEvent_FWD_DEFINED__
typedef interface ITDigitDetectionEvent ITDigitDetectionEvent;
#endif 	/* __ITDigitDetectionEvent_FWD_DEFINED__ */


#ifndef __ITDigitGenerationEvent_FWD_DEFINED__
#define __ITDigitGenerationEvent_FWD_DEFINED__
typedef interface ITDigitGenerationEvent ITDigitGenerationEvent;
#endif 	/* __ITDigitGenerationEvent_FWD_DEFINED__ */


#ifndef __ITTAPIObjectEvent_FWD_DEFINED__
#define __ITTAPIObjectEvent_FWD_DEFINED__
typedef interface ITTAPIObjectEvent ITTAPIObjectEvent;
#endif 	/* __ITTAPIObjectEvent_FWD_DEFINED__ */


#ifndef __ITTAPIEventNotification_FWD_DEFINED__
#define __ITTAPIEventNotification_FWD_DEFINED__
typedef interface ITTAPIEventNotification ITTAPIEventNotification;
#endif 	/* __ITTAPIEventNotification_FWD_DEFINED__ */


#ifndef __ITCallHubEvent_FWD_DEFINED__
#define __ITCallHubEvent_FWD_DEFINED__
typedef interface ITCallHubEvent ITCallHubEvent;
#endif 	/* __ITCallHubEvent_FWD_DEFINED__ */


#ifndef __ITAddressEvent_FWD_DEFINED__
#define __ITAddressEvent_FWD_DEFINED__
typedef interface ITAddressEvent ITAddressEvent;
#endif 	/* __ITAddressEvent_FWD_DEFINED__ */


#ifndef __ITQOSEvent_FWD_DEFINED__
#define __ITQOSEvent_FWD_DEFINED__
typedef interface ITQOSEvent ITQOSEvent;
#endif 	/* __ITQOSEvent_FWD_DEFINED__ */


#ifndef __ITCallInfoChangeEvent_FWD_DEFINED__
#define __ITCallInfoChangeEvent_FWD_DEFINED__
typedef interface ITCallInfoChangeEvent ITCallInfoChangeEvent;
#endif 	/* __ITCallInfoChangeEvent_FWD_DEFINED__ */


#ifndef __ITRequest_FWD_DEFINED__
#define __ITRequest_FWD_DEFINED__
typedef interface ITRequest ITRequest;
#endif 	/* __ITRequest_FWD_DEFINED__ */


#ifndef __ITRequestEvent_FWD_DEFINED__
#define __ITRequestEvent_FWD_DEFINED__
typedef interface ITRequestEvent ITRequestEvent;
#endif 	/* __ITRequestEvent_FWD_DEFINED__ */


#ifndef __ITCollection_FWD_DEFINED__
#define __ITCollection_FWD_DEFINED__
typedef interface ITCollection ITCollection;
#endif 	/* __ITCollection_FWD_DEFINED__ */


#ifndef __ITForwardInformation_FWD_DEFINED__
#define __ITForwardInformation_FWD_DEFINED__
typedef interface ITForwardInformation ITForwardInformation;
#endif 	/* __ITForwardInformation_FWD_DEFINED__ */


#ifndef __ITAddressTranslation_FWD_DEFINED__
#define __ITAddressTranslation_FWD_DEFINED__
typedef interface ITAddressTranslation ITAddressTranslation;
#endif 	/* __ITAddressTranslation_FWD_DEFINED__ */


#ifndef __ITAddressTranslationInfo_FWD_DEFINED__
#define __ITAddressTranslationInfo_FWD_DEFINED__
typedef interface ITAddressTranslationInfo ITAddressTranslationInfo;
#endif 	/* __ITAddressTranslationInfo_FWD_DEFINED__ */


#ifndef __ITLocationInfo_FWD_DEFINED__
#define __ITLocationInfo_FWD_DEFINED__
typedef interface ITLocationInfo ITLocationInfo;
#endif 	/* __ITLocationInfo_FWD_DEFINED__ */


#ifndef __IEnumLocation_FWD_DEFINED__
#define __IEnumLocation_FWD_DEFINED__
typedef interface IEnumLocation IEnumLocation;
#endif 	/* __IEnumLocation_FWD_DEFINED__ */


#ifndef __ITCallingCard_FWD_DEFINED__
#define __ITCallingCard_FWD_DEFINED__
typedef interface ITCallingCard ITCallingCard;
#endif 	/* __ITCallingCard_FWD_DEFINED__ */


#ifndef __IEnumCallingCard_FWD_DEFINED__
#define __IEnumCallingCard_FWD_DEFINED__
typedef interface IEnumCallingCard IEnumCallingCard;
#endif 	/* __IEnumCallingCard_FWD_DEFINED__ */


#ifndef __ITCallNotificationEvent_FWD_DEFINED__
#define __ITCallNotificationEvent_FWD_DEFINED__
typedef interface ITCallNotificationEvent ITCallNotificationEvent;
#endif 	/* __ITCallNotificationEvent_FWD_DEFINED__ */


#ifndef __ITPrivateData_FWD_DEFINED__
#define __ITPrivateData_FWD_DEFINED__
typedef interface ITPrivateData ITPrivateData;
#endif 	/* __ITPrivateData_FWD_DEFINED__ */


#ifndef __ITPrivateReceiveData_FWD_DEFINED__
#define __ITPrivateReceiveData_FWD_DEFINED__
typedef interface ITPrivateReceiveData ITPrivateReceiveData;
#endif 	/* __ITPrivateReceiveData_FWD_DEFINED__ */


#ifndef __ITPrivateObjectFactory_FWD_DEFINED__
#define __ITPrivateObjectFactory_FWD_DEFINED__
typedef interface ITPrivateObjectFactory ITPrivateObjectFactory;
#endif 	/* __ITPrivateObjectFactory_FWD_DEFINED__ */


#ifndef __ITDispatchMapper_FWD_DEFINED__
#define __ITDispatchMapper_FWD_DEFINED__
typedef interface ITDispatchMapper ITDispatchMapper;
#endif 	/* __ITDispatchMapper_FWD_DEFINED__ */


#ifndef __ITStreamControl_FWD_DEFINED__
#define __ITStreamControl_FWD_DEFINED__
typedef interface ITStreamControl ITStreamControl;
#endif 	/* __ITStreamControl_FWD_DEFINED__ */


#ifndef __ITStream_FWD_DEFINED__
#define __ITStream_FWD_DEFINED__
typedef interface ITStream ITStream;
#endif 	/* __ITStream_FWD_DEFINED__ */


#ifndef __IEnumStream_FWD_DEFINED__
#define __IEnumStream_FWD_DEFINED__
typedef interface IEnumStream IEnumStream;
#endif 	/* __IEnumStream_FWD_DEFINED__ */


#ifndef __ITSubStreamControl_FWD_DEFINED__
#define __ITSubStreamControl_FWD_DEFINED__
typedef interface ITSubStreamControl ITSubStreamControl;
#endif 	/* __ITSubStreamControl_FWD_DEFINED__ */


#ifndef __ITSubStream_FWD_DEFINED__
#define __ITSubStream_FWD_DEFINED__
typedef interface ITSubStream ITSubStream;
#endif 	/* __ITSubStream_FWD_DEFINED__ */


#ifndef __IEnumSubStream_FWD_DEFINED__
#define __IEnumSubStream_FWD_DEFINED__
typedef interface IEnumSubStream IEnumSubStream;
#endif 	/* __IEnumSubStream_FWD_DEFINED__ */


#ifndef __ITLegacyWaveSupport_FWD_DEFINED__
#define __ITLegacyWaveSupport_FWD_DEFINED__
typedef interface ITLegacyWaveSupport ITLegacyWaveSupport;
#endif 	/* __ITLegacyWaveSupport_FWD_DEFINED__ */


#ifndef __ITPrivateEvent_FWD_DEFINED__
#define __ITPrivateEvent_FWD_DEFINED__
typedef interface ITPrivateEvent ITPrivateEvent;
#endif 	/* __ITPrivateEvent_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_tapi3if_0000 */
/* [local] */ 

/* Copyright (c) 1998-1999  Microsoft Corporation  */

typedef long TAPI_DIGITMODE;

typedef 
enum ADDRESS_EVENT
    {	AE_STATE	= 0,
	AE_CAPSCHANGE	= AE_STATE + 1,
	AE_RINGING	= AE_CAPSCHANGE + 1,
	AE_CONFIGCHANGE	= AE_RINGING + 1,
	AE_FORWARD	= AE_CONFIGCHANGE + 1,
	AE_NEWTERMINAL	= AE_FORWARD + 1,
	AE_REMOVETERMINAL	= AE_NEWTERMINAL + 1
    }	ADDRESS_EVENT;

typedef 
enum ADDRESS_STATE
    {	AS_INSERVICE	= 0,
	AS_OUTOFSERVICE	= AS_INSERVICE + 1
    }	ADDRESS_STATE;

typedef 
enum CALL_STATE
    {	CS_IDLE	= 0,
	CS_INPROGRESS	= CS_IDLE + 1,
	CS_CONNECTED	= CS_INPROGRESS + 1,
	CS_DISCONNECTED	= CS_CONNECTED + 1,
	CS_OFFERING	= CS_DISCONNECTED + 1,
	CS_HOLD	= CS_OFFERING + 1,
	CS_QUEUED	= CS_HOLD + 1
    }	CALL_STATE;

typedef 
enum CALL_STATE_EVENT_CAUSE
    {	CEC_NONE	= 0,
	CEC_DISCONNECT_NORMAL	= CEC_NONE + 1,
	CEC_DISCONNECT_BUSY	= CEC_DISCONNECT_NORMAL + 1,
	CEC_DISCONNECT_BADADDRESS	= CEC_DISCONNECT_BUSY + 1,
	CEC_DISCONNECT_NOANSWER	= CEC_DISCONNECT_BADADDRESS + 1,
	CEC_DISCONNECT_CANCELLED	= CEC_DISCONNECT_NOANSWER + 1,
	CEC_DISCONNECT_REJECTED	= CEC_DISCONNECT_CANCELLED + 1,
	CEC_DISCONNECT_FAILED	= CEC_DISCONNECT_REJECTED + 1
    }	CALL_STATE_EVENT_CAUSE;

typedef 
enum CALL_MEDIA_EVENT
    {	CME_NEW_STREAM	= 0,
	CME_STREAM_FAIL	= CME_NEW_STREAM + 1,
	CME_TERMINAL_FAIL	= CME_STREAM_FAIL + 1,
	CME_STREAM_NOT_USED	= CME_TERMINAL_FAIL + 1,
	CME_STREAM_ACTIVE	= CME_STREAM_NOT_USED + 1,
	CME_STREAM_INACTIVE	= CME_STREAM_ACTIVE + 1
    }	CALL_MEDIA_EVENT;

typedef 
enum CALL_MEDIA_EVENT_CAUSE
    {	CMC_UNKNOWN	= 0,
	CMC_BAD_DEVICE	= CMC_UNKNOWN + 1,
	CMC_CONNECT_FAIL	= CMC_BAD_DEVICE + 1,
	CMC_LOCAL_REQUEST	= CMC_CONNECT_FAIL + 1,
	CMC_REMOTE_REQUEST	= CMC_LOCAL_REQUEST + 1,
	CMC_MEDIA_TIMEOUT	= CMC_REMOTE_REQUEST + 1,
	CMC_MEDIA_RECOVERED	= CMC_MEDIA_TIMEOUT + 1
    }	CALL_MEDIA_EVENT_CAUSE;

typedef 
enum DISCONNECT_CODE
    {	DC_NORMAL	= 0,
	DC_NOANSWER	= DC_NORMAL + 1,
	DC_REJECTED	= DC_NOANSWER + 1
    }	DISCONNECT_CODE;

typedef 
enum TERMINAL_STATE
    {	TS_INUSE	= 0,
	TS_NOTINUSE	= TS_INUSE + 1
    }	TERMINAL_STATE;

typedef 
enum TERMINAL_DIRECTION
    {	TD_CAPTURE	= 0,
	TD_RENDER	= TD_CAPTURE + 1
    }	TERMINAL_DIRECTION;

typedef 
enum TERMINAL_TYPE
    {	TT_STATIC	= 0,
	TT_DYNAMIC	= TT_STATIC + 1
    }	TERMINAL_TYPE;

typedef 
enum CALL_PRIVILEGE
    {	CP_OWNER	= 0,
	CP_MONITOR	= CP_OWNER + 1
    }	CALL_PRIVILEGE;

typedef 
enum TAPI_EVENT
    {	TE_TAPIOBJECT	= 0x1,
	TE_ADDRESS	= 0x2,
	TE_CALLNOTIFICATION	= 0x4,
	TE_CALLSTATE	= 0x8,
	TE_CALLMEDIA	= 0x10,
	TE_CALLHUB	= 0x20,
	TE_CALLINFOCHANGE	= 0x40,
	TE_PRIVATE	= 0x80,
	TE_REQUEST	= 0x100,
	TE_AGENT	= 0x200,
	TE_AGENTSESSION	= 0x400,
	TE_QOSEVENT	= 0x800,
	TE_AGENTHANDLER	= 0x1000,
	TE_ACDGROUP	= 0x2000,
	TE_QUEUE	= 0x4000,
	TE_DIGITEVENT	= 0x8000,
	TE_GENERATEEVENT	= 0x10000
    }	TAPI_EVENT;

typedef 
enum CALL_NOTIFICATION_EVENT
    {	CNE_OWNER	= 0,
	CNE_MONITOR	= CNE_OWNER + 1
    }	CALL_NOTIFICATION_EVENT;

typedef 
enum CALLHUB_EVENT
    {	CHE_CALLJOIN	= 0,
	CHE_CALLLEAVE	= CHE_CALLJOIN + 1,
	CHE_CALLHUBNEW	= CHE_CALLLEAVE + 1,
	CHE_CALLHUBIDLE	= CHE_CALLHUBNEW + 1
    }	CALLHUB_EVENT;

typedef 
enum CALLHUB_STATE
    {	CHS_ACTIVE	= 0,
	CHS_IDLE	= CHS_ACTIVE + 1
    }	CALLHUB_STATE;

typedef 
enum TAPIOBJECT_EVENT
    {	TE_ADDRESSCREATE	= 0,
	TE_ADDRESSREMOVE	= TE_ADDRESSCREATE + 1,
	TE_REINIT	= TE_ADDRESSREMOVE + 1,
	TE_TRANSLATECHANGE	= TE_REINIT + 1,
	TE_ADDRESSCLOSE	= TE_TRANSLATECHANGE + 1
    }	TAPIOBJECT_EVENT;

typedef 
enum TAPI_OBJECT_TYPE
    {	TOT_NONE	= 0,
	TOT_TAPI	= TOT_NONE + 1,
	TOT_ADDRESS	= TOT_TAPI + 1,
	TOT_TERMINAL	= TOT_ADDRESS + 1,
	TOT_CALL	= TOT_TERMINAL + 1,
	TOT_CALLHUB	= TOT_CALL + 1
    }	TAPI_OBJECT_TYPE;

typedef 
enum QOS_SERVICE_LEVEL
    {	QSL_NEEDED	= 1,
	QSL_IF_AVAILABLE	= 2,
	QSL_BEST_EFFORT	= 3
    }	QOS_SERVICE_LEVEL;

typedef 
enum QOS_EVENT
    {	QE_NOQOS	= 1,
	QE_ADMISSIONFAILURE	= 2,
	QE_POLICYFAILURE	= 3,
	QE_GENERICERROR	= 4
    }	QOS_EVENT;

typedef 
enum CALLINFOCHANGE_CAUSE
    {	CIC_OTHER	= 0,
	CIC_DEVSPECIFIC	= CIC_OTHER + 1,
	CIC_BEARERMODE	= CIC_DEVSPECIFIC + 1,
	CIC_RATE	= CIC_BEARERMODE + 1,
	CIC_APPSPECIFIC	= CIC_RATE + 1,
	CIC_CALLID	= CIC_APPSPECIFIC + 1,
	CIC_RELATEDCALLID	= CIC_CALLID + 1,
	CIC_ORIGIN	= CIC_RELATEDCALLID + 1,
	CIC_REASON	= CIC_ORIGIN + 1,
	CIC_COMPLETIONID	= CIC_REASON + 1,
	CIC_NUMOWNERINCR	= CIC_COMPLETIONID + 1,
	CIC_NUMOWNERDECR	= CIC_NUMOWNERINCR + 1,
	CIC_NUMMONITORS	= CIC_NUMOWNERDECR + 1,
	CIC_TRUNK	= CIC_NUMMONITORS + 1,
	CIC_CALLERID	= CIC_TRUNK + 1,
	CIC_CALLEDID	= CIC_CALLERID + 1,
	CIC_CONNECTEDID	= CIC_CALLEDID + 1,
	CIC_REDIRECTIONID	= CIC_CONNECTEDID + 1,
	CIC_REDIRECTINGID	= CIC_REDIRECTIONID + 1,
	CIC_USERUSERINFO	= CIC_REDIRECTINGID + 1,
	CIC_HIGHLEVELCOMP	= CIC_USERUSERINFO + 1,
	CIC_LOWLEVELCOMP	= CIC_HIGHLEVELCOMP + 1,
	CIC_CHARGINGINFO	= CIC_LOWLEVELCOMP + 1,
	CIC_TREATMENT	= CIC_CHARGINGINFO + 1,
	CIC_CALLDATA	= CIC_TREATMENT + 1,
	CIC_PRIVILEGE	= CIC_CALLDATA + 1,
	CIC_MEDIATYPE	= CIC_PRIVILEGE + 1
    }	CALLINFOCHANGE_CAUSE;

typedef 
enum CALLINFO_LONG
    {	CIL_MEDIATYPESAVAILABLE	= 0,
	CIL_BEARERMODE	= CIL_MEDIATYPESAVAILABLE + 1,
	CIL_CALLERIDADDRESSTYPE	= CIL_BEARERMODE + 1,
	CIL_CALLEDIDADDRESSTYPE	= CIL_CALLERIDADDRESSTYPE + 1,
	CIL_CONNECTEDIDADDRESSTYPE	= CIL_CALLEDIDADDRESSTYPE + 1,
	CIL_REDIRECTIONIDADDRESSTYPE	= CIL_CONNECTEDIDADDRESSTYPE + 1,
	CIL_REDIRECTINGIDADDRESSTYPE	= CIL_REDIRECTIONIDADDRESSTYPE + 1,
	CIL_ORIGIN	= CIL_REDIRECTINGIDADDRESSTYPE + 1,
	CIL_REASON	= CIL_ORIGIN + 1,
	CIL_APPSPECIFIC	= CIL_REASON + 1,
	CIL_CALLPARAMSFLAGS	= CIL_APPSPECIFIC + 1,
	CIL_CALLTREATMENT	= CIL_CALLPARAMSFLAGS + 1,
	CIL_MINRATE	= CIL_CALLTREATMENT + 1,
	CIL_MAXRATE	= CIL_MINRATE + 1,
	CIL_COUNTRYCODE	= CIL_MAXRATE + 1,
	CIL_CALLID	= CIL_COUNTRYCODE + 1,
	CIL_RELATEDCALLID	= CIL_CALLID + 1,
	CIL_COMPLETIONID	= CIL_RELATEDCALLID + 1,
	CIL_NUMBEROFOWNERS	= CIL_COMPLETIONID + 1,
	CIL_NUMBEROFMONITORS	= CIL_NUMBEROFOWNERS + 1,
	CIL_TRUNK	= CIL_NUMBEROFMONITORS + 1,
	CIL_RATE	= CIL_TRUNK + 1
    }	CALLINFO_LONG;

typedef 
enum CALLINFO_STRING
    {	CIS_CALLERIDNAME	= 0,
	CIS_CALLERIDNUMBER	= CIS_CALLERIDNAME + 1,
	CIS_CALLEDIDNAME	= CIS_CALLERIDNUMBER + 1,
	CIS_CALLEDIDNUMBER	= CIS_CALLEDIDNAME + 1,
	CIS_CONNECTEDIDNAME	= CIS_CALLEDIDNUMBER + 1,
	CIS_CONNECTEDIDNUMBER	= CIS_CONNECTEDIDNAME + 1,
	CIS_REDIRECTIONIDNAME	= CIS_CONNECTEDIDNUMBER + 1,
	CIS_REDIRECTIONIDNUMBER	= CIS_REDIRECTIONIDNAME + 1,
	CIS_REDIRECTINGIDNAME	= CIS_REDIRECTIONIDNUMBER + 1,
	CIS_REDIRECTINGIDNUMBER	= CIS_REDIRECTINGIDNAME + 1,
	CIS_CALLEDPARTYFRIENDLYNAME	= CIS_REDIRECTINGIDNUMBER + 1,
	CIS_COMMENT	= CIS_CALLEDPARTYFRIENDLYNAME + 1,
	CIS_DISPLAYABLEADDRESS	= CIS_COMMENT + 1,
	CIS_CALLINGPARTYID	= CIS_DISPLAYABLEADDRESS + 1
    }	CALLINFO_STRING;

typedef 
enum CALLINFO_BUFFER
    {	CIB_USERUSERINFO	= 0,
	CIB_DEVSPECIFICBUFFER	= CIB_USERUSERINFO + 1,
	CIB_CALLDATABUFFER	= CIB_DEVSPECIFICBUFFER + 1,
	CIB_CHARGINGINFOBUFFER	= CIB_CALLDATABUFFER + 1,
	CIB_HIGHLEVELCOMPATIBILITYBUFFER	= CIB_CHARGINGINFOBUFFER + 1,
	CIB_LOWLEVELCOMPATIBILITYBUFFER	= CIB_HIGHLEVELCOMPATIBILITYBUFFER + 1
    }	CALLINFO_BUFFER;

typedef 
enum ADDRESS_CAPABILITY
    {	AC_ADDRESSTYPES	= 0,
	AC_BEARERMODES	= AC_ADDRESSTYPES + 1,
	AC_MAXACTIVECALLS	= AC_BEARERMODES + 1,
	AC_MAXONHOLDCALLS	= AC_MAXACTIVECALLS + 1,
	AC_MAXONHOLDPENDINGCALLS	= AC_MAXONHOLDCALLS + 1,
	AC_MAXNUMCONFERENCE	= AC_MAXONHOLDPENDINGCALLS + 1,
	AC_MAXNUMTRANSCONF	= AC_MAXNUMCONFERENCE + 1,
	AC_MONITORDIGITSUPPORT	= AC_MAXNUMTRANSCONF + 1,
	AC_GENERATEDIGITSUPPORT	= AC_MONITORDIGITSUPPORT + 1,
	AC_GENERATETONEMODES	= AC_GENERATEDIGITSUPPORT + 1,
	AC_GENERATETONEMAXNUMFREQ	= AC_GENERATETONEMODES + 1,
	AC_MONITORTONEMAXNUMFREQ	= AC_GENERATETONEMAXNUMFREQ + 1,
	AC_MONITORTONEMAXNUMENTRIES	= AC_MONITORTONEMAXNUMFREQ + 1,
	AC_DEVCAPFLAGS	= AC_MONITORTONEMAXNUMENTRIES + 1,
	AC_ANSWERMODES	= AC_DEVCAPFLAGS + 1,
	AC_LINEFEATURES	= AC_ANSWERMODES + 1,
	AC_SETTABLEDEVSTATUS	= AC_LINEFEATURES + 1,
	AC_PARKSUPPORT	= AC_SETTABLEDEVSTATUS + 1,
	AC_CALLERIDSUPPORT	= AC_PARKSUPPORT + 1,
	AC_CALLEDIDSUPPORT	= AC_CALLERIDSUPPORT + 1,
	AC_CONNECTEDIDSUPPORT	= AC_CALLEDIDSUPPORT + 1,
	AC_REDIRECTIONIDSUPPORT	= AC_CONNECTEDIDSUPPORT + 1,
	AC_REDIRECTINGIDSUPPORT	= AC_REDIRECTIONIDSUPPORT + 1,
	AC_ADDRESSCAPFLAGS	= AC_REDIRECTINGIDSUPPORT + 1,
	AC_CALLFEATURES1	= AC_ADDRESSCAPFLAGS + 1,
	AC_CALLFEATURES2	= AC_CALLFEATURES1 + 1,
	AC_REMOVEFROMCONFCAPS	= AC_CALLFEATURES2 + 1,
	AC_REMOVEFROMCONFSTATE	= AC_REMOVEFROMCONFCAPS + 1,
	AC_TRANSFERMODES	= AC_REMOVEFROMCONFSTATE + 1,
	AC_ADDRESSFEATURES	= AC_TRANSFERMODES + 1,
	AC_PREDICTIVEAUTOTRANSFERSTATES	= AC_ADDRESSFEATURES + 1,
	AC_MAXCALLDATASIZE	= AC_PREDICTIVEAUTOTRANSFERSTATES + 1,
	AC_LINEID	= AC_MAXCALLDATASIZE + 1,
	AC_ADDRESSID	= AC_LINEID + 1,
	AC_FORWARDMODES	= AC_ADDRESSID + 1,
	AC_MAXFORWARDENTRIES	= AC_FORWARDMODES + 1,
	AC_MAXSPECIFICENTRIES	= AC_MAXFORWARDENTRIES + 1,
	AC_MINFWDNUMRINGS	= AC_MAXSPECIFICENTRIES + 1,
	AC_MAXFWDNUMRINGS	= AC_MINFWDNUMRINGS + 1,
	AC_MAXCALLCOMPLETIONS	= AC_MAXFWDNUMRINGS + 1,
	AC_CALLCOMPLETIONCONDITIONS	= AC_MAXCALLCOMPLETIONS + 1,
	AC_CALLCOMPLETIONMODES	= AC_CALLCOMPLETIONCONDITIONS + 1,
	AC_PERMANENTDEVICEID	= AC_CALLCOMPLETIONMODES + 1
    }	ADDRESS_CAPABILITY;

typedef 
enum ADDRESS_CAPABILITY_STRING
    {	ACS_PROTOCOL	= 0,
	ACS_ADDRESSDEVICESPECIFIC	= ACS_PROTOCOL + 1,
	ACS_LINEDEVICESPECIFIC	= ACS_ADDRESSDEVICESPECIFIC + 1,
	ACS_PROVIDERSPECIFIC	= ACS_LINEDEVICESPECIFIC + 1,
	ACS_SWITCHSPECIFIC	= ACS_PROVIDERSPECIFIC + 1,
	ACS_PERMANENTDEVICEGUID	= ACS_SWITCHSPECIFIC + 1
    }	ADDRESS_CAPABILITY_STRING;

typedef 
enum FULLDUPLEX_SUPPORT
    {	FDS_SUPPORTED	= 0,
	FDS_NOTSUPPORTED	= FDS_SUPPORTED + 1,
	FDS_UNKNOWN	= FDS_NOTSUPPORTED + 1
    }	FULLDUPLEX_SUPPORT;

typedef 
enum FINISH_MODE
    {	FM_ASTRANSFER	= 0,
	FM_ASCONFERENCE	= FM_ASTRANSFER + 1
    }	FINISH_MODE;

#define	INTERFACEMASK	( 0xff0000 )

#define	DISPIDMASK	( 0xffff )

#define	IDISPTAPI	( 0x10000 )

#define	IDISPTAPICALLCENTER	( 0x20000 )

#define	IDISPCALLINFO	( 0x10000 )

#define	IDISPBASICCALLCONTROL	( 0x20000 )

#define	IDISPLEGACYCALLMEDIACONTROL	( 0x30000 )

#define	IDISPAGGREGATEDMSPCALLOBJ	( 0x40000 )

#define	IDISPADDRESS	( 0x10000 )

#define	IDISPADDRESSCAPABILITIES	( 0x20000 )

#define	IDISPMEDIASUPPORT	( 0x30000 )

#define	IDISPADDRESSTRANSLATION	( 0x40000 )

#define	IDISPLEGACYADDRESSMEDIACONTROL	( 0x50000 )

#define	IDISPAGGREGATEDMSPADDRESSOBJ	( 0x60000 )

































extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_v0_0_s_ifspec;

#ifndef __ITTAPI_INTERFACE_DEFINED__
#define __ITTAPI_INTERFACE_DEFINED__

/* interface ITTAPI */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC382-9355-11d0-835C-00AA003CCABD")
    ITTAPI : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Addresses( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAddresses( 
            /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnumAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterCallNotifications( 
            /* [in] */ ITAddress __RPC_FAR *pAddress,
            /* [in] */ VARIANT_BOOL fMonitor,
            /* [in] */ VARIANT_BOOL fOwner,
            /* [in] */ long lMediaTypes,
            /* [in] */ long lCallbackInstance,
            /* [retval][out] */ long __RPC_FAR *plRegister) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterNotifications( 
            /* [in] */ long lRegister) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHubs( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCallHubs( 
            /* [retval][out] */ IEnumCallHub __RPC_FAR *__RPC_FAR *ppEnumCallHub) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCallHubTracking( 
            /* [in] */ VARIANT pAddresses,
            /* [in] */ VARIANT_BOOL bTracking) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePrivateTAPIObjects( 
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnumUnknown) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrivateTAPIObjects( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterRequestRecipient( 
            /* [in] */ long lRegistrationInstance,
            /* [in] */ long lRequestMode,
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAssistedTelephonyPriority( 
            /* [in] */ BSTR pAppFilename,
            /* [in] */ VARIANT_BOOL fPriority) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetApplicationPriority( 
            /* [in] */ BSTR pAppFilename,
            /* [in] */ long lMediaType,
            /* [in] */ VARIANT_BOOL fPriority) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventFilter( 
            /* [in] */ long lFilterMask) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventFilter( 
            /* [retval][out] */ long __RPC_FAR *plFilterMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTAPI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTAPI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITTAPI __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ITTAPI __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Shutdown )( 
            ITTAPI __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Addresses )( 
            ITTAPI __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateAddresses )( 
            ITTAPI __RPC_FAR * This,
            /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnumAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCallNotifications )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ ITAddress __RPC_FAR *pAddress,
            /* [in] */ VARIANT_BOOL fMonitor,
            /* [in] */ VARIANT_BOOL fOwner,
            /* [in] */ long lMediaTypes,
            /* [in] */ long lCallbackInstance,
            /* [retval][out] */ long __RPC_FAR *plRegister);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterNotifications )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ long lRegister);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallHubs )( 
            ITTAPI __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateCallHubs )( 
            ITTAPI __RPC_FAR * This,
            /* [retval][out] */ IEnumCallHub __RPC_FAR *__RPC_FAR *ppEnumCallHub);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCallHubTracking )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ VARIANT pAddresses,
            /* [in] */ VARIANT_BOOL bTracking);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumeratePrivateTAPIObjects )( 
            ITTAPI __RPC_FAR * This,
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnumUnknown);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PrivateTAPIObjects )( 
            ITTAPI __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterRequestRecipient )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ long lRegistrationInstance,
            /* [in] */ long lRequestMode,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAssistedTelephonyPriority )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ BSTR pAppFilename,
            /* [in] */ VARIANT_BOOL fPriority);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationPriority )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ BSTR pAppFilename,
            /* [in] */ long lMediaType,
            /* [in] */ VARIANT_BOOL fPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventFilter )( 
            ITTAPI __RPC_FAR * This,
            /* [in] */ long lFilterMask);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventFilter )( 
            ITTAPI __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plFilterMask);
        
        END_INTERFACE
    } ITTAPIVtbl;

    interface ITTAPI
    {
        CONST_VTBL struct ITTAPIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTAPI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTAPI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTAPI_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTAPI_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTAPI_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTAPI_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTAPI_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define ITTAPI_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ITTAPI_get_Addresses(This,pVariant)	\
    (This)->lpVtbl -> get_Addresses(This,pVariant)

#define ITTAPI_EnumerateAddresses(This,ppEnumAddress)	\
    (This)->lpVtbl -> EnumerateAddresses(This,ppEnumAddress)

#define ITTAPI_RegisterCallNotifications(This,pAddress,fMonitor,fOwner,lMediaTypes,lCallbackInstance,plRegister)	\
    (This)->lpVtbl -> RegisterCallNotifications(This,pAddress,fMonitor,fOwner,lMediaTypes,lCallbackInstance,plRegister)

#define ITTAPI_UnregisterNotifications(This,lRegister)	\
    (This)->lpVtbl -> UnregisterNotifications(This,lRegister)

#define ITTAPI_get_CallHubs(This,pVariant)	\
    (This)->lpVtbl -> get_CallHubs(This,pVariant)

#define ITTAPI_EnumerateCallHubs(This,ppEnumCallHub)	\
    (This)->lpVtbl -> EnumerateCallHubs(This,ppEnumCallHub)

#define ITTAPI_SetCallHubTracking(This,pAddresses,bTracking)	\
    (This)->lpVtbl -> SetCallHubTracking(This,pAddresses,bTracking)

#define ITTAPI_EnumeratePrivateTAPIObjects(This,ppEnumUnknown)	\
    (This)->lpVtbl -> EnumeratePrivateTAPIObjects(This,ppEnumUnknown)

#define ITTAPI_get_PrivateTAPIObjects(This,pVariant)	\
    (This)->lpVtbl -> get_PrivateTAPIObjects(This,pVariant)

#define ITTAPI_RegisterRequestRecipient(This,lRegistrationInstance,lRequestMode,fEnable)	\
    (This)->lpVtbl -> RegisterRequestRecipient(This,lRegistrationInstance,lRequestMode,fEnable)

#define ITTAPI_SetAssistedTelephonyPriority(This,pAppFilename,fPriority)	\
    (This)->lpVtbl -> SetAssistedTelephonyPriority(This,pAppFilename,fPriority)

#define ITTAPI_SetApplicationPriority(This,pAppFilename,lMediaType,fPriority)	\
    (This)->lpVtbl -> SetApplicationPriority(This,pAppFilename,lMediaType,fPriority)

#define ITTAPI_put_EventFilter(This,lFilterMask)	\
    (This)->lpVtbl -> put_EventFilter(This,lFilterMask)

#define ITTAPI_get_EventFilter(This,plFilterMask)	\
    (This)->lpVtbl -> get_EventFilter(This,plFilterMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_Initialize_Proxy( 
    ITTAPI __RPC_FAR * This);


void __RPC_STUB ITTAPI_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_Shutdown_Proxy( 
    ITTAPI __RPC_FAR * This);


void __RPC_STUB ITTAPI_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPI_get_Addresses_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITTAPI_get_Addresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_EnumerateAddresses_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnumAddress);


void __RPC_STUB ITTAPI_EnumerateAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_RegisterCallNotifications_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ ITAddress __RPC_FAR *pAddress,
    /* [in] */ VARIANT_BOOL fMonitor,
    /* [in] */ VARIANT_BOOL fOwner,
    /* [in] */ long lMediaTypes,
    /* [in] */ long lCallbackInstance,
    /* [retval][out] */ long __RPC_FAR *plRegister);


void __RPC_STUB ITTAPI_RegisterCallNotifications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_UnregisterNotifications_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ long lRegister);


void __RPC_STUB ITTAPI_UnregisterNotifications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPI_get_CallHubs_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITTAPI_get_CallHubs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_EnumerateCallHubs_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [retval][out] */ IEnumCallHub __RPC_FAR *__RPC_FAR *ppEnumCallHub);


void __RPC_STUB ITTAPI_EnumerateCallHubs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_SetCallHubTracking_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ VARIANT pAddresses,
    /* [in] */ VARIANT_BOOL bTracking);


void __RPC_STUB ITTAPI_SetCallHubTracking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_EnumeratePrivateTAPIObjects_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnumUnknown);


void __RPC_STUB ITTAPI_EnumeratePrivateTAPIObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPI_get_PrivateTAPIObjects_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITTAPI_get_PrivateTAPIObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_RegisterRequestRecipient_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ long lRegistrationInstance,
    /* [in] */ long lRequestMode,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB ITTAPI_RegisterRequestRecipient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_SetAssistedTelephonyPriority_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ BSTR pAppFilename,
    /* [in] */ VARIANT_BOOL fPriority);


void __RPC_STUB ITTAPI_SetAssistedTelephonyPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPI_SetApplicationPriority_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ BSTR pAppFilename,
    /* [in] */ long lMediaType,
    /* [in] */ VARIANT_BOOL fPriority);


void __RPC_STUB ITTAPI_SetApplicationPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITTAPI_put_EventFilter_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [in] */ long lFilterMask);


void __RPC_STUB ITTAPI_put_EventFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPI_get_EventFilter_Proxy( 
    ITTAPI __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plFilterMask);


void __RPC_STUB ITTAPI_get_EventFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTAPI_INTERFACE_DEFINED__ */


#ifndef __ITMediaSupport_INTERFACE_DEFINED__
#define __ITMediaSupport_INTERFACE_DEFINED__

/* interface ITMediaSupport */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITMediaSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC384-9355-11d0-835C-00AA003CCABD")
    ITMediaSupport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ long __RPC_FAR *plMediaTypes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryMediaType( 
            /* [in] */ long lMediaType,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITMediaSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITMediaSupport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITMediaSupport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITMediaSupport __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITMediaSupport __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITMediaSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITMediaSupport __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MediaTypes )( 
            ITMediaSupport __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMediaTypes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryMediaType )( 
            ITMediaSupport __RPC_FAR * This,
            /* [in] */ long lMediaType,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfSupport);
        
        END_INTERFACE
    } ITMediaSupportVtbl;

    interface ITMediaSupport
    {
        CONST_VTBL struct ITMediaSupportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMediaSupport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITMediaSupport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITMediaSupport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITMediaSupport_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITMediaSupport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITMediaSupport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITMediaSupport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITMediaSupport_get_MediaTypes(This,plMediaTypes)	\
    (This)->lpVtbl -> get_MediaTypes(This,plMediaTypes)

#define ITMediaSupport_QueryMediaType(This,lMediaType,pfSupport)	\
    (This)->lpVtbl -> QueryMediaType(This,lMediaType,pfSupport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITMediaSupport_get_MediaTypes_Proxy( 
    ITMediaSupport __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMediaTypes);


void __RPC_STUB ITMediaSupport_get_MediaTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITMediaSupport_QueryMediaType_Proxy( 
    ITMediaSupport __RPC_FAR * This,
    /* [in] */ long lMediaType,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfSupport);


void __RPC_STUB ITMediaSupport_QueryMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITMediaSupport_INTERFACE_DEFINED__ */


#ifndef __ITTerminalSupport_INTERFACE_DEFINED__
#define __ITTerminalSupport_INTERFACE_DEFINED__

/* interface ITTerminalSupport */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTerminalSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC385-9355-11d0-835C-00AA003CCABD")
    ITTerminalSupport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StaticTerminals( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateStaticTerminals( 
            /* [retval][out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppTerminalEnumerator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DynamicTerminalClasses( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDynamicTerminalClasses( 
            /* [retval][out] */ IEnumTerminalClass __RPC_FAR *__RPC_FAR *ppTerminalClassEnumerator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTerminal( 
            /* [in] */ BSTR pTerminalClass,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultStaticTerminal( 
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTerminalSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTerminalSupport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTerminalSupport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticTerminals )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateStaticTerminals )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [retval][out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppTerminalEnumerator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DynamicTerminalClasses )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateDynamicTerminalClasses )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [retval][out] */ IEnumTerminalClass __RPC_FAR *__RPC_FAR *ppTerminalClassEnumerator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTerminal )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [in] */ BSTR pTerminalClass,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultStaticTerminal )( 
            ITTerminalSupport __RPC_FAR * This,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);
        
        END_INTERFACE
    } ITTerminalSupportVtbl;

    interface ITTerminalSupport
    {
        CONST_VTBL struct ITTerminalSupportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTerminalSupport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTerminalSupport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTerminalSupport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTerminalSupport_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTerminalSupport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTerminalSupport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTerminalSupport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTerminalSupport_get_StaticTerminals(This,pVariant)	\
    (This)->lpVtbl -> get_StaticTerminals(This,pVariant)

#define ITTerminalSupport_EnumerateStaticTerminals(This,ppTerminalEnumerator)	\
    (This)->lpVtbl -> EnumerateStaticTerminals(This,ppTerminalEnumerator)

#define ITTerminalSupport_get_DynamicTerminalClasses(This,pVariant)	\
    (This)->lpVtbl -> get_DynamicTerminalClasses(This,pVariant)

#define ITTerminalSupport_EnumerateDynamicTerminalClasses(This,ppTerminalClassEnumerator)	\
    (This)->lpVtbl -> EnumerateDynamicTerminalClasses(This,ppTerminalClassEnumerator)

#define ITTerminalSupport_CreateTerminal(This,pTerminalClass,lMediaType,Direction,ppTerminal)	\
    (This)->lpVtbl -> CreateTerminal(This,pTerminalClass,lMediaType,Direction,ppTerminal)

#define ITTerminalSupport_GetDefaultStaticTerminal(This,lMediaType,Direction,ppTerminal)	\
    (This)->lpVtbl -> GetDefaultStaticTerminal(This,lMediaType,Direction,ppTerminal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminalSupport_get_StaticTerminals_Proxy( 
    ITTerminalSupport __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITTerminalSupport_get_StaticTerminals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITTerminalSupport_EnumerateStaticTerminals_Proxy( 
    ITTerminalSupport __RPC_FAR * This,
    /* [retval][out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppTerminalEnumerator);


void __RPC_STUB ITTerminalSupport_EnumerateStaticTerminals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminalSupport_get_DynamicTerminalClasses_Proxy( 
    ITTerminalSupport __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITTerminalSupport_get_DynamicTerminalClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITTerminalSupport_EnumerateDynamicTerminalClasses_Proxy( 
    ITTerminalSupport __RPC_FAR * This,
    /* [retval][out] */ IEnumTerminalClass __RPC_FAR *__RPC_FAR *ppTerminalClassEnumerator);


void __RPC_STUB ITTerminalSupport_EnumerateDynamicTerminalClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTerminalSupport_CreateTerminal_Proxy( 
    ITTerminalSupport __RPC_FAR * This,
    /* [in] */ BSTR pTerminalClass,
    /* [in] */ long lMediaType,
    /* [in] */ TERMINAL_DIRECTION Direction,
    /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);


void __RPC_STUB ITTerminalSupport_CreateTerminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTerminalSupport_GetDefaultStaticTerminal_Proxy( 
    ITTerminalSupport __RPC_FAR * This,
    /* [in] */ long lMediaType,
    /* [in] */ TERMINAL_DIRECTION Direction,
    /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);


void __RPC_STUB ITTerminalSupport_GetDefaultStaticTerminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTerminalSupport_INTERFACE_DEFINED__ */


#ifndef __ITAddress_INTERFACE_DEFINED__
#define __ITAddress_INTERFACE_DEFINED__

/* interface ITAddress */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC386-9355-11d0-835C-00AA003CCABD")
    ITAddress : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ ADDRESS_STATE __RPC_FAR *pAddressState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressName( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceProviderName( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TAPIObject( 
            /* [retval][out] */ ITTAPI __RPC_FAR *__RPC_FAR *ppTapiObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateCall( 
            /* [in] */ BSTR pDestAddress,
            /* [in] */ long lAddressType,
            /* [in] */ long lMediaTypes,
            /* [retval][out] */ ITBasicCallControl __RPC_FAR *__RPC_FAR *ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Calls( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCalls( 
            /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppCallEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pDialableAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateForwardInfoObject( 
            /* [retval][out] */ ITForwardInformation __RPC_FAR *__RPC_FAR *ppForwardInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Forward( 
            /* [in] */ ITForwardInformation __RPC_FAR *pForwardInfo,
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentForwardInfo( 
            /* [retval][out] */ ITForwardInformation __RPC_FAR *__RPC_FAR *ppForwardInfo) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MessageWaiting( 
            /* [in] */ VARIANT_BOOL fMessageWaiting) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageWaiting( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMessageWaiting) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DoNotDisturb( 
            /* [in] */ VARIANT_BOOL fDoNotDisturb) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DoNotDisturb( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfDoNotDisturb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAddress __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAddress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAddress __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ ADDRESS_STATE __RPC_FAR *pAddressState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddressName )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServiceProviderName )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TAPIObject )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ ITTAPI __RPC_FAR *__RPC_FAR *ppTapiObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateCall )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ BSTR pDestAddress,
            /* [in] */ long lAddressType,
            /* [in] */ long lMediaTypes,
            /* [retval][out] */ ITBasicCallControl __RPC_FAR *__RPC_FAR *ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Calls )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateCalls )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppCallEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialableAddress )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pDialableAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateForwardInfoObject )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ ITForwardInformation __RPC_FAR *__RPC_FAR *ppForwardInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Forward )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ ITForwardInformation __RPC_FAR *pForwardInfo,
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentForwardInfo )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ ITForwardInformation __RPC_FAR *__RPC_FAR *ppForwardInfo);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageWaiting )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fMessageWaiting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageWaiting )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMessageWaiting);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DoNotDisturb )( 
            ITAddress __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fDoNotDisturb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DoNotDisturb )( 
            ITAddress __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfDoNotDisturb);
        
        END_INTERFACE
    } ITAddressVtbl;

    interface ITAddress
    {
        CONST_VTBL struct ITAddressVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAddress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAddress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAddress_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAddress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAddress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAddress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAddress_get_State(This,pAddressState)	\
    (This)->lpVtbl -> get_State(This,pAddressState)

#define ITAddress_get_AddressName(This,ppName)	\
    (This)->lpVtbl -> get_AddressName(This,ppName)

#define ITAddress_get_ServiceProviderName(This,ppName)	\
    (This)->lpVtbl -> get_ServiceProviderName(This,ppName)

#define ITAddress_get_TAPIObject(This,ppTapiObject)	\
    (This)->lpVtbl -> get_TAPIObject(This,ppTapiObject)

#define ITAddress_CreateCall(This,pDestAddress,lAddressType,lMediaTypes,ppCall)	\
    (This)->lpVtbl -> CreateCall(This,pDestAddress,lAddressType,lMediaTypes,ppCall)

#define ITAddress_get_Calls(This,pVariant)	\
    (This)->lpVtbl -> get_Calls(This,pVariant)

#define ITAddress_EnumerateCalls(This,ppCallEnum)	\
    (This)->lpVtbl -> EnumerateCalls(This,ppCallEnum)

#define ITAddress_get_DialableAddress(This,pDialableAddress)	\
    (This)->lpVtbl -> get_DialableAddress(This,pDialableAddress)

#define ITAddress_CreateForwardInfoObject(This,ppForwardInfo)	\
    (This)->lpVtbl -> CreateForwardInfoObject(This,ppForwardInfo)

#define ITAddress_Forward(This,pForwardInfo,pCall)	\
    (This)->lpVtbl -> Forward(This,pForwardInfo,pCall)

#define ITAddress_get_CurrentForwardInfo(This,ppForwardInfo)	\
    (This)->lpVtbl -> get_CurrentForwardInfo(This,ppForwardInfo)

#define ITAddress_put_MessageWaiting(This,fMessageWaiting)	\
    (This)->lpVtbl -> put_MessageWaiting(This,fMessageWaiting)

#define ITAddress_get_MessageWaiting(This,pfMessageWaiting)	\
    (This)->lpVtbl -> get_MessageWaiting(This,pfMessageWaiting)

#define ITAddress_put_DoNotDisturb(This,fDoNotDisturb)	\
    (This)->lpVtbl -> put_DoNotDisturb(This,fDoNotDisturb)

#define ITAddress_get_DoNotDisturb(This,pfDoNotDisturb)	\
    (This)->lpVtbl -> get_DoNotDisturb(This,pfDoNotDisturb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_State_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ ADDRESS_STATE __RPC_FAR *pAddressState);


void __RPC_STUB ITAddress_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_AddressName_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITAddress_get_AddressName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_ServiceProviderName_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITAddress_get_ServiceProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_TAPIObject_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ ITTAPI __RPC_FAR *__RPC_FAR *ppTapiObject);


void __RPC_STUB ITAddress_get_TAPIObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAddress_CreateCall_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [in] */ BSTR pDestAddress,
    /* [in] */ long lAddressType,
    /* [in] */ long lMediaTypes,
    /* [retval][out] */ ITBasicCallControl __RPC_FAR *__RPC_FAR *ppCall);


void __RPC_STUB ITAddress_CreateCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_Calls_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAddress_get_Calls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITAddress_EnumerateCalls_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppCallEnum);


void __RPC_STUB ITAddress_EnumerateCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_DialableAddress_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pDialableAddress);


void __RPC_STUB ITAddress_get_DialableAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAddress_CreateForwardInfoObject_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ ITForwardInformation __RPC_FAR *__RPC_FAR *ppForwardInfo);


void __RPC_STUB ITAddress_CreateForwardInfoObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAddress_Forward_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [in] */ ITForwardInformation __RPC_FAR *pForwardInfo,
    /* [in] */ ITBasicCallControl __RPC_FAR *pCall);


void __RPC_STUB ITAddress_Forward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_CurrentForwardInfo_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ ITForwardInformation __RPC_FAR *__RPC_FAR *ppForwardInfo);


void __RPC_STUB ITAddress_get_CurrentForwardInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAddress_put_MessageWaiting_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fMessageWaiting);


void __RPC_STUB ITAddress_put_MessageWaiting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_MessageWaiting_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMessageWaiting);


void __RPC_STUB ITAddress_get_MessageWaiting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITAddress_put_DoNotDisturb_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fDoNotDisturb);


void __RPC_STUB ITAddress_put_DoNotDisturb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddress_get_DoNotDisturb_Proxy( 
    ITAddress __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfDoNotDisturb);


void __RPC_STUB ITAddress_get_DoNotDisturb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAddress_INTERFACE_DEFINED__ */


#ifndef __ITAddressCapabilities_INTERFACE_DEFINED__
#define __ITAddressCapabilities_INTERFACE_DEFINED__

/* interface ITAddressCapabilities */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8DF232F5-821B-11d1-BB5C-00C04FB6809F")
    ITAddressCapabilities : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressCapability( 
            /* [in] */ ADDRESS_CAPABILITY AddressCap,
            /* [retval][out] */ long __RPC_FAR *plCapability) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressCapabilityString( 
            /* [in] */ ADDRESS_CAPABILITY_STRING AddressCapString,
            /* [retval][out] */ BSTR __RPC_FAR *ppCapabilityString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallTreatments( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCallTreatments( 
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumCallTreatment) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CompletionMessages( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCompletionMessages( 
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumCompletionMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceClasses( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDeviceClasses( 
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumDeviceClass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAddressCapabilities __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAddressCapabilities __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddressCapability )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [in] */ ADDRESS_CAPABILITY AddressCap,
            /* [retval][out] */ long __RPC_FAR *plCapability);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddressCapabilityString )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [in] */ ADDRESS_CAPABILITY_STRING AddressCapString,
            /* [retval][out] */ BSTR __RPC_FAR *ppCapabilityString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallTreatments )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateCallTreatments )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumCallTreatment);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CompletionMessages )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateCompletionMessages )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumCompletionMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceClasses )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateDeviceClasses )( 
            ITAddressCapabilities __RPC_FAR * This,
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumDeviceClass);
        
        END_INTERFACE
    } ITAddressCapabilitiesVtbl;

    interface ITAddressCapabilities
    {
        CONST_VTBL struct ITAddressCapabilitiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressCapabilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAddressCapabilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAddressCapabilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAddressCapabilities_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAddressCapabilities_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAddressCapabilities_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAddressCapabilities_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAddressCapabilities_get_AddressCapability(This,AddressCap,plCapability)	\
    (This)->lpVtbl -> get_AddressCapability(This,AddressCap,plCapability)

#define ITAddressCapabilities_get_AddressCapabilityString(This,AddressCapString,ppCapabilityString)	\
    (This)->lpVtbl -> get_AddressCapabilityString(This,AddressCapString,ppCapabilityString)

#define ITAddressCapabilities_get_CallTreatments(This,pVariant)	\
    (This)->lpVtbl -> get_CallTreatments(This,pVariant)

#define ITAddressCapabilities_EnumerateCallTreatments(This,ppEnumCallTreatment)	\
    (This)->lpVtbl -> EnumerateCallTreatments(This,ppEnumCallTreatment)

#define ITAddressCapabilities_get_CompletionMessages(This,pVariant)	\
    (This)->lpVtbl -> get_CompletionMessages(This,pVariant)

#define ITAddressCapabilities_EnumerateCompletionMessages(This,ppEnumCompletionMessage)	\
    (This)->lpVtbl -> EnumerateCompletionMessages(This,ppEnumCompletionMessage)

#define ITAddressCapabilities_get_DeviceClasses(This,pVariant)	\
    (This)->lpVtbl -> get_DeviceClasses(This,pVariant)

#define ITAddressCapabilities_EnumerateDeviceClasses(This,ppEnumDeviceClass)	\
    (This)->lpVtbl -> EnumerateDeviceClasses(This,ppEnumDeviceClass)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_get_AddressCapability_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [in] */ ADDRESS_CAPABILITY AddressCap,
    /* [retval][out] */ long __RPC_FAR *plCapability);


void __RPC_STUB ITAddressCapabilities_get_AddressCapability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_get_AddressCapabilityString_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [in] */ ADDRESS_CAPABILITY_STRING AddressCapString,
    /* [retval][out] */ BSTR __RPC_FAR *ppCapabilityString);


void __RPC_STUB ITAddressCapabilities_get_AddressCapabilityString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_get_CallTreatments_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAddressCapabilities_get_CallTreatments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_EnumerateCallTreatments_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumCallTreatment);


void __RPC_STUB ITAddressCapabilities_EnumerateCallTreatments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_get_CompletionMessages_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAddressCapabilities_get_CompletionMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_EnumerateCompletionMessages_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumCompletionMessage);


void __RPC_STUB ITAddressCapabilities_EnumerateCompletionMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_get_DeviceClasses_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAddressCapabilities_get_DeviceClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITAddressCapabilities_EnumerateDeviceClasses_Proxy( 
    ITAddressCapabilities __RPC_FAR * This,
    /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnumDeviceClass);


void __RPC_STUB ITAddressCapabilities_EnumerateDeviceClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAddressCapabilities_INTERFACE_DEFINED__ */


#ifndef __ITBasicCallControl_INTERFACE_DEFINED__
#define __ITBasicCallControl_INTERFACE_DEFINED__

/* interface ITBasicCallControl */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITBasicCallControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC389-9355-11d0-835C-00AA003CCABD")
    ITBasicCallControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ VARIANT_BOOL fSync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Answer( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ DISCONNECT_CODE code) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Hold( 
            /* [in] */ VARIANT_BOOL fHold) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandoffDirect( 
            /* [in] */ BSTR pApplicationName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandoffIndirect( 
            /* [in] */ long lMediaType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Conference( 
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall,
            /* [in] */ VARIANT_BOOL fSync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Transfer( 
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall,
            /* [in] */ VARIANT_BOOL fSync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BlindTransfer( 
            /* [in] */ BSTR pDestAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SwapHold( 
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParkDirect( 
            /* [in] */ BSTR pParkAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParkIndirect( 
            /* [retval][out] */ BSTR __RPC_FAR *ppNonDirAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Unpark( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetQOS( 
            /* [in] */ long lMediaType,
            /* [in] */ QOS_SERVICE_LEVEL ServiceLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pickup( 
            /* [in] */ BSTR pGroupID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Dial( 
            /* [in] */ BSTR pDestAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Finish( 
            /* [in] */ FINISH_MODE finishMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveFromConference( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITBasicCallControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITBasicCallControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITBasicCallControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Answer )( 
            ITBasicCallControl __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ DISCONNECT_CODE code);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Hold )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fHold);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandoffDirect )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ BSTR pApplicationName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandoffIndirect )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Conference )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Transfer )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BlindTransfer )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ BSTR pDestAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SwapHold )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ ITBasicCallControl __RPC_FAR *pCall);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParkDirect )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ BSTR pParkAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParkIndirect )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppNonDirAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unpark )( 
            ITBasicCallControl __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQOS )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ long lMediaType,
            /* [in] */ QOS_SERVICE_LEVEL ServiceLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pickup )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ BSTR pGroupID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Dial )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ BSTR pDestAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Finish )( 
            ITBasicCallControl __RPC_FAR * This,
            /* [in] */ FINISH_MODE finishMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveFromConference )( 
            ITBasicCallControl __RPC_FAR * This);
        
        END_INTERFACE
    } ITBasicCallControlVtbl;

    interface ITBasicCallControl
    {
        CONST_VTBL struct ITBasicCallControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITBasicCallControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITBasicCallControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITBasicCallControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITBasicCallControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITBasicCallControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITBasicCallControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITBasicCallControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITBasicCallControl_Connect(This,fSync)	\
    (This)->lpVtbl -> Connect(This,fSync)

#define ITBasicCallControl_Answer(This)	\
    (This)->lpVtbl -> Answer(This)

#define ITBasicCallControl_Disconnect(This,code)	\
    (This)->lpVtbl -> Disconnect(This,code)

#define ITBasicCallControl_Hold(This,fHold)	\
    (This)->lpVtbl -> Hold(This,fHold)

#define ITBasicCallControl_HandoffDirect(This,pApplicationName)	\
    (This)->lpVtbl -> HandoffDirect(This,pApplicationName)

#define ITBasicCallControl_HandoffIndirect(This,lMediaType)	\
    (This)->lpVtbl -> HandoffIndirect(This,lMediaType)

#define ITBasicCallControl_Conference(This,pCall,fSync)	\
    (This)->lpVtbl -> Conference(This,pCall,fSync)

#define ITBasicCallControl_Transfer(This,pCall,fSync)	\
    (This)->lpVtbl -> Transfer(This,pCall,fSync)

#define ITBasicCallControl_BlindTransfer(This,pDestAddress)	\
    (This)->lpVtbl -> BlindTransfer(This,pDestAddress)

#define ITBasicCallControl_SwapHold(This,pCall)	\
    (This)->lpVtbl -> SwapHold(This,pCall)

#define ITBasicCallControl_ParkDirect(This,pParkAddress)	\
    (This)->lpVtbl -> ParkDirect(This,pParkAddress)

#define ITBasicCallControl_ParkIndirect(This,ppNonDirAddress)	\
    (This)->lpVtbl -> ParkIndirect(This,ppNonDirAddress)

#define ITBasicCallControl_Unpark(This)	\
    (This)->lpVtbl -> Unpark(This)

#define ITBasicCallControl_SetQOS(This,lMediaType,ServiceLevel)	\
    (This)->lpVtbl -> SetQOS(This,lMediaType,ServiceLevel)

#define ITBasicCallControl_Pickup(This,pGroupID)	\
    (This)->lpVtbl -> Pickup(This,pGroupID)

#define ITBasicCallControl_Dial(This,pDestAddress)	\
    (This)->lpVtbl -> Dial(This,pDestAddress)

#define ITBasicCallControl_Finish(This,finishMode)	\
    (This)->lpVtbl -> Finish(This,finishMode)

#define ITBasicCallControl_RemoveFromConference(This)	\
    (This)->lpVtbl -> RemoveFromConference(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Connect_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSync);


void __RPC_STUB ITBasicCallControl_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Answer_Proxy( 
    ITBasicCallControl __RPC_FAR * This);


void __RPC_STUB ITBasicCallControl_Answer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Disconnect_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ DISCONNECT_CODE code);


void __RPC_STUB ITBasicCallControl_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Hold_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fHold);


void __RPC_STUB ITBasicCallControl_Hold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_HandoffDirect_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ BSTR pApplicationName);


void __RPC_STUB ITBasicCallControl_HandoffDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_HandoffIndirect_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ long lMediaType);


void __RPC_STUB ITBasicCallControl_HandoffIndirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Conference_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ ITBasicCallControl __RPC_FAR *pCall,
    /* [in] */ VARIANT_BOOL fSync);


void __RPC_STUB ITBasicCallControl_Conference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Transfer_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ ITBasicCallControl __RPC_FAR *pCall,
    /* [in] */ VARIANT_BOOL fSync);


void __RPC_STUB ITBasicCallControl_Transfer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_BlindTransfer_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ BSTR pDestAddress);


void __RPC_STUB ITBasicCallControl_BlindTransfer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_SwapHold_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ ITBasicCallControl __RPC_FAR *pCall);


void __RPC_STUB ITBasicCallControl_SwapHold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_ParkDirect_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ BSTR pParkAddress);


void __RPC_STUB ITBasicCallControl_ParkDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_ParkIndirect_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppNonDirAddress);


void __RPC_STUB ITBasicCallControl_ParkIndirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Unpark_Proxy( 
    ITBasicCallControl __RPC_FAR * This);


void __RPC_STUB ITBasicCallControl_Unpark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_SetQOS_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ long lMediaType,
    /* [in] */ QOS_SERVICE_LEVEL ServiceLevel);


void __RPC_STUB ITBasicCallControl_SetQOS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Pickup_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ BSTR pGroupID);


void __RPC_STUB ITBasicCallControl_Pickup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Dial_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ BSTR pDestAddress);


void __RPC_STUB ITBasicCallControl_Dial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_Finish_Proxy( 
    ITBasicCallControl __RPC_FAR * This,
    /* [in] */ FINISH_MODE finishMode);


void __RPC_STUB ITBasicCallControl_Finish_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITBasicCallControl_RemoveFromConference_Proxy( 
    ITBasicCallControl __RPC_FAR * This);


void __RPC_STUB ITBasicCallControl_RemoveFromConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITBasicCallControl_INTERFACE_DEFINED__ */


#ifndef __ITCallInfo_INTERFACE_DEFINED__
#define __ITCallInfo_INTERFACE_DEFINED__

/* interface ITCallInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("350F85D1-1227-11D3-83D4-00C04FB6809F")
    ITCallInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallState( 
            /* [retval][out] */ CALL_STATE __RPC_FAR *pCallState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Privilege( 
            /* [retval][out] */ CALL_PRIVILEGE __RPC_FAR *pPrivilege) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHub( 
            /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallInfoLong( 
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [retval][out] */ long __RPC_FAR *plCallInfoLongVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallInfoLong( 
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [in] */ long lCallInfoLongVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallInfoString( 
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [retval][out] */ BSTR __RPC_FAR *ppCallInfoString) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallInfoString( 
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [in] */ BSTR pCallInfoString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [retval][out] */ VARIANT __RPC_FAR *ppCallInfoBuffer) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ VARIANT pCallInfoBuffer) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetCallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCallInfoBuffer) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE SetCallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pCallInfoBuffer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseUserUserInfo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            ITCallInfo __RPC_FAR * This,
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallState )( 
            ITCallInfo __RPC_FAR * This,
            /* [retval][out] */ CALL_STATE __RPC_FAR *pCallState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Privilege )( 
            ITCallInfo __RPC_FAR * This,
            /* [retval][out] */ CALL_PRIVILEGE __RPC_FAR *pPrivilege);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallHub )( 
            ITCallInfo __RPC_FAR * This,
            /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallInfoLong )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [retval][out] */ long __RPC_FAR *plCallInfoLongVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CallInfoLong )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [in] */ long lCallInfoLongVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallInfoString )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [retval][out] */ BSTR __RPC_FAR *ppCallInfoString);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CallInfoString )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [in] */ BSTR pCallInfoString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallInfoBuffer )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [retval][out] */ VARIANT __RPC_FAR *ppCallInfoBuffer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CallInfoBuffer )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ VARIANT pCallInfoBuffer);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallInfoBuffer )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCallInfoBuffer);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCallInfoBuffer )( 
            ITCallInfo __RPC_FAR * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pCallInfoBuffer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseUserUserInfo )( 
            ITCallInfo __RPC_FAR * This);
        
        END_INTERFACE
    } ITCallInfoVtbl;

    interface ITCallInfo
    {
        CONST_VTBL struct ITCallInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallInfo_get_Address(This,ppAddress)	\
    (This)->lpVtbl -> get_Address(This,ppAddress)

#define ITCallInfo_get_CallState(This,pCallState)	\
    (This)->lpVtbl -> get_CallState(This,pCallState)

#define ITCallInfo_get_Privilege(This,pPrivilege)	\
    (This)->lpVtbl -> get_Privilege(This,pPrivilege)

#define ITCallInfo_get_CallHub(This,ppCallHub)	\
    (This)->lpVtbl -> get_CallHub(This,ppCallHub)

#define ITCallInfo_get_CallInfoLong(This,CallInfoLong,plCallInfoLongVal)	\
    (This)->lpVtbl -> get_CallInfoLong(This,CallInfoLong,plCallInfoLongVal)

#define ITCallInfo_put_CallInfoLong(This,CallInfoLong,lCallInfoLongVal)	\
    (This)->lpVtbl -> put_CallInfoLong(This,CallInfoLong,lCallInfoLongVal)

#define ITCallInfo_get_CallInfoString(This,CallInfoString,ppCallInfoString)	\
    (This)->lpVtbl -> get_CallInfoString(This,CallInfoString,ppCallInfoString)

#define ITCallInfo_put_CallInfoString(This,CallInfoString,pCallInfoString)	\
    (This)->lpVtbl -> put_CallInfoString(This,CallInfoString,pCallInfoString)

#define ITCallInfo_get_CallInfoBuffer(This,CallInfoBuffer,ppCallInfoBuffer)	\
    (This)->lpVtbl -> get_CallInfoBuffer(This,CallInfoBuffer,ppCallInfoBuffer)

#define ITCallInfo_put_CallInfoBuffer(This,CallInfoBuffer,pCallInfoBuffer)	\
    (This)->lpVtbl -> put_CallInfoBuffer(This,CallInfoBuffer,pCallInfoBuffer)

#define ITCallInfo_GetCallInfoBuffer(This,CallInfoBuffer,pdwSize,ppCallInfoBuffer)	\
    (This)->lpVtbl -> GetCallInfoBuffer(This,CallInfoBuffer,pdwSize,ppCallInfoBuffer)

#define ITCallInfo_SetCallInfoBuffer(This,CallInfoBuffer,dwSize,pCallInfoBuffer)	\
    (This)->lpVtbl -> SetCallInfoBuffer(This,CallInfoBuffer,dwSize,pCallInfoBuffer)

#define ITCallInfo_ReleaseUserUserInfo(This)	\
    (This)->lpVtbl -> ReleaseUserUserInfo(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_Address_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB ITCallInfo_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_CallState_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [retval][out] */ CALL_STATE __RPC_FAR *pCallState);


void __RPC_STUB ITCallInfo_get_CallState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_Privilege_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [retval][out] */ CALL_PRIVILEGE __RPC_FAR *pPrivilege);


void __RPC_STUB ITCallInfo_get_Privilege_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_CallHub_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub);


void __RPC_STUB ITCallInfo_get_CallHub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_CallInfoLong_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_LONG CallInfoLong,
    /* [retval][out] */ long __RPC_FAR *plCallInfoLongVal);


void __RPC_STUB ITCallInfo_get_CallInfoLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITCallInfo_put_CallInfoLong_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_LONG CallInfoLong,
    /* [in] */ long lCallInfoLongVal);


void __RPC_STUB ITCallInfo_put_CallInfoLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_CallInfoString_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_STRING CallInfoString,
    /* [retval][out] */ BSTR __RPC_FAR *ppCallInfoString);


void __RPC_STUB ITCallInfo_get_CallInfoString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITCallInfo_put_CallInfoString_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_STRING CallInfoString,
    /* [in] */ BSTR pCallInfoString);


void __RPC_STUB ITCallInfo_put_CallInfoString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfo_get_CallInfoBuffer_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
    /* [retval][out] */ VARIANT __RPC_FAR *ppCallInfoBuffer);


void __RPC_STUB ITCallInfo_get_CallInfoBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITCallInfo_put_CallInfoBuffer_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
    /* [in] */ VARIANT pCallInfoBuffer);


void __RPC_STUB ITCallInfo_put_CallInfoBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITCallInfo_GetCallInfoBuffer_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwSize,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCallInfoBuffer);


void __RPC_STUB ITCallInfo_GetCallInfoBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITCallInfo_SetCallInfoBuffer_Proxy( 
    ITCallInfo __RPC_FAR * This,
    /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
    /* [in] */ DWORD dwSize,
    /* [size_is][in] */ BYTE __RPC_FAR *pCallInfoBuffer);


void __RPC_STUB ITCallInfo_SetCallInfoBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITCallInfo_ReleaseUserUserInfo_Proxy( 
    ITCallInfo __RPC_FAR * This);


void __RPC_STUB ITCallInfo_ReleaseUserUserInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallInfo_INTERFACE_DEFINED__ */


#ifndef __ITTerminal_INTERFACE_DEFINED__
#define __ITTerminal_INTERFACE_DEFINED__

/* interface ITTerminal */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC38A-9355-11d0-835C-00AA003CCABD")
    ITTerminal : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ TERMINAL_STATE __RPC_FAR *pTerminalState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TerminalType( 
            /* [retval][out] */ TERMINAL_TYPE __RPC_FAR *pType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TerminalClass( 
            /* [retval][out] */ BSTR __RPC_FAR *ppTerminalClass) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ long __RPC_FAR *plMediaType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ TERMINAL_DIRECTION __RPC_FAR *pDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTerminal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTerminal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTerminal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITTerminal __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITTerminal __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITTerminal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITTerminal __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ITTerminal __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ITTerminal __RPC_FAR * This,
            /* [retval][out] */ TERMINAL_STATE __RPC_FAR *pTerminalState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TerminalType )( 
            ITTerminal __RPC_FAR * This,
            /* [retval][out] */ TERMINAL_TYPE __RPC_FAR *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TerminalClass )( 
            ITTerminal __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppTerminalClass);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MediaType )( 
            ITTerminal __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMediaType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            ITTerminal __RPC_FAR * This,
            /* [retval][out] */ TERMINAL_DIRECTION __RPC_FAR *pDirection);
        
        END_INTERFACE
    } ITTerminalVtbl;

    interface ITTerminal
    {
        CONST_VTBL struct ITTerminalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTerminal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTerminal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTerminal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTerminal_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTerminal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTerminal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTerminal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTerminal_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITTerminal_get_State(This,pTerminalState)	\
    (This)->lpVtbl -> get_State(This,pTerminalState)

#define ITTerminal_get_TerminalType(This,pType)	\
    (This)->lpVtbl -> get_TerminalType(This,pType)

#define ITTerminal_get_TerminalClass(This,ppTerminalClass)	\
    (This)->lpVtbl -> get_TerminalClass(This,ppTerminalClass)

#define ITTerminal_get_MediaType(This,plMediaType)	\
    (This)->lpVtbl -> get_MediaType(This,plMediaType)

#define ITTerminal_get_Direction(This,pDirection)	\
    (This)->lpVtbl -> get_Direction(This,pDirection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminal_get_Name_Proxy( 
    ITTerminal __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITTerminal_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminal_get_State_Proxy( 
    ITTerminal __RPC_FAR * This,
    /* [retval][out] */ TERMINAL_STATE __RPC_FAR *pTerminalState);


void __RPC_STUB ITTerminal_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminal_get_TerminalType_Proxy( 
    ITTerminal __RPC_FAR * This,
    /* [retval][out] */ TERMINAL_TYPE __RPC_FAR *pType);


void __RPC_STUB ITTerminal_get_TerminalType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminal_get_TerminalClass_Proxy( 
    ITTerminal __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppTerminalClass);


void __RPC_STUB ITTerminal_get_TerminalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminal_get_MediaType_Proxy( 
    ITTerminal __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMediaType);


void __RPC_STUB ITTerminal_get_MediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTerminal_get_Direction_Proxy( 
    ITTerminal __RPC_FAR * This,
    /* [retval][out] */ TERMINAL_DIRECTION __RPC_FAR *pDirection);


void __RPC_STUB ITTerminal_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTerminal_INTERFACE_DEFINED__ */


#ifndef __ITBasicAudioTerminal_INTERFACE_DEFINED__
#define __ITBasicAudioTerminal_INTERFACE_DEFINED__

/* interface ITBasicAudioTerminal */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITBasicAudioTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC38D-9355-11d0-835C-00AA003CCABD")
    ITBasicAudioTerminal : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long __RPC_FAR *plVolume) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long __RPC_FAR *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITBasicAudioTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITBasicAudioTerminal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITBasicAudioTerminal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Volume )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [in] */ long lVolume);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Volume )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVolume);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Balance )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [in] */ long lBalance);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Balance )( 
            ITBasicAudioTerminal __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBalance);
        
        END_INTERFACE
    } ITBasicAudioTerminalVtbl;

    interface ITBasicAudioTerminal
    {
        CONST_VTBL struct ITBasicAudioTerminalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITBasicAudioTerminal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITBasicAudioTerminal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITBasicAudioTerminal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITBasicAudioTerminal_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITBasicAudioTerminal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITBasicAudioTerminal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITBasicAudioTerminal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITBasicAudioTerminal_put_Volume(This,lVolume)	\
    (This)->lpVtbl -> put_Volume(This,lVolume)

#define ITBasicAudioTerminal_get_Volume(This,plVolume)	\
    (This)->lpVtbl -> get_Volume(This,plVolume)

#define ITBasicAudioTerminal_put_Balance(This,lBalance)	\
    (This)->lpVtbl -> put_Balance(This,lBalance)

#define ITBasicAudioTerminal_get_Balance(This,plBalance)	\
    (This)->lpVtbl -> get_Balance(This,plBalance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITBasicAudioTerminal_put_Volume_Proxy( 
    ITBasicAudioTerminal __RPC_FAR * This,
    /* [in] */ long lVolume);


void __RPC_STUB ITBasicAudioTerminal_put_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITBasicAudioTerminal_get_Volume_Proxy( 
    ITBasicAudioTerminal __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVolume);


void __RPC_STUB ITBasicAudioTerminal_get_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITBasicAudioTerminal_put_Balance_Proxy( 
    ITBasicAudioTerminal __RPC_FAR * This,
    /* [in] */ long lBalance);


void __RPC_STUB ITBasicAudioTerminal_put_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITBasicAudioTerminal_get_Balance_Proxy( 
    ITBasicAudioTerminal __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBalance);


void __RPC_STUB ITBasicAudioTerminal_get_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITBasicAudioTerminal_INTERFACE_DEFINED__ */


#ifndef __ITCallHub_INTERFACE_DEFINED__
#define __ITCallHub_INTERFACE_DEFINED__

/* interface ITCallHub */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallHub;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C1544E-5B92-11d1-8F4E-00C04FB6809F")
    ITCallHub : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCalls( 
            /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppEnumCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Calls( 
            /* [retval][out] */ VARIANT __RPC_FAR *pCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumCalls( 
            /* [retval][out] */ long __RPC_FAR *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ CALLHUB_STATE __RPC_FAR *pState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallHubVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallHub __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallHub __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallHub __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallHub __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallHub __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallHub __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallHub __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ITCallHub __RPC_FAR * This);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateCalls )( 
            ITCallHub __RPC_FAR * This,
            /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppEnumCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Calls )( 
            ITCallHub __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumCalls )( 
            ITCallHub __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ITCallHub __RPC_FAR * This,
            /* [retval][out] */ CALLHUB_STATE __RPC_FAR *pState);
        
        END_INTERFACE
    } ITCallHubVtbl;

    interface ITCallHub
    {
        CONST_VTBL struct ITCallHubVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallHub_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallHub_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallHub_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallHub_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallHub_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallHub_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallHub_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallHub_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define ITCallHub_EnumerateCalls(This,ppEnumCall)	\
    (This)->lpVtbl -> EnumerateCalls(This,ppEnumCall)

#define ITCallHub_get_Calls(This,pCalls)	\
    (This)->lpVtbl -> get_Calls(This,pCalls)

#define ITCallHub_get_NumCalls(This,plCalls)	\
    (This)->lpVtbl -> get_NumCalls(This,plCalls)

#define ITCallHub_get_State(This,pState)	\
    (This)->lpVtbl -> get_State(This,pState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITCallHub_Clear_Proxy( 
    ITCallHub __RPC_FAR * This);


void __RPC_STUB ITCallHub_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITCallHub_EnumerateCalls_Proxy( 
    ITCallHub __RPC_FAR * This,
    /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppEnumCall);


void __RPC_STUB ITCallHub_EnumerateCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallHub_get_Calls_Proxy( 
    ITCallHub __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pCalls);


void __RPC_STUB ITCallHub_get_Calls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallHub_get_NumCalls_Proxy( 
    ITCallHub __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCalls);


void __RPC_STUB ITCallHub_get_NumCalls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallHub_get_State_Proxy( 
    ITCallHub __RPC_FAR * This,
    /* [retval][out] */ CALLHUB_STATE __RPC_FAR *pState);


void __RPC_STUB ITCallHub_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallHub_INTERFACE_DEFINED__ */


#ifndef __ITLegacyAddressMediaControl_INTERFACE_DEFINED__
#define __ITLegacyAddressMediaControl_INTERFACE_DEFINED__

/* interface ITLegacyAddressMediaControl */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyAddressMediaControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB493640-4C0B-11D2-A046-00C04FB6809F")
    ITLegacyAddressMediaControl : public IUnknown
    {
    public:
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ BSTR pDeviceClass,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceID) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetDevConfig( 
            /* [in] */ BSTR pDeviceClass,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceConfig) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE SetDevConfig( 
            /* [in] */ BSTR pDeviceClass,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pDeviceConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyAddressMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITLegacyAddressMediaControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITLegacyAddressMediaControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITLegacyAddressMediaControl __RPC_FAR * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            ITLegacyAddressMediaControl __RPC_FAR * This,
            /* [in] */ BSTR pDeviceClass,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceID);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDevConfig )( 
            ITLegacyAddressMediaControl __RPC_FAR * This,
            /* [in] */ BSTR pDeviceClass,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceConfig);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDevConfig )( 
            ITLegacyAddressMediaControl __RPC_FAR * This,
            /* [in] */ BSTR pDeviceClass,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pDeviceConfig);
        
        END_INTERFACE
    } ITLegacyAddressMediaControlVtbl;

    interface ITLegacyAddressMediaControl
    {
        CONST_VTBL struct ITLegacyAddressMediaControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyAddressMediaControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITLegacyAddressMediaControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITLegacyAddressMediaControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITLegacyAddressMediaControl_GetID(This,pDeviceClass,pdwSize,ppDeviceID)	\
    (This)->lpVtbl -> GetID(This,pDeviceClass,pdwSize,ppDeviceID)

#define ITLegacyAddressMediaControl_GetDevConfig(This,pDeviceClass,pdwSize,ppDeviceConfig)	\
    (This)->lpVtbl -> GetDevConfig(This,pDeviceClass,pdwSize,ppDeviceConfig)

#define ITLegacyAddressMediaControl_SetDevConfig(This,pDeviceClass,dwSize,pDeviceConfig)	\
    (This)->lpVtbl -> SetDevConfig(This,pDeviceClass,dwSize,pDeviceConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITLegacyAddressMediaControl_GetID_Proxy( 
    ITLegacyAddressMediaControl __RPC_FAR * This,
    /* [in] */ BSTR pDeviceClass,
    /* [out] */ DWORD __RPC_FAR *pdwSize,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceID);


void __RPC_STUB ITLegacyAddressMediaControl_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITLegacyAddressMediaControl_GetDevConfig_Proxy( 
    ITLegacyAddressMediaControl __RPC_FAR * This,
    /* [in] */ BSTR pDeviceClass,
    /* [out] */ DWORD __RPC_FAR *pdwSize,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceConfig);


void __RPC_STUB ITLegacyAddressMediaControl_GetDevConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITLegacyAddressMediaControl_SetDevConfig_Proxy( 
    ITLegacyAddressMediaControl __RPC_FAR * This,
    /* [in] */ BSTR pDeviceClass,
    /* [in] */ DWORD dwSize,
    /* [size_is][in] */ BYTE __RPC_FAR *pDeviceConfig);


void __RPC_STUB ITLegacyAddressMediaControl_SetDevConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITLegacyAddressMediaControl_INTERFACE_DEFINED__ */


#ifndef __ITLegacyCallMediaControl_INTERFACE_DEFINED__
#define __ITLegacyCallMediaControl_INTERFACE_DEFINED__

/* interface ITLegacyCallMediaControl */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyCallMediaControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d624582f-cc23-4436-b8a5-47c625c8045d")
    ITLegacyCallMediaControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DetectDigits( 
            /* [in] */ TAPI_DIGITMODE DigitMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateDigits( 
            /* [in] */ BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ BSTR pDeviceClass,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ long lMediaType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MonitorMedia( 
            /* [in] */ long lMediaType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyCallMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITLegacyCallMediaControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITLegacyCallMediaControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetectDigits )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ TAPI_DIGITMODE DigitMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateDigits )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ BSTR pDeviceClass,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonitorMedia )( 
            ITLegacyCallMediaControl __RPC_FAR * This,
            /* [in] */ long lMediaType);
        
        END_INTERFACE
    } ITLegacyCallMediaControlVtbl;

    interface ITLegacyCallMediaControl
    {
        CONST_VTBL struct ITLegacyCallMediaControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyCallMediaControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITLegacyCallMediaControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITLegacyCallMediaControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITLegacyCallMediaControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITLegacyCallMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITLegacyCallMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITLegacyCallMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITLegacyCallMediaControl_DetectDigits(This,DigitMode)	\
    (This)->lpVtbl -> DetectDigits(This,DigitMode)

#define ITLegacyCallMediaControl_GenerateDigits(This,pDigits,DigitMode)	\
    (This)->lpVtbl -> GenerateDigits(This,pDigits,DigitMode)

#define ITLegacyCallMediaControl_GetID(This,pDeviceClass,pdwSize,ppDeviceID)	\
    (This)->lpVtbl -> GetID(This,pDeviceClass,pdwSize,ppDeviceID)

#define ITLegacyCallMediaControl_SetMediaType(This,lMediaType)	\
    (This)->lpVtbl -> SetMediaType(This,lMediaType)

#define ITLegacyCallMediaControl_MonitorMedia(This,lMediaType)	\
    (This)->lpVtbl -> MonitorMedia(This,lMediaType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITLegacyCallMediaControl_DetectDigits_Proxy( 
    ITLegacyCallMediaControl __RPC_FAR * This,
    /* [in] */ TAPI_DIGITMODE DigitMode);


void __RPC_STUB ITLegacyCallMediaControl_DetectDigits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITLegacyCallMediaControl_GenerateDigits_Proxy( 
    ITLegacyCallMediaControl __RPC_FAR * This,
    /* [in] */ BSTR pDigits,
    /* [in] */ TAPI_DIGITMODE DigitMode);


void __RPC_STUB ITLegacyCallMediaControl_GenerateDigits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITLegacyCallMediaControl_GetID_Proxy( 
    ITLegacyCallMediaControl __RPC_FAR * This,
    /* [in] */ BSTR pDeviceClass,
    /* [out] */ DWORD __RPC_FAR *pdwSize,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDeviceID);


void __RPC_STUB ITLegacyCallMediaControl_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITLegacyCallMediaControl_SetMediaType_Proxy( 
    ITLegacyCallMediaControl __RPC_FAR * This,
    /* [in] */ long lMediaType);


void __RPC_STUB ITLegacyCallMediaControl_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITLegacyCallMediaControl_MonitorMedia_Proxy( 
    ITLegacyCallMediaControl __RPC_FAR * This,
    /* [in] */ long lMediaType);


void __RPC_STUB ITLegacyCallMediaControl_MonitorMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITLegacyCallMediaControl_INTERFACE_DEFINED__ */


#ifndef __IEnumTerminal_INTERFACE_DEFINED__
#define __IEnumTerminal_INTERFACE_DEFINED__

/* interface IEnumTerminal */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE269CF4-935E-11d0-835C-00AA003CCABD")
    IEnumTerminal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumTerminal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumTerminal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumTerminal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumTerminal __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumTerminal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumTerminal __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumTerminal __RPC_FAR * This,
            /* [retval][out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumTerminalVtbl;

    interface IEnumTerminal
    {
        CONST_VTBL struct IEnumTerminalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTerminal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTerminal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTerminal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTerminal_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumTerminal_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTerminal_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumTerminal_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTerminal_Next_Proxy( 
    IEnumTerminal __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumTerminal_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTerminal_Reset_Proxy( 
    IEnumTerminal __RPC_FAR * This);


void __RPC_STUB IEnumTerminal_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTerminal_Skip_Proxy( 
    IEnumTerminal __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumTerminal_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTerminal_Clone_Proxy( 
    IEnumTerminal __RPC_FAR * This,
    /* [retval][out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumTerminal_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTerminal_INTERFACE_DEFINED__ */


#ifndef __IEnumTerminalClass_INTERFACE_DEFINED__
#define __IEnumTerminalClass_INTERFACE_DEFINED__

/* interface IEnumTerminalClass */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumTerminalClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE269CF5-935E-11d0-835C-00AA003CCABD")
    IEnumTerminalClass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ GUID __RPC_FAR *pElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumTerminalClass __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTerminalClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumTerminalClass __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumTerminalClass __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumTerminalClass __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumTerminalClass __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ GUID __RPC_FAR *pElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumTerminalClass __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumTerminalClass __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumTerminalClass __RPC_FAR * This,
            /* [retval][out] */ IEnumTerminalClass __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumTerminalClassVtbl;

    interface IEnumTerminalClass
    {
        CONST_VTBL struct IEnumTerminalClassVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTerminalClass_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTerminalClass_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTerminalClass_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTerminalClass_Next(This,celt,pElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pElements,pceltFetched)

#define IEnumTerminalClass_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTerminalClass_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumTerminalClass_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTerminalClass_Next_Proxy( 
    IEnumTerminalClass __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ GUID __RPC_FAR *pElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumTerminalClass_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTerminalClass_Reset_Proxy( 
    IEnumTerminalClass __RPC_FAR * This);


void __RPC_STUB IEnumTerminalClass_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTerminalClass_Skip_Proxy( 
    IEnumTerminalClass __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumTerminalClass_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTerminalClass_Clone_Proxy( 
    IEnumTerminalClass __RPC_FAR * This,
    /* [retval][out] */ IEnumTerminalClass __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumTerminalClass_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTerminalClass_INTERFACE_DEFINED__ */


#ifndef __IEnumCall_INTERFACE_DEFINED__
#define __IEnumCall_INTERFACE_DEFINED__

/* interface IEnumCall */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE269CF6-935E-11d0-835C-00AA003CCABD")
    IEnumCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCall __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCall __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCall __RPC_FAR * This,
            /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumCallVtbl;

    interface IEnumCall
    {
        CONST_VTBL struct IEnumCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCall_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumCall_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCall_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCall_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCall_Next_Proxy( 
    IEnumCall __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCall_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCall_Reset_Proxy( 
    IEnumCall __RPC_FAR * This);


void __RPC_STUB IEnumCall_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCall_Skip_Proxy( 
    IEnumCall __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCall_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCall_Clone_Proxy( 
    IEnumCall __RPC_FAR * This,
    /* [retval][out] */ IEnumCall __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumCall_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCall_INTERFACE_DEFINED__ */


#ifndef __IEnumAddress_INTERFACE_DEFINED__
#define __IEnumAddress_INTERFACE_DEFINED__

/* interface IEnumAddress */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1666FCA1-9363-11d0-835C-00AA003CCABD")
    IEnumAddress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumAddress __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumAddress __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumAddress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumAddress __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumAddress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumAddress __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumAddress __RPC_FAR * This,
            /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumAddressVtbl;

    interface IEnumAddress
    {
        CONST_VTBL struct IEnumAddressVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAddress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAddress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAddress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAddress_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumAddress_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAddress_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumAddress_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAddress_Next_Proxy( 
    IEnumAddress __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumAddress_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAddress_Reset_Proxy( 
    IEnumAddress __RPC_FAR * This);


void __RPC_STUB IEnumAddress_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAddress_Skip_Proxy( 
    IEnumAddress __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumAddress_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAddress_Clone_Proxy( 
    IEnumAddress __RPC_FAR * This,
    /* [retval][out] */ IEnumAddress __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumAddress_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAddress_INTERFACE_DEFINED__ */


#ifndef __IEnumCallHub_INTERFACE_DEFINED__
#define __IEnumCallHub_INTERFACE_DEFINED__

/* interface IEnumCallHub */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumCallHub;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C15450-5B92-11d1-8F4E-00C04FB6809F")
    IEnumCallHub : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCallHub __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCallHubVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCallHub __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCallHub __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCallHub __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCallHub __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCallHub __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCallHub __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCallHub __RPC_FAR * This,
            /* [retval][out] */ IEnumCallHub __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumCallHubVtbl;

    interface IEnumCallHub
    {
        CONST_VTBL struct IEnumCallHubVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCallHub_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCallHub_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCallHub_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCallHub_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumCallHub_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCallHub_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCallHub_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCallHub_Next_Proxy( 
    IEnumCallHub __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCallHub_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCallHub_Reset_Proxy( 
    IEnumCallHub __RPC_FAR * This);


void __RPC_STUB IEnumCallHub_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCallHub_Skip_Proxy( 
    IEnumCallHub __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCallHub_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCallHub_Clone_Proxy( 
    IEnumCallHub __RPC_FAR * This,
    /* [retval][out] */ IEnumCallHub __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumCallHub_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCallHub_INTERFACE_DEFINED__ */


#ifndef __IEnumBstr_INTERFACE_DEFINED__
#define __IEnumBstr_INTERFACE_DEFINED__

/* interface IEnumBstr */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBstr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35372049-0BC6-11d2-A033-00C04FB6809F")
    IEnumBstr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ BSTR __RPC_FAR *ppStrings,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBstrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumBstr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumBstr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumBstr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumBstr __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ BSTR __RPC_FAR *ppStrings,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumBstr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumBstr __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumBstr __RPC_FAR * This,
            /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumBstrVtbl;

    interface IEnumBstr
    {
        CONST_VTBL struct IEnumBstrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBstr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBstr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBstr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBstr_Next(This,celt,ppStrings,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppStrings,pceltFetched)

#define IEnumBstr_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBstr_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumBstr_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBstr_Next_Proxy( 
    IEnumBstr __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ BSTR __RPC_FAR *ppStrings,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumBstr_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBstr_Reset_Proxy( 
    IEnumBstr __RPC_FAR * This);


void __RPC_STUB IEnumBstr_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBstr_Skip_Proxy( 
    IEnumBstr __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumBstr_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBstr_Clone_Proxy( 
    IEnumBstr __RPC_FAR * This,
    /* [retval][out] */ IEnumBstr __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumBstr_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBstr_INTERFACE_DEFINED__ */


#ifndef __ITCallStateEvent_INTERFACE_DEFINED__
#define __ITCallStateEvent_INTERFACE_DEFINED__

/* interface ITCallStateEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallStateEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62F47097-95C9-11d0-835D-00AA003CCABD")
    ITCallStateEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ CALL_STATE __RPC_FAR *pCallState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ CALL_STATE_EVENT_CAUSE __RPC_FAR *pCEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallStateEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallStateEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallStateEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [retval][out] */ CALL_STATE __RPC_FAR *pCallState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cause )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [retval][out] */ CALL_STATE_EVENT_CAUSE __RPC_FAR *pCEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallbackInstance )( 
            ITCallStateEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance);
        
        END_INTERFACE
    } ITCallStateEventVtbl;

    interface ITCallStateEvent
    {
        CONST_VTBL struct ITCallStateEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallStateEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallStateEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallStateEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallStateEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallStateEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallStateEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallStateEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallStateEvent_get_Call(This,ppCallInfo)	\
    (This)->lpVtbl -> get_Call(This,ppCallInfo)

#define ITCallStateEvent_get_State(This,pCallState)	\
    (This)->lpVtbl -> get_State(This,pCallState)

#define ITCallStateEvent_get_Cause(This,pCEC)	\
    (This)->lpVtbl -> get_Cause(This,pCEC)

#define ITCallStateEvent_get_CallbackInstance(This,plCallbackInstance)	\
    (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallStateEvent_get_Call_Proxy( 
    ITCallStateEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);


void __RPC_STUB ITCallStateEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallStateEvent_get_State_Proxy( 
    ITCallStateEvent __RPC_FAR * This,
    /* [retval][out] */ CALL_STATE __RPC_FAR *pCallState);


void __RPC_STUB ITCallStateEvent_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallStateEvent_get_Cause_Proxy( 
    ITCallStateEvent __RPC_FAR * This,
    /* [retval][out] */ CALL_STATE_EVENT_CAUSE __RPC_FAR *pCEC);


void __RPC_STUB ITCallStateEvent_get_Cause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallStateEvent_get_CallbackInstance_Proxy( 
    ITCallStateEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallbackInstance);


void __RPC_STUB ITCallStateEvent_get_CallbackInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallStateEvent_INTERFACE_DEFINED__ */


#ifndef __ITCallMediaEvent_INTERFACE_DEFINED__
#define __ITCallMediaEvent_INTERFACE_DEFINED__

/* interface ITCallMediaEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallMediaEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FF36B87F-EC3A-11d0-8EE4-00C04FB6809F")
    ITCallMediaEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ CALL_MEDIA_EVENT __RPC_FAR *pCallMediaEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ HRESULT __RPC_FAR *phrError) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Stream( 
            /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ CALL_MEDIA_EVENT_CAUSE __RPC_FAR *pCause) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallMediaEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallMediaEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [retval][out] */ CALL_MEDIA_EVENT __RPC_FAR *pCallMediaEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Error )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [retval][out] */ HRESULT __RPC_FAR *phrError);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Terminal )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Stream )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cause )( 
            ITCallMediaEvent __RPC_FAR * This,
            /* [retval][out] */ CALL_MEDIA_EVENT_CAUSE __RPC_FAR *pCause);
        
        END_INTERFACE
    } ITCallMediaEventVtbl;

    interface ITCallMediaEvent
    {
        CONST_VTBL struct ITCallMediaEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallMediaEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallMediaEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallMediaEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallMediaEvent_get_Call(This,ppCallInfo)	\
    (This)->lpVtbl -> get_Call(This,ppCallInfo)

#define ITCallMediaEvent_get_Event(This,pCallMediaEvent)	\
    (This)->lpVtbl -> get_Event(This,pCallMediaEvent)

#define ITCallMediaEvent_get_Error(This,phrError)	\
    (This)->lpVtbl -> get_Error(This,phrError)

#define ITCallMediaEvent_get_Terminal(This,ppTerminal)	\
    (This)->lpVtbl -> get_Terminal(This,ppTerminal)

#define ITCallMediaEvent_get_Stream(This,ppStream)	\
    (This)->lpVtbl -> get_Stream(This,ppStream)

#define ITCallMediaEvent_get_Cause(This,pCause)	\
    (This)->lpVtbl -> get_Cause(This,pCause)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallMediaEvent_get_Call_Proxy( 
    ITCallMediaEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);


void __RPC_STUB ITCallMediaEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallMediaEvent_get_Event_Proxy( 
    ITCallMediaEvent __RPC_FAR * This,
    /* [retval][out] */ CALL_MEDIA_EVENT __RPC_FAR *pCallMediaEvent);


void __RPC_STUB ITCallMediaEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallMediaEvent_get_Error_Proxy( 
    ITCallMediaEvent __RPC_FAR * This,
    /* [retval][out] */ HRESULT __RPC_FAR *phrError);


void __RPC_STUB ITCallMediaEvent_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallMediaEvent_get_Terminal_Proxy( 
    ITCallMediaEvent __RPC_FAR * This,
    /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);


void __RPC_STUB ITCallMediaEvent_get_Terminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallMediaEvent_get_Stream_Proxy( 
    ITCallMediaEvent __RPC_FAR * This,
    /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB ITCallMediaEvent_get_Stream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallMediaEvent_get_Cause_Proxy( 
    ITCallMediaEvent __RPC_FAR * This,
    /* [retval][out] */ CALL_MEDIA_EVENT_CAUSE __RPC_FAR *pCause);


void __RPC_STUB ITCallMediaEvent_get_Cause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallMediaEvent_INTERFACE_DEFINED__ */


#ifndef __ITDigitDetectionEvent_INTERFACE_DEFINED__
#define __ITDigitDetectionEvent_INTERFACE_DEFINED__

/* interface ITDigitDetectionEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDigitDetectionEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80D3BFAC-57D9-11d2-A04A-00C04FB6809F")
    ITDigitDetectionEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Digit( 
            /* [retval][out] */ unsigned char __RPC_FAR *pucDigit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DigitMode( 
            /* [retval][out] */ TAPI_DIGITMODE __RPC_FAR *pDigitMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TickCount( 
            /* [retval][out] */ long __RPC_FAR *plTickCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDigitDetectionEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITDigitDetectionEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITDigitDetectionEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Digit )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [retval][out] */ unsigned char __RPC_FAR *pucDigit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DigitMode )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [retval][out] */ TAPI_DIGITMODE __RPC_FAR *pDigitMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TickCount )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTickCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallbackInstance )( 
            ITDigitDetectionEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance);
        
        END_INTERFACE
    } ITDigitDetectionEventVtbl;

    interface ITDigitDetectionEvent
    {
        CONST_VTBL struct ITDigitDetectionEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDigitDetectionEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDigitDetectionEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDigitDetectionEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDigitDetectionEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDigitDetectionEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDigitDetectionEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDigitDetectionEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDigitDetectionEvent_get_Call(This,ppCallInfo)	\
    (This)->lpVtbl -> get_Call(This,ppCallInfo)

#define ITDigitDetectionEvent_get_Digit(This,pucDigit)	\
    (This)->lpVtbl -> get_Digit(This,pucDigit)

#define ITDigitDetectionEvent_get_DigitMode(This,pDigitMode)	\
    (This)->lpVtbl -> get_DigitMode(This,pDigitMode)

#define ITDigitDetectionEvent_get_TickCount(This,plTickCount)	\
    (This)->lpVtbl -> get_TickCount(This,plTickCount)

#define ITDigitDetectionEvent_get_CallbackInstance(This,plCallbackInstance)	\
    (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitDetectionEvent_get_Call_Proxy( 
    ITDigitDetectionEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);


void __RPC_STUB ITDigitDetectionEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitDetectionEvent_get_Digit_Proxy( 
    ITDigitDetectionEvent __RPC_FAR * This,
    /* [retval][out] */ unsigned char __RPC_FAR *pucDigit);


void __RPC_STUB ITDigitDetectionEvent_get_Digit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitDetectionEvent_get_DigitMode_Proxy( 
    ITDigitDetectionEvent __RPC_FAR * This,
    /* [retval][out] */ TAPI_DIGITMODE __RPC_FAR *pDigitMode);


void __RPC_STUB ITDigitDetectionEvent_get_DigitMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitDetectionEvent_get_TickCount_Proxy( 
    ITDigitDetectionEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTickCount);


void __RPC_STUB ITDigitDetectionEvent_get_TickCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitDetectionEvent_get_CallbackInstance_Proxy( 
    ITDigitDetectionEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallbackInstance);


void __RPC_STUB ITDigitDetectionEvent_get_CallbackInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDigitDetectionEvent_INTERFACE_DEFINED__ */


#ifndef __ITDigitGenerationEvent_INTERFACE_DEFINED__
#define __ITDigitGenerationEvent_INTERFACE_DEFINED__

/* interface ITDigitGenerationEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDigitGenerationEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80D3BFAD-57D9-11d2-A04A-00C04FB6809F")
    ITDigitGenerationEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GenerationTermination( 
            /* [retval][out] */ long __RPC_FAR *plGenerationTermination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TickCount( 
            /* [retval][out] */ long __RPC_FAR *plTickCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDigitGenerationEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITDigitGenerationEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITDigitGenerationEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GenerationTermination )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plGenerationTermination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TickCount )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTickCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallbackInstance )( 
            ITDigitGenerationEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance);
        
        END_INTERFACE
    } ITDigitGenerationEventVtbl;

    interface ITDigitGenerationEvent
    {
        CONST_VTBL struct ITDigitGenerationEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDigitGenerationEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDigitGenerationEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDigitGenerationEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDigitGenerationEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDigitGenerationEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDigitGenerationEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDigitGenerationEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDigitGenerationEvent_get_Call(This,ppCallInfo)	\
    (This)->lpVtbl -> get_Call(This,ppCallInfo)

#define ITDigitGenerationEvent_get_GenerationTermination(This,plGenerationTermination)	\
    (This)->lpVtbl -> get_GenerationTermination(This,plGenerationTermination)

#define ITDigitGenerationEvent_get_TickCount(This,plTickCount)	\
    (This)->lpVtbl -> get_TickCount(This,plTickCount)

#define ITDigitGenerationEvent_get_CallbackInstance(This,plCallbackInstance)	\
    (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitGenerationEvent_get_Call_Proxy( 
    ITDigitGenerationEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);


void __RPC_STUB ITDigitGenerationEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitGenerationEvent_get_GenerationTermination_Proxy( 
    ITDigitGenerationEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plGenerationTermination);


void __RPC_STUB ITDigitGenerationEvent_get_GenerationTermination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitGenerationEvent_get_TickCount_Proxy( 
    ITDigitGenerationEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTickCount);


void __RPC_STUB ITDigitGenerationEvent_get_TickCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITDigitGenerationEvent_get_CallbackInstance_Proxy( 
    ITDigitGenerationEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallbackInstance);


void __RPC_STUB ITDigitGenerationEvent_get_CallbackInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDigitGenerationEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPIObjectEvent_INTERFACE_DEFINED__
#define __ITTAPIObjectEvent_INTERFACE_DEFINED__

/* interface ITTAPIObjectEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPIObjectEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4854D48-937A-11d1-BB58-00C04FB6809F")
    ITTAPIObjectEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TAPIObject( 
            /* [retval][out] */ ITTAPI __RPC_FAR *__RPC_FAR *ppTAPIObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ TAPIOBJECT_EVENT __RPC_FAR *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIObjectEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTAPIObjectEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTAPIObjectEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TAPIObject )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [retval][out] */ ITTAPI __RPC_FAR *__RPC_FAR *ppTAPIObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [retval][out] */ TAPIOBJECT_EVENT __RPC_FAR *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallbackInstance )( 
            ITTAPIObjectEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance);
        
        END_INTERFACE
    } ITTAPIObjectEventVtbl;

    interface ITTAPIObjectEvent
    {
        CONST_VTBL struct ITTAPIObjectEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPIObjectEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTAPIObjectEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTAPIObjectEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTAPIObjectEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITTAPIObjectEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITTAPIObjectEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITTAPIObjectEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITTAPIObjectEvent_get_TAPIObject(This,ppTAPIObject)	\
    (This)->lpVtbl -> get_TAPIObject(This,ppTAPIObject)

#define ITTAPIObjectEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#define ITTAPIObjectEvent_get_Address(This,ppAddress)	\
    (This)->lpVtbl -> get_Address(This,ppAddress)

#define ITTAPIObjectEvent_get_CallbackInstance(This,plCallbackInstance)	\
    (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPIObjectEvent_get_TAPIObject_Proxy( 
    ITTAPIObjectEvent __RPC_FAR * This,
    /* [retval][out] */ ITTAPI __RPC_FAR *__RPC_FAR *ppTAPIObject);


void __RPC_STUB ITTAPIObjectEvent_get_TAPIObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPIObjectEvent_get_Event_Proxy( 
    ITTAPIObjectEvent __RPC_FAR * This,
    /* [retval][out] */ TAPIOBJECT_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITTAPIObjectEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPIObjectEvent_get_Address_Proxy( 
    ITTAPIObjectEvent __RPC_FAR * This,
    /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB ITTAPIObjectEvent_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITTAPIObjectEvent_get_CallbackInstance_Proxy( 
    ITTAPIObjectEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallbackInstance);


void __RPC_STUB ITTAPIObjectEvent_get_CallbackInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTAPIObjectEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPIEventNotification_INTERFACE_DEFINED__
#define __ITTAPIEventNotification_INTERFACE_DEFINED__

/* interface ITTAPIEventNotification */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPIEventNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDDB9426-3B91-11d1-8F30-00C04FB6809F")
    ITTAPIEventNotification : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Event( 
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ IDispatch __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIEventNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITTAPIEventNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITTAPIEventNotification __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITTAPIEventNotification __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Event )( 
            ITTAPIEventNotification __RPC_FAR * This,
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ IDispatch __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITTAPIEventNotificationVtbl;

    interface ITTAPIEventNotification
    {
        CONST_VTBL struct ITTAPIEventNotificationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPIEventNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITTAPIEventNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITTAPIEventNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITTAPIEventNotification_Event(This,TapiEvent,pEvent)	\
    (This)->lpVtbl -> Event(This,TapiEvent,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITTAPIEventNotification_Event_Proxy( 
    ITTAPIEventNotification __RPC_FAR * This,
    /* [in] */ TAPI_EVENT TapiEvent,
    /* [in] */ IDispatch __RPC_FAR *pEvent);


void __RPC_STUB ITTAPIEventNotification_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITTAPIEventNotification_INTERFACE_DEFINED__ */


#ifndef __ITCallHubEvent_INTERFACE_DEFINED__
#define __ITCallHubEvent_INTERFACE_DEFINED__

/* interface ITCallHubEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallHubEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C15451-5B92-11d1-8F4E-00C04FB6809F")
    ITCallHubEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ CALLHUB_EVENT __RPC_FAR *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHub( 
            /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallHubEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallHubEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallHubEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [retval][out] */ CALLHUB_EVENT __RPC_FAR *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallHub )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITCallHubEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);
        
        END_INTERFACE
    } ITCallHubEventVtbl;

    interface ITCallHubEvent
    {
        CONST_VTBL struct ITCallHubEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallHubEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallHubEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallHubEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallHubEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallHubEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallHubEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallHubEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallHubEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#define ITCallHubEvent_get_CallHub(This,ppCallHub)	\
    (This)->lpVtbl -> get_CallHub(This,ppCallHub)

#define ITCallHubEvent_get_Call(This,ppCall)	\
    (This)->lpVtbl -> get_Call(This,ppCall)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallHubEvent_get_Event_Proxy( 
    ITCallHubEvent __RPC_FAR * This,
    /* [retval][out] */ CALLHUB_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITCallHubEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallHubEvent_get_CallHub_Proxy( 
    ITCallHubEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub);


void __RPC_STUB ITCallHubEvent_get_CallHub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallHubEvent_get_Call_Proxy( 
    ITCallHubEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);


void __RPC_STUB ITCallHubEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallHubEvent_INTERFACE_DEFINED__ */


#ifndef __ITAddressEvent_INTERFACE_DEFINED__
#define __ITAddressEvent_INTERFACE_DEFINED__

/* interface ITAddressEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("831CE2D1-83B5-11d1-BB5C-00C04FB6809F")
    ITAddressEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ ADDRESS_EVENT __RPC_FAR *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAddressEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAddressEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAddressEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAddressEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAddressEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAddressEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAddressEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            ITAddressEvent __RPC_FAR * This,
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITAddressEvent __RPC_FAR * This,
            /* [retval][out] */ ADDRESS_EVENT __RPC_FAR *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Terminal )( 
            ITAddressEvent __RPC_FAR * This,
            /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);
        
        END_INTERFACE
    } ITAddressEventVtbl;

    interface ITAddressEvent
    {
        CONST_VTBL struct ITAddressEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAddressEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAddressEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAddressEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAddressEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAddressEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAddressEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAddressEvent_get_Address(This,ppAddress)	\
    (This)->lpVtbl -> get_Address(This,ppAddress)

#define ITAddressEvent_get_Event(This,pEvent)	\
    (This)->lpVtbl -> get_Event(This,pEvent)

#define ITAddressEvent_get_Terminal(This,ppTerminal)	\
    (This)->lpVtbl -> get_Terminal(This,ppTerminal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressEvent_get_Address_Proxy( 
    ITAddressEvent __RPC_FAR * This,
    /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB ITAddressEvent_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressEvent_get_Event_Proxy( 
    ITAddressEvent __RPC_FAR * This,
    /* [retval][out] */ ADDRESS_EVENT __RPC_FAR *pEvent);


void __RPC_STUB ITAddressEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressEvent_get_Terminal_Proxy( 
    ITAddressEvent __RPC_FAR * This,
    /* [retval][out] */ ITTerminal __RPC_FAR *__RPC_FAR *ppTerminal);


void __RPC_STUB ITAddressEvent_get_Terminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAddressEvent_INTERFACE_DEFINED__ */


#ifndef __ITQOSEvent_INTERFACE_DEFINED__
#define __ITQOSEvent_INTERFACE_DEFINED__

/* interface ITQOSEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQOSEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CFA3357C-AD77-11d1-BB68-00C04FB6809F")
    ITQOSEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ QOS_EVENT __RPC_FAR *pQosEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ long __RPC_FAR *plMediaType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQOSEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITQOSEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITQOSEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITQOSEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITQOSEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITQOSEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITQOSEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITQOSEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITQOSEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITQOSEvent __RPC_FAR * This,
            /* [retval][out] */ QOS_EVENT __RPC_FAR *pQosEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MediaType )( 
            ITQOSEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMediaType);
        
        END_INTERFACE
    } ITQOSEventVtbl;

    interface ITQOSEvent
    {
        CONST_VTBL struct ITQOSEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQOSEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITQOSEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITQOSEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITQOSEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITQOSEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITQOSEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITQOSEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITQOSEvent_get_Call(This,ppCall)	\
    (This)->lpVtbl -> get_Call(This,ppCall)

#define ITQOSEvent_get_Event(This,pQosEvent)	\
    (This)->lpVtbl -> get_Event(This,pQosEvent)

#define ITQOSEvent_get_MediaType(This,plMediaType)	\
    (This)->lpVtbl -> get_MediaType(This,plMediaType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQOSEvent_get_Call_Proxy( 
    ITQOSEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);


void __RPC_STUB ITQOSEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQOSEvent_get_Event_Proxy( 
    ITQOSEvent __RPC_FAR * This,
    /* [retval][out] */ QOS_EVENT __RPC_FAR *pQosEvent);


void __RPC_STUB ITQOSEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITQOSEvent_get_MediaType_Proxy( 
    ITQOSEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMediaType);


void __RPC_STUB ITQOSEvent_get_MediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITQOSEvent_INTERFACE_DEFINED__ */


#ifndef __ITCallInfoChangeEvent_INTERFACE_DEFINED__
#define __ITCallInfoChangeEvent_INTERFACE_DEFINED__

/* interface ITCallInfoChangeEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallInfoChangeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D4B65F9-E51C-11d1-A02F-00C04FB6809F")
    ITCallInfoChangeEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ CALLINFOCHANGE_CAUSE __RPC_FAR *pCIC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallInfoChangeEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallInfoChangeEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallInfoChangeEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cause )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [retval][out] */ CALLINFOCHANGE_CAUSE __RPC_FAR *pCIC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallbackInstance )( 
            ITCallInfoChangeEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance);
        
        END_INTERFACE
    } ITCallInfoChangeEventVtbl;

    interface ITCallInfoChangeEvent
    {
        CONST_VTBL struct ITCallInfoChangeEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallInfoChangeEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallInfoChangeEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallInfoChangeEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallInfoChangeEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallInfoChangeEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallInfoChangeEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallInfoChangeEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallInfoChangeEvent_get_Call(This,ppCall)	\
    (This)->lpVtbl -> get_Call(This,ppCall)

#define ITCallInfoChangeEvent_get_Cause(This,pCIC)	\
    (This)->lpVtbl -> get_Cause(This,pCIC)

#define ITCallInfoChangeEvent_get_CallbackInstance(This,plCallbackInstance)	\
    (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfoChangeEvent_get_Call_Proxy( 
    ITCallInfoChangeEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);


void __RPC_STUB ITCallInfoChangeEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfoChangeEvent_get_Cause_Proxy( 
    ITCallInfoChangeEvent __RPC_FAR * This,
    /* [retval][out] */ CALLINFOCHANGE_CAUSE __RPC_FAR *pCIC);


void __RPC_STUB ITCallInfoChangeEvent_get_Cause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallInfoChangeEvent_get_CallbackInstance_Proxy( 
    ITCallInfoChangeEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallbackInstance);


void __RPC_STUB ITCallInfoChangeEvent_get_CallbackInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallInfoChangeEvent_INTERFACE_DEFINED__ */


#ifndef __ITRequest_INTERFACE_DEFINED__
#define __ITRequest_INTERFACE_DEFINED__

/* interface ITRequest */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC48FFDF-F8C4-11d1-A030-00C04FB6809F")
    ITRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MakeCall( 
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pAppName,
            /* [in] */ BSTR pCalledParty,
            /* [in] */ BSTR pComment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeCall )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pAppName,
            /* [in] */ BSTR pCalledParty,
            /* [in] */ BSTR pComment);
        
        END_INTERFACE
    } ITRequestVtbl;

    interface ITRequest
    {
        CONST_VTBL struct ITRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITRequest_MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)	\
    (This)->lpVtbl -> MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRequest_MakeCall_Proxy( 
    ITRequest __RPC_FAR * This,
    /* [in] */ BSTR pDestAddress,
    /* [in] */ BSTR pAppName,
    /* [in] */ BSTR pCalledParty,
    /* [in] */ BSTR pComment);


void __RPC_STUB ITRequest_MakeCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITRequest_INTERFACE_DEFINED__ */


#ifndef __ITRequestEvent_INTERFACE_DEFINED__
#define __ITRequestEvent_INTERFACE_DEFINED__

/* interface ITRequestEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITRequestEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC48FFDE-F8C4-11d1-A030-00C04FB6809F")
    ITRequestEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RegistrationInstance( 
            /* [retval][out] */ long __RPC_FAR *plRegistrationInstance) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestMode( 
            /* [retval][out] */ long __RPC_FAR *plRequestMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *ppDestAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AppName( 
            /* [retval][out] */ BSTR __RPC_FAR *ppAppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CalledParty( 
            /* [retval][out] */ BSTR __RPC_FAR *ppCalledParty) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Comment( 
            /* [retval][out] */ BSTR __RPC_FAR *ppComment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRequestEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITRequestEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITRequestEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITRequestEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITRequestEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITRequestEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITRequestEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITRequestEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RegistrationInstance )( 
            ITRequestEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plRegistrationInstance);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RequestMode )( 
            ITRequestEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plRequestMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DestAddress )( 
            ITRequestEvent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppDestAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AppName )( 
            ITRequestEvent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppAppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CalledParty )( 
            ITRequestEvent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppCalledParty);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Comment )( 
            ITRequestEvent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppComment);
        
        END_INTERFACE
    } ITRequestEventVtbl;

    interface ITRequestEvent
    {
        CONST_VTBL struct ITRequestEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRequestEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITRequestEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITRequestEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITRequestEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITRequestEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITRequestEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITRequestEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITRequestEvent_get_RegistrationInstance(This,plRegistrationInstance)	\
    (This)->lpVtbl -> get_RegistrationInstance(This,plRegistrationInstance)

#define ITRequestEvent_get_RequestMode(This,plRequestMode)	\
    (This)->lpVtbl -> get_RequestMode(This,plRequestMode)

#define ITRequestEvent_get_DestAddress(This,ppDestAddress)	\
    (This)->lpVtbl -> get_DestAddress(This,ppDestAddress)

#define ITRequestEvent_get_AppName(This,ppAppName)	\
    (This)->lpVtbl -> get_AppName(This,ppAppName)

#define ITRequestEvent_get_CalledParty(This,ppCalledParty)	\
    (This)->lpVtbl -> get_CalledParty(This,ppCalledParty)

#define ITRequestEvent_get_Comment(This,ppComment)	\
    (This)->lpVtbl -> get_Comment(This,ppComment)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRequestEvent_get_RegistrationInstance_Proxy( 
    ITRequestEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plRegistrationInstance);


void __RPC_STUB ITRequestEvent_get_RegistrationInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRequestEvent_get_RequestMode_Proxy( 
    ITRequestEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plRequestMode);


void __RPC_STUB ITRequestEvent_get_RequestMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRequestEvent_get_DestAddress_Proxy( 
    ITRequestEvent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppDestAddress);


void __RPC_STUB ITRequestEvent_get_DestAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRequestEvent_get_AppName_Proxy( 
    ITRequestEvent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppAppName);


void __RPC_STUB ITRequestEvent_get_AppName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRequestEvent_get_CalledParty_Proxy( 
    ITRequestEvent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppCalledParty);


void __RPC_STUB ITRequestEvent_get_CalledParty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITRequestEvent_get_Comment_Proxy( 
    ITRequestEvent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppComment);


void __RPC_STUB ITRequestEvent_get_Comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITRequestEvent_INTERFACE_DEFINED__ */


#ifndef __ITCollection_INTERFACE_DEFINED__
#define __ITCollection_INTERFACE_DEFINED__

/* interface ITCollection */
/* [dual][helpstring][uuid][public][object] */ 


EXTERN_C const IID IID_ITCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5EC5ACF2-9C02-11d0-8362-00AA003CCABD")
    ITCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *lCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ITCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *lCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ITCollection __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ITCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppNewEnum);
        
        END_INTERFACE
    } ITCollectionVtbl;

    interface ITCollection
    {
        CONST_VTBL struct ITCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCollection_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define ITCollection_get_Item(This,Index,pVariant)	\
    (This)->lpVtbl -> get_Item(This,Index,pVariant)

#define ITCollection_get__NewEnum(This,ppNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppNewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ITCollection_get_Count_Proxy( 
    ITCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *lCount);


void __RPC_STUB ITCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCollection_get_Item_Proxy( 
    ITCollection __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ITCollection_get__NewEnum_Proxy( 
    ITCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppNewEnum);


void __RPC_STUB ITCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCollection_INTERFACE_DEFINED__ */


#ifndef __ITForwardInformation_INTERFACE_DEFINED__
#define __ITForwardInformation_INTERFACE_DEFINED__

/* interface ITForwardInformation */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITForwardInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("449F659E-88A3-11d1-BB5D-00C04FB6809F")
    ITForwardInformation : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NumRingsNoAnswer( 
            /* [in] */ long lNumRings) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumRingsNoAnswer( 
            /* [retval][out] */ long __RPC_FAR *plNumRings) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetForwardType( 
            /* [in] */ long ForwardType,
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pCallerAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForwardTypeDestination( 
            /* [in] */ long ForwardType,
            /* [retval][out] */ BSTR __RPC_FAR *ppDestAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForwardTypeCaller( 
            /* [in] */ long Forwardtype,
            /* [retval][out] */ BSTR __RPC_FAR *ppCallerAddress) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetForwardType( 
            /* [in] */ long ForwardType,
            /* [out] */ BSTR __RPC_FAR *ppDestinationAddress,
            /* [out] */ BSTR __RPC_FAR *ppCallerAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITForwardInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITForwardInformation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITForwardInformation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITForwardInformation __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumRingsNoAnswer )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ long lNumRings);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumRingsNoAnswer )( 
            ITForwardInformation __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plNumRings);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForwardType )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ long ForwardType,
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pCallerAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ForwardTypeDestination )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ long ForwardType,
            /* [retval][out] */ BSTR __RPC_FAR *ppDestAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ForwardTypeCaller )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ long Forwardtype,
            /* [retval][out] */ BSTR __RPC_FAR *ppCallerAddress);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForwardType )( 
            ITForwardInformation __RPC_FAR * This,
            /* [in] */ long ForwardType,
            /* [out] */ BSTR __RPC_FAR *ppDestinationAddress,
            /* [out] */ BSTR __RPC_FAR *ppCallerAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ITForwardInformation __RPC_FAR * This);
        
        END_INTERFACE
    } ITForwardInformationVtbl;

    interface ITForwardInformation
    {
        CONST_VTBL struct ITForwardInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITForwardInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITForwardInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITForwardInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITForwardInformation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITForwardInformation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITForwardInformation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITForwardInformation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITForwardInformation_put_NumRingsNoAnswer(This,lNumRings)	\
    (This)->lpVtbl -> put_NumRingsNoAnswer(This,lNumRings)

#define ITForwardInformation_get_NumRingsNoAnswer(This,plNumRings)	\
    (This)->lpVtbl -> get_NumRingsNoAnswer(This,plNumRings)

#define ITForwardInformation_SetForwardType(This,ForwardType,pDestAddress,pCallerAddress)	\
    (This)->lpVtbl -> SetForwardType(This,ForwardType,pDestAddress,pCallerAddress)

#define ITForwardInformation_get_ForwardTypeDestination(This,ForwardType,ppDestAddress)	\
    (This)->lpVtbl -> get_ForwardTypeDestination(This,ForwardType,ppDestAddress)

#define ITForwardInformation_get_ForwardTypeCaller(This,Forwardtype,ppCallerAddress)	\
    (This)->lpVtbl -> get_ForwardTypeCaller(This,Forwardtype,ppCallerAddress)

#define ITForwardInformation_GetForwardType(This,ForwardType,ppDestinationAddress,ppCallerAddress)	\
    (This)->lpVtbl -> GetForwardType(This,ForwardType,ppDestinationAddress,ppCallerAddress)

#define ITForwardInformation_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_put_NumRingsNoAnswer_Proxy( 
    ITForwardInformation __RPC_FAR * This,
    /* [in] */ long lNumRings);


void __RPC_STUB ITForwardInformation_put_NumRingsNoAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_get_NumRingsNoAnswer_Proxy( 
    ITForwardInformation __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plNumRings);


void __RPC_STUB ITForwardInformation_get_NumRingsNoAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_SetForwardType_Proxy( 
    ITForwardInformation __RPC_FAR * This,
    /* [in] */ long ForwardType,
    /* [in] */ BSTR pDestAddress,
    /* [in] */ BSTR pCallerAddress);


void __RPC_STUB ITForwardInformation_SetForwardType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_get_ForwardTypeDestination_Proxy( 
    ITForwardInformation __RPC_FAR * This,
    /* [in] */ long ForwardType,
    /* [retval][out] */ BSTR __RPC_FAR *ppDestAddress);


void __RPC_STUB ITForwardInformation_get_ForwardTypeDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_get_ForwardTypeCaller_Proxy( 
    ITForwardInformation __RPC_FAR * This,
    /* [in] */ long Forwardtype,
    /* [retval][out] */ BSTR __RPC_FAR *ppCallerAddress);


void __RPC_STUB ITForwardInformation_get_ForwardTypeCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_GetForwardType_Proxy( 
    ITForwardInformation __RPC_FAR * This,
    /* [in] */ long ForwardType,
    /* [out] */ BSTR __RPC_FAR *ppDestinationAddress,
    /* [out] */ BSTR __RPC_FAR *ppCallerAddress);


void __RPC_STUB ITForwardInformation_GetForwardType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITForwardInformation_Clear_Proxy( 
    ITForwardInformation __RPC_FAR * This);


void __RPC_STUB ITForwardInformation_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITForwardInformation_INTERFACE_DEFINED__ */


#ifndef __ITAddressTranslation_INTERFACE_DEFINED__
#define __ITAddressTranslation_INTERFACE_DEFINED__

/* interface ITAddressTranslation */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressTranslation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F03-8DDB-11d1-A09E-00805FC147D3")
    ITAddressTranslation : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TranslateAddress( 
            /* [in] */ BSTR pAddressToTranslate,
            /* [in] */ long lCard,
            /* [in] */ long lTranslateOptions,
            /* [retval][out] */ ITAddressTranslationInfo __RPC_FAR *__RPC_FAR *ppTranslated) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TranslateDialog( 
            /* [in] */ long hwndOwner,
            /* [in] */ BSTR pAddressIn) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateLocations( 
            /* [retval][out] */ IEnumLocation __RPC_FAR *__RPC_FAR *ppEnumLocation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Locations( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCallingCards( 
            /* [retval][out] */ IEnumCallingCard __RPC_FAR *__RPC_FAR *ppEnumCallingCard) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallingCards( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressTranslationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAddressTranslation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAddressTranslation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateAddress )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [in] */ BSTR pAddressToTranslate,
            /* [in] */ long lCard,
            /* [in] */ long lTranslateOptions,
            /* [retval][out] */ ITAddressTranslationInfo __RPC_FAR *__RPC_FAR *ppTranslated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateDialog )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [in] */ long hwndOwner,
            /* [in] */ BSTR pAddressIn);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateLocations )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [retval][out] */ IEnumLocation __RPC_FAR *__RPC_FAR *ppEnumLocation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Locations )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateCallingCards )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [retval][out] */ IEnumCallingCard __RPC_FAR *__RPC_FAR *ppEnumCallingCard);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallingCards )( 
            ITAddressTranslation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITAddressTranslationVtbl;

    interface ITAddressTranslation
    {
        CONST_VTBL struct ITAddressTranslationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressTranslation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAddressTranslation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAddressTranslation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAddressTranslation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAddressTranslation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAddressTranslation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAddressTranslation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAddressTranslation_TranslateAddress(This,pAddressToTranslate,lCard,lTranslateOptions,ppTranslated)	\
    (This)->lpVtbl -> TranslateAddress(This,pAddressToTranslate,lCard,lTranslateOptions,ppTranslated)

#define ITAddressTranslation_TranslateDialog(This,hwndOwner,pAddressIn)	\
    (This)->lpVtbl -> TranslateDialog(This,hwndOwner,pAddressIn)

#define ITAddressTranslation_EnumerateLocations(This,ppEnumLocation)	\
    (This)->lpVtbl -> EnumerateLocations(This,ppEnumLocation)

#define ITAddressTranslation_get_Locations(This,pVariant)	\
    (This)->lpVtbl -> get_Locations(This,pVariant)

#define ITAddressTranslation_EnumerateCallingCards(This,ppEnumCallingCard)	\
    (This)->lpVtbl -> EnumerateCallingCards(This,ppEnumCallingCard)

#define ITAddressTranslation_get_CallingCards(This,pVariant)	\
    (This)->lpVtbl -> get_CallingCards(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAddressTranslation_TranslateAddress_Proxy( 
    ITAddressTranslation __RPC_FAR * This,
    /* [in] */ BSTR pAddressToTranslate,
    /* [in] */ long lCard,
    /* [in] */ long lTranslateOptions,
    /* [retval][out] */ ITAddressTranslationInfo __RPC_FAR *__RPC_FAR *ppTranslated);


void __RPC_STUB ITAddressTranslation_TranslateAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITAddressTranslation_TranslateDialog_Proxy( 
    ITAddressTranslation __RPC_FAR * This,
    /* [in] */ long hwndOwner,
    /* [in] */ BSTR pAddressIn);


void __RPC_STUB ITAddressTranslation_TranslateDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITAddressTranslation_EnumerateLocations_Proxy( 
    ITAddressTranslation __RPC_FAR * This,
    /* [retval][out] */ IEnumLocation __RPC_FAR *__RPC_FAR *ppEnumLocation);


void __RPC_STUB ITAddressTranslation_EnumerateLocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslation_get_Locations_Proxy( 
    ITAddressTranslation __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAddressTranslation_get_Locations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE ITAddressTranslation_EnumerateCallingCards_Proxy( 
    ITAddressTranslation __RPC_FAR * This,
    /* [retval][out] */ IEnumCallingCard __RPC_FAR *__RPC_FAR *ppEnumCallingCard);


void __RPC_STUB ITAddressTranslation_EnumerateCallingCards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslation_get_CallingCards_Proxy( 
    ITAddressTranslation __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITAddressTranslation_get_CallingCards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAddressTranslation_INTERFACE_DEFINED__ */


#ifndef __ITAddressTranslationInfo_INTERFACE_DEFINED__
#define __ITAddressTranslationInfo_INTERFACE_DEFINED__

/* interface ITAddressTranslationInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressTranslationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AFC15945-8D40-11d1-A09E-00805FC147D3")
    ITAddressTranslationInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableString( 
            /* [retval][out] */ BSTR __RPC_FAR *ppDialableString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayableString( 
            /* [retval][out] */ BSTR __RPC_FAR *ppDisplayableString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCountryCode( 
            /* [retval][out] */ long __RPC_FAR *CountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationCountryCode( 
            /* [retval][out] */ long __RPC_FAR *CountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TranslationResults( 
            /* [retval][out] */ long __RPC_FAR *plResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressTranslationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITAddressTranslationInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITAddressTranslationInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialableString )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppDialableString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayableString )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppDisplayableString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentCountryCode )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *CountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DestinationCountryCode )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *CountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TranslationResults )( 
            ITAddressTranslationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plResults);
        
        END_INTERFACE
    } ITAddressTranslationInfoVtbl;

    interface ITAddressTranslationInfo
    {
        CONST_VTBL struct ITAddressTranslationInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressTranslationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITAddressTranslationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITAddressTranslationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITAddressTranslationInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITAddressTranslationInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITAddressTranslationInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITAddressTranslationInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITAddressTranslationInfo_get_DialableString(This,ppDialableString)	\
    (This)->lpVtbl -> get_DialableString(This,ppDialableString)

#define ITAddressTranslationInfo_get_DisplayableString(This,ppDisplayableString)	\
    (This)->lpVtbl -> get_DisplayableString(This,ppDisplayableString)

#define ITAddressTranslationInfo_get_CurrentCountryCode(This,CountryCode)	\
    (This)->lpVtbl -> get_CurrentCountryCode(This,CountryCode)

#define ITAddressTranslationInfo_get_DestinationCountryCode(This,CountryCode)	\
    (This)->lpVtbl -> get_DestinationCountryCode(This,CountryCode)

#define ITAddressTranslationInfo_get_TranslationResults(This,plResults)	\
    (This)->lpVtbl -> get_TranslationResults(This,plResults)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslationInfo_get_DialableString_Proxy( 
    ITAddressTranslationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppDialableString);


void __RPC_STUB ITAddressTranslationInfo_get_DialableString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslationInfo_get_DisplayableString_Proxy( 
    ITAddressTranslationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppDisplayableString);


void __RPC_STUB ITAddressTranslationInfo_get_DisplayableString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslationInfo_get_CurrentCountryCode_Proxy( 
    ITAddressTranslationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *CountryCode);


void __RPC_STUB ITAddressTranslationInfo_get_CurrentCountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslationInfo_get_DestinationCountryCode_Proxy( 
    ITAddressTranslationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *CountryCode);


void __RPC_STUB ITAddressTranslationInfo_get_DestinationCountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITAddressTranslationInfo_get_TranslationResults_Proxy( 
    ITAddressTranslationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plResults);


void __RPC_STUB ITAddressTranslationInfo_get_TranslationResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITAddressTranslationInfo_INTERFACE_DEFINED__ */


#ifndef __ITLocationInfo_INTERFACE_DEFINED__
#define __ITLocationInfo_INTERFACE_DEFINED__

/* interface ITLocationInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLocationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8EFF-8DDB-11d1-A09E-00805FC147D3")
    ITLocationInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermanentLocationID( 
            /* [retval][out] */ long __RPC_FAR *plLocationID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [retval][out] */ long __RPC_FAR *plCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryID( 
            /* [retval][out] */ long __RPC_FAR *plCountryID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options( 
            /* [retval][out] */ long __RPC_FAR *plOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredCardID( 
            /* [retval][out] */ long __RPC_FAR *plCardID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocationName( 
            /* [retval][out] */ BSTR __RPC_FAR *ppLocationName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CityCode( 
            /* [retval][out] */ BSTR __RPC_FAR *ppCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalAccessCode( 
            /* [retval][out] */ BSTR __RPC_FAR *ppCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongDistanceAccessCode( 
            /* [retval][out] */ BSTR __RPC_FAR *ppCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TollPrefixList( 
            /* [retval][out] */ BSTR __RPC_FAR *ppTollList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CancelCallWaitingCode( 
            /* [retval][out] */ BSTR __RPC_FAR *ppCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLocationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITLocationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITLocationInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITLocationInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITLocationInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITLocationInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITLocationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITLocationInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PermanentLocationID )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLocationID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountryCode )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountryID )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCountryID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Options )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreferredCardID )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCardID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppLocationName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CityCode )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocalAccessCode )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LongDistanceAccessCode )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TollPrefixList )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppTollList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CancelCallWaitingCode )( 
            ITLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppCode);
        
        END_INTERFACE
    } ITLocationInfoVtbl;

    interface ITLocationInfo
    {
        CONST_VTBL struct ITLocationInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLocationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITLocationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITLocationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITLocationInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITLocationInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITLocationInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITLocationInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITLocationInfo_get_PermanentLocationID(This,plLocationID)	\
    (This)->lpVtbl -> get_PermanentLocationID(This,plLocationID)

#define ITLocationInfo_get_CountryCode(This,plCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,plCountryCode)

#define ITLocationInfo_get_CountryID(This,plCountryID)	\
    (This)->lpVtbl -> get_CountryID(This,plCountryID)

#define ITLocationInfo_get_Options(This,plOptions)	\
    (This)->lpVtbl -> get_Options(This,plOptions)

#define ITLocationInfo_get_PreferredCardID(This,plCardID)	\
    (This)->lpVtbl -> get_PreferredCardID(This,plCardID)

#define ITLocationInfo_get_LocationName(This,ppLocationName)	\
    (This)->lpVtbl -> get_LocationName(This,ppLocationName)

#define ITLocationInfo_get_CityCode(This,ppCode)	\
    (This)->lpVtbl -> get_CityCode(This,ppCode)

#define ITLocationInfo_get_LocalAccessCode(This,ppCode)	\
    (This)->lpVtbl -> get_LocalAccessCode(This,ppCode)

#define ITLocationInfo_get_LongDistanceAccessCode(This,ppCode)	\
    (This)->lpVtbl -> get_LongDistanceAccessCode(This,ppCode)

#define ITLocationInfo_get_TollPrefixList(This,ppTollList)	\
    (This)->lpVtbl -> get_TollPrefixList(This,ppTollList)

#define ITLocationInfo_get_CancelCallWaitingCode(This,ppCode)	\
    (This)->lpVtbl -> get_CancelCallWaitingCode(This,ppCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_PermanentLocationID_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plLocationID);


void __RPC_STUB ITLocationInfo_get_PermanentLocationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_CountryCode_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCountryCode);


void __RPC_STUB ITLocationInfo_get_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_CountryID_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCountryID);


void __RPC_STUB ITLocationInfo_get_CountryID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_Options_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plOptions);


void __RPC_STUB ITLocationInfo_get_Options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_PreferredCardID_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCardID);


void __RPC_STUB ITLocationInfo_get_PreferredCardID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_LocationName_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppLocationName);


void __RPC_STUB ITLocationInfo_get_LocationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_CityCode_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppCode);


void __RPC_STUB ITLocationInfo_get_CityCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_LocalAccessCode_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppCode);


void __RPC_STUB ITLocationInfo_get_LocalAccessCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_LongDistanceAccessCode_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppCode);


void __RPC_STUB ITLocationInfo_get_LongDistanceAccessCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_TollPrefixList_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppTollList);


void __RPC_STUB ITLocationInfo_get_TollPrefixList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITLocationInfo_get_CancelCallWaitingCode_Proxy( 
    ITLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppCode);


void __RPC_STUB ITLocationInfo_get_CancelCallWaitingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITLocationInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumLocation_INTERFACE_DEFINED__
#define __IEnumLocation_INTERFACE_DEFINED__

/* interface IEnumLocation */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumLocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F01-8DDB-11d1-A09E-00805FC147D3")
    IEnumLocation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITLocationInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumLocation __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumLocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumLocation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumLocation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumLocation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumLocation __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITLocationInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumLocation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumLocation __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumLocation __RPC_FAR * This,
            /* [retval][out] */ IEnumLocation __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumLocationVtbl;

    interface IEnumLocation
    {
        CONST_VTBL struct IEnumLocationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumLocation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumLocation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumLocation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumLocation_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumLocation_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumLocation_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumLocation_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumLocation_Next_Proxy( 
    IEnumLocation __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITLocationInfo __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumLocation_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLocation_Reset_Proxy( 
    IEnumLocation __RPC_FAR * This);


void __RPC_STUB IEnumLocation_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLocation_Skip_Proxy( 
    IEnumLocation __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumLocation_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLocation_Clone_Proxy( 
    IEnumLocation __RPC_FAR * This,
    /* [retval][out] */ IEnumLocation __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumLocation_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumLocation_INTERFACE_DEFINED__ */


#ifndef __ITCallingCard_INTERFACE_DEFINED__
#define __ITCallingCard_INTERFACE_DEFINED__

/* interface ITCallingCard */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallingCard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F00-8DDB-11d1-A09E-00805FC147D3")
    ITCallingCard : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermanentCardID( 
            /* [retval][out] */ long __RPC_FAR *plCardID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfDigits( 
            /* [retval][out] */ long __RPC_FAR *plDigits) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options( 
            /* [retval][out] */ long __RPC_FAR *plOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CardName( 
            /* [retval][out] */ BSTR __RPC_FAR *ppCardName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SameAreaDialingRule( 
            /* [retval][out] */ BSTR __RPC_FAR *ppRule) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongDistanceDialingRule( 
            /* [retval][out] */ BSTR __RPC_FAR *ppRule) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternationalDialingRule( 
            /* [retval][out] */ BSTR __RPC_FAR *ppRule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallingCardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallingCard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallingCard __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallingCard __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallingCard __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallingCard __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallingCard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallingCard __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PermanentCardID )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCardID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfDigits )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plDigits);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Options )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CardName )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppCardName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SameAreaDialingRule )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppRule);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LongDistanceDialingRule )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppRule);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InternationalDialingRule )( 
            ITCallingCard __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppRule);
        
        END_INTERFACE
    } ITCallingCardVtbl;

    interface ITCallingCard
    {
        CONST_VTBL struct ITCallingCardVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallingCard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallingCard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallingCard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallingCard_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallingCard_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallingCard_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallingCard_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallingCard_get_PermanentCardID(This,plCardID)	\
    (This)->lpVtbl -> get_PermanentCardID(This,plCardID)

#define ITCallingCard_get_NumberOfDigits(This,plDigits)	\
    (This)->lpVtbl -> get_NumberOfDigits(This,plDigits)

#define ITCallingCard_get_Options(This,plOptions)	\
    (This)->lpVtbl -> get_Options(This,plOptions)

#define ITCallingCard_get_CardName(This,ppCardName)	\
    (This)->lpVtbl -> get_CardName(This,ppCardName)

#define ITCallingCard_get_SameAreaDialingRule(This,ppRule)	\
    (This)->lpVtbl -> get_SameAreaDialingRule(This,ppRule)

#define ITCallingCard_get_LongDistanceDialingRule(This,ppRule)	\
    (This)->lpVtbl -> get_LongDistanceDialingRule(This,ppRule)

#define ITCallingCard_get_InternationalDialingRule(This,ppRule)	\
    (This)->lpVtbl -> get_InternationalDialingRule(This,ppRule)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_PermanentCardID_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCardID);


void __RPC_STUB ITCallingCard_get_PermanentCardID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_NumberOfDigits_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plDigits);


void __RPC_STUB ITCallingCard_get_NumberOfDigits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_Options_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plOptions);


void __RPC_STUB ITCallingCard_get_Options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_CardName_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppCardName);


void __RPC_STUB ITCallingCard_get_CardName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_SameAreaDialingRule_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppRule);


void __RPC_STUB ITCallingCard_get_SameAreaDialingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_LongDistanceDialingRule_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppRule);


void __RPC_STUB ITCallingCard_get_LongDistanceDialingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallingCard_get_InternationalDialingRule_Proxy( 
    ITCallingCard __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppRule);


void __RPC_STUB ITCallingCard_get_InternationalDialingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallingCard_INTERFACE_DEFINED__ */


#ifndef __IEnumCallingCard_INTERFACE_DEFINED__
#define __IEnumCallingCard_INTERFACE_DEFINED__

/* interface IEnumCallingCard */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumCallingCard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F02-8DDB-11d1-A09E-00805FC147D3")
    IEnumCallingCard : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITCallingCard __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCallingCard __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCallingCardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCallingCard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCallingCard __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCallingCard __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCallingCard __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITCallingCard __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCallingCard __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCallingCard __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCallingCard __RPC_FAR * This,
            /* [retval][out] */ IEnumCallingCard __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumCallingCardVtbl;

    interface IEnumCallingCard
    {
        CONST_VTBL struct IEnumCallingCardVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCallingCard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCallingCard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCallingCard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCallingCard_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumCallingCard_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCallingCard_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCallingCard_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCallingCard_Next_Proxy( 
    IEnumCallingCard __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITCallingCard __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCallingCard_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCallingCard_Reset_Proxy( 
    IEnumCallingCard __RPC_FAR * This);


void __RPC_STUB IEnumCallingCard_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCallingCard_Skip_Proxy( 
    IEnumCallingCard __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCallingCard_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCallingCard_Clone_Proxy( 
    IEnumCallingCard __RPC_FAR * This,
    /* [retval][out] */ IEnumCallingCard __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumCallingCard_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCallingCard_INTERFACE_DEFINED__ */


#ifndef __ITCallNotificationEvent_INTERFACE_DEFINED__
#define __ITCallNotificationEvent_INTERFACE_DEFINED__

/* interface ITCallNotificationEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallNotificationEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("895801DF-3DD6-11d1-8F30-00C04FB6809F")
    ITCallNotificationEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ CALL_NOTIFICATION_EVENT __RPC_FAR *pCallNotificationEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallNotificationEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITCallNotificationEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITCallNotificationEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Event )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [retval][out] */ CALL_NOTIFICATION_EVENT __RPC_FAR *pCallNotificationEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallbackInstance )( 
            ITCallNotificationEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCallbackInstance);
        
        END_INTERFACE
    } ITCallNotificationEventVtbl;

    interface ITCallNotificationEvent
    {
        CONST_VTBL struct ITCallNotificationEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallNotificationEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITCallNotificationEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITCallNotificationEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITCallNotificationEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITCallNotificationEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITCallNotificationEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITCallNotificationEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITCallNotificationEvent_get_Call(This,ppCall)	\
    (This)->lpVtbl -> get_Call(This,ppCall)

#define ITCallNotificationEvent_get_Event(This,pCallNotificationEvent)	\
    (This)->lpVtbl -> get_Event(This,pCallNotificationEvent)

#define ITCallNotificationEvent_get_CallbackInstance(This,plCallbackInstance)	\
    (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallNotificationEvent_get_Call_Proxy( 
    ITCallNotificationEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCall);


void __RPC_STUB ITCallNotificationEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallNotificationEvent_get_Event_Proxy( 
    ITCallNotificationEvent __RPC_FAR * This,
    /* [retval][out] */ CALL_NOTIFICATION_EVENT __RPC_FAR *pCallNotificationEvent);


void __RPC_STUB ITCallNotificationEvent_get_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITCallNotificationEvent_get_CallbackInstance_Proxy( 
    ITCallNotificationEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCallbackInstance);


void __RPC_STUB ITCallNotificationEvent_get_CallbackInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITCallNotificationEvent_INTERFACE_DEFINED__ */


#ifndef __ITPrivateData_INTERFACE_DEFINED__
#define __ITPrivateData_INTERFACE_DEFINED__

/* interface ITPrivateData */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPrivateData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f42a92cd-f74f-4cf7-abe8-5ce0c17a2206")
    ITPrivateData : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SendPrivateData( 
            IUnknown __RPC_FAR *pObject,
            TAPI_OBJECT_TYPE ObjectType,
            BYTE __RPC_FAR *pBuffer,
            DWORD dwSize) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SendPrivateEvent( 
            IUnknown __RPC_FAR *pObject,
            TAPI_OBJECT_TYPE ObjectType,
            long lEventCode,
            IDispatch __RPC_FAR *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPrivateDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITPrivateData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITPrivateData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITPrivateData __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendPrivateData )( 
            ITPrivateData __RPC_FAR * This,
            IUnknown __RPC_FAR *pObject,
            TAPI_OBJECT_TYPE ObjectType,
            BYTE __RPC_FAR *pBuffer,
            DWORD dwSize);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendPrivateEvent )( 
            ITPrivateData __RPC_FAR * This,
            IUnknown __RPC_FAR *pObject,
            TAPI_OBJECT_TYPE ObjectType,
            long lEventCode,
            IDispatch __RPC_FAR *pEvent);
        
        END_INTERFACE
    } ITPrivateDataVtbl;

    interface ITPrivateData
    {
        CONST_VTBL struct ITPrivateDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPrivateData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITPrivateData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITPrivateData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITPrivateData_SendPrivateData(This,pObject,ObjectType,pBuffer,dwSize)	\
    (This)->lpVtbl -> SendPrivateData(This,pObject,ObjectType,pBuffer,dwSize)

#define ITPrivateData_SendPrivateEvent(This,pObject,ObjectType,lEventCode,pEvent)	\
    (This)->lpVtbl -> SendPrivateEvent(This,pObject,ObjectType,lEventCode,pEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateData_SendPrivateData_Proxy( 
    ITPrivateData __RPC_FAR * This,
    IUnknown __RPC_FAR *pObject,
    TAPI_OBJECT_TYPE ObjectType,
    BYTE __RPC_FAR *pBuffer,
    DWORD dwSize);


void __RPC_STUB ITPrivateData_SendPrivateData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateData_SendPrivateEvent_Proxy( 
    ITPrivateData __RPC_FAR * This,
    IUnknown __RPC_FAR *pObject,
    TAPI_OBJECT_TYPE ObjectType,
    long lEventCode,
    IDispatch __RPC_FAR *pEvent);


void __RPC_STUB ITPrivateData_SendPrivateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITPrivateData_INTERFACE_DEFINED__ */


#ifndef __ITPrivateReceiveData_INTERFACE_DEFINED__
#define __ITPrivateReceiveData_INTERFACE_DEFINED__

/* interface ITPrivateReceiveData */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPrivateReceiveData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89A69E97-9119-11d1-BB60-00C04FB6809F")
    ITPrivateReceiveData : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ReceivePrivateData( 
            IUnknown __RPC_FAR *pPrivateObject,
            TAPI_OBJECT_TYPE ObjectType,
            BYTE __RPC_FAR *pBuffer,
            DWORD dwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPrivateReceiveDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITPrivateReceiveData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITPrivateReceiveData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITPrivateReceiveData __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReceivePrivateData )( 
            ITPrivateReceiveData __RPC_FAR * This,
            IUnknown __RPC_FAR *pPrivateObject,
            TAPI_OBJECT_TYPE ObjectType,
            BYTE __RPC_FAR *pBuffer,
            DWORD dwSize);
        
        END_INTERFACE
    } ITPrivateReceiveDataVtbl;

    interface ITPrivateReceiveData
    {
        CONST_VTBL struct ITPrivateReceiveDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPrivateReceiveData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITPrivateReceiveData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITPrivateReceiveData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITPrivateReceiveData_ReceivePrivateData(This,pPrivateObject,ObjectType,pBuffer,dwSize)	\
    (This)->lpVtbl -> ReceivePrivateData(This,pPrivateObject,ObjectType,pBuffer,dwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateReceiveData_ReceivePrivateData_Proxy( 
    ITPrivateReceiveData __RPC_FAR * This,
    IUnknown __RPC_FAR *pPrivateObject,
    TAPI_OBJECT_TYPE ObjectType,
    BYTE __RPC_FAR *pBuffer,
    DWORD dwSize);


void __RPC_STUB ITPrivateReceiveData_ReceivePrivateData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITPrivateReceiveData_INTERFACE_DEFINED__ */


#ifndef __ITPrivateObjectFactory_INTERFACE_DEFINED__
#define __ITPrivateObjectFactory_INTERFACE_DEFINED__

/* interface ITPrivateObjectFactory */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPrivateObjectFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FFB3DF5-9118-11d1-BB60-00C04FB6809F")
    ITPrivateObjectFactory : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePrivateCommunication( 
            ITPrivateData __RPC_FAR *pPrivateData,
            ITPrivateReceiveData __RPC_FAR *__RPC_FAR *ppPrivateReceiveData) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePrivateTapi( 
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateTapi) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePrivateAddress( 
            IUnknown __RPC_FAR *pOuterUnknown,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateAddress) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePrivateCall( 
            BOOL fCallExists,
            IUnknown __RPC_FAR *pOuterUnknown,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateCall) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePrivateCallHub( 
            IUnknown __RPC_FAR *pOuterUnknown,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateCallHub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPrivateObjectFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITPrivateObjectFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITPrivateObjectFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITPrivateObjectFactory __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePrivateCommunication )( 
            ITPrivateObjectFactory __RPC_FAR * This,
            ITPrivateData __RPC_FAR *pPrivateData,
            ITPrivateReceiveData __RPC_FAR *__RPC_FAR *ppPrivateReceiveData);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePrivateTapi )( 
            ITPrivateObjectFactory __RPC_FAR * This,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateTapi);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePrivateAddress )( 
            ITPrivateObjectFactory __RPC_FAR * This,
            IUnknown __RPC_FAR *pOuterUnknown,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateAddress);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePrivateCall )( 
            ITPrivateObjectFactory __RPC_FAR * This,
            BOOL fCallExists,
            IUnknown __RPC_FAR *pOuterUnknown,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateCall);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePrivateCallHub )( 
            ITPrivateObjectFactory __RPC_FAR * This,
            IUnknown __RPC_FAR *pOuterUnknown,
            IUnknown __RPC_FAR *__RPC_FAR *ppPrivateCallHub);
        
        END_INTERFACE
    } ITPrivateObjectFactoryVtbl;

    interface ITPrivateObjectFactory
    {
        CONST_VTBL struct ITPrivateObjectFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPrivateObjectFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITPrivateObjectFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITPrivateObjectFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITPrivateObjectFactory_CreatePrivateCommunication(This,pPrivateData,ppPrivateReceiveData)	\
    (This)->lpVtbl -> CreatePrivateCommunication(This,pPrivateData,ppPrivateReceiveData)

#define ITPrivateObjectFactory_CreatePrivateTapi(This,ppPrivateTapi)	\
    (This)->lpVtbl -> CreatePrivateTapi(This,ppPrivateTapi)

#define ITPrivateObjectFactory_CreatePrivateAddress(This,pOuterUnknown,ppPrivateAddress)	\
    (This)->lpVtbl -> CreatePrivateAddress(This,pOuterUnknown,ppPrivateAddress)

#define ITPrivateObjectFactory_CreatePrivateCall(This,fCallExists,pOuterUnknown,ppPrivateCall)	\
    (This)->lpVtbl -> CreatePrivateCall(This,fCallExists,pOuterUnknown,ppPrivateCall)

#define ITPrivateObjectFactory_CreatePrivateCallHub(This,pOuterUnknown,ppPrivateCallHub)	\
    (This)->lpVtbl -> CreatePrivateCallHub(This,pOuterUnknown,ppPrivateCallHub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateObjectFactory_CreatePrivateCommunication_Proxy( 
    ITPrivateObjectFactory __RPC_FAR * This,
    ITPrivateData __RPC_FAR *pPrivateData,
    ITPrivateReceiveData __RPC_FAR *__RPC_FAR *ppPrivateReceiveData);


void __RPC_STUB ITPrivateObjectFactory_CreatePrivateCommunication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateObjectFactory_CreatePrivateTapi_Proxy( 
    ITPrivateObjectFactory __RPC_FAR * This,
    IUnknown __RPC_FAR *__RPC_FAR *ppPrivateTapi);


void __RPC_STUB ITPrivateObjectFactory_CreatePrivateTapi_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateObjectFactory_CreatePrivateAddress_Proxy( 
    ITPrivateObjectFactory __RPC_FAR * This,
    IUnknown __RPC_FAR *pOuterUnknown,
    IUnknown __RPC_FAR *__RPC_FAR *ppPrivateAddress);


void __RPC_STUB ITPrivateObjectFactory_CreatePrivateAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateObjectFactory_CreatePrivateCall_Proxy( 
    ITPrivateObjectFactory __RPC_FAR * This,
    BOOL fCallExists,
    IUnknown __RPC_FAR *pOuterUnknown,
    IUnknown __RPC_FAR *__RPC_FAR *ppPrivateCall);


void __RPC_STUB ITPrivateObjectFactory_CreatePrivateCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITPrivateObjectFactory_CreatePrivateCallHub_Proxy( 
    ITPrivateObjectFactory __RPC_FAR * This,
    IUnknown __RPC_FAR *pOuterUnknown,
    IUnknown __RPC_FAR *__RPC_FAR *ppPrivateCallHub);


void __RPC_STUB ITPrivateObjectFactory_CreatePrivateCallHub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITPrivateObjectFactory_INTERFACE_DEFINED__ */


#ifndef __ITDispatchMapper_INTERFACE_DEFINED__
#define __ITDispatchMapper_INTERFACE_DEFINED__

/* interface ITDispatchMapper */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDispatchMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9225295-C759-11d1-A02B-00C04FB6809F")
    ITDispatchMapper : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryDispatchInterface( 
            /* [in] */ BSTR pIID,
            /* [in] */ IDispatch __RPC_FAR *pInterfaceToMap,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppReturnedInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDispatchMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITDispatchMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITDispatchMapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITDispatchMapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITDispatchMapper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITDispatchMapper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITDispatchMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITDispatchMapper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDispatchInterface )( 
            ITDispatchMapper __RPC_FAR * This,
            /* [in] */ BSTR pIID,
            /* [in] */ IDispatch __RPC_FAR *pInterfaceToMap,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppReturnedInterface);
        
        END_INTERFACE
    } ITDispatchMapperVtbl;

    interface ITDispatchMapper
    {
        CONST_VTBL struct ITDispatchMapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDispatchMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITDispatchMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITDispatchMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITDispatchMapper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITDispatchMapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITDispatchMapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITDispatchMapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITDispatchMapper_QueryDispatchInterface(This,pIID,pInterfaceToMap,ppReturnedInterface)	\
    (This)->lpVtbl -> QueryDispatchInterface(This,pIID,pInterfaceToMap,ppReturnedInterface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITDispatchMapper_QueryDispatchInterface_Proxy( 
    ITDispatchMapper __RPC_FAR * This,
    /* [in] */ BSTR pIID,
    /* [in] */ IDispatch __RPC_FAR *pInterfaceToMap,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppReturnedInterface);


void __RPC_STUB ITDispatchMapper_QueryDispatchInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITDispatchMapper_INTERFACE_DEFINED__ */


#ifndef __ITStreamControl_INTERFACE_DEFINED__
#define __ITStreamControl_INTERFACE_DEFINED__

/* interface ITStreamControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD604-3868-11D2-A045-00C04FB6809F")
    ITStreamControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION td,
            /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ ITStream __RPC_FAR *pStream) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateStreams( 
            /* [out] */ IEnumStream __RPC_FAR *__RPC_FAR *ppEnumStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Streams( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITStreamControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITStreamControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITStreamControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITStreamControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITStreamControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITStreamControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITStreamControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStream )( 
            ITStreamControl __RPC_FAR * This,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION td,
            /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            ITStreamControl __RPC_FAR * This,
            /* [in] */ ITStream __RPC_FAR *pStream);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateStreams )( 
            ITStreamControl __RPC_FAR * This,
            /* [out] */ IEnumStream __RPC_FAR *__RPC_FAR *ppEnumStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Streams )( 
            ITStreamControl __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITStreamControlVtbl;

    interface ITStreamControl
    {
        CONST_VTBL struct ITStreamControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITStreamControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITStreamControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITStreamControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITStreamControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITStreamControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITStreamControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITStreamControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITStreamControl_CreateStream(This,lMediaType,td,ppStream)	\
    (This)->lpVtbl -> CreateStream(This,lMediaType,td,ppStream)

#define ITStreamControl_RemoveStream(This,pStream)	\
    (This)->lpVtbl -> RemoveStream(This,pStream)

#define ITStreamControl_EnumerateStreams(This,ppEnumStream)	\
    (This)->lpVtbl -> EnumerateStreams(This,ppEnumStream)

#define ITStreamControl_get_Streams(This,pVariant)	\
    (This)->lpVtbl -> get_Streams(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStreamControl_CreateStream_Proxy( 
    ITStreamControl __RPC_FAR * This,
    /* [in] */ long lMediaType,
    /* [in] */ TERMINAL_DIRECTION td,
    /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB ITStreamControl_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStreamControl_RemoveStream_Proxy( 
    ITStreamControl __RPC_FAR * This,
    /* [in] */ ITStream __RPC_FAR *pStream);


void __RPC_STUB ITStreamControl_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITStreamControl_EnumerateStreams_Proxy( 
    ITStreamControl __RPC_FAR * This,
    /* [out] */ IEnumStream __RPC_FAR *__RPC_FAR *ppEnumStream);


void __RPC_STUB ITStreamControl_EnumerateStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITStreamControl_get_Streams_Proxy( 
    ITStreamControl __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITStreamControl_get_Streams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITStreamControl_INTERFACE_DEFINED__ */


#ifndef __ITStream_INTERFACE_DEFINED__
#define __ITStream_INTERFACE_DEFINED__

/* interface ITStream */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD605-3868-11D2-A045-00C04FB6809F")
    ITStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ long __RPC_FAR *plMediaType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ TERMINAL_DIRECTION __RPC_FAR *pTD) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *ppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectTerminal( 
            /* [in] */ ITTerminal __RPC_FAR *pTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectTerminal( 
            /* [in] */ ITTerminal __RPC_FAR *pTerminal) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateTerminals( 
            /* [out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnumTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminals( 
            /* [retval][out] */ VARIANT __RPC_FAR *pTerminals) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITStream __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITStream __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITStream __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MediaType )( 
            ITStream __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMediaType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            ITStream __RPC_FAR * This,
            /* [retval][out] */ TERMINAL_DIRECTION __RPC_FAR *pTD);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ITStream __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartStream )( 
            ITStream __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseStream )( 
            ITStream __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopStream )( 
            ITStream __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectTerminal )( 
            ITStream __RPC_FAR * This,
            /* [in] */ ITTerminal __RPC_FAR *pTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnselectTerminal )( 
            ITStream __RPC_FAR * This,
            /* [in] */ ITTerminal __RPC_FAR *pTerminal);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateTerminals )( 
            ITStream __RPC_FAR * This,
            /* [out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnumTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Terminals )( 
            ITStream __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pTerminals);
        
        END_INTERFACE
    } ITStreamVtbl;

    interface ITStream
    {
        CONST_VTBL struct ITStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITStream_get_MediaType(This,plMediaType)	\
    (This)->lpVtbl -> get_MediaType(This,plMediaType)

#define ITStream_get_Direction(This,pTD)	\
    (This)->lpVtbl -> get_Direction(This,pTD)

#define ITStream_get_Name(This,ppName)	\
    (This)->lpVtbl -> get_Name(This,ppName)

#define ITStream_StartStream(This)	\
    (This)->lpVtbl -> StartStream(This)

#define ITStream_PauseStream(This)	\
    (This)->lpVtbl -> PauseStream(This)

#define ITStream_StopStream(This)	\
    (This)->lpVtbl -> StopStream(This)

#define ITStream_SelectTerminal(This,pTerminal)	\
    (This)->lpVtbl -> SelectTerminal(This,pTerminal)

#define ITStream_UnselectTerminal(This,pTerminal)	\
    (This)->lpVtbl -> UnselectTerminal(This,pTerminal)

#define ITStream_EnumerateTerminals(This,ppEnumTerminal)	\
    (This)->lpVtbl -> EnumerateTerminals(This,ppEnumTerminal)

#define ITStream_get_Terminals(This,pTerminals)	\
    (This)->lpVtbl -> get_Terminals(This,pTerminals)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITStream_get_MediaType_Proxy( 
    ITStream __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMediaType);


void __RPC_STUB ITStream_get_MediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITStream_get_Direction_Proxy( 
    ITStream __RPC_FAR * This,
    /* [retval][out] */ TERMINAL_DIRECTION __RPC_FAR *pTD);


void __RPC_STUB ITStream_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITStream_get_Name_Proxy( 
    ITStream __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ppName);


void __RPC_STUB ITStream_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStream_StartStream_Proxy( 
    ITStream __RPC_FAR * This);


void __RPC_STUB ITStream_StartStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStream_PauseStream_Proxy( 
    ITStream __RPC_FAR * This);


void __RPC_STUB ITStream_PauseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStream_StopStream_Proxy( 
    ITStream __RPC_FAR * This);


void __RPC_STUB ITStream_StopStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStream_SelectTerminal_Proxy( 
    ITStream __RPC_FAR * This,
    /* [in] */ ITTerminal __RPC_FAR *pTerminal);


void __RPC_STUB ITStream_SelectTerminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITStream_UnselectTerminal_Proxy( 
    ITStream __RPC_FAR * This,
    /* [in] */ ITTerminal __RPC_FAR *pTerminal);


void __RPC_STUB ITStream_UnselectTerminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITStream_EnumerateTerminals_Proxy( 
    ITStream __RPC_FAR * This,
    /* [out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnumTerminal);


void __RPC_STUB ITStream_EnumerateTerminals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITStream_get_Terminals_Proxy( 
    ITStream __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pTerminals);


void __RPC_STUB ITStream_get_Terminals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITStream_INTERFACE_DEFINED__ */


#ifndef __IEnumStream_INTERFACE_DEFINED__
#define __IEnumStream_INTERFACE_DEFINED__

/* interface IEnumStream */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD606-3868-11d2-A045-00C04FB6809F")
    IEnumStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITStream __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumStream __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumStream __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITStream __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumStream __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumStream __RPC_FAR * This,
            /* [retval][out] */ IEnumStream __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumStreamVtbl;

    interface IEnumStream
    {
        CONST_VTBL struct IEnumStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumStream_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumStream_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumStream_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumStream_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumStream_Next_Proxy( 
    IEnumStream __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITStream __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumStream_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStream_Reset_Proxy( 
    IEnumStream __RPC_FAR * This);


void __RPC_STUB IEnumStream_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStream_Skip_Proxy( 
    IEnumStream __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumStream_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStream_Clone_Proxy( 
    IEnumStream __RPC_FAR * This,
    /* [retval][out] */ IEnumStream __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumStream_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumStream_INTERFACE_DEFINED__ */


#ifndef __ITSubStreamControl_INTERFACE_DEFINED__
#define __ITSubStreamControl_INTERFACE_DEFINED__

/* interface ITSubStreamControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITSubStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD607-3868-11D2-A045-00C04FB6809F")
    ITSubStreamControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSubStream( 
            /* [retval][out] */ ITSubStream __RPC_FAR *__RPC_FAR *ppSubStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveSubStream( 
            /* [in] */ ITSubStream __RPC_FAR *pSubStream) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateSubStreams( 
            /* [out] */ IEnumSubStream __RPC_FAR *__RPC_FAR *ppEnumSubStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubStreams( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITSubStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITSubStreamControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITSubStreamControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubStream )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [retval][out] */ ITSubStream __RPC_FAR *__RPC_FAR *ppSubStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSubStream )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [in] */ ITSubStream __RPC_FAR *pSubStream);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateSubStreams )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [out] */ IEnumSubStream __RPC_FAR *__RPC_FAR *ppEnumSubStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubStreams )( 
            ITSubStreamControl __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariant);
        
        END_INTERFACE
    } ITSubStreamControlVtbl;

    interface ITSubStreamControl
    {
        CONST_VTBL struct ITSubStreamControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITSubStreamControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITSubStreamControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITSubStreamControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITSubStreamControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITSubStreamControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITSubStreamControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITSubStreamControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITSubStreamControl_CreateSubStream(This,ppSubStream)	\
    (This)->lpVtbl -> CreateSubStream(This,ppSubStream)

#define ITSubStreamControl_RemoveSubStream(This,pSubStream)	\
    (This)->lpVtbl -> RemoveSubStream(This,pSubStream)

#define ITSubStreamControl_EnumerateSubStreams(This,ppEnumSubStream)	\
    (This)->lpVtbl -> EnumerateSubStreams(This,ppEnumSubStream)

#define ITSubStreamControl_get_SubStreams(This,pVariant)	\
    (This)->lpVtbl -> get_SubStreams(This,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStreamControl_CreateSubStream_Proxy( 
    ITSubStreamControl __RPC_FAR * This,
    /* [retval][out] */ ITSubStream __RPC_FAR *__RPC_FAR *ppSubStream);


void __RPC_STUB ITSubStreamControl_CreateSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStreamControl_RemoveSubStream_Proxy( 
    ITSubStreamControl __RPC_FAR * This,
    /* [in] */ ITSubStream __RPC_FAR *pSubStream);


void __RPC_STUB ITSubStreamControl_RemoveSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITSubStreamControl_EnumerateSubStreams_Proxy( 
    ITSubStreamControl __RPC_FAR * This,
    /* [out] */ IEnumSubStream __RPC_FAR *__RPC_FAR *ppEnumSubStream);


void __RPC_STUB ITSubStreamControl_EnumerateSubStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSubStreamControl_get_SubStreams_Proxy( 
    ITSubStreamControl __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariant);


void __RPC_STUB ITSubStreamControl_get_SubStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITSubStreamControl_INTERFACE_DEFINED__ */


#ifndef __ITSubStream_INTERFACE_DEFINED__
#define __ITSubStream_INTERFACE_DEFINED__

/* interface ITSubStream */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITSubStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD608-3868-11D2-A045-00C04FB6809F")
    ITSubStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartSubStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseSubStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopSubStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectTerminal( 
            /* [in] */ ITTerminal __RPC_FAR *pTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectTerminal( 
            /* [in] */ ITTerminal __RPC_FAR *pTerminal) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateTerminals( 
            /* [out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnumTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminals( 
            /* [retval][out] */ VARIANT __RPC_FAR *pTerminals) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Stream( 
            /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppITStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITSubStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITSubStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITSubStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITSubStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITSubStream __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITSubStream __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITSubStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITSubStream __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartSubStream )( 
            ITSubStream __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseSubStream )( 
            ITSubStream __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopSubStream )( 
            ITSubStream __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectTerminal )( 
            ITSubStream __RPC_FAR * This,
            /* [in] */ ITTerminal __RPC_FAR *pTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnselectTerminal )( 
            ITSubStream __RPC_FAR * This,
            /* [in] */ ITTerminal __RPC_FAR *pTerminal);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateTerminals )( 
            ITSubStream __RPC_FAR * This,
            /* [out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnumTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Terminals )( 
            ITSubStream __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pTerminals);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Stream )( 
            ITSubStream __RPC_FAR * This,
            /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppITStream);
        
        END_INTERFACE
    } ITSubStreamVtbl;

    interface ITSubStream
    {
        CONST_VTBL struct ITSubStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITSubStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITSubStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITSubStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITSubStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITSubStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITSubStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITSubStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITSubStream_StartSubStream(This)	\
    (This)->lpVtbl -> StartSubStream(This)

#define ITSubStream_PauseSubStream(This)	\
    (This)->lpVtbl -> PauseSubStream(This)

#define ITSubStream_StopSubStream(This)	\
    (This)->lpVtbl -> StopSubStream(This)

#define ITSubStream_SelectTerminal(This,pTerminal)	\
    (This)->lpVtbl -> SelectTerminal(This,pTerminal)

#define ITSubStream_UnselectTerminal(This,pTerminal)	\
    (This)->lpVtbl -> UnselectTerminal(This,pTerminal)

#define ITSubStream_EnumerateTerminals(This,ppEnumTerminal)	\
    (This)->lpVtbl -> EnumerateTerminals(This,ppEnumTerminal)

#define ITSubStream_get_Terminals(This,pTerminals)	\
    (This)->lpVtbl -> get_Terminals(This,pTerminals)

#define ITSubStream_get_Stream(This,ppITStream)	\
    (This)->lpVtbl -> get_Stream(This,ppITStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStream_StartSubStream_Proxy( 
    ITSubStream __RPC_FAR * This);


void __RPC_STUB ITSubStream_StartSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStream_PauseSubStream_Proxy( 
    ITSubStream __RPC_FAR * This);


void __RPC_STUB ITSubStream_PauseSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStream_StopSubStream_Proxy( 
    ITSubStream __RPC_FAR * This);


void __RPC_STUB ITSubStream_StopSubStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStream_SelectTerminal_Proxy( 
    ITSubStream __RPC_FAR * This,
    /* [in] */ ITTerminal __RPC_FAR *pTerminal);


void __RPC_STUB ITSubStream_SelectTerminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITSubStream_UnselectTerminal_Proxy( 
    ITSubStream __RPC_FAR * This,
    /* [in] */ ITTerminal __RPC_FAR *pTerminal);


void __RPC_STUB ITSubStream_UnselectTerminal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id] */ HRESULT STDMETHODCALLTYPE ITSubStream_EnumerateTerminals_Proxy( 
    ITSubStream __RPC_FAR * This,
    /* [out] */ IEnumTerminal __RPC_FAR *__RPC_FAR *ppEnumTerminal);


void __RPC_STUB ITSubStream_EnumerateTerminals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSubStream_get_Terminals_Proxy( 
    ITSubStream __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pTerminals);


void __RPC_STUB ITSubStream_get_Terminals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITSubStream_get_Stream_Proxy( 
    ITSubStream __RPC_FAR * This,
    /* [retval][out] */ ITStream __RPC_FAR *__RPC_FAR *ppITStream);


void __RPC_STUB ITSubStream_get_Stream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITSubStream_INTERFACE_DEFINED__ */


#ifndef __IEnumSubStream_INTERFACE_DEFINED__
#define __IEnumSubStream_INTERFACE_DEFINED__

/* interface IEnumSubStream */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumSubStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD609-3868-11d2-A045-00C04FB6809F")
    IEnumSubStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ ITSubStream __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumSubStream __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSubStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumSubStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumSubStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumSubStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumSubStream __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ITSubStream __RPC_FAR *__RPC_FAR *ppElements,
            /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumSubStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumSubStream __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumSubStream __RPC_FAR * This,
            /* [retval][out] */ IEnumSubStream __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumSubStreamVtbl;

    interface IEnumSubStream
    {
        CONST_VTBL struct IEnumSubStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSubStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSubStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSubStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSubStream_Next(This,celt,ppElements,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched)

#define IEnumSubStream_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSubStream_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSubStream_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumSubStream_Next_Proxy( 
    IEnumSubStream __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ITSubStream __RPC_FAR *__RPC_FAR *ppElements,
    /* [full][out][in] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumSubStream_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSubStream_Reset_Proxy( 
    IEnumSubStream __RPC_FAR * This);


void __RPC_STUB IEnumSubStream_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSubStream_Skip_Proxy( 
    IEnumSubStream __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSubStream_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSubStream_Clone_Proxy( 
    IEnumSubStream __RPC_FAR * This,
    /* [retval][out] */ IEnumSubStream __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumSubStream_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSubStream_INTERFACE_DEFINED__ */


#ifndef __ITLegacyWaveSupport_INTERFACE_DEFINED__
#define __ITLegacyWaveSupport_INTERFACE_DEFINED__

/* interface ITLegacyWaveSupport */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyWaveSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("207823EA-E252-11d2-B77E-0080C7135381")
    ITLegacyWaveSupport : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsFullDuplex( 
            /* [out] */ FULLDUPLEX_SUPPORT __RPC_FAR *pSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyWaveSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITLegacyWaveSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITLegacyWaveSupport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITLegacyWaveSupport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITLegacyWaveSupport __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITLegacyWaveSupport __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITLegacyWaveSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITLegacyWaveSupport __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsFullDuplex )( 
            ITLegacyWaveSupport __RPC_FAR * This,
            /* [out] */ FULLDUPLEX_SUPPORT __RPC_FAR *pSupport);
        
        END_INTERFACE
    } ITLegacyWaveSupportVtbl;

    interface ITLegacyWaveSupport
    {
        CONST_VTBL struct ITLegacyWaveSupportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyWaveSupport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITLegacyWaveSupport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITLegacyWaveSupport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITLegacyWaveSupport_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITLegacyWaveSupport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITLegacyWaveSupport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITLegacyWaveSupport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITLegacyWaveSupport_IsFullDuplex(This,pSupport)	\
    (This)->lpVtbl -> IsFullDuplex(This,pSupport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITLegacyWaveSupport_IsFullDuplex_Proxy( 
    ITLegacyWaveSupport __RPC_FAR * This,
    /* [out] */ FULLDUPLEX_SUPPORT __RPC_FAR *pSupport);


void __RPC_STUB ITLegacyWaveSupport_IsFullDuplex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITLegacyWaveSupport_INTERFACE_DEFINED__ */


#ifndef __ITPrivateEvent_INTERFACE_DEFINED__
#define __ITPrivateEvent_INTERFACE_DEFINED__

/* interface ITPrivateEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPrivateEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e269cd0-10d4-4121-9c22-9c85d625650d")
    ITPrivateEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHub( 
            /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventCode( 
            /* [retval][out] */ long __RPC_FAR *plEventCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventInterface( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *pEventInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPrivateEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITPrivateEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITPrivateEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Call )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallHub )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventCode )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plEventCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventInterface )( 
            ITPrivateEvent __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *pEventInterface);
        
        END_INTERFACE
    } ITPrivateEventVtbl;

    interface ITPrivateEvent
    {
        CONST_VTBL struct ITPrivateEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPrivateEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITPrivateEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITPrivateEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITPrivateEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITPrivateEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITPrivateEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITPrivateEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITPrivateEvent_get_Address(This,ppAddress)	\
    (This)->lpVtbl -> get_Address(This,ppAddress)

#define ITPrivateEvent_get_Call(This,ppCallInfo)	\
    (This)->lpVtbl -> get_Call(This,ppCallInfo)

#define ITPrivateEvent_get_CallHub(This,ppCallHub)	\
    (This)->lpVtbl -> get_CallHub(This,ppCallHub)

#define ITPrivateEvent_get_EventCode(This,plEventCode)	\
    (This)->lpVtbl -> get_EventCode(This,plEventCode)

#define ITPrivateEvent_get_EventInterface(This,pEventInterface)	\
    (This)->lpVtbl -> get_EventInterface(This,pEventInterface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITPrivateEvent_get_Address_Proxy( 
    ITPrivateEvent __RPC_FAR * This,
    /* [retval][out] */ ITAddress __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB ITPrivateEvent_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITPrivateEvent_get_Call_Proxy( 
    ITPrivateEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallInfo __RPC_FAR *__RPC_FAR *ppCallInfo);


void __RPC_STUB ITPrivateEvent_get_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITPrivateEvent_get_CallHub_Proxy( 
    ITPrivateEvent __RPC_FAR * This,
    /* [retval][out] */ ITCallHub __RPC_FAR *__RPC_FAR *ppCallHub);


void __RPC_STUB ITPrivateEvent_get_CallHub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITPrivateEvent_get_EventCode_Proxy( 
    ITPrivateEvent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plEventCode);


void __RPC_STUB ITPrivateEvent_get_EventCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITPrivateEvent_get_EventInterface_Proxy( 
    ITPrivateEvent __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *pEventInterface);


void __RPC_STUB ITPrivateEvent_get_EventInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITPrivateEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tapi3if_0156 */
/* [local] */ 

/****************************************
 * Terminal Classes
 ****************************************/

// Video Windows - {F7438990-D6EB-11d0-82A6-00AA00B5CA1B}
EXTERN_C const CLSID CLSID_VideoWindowTerm;

// Video input (camera) {AAF578EC-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_VideoInputTerminal;

// Handset device {AAF578EB-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_HandsetTerminal;

// Headset device {AAF578ED-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_HeadsetTerminal;

// Speakerphone device {AAF578EE-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_SpeakerphoneTerminal;

// Microphone (sound card) {AAF578EF-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_MicrophoneTerminal;

// Speakers (sound card) {AAF578F0-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_SpeakersTerminal;

// Media stream terminal {E2F7AEF7-4971-11D1-A671-006097C9A2E8}
EXTERN_C const CLSID CLSID_MediaStreamTerminal;

// define the media modes
#define TAPIMEDIATYPE_AUDIO                     0x8
#define TAPIMEDIATYPE_VIDEO                     0x8000
#define TAPIMEDIATYPE_DATAMODEM                 0x10
#define TAPIMEDIATYPE_G3FAX                     0x20

// {831CE2D6-83B5-11d1-BB5C-00C04FB6809F}
EXTERN_C const CLSID TAPIPROTOCOL_PSTN;

// {831CE2D7-83B5-11d1-BB5C-00C04FB6809F}
EXTERN_C const CLSID TAPIPROTOCOL_H323;

// {831CE2D8-83B5-11d1-BB5C-00C04FB6809F}
EXTERN_C const CLSID TAPIPROTOCOL_Multicast;

#define __TapiConstants_MODULE_DEFINED__


extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0156_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#if defined(_WIN32_WCE) && (_WIN32_WCE < 200)
#error "ATL projects can only be compiled for Windows CE 2.0 or later."
#endif // _WIN32_WCE

#if defined(_WIN32_WCE)
#include "wceatl.h"
#define WCE_DEL /##/
#define WCE_INS
#define WCE_FCTN(fctn) wce_##fctn
#define WCE_IF(wce,base) wce
#define WCE_ATL_LIBNAME                WCE_FILENAME_1(atlce,_WIN32_WCE,.lib)
#define WCE_FILENAME_1(name, ver, ext) WCE_FILENAME_2(name, ver, ext)
#define WCE_FILENAME_2(name, ver, ext) #name #ver #ext
#else // _WIN32_WCE
#define _T(x) x
#define WCE_DEL
#define WCE_INS /##/
#define WCE_FCTN(fctn) fctn
#define WCE_IF(wce,base) base
#endif // _WIN32_WCE
#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <atldef.h>

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

WCE_INS typedef GUID CATID;		// missed definition from comcat.h
WCE_DEL #include <comcat.h>
WCE_DEL #include <stddef.h>

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
WCE_DEL #include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

WCE_DEL #include <shlwapi.h>

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
#if defined(_WIN32_WCE)
	#pragma comment(lib, WCE_ATL_LIBNAME)
#else // _WIN32_WCE
	#pragma comment(lib, "atl.lib")
#endif // _WIN32_WCE
#endif
#if defined(_WIN32_WCE)
namespace ATL
{
	HRESULT wce_OleLoadFromStream ( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
	HRESULT wce_OleSaveToStream ( LPPERSISTSTREAM pPStm, LPSTREAM pStm);
	HRESULT wce_ProgIDFromCLSID(REFCLSID clsid, LPOLESTR *lplpszProgID);
	HRESULT wce_CLSIDFromProgID(LPCOLESTR lpszProgID, LPCLSID pclsid);
	HRESULT wce_CreateStreamOnHGlobal(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
	int	wce_MulDiv(int nNumber, int nNumerator, int nDenominator);
} // namespace ATL

#endif // _WIN32_WCE

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
WCE_DEL extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
WCE_DEL extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD dw);

struct _ATL_TERMFUNC_ELEM
{
	_ATL_TERMFUNC* pFunc;
	DWORD dw;
	_ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
	_ATL_CATMAPFUNC* pfnGetCategoryMap;
#if !defined(_WIN32_WCE)
	HRESULT WINAPI RevokeClassObject()
	{
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
	{
		IUnknown* p = NULL;
		if (pfnGetClassObject == NULL)
			return S_OK;
		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		if (p != NULL)
			p->Release();
		return hRes;
	}
#endif // _WIN32_WCE
// Added in ATL 3.0
	void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
	LPCOLESTR     szKey;
	LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
	void* m_pThis;
	DWORD m_dwThreadID;
	_AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
	DWORD dwAtlBuildVer;
	_AtlCreateWndData* m_pCreateWndList;
	bool m_bDestroyHeap;
	GUID* pguidVer;
	DWORD m_dwHeaps;	// Number of heaps we have (-1)
	HANDLE* m_phHeaps;
	int m_nHeap;		// Which heap to choose from
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

const int _nAtlModuleVer1Size = 100;

//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

WCE_DEL ATLAPI AtlFreeMarshalStream(IStream* pStream);
WCE_DEL ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
WCE_DEL ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

WCE_DEL ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
	HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

WCE_DEL ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
WCE_DEL ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD dw);


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

enum atlTraceFlags
{
	// Application defined categories
	atlTraceUser 		= 0x00000001,
	atlTraceUser2 		= 0x00000002,
	atlTraceUser3 		= 0x00000004,
	atlTraceUser4 		= 0x00000008,
	// ATL defined categories
	atlTraceGeneral		= 0x00000020,
	atlTraceCOM 		= 0x00000040,
	atlTraceQI		= 0x00000080,
	atlTraceRegistrar	= 0x00000100,
	atlTraceRefcount	= 0x00000200,
	atlTraceWindowing	= 0x00000400,
	atlTraceControls	= 0x00000800,
	atlTraceHosting		= 0x00001000,
	atlTraceDBClient	= 0x00002000,
	atlTraceDBProvider	= 0x00004000,
	atlTraceSnapin		= 0x00008000,
	atlTraceNotImpl		= 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

#if !defined(_WIN32_WCE)
inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("ATL: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#endif // _WIN32_WCE
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

#if defined(_WIN32_WCE)
	nBuf = _vstprintf(szBuffer, lpszFormat, args);
#else // _WIN32_WCE
	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
#endif // _WIN32_WCE
	ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

#if defined(_WIN32_WCE)
		nBuf = _vstprintf(szBuffer, lpszFormat, args);
#else // _WIN32_WCE
		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
#endif // _WIN32_WCE
		ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"ATL: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2			1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG





/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _ATL_NO_FORCE_LIBS
#if defined(_WIN32_WCE)
	#pragma comment(lib, "coredll.lib")
	#pragma comment(lib, "commctrl.lib")
	#pragma comment(lib, "uuid.lib")
	#if defined(_WIN32_WCE_EMULATION) && (_WIN32_WCE < 210) 
		#pragma comment(lib, "ole32m.lib")
		#pragma comment(lib, "oleautm.lib")
	#else
		#pragma comment(lib, "ole32.lib")
		#pragma comment(lib, "oleaut32.lib")
	#endif // _WIN32_WCE_EMULATION
	#if (_WIN32_WCE > 200)	
		#pragma comment(lib, "corelibc.lib")
		#pragma comment(linker, "/nodefaultlib:libc.lib")
		#pragma comment(linker, "/nodefaultlib:libcd.lib")
		#pragma comment(linker, "/nodefaultlib:libcmt.lib")
		#pragma comment(linker, "/nodefaultlib:libcmtd.lib")
		#pragma comment(linker, "/nodefaultlib:oldnames.lib")
	#else // _WIN32_WCE > 200
		#if defined(_DEBUG)
			#pragma comment(lib, "libcmtd.lib")
			#pragma comment(linker, "/nodefaultlib:corelibc.lib")
		#else
			#pragma comment(lib, "libcmt.lib")
			#pragma comment(linker, "/nodefaultlib:corelibc.lib")
		#endif
	#endif // _WIN32_WCE > 200
#else                            // Win32
	#pragma comment(lib, "kernel32.lib")
	#pragma comment(lib, "user32.lib")
	#pragma comment(lib, "olepro32.lib")
	#pragma comment(lib, "advapi32.lib")
	#pragma comment(lib, "ole32.lib")
	#pragma comment(lib, "oleaut32.lib")
	#pragma comment(lib, "uuid.lib")
#endif // _WIN32_WCE
#endif // _ATL_NO_FORCE_LIBS

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
	if (punkChild == NULL)
		return E_POINTER;

	HRESULT hr;
	IObjectWithSite* pChildSite = NULL;
	hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
	if (SUCCEEDED(hr) && pChildSite != NULL)
	{
		hr = pChildSite->SetSite(punkParent);
		pChildSite->Release();
	}
	return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr()
	{
		p=NULL;
	}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return (T*)p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p; 
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p; 
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = WCE_FCTN(CLSIDFromProgID)(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
#if 1//!defined(_WIN32_WCE)
// WinCE: our compilers don't support this kind of overloaded templated function
	template <class Q>
	HRESULT QueryInterface(Q** pp) const
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
#endif // _WIN32_WCE
	T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CComQIPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL); return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComQIPtr<T,piid>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	T* operator=(IUnknown* lp)
	{
		return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = WCE_FCTN(CLSIDFromProgID)(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp)
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
	typedef IUnknown _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(IUnknown* lp)
	{
		//Actually do a QI to get identity
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IUnknown, (void **)&p);
	}
	CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComQIPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator IUnknown*() const
	{
		return p;
	}
	IUnknown& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	IUnknown** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	IUnknown* operator=(IUnknown* lp)
	{
		//Actually do a QI to get identity
		return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
	}
	IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
	{
		return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(IUnknown* pT) const
	{
		return p < pT;
	}
	bool operator==(IUnknown* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	IUnknown* Detach()
	{
		IUnknown* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = WCE_FCTN(CLSIDFromProgID)(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp)
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	IUnknown* p;
};

#define com_cast CComQIPtr

/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is 
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
	CAdapt()
	{
	}
	CAdapt(const T& rSrc)
	{
		m_T = rSrc;
	}

	CAdapt(const CAdapt& rSrCA)
	{
		m_T = rSrCA.m_T;
	}

	CAdapt& operator=(const T& rSrc)
	{
		m_T = rSrc;
		return *this;
	}
	bool operator<(const T& rSrc) const
	{
		return m_T < rSrc;
	}
	bool operator==(const T& rSrc) const
	{
		return m_T == rSrc;
	}
	operator T&()
	{
		return m_T;
	}

	operator const T&() const
	{
		return m_T;
	}

	T m_T;
};

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support


class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	void Init() {InitializeCriticalSection(&m_sec);}
	void Term() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
	~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};


class CComMultiThreadModelNoCS
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};



class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComSingleThreadModel ThreadModelNoCS;
};



#if defined(_ATL_SINGLE_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
	STDMETHOD(QueryInterface)(REFIID iid, void** pp)
	{
		ATLASSERT(m_dwRef >= 0);
		return pUnk->QueryInterface(iid, pp);
	}
	STDMETHOD_(ULONG, AddRef)()
	{
		if (bBreak)
			DebugBreak();
		pUnk->AddRef();
		return InternalAddRef();
	}
	ULONG InternalAddRef()
	{
		if (bBreak)
			DebugBreak();
		ATLASSERT(m_dwRef >= 0);
		long l = InterlockedIncrement(&m_dwRef);
		ATLTRACE(_T("%d> "), m_dwRef);
		AtlDumpIID(iid, lpszClassName, S_OK);
		if (l > m_dwMaxRef)
			m_dwMaxRef = l;
		return l;
	}
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(f3)();
	STDMETHOD(f4)();
	STDMETHOD(f5)();
	STDMETHOD(f6)();
	STDMETHOD(f7)();
	STDMETHOD(f8)();
	STDMETHOD(f9)();
	STDMETHOD(f10)();
	STDMETHOD(f11)();
	STDMETHOD(f12)();
	STDMETHOD(f13)();
	STDMETHOD(f14)();
	STDMETHOD(f15)();
	STDMETHOD(f16)();
	STDMETHOD(f17)();
	STDMETHOD(f18)();
	STDMETHOD(f19)();
	STDMETHOD(f20)();
	STDMETHOD(f21)();
	STDMETHOD(f22)();
	STDMETHOD(f23)();
	STDMETHOD(f24)();
	STDMETHOD(f25)();
	STDMETHOD(f26)();
	STDMETHOD(f27)();
	STDMETHOD(f28)();
	STDMETHOD(f29)();
	STDMETHOD(f30)();
	STDMETHOD(f31)();
	STDMETHOD(f32)();
	STDMETHOD(f33)();
	STDMETHOD(f34)();
	STDMETHOD(f35)();
	STDMETHOD(f36)();
	STDMETHOD(f37)();
	STDMETHOD(f38)();
	STDMETHOD(f39)();
	STDMETHOD(f40)();
	STDMETHOD(f41)();
	STDMETHOD(f42)();
	STDMETHOD(f43)();
	STDMETHOD(f44)();
	STDMETHOD(f45)();
	STDMETHOD(f46)();
	STDMETHOD(f47)();
	STDMETHOD(f48)();
	STDMETHOD(f49)();
	STDMETHOD(f50)();
	STDMETHOD(f51)();
	STDMETHOD(f52)();
	STDMETHOD(f53)();
	STDMETHOD(f54)();
	STDMETHOD(f55)();
	STDMETHOD(f56)();
	STDMETHOD(f57)();
	STDMETHOD(f58)();
	STDMETHOD(f59)();
	STDMETHOD(f60)();
	STDMETHOD(f61)();
	STDMETHOD(f62)();
	STDMETHOD(f63)();
	STDMETHOD(f64)();
	STDMETHOD(f65)();
	STDMETHOD(f66)();
	STDMETHOD(f67)();
	STDMETHOD(f68)();
	STDMETHOD(f69)();
	STDMETHOD(f70)();
	STDMETHOD(f71)();
	STDMETHOD(f72)();
	STDMETHOD(f73)();
	STDMETHOD(f74)();
	STDMETHOD(f75)();
	STDMETHOD(f76)();
	STDMETHOD(f77)();
	STDMETHOD(f78)();
	STDMETHOD(f79)();
	STDMETHOD(f80)();
	STDMETHOD(f81)();
	STDMETHOD(f82)();
	STDMETHOD(f83)();
	STDMETHOD(f84)();
	STDMETHOD(f85)();
	STDMETHOD(f86)();
	STDMETHOD(f87)();
	STDMETHOD(f88)();
	STDMETHOD(f89)();
	STDMETHOD(f90)();
	STDMETHOD(f91)();
	STDMETHOD(f92)();
	STDMETHOD(f93)();
	STDMETHOD(f94)();
	STDMETHOD(f95)();
	STDMETHOD(f96)();
	STDMETHOD(f97)();
	STDMETHOD(f98)();
	STDMETHOD(f99)();
	STDMETHOD(f100)();
	STDMETHOD(f101)();
	STDMETHOD(f102)();
	STDMETHOD(f103)();
	STDMETHOD(f104)();
	STDMETHOD(f105)();
	STDMETHOD(f106)();
	STDMETHOD(f107)();
	STDMETHOD(f108)();
	STDMETHOD(f109)();
	STDMETHOD(f110)();
	STDMETHOD(f111)();
	STDMETHOD(f112)();
	STDMETHOD(f113)();
	STDMETHOD(f114)();
	STDMETHOD(f115)();
	STDMETHOD(f116)();
	STDMETHOD(f117)();
	STDMETHOD(f118)();
	STDMETHOD(f119)();
	STDMETHOD(f120)();
	STDMETHOD(f121)();
	STDMETHOD(f122)();
	STDMETHOD(f123)();
	STDMETHOD(f124)();
	STDMETHOD(f125)();
	STDMETHOD(f126)();
	STDMETHOD(f127)();
	STDMETHOD(f128)();
	STDMETHOD(f129)();
	STDMETHOD(f130)();
	STDMETHOD(f131)();
	STDMETHOD(f132)();
	STDMETHOD(f133)();
	STDMETHOD(f134)();
	STDMETHOD(f135)();
	STDMETHOD(f136)();
	STDMETHOD(f137)();
	STDMETHOD(f138)();
	STDMETHOD(f139)();
	STDMETHOD(f140)();
	STDMETHOD(f141)();
	STDMETHOD(f142)();
	STDMETHOD(f143)();
	STDMETHOD(f144)();
	STDMETHOD(f145)();
	STDMETHOD(f146)();
	STDMETHOD(f147)();
	STDMETHOD(f148)();
	STDMETHOD(f149)();
	STDMETHOD(f150)();
	STDMETHOD(f151)();
	STDMETHOD(f152)();
	STDMETHOD(f153)();
	STDMETHOD(f154)();
	STDMETHOD(f155)();
	STDMETHOD(f156)();
	STDMETHOD(f157)();
	STDMETHOD(f158)();
	STDMETHOD(f159)();
	STDMETHOD(f160)();
	STDMETHOD(f161)();
	STDMETHOD(f162)();
	STDMETHOD(f163)();
	STDMETHOD(f164)();
	STDMETHOD(f165)();
	STDMETHOD(f166)();
	STDMETHOD(f167)();
	STDMETHOD(f168)();
	STDMETHOD(f169)();
	STDMETHOD(f170)();
	STDMETHOD(f171)();
	STDMETHOD(f172)();
	STDMETHOD(f173)();
	STDMETHOD(f174)();
	STDMETHOD(f175)();
	STDMETHOD(f176)();
	STDMETHOD(f177)();
	STDMETHOD(f178)();
	STDMETHOD(f179)();
	STDMETHOD(f180)();
	STDMETHOD(f181)();
	STDMETHOD(f182)();
	STDMETHOD(f183)();
	STDMETHOD(f184)();
	STDMETHOD(f185)();
	STDMETHOD(f186)();
	STDMETHOD(f187)();
	STDMETHOD(f188)();
	STDMETHOD(f189)();
	STDMETHOD(f190)();
	STDMETHOD(f191)();
	STDMETHOD(f192)();
	STDMETHOD(f193)();
	STDMETHOD(f194)();
	STDMETHOD(f195)();
	STDMETHOD(f196)();
	STDMETHOD(f197)();
	STDMETHOD(f198)();
	STDMETHOD(f199)();
	STDMETHOD(f200)();
	STDMETHOD(f201)();
	STDMETHOD(f202)();
	STDMETHOD(f203)();
	STDMETHOD(f204)();
	STDMETHOD(f205)();
	STDMETHOD(f206)();
	STDMETHOD(f207)();
	STDMETHOD(f208)();
	STDMETHOD(f209)();
	STDMETHOD(f210)();
	STDMETHOD(f211)();
	STDMETHOD(f212)();
	STDMETHOD(f213)();
	STDMETHOD(f214)();
	STDMETHOD(f215)();
	STDMETHOD(f216)();
	STDMETHOD(f217)();
	STDMETHOD(f218)();
	STDMETHOD(f219)();
	STDMETHOD(f220)();
	STDMETHOD(f221)();
	STDMETHOD(f222)();
	STDMETHOD(f223)();
	STDMETHOD(f224)();
	STDMETHOD(f225)();
	STDMETHOD(f226)();
	STDMETHOD(f227)();
	STDMETHOD(f228)();
	STDMETHOD(f229)();
	STDMETHOD(f230)();
	STDMETHOD(f231)();
	STDMETHOD(f232)();
	STDMETHOD(f233)();
	STDMETHOD(f234)();
	STDMETHOD(f235)();
	STDMETHOD(f236)();
	STDMETHOD(f237)();
	STDMETHOD(f238)();
	STDMETHOD(f239)();
	STDMETHOD(f240)();
	STDMETHOD(f241)();
	STDMETHOD(f242)();
	STDMETHOD(f243)();
	STDMETHOD(f244)();
	STDMETHOD(f245)();
	STDMETHOD(f246)();
	STDMETHOD(f247)();
	STDMETHOD(f248)();
	STDMETHOD(f249)();
	STDMETHOD(f250)();
	STDMETHOD(f251)();
	STDMETHOD(f252)();
	STDMETHOD(f253)();
	STDMETHOD(f254)();
	STDMETHOD(f255)();
	STDMETHOD(f256)();
	STDMETHOD(f257)();
	STDMETHOD(f258)();
	STDMETHOD(f259)();
	STDMETHOD(f260)();
	STDMETHOD(f261)();
	STDMETHOD(f262)();
	STDMETHOD(f263)();
	STDMETHOD(f264)();
	STDMETHOD(f265)();
	STDMETHOD(f266)();
	STDMETHOD(f267)();
	STDMETHOD(f268)();
	STDMETHOD(f269)();
	STDMETHOD(f270)();
	STDMETHOD(f271)();
	STDMETHOD(f272)();
	STDMETHOD(f273)();
	STDMETHOD(f274)();
	STDMETHOD(f275)();
	STDMETHOD(f276)();
	STDMETHOD(f277)();
	STDMETHOD(f278)();
	STDMETHOD(f279)();
	STDMETHOD(f280)();
	STDMETHOD(f281)();
	STDMETHOD(f282)();
	STDMETHOD(f283)();
	STDMETHOD(f284)();
	STDMETHOD(f285)();
	STDMETHOD(f286)();
	STDMETHOD(f287)();
	STDMETHOD(f288)();
	STDMETHOD(f289)();
	STDMETHOD(f290)();
	STDMETHOD(f291)();
	STDMETHOD(f292)();
	STDMETHOD(f293)();
	STDMETHOD(f294)();
	STDMETHOD(f295)();
	STDMETHOD(f296)();
	STDMETHOD(f297)();
	STDMETHOD(f298)();
	STDMETHOD(f299)();
	STDMETHOD(f300)();
	STDMETHOD(f301)();
	STDMETHOD(f302)();
	STDMETHOD(f303)();
	STDMETHOD(f304)();
	STDMETHOD(f305)();
	STDMETHOD(f306)();
	STDMETHOD(f307)();
	STDMETHOD(f308)();
	STDMETHOD(f309)();
	STDMETHOD(f310)();
	STDMETHOD(f311)();
	STDMETHOD(f312)();
	STDMETHOD(f313)();
	STDMETHOD(f314)();
	STDMETHOD(f315)();
	STDMETHOD(f316)();
	STDMETHOD(f317)();
	STDMETHOD(f318)();
	STDMETHOD(f319)();
	STDMETHOD(f320)();
	STDMETHOD(f321)();
	STDMETHOD(f322)();
	STDMETHOD(f323)();
	STDMETHOD(f324)();
	STDMETHOD(f325)();
	STDMETHOD(f326)();
	STDMETHOD(f327)();
	STDMETHOD(f328)();
	STDMETHOD(f329)();
	STDMETHOD(f330)();
	STDMETHOD(f331)();
	STDMETHOD(f332)();
	STDMETHOD(f333)();
	STDMETHOD(f334)();
	STDMETHOD(f335)();
	STDMETHOD(f336)();
	STDMETHOD(f337)();
	STDMETHOD(f338)();
	STDMETHOD(f339)();
	STDMETHOD(f340)();
	STDMETHOD(f341)();
	STDMETHOD(f342)();
	STDMETHOD(f343)();
	STDMETHOD(f344)();
	STDMETHOD(f345)();
	STDMETHOD(f346)();
	STDMETHOD(f347)();
	STDMETHOD(f348)();
	STDMETHOD(f349)();
	STDMETHOD(f350)();
	STDMETHOD(f351)();
	STDMETHOD(f352)();
	STDMETHOD(f353)();
	STDMETHOD(f354)();
	STDMETHOD(f355)();
	STDMETHOD(f356)();
	STDMETHOD(f357)();
	STDMETHOD(f358)();
	STDMETHOD(f359)();
	STDMETHOD(f360)();
	STDMETHOD(f361)();
	STDMETHOD(f362)();
	STDMETHOD(f363)();
	STDMETHOD(f364)();
	STDMETHOD(f365)();
	STDMETHOD(f366)();
	STDMETHOD(f367)();
	STDMETHOD(f368)();
	STDMETHOD(f369)();
	STDMETHOD(f370)();
	STDMETHOD(f371)();
	STDMETHOD(f372)();
	STDMETHOD(f373)();
	STDMETHOD(f374)();
	STDMETHOD(f375)();
	STDMETHOD(f376)();
	STDMETHOD(f377)();
	STDMETHOD(f378)();
	STDMETHOD(f379)();
	STDMETHOD(f380)();
	STDMETHOD(f381)();
	STDMETHOD(f382)();
	STDMETHOD(f383)();
	STDMETHOD(f384)();
	STDMETHOD(f385)();
	STDMETHOD(f386)();
	STDMETHOD(f387)();
	STDMETHOD(f388)();
	STDMETHOD(f389)();
	STDMETHOD(f390)();
	STDMETHOD(f391)();
	STDMETHOD(f392)();
	STDMETHOD(f393)();
	STDMETHOD(f394)();
	STDMETHOD(f395)();
	STDMETHOD(f396)();
	STDMETHOD(f397)();
	STDMETHOD(f398)();
	STDMETHOD(f399)();
	STDMETHOD(f400)();
	STDMETHOD(f401)();
	STDMETHOD(f402)();
	STDMETHOD(f403)();
	STDMETHOD(f404)();
	STDMETHOD(f405)();
	STDMETHOD(f406)();
	STDMETHOD(f407)();
	STDMETHOD(f408)();
	STDMETHOD(f409)();
	STDMETHOD(f410)();
	STDMETHOD(f411)();
	STDMETHOD(f412)();
	STDMETHOD(f413)();
	STDMETHOD(f414)();
	STDMETHOD(f415)();
	STDMETHOD(f416)();
	STDMETHOD(f417)();
	STDMETHOD(f418)();
	STDMETHOD(f419)();
	STDMETHOD(f420)();
	STDMETHOD(f421)();
	STDMETHOD(f422)();
	STDMETHOD(f423)();
	STDMETHOD(f424)();
	STDMETHOD(f425)();
	STDMETHOD(f426)();
	STDMETHOD(f427)();
	STDMETHOD(f428)();
	STDMETHOD(f429)();
	STDMETHOD(f430)();
	STDMETHOD(f431)();
	STDMETHOD(f432)();
	STDMETHOD(f433)();
	STDMETHOD(f434)();
	STDMETHOD(f435)();
	STDMETHOD(f436)();
	STDMETHOD(f437)();
	STDMETHOD(f438)();
	STDMETHOD(f439)();
	STDMETHOD(f440)();
	STDMETHOD(f441)();
	STDMETHOD(f442)();
	STDMETHOD(f443)();
	STDMETHOD(f444)();
	STDMETHOD(f445)();
	STDMETHOD(f446)();
	STDMETHOD(f447)();
	STDMETHOD(f448)();
	STDMETHOD(f449)();
	STDMETHOD(f450)();
	STDMETHOD(f451)();
	STDMETHOD(f452)();
	STDMETHOD(f453)();
	STDMETHOD(f454)();
	STDMETHOD(f455)();
	STDMETHOD(f456)();
	STDMETHOD(f457)();
	STDMETHOD(f458)();
	STDMETHOD(f459)();
	STDMETHOD(f460)();
	STDMETHOD(f461)();
	STDMETHOD(f462)();
	STDMETHOD(f463)();
	STDMETHOD(f464)();
	STDMETHOD(f465)();
	STDMETHOD(f466)();
	STDMETHOD(f467)();
	STDMETHOD(f468)();
	STDMETHOD(f469)();
	STDMETHOD(f470)();
	STDMETHOD(f471)();
	STDMETHOD(f472)();
	STDMETHOD(f473)();
	STDMETHOD(f474)();
	STDMETHOD(f475)();
	STDMETHOD(f476)();
	STDMETHOD(f477)();
	STDMETHOD(f478)();
	STDMETHOD(f479)();
	STDMETHOD(f480)();
	STDMETHOD(f481)();
	STDMETHOD(f482)();
	STDMETHOD(f483)();
	STDMETHOD(f484)();
	STDMETHOD(f485)();
	STDMETHOD(f486)();
	STDMETHOD(f487)();
	STDMETHOD(f488)();
	STDMETHOD(f489)();
	STDMETHOD(f490)();
	STDMETHOD(f491)();
	STDMETHOD(f492)();
	STDMETHOD(f493)();
	STDMETHOD(f494)();
	STDMETHOD(f495)();
	STDMETHOD(f496)();
	STDMETHOD(f497)();
	STDMETHOD(f498)();
	STDMETHOD(f499)();
	STDMETHOD(f500)();
	STDMETHOD(f501)();
	STDMETHOD(f502)();
	STDMETHOD(f503)();
	STDMETHOD(f504)();
	STDMETHOD(f505)();
	STDMETHOD(f506)();
	STDMETHOD(f507)();
	STDMETHOD(f508)();
	STDMETHOD(f509)();
	STDMETHOD(f510)();
	STDMETHOD(f511)();
	STDMETHOD(f512)();
	STDMETHOD(f513)();
	STDMETHOD(f514)();
	STDMETHOD(f515)();
	STDMETHOD(f516)();
	STDMETHOD(f517)();
	STDMETHOD(f518)();
	STDMETHOD(f519)();
	STDMETHOD(f520)();
	STDMETHOD(f521)();
	STDMETHOD(f522)();
	STDMETHOD(f523)();
	STDMETHOD(f524)();
	STDMETHOD(f525)();
	STDMETHOD(f526)();
	STDMETHOD(f527)();
	STDMETHOD(f528)();
	STDMETHOD(f529)();
	STDMETHOD(f530)();
	STDMETHOD(f531)();
	STDMETHOD(f532)();
	STDMETHOD(f533)();
	STDMETHOD(f534)();
	STDMETHOD(f535)();
	STDMETHOD(f536)();
	STDMETHOD(f537)();
	STDMETHOD(f538)();
	STDMETHOD(f539)();
	STDMETHOD(f540)();
	STDMETHOD(f541)();
	STDMETHOD(f542)();
	STDMETHOD(f543)();
	STDMETHOD(f544)();
	STDMETHOD(f545)();
	STDMETHOD(f546)();
	STDMETHOD(f547)();
	STDMETHOD(f548)();
	STDMETHOD(f549)();
	STDMETHOD(f550)();
	STDMETHOD(f551)();
	STDMETHOD(f552)();
	STDMETHOD(f553)();
	STDMETHOD(f554)();
	STDMETHOD(f555)();
	STDMETHOD(f556)();
	STDMETHOD(f557)();
	STDMETHOD(f558)();
	STDMETHOD(f559)();
	STDMETHOD(f560)();
	STDMETHOD(f561)();
	STDMETHOD(f562)();
	STDMETHOD(f563)();
	STDMETHOD(f564)();
	STDMETHOD(f565)();
	STDMETHOD(f566)();
	STDMETHOD(f567)();
	STDMETHOD(f568)();
	STDMETHOD(f569)();
	STDMETHOD(f570)();
	STDMETHOD(f571)();
	STDMETHOD(f572)();
	STDMETHOD(f573)();
	STDMETHOD(f574)();
	STDMETHOD(f575)();
	STDMETHOD(f576)();
	STDMETHOD(f577)();
	STDMETHOD(f578)();
	STDMETHOD(f579)();
	STDMETHOD(f580)();
	STDMETHOD(f581)();
	STDMETHOD(f582)();
	STDMETHOD(f583)();
	STDMETHOD(f584)();
	STDMETHOD(f585)();
	STDMETHOD(f586)();
	STDMETHOD(f587)();
	STDMETHOD(f588)();
	STDMETHOD(f589)();
	STDMETHOD(f590)();
	STDMETHOD(f591)();
	STDMETHOD(f592)();
	STDMETHOD(f593)();
	STDMETHOD(f594)();
	STDMETHOD(f595)();
	STDMETHOD(f596)();
	STDMETHOD(f597)();
	STDMETHOD(f598)();
	STDMETHOD(f599)();
	STDMETHOD(f600)();
	STDMETHOD(f601)();
	STDMETHOD(f602)();
	STDMETHOD(f603)();
	STDMETHOD(f604)();
	STDMETHOD(f605)();
	STDMETHOD(f606)();
	STDMETHOD(f607)();
	STDMETHOD(f608)();
	STDMETHOD(f609)();
	STDMETHOD(f610)();
	STDMETHOD(f611)();
	STDMETHOD(f612)();
	STDMETHOD(f613)();
	STDMETHOD(f614)();
	STDMETHOD(f615)();
	STDMETHOD(f616)();
	STDMETHOD(f617)();
	STDMETHOD(f618)();
	STDMETHOD(f619)();
	STDMETHOD(f620)();
	STDMETHOD(f621)();
	STDMETHOD(f622)();
	STDMETHOD(f623)();
	STDMETHOD(f624)();
	STDMETHOD(f625)();
	STDMETHOD(f626)();
	STDMETHOD(f627)();
	STDMETHOD(f628)();
	STDMETHOD(f629)();
	STDMETHOD(f630)();
	STDMETHOD(f631)();
	STDMETHOD(f632)();
	STDMETHOD(f633)();
	STDMETHOD(f634)();
	STDMETHOD(f635)();
	STDMETHOD(f636)();
	STDMETHOD(f637)();
	STDMETHOD(f638)();
	STDMETHOD(f639)();
	STDMETHOD(f640)();
	STDMETHOD(f641)();
	STDMETHOD(f642)();
	STDMETHOD(f643)();
	STDMETHOD(f644)();
	STDMETHOD(f645)();
	STDMETHOD(f646)();
	STDMETHOD(f647)();
	STDMETHOD(f648)();
	STDMETHOD(f649)();
	STDMETHOD(f650)();
	STDMETHOD(f651)();
	STDMETHOD(f652)();
	STDMETHOD(f653)();
	STDMETHOD(f654)();
	STDMETHOD(f655)();
	STDMETHOD(f656)();
	STDMETHOD(f657)();
	STDMETHOD(f658)();
	STDMETHOD(f659)();
	STDMETHOD(f660)();
	STDMETHOD(f661)();
	STDMETHOD(f662)();
	STDMETHOD(f663)();
	STDMETHOD(f664)();
	STDMETHOD(f665)();
	STDMETHOD(f666)();
	STDMETHOD(f667)();
	STDMETHOD(f668)();
	STDMETHOD(f669)();
	STDMETHOD(f670)();
	STDMETHOD(f671)();
	STDMETHOD(f672)();
	STDMETHOD(f673)();
	STDMETHOD(f674)();
	STDMETHOD(f675)();
	STDMETHOD(f676)();
	STDMETHOD(f677)();
	STDMETHOD(f678)();
	STDMETHOD(f679)();
	STDMETHOD(f680)();
	STDMETHOD(f681)();
	STDMETHOD(f682)();
	STDMETHOD(f683)();
	STDMETHOD(f684)();
	STDMETHOD(f685)();
	STDMETHOD(f686)();
	STDMETHOD(f687)();
	STDMETHOD(f688)();
	STDMETHOD(f689)();
	STDMETHOD(f690)();
	STDMETHOD(f691)();
	STDMETHOD(f692)();
	STDMETHOD(f693)();
	STDMETHOD(f694)();
	STDMETHOD(f695)();
	STDMETHOD(f696)();
	STDMETHOD(f697)();
	STDMETHOD(f698)();
	STDMETHOD(f699)();
	STDMETHOD(f700)();
	STDMETHOD(f701)();
	STDMETHOD(f702)();
	STDMETHOD(f703)();
	STDMETHOD(f704)();
	STDMETHOD(f705)();
	STDMETHOD(f706)();
	STDMETHOD(f707)();
	STDMETHOD(f708)();
	STDMETHOD(f709)();
	STDMETHOD(f710)();
	STDMETHOD(f711)();
	STDMETHOD(f712)();
	STDMETHOD(f713)();
	STDMETHOD(f714)();
	STDMETHOD(f715)();
	STDMETHOD(f716)();
	STDMETHOD(f717)();
	STDMETHOD(f718)();
	STDMETHOD(f719)();
	STDMETHOD(f720)();
	STDMETHOD(f721)();
	STDMETHOD(f722)();
	STDMETHOD(f723)();
	STDMETHOD(f724)();
	STDMETHOD(f725)();
	STDMETHOD(f726)();
	STDMETHOD(f727)();
	STDMETHOD(f728)();
	STDMETHOD(f729)();
	STDMETHOD(f730)();
	STDMETHOD(f731)();
	STDMETHOD(f732)();
	STDMETHOD(f733)();
	STDMETHOD(f734)();
	STDMETHOD(f735)();
	STDMETHOD(f736)();
	STDMETHOD(f737)();
	STDMETHOD(f738)();
	STDMETHOD(f739)();
	STDMETHOD(f740)();
	STDMETHOD(f741)();
	STDMETHOD(f742)();
	STDMETHOD(f743)();
	STDMETHOD(f744)();
	STDMETHOD(f745)();
	STDMETHOD(f746)();
	STDMETHOD(f747)();
	STDMETHOD(f748)();
	STDMETHOD(f749)();
	STDMETHOD(f750)();
	STDMETHOD(f751)();
	STDMETHOD(f752)();
	STDMETHOD(f753)();
	STDMETHOD(f754)();
	STDMETHOD(f755)();
	STDMETHOD(f756)();
	STDMETHOD(f757)();
	STDMETHOD(f758)();
	STDMETHOD(f759)();
	STDMETHOD(f760)();
	STDMETHOD(f761)();
	STDMETHOD(f762)();
	STDMETHOD(f763)();
	STDMETHOD(f764)();
	STDMETHOD(f765)();
	STDMETHOD(f766)();
	STDMETHOD(f767)();
	STDMETHOD(f768)();
	STDMETHOD(f769)();
	STDMETHOD(f770)();
	STDMETHOD(f771)();
	STDMETHOD(f772)();
	STDMETHOD(f773)();
	STDMETHOD(f774)();
	STDMETHOD(f775)();
	STDMETHOD(f776)();
	STDMETHOD(f777)();
	STDMETHOD(f778)();
	STDMETHOD(f779)();
	STDMETHOD(f780)();
	STDMETHOD(f781)();
	STDMETHOD(f782)();
	STDMETHOD(f783)();
	STDMETHOD(f784)();
	STDMETHOD(f785)();
	STDMETHOD(f786)();
	STDMETHOD(f787)();
	STDMETHOD(f788)();
	STDMETHOD(f789)();
	STDMETHOD(f790)();
	STDMETHOD(f791)();
	STDMETHOD(f792)();
	STDMETHOD(f793)();
	STDMETHOD(f794)();
	STDMETHOD(f795)();
	STDMETHOD(f796)();
	STDMETHOD(f797)();
	STDMETHOD(f798)();
	STDMETHOD(f799)();
	STDMETHOD(f800)();
	STDMETHOD(f801)();
	STDMETHOD(f802)();
	STDMETHOD(f803)();
	STDMETHOD(f804)();
	STDMETHOD(f805)();
	STDMETHOD(f806)();
	STDMETHOD(f807)();
	STDMETHOD(f808)();
	STDMETHOD(f809)();
	STDMETHOD(f810)();
	STDMETHOD(f811)();
	STDMETHOD(f812)();
	STDMETHOD(f813)();
	STDMETHOD(f814)();
	STDMETHOD(f815)();
	STDMETHOD(f816)();
	STDMETHOD(f817)();
	STDMETHOD(f818)();
	STDMETHOD(f819)();
	STDMETHOD(f820)();
	STDMETHOD(f821)();
	STDMETHOD(f822)();
	STDMETHOD(f823)();
	STDMETHOD(f824)();
	STDMETHOD(f825)();
	STDMETHOD(f826)();
	STDMETHOD(f827)();
	STDMETHOD(f828)();
	STDMETHOD(f829)();
	STDMETHOD(f830)();
	STDMETHOD(f831)();
	STDMETHOD(f832)();
	STDMETHOD(f833)();
	STDMETHOD(f834)();
	STDMETHOD(f835)();
	STDMETHOD(f836)();
	STDMETHOD(f837)();
	STDMETHOD(f838)();
	STDMETHOD(f839)();
	STDMETHOD(f840)();
	STDMETHOD(f841)();
	STDMETHOD(f842)();
	STDMETHOD(f843)();
	STDMETHOD(f844)();
	STDMETHOD(f845)();
	STDMETHOD(f846)();
	STDMETHOD(f847)();
	STDMETHOD(f848)();
	STDMETHOD(f849)();
	STDMETHOD(f850)();
	STDMETHOD(f851)();
	STDMETHOD(f852)();
	STDMETHOD(f853)();
	STDMETHOD(f854)();
	STDMETHOD(f855)();
	STDMETHOD(f856)();
	STDMETHOD(f857)();
	STDMETHOD(f858)();
	STDMETHOD(f859)();
	STDMETHOD(f860)();
	STDMETHOD(f861)();
	STDMETHOD(f862)();
	STDMETHOD(f863)();
	STDMETHOD(f864)();
	STDMETHOD(f865)();
	STDMETHOD(f866)();
	STDMETHOD(f867)();
	STDMETHOD(f868)();
	STDMETHOD(f869)();
	STDMETHOD(f870)();
	STDMETHOD(f871)();
	STDMETHOD(f872)();
	STDMETHOD(f873)();
	STDMETHOD(f874)();
	STDMETHOD(f875)();
	STDMETHOD(f876)();
	STDMETHOD(f877)();
	STDMETHOD(f878)();
	STDMETHOD(f879)();
	STDMETHOD(f880)();
	STDMETHOD(f881)();
	STDMETHOD(f882)();
	STDMETHOD(f883)();
	STDMETHOD(f884)();
	STDMETHOD(f885)();
	STDMETHOD(f886)();
	STDMETHOD(f887)();
	STDMETHOD(f888)();
	STDMETHOD(f889)();
	STDMETHOD(f890)();
	STDMETHOD(f891)();
	STDMETHOD(f892)();
	STDMETHOD(f893)();
	STDMETHOD(f894)();
	STDMETHOD(f895)();
	STDMETHOD(f896)();
	STDMETHOD(f897)();
	STDMETHOD(f898)();
	STDMETHOD(f899)();
	STDMETHOD(f900)();
	STDMETHOD(f901)();
	STDMETHOD(f902)();
	STDMETHOD(f903)();
	STDMETHOD(f904)();
	STDMETHOD(f905)();
	STDMETHOD(f906)();
	STDMETHOD(f907)();
	STDMETHOD(f908)();
	STDMETHOD(f909)();
	STDMETHOD(f910)();
	STDMETHOD(f911)();
	STDMETHOD(f912)();
	STDMETHOD(f913)();
	STDMETHOD(f914)();
	STDMETHOD(f915)();
	STDMETHOD(f916)();
	STDMETHOD(f917)();
	STDMETHOD(f918)();
	STDMETHOD(f919)();
	STDMETHOD(f920)();
	STDMETHOD(f921)();
	STDMETHOD(f922)();
	STDMETHOD(f923)();
	STDMETHOD(f924)();
	STDMETHOD(f925)();
	STDMETHOD(f926)();
	STDMETHOD(f927)();
	STDMETHOD(f928)();
	STDMETHOD(f929)();
	STDMETHOD(f930)();
	STDMETHOD(f931)();
	STDMETHOD(f932)();
	STDMETHOD(f933)();
	STDMETHOD(f934)();
	STDMETHOD(f935)();
	STDMETHOD(f936)();
	STDMETHOD(f937)();
	STDMETHOD(f938)();
	STDMETHOD(f939)();
	STDMETHOD(f940)();
	STDMETHOD(f941)();
	STDMETHOD(f942)();
	STDMETHOD(f943)();
	STDMETHOD(f944)();
	STDMETHOD(f945)();
	STDMETHOD(f946)();
	STDMETHOD(f947)();
	STDMETHOD(f948)();
	STDMETHOD(f949)();
	STDMETHOD(f950)();
	STDMETHOD(f951)();
	STDMETHOD(f952)();
	STDMETHOD(f953)();
	STDMETHOD(f954)();
	STDMETHOD(f955)();
	STDMETHOD(f956)();
	STDMETHOD(f957)();
	STDMETHOD(f958)();
	STDMETHOD(f959)();
	STDMETHOD(f960)();
	STDMETHOD(f961)();
	STDMETHOD(f962)();
	STDMETHOD(f963)();
	STDMETHOD(f964)();
	STDMETHOD(f965)();
	STDMETHOD(f966)();
	STDMETHOD(f967)();
	STDMETHOD(f968)();
	STDMETHOD(f969)();
	STDMETHOD(f970)();
	STDMETHOD(f971)();
	STDMETHOD(f972)();
	STDMETHOD(f973)();
	STDMETHOD(f974)();
	STDMETHOD(f975)();
	STDMETHOD(f976)();
	STDMETHOD(f977)();
	STDMETHOD(f978)();
	STDMETHOD(f979)();
	STDMETHOD(f980)();
	STDMETHOD(f981)();
	STDMETHOD(f982)();
	STDMETHOD(f983)();
	STDMETHOD(f984)();
	STDMETHOD(f985)();
	STDMETHOD(f986)();
	STDMETHOD(f987)();
	STDMETHOD(f988)();
	STDMETHOD(f989)();
	STDMETHOD(f990)();
	STDMETHOD(f991)();
	STDMETHOD(f992)();
	STDMETHOD(f993)();
	STDMETHOD(f994)();
	STDMETHOD(f995)();
	STDMETHOD(f996)();
	STDMETHOD(f997)();
	STDMETHOD(f998)();
	STDMETHOD(f999)();
	STDMETHOD(f1000)();
	STDMETHOD(f1001)();
	STDMETHOD(f1002)();
	STDMETHOD(f1003)();
	STDMETHOD(f1004)();
	STDMETHOD(f1005)();
	STDMETHOD(f1006)();
	STDMETHOD(f1007)();
	STDMETHOD(f1008)();
	STDMETHOD(f1009)();
	STDMETHOD(f1010)();
	STDMETHOD(f1011)();
	STDMETHOD(f1012)();
	STDMETHOD(f1013)();
	STDMETHOD(f1014)();
	STDMETHOD(f1015)();
	STDMETHOD(f1016)();
	STDMETHOD(f1017)();
	STDMETHOD(f1018)();
	STDMETHOD(f1019)();
	STDMETHOD(f1020)();
	STDMETHOD(f1021)();
	STDMETHOD(f1022)();
	STDMETHOD(f1023)();
	STDMETHOD(f1024)();
	_QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
	{
		lpszClassName = p;
		iid = i;
		nIndex = n;
		m_dwRef = 0;
		m_dwMaxRef = 0;
		pUnk = pOrig;
		bBreak = b;
		bNonAddRefThunk = false;
	}
	IUnknown* pUnk;
	long m_dwRef;
	long m_dwMaxRef;
	LPCTSTR lpszClassName;
	IID iid;
	UINT nIndex;
	bool bBreak;
	bool bNonAddRefThunk;
	void Dump()
	{
		TCHAR buf[256];
		if (m_dwRef != 0)
		{
			wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
			OutputDebugString(buf);
			AtlDumpIID(iid, lpszClassName, S_OK);
		}
		else
		{
			wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
			OutputDebugString(buf);
		}
	}
};
#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
		{
#if (_WIN32_WCE == 200)
			if(m_aT[nIndex] != NULL)
				delete m_aT[nIndex];
#else // _WIN32_WCE
			m_aT[nIndex].~T();
#endif // _WIN32_WCE
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		}
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
#if (_WIN32_WCE == 200)
				if(m_aT[i] != NULL)
					delete m_aT[i];
#else // _WIN32_WCE
				m_aT[i].~T();
#endif // _WIN32_WCE
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(&m_aT[nIndex]) Wrapper(t);
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
	BOOL Add(T t)
	{
		return CSimpleArray< T >::Add(t);
	}
	BOOL Remove(T t)
	{
		return CSimpleArray< T >::Remove(t);
	}
	T operator[] (int nIndex) const
	{
		return CSimpleArray< T >::operator[](nIndex);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
#if (_WIN32_WCE == 200)
			if(m_aKey[nIndex] != NULL)
				delete m_aKey[nIndex];
			if(m_aVal[nIndex] != NULL)
				delete m_aVal[nIndex];
#else // _WIN32_WCE
			m_aKey[nIndex].~TKey();
			m_aVal[nIndex].~TVal();
#endif // _WIN32_WCE
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
#if (_WIN32_WCE == 200)
			if(m_aKey[i] != NULL)
				delete m_aKey[nIndex];
			if(m_aVal[i] != NULL)
				delete m_aVal[nIndex];
#else // _WIN32_WCE
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
#endif // _WIN32_WCE
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <typename _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(&m_aKey[nIndex]) Wrapper<TKey>(key);
		new(&m_aVal[nIndex]) Wrapper<TVal>(val);
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
	static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
	UINT m_nIndexQI;
	UINT m_nIndexBreakAt;
	CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

	void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
	{
		AtlModuleAddCreateWndData(this, pData, pObject);
	}
	void* ExtractCreateWndData()
	{
		return AtlModuleExtractCreateWndData(this);
	}

	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
	{
		pguidVer = &GUID_ATLVer30;
		_pModule = this;
		cbSize = sizeof(_ATL_MODULE);
		dwAtlBuildVer = _ATL_VER;
		AtlModuleInit(this, p, h);
		if (plibid != NULL)
			memcpy((void*)&m_libid, plibid, sizeof(GUID));
#ifdef _ATL_MIN_CRT
		// Create a base heap
		m_hHeap = HeapCreate(0, 0, 0);

#ifndef _ATL_NO_MP_HEAP
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		if (si.dwNumberOfProcessors > 1)
		{
			DWORD dwHeaps = si.dwNumberOfProcessors * 2;
			m_dwHeaps = 0xFFFFFFFF;
			for (int bits=0; bits<32; bits++)
			{
				if (dwHeaps & 0x80000000)
					break;
				dwHeaps <<= 1;
				m_dwHeaps >>= 1;
			}
			m_dwHeaps >>= 1;

			// Allocate more heaps for each processor
			m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
			for (DWORD i=0; i<=m_dwHeaps; i++)
				m_phHeaps[i] = HeapCreate(0, 0, 0);
		}
		else
#endif
		{
			m_phHeaps = NULL;
			m_dwHeaps = 0;
		}
#endif
#ifdef _ATL_DEBUG_INTERFACES
		m_nIndexQI = 0;
		m_nIndexBreakAt = 0;
		m_paThunks = NULL;
		ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
		if (m_paThunks == NULL)
			return E_OUTOFMEMORY;
#endif // _ATL_DEBUG_INTERFACES
		return S_OK;
	}
#ifdef _ATL_DEBUG_INTERFACES
	HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
	{
		if ((pp == NULL) || (*pp == NULL))
			return E_POINTER;
		IUnknown* p = *pp;
		_QIThunk* pThunk = NULL;
		EnterCriticalSection(&m_csObjMap);
		// Check if exists already for identity
		if (InlineIsEqualUnknown(iid))
		{
			for (int i=0; i<m_paThunks->GetSize(); i++)
			{
				if (m_paThunks->operator[](i)->pUnk == p)
				{
					m_paThunks->operator[](i)->InternalAddRef();
					pThunk = m_paThunks->operator[](i);
					break;
				}
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
				return E_OUTOFMEMORY;
			pThunk->InternalAddRef();
			m_paThunks->Add(pThunk);
		}
		LeaveCriticalSection(&m_csObjMap);
		*pp = (IUnknown*)pThunk;
		return S_OK;
	}
	HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
	{
		_QIThunk* pThunk = NULL;
		EnterCriticalSection(&m_csObjMap);
		// Check if exists already for identity
		for (int i=0; i<m_paThunks->GetSize(); i++)
		{
			if (m_paThunks->operator[](i)->pUnk == p)
			{
				m_paThunks->operator[](i)->bNonAddRefThunk = true;
				pThunk = m_paThunks->operator[](i);
				break;
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
			{
				*ppThunkRet = NULL;
				return E_OUTOFMEMORY;
			}
			pThunk->bNonAddRefThunk = true;
			m_paThunks->Add(pThunk);
		}
		LeaveCriticalSection(&m_csObjMap);
		*ppThunkRet = (IUnknown*)pThunk;
		return S_OK;;
	}
	void DeleteNonAddRefThunk(IUnknown* pUnk)
	{
		EnterCriticalSection(&m_csObjMap);
		for (int i=0; i<m_paThunks->GetSize(); i++)
		{
			if (m_paThunks->operator[](i)->pUnk == pUnk)
			{
				delete m_paThunks->operator[](i);
				m_paThunks->RemoveAt(i);
				break;
			}
		}
		LeaveCriticalSection(&m_csObjMap);
	}
	void DeleteThunk(_QIThunk* p)
	{
		EnterCriticalSection(&m_csObjMap);
		int nIndex = m_paThunks->Find(p);
		if (nIndex != -1)
		{
			delete m_paThunks->operator[](nIndex);
			m_paThunks->RemoveAt(nIndex);
		}
		LeaveCriticalSection(&m_csObjMap);
	}
	bool DumpLeakedThunks()
	{
		bool b = false;
		for (int i=0; i<m_paThunks->GetSize(); i++)
		{
			b = true;
			m_paThunks->operator[](i)->Dump();
			delete m_paThunks->operator[](i);
		}
		m_paThunks->RemoveAll();
		return b;
	}
#endif // _ATL_DEBUG_INTERFACES
	void Term()
	{
#ifdef _ATL_DEBUG_INTERFACES
		m_bDestroyHeap = false; // prevent heap from going away
		AtlModuleTerm(this);
		DumpLeakedThunks();
		delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
		if (m_phHeaps != NULL)
		{
			for (DWORD i = 0; i <= m_dwHeaps; i++)
				HeapDestroy(m_phHeaps[i]);
		}
#endif
		if (m_hHeap != NULL)
			HeapDestroy(m_hHeap);
#else
		AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
	}

	HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD dw)
	{
		return AtlModuleAddTermFunc(this, pFunc, dw);
	}

	LONG Lock()
	{
		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
	}
	LONG Unlock()
	{
		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount()
	{
		return m_nLockCnt;
	}

	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInstResource;}
	HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

	// Registry support (helpers)
	HRESULT RegisterTypeLib()
	{
		return AtlModuleRegisterTypeLib(this, NULL);
	}
	HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION;
		return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex));
	}
	HRESULT UnRegisterTypeLib()
	{
		return AtlModuleUnRegisterTypeLib(this, NULL);
	}
	HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION;
		return AtlModuleUnRegisterTypeLib(this, T2COLE(lpszIndex));
	}
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
	{
		return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
	}

	HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServer(this, pCLSID);
	}
	HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
	}

	// Resource-based Registration
	HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		USES_CONVERSION;
		return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister,
			pMapEntries);
	}
	HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		return AtlModuleUpdateRegistryFromResourceD(this,
			(LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
	}

#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

	// Standard Registration
	HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
	HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
	HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID);

	// Register/Revoke All Class Factories with the OS (EXE only)
#if !defined(_WIN32_WCE)
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
	{
		return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
	}
	HRESULT RevokeClassObjects()
	{
		return AtlModuleRevokeClassObjects(this);
	}
#endif // _WIN32_WCE

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
	{
		return AtlModuleGetClassObject(this, rclsid, riid, ppv);
	}

	// Only used in CComAutoThreadModule
	HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
	{
		ATLASSERT(FALSE);
		return E_NOTIMPL;
	}
	static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

	static void ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
	{
		while (*lp)
		{
			*lpDest++ = *lp;
			if (*lp == OLESTR('\''))
				*lpDest++ = *lp;
			lp++;
		}
		*lpDest = NULL;
	}
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
	if (bBreak)
		DebugBreak();
	ATLASSERT(m_dwRef > 0);
	ULONG l = InterlockedDecrement(&m_dwRef);
	ATLTRACE(_T("%d< "), m_dwRef);
	AtlDumpIID(iid, lpszClassName, S_OK);
	pUnk->Release();
	if (l == 0 && !bNonAddRefThunk)
		_pModule->DeleteThunk(this);
	return l;
}
inline static void atlBadThunkCall()
{
	ATLASSERT(FALSE && "Call through deleted thunk");
}
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
	__asm mov eax, [esp+4]\
	__asm cmp dword ptr [eax+8], 0\
	__asm jg goodref\
	__asm call atlBadThunkCall\
	__asm goodref:\
	__asm mov eax, [esp+4]\
	__asm mov eax, dword ptr [eax+4]\
	__asm mov [esp+4], eax\
	__asm mov eax, dword ptr [eax]\
	__asm mov eax, dword ptr [eax+4*n]\
	__asm jmp eax\
}

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
	_ATL_CREATORFUNC* pfnCreateInstance;
	const IID* piid;
	HANDLE hEvent;
	LPSTREAM pStream;
	HRESULT hRes;
};

class CComApartment
{
public:
	CComApartment()
	{
		m_nLockCnt = 0;
	}
	static UINT ATL_CREATE_OBJECT;
	static DWORD WINAPI _Apartment(void* pv)
	{
		return ((CComApartment*)pv)->Apartment();
	}
	DWORD Apartment()
	{
#if !defined(_WIN32_WCE)
		CoInitialize(NULL);
		MSG msg;
		while(GetMessage(&msg, 0, 0, 0))
		{
			if (msg.message == ATL_CREATE_OBJECT)
			{
				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
				IUnknown* pUnk = NULL;
				pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
				if (SUCCEEDED(pdata->hRes))
					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
				if (SUCCEEDED(pdata->hRes))
				{
					pUnk->Release();
					ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
				}
				SetEvent(pdata->hEvent);
			}
			DispatchMessage(&msg);
		}
		CoUninitialize();
#endif // _WIN32_WCE
		return 0;
	}
	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount() {return m_nLockCnt;}

	DWORD m_dwThreadID;
	HANDLE m_hThread;
	LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
	CComSimpleThreadAllocator()
	{
		m_nThread = 0;
	}
	int GetThread(CComApartment* /*pApt*/, int nThreads)
	{
		if (++m_nThread == nThreads)
			m_nThread = 0;
		return m_nThread;
	}
	int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
	~CComAutoThreadModule();
	HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
	LONG Lock();
	LONG Unlock();
	DWORD dwThreadID;
	int m_nThreads;
	CComApartment* m_pApartments;
	ThreadAllocator m_Allocator;
	static int GetDefaultThreads()
	{
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		return si.dwNumberOfProcessors * 4;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	/*explicit*/ CComBSTR(int nSize)
	{
		m_str = ::SysAllocStringLen(NULL, nSize);
	}
	/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	/*explicit*/ CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	/*explicit*/ CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	/*explicit*/ CComBSTR(REFGUID src)
	{
		LPOLESTR szGuid;
		StringFromCLSID(src, &szGuid);
		m_str = ::SysAllocString(szGuid);
		CoTaskMemFree(szGuid);
	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			if (m_str)
				::SysFreeString(m_str);
			m_str = src.Copy();
		}
		return *this;
	}

	CComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = ::SysAllocString(pSrc);
		return *this;
	}

	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	HRESULT CopyTo(BSTR* pbstr)
	{
		ATLASSERT(pbstr != NULL);
		if (pbstr == NULL)
			return E_POINTER;
		*pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
		if (*pbstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}
	void Attach(BSTR src)
	{
		ATLASSERT(m_str == NULL);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const
	{
		return (m_str == NULL);
	}
	HRESULT Append(const CComBSTR& bstrSrc)
	{
		return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
	}
	HRESULT Append(LPCOLESTR lpsz)
	{
		return Append(lpsz, ocslen(lpsz));
	}
	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p)
	{
		return Append(p, SysStringLen(p));
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen)
	{
		int n1 = Length();
		BSTR b;
		b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
			return E_OUTOFMEMORY;
		memcpy(b, m_str, n1*sizeof(OLECHAR));
		memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}
	HRESULT ToLower()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharLower(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	HRESULT ToUpper()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharUpper(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	bool LoadString(HINSTANCE hInst, UINT nID)
	{
		USES_CONVERSION;
		TCHAR sz[512];
		UINT nLen = ::LoadString(hInst, nID, sz, 512);
		ATLASSERT(nLen < 511);
		SysFreeString(m_str);
		m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
		return (nLen != 0);
	}
	bool LoadString(UINT nID)
	{
		return LoadString(_pModule->m_hInstResource, nID);
	}

	CComBSTR& operator+=(const CComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
	bool operator<(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return false;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) < 0;
		return m_str == NULL;
	}
	bool operator==(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return true;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) == 0;
		return false; 
	}
	bool operator<(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return false;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) < 0;
		return m_str == NULL;
	}
	bool operator==(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return true;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) == 0;
		return false; 
	}
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc)
	{
		m_str = A2WBSTR(pSrc);
	}

	CComBSTR(int nSize, LPCSTR sz)
	{
		m_str = A2WBSTR(sz, nSize);
	}

	void Append(LPCSTR lpsz)
	{
		USES_CONVERSION;
		LPCOLESTR lpo = A2COLE(lpsz);
		Append(lpo, ocslen(lpo));
	}

	CComBSTR& operator=(LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		return *this;
	}
#endif
	HRESULT WriteToStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ULONG cb;
		ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
			return hr;
		return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
	}
	HRESULT ReadFromStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ATLASSERT(m_str == NULL); // should be empty
		ULONG cbStrLen = 0;
		HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
		if ((hr == S_OK) && (cbStrLen != 0))
		{
			//subtract size for terminating NULL which we wrote out
			//since SysAllocStringByteLen overallocates for the NULL
			m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
			if (m_str == NULL)
				hr = E_OUTOFMEMORY;
			else
				hr = pStream->Read((void*) m_str, cbStrLen, NULL);
		}
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant()
	{
		vt = VT_EMPTY;
	}
	~CComVariant()
	{
		Clear();
	}

	CComVariant(const VARIANT& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(const CComVariant& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(BSTR bstrSrc)
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	CComVariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

#ifndef OLE2ANSI
	CComVariant(LPCSTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
#endif

	CComVariant(bool bSrc)
	{
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}

	CComVariant(int nSrc)
	{
		vt = VT_I4;
		lVal = nSrc;
	}
	CComVariant(BYTE nSrc)
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(short nSrc)
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		vt = vtSrc;
		lVal = nSrc;
	}
	CComVariant(float fltSrc)
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(double dblSrc)
	{
		vt = VT_R8;
		dblVal = dblSrc;
	}
	CComVariant(CY cySrc)
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(IDispatch* pSrc)
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(IUnknown* pSrc)
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	CComVariant& operator=(const CComVariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(BSTR bstrSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(bstrSrc);
		if (bstrVal == NULL && bstrSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	CComVariant& operator=(LPCOLESTR lpszSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpszSrc)
	{
		USES_CONVERSION;
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE(lpszSrc));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}
	#endif

	CComVariant& operator=(bool bSrc)
	{
		if (vt != VT_BOOL)
		{
			InternalClear();
			vt = VT_BOOL;
		}
	#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
	#pragma warning(default: 4310) // cast truncates constant value
		return *this;
	}

	CComVariant& operator=(int nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;

		return *this;
	}

	CComVariant& operator=(BYTE nSrc)
	{
		if (vt != VT_UI1)
		{
			InternalClear();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	CComVariant& operator=(short nSrc)
	{
		if (vt != VT_I2)
		{
			InternalClear();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	CComVariant& operator=(long nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(float fltSrc)
	{
		if (vt != VT_R4)
		{
			InternalClear();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	CComVariant& operator=(double dblSrc)
	{
		if (vt != VT_R8)
		{
			InternalClear();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	CComVariant& operator=(CY cySrc)
	{
		if (vt != VT_CY)
		{
			InternalClear();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	CComVariant& operator=(IDispatch* pSrc)
	{
		InternalClear();
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	CComVariant& operator=(IUnknown* pSrc)
	{
		InternalClear();
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}


// Comparison Operators
public:
	bool operator==(const VARIANT& varSrc) const
	{
		if (this == &varSrc)
			return true;

		// Variants not equal if types don't match
		if (vt != varSrc.vt)
			return false;

		// Check type specific values
		switch (vt)
		{
			case VT_EMPTY:
			case VT_NULL:
				return true;

			case VT_BOOL:
				return boolVal == varSrc.boolVal;

			case VT_UI1:
				return bVal == varSrc.bVal;

			case VT_I2:
				return iVal == varSrc.iVal;

			case VT_I4:
				return lVal == varSrc.lVal;

			case VT_R4:
				return fltVal == varSrc.fltVal;

			case VT_R8:
				return dblVal == varSrc.dblVal;

			case VT_BSTR:
				return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
						(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

			case VT_ERROR:
				return scode == varSrc.scode;

			case VT_DISPATCH:
				return pdispVal == varSrc.pdispVal;

			case VT_UNKNOWN:
				return punkVal == varSrc.punkVal;

			default:
				ATLASSERT(false);
				// fall through
		}

		return false;
	}
	bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
WCE_DEL bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_LT;}
WCE_DEL bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_GT;}

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc)
	{
		// Clear out the variant
		HRESULT hr = Clear();
		if (!FAILED(hr))
		{
			// Copy the contents and give control to CComVariant
			memcpy(this, pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(VARIANT* pDest)
	{
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from CComVariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
		return hr;
	}

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return WCE_FCTN(OleSaveToStream)(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	ATLASSERT(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (hr == S_FALSE)
		hr = E_FAIL;
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = WCE_FCTN(OleLoadFromStream)(pStream, (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch, (void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
	{
		hr = pStream->Read((void*) &bVal, cbRead, NULL);
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	LONG Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	LONG DeleteSubKey(LPCTSTR lpszSubKey);
	LONG RecurseDeleteKey(LPCTSTR lpszKey);
	LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	ATLASSERT(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	ATLASSERT(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	ATLASSERT(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		ATLASSERT(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	ATLASSERT(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	ATLASSERT(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	ATLASSERT(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	ATL::CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
	WCE_DEL TCHAR szModuleShort[_MAX_PATH];
	WCE_DEL GetShortPathName(szModule, szModuleShort, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(WCE_IF(szModule, szModuleShort));

	int nLen = ocslen(pszModule);
	LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
	ReplaceSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
			ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	ATL::CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
	WCE_DEL TCHAR szModuleShort[_MAX_PATH];
	WCE_DEL GetShortPathName(szModule, szModuleShort, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(WCE_IF(szModule,szModuleShort));

	int nLen = ocslen(pszModule);
	LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
	ReplaceSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	LPCOLESTR pszRes = T2COLE(lpszRes);
	return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
			ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

	hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

#if !defined(_WIN32_WCE)
// WinCE: No out-of-proc servers.
				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
				{
					// Convert to short path to work around bug in NT4's CreateProcess
					TCHAR szModuleShort[_MAX_PATH];
					GetShortPathName(szModule, szModuleShort, _MAX_PATH);
					key.SetKeyValue(szLS32, szModuleShort);
				}
				else
#endif // _WIN32_WCE
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;

	key.Attach(HKEY_CLASSES_ROOT);
	if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
		key.RecurseDeleteKey(lpszProgID);
	if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
		key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID"), KEY_READ) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
	virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
	CVirtualBuffer() {}
	T* m_pBase;
	T* m_pCurrent;
	T* m_pTop;
	int m_nMaxElements;
public:
	CVirtualBuffer(int nMaxElements)
	{
		m_nMaxElements = nMaxElements;
		m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
			MEM_RESERVE, PAGE_READWRITE);
		m_pTop = m_pCurrent = m_pBase;
		// Commit first page - chances are this is all that will be used
		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
	}
	~CVirtualBuffer()
	{
		VirtualFree(m_pBase, 0, MEM_RELEASE);
	}
#if !defined(_WIN32_WCE)
	int Except(LPEXCEPTION_POINTERS lpEP)
	{
		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
			return EXCEPTION_CONTINUE_SEARCH;
		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
		VirtualAlloc(pAddress, ((BYTE*)m_pTop - (BYTE*)m_pBase), MEM_COMMIT, PAGE_READWRITE);
		return EXCEPTION_CONTINUE_EXECUTION;
	}
#endif // _WIN32_WCE
	void Seek(int nElement)
	{
		m_pCurrent = &m_pBase[nElement];
	}
	void SetAt(int nElement, const T& Element)
	{
		__try
		{
			T* p = &m_pBase[nElement]
			*p = Element;
			m_pTop = p > m_pTop ? p : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}

	}
	template <class Q>
	void WriteBulk(Q& helper)
	{
		__try
		{
			m_pCurrent = helper(m_pBase);
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	void Write(const T& Element)
	{
		__try
		{
			*m_pCurrent = Element;
			m_pCurrent++;
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	T& Read()
	{
		return *m_pCurrent;
	}
	operator BSTR()
	{
		BSTR bstrTemp;
		__try
		{
			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
		}
		__except(Except(GetExceptionInformation()))
		{
		}
		return bstrTemp;
	}
	const T& operator[](int nElement) const
	{
		return m_pBase[nElement];
	}
	operator T*()
	{
		return m_pBase;
	}
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	if (atlTraceQI & ATL_TRACE_CATEGORY)
	{
		USES_CONVERSION;
		CRegKey key;
		TCHAR szName[100];
		DWORD dwType,dw = sizeof(szName);

		LPOLESTR pszGUID = NULL;
		StringFromCLSID(iid, &pszGUID);
		OutputDebugString(pszClassName);
		OutputDebugString(_T(" - "));

		// Attempt to find it in the interfaces section
		key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
		if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
		{
			*szName = 0;
			RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
			OutputDebugString(szName);
			goto cleanup;
		}
		// Attempt to find it in the clsid section
		key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
		if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
		{
			*szName = 0;
			RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
			OutputDebugString(_T("(CLSID\?\?\?) "));
			OutputDebugString(szName);
			goto cleanup;
		}
		OutputDebugString(OLE2T(pszGUID));
	cleanup:
		if (hr != S_OK)
			OutputDebugString(_T(" - failed"));
		OutputDebugString(_T("\n"));
		CoTaskMemFree(pszGUID);
	}
	return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

}; //namespace ATL
using namespace ATL;

//only suck in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	ATLASSERT(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return lpszTemp-lpszPathName;
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	ATLASSERT(pThis != NULL);
	// First entry in the com map should be a simple map entry
	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				ATLASSERT(!bBlind);
				IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

#if !defined(_WIN32_WCE)
/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
	return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return TRUE;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			break;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return TRUE; // Event is now signaled.
		}
	}
	return FALSE;
}
#endif // _WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	USES_CONVERSION;
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	if (HIWORD(lpszDesc) == 0) //id
	{
		UINT nID = LOWORD((DWORD)lpszDesc);
		ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			ATLASSERT(FALSE);
			lstrcpy(szDesc, _T("Unknown Error"));
		}
		lpszDesc = T2OLE(szDesc);
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		WCE_FCTN(ProgIDFromCLSID)(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CRITICAL_SECTION m_csTypeInfoHolder;
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
	if (pM->cbSize == sizeof(_ATL_MODULE20))
		return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
	return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
	if ((pM->cbSize != _nAtlModuleVer1Size) && (pM->cbSize != sizeof(_ATL_MODULE)))
		return E_INVALIDARG;
#else
	ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
	pM->m_pObjMap = p;
	pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
	pM->m_nLockCnt=0L;
	pM->m_hHeap = NULL;
	InitializeCriticalSection(&pM->m_csTypeInfoHolder);
	InitializeCriticalSection(&pM->m_csWindowCreate);
	InitializeCriticalSection(&pM->m_csObjMap);
#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer1Size)
#endif
	{
		pM->m_pCreateWndList = NULL;
		pM->m_bDestroyHeap = true;
		pM->m_dwHeaps = 0;
		pM->m_nHeap = 0;
		pM->m_phHeaps = NULL;
		pM->m_pTermFuncs = NULL;
		if (pM->m_pObjMap != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
			while (pEntry->pclsid != NULL)
			{
				pEntry->pfnObjectMain(true); //initialize class resources
				pEntry = _NextObjectMapEntry(pM, pEntry);
			}
		}
	}
	
	return S_OK;
}

#if !defined(_WIN32_WCE)
ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	return hRes;
}
#endif // _WIN32_WCE

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	*ppv = NULL;
	while (pEntry->pclsid != NULL)
	{
		if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				EnterCriticalSection(&pM->m_csObjMap);
				if (pEntry->pCF == NULL)
					hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				LeaveCriticalSection(&pM->m_csObjMap);
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	if (pM->m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
			if (pM->cbSize > _nAtlModuleVer1Size)
#endif
				pEntry->pfnObjectMain(false); //cleanup class resources
			pEntry = _NextObjectMapEntry(pM, pEntry);
		}
	}
	DeleteCriticalSection(&pM->m_csTypeInfoHolder);
	DeleteCriticalSection(&pM->m_csWindowCreate);
	DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer1Size)
#endif
	{
		_ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
		_ATL_TERMFUNC_ELEM* pNext = NULL;
		while (pElem != NULL)
		{
			pElem->pFunc(pElem->dw);
			pNext = pElem->pNext;
			delete pElem;
			pElem = pNext;
		}
		if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
		{
#ifndef _ATL_NO_MP_HEAP
			if (pM->m_phHeaps != NULL)
			{
				for (DWORD i=0; i<=pM->m_dwHeaps; i++)
					HeapDestroy(pM->m_phHeaps[i]);
			}
#endif
			HeapDestroy(pM->m_hHeap);
		}
	}
	return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD dw)
{
	HRESULT hr = S_OK;
	_ATL_TERMFUNC_ELEM* pNew = NULL;
	ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
	if (pNew == NULL)
		hr = E_OUTOFMEMORY;
	else
	{
		pNew->pFunc = pFunc;
		pNew->dw = dw;
		EnterCriticalSection(&pM->m_csStaticDataInit);
		pNew->pNext = pM->m_pTermFuncs;
		pM->m_pTermFuncs = pNew;
		LeaveCriticalSection(&pM->m_csStaticDataInit);
	}
	return hr;
}

#if !defined(_WIN32_WCE)
ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid, 
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
      return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, 
      CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
      // Since not all systems have the category manager installed, we'll allow
      // the registration to succeed even though we didn't register our 
      // categories.  If you really want to register categories on a system
      // without the category manager, you can either manually add the 
      // appropriate entries to your registry script (.rgs), or you can 
      // redistribute comcat.dll.
      return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
      catid = *pEntry->pcatid;
      if( bRegister )
      {
         if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
         {
            hResult = pCatRegister->RegisterClassImplCategories( clsid, 1, 
               &catid );
         }
         else
         {
            ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
            hResult = pCatRegister->RegisterClassReqCategories( clsid, 1, 
               &catid );
         }
         if( FAILED( hResult ) )
         {
            return( hResult );
         }
      }
      else
      {
         if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
         {
            pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
         }
         else
         {
            ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
            pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
         }
      }
      pEntry++;
   }

   return( S_OK );
}
#endif // _WIN32_WCE

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription != NULL &&
				pEntry->pfnGetObjectDescription() != NULL)
					continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
#if !defined(_WIN32_WCE)
		if (pM->cbSize == sizeof(_ATL_MODULE))
		{
			hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, 
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hRes))
				break;
		}
#endif // _WIN32_WCE
	}
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = AtlModuleRegisterTypeLib(pM, 0);
	return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription != NULL
				&& pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		pEntry->pfnUpdateRegistry(FALSE); //unregister
#if !defined(_WIN32_WCE)
		AtlRegisterClassCategoriesHelper( *pEntry->pclsid, 
			pEntry->pfnGetCategoryMap(), FALSE );
#endif // _WIN32_WCE
	}
	if (bUnRegTypeLib)
		AtlModuleUnRegisterTypeLib(pM, 0);
	return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
	return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
	USES_CONVERSION;
	ATLASSERT(pM != NULL);
	HRESULT hRes = S_OK;
	CComPtr<IRegistrar> p;
	if (pReg != NULL)
		p = pReg;
	else
	{
		hRes = CoCreateInstance(CLSID_Registrar, NULL,
			CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
	}
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

      // Convert to short path to work around bug in NT4's CreateProcess
      WCE_DEL TCHAR szModuleShort[_MAX_PATH];
      WCE_DEL GetShortPathName(szModule, szModuleShort, _MAX_PATH);
      LPOLESTR pszModule = T2OLE(WCE_IF(szModule,szModuleShort));

		int nLen = ocslen(pszModule);
		LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
		CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
		p->AddReplacement(OLESTR("Module"), pszModuleQuote);

		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				ATLASSERT(NULL != pMapEntries->szData);
				p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
				pMapEntries++;
			}
		}
		LPCOLESTR szType = OLESTR("REGISTRY");
		if (HIWORD(lpszRes)==0)
		{
			if (bRegister)
				hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
			else
				hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
		}
		else
		{
			if (bRegister)
				hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
			else
				hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
		}

	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
	*pbstrPath = NULL;
	*ppTypeLib = NULL;
	ATLASSERT(pM != NULL);
	USES_CONVERSION;
	ATLASSERT(pM->m_hInstTypeLib != NULL);
	TCHAR szModule[_MAX_PATH+10];
	GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
	if (lpszIndex != NULL)
		lstrcat(szModule, OLE2CT(lpszIndex));
	LPOLESTR lpszModule = T2OLE(szModule);
	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, ppTypeLib);
	}
	if (SUCCEEDED(hr))
		*pbstrPath = OLE2BSTR(lpszModule);
	return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		TLIBATTR* ptla;
		HRESULT hr = pTypeLib->GetLibAttr(&ptla);
		if (SUCCEEDED(hr))
		{
			HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
			if (h != NULL)
			{
				PFNRTL pfn = (PFNRTL) GetProcAddress(h, WCE_IF(_T("UnRegisterTypeLib"),"UnRegisterTypeLib"));
				if (pfn != NULL)
					hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
				FreeLibrary(h);
			}
			pTypeLib->ReleaseTLibAttr(ptla);
		}
	}
	return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		OLECHAR szDir[_MAX_PATH];
		ocscpy(szDir, bstrPath);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
	}
	return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
	return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
	pData->m_pThis = pObject;
	pData->m_dwThreadID = ::GetCurrentThreadId();
	::EnterCriticalSection(&pM->m_csWindowCreate);
	pData->m_pNext = pM->m_pCreateWndList;
	pM->m_pCreateWndList = pData;
	::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
	void* pv = NULL;
	::EnterCriticalSection(&pM->m_csWindowCreate);
	_AtlCreateWndData* pEntry = pM->m_pCreateWndList;
	if(pEntry != NULL)
	{
		DWORD dwThreadID = ::GetCurrentThreadId();
		_AtlCreateWndData* pPrev = NULL;
		while(pEntry != NULL)
		{
			if(pEntry->m_dwThreadID == dwThreadID)
			{
				if(pPrev == NULL)
					pM->m_pCreateWndList = pEntry->m_pNext;
				else
					pPrev->m_pNext = pEntry->m_pNext;
				pv = pEntry->m_pThis;
				break;
			}
			pPrev = pEntry;
			pEntry = pEntry->m_pNext;
		}
	}
	::LeaveCriticalSection(&pM->m_csWindowCreate);
	return pv;
}

#if !defined(_WIN32_WCE)
/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
	ATLASSERT(pDllVersionInfo != NULL);
	if(::IsBadWritePtr(pDllVersionInfo, sizeof(DWORD)))
		return E_INVALIDARG;

	// We must get this function explicitly because some DLLs don't implement it.
	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
	if(pfnDllGetVersion == NULL)
		return E_NOTIMPL;

	return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
	HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
	if(hInstDLL == NULL)
		return E_FAIL;
	HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
	::FreeLibrary(hInstDLL);
	return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0	maj=4 min=00
//   IE 3.x		maj=4 min=70
//   IE 4.0		maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
	if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
		return E_INVALIDARG;

	DLLVERSIONINFO dvi;
	::ZeroMemory(&dvi, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}
	else if(hRet == E_NOTIMPL)
	{
		// If DllGetVersion is not there, then the DLL is a version 
		// previous to the one shipped with IE 3.x
		*pdwMajor = 4;
		*pdwMinor = 0;
		hRet = S_OK;
	}

	return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0					maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop	maj=4 min=00
//   IE 4.0 with Web Integrated Desktop			maj=4 min=71
//   IE 4.01 with Web Integrated Desktop		maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
	if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
		return E_INVALIDARG;

	DLLVERSIONINFO dvi;
	::ZeroMemory(&dvi, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}
	else if(hRet == E_NOTIMPL)
	{
		// If DllGetVersion is not there, then the DLL is a version 
		// previous to the one shipped with IE 4.x
		*pdwMajor = 4;
		*pdwMinor = 0;
		hRet = S_OK;
	}

	return hRet;
}
#endif // _WIN32_WCE

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif



#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\servprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Thu Sep 11 10:59:13 1997
 */
/* Compiler settings for servprov.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __servprov_h__
#define __servprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_servprov_0000
 * at Thu Sep 11 10:59:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.


#ifndef _LPSERVICEPROVIDER_DEFINED
#define _LPSERVICEPROVIDER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServiceProvider
 * at Thu Sep 11 10:59:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IServiceProvider __RPC_FAR *LPSERVICEPROVIDER;


EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
#if (_MSC_VER >= 1200)	// VC6 or greater
extern "C++"
{
#endif

    MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
    IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
#if (_MSC_VER >= 1200)	// VC6 or greater
		template <class Q>
		HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, Q** pp)
		{
			return QueryService(guidService, __uuidof(Q), (void**)pp);
		}
#endif    
    };

#if (_MSC_VER >= 1200)	// VC6 or greater
} // extern "C++"
#endif
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServiceProvider __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_servprov_0074
 * at Thu Sep 11 10:59:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_servprov_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0074_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* ndef _MAC */


/* modeflag values for _spawnxx routines */

#ifndef _MAC

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1

#else   /* ndef _MAC */

#define _P_NOWAIT       1
#define _P_OVERLAY      2

#endif  /* ndef _MAC */


/* function prototypes */

#ifdef  _MT
_CRTIMP unsigned long  __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP unsigned long __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

#ifndef _MAC

_CRTIMP int __cdecl _cwait(int *, int, int);
_CRTIMP int __cdecl _execl(const char *, const char *, ...);
_CRTIMP int __cdecl _execle(const char *, const char *, ...);
_CRTIMP int __cdecl _execlp(const char *, const char *, ...);
_CRTIMP int __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl _execv(const char *, const char * const *);
_CRTIMP int __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _execvp(const char *, const char * const *);
_CRTIMP int __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#else   /* ndef _MAC */

_CRTIMP int __cdecl _spawn(int, const char *);

#endif  /* ndef _MAC */

#ifndef _MAC
#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
int __cdecl _loaddll(char *);
int __cdecl _unloaddll(int);
int (__cdecl * __cdecl _getdllprocaddr(int, char *, int))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif
#endif  /* ndef _MAC */

#if     !__STDC__

/* Non-ANSI names for compatibility */


#ifndef _MAC

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

#else   /* ndef _MAC */

#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY

#endif  /* ndef _MAC */

#ifndef _MAC

/* current declarations */
_CRTIMP int __cdecl cwait(int *, int, int);
_CRTIMP int __cdecl execl(const char *, const char *, ...);
_CRTIMP int __cdecl execle(const char *, const char *, ...);
_CRTIMP int __cdecl execlp(const char *, const char *, ...);
_CRTIMP int __cdecl execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl execv(const char *, const char * const *);
_CRTIMP int __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl execvp(const char *, const char * const *);
_CRTIMP int __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

#endif  /* ndef _MAC */

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\patch\include\winver.h ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*          Copyright 1993 - 1998 Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#ifdef __cplusplus
extern "C" {
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#ifndef _MAC
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#else
#define VS_FFI_SIGNATURE        0xBD04EFFEL
#endif
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

DWORD
APIENTRY
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
APIENTRY
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

DWORD
APIENTRY
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
APIENTRY
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD
APIENTRY
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
APIENTRY
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE

#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif

#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\helpresource.h ===
#define IDH_LIST_TTS			101  
#define IDH_TTS_ADV				102
#define IDH_OUTPUT_SETTINGS		103
#define IDH_SLIDER_SPEED		104
#define IDH_EDIT_SPEAK			105
#define IDH_SPEAK				106

#define IDH_USER				201
#define IDH_SETTINGS			202
#define IDH_ADD					203
#define IDH_DELETE				204

#define IDH_ENGINES				301
#define IDH_SR_ADV				302
#define IDH_USERTRAINING		303
#define IDH_PROGRESS1			304
#define IDH_AUD_IN				305
#define IDH_MICWIZ				306

#define IDH_BUILDER				401
#define IDH_VEDITOR				402
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	copy /Y $(O)\sapi.cpl $(SYSTEMROOT)\system32\sapi.cpl
	copy /Y $(O)\sapi.cpl ..\sapi\$(O)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\audiodlg.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <sapi.h>
#include <string.h>
#include "audiodlg.h"
#include <spddkhlp.h>
#include <stdio.h>

/*****************************************************************************
* AudioDlgProc *
*--------------*
*   Description:
*       DLGPROC for choosing the default audio input/output
****************************************************************** BECKYW ***/
BOOL CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CSpUnicodeSupport unicode;  
    CAudioDlg *pAudioDlg = (CAudioDlg *) unicode.GetWindowLongPtr( hWnd, GWLP_USERDATA );
    SPDBG_FUNC( "AudioDlgProc" );

    CComPtr<ISpObjectToken> cpToken;

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            // pAudioDlg comes in on the lParam
            pAudioDlg = (CAudioDlg *) lParam;

            // Set pAudioDlg to the window long so we can get it later
            unicode.SetWindowLongPtr( hWnd, GWLP_USERDATA, lParam );

            pAudioDlg->OnInitDialog(hWnd);
            break;

        case WM_DESTROY:
            pAudioDlg->OnDestroy();
            break;

        case WM_COMMAND:
            if ( LOWORD( wParam ) == IDOK )
            {
                // Determine if there are changes to commit
                WCHAR pwszRequestedDefault[ MAX_PATH ];
                pwszRequestedDefault[0] = 0;
                if ( pAudioDlg->GetRequestedDefaultTokenID( pwszRequestedDefault, MAX_PATH ) )
                {
                    // What kind of changes have been made?
                    pAudioDlg->m_fChangesToCommit = 
                        (pAudioDlg->m_dstrCurrentDefaultTokenId &&
                        (0 != wcsicmp( pwszRequestedDefault, pAudioDlg->m_dstrCurrentDefaultTokenId )));

                    pAudioDlg->m_fChangesSinceLastTime = 
                         (pAudioDlg->m_dstrCurrentDefaultTokenId &&
                         (0 != wcsicmp( pwszRequestedDefault, pAudioDlg->m_dstrDefaultTokenIdBeforeOK )));
               }

                if ( pAudioDlg->m_fChangesSinceLastTime )
                {
                    pAudioDlg->m_dstrLastRequestedDefaultTokenId = pwszRequestedDefault;
                }

                ::EndDialog( hWnd, true );
            }
            
            else if ( LOWORD( wParam ) == IDCANCEL )
            {
                // There are no changes to commit
                pAudioDlg->m_fChangesSinceLastTime = false;

                ::EndDialog( hWnd, false );
            }

            // Handle the volume button
            else if ( LOWORD( wParam ) == ID_TTS_VOL )
            {
                pAudioDlg->GetAudioToken(&cpToken);
                CSpDynamicString wszTitle;
                CComPtr<ISpObjectWithToken> cpSpObjectWithToken;
                HRESULT hr = S_OK;

	            hr = cpToken->CreateInstance(
			            NULL, CLSCTX_INPROC_SERVER, IID_ISpObjectWithToken,
			            (void **)&cpSpObjectWithToken);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[256];
                    ::LoadString(_Module.GetResourceInstance(), IDS_AUDIO_VOLUME, wszTitle, 256);
                    hr = cpToken->DisplayUI(pAudioDlg->GetHDlg(), wszTitle, SPDUI_AudioVolume, NULL, 0, cpSpObjectWithToken);
                }
                SPDBG_REPORT_ON_FAIL(hr);
            }

            // Handle the audio properties button
            else if ( LOWORD(wParam) == IDC_AUDIO_PROPERTIES)
            {
                pAudioDlg->GetAudioToken(&cpToken);
                CSpDynamicString wszTitle;
                CComPtr<ISpObjectWithToken> cpSpObjectWithToken;
                HRESULT hr = S_OK;

	            hr = cpToken->CreateInstance(
			            NULL, CLSCTX_INPROC_SERVER, IID_ISpObjectWithToken,
			            (void **)&cpSpObjectWithToken);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[256];
                    ::LoadString(_Module.GetResourceInstance(), IDS_AUDIO_PROPERTIES, wszTitle, 256);
                    hr = cpToken->DisplayUI(pAudioDlg->GetHDlg(), wszTitle, SPDUI_AudioProperties, NULL, 0, cpSpObjectWithToken);
                }
                SPDBG_REPORT_ON_FAIL(hr);
            }

            // Handle a selection change for the audio device
            else if (( IDC_DEFAULT_DEVICE == LOWORD( wParam ) ) &&
                     ( CBN_SELCHANGE == HIWORD( wParam ) ))
            {
                SPDBG_ASSERT( !pAudioDlg->IsPreferredDevice() );

                pAudioDlg->GetAudioToken(&cpToken);
                pAudioDlg->UpdateDlgUI(cpToken);
            }

            // Handle a click to either the preferred or 'this device' radio buttons
            else if (HIWORD(wParam) == BN_CLICKED)
            {
                bool bPreferred;
                if( LOWORD(wParam) == IDC_PREFERRED_MM_DEVICE)
                {
                    bPreferred = true;
                }
                else if(LOWORD(wParam) == IDC_THIS_DEVICE)
                {
                    bPreferred = false;
                }

                ::EnableWindow( ::GetDlgItem(pAudioDlg->GetHDlg(), IDC_DEFAULT_DEVICE), !bPreferred );
                pAudioDlg->SetPreferredDevice( bPreferred );
                pAudioDlg->GetAudioToken(&cpToken);
                pAudioDlg->UpdateDlgUI(cpToken);
            }
            break;
    
    }

    return FALSE;
} /* AudioDlgProc */

/*****************************************************************************
* CAudioDlg::OnInitDialog *
*-------------------------*
*   Description:
*       Dialog Initialization
****************************************************************** BECKYW ***/
void CAudioDlg::OnInitDialog(HWND hWnd)
{
    SPDBG_FUNC( "CAudioDlg::OnInitDialog" );
    SPDBG_ASSERT(IsWindow(hWnd));
    m_hDlg = hWnd;

    // Set the appropriate captions
    WCHAR wszCaption[ MAX_LOADSTRING ];
    HINSTANCE hInst = _Module.GetResourceInstance();

    // Main Window Caption
    ::LoadString( hInst, 
        (m_iotype == eINPUT) ? IDS_DEFAULT_SPEECH_INPUT : IDS_DEFAULT_SPEECH_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( hWnd, WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Group Box Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_DEFAULT_INPUT : IDS_DEFAULT_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_AUDIO_GROUPBOX ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Preferred Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_PREFERRED_INPUT : IDS_PREFERRED_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_PREFERRED_MM_DEVICE ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Specific Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_SPECIFIC_INPUT : IDS_SPECIFIC_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_THIS_DEVICE ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );
    // MSAA Specific Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_SPECIFIC_INPUT2 : IDS_SPECIFIC_OUTPUT2,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_THIS_DEVICE2 ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Volume Button
    ::LoadString( hInst,
        IDS_VOLUME,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, ID_TTS_VOL ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Properties Button
    ::LoadString( hInst,
        IDS_PROPERTIES,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_AUDIO_PROPERTIES ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    const WCHAR *pszCategory = (m_iotype == eINPUT) ? SPCAT_AUDIOIN : SPCAT_AUDIOOUT;

    const WCHAR *pszMMSysEnum = (m_iotype == eINPUT)
        ? SPMMSYS_AUDIO_IN_TOKEN_ID
        : SPMMSYS_AUDIO_OUT_TOKEN_ID;

    HRESULT hr = S_OK;
    if ( !m_dstrCurrentDefaultTokenId )
    {
        hr = SpGetDefaultTokenIdFromCategoryId( pszCategory, &m_dstrCurrentDefaultTokenId );
    }

    if (SUCCEEDED(hr))
    {
        // Determine what the initial setting will appear as 
        if ( m_dstrLastRequestedDefaultTokenId )
        {
            // An audio change was previously OK'ed
            m_dstrDefaultTokenIdBeforeOK = m_dstrLastRequestedDefaultTokenId;

            // The current default could be different if the user OK'ed a change
            // but did not apply it
            m_fChangesToCommit = ( 0 != wcsicmp( m_dstrCurrentDefaultTokenId, 
                m_dstrDefaultTokenIdBeforeOK ) );
        }
        else
        {
            // No audio change was previously OK'ed
            if ( !m_dstrDefaultTokenIdBeforeOK )
            {
                m_dstrDefaultTokenIdBeforeOK = m_dstrCurrentDefaultTokenId;
            }
        }

        if (wcsicmp(m_dstrDefaultTokenIdBeforeOK, pszMMSysEnum) == 0)
        {
            // This message will cause the check button to be correct.
            ::SendMessage( ::GetDlgItem(m_hDlg, IDC_PREFERRED_MM_DEVICE), BM_SETCHECK, true, 0L );

            // This message will cause the volume button to be enabled or disabled as appropriate
            ::SendMessage( m_hDlg, WM_COMMAND, MAKELONG( IDC_PREFERRED_MM_DEVICE, BN_CLICKED ),
                (LPARAM) ::GetDlgItem( m_hDlg, IDC_PREFERRED_MM_DEVICE ) );
        }
        else
        {
            // This message will cause the check button to be correct.
            ::SendMessage( ::GetDlgItem(m_hDlg, IDC_THIS_DEVICE), BM_SETCHECK, true, 0L );
        }
    
        // Initialize the list of audio devices
        hr = SpInitTokenComboBox( ::GetDlgItem( hWnd, IDC_DEFAULT_DEVICE ),
            (m_iotype == eINPUT) ? SPCAT_AUDIOIN : SPCAT_AUDIOOUT );
    }
    
    if (S_OK == hr)
    {
        if ( BST_CHECKED == ::SendMessage( ::GetDlgItem( m_hDlg, IDC_THIS_DEVICE ), BM_GETCHECK, 0, 0 ) )
        {
            // Select the appropriate default token ID here by going through the 
            // stuff in the list and selecting the one whose token ID matches
            // m_dstrDefaultTokenIdBeforeOK
            int nTokens = (int)::SendDlgItemMessage( m_hDlg, IDC_DEFAULT_DEVICE, CB_GETCOUNT, 0, 0 );
            int iItem = 0;
            CSpDynamicString dstrTokenId;
            bool fFound = false;
            for ( iItem = 0; 
                (iItem < nTokens) && !fFound;
                iItem++ )
            {
                ISpObjectToken *pToken = (ISpObjectToken *) ::SendDlgItemMessage( m_hDlg,
                    IDC_DEFAULT_DEVICE, CB_GETITEMDATA, iItem, 0 );

                HRESULT hr = E_FAIL;
                if ( pToken )
                {
                    hr = pToken->GetId(&dstrTokenId);
                }

                if ( SUCCEEDED( hr ) )
                {
                    fFound = (0 == wcsicmp( m_dstrDefaultTokenIdBeforeOK, dstrTokenId ));
                }

                dstrTokenId = (WCHAR *) NULL;
            }
            SPDBG_ASSERT( fFound );
            ::SendDlgItemMessage( m_hDlg, IDC_DEFAULT_DEVICE, CB_SETCURSEL, iItem - 1, 0 );

            // This message will cause the volume button to be enabled or disabled as appropriate
            ::SendMessage( m_hDlg, WM_COMMAND, MAKELONG( IDC_THIS_DEVICE, BN_CLICKED ),
                (LPARAM) ::GetDlgItem( m_hDlg, IDC_THIS_DEVICE ) );
        }

        ::SetCursor( ::LoadCursor( NULL, IDC_ARROW ) );
    }
    else
    {
        WCHAR szError[ MAX_LOADSTRING ];
        WCHAR szIO[ MAX_LOADSTRING ];
        WCHAR szErrorTemplate[ MAX_LOADSTRING ];
        ::LoadString( _Module.GetResourceInstance(), IDS_NO_DEVICES, szErrorTemplate, sp_countof( szErrorTemplate ) );
        ::LoadString( _Module.GetResourceInstance(), (eINPUT == m_iotype) ? IDS_INPUT : IDS_OUTPUT, szIO, sp_countof( szIO ) );
        swprintf( szError, szErrorTemplate, szIO );
        ::MessageBox( m_hDlg, szError, NULL, MB_ICONEXCLAMATION | g_dwIsRTLLayout );

        if ( FAILED( hr ) )
        {
            ::EndDialog( m_hDlg, -1 );
        }
        else
        {
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_THIS_DEVICE ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_PREFERRED_MM_DEVICE ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_AUDIO_PROPERTIES ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, ID_TTS_VOL ), FALSE );
        }
    }
} /* CAudioDlg::OnInitDialog */

/*****************************************************************************
* CAudioDlg::OnDestroy *
*----------------------*
*   Description:
*       Destruction
****************************************************************** BECKYW ***/
void CAudioDlg::OnDestroy()
{
    SPDBG_FUNC( "CAudioDlg::OnDestroy" );

    SpDestroyTokenComboBox( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ) );
} /* CAudioDlg::OnDestroy */

/*****************************************************************************
* CAudioDlg::OnApply *
*--------------------*
*   Description:
*       Set user specified options
****************************************************************** BECKYW ***/
HRESULT CAudioDlg::OnApply()
{
    SPDBG_FUNC( "CAudioDlg::OnApply" );

    if ( !m_dstrLastRequestedDefaultTokenId )
    {
        // nothing to apply
        return S_FALSE;
    }

    HRESULT hr;
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(
            m_iotype == eINPUT 
                ? SPCAT_AUDIOIN 
                : SPCAT_AUDIOOUT,
            &cpCategory);

    if ( SUCCEEDED( hr ) )
    {
        hr = cpCategory->SetDefaultTokenId( m_dstrLastRequestedDefaultTokenId );
    }

    // Next time we bring this up we should show the actual default
    m_dstrLastRequestedDefaultTokenId = (WCHAR *) NULL;
    m_dstrDefaultTokenIdBeforeOK = (WCHAR *) NULL;

    return hr;
} /* CAudioDlg::OnApply */

/*****************************************************************************
* CAudioDlg::GetRequestedDefaultTokenID *
*---------------------------------------*
*   Description:
*       Looks at the UI and gets the token ID that the user wants to switch 
*       to.  This is returned in pwszNewID.
*   Return:
*       Number of characters in the ID
****************************************************************** BECKYW ***/
UINT CAudioDlg::GetRequestedDefaultTokenID( WCHAR *pwszNewID, UINT cLength )
{
    if ( !pwszNewID )
    {
        return 0;
    }

    CComPtr<ISpObjectTokenCategory> cpCategory;
    HRESULT hr = SpGetCategoryFromId(
            m_iotype == eINPUT 
                ? SPCAT_AUDIOIN 
                : SPCAT_AUDIOOUT,
            &cpCategory);

    if (SUCCEEDED(hr))
    {
        if( ::SendMessage( ::GetDlgItem(m_hDlg, IDC_PREFERRED_MM_DEVICE), BM_GETCHECK, 0, 0L ) == BST_CHECKED )
        {
            const WCHAR *pwszMMSysAudioID = (m_iotype == eINPUT) ? 
                                            SPMMSYS_AUDIO_IN_TOKEN_ID : 
                                            SPMMSYS_AUDIO_OUT_TOKEN_ID;
            UINT cMMSysAudioIDLength = wcslen( pwszMMSysAudioID );
            UINT cRet = __min( cLength - 1, cMMSysAudioIDLength );
            wcsncpy( pwszNewID, pwszMMSysAudioID, cRet );
            pwszNewID[ cRet ] = 0;

            return cRet;
        }
        else
        {
            ISpObjectToken *pToken = SpGetCurSelComboBoxToken( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ) );
            if (pToken)
            {
                CSpDynamicString dstrTokenId;
                hr = pToken->GetId(&dstrTokenId);

                if (SUCCEEDED(hr))
                {
                    UINT cIDLength = wcslen( dstrTokenId );
                    UINT cRet = __min( cLength - 1, cIDLength );
                    wcsncpy( pwszNewID, dstrTokenId, cRet );
                    pwszNewID[ cRet ] = 0;

                    return cRet;

                }
            }
        }
    }

    // There was an error
    return 0;
}   /* CAudioDlg::GetRequestedDefaultTokenID */

/*****************************************************************************
* CAudioDlg::GetAudioToken *
*--------------------------*
*   Description:
*       Returns an interface to the currently selected token. Currently this
*       can either be the 'preferred' device in which case, the object is created
*       on the fly. Or it can be one from the drop-down list which contains an
*       attached token. In this case, it needs to be addref'd so that the returned
*       token is consistent regardless of the source inside this function.
*
*       NB: This requires the caller to call release on the instance.
*
*   Return:
**************************************************************** AGARSIDE ***/
HRESULT CAudioDlg::GetAudioToken(ISpObjectToken **ppToken)
{
    HRESULT hr = S_OK;
    *ppToken = NULL;

    if (IsPreferredDevice())
    {
        hr = SpGetTokenFromId((this->IsInput())?(SPMMSYS_AUDIO_IN_TOKEN_ID):(SPMMSYS_AUDIO_OUT_TOKEN_ID),
                              ppToken, 
                              FALSE);
        SPDBG_ASSERT(SUCCEEDED(hr));
    }
    else
    {
        *ppToken = SpGetCurSelComboBoxToken( GetDlgItem(this->GetHDlg(), IDC_DEFAULT_DEVICE) );
        (*ppToken)->AddRef();
    }

    return S_OK;
}

/*****************************************************************************
* CAudioDlg::UpdateDlgUI *
*------------------------*
*   Description:
*   Return:
**************************************************************** AGARSIDE ***/
HRESULT CAudioDlg::UpdateDlgUI(ISpObjectToken *pToken)
{
    SPDBG_FUNC("CAudioDlg::UpdateDlgUI");
    HRESULT hr = S_OK;
    BOOL fSupported;
    CComPtr<ISpObjectWithToken> cpSpObjectWithToken;

    // Get hold of ISpObjectWithToken
	hr = pToken->CreateInstance(
			NULL, CLSCTX_INPROC_SERVER, IID_ISpObjectWithToken,
			(void **)&cpSpObjectWithToken);

    // Update volume button status.
    fSupported = FALSE;
    if (SUCCEEDED(hr))
    {
        pToken->IsUISupported(SPDUI_AudioVolume, NULL, 0, cpSpObjectWithToken, &fSupported);
        ::EnableWindow( ::GetDlgItem(this->GetHDlg(), ID_TTS_VOL), fSupported);
    }

    // Update UI button status.
    fSupported = FALSE;
    if (SUCCEEDED(hr))
    {
        pToken->IsUISupported(SPDUI_AudioProperties, NULL, 0, cpSpObjectWithToken, &fSupported);
        ::EnableWindow( ::GetDlgItem(this->GetHDlg(), IDC_AUDIO_PROPERTIES), fSupported);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\audiodlg.h ===
/*******************************************************************************
* AudioDlg.h *
*------------*
*   Description:
*       This is the header file for the default audio input/output dialog.
*-------------------------------------------------------------------------------
*  Created By: BECKYW                            Date: 10/15/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/
#ifndef _AUDIODLG_H
#define _AUDIODLG_H

#define MAX_LOADSTRING      1000
#define WM_AUDIOINFO        WM_USER + 20

typedef enum IOTYPE
{
    eINPUT,
    eOUTPUT
};

typedef struct AUDIOINFO
{
    ISpObjectToken  *pToken;
}   AUDIOINFO;


class CAudioDlg
{
  private:
    BOOL                        m_bPreferredDevice;
    HWND                        m_hDlg;
    const IOTYPE                m_iotype;
    CSpDynamicString            m_dstrDefaultTokenIdBeforeOK;
    CSpDynamicString            m_dstrCurrentDefaultTokenId;
    
    // Indicates whether a change was made that will have to be committed
    bool                        m_fChangesToCommit;

    bool                        m_fChangesSinceLastTime;

    // Indicates if any changes have been made since the last apply
    // that need to be reflected in the UI
    CSpDynamicString            m_dstrLastRequestedDefaultTokenId;

    // holds the process information for the volume control
    PROCESS_INFORMATION         m_pi;   

    // Will decide between W() and A() versions
    CSpUnicodeSupport           m_unicode;

  public:
    CAudioDlg(IOTYPE iotype) :
        m_bPreferredDevice(true),
        m_hDlg(NULL),
        m_iotype(iotype),
        m_fChangesToCommit( false ),
        m_fChangesSinceLastTime( false ),
        m_dstrLastRequestedDefaultTokenId( (WCHAR *) NULL ),
        m_dstrCurrentDefaultTokenId( (WCHAR *) NULL )
    {
        m_pi.hProcess = NULL;
    }


    HRESULT                     OnApply(void);
    bool                        IsAudioDeviceChanged()
                                    { return m_fChangesToCommit; }
    bool                        IsAudioDeviceChangedSinceLastTime()
                                    { return m_fChangesSinceLastTime; }
  private:
    void                        OnDestroy(void);
    void                        OnInitDialog(HWND hWnd);
    HWND                        GetHDlg(void) 
                                { return m_hDlg; }
    BOOL                        IsPreferredDevice(void) 
                                { return m_bPreferredDevice; }
    void                        SetPreferredDevice( BOOL b ) 
                                { m_bPreferredDevice = b; }

    UINT                        GetRequestedDefaultTokenID( WCHAR *pwszNewID, UINT cLength );
    HRESULT                     GetAudioToken(ISpObjectToken **ppToken);
    HRESULT                     UpdateDlgUI(ISpObjectToken *pToken);
    BOOL                        IsInput(void)
                                { return (m_iotype == eINPUT); };

    friend BOOL CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

};

#endif  // _AUDIODLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\progressbar.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "progressbar.h"

// Dispatch interfaces referenced by this interface
#include "Picture.h"

/////////////////////////////////////////////////////////////////////////////
// CProgressBar

IMPLEMENT_DYNCREATE(CProgressBar, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CProgressBar properties

/////////////////////////////////////////////////////////////////////////////
// CProgressBar operations

float CProgressBar::GetMax()
{
	float result;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetMax(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

float CProgressBar::GetMin()
{
	float result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetMin(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

long CProgressBar::GetMousePointer()
{
	long result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetMousePointer(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CPicture CProgressBar::GetMouseIcon()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CPicture(pDispatch);
}

void CProgressBar::SetRefMouseIcon(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

void CProgressBar::SetMouseIcon(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

float CProgressBar::GetValue()
{
	float result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetValue(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

long CProgressBar::GetOLEDropMode()
{
	long result;
	InvokeHelper(0x60f, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetOLEDropMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x60f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CProgressBar::GetAppearance()
{
	long result;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetAppearance(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CProgressBar::GetBorderStyle()
{
	long result;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetBorderStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CProgressBar::GetEnabled()
{
	BOOL result;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetEnabled(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CProgressBar::GetHWnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::OLEDrag()
{
	InvokeHelper(0x610, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CProgressBar::GetOrientation()
{
	long result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetOrientation(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CProgressBar::GetScrolling()
{
	long result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetScrolling(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CProgressBar::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\picture.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "picture.h"


/////////////////////////////////////////////////////////////////////////////
// CPicture properties

long CPicture::GetHandle()
{
	long result;
	GetProperty(0x0, VT_I4, (void*)&result);
	return result;
}

long CPicture::GetHPal()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CPicture::SetHPal(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

short CPicture::GetType()
{
	short result;
	GetProperty(0x3, VT_I2, (void*)&result);
	return result;
}

long CPicture::GetWidth()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

long CPicture::GetHeight()
{
	long result;
	GetProperty(0x5, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CPicture operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\picture.h ===
#if !defined(AFX_PICTURE_H__5245593F_5C46_40FB_9DE4_69AD6DD0648A__INCLUDED_)
#define AFX_PICTURE_H__5245593F_5C46_40FB_9DE4_69AD6DD0648A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CPicture wrapper class

class CPicture : public COleDispatchDriver
{
public:
	CPicture() {}		// Calls COleDispatchDriver default constructor
	CPicture(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	CPicture(const CPicture& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	long GetHandle();
	long GetHPal();
	void SetHPal(long);
	short GetType();
	long GetWidth();
	long GetHeight();

// Operations
public:
	// method 'Render' not emitted because of invalid return type or parameter type
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PICTURE_H__5245593F_5C46_40FB_9DE4_69AD6DD0648A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\progressbar.h ===
#if !defined(AFX_PROGRESSBAR_H__78F8DA9B_4EF4_4500_97B6_647141CA2280__INCLUDED_)
#define AFX_PROGRESSBAR_H__78F8DA9B_4EF4_4500_97B6_647141CA2280__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class CPicture;

/////////////////////////////////////////////////////////////////////////////
// CProgressBar wrapper class

class CProgressBar : public CWnd
{
protected:
	DECLARE_DYNCREATE(CProgressBar)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x35053a22, 0x8589, 0x11d1, { 0xb1, 0x6a, 0x0, 0xc0, 0xf0, 0x28, 0x36, 0x28 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	float GetMax();
	void SetMax(float newValue);
	float GetMin();
	void SetMin(float newValue);
	long GetMousePointer();
	void SetMousePointer(long nNewValue);
	CPicture GetMouseIcon();
	void SetRefMouseIcon(LPDISPATCH newValue);
	void SetMouseIcon(LPDISPATCH newValue);
	float GetValue();
	void SetValue(float newValue);
	long GetOLEDropMode();
	void SetOLEDropMode(long nNewValue);
	long GetAppearance();
	void SetAppearance(long nNewValue);
	long GetBorderStyle();
	void SetBorderStyle(long nNewValue);
	BOOL GetEnabled();
	void SetEnabled(BOOL bNewValue);
	long GetHWnd();
	void OLEDrag();
	long GetOrientation();
	void SetOrientation(long nNewValue);
	long GetScrolling();
	void SetScrolling(long nNewValue);
	void Refresh();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSBAR_H__78F8DA9B_4EF4_4500_97B6_647141CA2280__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\ownerdrawui.inl ===
/*******************************************************************************
* OwnerDrawUI.inl *
*-----------------*
*   Description:
*       This is the header file for user-interface helper functions.  Note that
*       unlike SpHelper.H, this file requires the use of ATL.
*       Unlike spuihelp.h, this will take care of displaying DBCS characters
*       (non-native-codepage)
*
*   PLEASE NOTE: In order for this to work, the caller must I mean must 
*       process WM_DRAWITEM messages and call DrawODTokenListItem()!!! 
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#ifndef __ATLBASE_H__
#include <ATLBASE.h>
#endif

#ifndef __ATLCONV_H__
#include <ATLCONV.H>
#endif

inline HRESULT InitODTokenList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel,
                               HWND hwnd, const WCHAR * pszCatName,
                               const WCHAR * pszRequiredAttrib, const WCHAR * pszOptionalAttrib)
{
    HRESULT hr;
    ISpObjectToken * pToken;        // NOTE:  Not a CComPtr!  Be Careful.
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens(pszCatName, pszRequiredAttrib, pszOptionalAttrib, &cpEnum);
    UINT cItems = 0;
    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            if (SUCCEEDED(hr))
            {
                // This sets the thing as item data, since this CB is ownerdraw
                LRESULT i = ::SendMessage(hwnd, MsgAddString, 0, (LPARAM) pToken);

                if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    if (!fSetDefault)
                    {
                        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
                        fSetDefault = true;
                    }

                    cItems++;
                }
            }
            if (FAILED(hr))
            {
                pToken->Release();
            }
        }
    }
    else
    {
        hr = SPERR_NO_MORE_ITEMS;
    }

    if ( SUCCEEDED( hr ) && (0 == cItems) )
    {
        hr = S_FALSE;
    }

    return hr;
}

inline HRESULT InitODTokenComboBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return InitODTokenList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

//
//  Dont call this function directly.  Use DestoyTokenODComboBox or DestroyTokenODListBox.
//
inline void DestroyODTokenList(UINT MsgGetCount, UINT MsgGetItemData, HWND hwnd)
{
    LRESULT c = ::SendMessage(hwnd, MsgGetCount, 0, 0);
    for (LRESULT i = 0; i < c; i++)
    {
        IUnknown * pUnkObj = (IUnknown *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        if (pUnkObj)
        {
            pUnkObj->Release();
        }
    }
}

inline void DestroyODTokenComboBox(HWND hwnd)
{
    DestroyODTokenList(CB_GETCOUNT, CB_GETITEMDATA, hwnd);
}

inline ISpObjectToken * GetODComboBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessage(hwnd, CB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * GetCurSelODComboBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    return (i == CB_ERR) ? NULL : GetODComboBoxToken(hwnd, i);
}

inline void UpdateCurSelODComboBoxToken(HWND hwnd)
{
    // Repainting the window will get the correct text displayed
    ::InvalidateRect( hwnd, NULL, TRUE );
}

// Don't call this directly.  
inline HRESULT AddTokenToODList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel, HWND hwnd, ISpObjectToken * pToken)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;
    LRESULT i = ::SendMessage(hwnd, MsgAddString, 0, (LPARAM)pToken);
    if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
        pToken->AddRef();
    }
}

inline HRESULT AddTokenToODComboBox(HWND hwnd, ISpObjectToken * pToken)
{
    return AddTokenToODList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pToken);
}

// Don't call this directly
inline HRESULT DeleteCurSelODToken(UINT MsgGetCurSel, UINT MsgSetCurSel, UINT MsgGetItemData, UINT MsgDeleteString, HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessage(hwnd, MsgGetCurSel, 0, 0);
    if (i == CB_ERR)
    {
        hr = S_FALSE;
    }
    else
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        if (pToken)
        {
            pToken->Release();
        }
        ::SendMessage(hwnd, MsgDeleteString, i, 0);
        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
    }
    return hr;
}

inline HRESULT DeleteCurSelODComboBoxToken(HWND hwnd)
{
    return DeleteCurSelODToken(CB_GETCURSEL, CB_SETCURSEL, CB_GETITEMDATA, CB_DELETESTRING, hwnd);
}

// The owner of the owner-draw control MUST call this upon receiving a WM_DRAWITEM message
void DrawODTokenListItem( LPDRAWITEMSTRUCT lpdis )
{
    UINT oldTextAlign = GetTextAlign(lpdis->hDC);

    COLORREF clrfTextOld = ::GetTextColor( lpdis->hDC );
    COLORREF clrfBkOld = ::GetBkColor( lpdis->hDC );

    // Get the item state and change colors accordingly
    if ( (ODS_DISABLED & lpdis->itemState) || (-1 == lpdis->itemID) )
    {
        ::SetTextColor( lpdis->hDC, ::GetSysColor( COLOR_GRAYTEXT ) );
    }
    else if ( ODS_SELECTED & lpdis->itemState )
    {
        // Set the text background and foreground colors
        SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }

    UINT options = ETO_OPAQUE | ETO_CLIPPED;

    // Strings are stored as item data
    CSpDynamicString dstrName;
    if ( -1 != lpdis->itemID )
    {
        SpGetDescription( GetODComboBoxToken( lpdis->hwndItem, lpdis->itemID ), &dstrName );
    }
    else
    {
        dstrName = L"";
    }
  
    int cStringLen = wcslen( dstrName );

    SetTextAlign(lpdis->hDC, TA_UPDATECP);
    MoveToEx(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, NULL);
    ExtTextOutW(lpdis->hDC,
                lpdis->rcItem.left, lpdis->rcItem.top,
                options,
                &lpdis->rcItem,
                dstrName, 
                cStringLen,
                NULL);

    ::SetTextColor( lpdis->hDC, clrfTextOld );
    ::SetBkColor( lpdis->hDC, clrfBkOld );

    SetTextAlign(lpdis->hDC, oldTextAlign);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SpeechCPL.rc
//
#define IDS_NAME                        1
#define IDS_DESCRIPTION                 2
#define IDS_CAPTION                     3
#define ID_TTS_VOL                      3
#define IDS_E_INSTALL                   4
#define IDS_E_ENGINE                    5
#define IDS_E_MICWIZARD                 6
#define IDS_TREE_ROOT                   7
#define IDS_TREE_INPUT                  8
#define IDS_TREE_OUTPUT                 9
#define IDS_LANGID                      10
#define IDS_DEF_VOICE_TEXT              11
#define IDS_ENGINE_SETTINGS             12
#define IDI_CPL                         101
#define IDI_MIC                         101
#define IDB_OUTPUT                      103
#define IDB_INPUT                       104
#define IDB_LANG                        107
#define IDS_AGE_UNKNOWN                 107
#define IDB_ENGINE                      108
#define IDS_AGE_YOUNG                   108
#define IDB_TTSMODE                     109
#define IDS_AGE_NOTYOUNG                109
#define IDS_GENDER_UNKNOWN              110
#define IDS_GENDER_MALE                 111
#define IDS_GENDER_FEMALE               112
#define IDD_DEBUG                       113
#define IDS_USER_DEFAULT                113
#define IDS_TTSNAME                     115
#define IDD_DEFAULT_VOICE               116
#define IDD_TTS                         116
#define IDS_LANGUAGE                    116
#define IDD_MM_INPUTS                   117
#define IDD_SR                          117
#define IDS_GENDER                      117
#define IDS_VENDOR                      118
#define IDD_USER                        119
#define IDS_TTSDESCRIPTION              119
#define IDD_USER_NAME                   120
#define IDD_USER_PROP                   120
#define IDS_PREVIEW                     120
#define IDB_CHECKMARK                   121
#define IDS_STOP_PREVIEW                121
#define IDB_TTSPROP                     122
#define IDS_DEFAULT_SPEECH_INPUT        122
#define IDI_TTSICON                     123
#define IDS_DEFAULT_SPEECH_OUTPUT       123
#define IDD_AUDIO_DEFAULT               124
#define IDS_DEFAULT_INPUT               124
#define IDS_DEFAULT_OUTPUT              125
#define IDD_ENVIRONMENT                 125
#define IDS_CURRENT_USER                126
#define IDD_VOCAB                       126
#define IDD_DICT_RULES                  127
#define IDS_DESCRIPT                    127
#define IDS_LANG_DESC                   128
#define IDI_PEOPLE                      129
#define IDS_VEND_DESC                   129
#define IDD_SR_ADV                      130
#define IDS_DATE_ADV                    130
#define IDI_VOL                         132
#define IDS_DUP_NAME                    132
#define IDS_PREFERRED_INPUT             133
#define IDD_PROF_WIZ                    134
#define IDS_PREFERRED_OUTPUT            134
#define IDD_PROF_PROP                   136
#define IDS_SPECIFIC_INPUT              137
#define IDD_ABOUT                       137
#define IDS_SPECIFIC_OUTPUT             138
#define IDI_SAPICPL                     138
#define IDS_ENGINE_LIST_NAME            139
#define IDS_VOICE_LIST_NAME             140
#define IDS_PROFILE_LIST_NAME           141
#define IDS_ASK_CONFIRM                 142
#define IDS_ASK_TITLE                   143
#define IDS_PROPERTIES                  144
#define IDS_RENAME                      145
#define IDS_CONTEXT_WARNING             146
#define IDS_GETTOK_WARNING              147
#define IDS_AUDIO_WARNING               148
#define IDS_FORMAT_WARNING              149
#define IDS_METER_WARNING               150
#define IDS_DEFAULT_WARNING             151
#define IDS_DEFAULT_ENGINE_WARNING      151
#define IDS_UISUPPORT_WARNING           152
#define IDS_RECOSET_WARNING             153
#define IDS_CTXT_WARNING                154
#define IDS_WNDMESS_WARNING             155
#define ID_CONTROL_PANEL_GRAMMAR        156
#define IDS_REMOVE_WARNING              157
#define IDS_AUDIO_DEVICE_WARNING        159
#define IDS_ENGINE_IN_USE_WARNING       160
#define IDS_RECOSTATE_PROBLEM           161
#define IDS_PROFILE_WARNING             162
#define IDS_CANNOTAPPLY                 163
#define IDS_OUTOFMEMORY                 164
#define IDS_AUDIO_CHANGE_FAILED         166
#define IDS_COINITIALIZE_FAILED         167
#define IDD_SPEECH                      206
#define IDC_MIC                         214
#define IDC_TREE                        1002
#define IDC_PROPERTIES                  1004
#define IDC_ABOUT                       1005
#define IDC_TRAINING                    1006
#define IDC_USERTRAINING                1006
#define IDC_PRONUNCIATION               1007
#define IDC_FUNC_TRACE                  1007
#define IDC_AUD_IN                      1007
#define IDC_PARAM_INFO                  1008
#define IDC_SPECIALHANDLING             1009
#define IDC_DUMP_INFO                   1009
#define IDC_DEF_VOICE                   1010
#define IDC_EDIT_SPEAK                  1017
#define IDC_SPEAK                       1019
#define IDC_MMINPUT_COMBO               1020
#define IDC_SET_AS_CURRENT              1020
#define IDC_RUN_MICWIZ                  1022
#define IDC_SHARE_INPUT                 1023
#define IDC_ENGINE_DEFAULT              1024
#define IDC_ENABLE_CHECK                1025
#define IDC_STANDARD_IN                 1026
#define IDC_THIS_IN                     1027
#define IDC_STANDARD_IN_CB              1028
#define IDC_DEFAULT_INPUT               1028
#define IDC_THIS_IN_CB                  1029
#define IDC_INPUT_SETTINGS              1030
#define IDC_DEFAULT_OUTPUT              1031
#define IDC_SR_ENGINE                   1032
#define IDC_BUTTON1                     1033
#define IDC_MICWIZ                      1033
#define IDC_OUTPUT_SETTINGS             1033
#define IDC_CREATE_USER                 1033
#define IDC_ADD_LANG                    1033
#define IDC_ADD_USER                    1033
#define IDC_RESTORE                     1033
#define IDC_BUILDER                     1033
#define IDC_MODIFY_OLD                  1033
#define IDC_ABOUT_HELP                  1033
#define IDC_PREFERRED_INPUT             1034
#define IDC_PREFERRED_MM_INPUT          1034
#define IDC_ADD                         1034
#define IDC_TESTMIC                     1034
#define IDC_THIS_INPUT                  1035
#define IDC_SR_ADV                      1035
#define IDC_DELETE_OLD                  1035
#define IDC_PREFERRED_OUTPUT            1036
#define IDC_PREFERRED_MM_OUTPUT         1036
#define IDC_EXPORT                      1036
#define IDC_DELETE                      1036
#define IDC_THIS_OUTPUT                 1037
#define IDC_IMPORT                      1037
#define IDC_MODIFY                      1037
#define IDC_IGNORE_ASSERTS              1038
#define IDC_DELETE_USER                 1041
#define IDC_USER_PROPS                  1042
#define IDC_USER_LIST                   1043
#define IDC_USER_NAME                   1044
#define IDC_USER_SAVE                   1044
#define IDC_SET_DEFAULT                 1044
#define IDC_FEMALE                      1045
#define IDC_MALE                        1046
#define IDC_AGE                         1047
#define IDC_LANG_LIST                   1048
#define IDC_DEL_LANG                    1049
#define IDC_COMBO_AGE                   1050
#define IDC_COMBO2                      1051
#define IDC_COMBO_GENDER                1051
#define IDC_SLIDER1                     1052
#define IDC_COMBO4                      1054
#define IDC_EDIT_LCID                   1056
#define IDC_DEF_STATUS                  1057
#define IDC_ENGINEPROPERTIES            1058
#define IDC_LIST_TTS                    1064
#define IDC_CURRENTUSER                 1065
#define IDC_DIRECTIONS                  1066
#define IDC_GROUP_PREVIEWVOICE          1068
#define IDC_GROUP_VOICESPEED            1069
#define IDC_SLIDER_SPEED                1070
#define IDC_THIS_DEVICE                 1071
#define IDC_THIS_DEVICE2                1072
#define IDC_PREFERRED_MM_DEVICE         1073
#define IDC_DEFAULT_DEVICE              1074
#define IDC_AUDIO_GROUPBOX              1075
#define IDC_USER                        1077
#define IDC_ENGINES                     1080
#define IDC_LAST_TRAIN_DATE             1082
#define IDC_ADVICE                      1083
#define IDC_PROGRESS1                   1084
#define IDC_PRON_SENS                   1087
#define IDC_ACC_RRT                     1088
#define IDC_DATE_ADV                    1089
#define IDC_COMBO1                      1090
#define IDC_COMBO_VOICES                1090
#define IDC_TTS_ADV                     1091
#define IDC_VEDITOR                     1092
#define IDC_LANG_COMBO                  1093
#define ID_NEXT                         1094
#define IDC_PROF_ICON                   1099
#define IDC_PROF_CAPTION                1100
#define IDC_PROF_GROUP                  1101
#define IDC_SR_ICON                     1102
#define IDC_SR_CAPTION                  1103
#define IDC_SR_LIST_CAP                 1104
#define IDC_TRAIN_GROUP                 1105
#define IDC_IN_GROUP                    1106
#define IDC_MIC_CAP                     1107
#define IDC_MIC_INST                    1108
#define IDC_TTS_ICON                    1109
#define IDC_TTS_CAP                     1110
#define IDC_SLOW                        1111
#define IDC_NORMAL                      1112
#define IDC_FAST                        1113
#define IDC_VOCAB_GRP                   1114
#define IDC_VOCAB_ICON1                 1115
#define IDC_VOCAB_ICON2                 1116
#define IDC_BLD_INST                    1117
#define IDC_EDT_CAP                     1118
#define IDC_MIC_ICON                    1120
#define IDC_TRN_ADVICE                  1121
#define IDC_CUSTOM1                     1124
#define IDC_AUDIO_PROPERTIES            1125
#define IDS_AUDIO_PROPERTIES            1126
#define IDS_VOLUME                      1127
#define IDD_AUDIO_PROPERTIES            1128
#define IDC_ADVANCED_GROUPBOX           1129
#define IDC_AUTOMATIC_MM_LINE           1130
#define IDC_THIS_MM_LINE                1131
#define IDC_MM_LINE                     1132
#define IDC_THIS_MM_LINE2               1133
#define IDS_ADVANCED_GROUPBOX           1134
#define IDS_AUTOMATIC_MM_LINE           1135
#define IDS_THIS_MM_LINE                1136
#define IDC_DEVICE_NAME                 1137
#define IDS_THIS_MM_LINE2               1137
#define IDS_DEVICE_NAME                 1138
#define IDS_AUDIO_VOLUME                1139
#define IDC_COMBO_RECOGNIZERS           1140
#define IDS_ENGINE_SWITCH_ERROR         1140
#define IDS_RECOPROFILE_ADD_ERROR       1141
#define IDS_DEFAULT_PROFILE_NAME        1142
#define IDS_UNNAMED_RECOPROFILE         1143
#define IDC_VERSION_STATIC              1143
#define IDS_TTS_ERROR                   1144
#define IDC_STATC_SAPIVER               1144
#define IDC_STATIC_SAPIVER              1144
#define IDS_SPEAK_ERROR                 1145
#define IDC_CPL_SAPI4                   1145
#define IDS_NO_DEVICES                  1146
#define IDC_GROUP_SAPI4                 1146
#define IDS_INPUT                       1147
#define IDC_STATIC_SAPI4                1147
#define IDS_OUTPUT                      1148
#define IDS_SAPI_VERSION                1149
#define IDS_AUDIOIN_CHANGE_WARNING      1150
#define IDS_AUDIOOUT_CHANGE_WARNING     1151
#define IDS_DUP_NAME_DELETED            1152
#define IDS_TTSUI_ERROR                 1153
#define IDS_STRING1154                  1154
#define IDS_NO_IE5                      1155
#define IDS_SPECIFIC_INPUT2             1156
#define IDS_SPECIFIC_OUTPUT2            1157
#define IDS_UNSUPPORTED_LANG		1158
#define IDS_MAX_PROFILES_EXCEEDED	1159

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1148
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\silence.cpp ===
/*********************************************************************
Silence.Cpp - Code for detecting silence on an incoming audio stream

begun 5/14/94 by Mike Rozak
Modified 12/10/96 by John Merrill to fix up alignment problems
*/


#include "stdafx.h"
#include <malloc.h>
#include "silence.h"

// temporary
#pragma warning(disable: 4100 4244) 

/*********************************************************************
LowPassFilter - This low-pass filters 16-bit mono PCM data from one
   buffer into another.

inputs
   short    *lpSrc - Source buffer
   DWORD    dwNumSamples - Number of samples in the source buffer
   short    *lpDst - Destination buffer. This will be filled in
               with a low-passed version. It will have about an 8
               sample lag. This must be as large as lpSrc.
   short    *psMax - Filled in with the new maximum.
               If NULL then nothing is copied.
   short    *psMin - Filled in with the new minimum
               If NULL then nothing is copied.
   short    *psAvg - Filled in with the new average
               If NULL then nothing is copied.
   DWORD    dwSamplesPerSec
returns
   DWORD - Number of samples returned. This will be <= dwNumSamples,
      possible dwNumSamples - 7.
*/
DWORD LowPassFilter (short *lpSrc, DWORD dwNumSamples, short *lpDst,
   short *psMax, short *psMin, short *psAvg, DWORD dwSamplesPerSec)
{
    SPDBG_FUNC( "LowPassFilter" );
DWORD    i;
long     lSum;
short    sSum, sMax, sMin;
short    *lpLag;
BOOL     fLow = (dwSamplesPerSec < 13000);

#define  SHIFTRIGHT        (fLow ? 3 : 4)   // # bits to shift right.
#define  WINDOWSIZE        (1 << SHIFTRIGHT)   // # samples

if (dwNumSamples < (DWORD) (WINDOWSIZE+1))
   return 0;

// take the first 8 samples and average them together.
lSum = 0;
for (i = 0; i < (DWORD) WINDOWSIZE; i++)
   lSum += lpSrc[i];
sSum = (short) (lSum >> SHIFTRIGHT);

//loop through the rest of the samples
lpLag = lpSrc;
lpSrc += WINDOWSIZE;
dwNumSamples -= WINDOWSIZE;
lSum = 0;   // total
sMax = -32768;
sMin = 32767;
for (i = 0;dwNumSamples; lpSrc++, lpDst++, lpLag++, i++, dwNumSamples--) {
   sSum = sSum - (*lpLag >> SHIFTRIGHT) + (*lpSrc >> SHIFTRIGHT);
   // sSum = *lpSrc; // Dont do any filtering at all
   *lpDst = sSum;
   lSum += sSum;
   if (sSum > sMax)
      sMax = sSum;
   if (sSum < sMin)
      sMin = sSum;
   };

// whow much did we do
if (psMax)
   *psMax = sMax;
if (psMin)
   *psMin = sMin;
if (psAvg && i)
   *psAvg = (short) (lSum / (long) i);
return i;
}


/*********************************************************************
QuantSamples - This quantizes the samples to +1, 0, or -1 (in place),
   depedning if the given value is:
      > sPositive then +1
      < sNegative then -1
      else 0

inputs
   short       *pSamples - Samples
   DWORD       dwNumSamples - Number of samples
   short       sPositive - Positive threshhold
   short       sNegative - Negative threshhold
returns
   none
*/
void QuantSamples (short *pSamples, DWORD dwNumSamples,
   short sPositive, short sNegative)
{
    SPDBG_FUNC( "QuantSamples" );
while (dwNumSamples) {
   if (*pSamples > sPositive)
      *pSamples = 1;
   else if (*pSamples < sNegative)
      *pSamples = -1;
   else
      *pSamples = 0;
   pSamples++;
   dwNumSamples--;
   };
}

/*********************************************************************
FindZC - This searches through the samples for the first zero crossing.
   The returned point will have its previous sample at <= 0, and the
   new one at >0.

inputs
   short       *pSamples - Samples;
   DWORD       dwNumSamples - Number of samples
returns
   DWORD - first sampe number which is positive, or 0 if cant find
*/
DWORD FindZC (short *pSamples, DWORD dwNumSamples)
{
    SPDBG_FUNC( "FindZC" );
DWORD i;

for (i = 1; i < dwNumSamples; i++)
   if ((pSamples[i] > 0) && (pSamples[i-1] <= 0))
      return i;

// else cant find
return 0;
}


/*********************************************************************
CompareSegments - This compares two wave segments and sees how much
   alike they are, returning a confidence that they are the same.

inputs
   short       *pA - Samples. This assumes that the samples
                  are -1, 0, or +1.
   short       *pB - Samples for B. Should be -1, 0, or +1
   DWORD       dwNumSamples - Number of samples in each of them
returns
   WORD - Confidence from 0 to 0xffff (highest confidence)

Notes about the algo: Each sample will score a "similarity point"
for like signs, or if one of the values is a 0.
*/
WORD CompareSegments (short *pA, short *pB, DWORD dwNumSamples)
{
    SPDBG_FUNC( "CompareSegments" );
DWORD    dwSimilar = 0;
DWORD    dwLeft;

for (dwLeft = dwNumSamples; dwLeft; pA++, pB++, dwLeft--)
   if ((*pA == *pB) || (*pA == 0) || (*pB == 0))
      dwSimilar++;

return (WORD) ((dwSimilar * 0xffff) / dwNumSamples);
}


/*********************************************************************
FindMostLikelyWaveLen - This Searches through wave data and finds the
   most likeley wavelength for voiced audio. it returns a condifence
   score from 0 to ffff (ffff is 100% positive).

inputs
   short       *pSamples - Samples
   DWORD       dwNumSamples - Number of samples
   DWORD       dwMinWaveLen - Minimum accepatble wavelength
   DWORD       dwMaxWaveLen - Maximum acceptable wavelength
   WORD       *pwConfidence - Filled in with confidence rating.
returns
   DWORD - Wavelength found. 0 if can't deteermine anything
*/
DWORD FindMostLikelyWaveLen (short *pSamples, DWORD dwNumSamples,
   DWORD dwMinWaveLen, DWORD dwMaxWaveLen, WORD *pwConfidence)
{
    SPDBG_FUNC( "FindMostLikelyWaveLen" );
#define     NUMCOMP     (3)
DWORD    dwFirstZC, i;
DWORD    dwBestWaveLen;
WORD     wBestConfidence;
DWORD    dwCurZC, dwCurWaveLen, dwTemp;
WORD     wConf, wTemp;

// Step one, find the first zero crossing
dwFirstZC = FindZC (pSamples, dwNumSamples);
if (!dwFirstZC)
   return 0;   // error

// Start at a minimum-wavelength away and start finding a wave
// which repeats three times and compares well.
dwBestWaveLen = 0;   // best wavelength found so far
wBestConfidence = 0; // confidence of the best wavelength
dwCurWaveLen = dwMinWaveLen;
while (dwCurWaveLen <= dwMaxWaveLen) {
   // Try the first comparison
   dwCurZC = dwFirstZC + dwCurWaveLen;
   if (dwCurZC >= dwNumSamples)
      break;   // no more samples left

   // find first zero crossing from the current wavelen
   dwTemp = FindZC (pSamples + dwCurZC, dwNumSamples - dwCurZC);
   if (!dwTemp)
      break;      // no more samples left
   dwCurZC += dwTemp;
   dwCurWaveLen += dwTemp;

   // Make sure that we have three wavelength's worth
   if ((dwFirstZC + (NUMCOMP+1)*dwCurWaveLen) >= dwNumSamples)
      break;   // cant compare this

   // Do two confidence tests and multiply them toegther to
   // get the confidence for this wavelength
   wConf = 0xffff;
   for (i = 0; i < NUMCOMP; i++) {
      wTemp = CompareSegments (pSamples + dwFirstZC /* + i * dwCurWaveLen */,
         pSamples + (dwFirstZC + (i+1) * dwCurWaveLen), dwCurWaveLen);
      wConf = (WORD) (((DWORD) wConf * (DWORD) wTemp) >> 16);
      };

   // If we're more confident about this one than others then use it
   if (wConf >= wBestConfidence) {
      wBestConfidence = wConf;
      dwBestWaveLen = dwCurWaveLen;
      };

   // Up the current wavelength just a tad
   dwCurWaveLen++;
   };

*pwConfidence = wBestConfidence;
return dwBestWaveLen;
}

/*********************************************************************
IsSegmentVoiced - This detects if the segment if voiced or not.

inputs
   short       *pSamples - Sample data
   DWORD       dwNumSamples - number of samples
   DWORD       dwSamplesPerSec - Number of sample sper second
   WORD        wMinConfidence - Minimum condifence
returns
   BOOL - TRUE if its definately voiced, FALSE if not or cant tell
*/

BOOL CSilence::IsSegmentVoiced (short *pSamples, DWORD dwNumSamples,
   DWORD dwSamplesPerSec, WORD wMinConfidence, short *asFiltered)
{
    SPDBG_FUNC( "CSilence::IsSegmentVoiced" );
//#define     FILTERNUM      (1024)      // max # samples i nthe filter
//#define     MAXVOICEHZ     (300)       // maximum voicce pitchm in hz
//#define     MINVOICEHZ     (50)        // minimum voice pitch in hz
// #define     MINCONFIDENCE  (0x6000)    // minimum confidence
   // This means that 70% of the samples line up from one wavelength
   // to another

DWORD    dwNumFilter;
//short    asFiltered[FILTERNUM];
short    sMax, sMin, sAvg;
DWORD    dwWaveLen;
WORD     wConfidence;
short    sPositive, sNegative;

// Filter it first so we just get the voiced audio range
if (dwNumSamples > FILTERNUM)
   dwNumSamples = FILTERNUM;
dwNumFilter = LowPassFilter (pSamples, dwNumSamples, asFiltered,
  &sMax, &sMin, &sAvg, m_dwSamplesPerSec);

// Truncate the wave samples to +1, 0, -1
sPositive = sAvg;
sNegative =  sAvg;
QuantSamples (asFiltered, dwNumFilter, sPositive, sNegative);

// look through the voiced wavelengths for a frequency
dwWaveLen = FindMostLikelyWaveLen (asFiltered, dwNumFilter,
   dwSamplesPerSec / m_dwHighFreq, dwSamplesPerSec / MINVOICEHZ,
   &wConfidence);

return (dwWaveLen && (wConfidence >= wMinConfidence));
}




/*********************************************************************
TrimMaxAmp - This extracts the maximum amplitude range of the wave file
	segment.

inputs
	short *	lpS - samples to look through
	WORD		dwNum - number of samples
returns
	WORD - maximum amplitude range
*/
WORD NEAR PASCAL TrimMaxAmp (short * lpS, DWORD dwNum)
{
    SPDBG_FUNC( "TrimMaxAmp" );
DWORD i;
short	sMin, sMax, sTemp;

sMin = 32767;
sMax = (short) -32768;
for (i = dwNum; i; i--) {
   sTemp = *(lpS++);
	if (sTemp < sMin)
		sMin = sTemp;
	if (sTemp > sMax)
		sMax = sTemp;
	};

// If we're clipping at all then claim that we've maxed out.
// Some sound cards have bad DC offsets
if ((sMax >= 0x7f00) || (sMin <= -0x7f00))
   return 0xffff;

return (WORD) (sMax - sMin);
}

/********************************************************************
TrimMaxAmpDelta - This extracts the maximum amplitude range and 
                  calculates the maximum delta of the wave file
	               segment.

inputs
   PBLOCKCHAR  pBlockChar - Pointer to a block characteristic
            structure which is filled in. 
	short *	lpS - deltas to look through
	WORD		dwNum - number of samples
returns
	nothing
*/
void TrimMaxAmpDelta(PBLOCKCHAR pBlockChar, short *lpS, DWORD dwNum)
{
    SPDBG_FUNC( "TrimMaxAmpDelta" );
   DWORD i;
   WORD wMax = 0;
   WORD wTemp;
   short sMin, sMax, sCur, sLast;

   // BUGFIX:  4303 Merge TrimMaxAmp and TrimMaxDelta
   sLast = sMin = sMax = *(lpS++);
   for (i = dwNum - 1; i; i--, sLast = sCur) {
      sCur = *(lpS++);
      // TrimMaxAmp
      if (sCur < sMin)
         sMin = sCur;
      if (sCur > sMax)
         sMax = sCur;

      // TrimMaxDelta
      wTemp = sCur > sLast ? (WORD) (sCur - sLast) : (WORD) (sLast - sCur);
      if (wTemp > wMax)
         wMax = wTemp;

   }
   // If we're clipping at all then claim that we've maxed out.
   // Some sound cards have bad DC offsets
   pBlockChar->wMaxLevel = ((sMax >= 0x7F00) || (sMin <= -0x7F00)) ? 0xFFFF : (WORD) (sMax - sMin);
   pBlockChar->wMaxDelta = wMax;
} /* End of TrimMaxAmpDelta() */ 

         
/*********************************************************************
GetBlockChar - This gets the characteristics of a block of audio.
   This characteristics can then be used to determine if the block
   is silent or not.

inputs
   short    *lpS - sample data
   DWORD    dwNum - number of samples
   PBLOCKCHAR  pBlockChar - Pointer to a block characteristic
            structure which is filled in. 
   BOOL     fTestVoiced - Voicce testing will only be done if
            this is TTRUE (in order to save processor).
returns
   none
*/
void GetBlockChar(short *lpS, DWORD dwNum, PBLOCKCHAR pBlockChar, BOOL fTestVoiced)
{
    SPDBG_FUNC( "GetBlockChar" );
   // BUGFIX:  4303 Merge TrimMaxAmp and TrimMaxDelta
   TrimMaxAmpDelta(pBlockChar, lpS, dwNum);
   pBlockChar->bIsVoiced = pBlockChar->bHighLevel =
      pBlockChar->bHighDelta = SIL_UNKNOWN;
}


/*********************************************************************
IsBlockSound - This detects whether the block is silent or not.

inputs
   PBLOCKCHAR  pBlockInQuestion - Block in question. This has the
      bHighLevel and bHighDelta flags modified
   PBLOCKCHAR  pBlockSilence - Silent block  
   BOOL        fInUtterance - TRUE if we're in an utterance (which
            means be more sensative), FALSE if we're not
returns
   BOOL - TTRUE if has sound, FALSE if it is silent
*/
BOOL IsBlockSound (PBLOCKCHAR pBlockInQuestion, PBLOCKCHAR pBlockSilence,
   BOOL fInUtterance)
{
    SPDBG_FUNC( "IsBlockSound" );
#ifdef SOFTEND // Use so that catches a soft ending to phrases
#define     SENSINV_THRESHHOLD_LEVEL(x)     (((x)/4)*3)
#define     SENSINV_THRESHHOLD_DELTA(x)     (((x)/4)*3)
#else
#define     SENSINV_THRESHHOLD_LEVEL(x)     ((x)/2)
#define     SENSINV_THRESHHOLD_DELTA(x)     ((x)/2)
#endif
#define     NORMINV_THRESHHOLD_LEVEL(x)     ((x)/2)
#define     NORMINV_THRESHHOLD_DELTA(x)     ((x)/2)

if (fInUtterance) {
   pBlockInQuestion->bHighLevel =
      SENSINV_THRESHHOLD_LEVEL(pBlockInQuestion->wMaxLevel) >= pBlockSilence->wMaxLevel;
   pBlockInQuestion->bHighDelta =
      SENSINV_THRESHHOLD_DELTA(pBlockInQuestion->wMaxDelta) >= pBlockSilence->wMaxDelta;
   }
else {
   pBlockInQuestion->bHighLevel =
      NORMINV_THRESHHOLD_LEVEL(pBlockInQuestion->wMaxLevel) >= pBlockSilence->wMaxLevel;
   pBlockInQuestion->bHighDelta =
      NORMINV_THRESHHOLD_DELTA(pBlockInQuestion->wMaxDelta) >= pBlockSilence->wMaxDelta;
   };


return pBlockInQuestion->bHighLevel || pBlockInQuestion->bHighDelta;
}


/*********************************************************************
ReEvaluateSilence - This takes the values used for silence and re-evaluates
   them based upon new data which indicates what silence is. It
   automatically adjusts to the noise level in the room over a few seconds.
   NOTE: This should not be called when an utterance is happening, or
   when it might be starting.

inputs
   PBLOCKCHAR     pSilence - This is the silence block, and should
                     start out with values in it. It will be modified
                     so to incorporate the new silence information.
   PBLOCKCHAR     pNew - New block which is known to be silence.
   BYTE           bWeight - This is the weighting of the new block
                     in influencing the old block, in a value from 0 to 255.
                     256 means that the value of the new silence completely
                     overpowers the old one, 0 means that it doesnt have
                     any affect.
returns
   none
*/
void ReEvaluateSilence (PBLOCKCHAR pSilence, PBLOCKCHAR pNew,
   BYTE bWeight)
{
    SPDBG_FUNC( "ReEvaluateSilence" );
#define  ADJUST(wOrig,wNew,bWt)                 \
   (WORD) ((                                    \
      ((DWORD) (wOrig) * (DWORD) (256 - (bWt))) + \
      ((DWORD) (wNew) * (DWORD) (bWt))          \
      ) >> 8);

pSilence->wMaxLevel = ADJUST (pSilence->wMaxLevel,
   pNew->wMaxLevel, bWeight);
pSilence->wMaxDelta = ADJUST (pSilence->wMaxDelta,
   pNew->wMaxDelta, bWeight);

// If it's way too silence (and too good to be true) then assume
// a default silece
// if (!pNew->wMaxLevel && !pNew->wMaxDelta) {
//   if (pSilence->wMaxLevel < 2500)
//      pSilence->wMaxLevel = 2500;
//   if (pSilence->wMaxDelta < 400)
//       pSilence->wMaxDelta = 400;
//   }
}

/*********************************************************************
WhatsTheNewState - This takes in a stream of bit-field indicating which
   of the last 32 blocks were detected as having sound, and what our
   state was the last time this was called (utterance or not). It then
   figureous out if we're still in an utterance, or we just entered one.
   It also says how many buffers ago that was.

inputs
   DWORD    dwSoundBits - This is a bit-field of the last 32
               audio blocks. A 1 in the field indicates that there was
               sound there, a 0 indicates no sound. The low bit
               corresponds to the most recent block, and high bit
               the oldest.
   DWORD    dwVoicedBits - Just like sound bits except that it indicates
               voiced sections of sound.
   BOOL     fWasInUtterance - This is true is we had an utterance
               the last time this called, FALSE if there was silence
   BOOL     fLongUtterance - If this is a long utterance then dont
               react for 1/4 second, otherwise use 1/8 second for
               short utterance
   WORD     wBlocksPerSec - How many of the above-mentioned blocks
               fit into a second.
   WORD     *wStarted - If a transition occurs from no utterance to
               an utterance, then this fills in the number of of blocks
               ago that the utterance started, into *wStarted. Otherwise
               it is not changed.
   WORD     wReaction - Reaction time (in blocks) after an utterance is
               finished
returns
   BOOL - TRUE if we're in an utterance now,  FALSE if we're in silence
*/

BOOL CSilence::WhatsTheNewState (DWORD dwSoundBits, DWORD dwVoicedBits,
   BOOL fWasInUtterance, BOOL fLongUtterance,
   WORD wBlocksPerSec, WORD *wStarted, WORD wReaction)
{
    SPDBG_FUNC( "CSilence::WhatsTheNewState" );
WORD wCount, wOneBits;
WORD  wTimeToCheck;
DWORD dwTemp, dwMask;

if (fWasInUtterance)
   wTimeToCheck = wReaction;
else
   wTimeToCheck = (wBlocksPerSec/4);   // 1/4 second
if (!wTimeToCheck)
   wTimeToCheck = 1;


for (wOneBits = 0, wCount = wTimeToCheck, dwTemp = dwSoundBits;
      wCount;
      dwTemp /= 2, wCount--)
   if (dwTemp & 0x01)
      wOneBits++;

if (fWasInUtterance) {
   // If we were in an utterance, then we still are in an utterance
   // UNLESS the number of bits which are turned on for the last
   // 0.5 seconds is less that 1/4 of what should be turned on.
   if ( (wOneBits >= 1))
      return TRUE;
   else
      return FALSE;
   }
else {
   // We are in silence. We cannot possible go into an utterance
   // until the current block is voicced
   if (!(dwVoicedBits & 0x01))
      return FALSE;

   // If we were in silence then we're still in silence
   // UNLESS the number of bits which are turned on for the last
   // 0.5 seconds is more than 1/2 of what should be turned on.
   // If so, then start the utterance 0.75 seconds ago.
   if (wOneBits >= (wTimeToCheck / 2)) {
      // we're not in an utterance

      // Look back until get 1/8 second of silence, and include
      // that in the data returned
      dwTemp = dwSoundBits;
 //     dwMask = (1 << (wBlocksPerSec / 8)) - 1;
 //     for (wCount = wBlocksPerSec/8; dwTemp & dwMask; dwTemp >>= 1, wCount++);
      dwMask = (1 << (wBlocksPerSec / m_wAddSilenceDiv)) - 1;
      for (wCount = wBlocksPerSec/m_wAddSilenceDiv; dwTemp & dwMask; dwTemp >>= 1, wCount++);

      *wStarted = wCount;

      return TRUE;
      }
   else
      return FALSE;
   };

}


/*********************************************************************
CSilence::CSilence - This creates the silence class.

inputs
   WORD     wBlocksPerSec - Number of blocks per second. The blocks
               will be passed down through AddBlock().
returns
   class
*/
CSilence::CSilence (WORD wBlocksPerSec)
{
    SPDBG_FUNC( "CSilence::CSilence" );
m_wBlocksPerSec = min(wBlocksPerSec, 32); // no more than the # bits in a DWORD
m_wBlocksInQueue = m_wBlocksPerSec;   // 1 second worth.
m_wLatestBlock = 0;
m_paBlockInfo = NULL;
m_dwSoundBits = m_dwVoicedBits = 0;
m_fFirstBlock = TRUE;
m_fInUtterance = FALSE;
m_dwUtteranceLength = 0;
m_dwSamplesPerSec = 11025;
}

/*********************************************************************
CSilence::~CSilence - Free up everything.
*/
CSilence::~CSilence (void)
{
    SPDBG_FUNC( "CSilence::~CSilence" );
   WORD  i;

   if (m_paBlockInfo) {
      for (i = 0; i < m_wBlocksInQueue; i++)
         if (m_paBlockInfo[i].pSamples)
            free(m_paBlockInfo[i].pSamples);
      free(m_paBlockInfo);
   }

   if (m_pASFiltered)
      free(m_pASFiltered);
}

/*********************************************************************
CSilence::Init - This initializes the silence code. It basically
   allocates memory. It should be called immediately after the object
   is created and then not again.

inputs
   none
returns
   BOOL - TRUE if succeded, else out of memory
*/
BOOL CSilence::Init(BOOL fPhoneOptimized, DWORD dwSamplesPerSec)
{
    SPDBG_FUNC( "CSilence::Init" );
   m_dwSamplesPerSec = dwSamplesPerSec;
   if (fPhoneOptimized) {
   	m_wAddSilenceDiv = (WORD) PHADD_BEGIN_SILENCE;
	   m_dwHighFreq = PHMAXVOICEHZ;
	}
   else {
   	m_wAddSilenceDiv = (WORD) PCADD_BEGIN_SILENCE;
	   m_dwHighFreq = PCMAXVOICEHZ;
	}
   if ((m_pASFiltered = (short *) malloc((sizeof(short)) * FILTERNUM)) == NULL)
	   return (FALSE);

   // Initialize memory for the blocks and clear it.
   if (m_paBlockInfo)
      return (TRUE);
   m_paBlockInfo = (PBINFO) malloc(m_wBlocksInQueue * sizeof(BINFO));
   if (!m_paBlockInfo)
      return (FALSE);
   if (m_wBlocksInQueue && m_paBlockInfo)
      memset(m_paBlockInfo, 0, m_wBlocksInQueue * sizeof(BINFO));
   return (TRUE);
} /* End of Init() */

/*********************************************************************
CSilence::AddBlock - This does the following:
   - Add the block the the queue. Free up an old block if needed.
      The block should be 1/wBlocksPerSec long (about).
   - Analyze the block to see if its got sound or is quiet.
   - Fill in *wVU with a VU level.
   - Return TRUE if we're in an utterance, FALSE if its silence now.
      If TRUE then app should call GetBlock() until no more blocks left,
      and pass them to the SR engine.

inputs
   short    *pSamples - Pointer to samples. This memory should
               be allocaed with malloc(), and may be freed by the
               object.
   DWORD    dwNumSamples - Number of samples
   WORD     *wVU - This is fille in with the VU meter for the block
   QWORD	qwTimeStamp - Time stamp for this buffer.
returns
   BOOL - TRUE if an utterance is taking place, FALSE if its silent
*/
BOOL CSilence::AddBlock (short *pSamples, DWORD dwNumSamples,
   WORD *wVU, QWORD qwTimeStamp)
{
    SPDBG_FUNC( "CSilence::AddBlock" );
BLOCKCHAR      bcNew;
BOOL           fSound, fUtt;
PBINFO         pbInfo;
WORD           wUttStart, i;

// Dont add empty blocks
if (!dwNumSamples) {
   if (pSamples)
      free (pSamples);
   return m_fInUtterance;
   };

// Analyze the block for characteristics.
GetBlockChar (pSamples, dwNumSamples, &bcNew, !m_fInUtterance);

// fill in the vu
*wVU = bcNew.wMaxLevel;

// see if it's silent or not
if (m_fFirstBlock) {
   // first block, so of course its silent
   m_bcSilence = bcNew;
   m_fFirstBlock = FALSE;
   fSound = FALSE;

   // BUGFIX 2466 - If it's way too silence (and too good to be true) then assume
   // a default silece
   if ((m_bcSilence.wMaxLevel < 500) || (m_bcSilence.wMaxDelta < 100)) {
      m_bcSilence.wMaxLevel = 2500;
      m_bcSilence.wMaxDelta = 400;
      };

   // If it's way too loud then cut down
   if ((m_bcSilence.wMaxLevel > 2500) || (m_bcSilence.wMaxDelta > 1500)) {
      m_bcSilence.wMaxLevel = min (m_bcSilence.wMaxLevel, 2500);
      m_bcSilence.wMaxDelta = min (m_bcSilence.wMaxDelta, 1500);
      };
   }
else {
   fSound = IsBlockSound (&bcNew, &m_bcSilence, m_fInUtterance);
   };

// Test to see if the block is voiced if:
//    - The amplitude level is more than background sound
//    - We're not yet in an utterance (to save processor)
if (bcNew.bHighLevel && !m_fInUtterance) {
   WORD  wNoise;
   wNoise = (m_dwSamplesPerSec <= 13000) ?
               m_wNoiseThresh :
               ((m_wNoiseThresh / 3) * 2);

   bcNew.bIsVoiced = this->IsSegmentVoiced (pSamples, dwNumSamples, m_dwSamplesPerSec, wNoise, m_pASFiltered) ?
      SIL_YES : SIL_NO;
}

// add the block
m_dwVoicedBits = (m_dwVoicedBits << 1) |
   ( (bcNew.bIsVoiced  == SIL_YES) ? 1 : 0 );
m_dwSoundBits = (m_dwSoundBits << 1) | (fSound ? 1 : 0);
m_wLatestBlock++;
if (m_wLatestBlock >= m_wBlocksInQueue)
   m_wLatestBlock = 0;
pbInfo = m_paBlockInfo + m_wLatestBlock;
if (pbInfo->pSamples)
   free (pbInfo->pSamples);
pbInfo->pSamples = pSamples;
pbInfo->dwNumSamples = dwNumSamples;

// BUGFIX: Alignment code.  We need to store the timestamp for
// the BEGINNING of the block, not the end!

pbInfo->qwTimeStamp = qwTimeStamp - dwNumSamples * sizeof(WORD);

// What's our utterance state?
fUtt = this->WhatsTheNewState (m_dwSoundBits, m_dwVoicedBits, m_fInUtterance,
   m_dwUtteranceLength >= m_wBlocksPerSec,
   m_wBlocksPerSec, &wUttStart, m_wReaction);
if (fUtt && !m_fInUtterance) {
   // We just entered an utterance, so wUttStart has a valid teerm
   // in it. Go through the buffer queue and free all buffers which
   // are older than wUttStart. Remembeer, this is a circular buffer
   for (i = 0; i < (m_wBlocksInQueue - wUttStart); i++) {
      pbInfo = m_paBlockInfo +
         ( (m_wLatestBlock + i + 1) % m_wBlocksInQueue);
      if (pbInfo->pSamples)
         free (pbInfo->pSamples);
      pbInfo->pSamples = NULL;
      };

   // Since we just entered an utterance clear the utterance length counter
   m_dwUtteranceLength = 0;
   };
m_fInUtterance = fUtt;

// Remember how long this utterance has done on. Long utterances
// deserve more patience as far as silence goes
m_dwUtteranceLength++;

// Adjust the silence level if we're not in an utterance
// Requiring !fSound so that we dont accidentally indclude any
// utterance sections in the sound calculations
if (!m_fInUtterance /* && !fSound */) {
   ReEvaluateSilence (&m_bcSilence, &bcNew,
      255 / m_wBlocksPerSec);
   }
else if (m_dwUtteranceLength >= ((DWORD)m_wBlocksPerSec * 30))
   // if we have a very long utterance (> 30 second) then it's not
   ReEvaluateSilence (&m_bcSilence, &bcNew, 255 / m_wBlocksPerSec);

// done
return m_fInUtterance;
}

/*********************************************************************
CSilence::ExpectNoiseChange - Sent to the silence detection algorithm
   when it should expect the noise floor to go up/down.

inputs
   WORD     wValue - Amount that noise floor should change.
               0x100 = no change. > 0x100 => louder, < 0x100 => quieter
returns
*/
void CSilence::ExpectNoiseChange (WORD wValue)
{
    SPDBG_FUNC( "CSilence::ExpectNoiseChange" );
DWORD dwTemp;

dwTemp = ((DWORD) m_bcSilence.wMaxLevel * wValue) >> 8;
if (dwTemp > 0xffff)
   dwTemp = 0xffff;
m_bcSilence.wMaxLevel = (WORD) dwTemp;

dwTemp = ((DWORD) m_bcSilence.wMaxDelta * wValue) >> 8;
if (dwTemp > 0xffff)
   dwTemp = 0xffff;
m_bcSilence.wMaxDelta = (WORD) dwTemp;
}

/*********************************************************************
CSilence::GetBlock - This gets a block from the queue. This will fail
   if there are no more blocks left to get OR if there's not utterance.

inputs
   DWORD    *pdwNumSamples - If a block is returned then this
            will be filled in with the number of samples in the block.	 
	QWORD	*pqwTimeStamp - Filled in woth the time-stamp for the
			buffer.
returns
   short * - Pointer to a block of samples. This memory is the
         caller's property and can be freed with free().
*/
short * CSilence::GetBlock (DWORD *pdwNumSamples, QWORD * pqwTimeStamp)
{
    SPDBG_FUNC( "CSilence::GetBlock" );
PBINFO         pbInfo;
WORD           i, wCount;
short          *pSamples;

if (!m_fInUtterance)
   return NULL;

// find the first occurance
i = (m_wLatestBlock + 1) % m_wBlocksInQueue;
for (wCount = m_wBlocksInQueue; wCount;
      i = ((i < (m_wBlocksInQueue-1)) ? (i+1) : 0), wCount-- ) {
   pbInfo = m_paBlockInfo + i;
   if (pbInfo->pSamples) {
      *pdwNumSamples = pbInfo->dwNumSamples;
	  *pqwTimeStamp = pbInfo->qwTimeStamp;
      pSamples = pbInfo->pSamples;
      pbInfo->pSamples = NULL;

      return pSamples;
      };
   };

// if got here then couldnt find anything
return NULL;
}

/*********************************************************************
CSilence::KillUtterance - Kills an exitsing utterance.

inputs
   none
returns
   none
*/
void CSilence::KillUtterance (void)
{
    SPDBG_FUNC( "CSilence::KillUtterance" );
m_fInUtterance = FALSE;
m_dwSoundBits = 0;
m_dwVoicedBits = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\silence.h ===
/*********************************************************************
Silence.H - Includes to use the code to detect silence.

begun 5/14/94 by Mike Rozak
*/

#ifndef _SILENCE_H_
#define _SILENCE_H_

#ifndef _SPEECH_
typedef unsigned _int64 QWORD, *PQWORD;

#endif


/*********************************************************************
Typedefs */

#define  SIL_YES              (2)
#define  SIL_NO               (0)
#define  SIL_UNKNOWN          (1)

// #define  SIL_SAMPRATE         (11025)     // assumed sampling rate
#define  PHADD_BEGIN_SILENCE  (4)         // 1/4 second
#define  PCADD_BEGIN_SILENCE  (4)         // 1/4 second
#define  FILTERNUM            (1024)      // max # samples i nthe filter
#if 0
#define  MAXVOICEHZ           (300)       // maximum voice pitchm in hz
#define  PHMAXVOICEHZ         (300)       // maximum voice pitch in hz (phone)
#endif
#define  PHMAXVOICEHZ         (500)       // maximum voice pitch in hz (phone)
#define  PCMAXVOICEHZ         (500)       // maximum voice pitch in hz (PC)
#define  MINVOICEHZ           (50)        // minimum voice pitch in hz

// Store characteristics of a block
typedef struct {
   WORD     wMaxLevel;
   WORD     wMaxDelta;
   BYTE     bIsVoiced;
   BYTE     bHighLevel;
   BYTE     bHighDelta;
} BLOCKCHAR, *PBLOCKCHAR;

// Store information about a block
typedef struct {
   short   *pSamples;     // Sample data, or NULL if empty
   DWORD   dwNumSamples;  // number of samples in block
   QWORD   qwTimeStamp;   // time stamp for block
} BINFO, *PBINFO;

class CSilence {
   private:
      WORD     m_wBlocksPerSec;
      WORD     m_wBlocksInQueue;
      WORD     m_wLatestBlock;   // points to the last block entered in the circular list
      PBINFO   m_paBlockInfo;
      DWORD    m_dwSoundBits;
      DWORD    m_dwVoicedBits;   // turned on if block was voiced
      BLOCKCHAR m_bcSilence;     // what silence is
      BOOL     m_fFirstBlock;    // TRUE if the next block is the first
                                 // block ever, and used to judge silence, else FALSE
      BOOL     m_fInUtterance;   // TRUE if we're in an utterance
      DWORD    m_dwUtteranceLength; // Number of frames that utterance has gone on
      WORD     m_wReaction;      // reaction time
      WORD     m_wNoiseThresh;   // noiuse threshhold
      short    *m_pASFiltered;   // pointer to filtered data buffer
      WORD     m_wAddSilenceDiv;
      DWORD    m_dwHighFreq;
      DWORD    m_dwSamplesPerSec;
#ifdef USE_REG_ENG_CTRL
   BOOL   m_fSilenceDetectEnbl;
   BOOL   m_fVoiceDetectEnbl;
   WORD   m_wTimeToCheckDiv;
   DWORD   m_dwLowFreq;
   DWORD   m_dwCheckThisManySamples;
   DWORD   m_dwNumFilteredSamples;
   WORD   m_wMinConfidenceAdj;
   DWORD   m_dwLPFShift;
   DWORD   m_dwLPFWindow;
#endif

   public:
      CSilence (WORD wBlocksPerSec);
      ~CSilence (void);

      BOOL Init(BOOL fPhoneOptimized, DWORD dwSamplesPerSec);
      BOOL AddBlock (short * pSamples, DWORD dwNumSamples, WORD * wVU,
            QWORD qwTimeStamp);
      short * GetBlock (DWORD * pdwNumSamples, QWORD * pqwTimeStamp);
      void KillUtterance(void);
      void NoiseResistSet (WORD wValue)
         {
         m_wNoiseThresh = wValue;
         };
      void ReactionTimeSet (DWORD dwTime)
         {m_wReaction = (WORD) ((dwTime * m_wBlocksPerSec) / 1000);};
      WORD GetBackgroundNoise (void)
         {return m_bcSilence.wMaxLevel;};
      void ExpectNoiseChange (WORD wValue);

   private:
      BOOL CSilence::IsSegmentVoiced (short *pSamples, DWORD dwNumSamples,
            DWORD dwSamplesPerSec, WORD wMinConfidence, short *asFiltered);
      BOOL CSilence::WhatsTheNewState (DWORD dwSoundBits, DWORD dwVoicedBits,
            BOOL fWasInUtterance, BOOL fLongUtterance,
            WORD wBlocksPerSec, WORD *wStarted, WORD wReaction);
};

typedef CSilence *PCSilence;

WORD NEAR PASCAL TrimMaxAmp(short * lpS, DWORD dwNum);

#endif   // _SILENCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\srdlg.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <sapi.h>
#include <string.h>
#include "SRDlg.h"
#include <spddkhlp.h>
#include <initguid.h>
#include "helpresource.h"
#include "richedit.h"
#include "mlang.h"
#include "Lmcons.h"

static DWORD aKeywordIds[] = {
   // Control ID           // Help Context ID
   IDC_ADD,                 IDH_ADD,
    IDC_MODIFY,         IDH_SETTINGS,
    IDC_DELETE,             IDH_DELETE,
    IDC_TRN_ADVICE,         IDH_NOHELP,
    IDC_USER,               IDH_USER,
    IDC_MIC_ICON,           IDH_NOHELP,
   IDC_COMBO_RECOGNIZERS,   IDH_ENGINES,       
   IDC_SR_ADV,             IDH_SR_ADV,
   IDC_USERTRAINING,       IDH_USERTRAINING,
   IDC_PROGRESS1,          IDH_PROGRESS1,
   IDC_AUD_IN,             IDH_AUD_IN,
   IDC_MICWIZ,             IDH_MICWIZ,
   IDC_SR_ICON,             IDH_NOHELP,
   IDC_SR_CAPTION,          IDH_NOHELP,
   IDC_SR_LIST_CAP,         IDH_NOHELP,
   IDC_TRAIN_GROUP,         IDH_NOHELP,
    IDC_ADVICE,             IDH_NOHELP,
    IDC_IN_GROUP,           IDH_NOHELP,
    IDC_MIC_CAP,            IDH_NOHELP,
    IDC_MIC_INST,           IDH_NOHELP,
   0,                      0
};

/*****************************************************************************
* CSRDlg::CreateRecoContext *
*---------------------------*
*   Description:
*       This creates a new instance of the recognizer with whatever is the 
*       current defaults for the recognizer.
*       The "fInitialize" argument is FALSE by default.  If set, it does
*       NOT attempt to set the m_pCurUserToken reco profile and instead
*       just picks up whatever CoCreateInstance() on the shared recognizer
*       gave it.
*       NOTE: The caller is responsible for displaying error messages to 
*       the user when this fails.
*   Return: 
*       S_OK 
*       Failed HRESULT from recognizer/recocontext initialization functions
****************************************************************** BECKYW ***/
HRESULT CSRDlg::CreateRecoContext(BOOL *pfContextInitialized, BOOL fInitialize, ULONG ulFlags)
{
    // Kill the reco context and notify sink first, if we have one
    if ( m_cpRecoCtxt )
    {
        m_cpRecoCtxt->SetNotifySink( NULL );
    }
    m_cpRecoCtxt.Release();

    HRESULT hr;
    
    // SOFTWARE ENGINEERING OPPORTUNITY (beckyw 8/24): This is a workaround for a 
    // bug that appears to repro only on my dev machine, in which the recostate
    // needs to be inactive for this whole thing.
    if ( m_cpRecoEngine )
    {
        m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
    }

    if ( m_cpRecoEngine )
    {
        SPRECOSTATE recostate;
        hr = m_cpRecoEngine->GetRecoState( &recostate );

        // This is due to a SOFTWARE ENGINEERING OPPORTUNITY in which SetRecognizer( NULL )
        // doesn't work if the recostate is SPRST_ACTIVE_ALWAYS.
        // In this case, we temporarily switch the recostate
        if ( SUCCEEDED( hr ) && (SPRST_ACTIVE_ALWAYS == recostate) )
        {
            hr = m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
        }

        // Kick the recognizer
        if ( SUCCEEDED( hr ) && (ulFlags & SRDLGF_RECOGNIZER) )
        {
            hr = m_cpRecoEngine->SetRecognizer( NULL );
        }

        // Kick the audio input 
        if ( SUCCEEDED( hr )  && (ulFlags & SRDLGF_AUDIOINPUT))
        {
            hr = m_cpRecoEngine->SetInput( NULL, TRUE );
        }

        // Set the recostate back if we changed it.
        if ( (SPRST_ACTIVE_ALWAYS == recostate) )
        {
            HRESULT hrRecoState = m_cpRecoEngine->SetRecoState( recostate );
            if ( FAILED( hrRecoState ) )
            {
                hr = hrRecoState;
            }
        }
    }
    else 
    {
        hr = m_cpRecoEngine.CoCreateInstance( CLSID_SpSharedRecognizer );
    }

    if(!fInitialize && SUCCEEDED( hr ))
    {
        // Normally set to m_pCurUserToken
        // When initializing this is not created yet so just set to default
        hr = m_cpRecoEngine->SetRecoProfile(m_pCurUserToken);
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpRecoEngine->CreateRecoContext(&m_cpRecoCtxt);
    }
    
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpRecoCtxt->SetNotifyWindowMessage(m_hDlg, WM_RECOEVENT, 0, 0);
    }

    if ( SUCCEEDED( hr ) )
    {
        const ULONGLONG ullInterest = SPFEI(SPEI_SR_AUDIO_LEVEL);
        hr = m_cpRecoCtxt->SetInterest(ullInterest, ullInterest);
    }

    // Set the pfContextInitialized flag if everything has gone OK;
    // if something has not gone OK, clean up
    if ( pfContextInitialized )
    {
        // If we got here, the reco context has been initialized
        *pfContextInitialized = SUCCEEDED( hr );
    }
    if ( FAILED( hr ))
    {
        m_cpRecoCtxt.Release();
        m_cpRecoEngine.Release();

        
        return hr;
    }

#ifdef _DEBUG
    // Let's make sure we actually have the right recognizer now
    CComPtr<ISpObjectToken> cpCurDefaultToken; // What it should be
    SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &cpCurDefaultToken);

    CComPtr<ISpObjectToken> cpRecognizerToken;
    m_cpRecoEngine->GetRecognizer( &cpRecognizerToken );
    if ( cpRecognizerToken )
    {
        CSpDynamicString dstrCurDefaultToken;
        cpCurDefaultToken->GetId( &dstrCurDefaultToken );

        CSpDynamicString dstrRecognizerToken;
        cpRecognizerToken->GetId( &dstrRecognizerToken );

        if ( 0 != wcsicmp( dstrCurDefaultToken, dstrRecognizerToken ) )
        {
            OutputDebugString( L"Warning: We just created a recognizer that isn't the default!\n" );
        }
    }
#endif

    // Now turn on the reco state for the volume meter
    hr = m_cpRecoEngine->SetRecoState( SPRST_ACTIVE_ALWAYS );

    return(hr);
}   

/*****************************************************************************
* SortCols *
*-----------*
*   Description:
*       Comparison function for subitems in the reco list
****************************************************************** BRENTMID ***/
int CALLBACK SortCols( LPARAM pToken1, LPARAM pToken2, LPARAM pDefToken )
{
    USES_CONVERSION;

    // Get the names
    CSpDynamicString dstrDesc1;
    CSpDynamicString dstrDesc2;
    SpGetDescription( (ISpObjectToken *) pToken1, &dstrDesc1 );
    SpGetDescription( (ISpObjectToken *) pToken2, &dstrDesc2 );
    
    // First check if there is no description for either one.
    // If there is no description, set it to "<no name>"
    if ( !dstrDesc1.m_psz || !dstrDesc2.m_psz )
    {
        WCHAR szNoName[ MAX_LOADSTRING ];
        szNoName[0] = 0;
        ::LoadString( _Module.GetResourceInstance(), IDS_UNNAMED_RECOPROFILE, szNoName, sp_countof( szNoName ) );
        
        USES_CONVERSION;
        if ( !dstrDesc1 )
        {
            dstrDesc1 = szNoName;
            SpSetDescription( (ISpObjectToken *) pToken1, dstrDesc1 );
        }
        if ( !dstrDesc2 )
        {
            dstrDesc2 = szNoName;
            SpSetDescription( (ISpObjectToken *) pToken2, dstrDesc2 );
        }
    }

    if (pDefToken == pToken1) {
        return -1;   // make sure pToken1 goes to top of list
    }
    else if (pDefToken == pToken2) {
        return 1;    // make sure pToken2 goes to top of list
    }

    return wcscmp(_wcslwr(dstrDesc1.m_psz), _wcslwr(dstrDesc2.m_psz));
}

/*****************************************************************************
* CSRDlg::RecoEvent *
*-------------------*
*   Description:
*       Handles the SR events for the volume meter
****************************************************************** BRENTMID ***/
void CSRDlg::RecoEvent()
{
    CSpEvent event;
    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            if (event.eEventId == SPEI_SR_AUDIO_LEVEL)
            {
                ULONG l = (ULONG)event.wParam;
            
                SendMessage( GetDlgItem ( m_hDlg, IDC_PROGRESS1 ), PBM_SETPOS, l, 0);
            }
        }
    }
}   


/*****************************************************************************
* TrySwitchDefaultEngine *
*------------------------*
*   Description:
*       This function is called when we want to run some UI for the engine
*       the user has selected, but because we don't know which shared engine
*       is running and whether another app is using it we can't directly
*       create the UI. So this method temporarily switches the default recognizer,
*       and recreates the engine, and then checks its token. If another app
*       was using the engine we wouldn't be able to switch and we return S_FALSE.
*       A side effect of this method is that for the duration of the UI, the
*       default will be changed, even though the user hasn't yet pressed apply,
*       but there seems no good way round this.
*
*       In the case that m_pCurRecoToken is actually the same token as the
*       one the currently-active recognizer uses, we don't need to create
*       a new recognizer and recocontext; instead we just return successfully.
*   Return:
*       S_OK
*       FAILED HRESULT of various functions
*           In particular, SPERR_ENGINE_BUSY means that someone else is 
*           running the engine, so this couldn't be done.
****************************************************************** DAVEWOOD ***/
HRESULT CSRDlg::TrySwitchDefaultEngine( bool fShowErrorMessages)
{
    HRESULT hr = S_OK;
    bool fMatch = false;
    
    // Set the new temporary default
    if(SUCCEEDED(hr))
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOGNIZERS, m_pCurRecoToken);
    }

    if ( SUCCEEDED( hr ) && IsRecoTokenCurrentlyBeingUsed( m_pCurRecoToken ) )
    {
        // No need to switch engine all over again: just keep the one in use
        return S_OK;
    }

    // Try to create the engine & context with the default
    // then see if this was actually the engine we expected
    if(SUCCEEDED(hr))
    {
        hr = CreateRecoContext( );
    }

    if ( FAILED( hr ) && fShowErrorMessages )
    {
        WCHAR szError[256];
        szError[0] = '\0';
        
        // What to complain about...
        UINT uiErrorID = HRESULTToErrorID( hr );

        if ( uiErrorID )
        {
            LoadString(_Module.GetResourceInstance(), 
                uiErrorID, 
                szError, sizeof(szError));
            MessageBox(g_pSRDlg->m_hDlg, szError, m_szCaption, MB_ICONWARNING|g_dwIsRTLLayout);
        }
    }

    return hr;
}

/*****************************************************************************
* CSRDlg::ResetDefaultEngine *
*----------------------------*
*   Description:
*       This function resets the engine default back to its original value.
*       If the engine already has the right token, it doesn't bother trying
*       to create the engine again and returns S_OK
*   Return:
*       S_OK
*       S_FALSE if the default was set back but no engine was created
*       FAILED HRESULT of SpSetDefaultTokenForCategoryId()
****************************************************************** DAVEWOOD ***/
HRESULT CSRDlg::ResetDefaultEngine( bool fShowErrorMessages )
{
    HRESULT hr = S_OK;

    // Reset the old default
    if(m_pDefaultRecToken)
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOGNIZERS, m_pDefaultRecToken);
    }

    HRESULT hrRet = hr;

    BOOL fContextInitialized = FALSE;
    if ( SUCCEEDED( hr ) )
    {
        if ( IsRecoTokenCurrentlyBeingUsed( m_pDefaultRecToken ) )
        {
            // No need to switch engine all over again: just keep the one in use

            if ( m_cpRecoCtxt )
            {
                fContextInitialized = TRUE;
            }
            else
            {
                hr = SPERR_UNINITIALIZED;
            }
            
            // The UI might have monkeyed with the recostate.
            // Just in case, let's set it back to ACTIVE_ALWAYS
            if ( SUCCEEDED( hr ) )
            {
                hr = m_cpRecoEngine->SetRecoState( SPRST_ACTIVE_ALWAYS );
            }
        }
        else
        {
            // Create the engine & context using the old default
            hr = g_pSRDlg->CreateRecoContext( &fContextInitialized );
        }
    }

    if ( FAILED( hr ) )
    {
        BOOL fContextInitialized = FALSE;
        hr = g_pSRDlg->CreateRecoContext( &fContextInitialized );

        // Let's not complain about unsupported languages twice as this may be confusing
        // to the user.
        if ( FAILED( hr ) && ( SPERR_UNSUPPORTED_LANG != hr ) )
        {
            RecoContextError( fContextInitialized, fShowErrorMessages, hr );
            // The default was set back but no engine was successfully set up.

            // A FAILED hresult is not necessary here since the user
            // has been notified of the error
            hrRet = S_FALSE;
        }

        // Gray out all the buttons
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_USERTRAINING), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MICWIZ), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_SR_ADV), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MODIFY), FALSE);
    }

    return hrRet;
}   /* CSRDlg::ResetDefaultEngine */

/*****************************************************************************
* CSRDlg::IsRecoTokenCurrentlyBeingUsed *
*---------------------------------------*
*   Description:
*       Call GetRecognizer() on the recognizer currently in use, and 
*       compare IDs
****************************************************************** BECKYW ****/
bool CSRDlg::IsRecoTokenCurrentlyBeingUsed( ISpObjectToken *pRecoToken )
{
    if ( !pRecoToken || !m_cpRecoEngine )
    {
        return false;
    }

    CComPtr<ISpObjectToken> cpRecoTokenInUse;
    HRESULT hr = m_cpRecoEngine->GetRecognizer( &cpRecoTokenInUse );

    CSpDynamicString dstrTokenID;
    CSpDynamicString dstrTokenInUseID;
    if ( SUCCEEDED( hr ) )
    {
        hr = pRecoToken->GetId( &dstrTokenID );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = cpRecoTokenInUse->GetId( &dstrTokenInUseID );
    }

    return ( SUCCEEDED( hr ) && (0 == wcscmp(dstrTokenID, dstrTokenInUseID)) );
}   /* CSRDlg::IsRecoTokenCurrentlyBeingUsed */

/*****************************************************************************
* CSRDlg::HasRecognizerChanged *
*------------------------------*
*   Description:
*       Look at the currently-requested default recognizer, compare against the
*       original default recognizer, and return true iff it is 
*       different
****************************************************************** BECKYW ****/
bool CSRDlg::HasRecognizerChanged()
{
    bool fChanged = false;

    // Check the recognizer token
    CSpDynamicString dstrCurDefaultRecognizerID;
    CSpDynamicString dstrCurSelectedRecognizerID;
    HRESULT hr = E_FAIL;
    if ( m_pDefaultRecToken )
    {
        hr = m_pDefaultRecToken->GetId( &dstrCurDefaultRecognizerID );
    }
    if ( SUCCEEDED( hr ) && m_pCurRecoToken ) 
    {
        hr = m_pCurRecoToken->GetId( &dstrCurSelectedRecognizerID );
    }
    if (SUCCEEDED( hr ) && ( 0 != wcsicmp( dstrCurDefaultRecognizerID, dstrCurSelectedRecognizerID ) ))
    {
        fChanged = true;
    }

    return fChanged;

}   /* CSRDlg::HasRecognizerChanged */

/*****************************************************************************
* CSRDlg::KickCPLUI *
*-------------------*
*   Description:
*       Look at the currently-requested defaults, compare against the
*       original defaults, and enable the Apply button iff anything is 
*       different
****************************************************************** BECKYW ****/
void CSRDlg::KickCPLUI()
{
    // Check the default recognizer token
    bool fChanged = HasRecognizerChanged();

    // Check the default user token
    CSpDynamicString dstrCurSelectedProfileID;
    HRESULT hr = E_FAIL;
    if ( m_pCurUserToken )
    {
        hr = m_pCurUserToken->GetId( &dstrCurSelectedProfileID );
    }
    if (SUCCEEDED( hr ) && m_dstrOldUserTokenId 
        && ( 0 != wcsicmp( dstrCurSelectedProfileID, m_dstrOldUserTokenId ) ))
    {
        fChanged = true;
    }

    // Check the audio input device
    if ( m_pAudioDlg && m_pAudioDlg->IsAudioDeviceChanged() )
    {
        fChanged = true;
    }

    // If any tokens have been deleted, there has been a change
    if ( m_iDeletedTokens > 0 )
    {
        fChanged = true;
    }

    // If any tokens have been added, there has been a change
    if ( m_iAddedTokens > 0 )
    {
        fChanged = true;
    }

    // Tell the main propsheet
    HWND hwndParent = ::GetParent( m_hDlg );
    ::SendMessage( hwndParent, 
        fChanged ? PSM_CHANGED : PSM_UNCHANGED, (WPARAM)(m_hDlg), 0 ); 
}   /* CSRDlg::KickCPLUI */

/*****************************************************************************
* CSRDlg::RecoContextError *
*--------------------------*
*   Description:
*       Reacts to an error generated by trying to create and set up the 
*       recognition context within the CPL by displaying an error message
*       and graying out the UI.
****************************************************************** BECKYW ****/
void CSRDlg::RecoContextError( BOOL fRecoContextExists, BOOL fGiveErrorMessage,
                              HRESULT hrRelevantError )
{
    // Complain about the appropriate problem, if needed
    if ( fGiveErrorMessage )
    {
        WCHAR szError[256];
        szError[0] = '\0';
        
        // Figure out what error to talk about
        UINT uiErrorID = 0;
        if ( fRecoContextExists )
        {
            // There is a reco context but it couldn't be turned on
            uiErrorID = IDS_METER_WARNING;
        }
        else
        {
            uiErrorID = HRESULTToErrorID( hrRelevantError );
        }

        if ( uiErrorID )
        {
            LoadString(_Module.GetResourceInstance(), uiErrorID, 
                szError, sizeof(szError));
            MessageBox(m_hDlg, szError, m_szCaption, MB_ICONWARNING|g_dwIsRTLLayout);
        }
    }

    // Gray out all the buttons
    if ( !fRecoContextExists )
    {
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_USERTRAINING), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MICWIZ), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_SR_ADV), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MODIFY), FALSE);
    }
}   /* CSRDlg::RecoContextError */

/*****************************************************************************
* CSRDlg::HRESULTToErrorID *
*--------------------------*
*   Description:
*       Translates a failed HRESULT from a recognizer/recocontext 
*       initializion into a resource string ID
****************************************************************** BECKYW ****/
UINT CSRDlg::HRESULTToErrorID( HRESULT hr )
{
    if ( SUCCEEDED( hr ) )
    {
        return 0;
    }

    // What to complain about...
    UINT uiErrorID;
    switch( hr )
    {
    case SPERR_ENGINE_BUSY:
        uiErrorID = IDS_ENGINE_IN_USE_WARNING;
        break;
    case SPERR_UNSUPPORTED_LANG:
        uiErrorID = IDS_UNSUPPORTED_LANG;
        break;
    default:
        // Generic error
        uiErrorID = IDS_ENGINE_SWITCH_ERROR;
        break;
    }

    return uiErrorID;
 
}   /* CSRDlg::HRESULTToErrorID */

/*****************************************************************************
* CSRDlg::IsProfileNameInvisible *
*--------------------------------*
*   Description:
*       A profile name is "invisible" iff it is the name of an existing
*       profile AND it is on the pending deletes list AND it is does not
*       exist for any tokens off the pending deletes list
****************************************************************** BECKYW ****/
bool CSRDlg::IsProfileNameInvisible( WCHAR *pwszProfile )
{
    if ( !pwszProfile )
    {
        return false;
    }

    bool fIsInvisible = false;
    for ( int i=0; !fIsInvisible && (i < m_iDeletedTokens); i++ )
    {
        ISpObjectToken *pDeletedToken = m_aDeletedTokens[i];
        if ( !pDeletedToken )
        {
            continue;
        }

        CSpDynamicString dstrDeletedDesc;
        HRESULT hr = SpGetDescription( pDeletedToken, &dstrDeletedDesc );
        if ( FAILED( hr ) )
        {
            continue;
        }

        if ( 0 == wcscmp( dstrDeletedDesc, pwszProfile ) )
        {
            bool fOnList = false;

            // Now go through everything on the recoprofile list
            // that is visible to the user
            int cItems = ListView_GetItemCount( m_hUserList );
            for ( int j=0; !fOnList && (j < cItems); j++ )
            {
                LVITEM lvitem;
                ::memset( &lvitem, 0, sizeof( lvitem ) );
                lvitem.iItem = j;
                lvitem.mask = LVIF_PARAM;
                BOOL fSuccess = ListView_GetItem( m_hUserList, &lvitem );
                
                ISpObjectToken *pVisibleToken = 
                    fSuccess ? (ISpObjectToken *) lvitem.lParam : NULL;

                if ( pVisibleToken )
                {
                    CSpDynamicString dstrVisible;
                    hr = SpGetDescription( pVisibleToken, &dstrVisible );

                    if ( SUCCEEDED( hr ) &&
                        (0 == wcscmp( dstrVisible, pwszProfile )) )
                    {
                        fOnList = true;
                    }
                }
            }

            if ( !fOnList )
            {
                // The name matches something on the deleted list,
                // but it appears nowhere on the list of profiles visible
                // to the user.
                fIsInvisible = true;
            }
        }
    }

    return fIsInvisible;
}   /* IsProfileNameInvisible */

/*****************************************************************************
* SRDlgProc *
*-----------*
*   Description:
*       DLGPROC for managing recognition engines
****************************************************************** MIKEAR ***/
BOOL CALLBACK SRDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC( "SRDlgProc" );

    USES_CONVERSION;

    switch (uMsg) 
    {
        case WM_RECOEVENT:
        {
            g_pSRDlg->RecoEvent();
            break;
        }
        
        case WM_DRAWITEM:      // draw the items
        {
            g_pSRDlg->OnDrawItem( hWnd, ( DRAWITEMSTRUCT * )lParam );
            break;
        }

        case WM_INITDIALOG:
        {
            g_pSRDlg->OnInitDialog(hWnd);
            break;
        }

        case WM_DESTROY:
        {
            g_pSRDlg->OnDestroy();

            break;
        }

        // Handle the context sensitive help
        case WM_CONTEXTMENU:
        {
            WinHelp((HWND) wParam, CPL_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)(LPWSTR) aKeywordIds);
            break;
        }

        case WM_HELP:
        {
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, CPL_HELPFILE, HELP_WM_HELP,(DWORD_PTR)(LPWSTR) aKeywordIds);
            break;
        }

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
                case LVN_DELETEITEM:
                {
                    if (wParam != IDC_USER)
                    {
                        break;
                    }

                    if (g_pSRDlg->m_fDontDelete)
                    {
                        break;  
                    }

                    ISpObjectToken *pToken = (ISpObjectToken*)(((NMLISTVIEW*)lParam)->lParam);

                    if (pToken)
                    {
                        pToken->Release();
                    }
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    // Code ends up here when a profile is added, deleted, or changed
                    // We verify that we weren't selected before, but are now
                    // and then kill the current reco context, deactivate the engine, change the profile
                    // and fire everything back up again
                    if ( IDC_USER == wParam )
                    {
                        LPNMLISTVIEW lplv = (LPNMLISTVIEW) lParam;
                        if ( !(lplv->uOldState & LVIS_FOCUSED) && lplv->uNewState & LVIS_FOCUSED )
                        {
                            if ( g_pSRDlg->m_cpRecoEngine && g_pSRDlg->m_cpRecoCtxt )
                            {
                                HRESULT hr;

                                ISpObjectToken *pSelectedToken = (ISpObjectToken *) lplv->lParam;

                                hr = g_pSRDlg->m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
                                
                                if ( SUCCEEDED( hr ) )
                                {
                                    hr = g_pSRDlg->m_cpRecoEngine->SetRecoProfile( pSelectedToken );

                                    // Restart audio regardless of success of SetRecoProfile
                                    g_pSRDlg->m_cpRecoEngine->SetRecoState(SPRST_ACTIVE_ALWAYS);

                                    if ( FAILED( hr ) )
                                    {
                                        WCHAR szError[256];
                                        szError[0] = '\0';
                                        LoadString(_Module.GetResourceInstance(), IDS_PROFILE_WARNING, szError, sizeof(szError));
                                        MessageBox(g_pSRDlg->m_hDlg, szError, g_pSRDlg->m_szCaption, MB_ICONWARNING|g_dwIsRTLLayout);
                                    }
                                }
                                
                                if ( SUCCEEDED( hr ) )
                                {
                                    // This is now the new default
                                    g_pSRDlg->m_pCurUserToken = pSelectedToken;
                                    g_pSRDlg->UserSelChange( lplv->iItem );
                                }

                            }
                        }
                    }
                    break;
                }
 
                case PSN_APPLY:
                {
                    g_pSRDlg->OnApply();
                    break;
                }

                case PSN_QUERYCANCEL:  // user clicks the Cancel button
                {
                    g_pSRDlg->OnCancel();
                    break;
                }

            }
            break;

        case WM_COMMAND:
            if (CBN_SELCHANGE == HIWORD(wParam))
            {
                g_pSRDlg->EngineSelChange();
            }
            else if (HIWORD(wParam) == BN_CLICKED)
            {
                HRESULT hr = S_OK;

                if (LOWORD(wParam) == IDC_MODIFY)  // the "Modify" button
                {
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                    if ( SUCCEEDED( hr ) )
                    {
                        g_pSRDlg->ProfileProperties();
                    }
                    
                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                    
                }

                else if (LOWORD(wParam) == IDC_ADD) // the "Add" button
                {
                    // The engine we want to add this user for may not be the currently-
                    // running engine.  Try and switch it, and complain if there's 
                    // a problem
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                    if ( SUCCEEDED( hr ) )
                    {
                        g_pSRDlg->CreateNewUser();
                    }

                    // Switch back to original default, but complain about errors
                    // only if the UI actually succeeded in showing
                    g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ) );
                }

                else if (LOWORD(wParam) == IDC_DELETE) // the "Delete" button
                {
                    g_pSRDlg->DeleteCurrentUser();
                }

                else if (LOWORD(wParam) == IDC_SR_ADV)
                {
                    // The engine we want to display UI for may not be the currently
                    // running engine. Try and switch it
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                    if(SUCCEEDED(hr))
                    {
                        // display the UI w/ the new temporary default
                        g_pSRDlg->m_pCurRecoToken->DisplayUI(hWnd, NULL, 
                            SPDUI_EngineProperties, NULL, 0, g_pSRDlg->m_cpRecoEngine);
   
                    }
                    
                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                }

                else if(LOWORD(wParam) == IDC_USERTRAINING)
                {
                    // The engine we want to display UI for may not be the currently
                    // running engine. Try and switch it
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );
                    
                    if(SUCCEEDED(hr))
                    {
                        // display the UI w/ the new temporary default
                        SPDBG_ASSERT( g_pSRDlg->m_cpRecoEngine );
                        g_pSRDlg->m_cpRecoEngine->DisplayUI(hWnd, NULL, SPDUI_UserTraining, NULL, 0);
                    }
                    
                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                }

                else if(LOWORD(wParam) == IDC_MICWIZ)
                {
                    // The engine we want to display UI for may not be the currently
                    // running engine. Try and switch it
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );
                    
                    if(SUCCEEDED(hr))
                    {
                        // display the UI w/ the new temporary default
                        SPDBG_ASSERT( g_pSRDlg->m_cpRecoEngine );
                        g_pSRDlg->m_cpRecoEngine->DisplayUI(hWnd, NULL, SPDUI_MicTraining, NULL, 0);
                    }

                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                }

                else if (LOWORD(wParam) == IDC_AUD_IN)
                {
                    // The m_pAudioDlg will be non-NULL only if the audio dialog
                    // has been previously brough up.
                    // Otherwise, we need a newly-initialized one
                    if ( !g_pSRDlg->m_pAudioDlg )
                    {
                        g_pSRDlg->m_pAudioDlg = new CAudioDlg( eINPUT );
                    }
                    ::DialogBoxParam( _Module.GetResourceInstance(), 
                                MAKEINTRESOURCE( IDD_AUDIO_DEFAULT ),
                                hWnd, 
                                (DLGPROC) AudioDlgProc,
                                (LPARAM) g_pSRDlg->m_pAudioDlg );

                    if ( g_pSRDlg->m_pAudioDlg->IsAudioDeviceChangedSinceLastTime() )
                    {
                        // Warn the user that he needs to apply the changes
                        WCHAR szWarning[MAX_LOADSTRING];
                        szWarning[0] = 0;
                        LoadString( _Module.GetResourceInstance(), IDS_AUDIOIN_CHANGE_WARNING, szWarning, MAX_LOADSTRING);
                        MessageBox( g_pSRDlg->GetHDlg(), szWarning, g_pSRDlg->m_szCaption, MB_ICONWARNING |g_dwIsRTLLayout);
                    }

                    // Kick the Apply button
                    g_pSRDlg->KickCPLUI();

                }
            }
            break;
    }

    return FALSE;
} /* SRDlgProc */

/****************************************************************************
* CSRDlg::CreateNewUser *
*-------------------------*
*   Description:  Adds a new speech user profile to the registry
*
*   Returns:
*
********************************************************************* RAL ***/

void CSRDlg::CreateNewUser()
{
    SPDBG_FUNC("CSRDlg::CreateNewUser");
    HRESULT hr = S_OK;

    // Make sure that we haven't already added too many profiles to keep track of
    if ( m_iAddedTokens >= iMaxAddedProfiles_c )
    {
        WCHAR wszError[ MAX_LOADSTRING ];
        ::LoadString( _Module.GetResourceInstance(), IDS_MAX_PROFILES_EXCEEDED,
            wszError, MAX_LOADSTRING );
        ::MessageBox( m_hDlg, wszError, m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );

        return;
    }

    CComPtr<ISpObjectToken> cpNewToken;
    hr = SpCreateNewToken(SPCAT_RECOPROFILES, NULL, &cpNewToken);

    if (SUCCEEDED(hr))
    {
        if (!UserPropDlg(cpNewToken))   // User canceled!
        {
            cpNewToken->Remove(NULL);
        }
        else
        {
            //set the default
            m_pCurUserToken = cpNewToken;

            // Put the new token on the added tokens list
            cpNewToken->GetId( &(m_aAddedTokens[ m_iAddedTokens++ ]) );

            // make this the default after we edit it
            ChangeDefaultUser();
            
            // This will make sure that it gets displayed.
            // Note that m_pCurUserToken will point an AddRefed ISpObjectToken *
            // after the call to PopulateList()
            PopulateList();

            // Update the UI
            KickCPLUI();
        }
    }
    else
    {
        WCHAR szError[MAX_LOADSTRING];
        szError[0] = 0;
        LoadString(_Module.GetResourceInstance(), IDS_RECOPROFILE_ADD_ERROR, szError, MAX_LOADSTRING);
        MessageBox( m_hDlg, szError, m_szCaption, MB_ICONWARNING | g_dwIsRTLLayout);
    }

    // Only enable the delete button if there are 2 or more user profiles
    int iNumUsers = (int)::SendMessage(m_hUserList, LVM_GETITEMCOUNT, 0, 0);
    if (iNumUsers < 2) 
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), TRUE);
    }

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );
}

/****************************************************************************
* CSRDlg::UserPropDlg *
*-----------------------*
*   Description:  This is for when a user wants to add a new profile
*
*   Returns:
*
********************************************************************* BRENTMID ***/

HRESULT CSRDlg::UserPropDlg(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CSRDlg::UserPropDlg");
    HRESULT hr = S_OK;

    CEnvrPropDlg Dlg(this, pToken);

    hr = (HRESULT)DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_PROF_WIZ), m_hDlg,
        CEnvrPropDlg::DialogProc, (LPARAM)(&Dlg));
    
    return hr;
}

/****************************************************************************
* CEnvrPropDlg::InitDialog *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CEnvrPropDlg::InitDialog(HWND hDlg)
{
    USES_CONVERSION;
    CSpDynamicString dstrDescription;
    m_hDlg = hDlg;

    //
    //  Get the description if there is one...
    //
    SpGetDescription(m_cpToken, &dstrDescription);

    if (dstrDescription)
    {
        ::SendDlgItemMessage(hDlg, IDC_USER_NAME, WM_SETTEXT, 0, (LPARAM) dstrDescription.m_psz);
        ::SendDlgItemMessage(hDlg, IDC_USER_NAME, EM_LIMITTEXT, UNLEN, 0);
    }

    // We want the EN_CHANGE notifications from the edit control
    ::SendDlgItemMessage( hDlg, IDC_USER_NAME, EM_SETEVENTMASK, 0, ENM_CHANGE );

    if (!m_isModify)
    {
        // Set the user name to the one in the registry, if found; 
        // otherwise set it to the user name
        HKEY hkUserKey;
        LONG lUserOpen;
        WCHAR szUserName[ UNLEN + 1 ];
        szUserName[0] = 0;
        DWORD dwUserLen = UNLEN + 1;
        
        lUserOpen = ::RegOpenKeyEx( HKEY_CURRENT_USER, 
            L"Software\\Microsoft\\MS Setup (ACME)\\User Info", 
            0, KEY_READ, &hkUserKey );
        if ( lUserOpen == ERROR_SUCCESS )
        {
            lUserOpen = RegQueryValueEx( hkUserKey, L"DefName", NULL, NULL, 
                (BYTE *) szUserName, &dwUserLen );
            RegCloseKey(hkUserKey);
        }

        if ( ERROR_SUCCESS != lUserOpen )
        {
            // Just use the win32 user name
            BOOL fSuccess = ::GetUserName( szUserName, &dwUserLen );
            if ( !fSuccess ) 
            {
                szUserName[0] = 0;
            }
        }

        // Now put that in the edit box.
        // First check to make sure the name is nonempty
        // and enable the UI accordingly
        WCHAR *pwch;
        for ( pwch = szUserName; *pwch && iswspace( *pwch ); pwch++ )
        {
        }
        ::EnableWindow( ::GetDlgItem( m_hDlg, IDOK ), (0 != *pwch) );
        ::EnableWindow( ::GetDlgItem( m_hDlg, ID_NEXT ), (0 != *pwch) );
        
        // Set the edit box to have the user's name
        // Need to use SETTEXTEX since this might contain wide chars
        SETTEXTEX stx;
        stx.flags = ST_DEFAULT;
        stx.codepage = 1200;
        ::SendDlgItemMessage( m_hDlg, 
            IDC_USER_NAME, EM_SETTEXTEX, (WPARAM) &stx, (LPARAM) szUserName );

    }

    ::SetFocus(::GetDlgItem(hDlg, IDC_USER_NAME));

    return TRUE;
}

/****************************************************************************
* CEnvrPropDlg::ApplyChanges *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

EPD_RETURN_VALUE CEnvrPropDlg::ApplyChanges()
{
    USES_CONVERSION;
    SPDBG_FUNC("CEnvrPropDlg::ApplyChanges");
    WCHAR szName[UNLEN + 1];
    *szName = 0;
    GETTEXTEX gtex = { sp_countof(szName), GT_DEFAULT, 1200, NULL, NULL };
    ::SendDlgItemMessage(m_hDlg, IDC_USER_NAME, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)szName);

    if (*szName == 0)
    {
        return EPD_FAILED;
    }

    // Check to see if this profile name already exists
    CComPtr<IEnumSpObjectTokens>    cpEnum;
    ISpObjectToken                  *pToken;
    CSpDynamicString                dstrDescription;
    CSpDynamicString                dInputString;
    CSpDynamicString                dstrOldTok;
    bool                            isDuplicate = false;
    
    HRESULT hr = SpEnumTokens(SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);
    
    // Get the description of the currently selected profile
    dstrOldTok.Clear();
    hr = SpGetDescription( m_pParent->m_pCurUserToken, &dstrOldTok );
    
    while (cpEnum && cpEnum->Next(1, &pToken, NULL) == S_OK)
    {
        // Get the description of the enumerated token
        dstrDescription.Clear();
        hr = SpGetDescription( pToken, &dstrDescription );

        pToken->Release();

        // Get the input string
        dInputString = szName;
        
        if ( SUCCEEDED(hr) )
        {
            if ( wcscmp( dstrDescription.m_psz, dInputString.m_psz ) == 0 )
            {
                // the name is duplicated
                isDuplicate = true;
            }
        }
    }

    if ( isDuplicate )   // this not a modify box and the user entered a duplicate name
    {
        return EPD_DUP;  // tell the user about it
    }

    if (FAILED(SpSetDescription(m_cpToken, szName)))
    {
        return EPD_FAILED;
    }

    return EPD_OK;
}




/*****************************************************************************
* EnvrPropDialogProc *
*--------------------*
*   Description:
*       Mesage handler for User Name dialog
****************************************************************** BRENTMID ***/
INT_PTR CALLBACK CEnvrPropDlg::DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    USES_CONVERSION;

    static CSpUnicodeSupport unicode;
    CEnvrPropDlg * pThis = (CEnvrPropDlg *) unicode.GetWindowLongPtr(hDlg, GWLP_USERDATA);
    switch (message)
    {
        case WM_INITDIALOG:
            unicode.SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);
            pThis = (CEnvrPropDlg *)lParam;
            return pThis->InitDialog(hDlg);

        case WM_COMMAND:
        {
            if (( IDC_USER_NAME == LOWORD(wParam) )
                && ( EN_CHANGE == HIWORD(wParam) ))
            {
                // Edit control contents have changed: 
                
                // See if we should enable the "finish" and "next" buttons by getting the
                // text in the edit box and making sure it has at least one
                // non-whitespace character
                WCHAR szName[ UNLEN+1 ];
                *szName = 0;
                GETTEXTEX gtex = { UNLEN, GT_DEFAULT, 1200, NULL, NULL };
                ::SendDlgItemMessage(pThis->m_hDlg, 
                    IDC_USER_NAME, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)szName);

                WCHAR *pch = szName;
                for ( ; *pch && iswspace( *pch ); pch++ )
                {
                }

                ::EnableWindow( ::GetDlgItem( pThis->m_hDlg, IDOK ), (0 != *pch) );
                ::EnableWindow( ::GetDlgItem( pThis->m_hDlg, ID_NEXT ), (0 != *pch) );

                break;
            }
            
            if( LOWORD(wParam) == IDCANCEL ) 
            {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            // user clicks the NEXT button
            if ( (LOWORD( wParam ) == ID_NEXT) || (LOWORD( wParam ) == IDOK) )
            {
                EPD_RETURN_VALUE eRet = pThis->ApplyChanges();

                if ( eRet == EPD_OK ) 
                {
                    if ( ID_NEXT == LOWORD(wParam) )
                    {
                        // Launch the micwiz, if we can

                        // Try to switch engines in case the user has changed engines
                        // without applying
                        HRESULT hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                        if ( S_OK == hr )
                        {
                            SPDBG_ASSERT( g_pSRDlg->m_cpRecoEngine );

                            if ( g_pSRDlg->m_cpRecoEngine )
                            {
                                // Switch the recoprofile to the new one (might need to turn off
                                // recostate first

                                // Turn off recostate before calling SetRecoProfile() if necessary
                                SPRECOSTATE eOldRecoState = SPRST_INACTIVE;
                                g_pSRDlg->m_cpRecoEngine->GetRecoState( &eOldRecoState );
                                HRESULT hrRecoState = S_OK;
                                if ( SPRST_INACTIVE != eOldRecoState )
                                {
                                    hrRecoState = g_pSRDlg->m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
                                }

                                // Change to the newly-added recoprofile
                                HRESULT hrSetRecoProfile = E_FAIL;
                                if ( SUCCEEDED( hrRecoState ) )
                                {
                                    hrSetRecoProfile = 
                                        g_pSRDlg->m_cpRecoEngine->SetRecoProfile( pThis->m_cpToken );
                                
                                    // Restore the recostate
                                    g_pSRDlg->m_cpRecoEngine->SetRecoState( eOldRecoState );
                                }


                                // Bring on the micwiz and the training wiz
                                // Follow the yellow brick road.
                                g_pSRDlg->m_cpRecoEngine->DisplayUI(hDlg, NULL, SPDUI_MicTraining, NULL, 0);
                                if ( SUCCEEDED( hrSetRecoProfile ) )
                                {
                                    // Only want to train the profile if it actually _is_ this profile being 
                                    // used...
                                    g_pSRDlg->m_cpRecoEngine->DisplayUI(hDlg, NULL, SPDUI_UserTraining, NULL, 0);
                                }
                            }
                        }

                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
}

                    // now we are done
                    EndDialog(hDlg, TRUE);
                }
                else if ( eRet == EPD_DUP )  // user tried to enter a duplicate name
                {
                    // What name was added?
                    WCHAR szName[ UNLEN+1 ];
                    *szName = 0;
                    GETTEXTEX gtex = { UNLEN, GT_DEFAULT, 1200, NULL, NULL };
                    ::SendDlgItemMessage(pThis->m_hDlg, 
                        IDC_USER_NAME, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)szName);

                    WCHAR pszDuplicate[MAX_LOADSTRING];
                    LoadString(_Module.GetResourceInstance(), 
                        g_pSRDlg->IsProfileNameInvisible( szName ) ? IDS_DUP_NAME_DELETED : IDS_DUP_NAME, 
                        pszDuplicate, MAX_LOADSTRING);
                    MessageBox( hDlg, pszDuplicate, g_pSRDlg->m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
                }

            }
        }
        break;
    }
    return FALSE;
} /* UserNameDialogProc */

/*****************************************************************************
* CSRDlg::UserSelChange *
*-------------------------*
*   Description:
*       Changes the deafult user
****************************************************************** BRENTMID ***/
void CSRDlg::UserSelChange( int iSelIndex )
{
    HRESULT hr = S_OK;
    SPDBG_FUNC( "CSRDlg::UserSelChange" );

    // Get the selected item's token
    LVITEM lvitem;
    lvitem.iItem = iSelIndex;
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_PARAM;
    ::SendMessage( m_hUserList, LVM_GETITEM, 0, (LPARAM) &lvitem );
                    
    ISpObjectToken *pToken = (ISpObjectToken *) lvitem.lParam;

    if (pToken)
    {
        
        // Try to find the item in the list associated with the current default token
        LVFINDINFO lvfi;
        if ( iSelIndex >= 0 )
        {
            // Something was selected; this is the new default user
            lvfi.flags = LVFI_PARAM;
            lvfi.lParam = (LPARAM) m_pCurUserToken;
            int iCurDefaultIndex = (int)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
            
            if ( iCurDefaultIndex >= 0 )
            {
                // The current default has been found in the list; remove its checkmark
                SetCheckmark( m_hUserList, iCurDefaultIndex, false );
            }
            
            SetCheckmark( m_hUserList, iSelIndex, true );
            
            //set the default
            m_pCurUserToken = pToken;
            m_iLastSelected = iSelIndex;

            // Kick the Apply button
            KickCPLUI();
        }
    }
} /* CSRDlg::UserSelChange */

/*****************************************************************************
* CSRDlg::DeleteCurrentUser *
*-------------------------*
*   Description:
*       Deletes the default user
****************************************************************** BRENTMID ***/
void CSRDlg::DeleteCurrentUser()
{
    // Make sure that we haven't already deleted too many profiles to keep track of
    if ( m_iDeletedTokens >= iMaxDeletedProfiles_c )
    {
        WCHAR wszError[ MAX_LOADSTRING ];
        ::LoadString( _Module.GetResourceInstance(), IDS_MAX_PROFILES_EXCEEDED,
            wszError, MAX_LOADSTRING );
        ::MessageBox( m_hDlg, wszError, m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
        
        return;
    }

    // First confirm this action with the user
    WCHAR pszAsk[ MAX_LOADSTRING ];
    WCHAR pszWinTitle[ MAX_LOADSTRING ];
    ::LoadString( _Module.GetResourceInstance(), IDS_ASK_CONFIRM, pszAsk, MAX_LOADSTRING );
    ::LoadString( _Module.GetResourceInstance(), IDS_ASK_TITLE, pszWinTitle, MAX_LOADSTRING );

    if ( MessageBox( m_hDlg, pszAsk, pszWinTitle, MB_YESNO | g_dwIsRTLLayout ) == IDNO )
    {
        // User said no.
        return;
    }

    // We need to hang onto the current user token, since when the focus
    // changes because of the delete, there will be a different m_pCurUserToken
    ISpObjectToken *pTokenToDelete = m_pCurUserToken;
    SPDBG_ASSERT( pTokenToDelete );
    if ( !pTokenToDelete )
    {
        return;
    }

    m_fDontDelete = TRUE;

    // Try to find the item in the list associated with the current default token
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) pTokenToDelete;
    int iCurDefaultIndex = (int)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
    
    if ( iCurDefaultIndex >= 0 )
    {
        // The current default has been found in the list; remove its checkmark
        SetCheckmark( m_hUserList, iCurDefaultIndex, false );
    }
    
    //remove the token
    ::SendMessage( m_hUserList, LVM_DELETEITEM, iCurDefaultIndex, NULL );

    // now setup the new default

    // Get the first item's token
    LVITEM lvitem;
    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_PARAM;
    ::SendMessage( m_hUserList, LVM_GETITEM, 0, (LPARAM) &lvitem );
                    
    ISpObjectToken *pToken = (ISpObjectToken *) lvitem.lParam;

    // set the selected item.
    // Focusing it will cause it to be the default
    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    ::SendMessage( m_hUserList, LVM_SETITEMSTATE, 0, (LPARAM) &lvitem );

    SetCheckmark( m_hUserList, 0, true );
    
    // enable or disable the delete button based on # of profiles
    int iNumUsers = (int)::SendMessage(m_hUserList, LVM_GETITEMCOUNT, 0, 0);
    if (iNumUsers < 2) 
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), TRUE);
    }

    //set the focus back to the user profiles
    ::SetFocus(GetDlgItem( m_hDlg, IDC_USER ));

    // set the new default profile, inform the SR engine, and remove the old token
    SpSetDefaultTokenForCategoryId(SPCAT_RECOPROFILES, m_pCurUserToken );

    // Save the tokens in case the user clicks "Cancel"
    m_aDeletedTokens[m_iDeletedTokens] = pTokenToDelete;  // save the deleted token for possible "Cancel"
    m_iDeletedTokens++;  // increment the number deleted
    KickCPLUI();
    
    // Currently we immediately APPLY this deletion, since the user has already said "YES"
    // when the were prompted to confirm the delete.
    // If we want to have an "APPLY / CANCEL" thing happen, switch the #if 1 and #if 0

    // send the appropriate message to the parent
    HWND parentWin = ::GetParent( m_hDlg );


    // now the last selected token is gone, so note that
    m_iLastSelected = -1;

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );

    m_fDontDelete = FALSE;
}   /* CSRDlg::DeleteCurrentUser */

/*****************************************************************************
* CSRDlg::ProfileProperties *
*-------------------------*
*   Description:
*       Modifies the properites through engine UI
****************************************************************** BRENTMID ***/

void CSRDlg::ProfileProperties()
{
    if ( m_cpRecoEngine )
    {
        m_cpRecoEngine->DisplayUI(m_hDlg, NULL, SPDUI_RecoProfileProperties, NULL, 0);
    }
}

/*****************************************************************************
* CSRDlg::OnInitDialog *
*----------------------*
*   Description:
*       Dialog Initialization
****************************************************************** MIKEAR ***/
void CSRDlg::OnInitDialog(HWND hWnd)
{
    SPDBG_FUNC( "CSRDlg::OnInitDialog" );
    USES_CONVERSION;
    SPDBG_ASSERT(IsWindow(hWnd));

    m_hDlg = hWnd;
    
    // This will be the caption for all MessageBoxes
    m_szCaption[0] = 0;
    ::LoadString( _Module.GetResourceInstance(), IDS_CAPTION, m_szCaption, sp_countof( m_szCaption ) );

    m_hSRCombo = ::GetDlgItem( hWnd, IDC_COMBO_RECOGNIZERS );
    SpInitTokenComboBox( m_hSRCombo, SPCAT_RECOGNIZERS );

    // The first one in the list will be the current default
    int iSelected = (int) ::SendMessage( m_hSRCombo, CB_GETCURSEL, 0, 0 );
    ISpObjectToken *pCurDefault = (ISpObjectToken *) ::SendMessage( m_hSRCombo, CB_GETITEMDATA, iSelected, 0 );
    m_pCurRecoToken = pCurDefault;
    m_pDefaultRecToken = pCurDefault;

    // This simulates selecting the default engine - ensures the UI is setup correctly.
    EngineSelChange(TRUE);

    InitUserList( hWnd );
    m_hUserList = ::GetDlgItem( hWnd, IDC_USER );

    ::SendMessage( m_hUserList, LVM_SETCOLUMNWIDTH, 0, MAKELPARAM((int) LVSCW_AUTOSIZE, 0) );

    int iNumUsers = (int)::SendMessage(m_hUserList, LVM_GETITEMCOUNT, 0, 0);
    if (iNumUsers < 2) 
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), TRUE);
    }

    //set the focus back to the user profiles
    ::SetFocus(GetDlgItem( m_hDlg, IDC_USER ));

} /* CSRDlg::OnInitDialog */

/*****************************************************************************
* CSRDlg::SetCheckmark *
*----------------------*
*   Description:
*       Sets the specified item in the list control to be either checked
*       or unchecked (as the default user)
******************************************************************************/
void CSRDlg::SetCheckmark( HWND hList, int iIndex, bool bCheck )
{
    ListView_SetCheckState( hList, iIndex, bCheck );
}   /* CSRDlg::SetCheckmark */

/*****************************************************************************
* CSRDlg::OnDestroy *
*-------------------*
*   Description:
*       Destruction
****************************************************************** MIKEAR ***/
void CSRDlg::OnDestroy()
{
    SPDBG_FUNC( "CSRDlg::OnDestroy" );

    // spuihelp will take care of releasing its own tokens
    SpDestroyTokenComboBox( m_hSRCombo );

    // The tokens kepts as itemdata in the reco profile list were 
    // released in the LVN_DELETEITEM code

    // Shuts off the reco engine
    ShutDown();

} /* CSRDlg::OnDestroy */

/*****************************************************************************
* CSRDlg::ShutDown *
*------------------*
*   Description:
*       Shuts down by releasing the engine and reco context
****************************************************************** MIKEAR ***/
void CSRDlg::ShutDown()
{

    // Release objects
    m_cpRecoCtxt.Release();
    m_cpRecoEngine.Release();

}   /* CSRDlg::ShutDown */

/************************************************************
* CSRDlg::InitUserList
*
*   Description:
*       Initializes user list
*********************************************** BRENTMID ***/
void CSRDlg::InitUserList(HWND hWnd)
{
    const int iInitWidth_c = 260;  // pixel width of "Description Column"

    // Set up the "Description" column for the settings display
    m_hUserList = ::GetDlgItem( hWnd, IDC_USER );
    WCHAR pszColumnText[ UNLEN+1 ] = L"";
    LVCOLUMN lvc;
    lvc.mask = LVCF_FMT| LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;

    ::LoadString( _Module.GetResourceInstance(), IDS_DESCRIPT, pszColumnText, UNLEN );
    lvc.pszText = pszColumnText;
    lvc.iSubItem = 0;
    lvc.cx = iInitWidth_c;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( m_hUserList, 1, &lvc );

    // This should be a checkbox list
    ::SendMessage( m_hUserList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES );

    PopulateList();

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );

}   // CSRDlg::InitUserList

/************************************************************
* CSRDlg::PopulateList
*
*   Description:
*       Populates user list
*********************************************** BRENTMID ***/
void CSRDlg::PopulateList()
{
    USES_CONVERSION;

    // Populate the list control
    int                             iIndex = 0;
    LVITEM                          lvitem;
    CComPtr<IEnumSpObjectTokens>    cpEnum;
    ISpObjectToken                  *pToken;
    WCHAR                           *pszAttrib = NULL;

    HRESULT hr;

    // this is to lazily init the user profile if there are none - DON'T REMOVE
    if ( m_cpRecoEngine )
    {
        CComPtr<ISpObjectToken> cpTempToken;
        m_cpRecoEngine->GetRecoProfile(&cpTempToken);
    }

    // Now clear the list
    ListView_DeleteAllItems( m_hUserList );

    // We will list the tokens in the order they are enumerated
    hr = SpEnumTokens(SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);

    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            // first check to see if the token is in the "Deleted List"
            bool f_isDel = false;

            for (int iDel = 0; iDel < m_iDeletedTokens; iDel++)
            {
                CSpDynamicString dstrT1;
                CSpDynamicString dstrT2;

                pToken->GetId( &dstrT1 );
                m_aDeletedTokens[ iDel ]->GetId( &dstrT2 );

                if (dstrT1.m_psz && dstrT2.m_psz && !wcscmp(dstrT1.m_psz, dstrT2.m_psz))
                {
                    f_isDel = true;
                }
            }

            // if we should show it
            if ( f_isDel )
            {
                // This token has a refcounted reference to it on the deleted list:
                // this reference should be released
                pToken->Release();
            }
            else 
            {
                // Not a pending delete: We should show it

                // now insert the token 
                lvitem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                lvitem.iItem = iIndex;
                lvitem.iSubItem = 0;
                lvitem.lParam = (LPARAM) pToken;
                
                CSpDynamicString cUser;
                SpGetDescription(pToken, &cUser);
                lvitem.pszText = cUser;
                
                // if this is the default it should be selected/focused
                if ( !fSetDefault )
                {
                    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
                }
                else
                {
                    lvitem.state = 0;
                }
                
                iIndex = (int)::SendMessage( m_hUserList, LVM_INSERTITEM, 0, (LPARAM) &lvitem );

                // the default is the first token returned by cpEnum->Next
                if ( !fSetDefault )
                {
                    fSetDefault = true;
                    
                    // Put the checkmark there
                    SetCheckmark( m_hUserList, iIndex, true );
                    m_pCurUserToken = pToken;
                            
                    // Set the m_dstrOldUserTokenId to the first default if it hasn't been set yet.
                    if ( !m_dstrOldUserTokenId )
                    {
                        m_pCurUserToken->GetId( &m_dstrOldUserTokenId );
                    }
                }
                
                iIndex++;
            }
        }

        // Autosize according to the strings now in the list
        ::SendMessage( m_hUserList, LVM_SETCOLUMNWIDTH, 0, MAKELPARAM((int) LVSCW_AUTOSIZE, 0) );
    }

    // now find the default item so we can scroll to it
    // Try to find the item in the list associated with the current default token
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) m_pCurUserToken;
    int iCurDefaultIndex = (int)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
        
    if ( iCurDefaultIndex >= 0 )
    {
        // The current default has been found in the list; scroll to it
        ListView_EnsureVisible( m_hUserList, iCurDefaultIndex, false );
    }
    
    // Name the list view something appropriate
    WCHAR pszListName[ MAX_LOADSTRING ];
    ::LoadString( _Module.GetResourceInstance(), IDS_PROFILE_LIST_NAME, pszListName, MAX_LOADSTRING );
    ::SendMessage( m_hUserList, WM_SETTEXT, 0, (LPARAM)pszListName );
}

/*****************************************************************************
* CSRDlg::OnApply *
*-----------------*
*   Description:
*       Set user specified options
****************************************************************** MIKEAR ***/
void CSRDlg::OnApply()
{
    SPDBG_FUNC( "CSRDlg::OnApply" );

    int iSelected = (int) ::SendMessage( m_hSRCombo, CB_GETCURSEL, 0, 0 );
    ULONG ulFlags = 0;

    // Pick up the recognizer change, if any
    bool fRecognizerChange = false;
    ISpObjectToken *pToken = NULL;
    if ( HasRecognizerChanged() )
    {
        pToken = (ISpObjectToken *) ::SendMessage( m_hSRCombo, CB_GETITEMDATA, iSelected, 0 );
        if ( CB_ERR == (LRESULT) pToken )
        {
            pToken = NULL;
        }

        HRESULT hrEngine = S_OK;
        if (pToken && (iSelected >=0))
        {
            hrEngine = SpSetDefaultTokenForCategoryId(SPCAT_RECOGNIZERS, pToken );
            if (FAILED(hrEngine))
            {
                WCHAR szError[256];
                szError[0] = '\0';
                LoadString(_Module.GetResourceInstance(), IDS_DEFAULT_ENGINE_WARNING, szError, sizeof(szError));
                MessageBox(m_hDlg, szError, MB_OK, MB_ICONWARNING | g_dwIsRTLLayout);
            }
            else
            {
                fRecognizerChange = true;
            }
        }
    }

    // Pick up any audio changes that may have been made
    HRESULT hrAudio = S_OK;
    bool fAudioChange = false;
    if ( m_pAudioDlg )
    {
        fAudioChange = m_pAudioDlg->IsAudioDeviceChanged();

        if ( fAudioChange )
        {
            hrAudio = m_pAudioDlg->OnApply();
        }

        if ( FAILED( hrAudio ) )
        {
            WCHAR szError[256];
            szError[0] = '\0';
            LoadString(_Module.GetResourceInstance(), IDS_AUDIO_CHANGE_FAILED, szError, sizeof(szError));
            MessageBox(m_hDlg, szError, NULL, MB_ICONWARNING|g_dwIsRTLLayout);
        }

        // Kill the audio dialog, as we are done with it.
        delete m_pAudioDlg;
        m_pAudioDlg = NULL;
    }
    
    // Permanently delete any profiles the user has deleted
    for (int iIndex = 0; iIndex < m_iDeletedTokens; iIndex++)
    {
        HRESULT hr = m_aDeletedTokens[iIndex]->Remove(NULL);

        if (FAILED(hr))
        {
            // might fail if a user has another app open
            WCHAR szError[256];
            szError[0] = '\0';
            LoadString(_Module.GetResourceInstance(), IDS_REMOVE_WARNING, szError, sizeof(szError));
            MessageBox(m_hDlg, szError, MB_OK, MB_ICONWARNING|g_dwIsRTLLayout);

            // This will make sure that the attempted deleted item shows up again
            PopulateList();
        }
        else
        {
            // The token is now removed, we can release it
            m_aDeletedTokens[iIndex]->Release();
        }
    }
    m_iDeletedTokens = 0;

    // The added token list's tokens were added as they were put onto the list,
    // so just clear the list so that they stay added at the end
    m_iAddedTokens = 0;

    // Now we don't care about the old user because of the apply
    m_dstrOldUserTokenId.Clear();
    m_pCurUserToken->GetId( &m_dstrOldUserTokenId );
    
    ChangeDefaultUser();

    // Kick the engine to pick up the changes.
    // Note that the recoprofile change would have taken effect when
    // we selected that list item, and that there is no way to 
    // pick up the audio changes right now since SetInput() is not
    // implemented for shared engines.
    if ( fRecognizerChange || fAudioChange )
    {
        BOOL fRecoContextInitialized = FALSE;

        if (fRecognizerChange)
        {
            ulFlags |= SRDLGF_RECOGNIZER;
        }

        if (fAudioChange)
        {
            ulFlags |= SRDLGF_AUDIOINPUT;
        }

        HRESULT hr = CreateRecoContext( &fRecoContextInitialized, FALSE, ulFlags);
        if ( FAILED( hr ) )
        {
            RecoContextError( fRecoContextInitialized, TRUE, hr );
        }

        if ( fRecognizerChange )
        {
            SPDBG_ASSERT( pToken );
            m_pDefaultRecToken = pToken;
        }

        EngineSelChange();
    }

    if(m_cpRecoEngine)
    {
        m_cpRecoEngine->SetRecoState( SPRST_ACTIVE );
    }

} /* CSRDlg::OnApply */

/************************************************************
* CSRDlg::OnDrawItem
*
*   Description:
*       Handles drawing items in the list view
*********************************************** BRENTMID ***/
void CSRDlg::OnDrawItem( HWND hWnd, const DRAWITEMSTRUCT * pDrawStruct )
{
    RECT rcClip;
    LVITEM lvi;
    UINT uiFlags = ILD_TRANSPARENT;
    HIMAGELIST himl;
    int cxImage = 0, cyImage = 0;
    UINT uFirstColWidth;

    // Get the item image to be displayed
    lvi.mask = LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
    lvi.iItem = pDrawStruct->itemID;
    lvi.iSubItem = 0;
    ListView_GetItem(pDrawStruct->hwndItem, &lvi);

    // We want to be drawing the current default as selected
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) m_pCurUserToken;
    UINT uiCurDefaultIndex = (UINT)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
    bool fSelected = (uiCurDefaultIndex == pDrawStruct->itemID);
    
    // Check to see if this item is selected
    if ( fSelected )
    {
        // Set the text background and foreground colors
        SetTextColor(pDrawStruct->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(pDrawStruct->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        // Set the text background and foreground colors to the standard window
        // colors
        SetTextColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOW));
    }

    // Get the image list and draw the image.
    // The image list will consist of the checked box and the unchecked box
    // for the LVS_EX_CHECKBOXES style
    himl = ListView_GetImageList(pDrawStruct->hwndItem, LVSIL_STATE);
    if (himl)
    {
        // For a LVS_EX_CHECKBOXES style, image 0 is unchecked and image 1 is checked
        ImageList_Draw(himl, 
            fSelected ? 1 : 0, 
            pDrawStruct->hDC,
            pDrawStruct->rcItem.left, pDrawStruct->rcItem.top,
            uiFlags);

        // Find out how big the image we just drew was
        ImageList_GetIconSize(himl, &cxImage, &cyImage);
    }

    // Calculate the width of the first column after the image width.  If
    // There was no image, then cxImage will be zero.
    LVCOLUMN pColumn;
    pColumn.mask = LVCF_WIDTH;
    ::SendMessage( m_hUserList, LVM_GETCOLUMN, 0, (LPARAM)&pColumn );

    int iColWidth = pColumn.cx;  // pixel width of "Description Column"
    uFirstColWidth = iColWidth - cxImage;

    // Set up the new clipping rect for the first column text and draw it
    rcClip.left = pDrawStruct->rcItem.left + cxImage;
    rcClip.right = pDrawStruct->rcItem.left + iColWidth;
    rcClip.top = pDrawStruct->rcItem.top;
    rcClip.bottom = pDrawStruct->rcItem.bottom;

    ISpObjectToken *pToken = (ISpObjectToken *) lvi.lParam;
    CSpDynamicString dstrTokenName;
    SpGetDescription(pToken, &dstrTokenName);

    DrawItemColumn(pDrawStruct->hDC, dstrTokenName, &rcClip);

    // If we changed the colors for the selected item, undo it
    if ( fSelected )
    {
        // Set the text background and foreground colors
        SetTextColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOW));
    }

    // If the item is focused, now draw a focus rect around the entire row
    if (pDrawStruct->itemState & ODS_FOCUS)
    {
        // Adjust the left edge to exclude the image
        rcClip = pDrawStruct->rcItem;
        rcClip.left += cxImage;

        // Draw the focus rect
        if ( ::GetFocus() == m_hUserList )
        {
            DrawFocusRect(pDrawStruct->hDC, &rcClip);
        }
    }

}   // CSRDlg::OnDrawItem

/************************************************************
* CSRDlg::DrawItemColumn
*
*   Description:
*       Handles drawing of the column data
*********************************************** BRENTMID ***/
void CSRDlg::DrawItemColumn(HDC hdc, WCHAR* lpsz, LPRECT prcClip)
{
    USES_CONVERSION;

    int iHeight = 0;    // Will cause CreateFont() to use default in case we
                        // don't get the height below
    
    // Get the height of the text
    if (hdc)
    {
        TEXTMETRIC tm;
        
        if (GetTextMetrics(hdc, &tm))
        {
            iHeight = tm.tmHeight;
        }
    }

    // link the font
    LCID dwLCID = GetUserDefaultLCID();

    // Pick an appropriate font.  On Windows 2000, let the system fontlink.
    
    DWORD dwVersion = GetVersion();
    HFONT hfontNew = NULL;
    HFONT hfontOld = NULL;

    if (   (dwVersion >= 0x80000000)
        || (LOBYTE(LOWORD(dwVersion)) < 5 ) )
    {
        // Less than NT5: Figure out what font

        WCHAR achCodePage[6];
        UINT uiCodePage;
        
        if (0 != GetLocaleInfo(dwLCID, LOCALE_IDEFAULTANSICODEPAGE, achCodePage, 6))
        {
            uiCodePage = _wtoi(achCodePage);
        }
        else
        {
            uiCodePage = GetACP();
        }
        
        CComPtr<IMultiLanguage> cpMultiLanguage;
        MIMECPINFO MimeCpInfo;
        
        if (   SUCCEEDED(cpMultiLanguage.CoCreateInstance(CLSID_CMultiLanguage))
            && SUCCEEDED(cpMultiLanguage->GetCodePageInfo(uiCodePage, &MimeCpInfo)))
        {
            USES_CONVERSION;
            hfontNew = CreateFont(iHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
                MimeCpInfo.bGDICharset,
                OUT_DEFAULT_PRECIS,
                CLIP_DEFAULT_PRECIS,
                DEFAULT_QUALITY,
                DEFAULT_PITCH,
                MimeCpInfo.wszProportionalFont);
            
        }

        cpMultiLanguage.Release();
    }

    if ( hfontNew )
    {
        hfontOld = (HFONT) ::SelectObject( hdc, hfontNew );
    }

    CSpDynamicString szString;
    CSpDynamicString szNewString;

    // Check to see if the string fits in the clip rect.  If not, truncate
    // the string and add "...".
    szString = lpsz;
    szNewString = CalcStringEllipsis(hdc, szString, UNLEN, prcClip->right - prcClip->left);
    szString =  szNewString;
        
    // print the text
    ExtTextOutW(hdc, prcClip->left + 2, prcClip->top + 2, ETO_CLIPPED | ETO_OPAQUE,
               prcClip, szString.m_psz, szString.Length(), NULL);

    // Replace the old font
    if ( hfontNew )
    {
        ::SelectObject( hdc, hfontOld );
        ::DeleteObject( hfontNew );
    }

}

/************************************************************
* CSRDlg::CalcStringEllipsis
*
*   Description:
*       If the text won't fit in the box, edit it, and make
*       it have ellipses
*********************************************** BRENTMID ***/
CSpDynamicString CSRDlg::CalcStringEllipsis(HDC hdc, CSpDynamicString lpszString, int cchMax, UINT uColWidth)
{
    USES_CONVERSION;

    WCHAR  szEllipsis[] = L"...";
    SIZE   sizeString;
    SIZE   sizeEllipsis;
    int    cbString;
    CSpDynamicString lpszTemp;
    BOOL   fSuccess = FALSE;

    // Adjust the column width to take into account the edges
    uColWidth -= 4;

    lpszTemp = lpszString;

    // Get the width of the string in pixels
    cbString = lpszTemp.Length();
    if (!::GetTextExtentPoint32(hdc, lpszTemp, cbString, &sizeString))
    {
        SPDBG_ASSERT(FALSE);
    }

    // If the width of the string is greater than the column width shave
    // the string and add the ellipsis
    if ((ULONG)sizeString.cx > uColWidth)
    {
        if (!::GetTextExtentPoint32(hdc, szEllipsis, lstrlen(szEllipsis),
            &sizeEllipsis))
        {
            SPDBG_ASSERT(FALSE);
        }

        while ((cbString > 0) && (fSuccess == FALSE))
        {
            lpszTemp[--cbString] = 0;
            if (!::GetTextExtentPoint32(hdc, lpszTemp, cbString, &sizeString))
            {
                SPDBG_ASSERT(FALSE);
            }
            
            if ((ULONG)(sizeString.cx + sizeEllipsis.cx) <= uColWidth)
            {
                // The string with the ellipsis finally fits, now make sure
                // there is enough room in the string for the ellipsis
                if (cchMax >= (cbString + lstrlen(szEllipsis)))
                {
                    // Concatenate the two strings and break out of the loop
                    lpszTemp.Append( szEllipsis );
                    lpszString = lpszTemp;
                    fSuccess = TRUE;
                }
            }
        }
    }
    else
    {
        // No need to do anything, everything fits great.
        fSuccess = TRUE;
    }

    return (lpszString);
}  // CSRDlg::CalStringEllipsis

/************************************************************
* CSRDlg::ChangeDefaultUser
*
*   Description:
*       Handles changes to the environment settings
*********************************************** BRENTMID ***/
void CSRDlg::ChangeDefaultUser()
{
    HRESULT hr;
    
    if (m_pCurUserToken)
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOPROFILES, m_pCurUserToken);
    }

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );

}   // CSRDlg::ChangeDefaultUser

/************************************************************
* CSRDlg::OnCancel
*
*   Description:
*       Handles undoing changes to the environment settings
*********************************************** BRENTMID ***/
void CSRDlg::OnCancel()
{
    // Get the original user and make sure that is still the default.
    // Note that in general m_pCurUserToken does not AddRef the 
    // ISpObjectToken it points to, so this is OK.
    SpGetTokenFromId( m_dstrOldUserTokenId, &m_pCurUserToken );

    ChangeDefaultUser();
    
    // Set the old recoprofile so that none of the profiles added in this
    // session will be in use:
    // This allows us to roll back the adds below
    // m_pCurUserToken does the trick since it is guaranteed to have
    // been around before this session

    if (m_cpRecoEngine)
    {
        m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
        m_cpRecoEngine->SetRecoProfile( m_pCurUserToken );
        m_cpRecoEngine->SetRecoState( SPRST_ACTIVE );
    }

    // Roll back and delete any new profiles added
    int cItems = (int) ::SendMessage( m_hUserList, LVM_GETITEMCOUNT, 0, 0 );
    LVITEM lvitem;
    for ( int i = 0; i < m_iAddedTokens; i++ )
    {
        // Look for the list item with a ref out on this token.
        // We need to do this because in order for a token to be successfully 
        // removed the only existing ref to that token has to call the Remove() 
        // method.  The list is holding a ref to that item.
        bool fFound = false;
        for ( int j=0; !fFound && (j < cItems); j++ )
        {
            ::memset( &lvitem, 0, sizeof( lvitem ) );
            lvitem.iItem = j;
            lvitem.mask = LVIF_PARAM;
            ::SendMessage( m_hUserList, LVM_GETITEM, 0, (LPARAM) &lvitem );

            CSpDynamicString dstrItemId;
            ISpObjectToken *pItemToken = (ISpObjectToken *) lvitem.lParam;
            if ( pItemToken )
            {
                HRESULT hrId = pItemToken->GetId( &dstrItemId );
                if ( SUCCEEDED( hrId ) && 
                    dstrItemId && m_aAddedTokens[i] && 
                    ( 0 == wcscmp( dstrItemId, m_aAddedTokens[ i ] ) ) )
                {
                    // Should this fail, the profile just doesn't get removed: big deal 
                    pItemToken->Remove( NULL );
                    fFound = true;
                }
            }
        }
        
    }

    // We AddRefed it...
    m_pCurUserToken->Release();
}   // CSRDlg::OnCancel


/*****************************************************************************
* CSRDlg::EngineSelChange *
*-------------------------*
*   Description:
*       This function updates the list box when the user selects a new engine.
*       If queries the token to see which UI items the engine supports.
*       The parameter fInitialize determines if the engine is actually created.
*       It does NOT actually change the default engine.
****************************************************************** MIKEAR ***/
void CSRDlg::EngineSelChange(BOOL fInitialize)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC( "CSRDlg::EngineSelChange" );

    int iSelected = (int) ::SendMessage( m_hSRCombo, CB_GETCURSEL, 0, 0 );
    ISpObjectToken *pToken = (ISpObjectToken *) ::SendMessage( m_hSRCombo, CB_GETITEMDATA, iSelected, 0 );
    if ( CB_ERR == (LRESULT) pToken )
    {
        pToken = NULL;
    }

    if (pToken)
    {
        // Now the current reco token is the one we got off the currently-selected combobox item
        m_pCurRecoToken = pToken;

        // Kick the UI to enable the Apply button if necessary
        KickCPLUI();

        HRESULT hrRecoContextOK = S_OK;
        if(fInitialize)
        {
            BOOL fContextInitialized = FALSE;
            hrRecoContextOK = CreateRecoContext(&fContextInitialized, TRUE); 
            if ( FAILED( hrRecoContextOK ) )
            {
                RecoContextError( fContextInitialized, true, hrRecoContextOK );
            }
        }
        
        if ( FAILED( hrRecoContextOK ) )
        {
            // Don't continue, all the buttons are grayed out,
            // which is what we want
            return;
        }
    }

    // Check for something being wrong, in which case we want to gray out all
    // the UI and stop here.
    // For instance, if we had trouble creating the reco context that's supposed to
    // be on now (the one for m_pDefaultRecToken), we certainly shouldn't
    // enable the UI buttons...
    if ( !pToken || (!m_cpRecoCtxt && (pToken == m_pDefaultRecToken)) )
    {
        RecoContextError( FALSE, FALSE );
        return;
    }

    // Determine if the training UI component is supported.
    // We can pass the current reco engine in as an argument only
    // if it's the same as the one who's token we're asking about.
    IUnknown *punkObject = (pToken == m_pDefaultRecToken) ? m_cpRecoEngine : NULL;
    BOOL fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_UserTraining, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    {
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_USERTRAINING), fSupported);

    // Determine if the Mic Wiz UI component is supported
    fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_MicTraining, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    {
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MICWIZ), fSupported);

    // Determine if the Engine Prop UI component is supported
    fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_EngineProperties, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    {
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_SR_ADV), fSupported);


    // Determine if the Reco Profile Prop UI component is supported
    fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_RecoProfileProperties, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    { 
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MODIFY), fSupported);
        
} /* CSRDlg::EngineSelChange */

/*****************************************************************************
* CSRDlg::IsCurRecoEngineAndCurRecoTokenMatch *
*---------------------------------------------*
*   Description:
*       Returns true in pfMatch iff the m_pCurRecoToken is the same
*       as the token for m_cpRecoEngine.
*   Return:
*       S_OK
*       E_POINTER
*       Failed HRESULTs from any of the SAPI calls
****************************************************************** BECKYW ***/
HRESULT CSRDlg::IsCurRecoEngineAndCurRecoTokenMatch( bool *pfMatch )
{
    if ( !pfMatch )
    {
        return E_POINTER;
    }

    if ( !m_cpRecoEngine || !m_pCurRecoToken )
    {
        return E_FAIL;
    }

    *pfMatch = false;

    // This gets the object token for the engine
    CComPtr<ISpObjectToken> cpRecoEngineToken;
    HRESULT hr = m_cpRecoEngine->GetRecognizer( &cpRecoEngineToken );
    
    WCHAR *pwszRecoEngineTokenID = NULL;
    WCHAR *pwszCurRecoTokenID = NULL;
    if ( SUCCEEDED( hr ) )
    {
        hr = cpRecoEngineToken->GetId( &pwszRecoEngineTokenID );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pCurRecoToken->GetId( &pwszCurRecoTokenID );
    }

    if ( pwszRecoEngineTokenID && pwszCurRecoTokenID )
    {
        *pfMatch = ( 0 == wcscmp( pwszRecoEngineTokenID, pwszCurRecoTokenID ) );
    }

    return hr;
}   /* CSRDlg::IsCurRecoEngineAndCurRecoTokenMatch */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\srdlg.h ===
/*******************************************************************************
* SRDlg.h *
*------------*
*   Description:
*       This is the header file for the default voice dialog.
*-------------------------------------------------------------------------------
*  Created By: MIKEAR                            Date: 11/17/98
*  Copyright (C) 1998 Microsoft Corp