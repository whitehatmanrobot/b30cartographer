cSinks = rgSinks->Count();

    if (cSinks >= 0x00ffffff)
        return CONNECT_E_ADVISELIMIT; // 16M sinks max

    if (FAILED(punk->QueryInterface(riid, (void **)&punkSink)))
        return E_FAIL;

    // calculate a cookie
    if (cSinks == 0)
    {
        dwCookie = 0;
        iSink = 0;
    }
    else
    {
        // we are guarenteed to break from the loop because we already know
        // that there are fewer than 17M entries
        dwCookie = 0x00ffffff;
        for (iSink = cSinks-1; iSink>=0; iSink--)
        {
            dw = rgSinks->GetPtr(iSink)->dwCookie;
            if (dwCookie > dw)
            {
                iSink++;
                dwCookie = dw + 1; // keep the cookie as low as possible
                break;
            }
            dwCookie = dw - 1;
        }
        Assert(dwCookie <= 0x00ffffff);
    }

    if (!rgSinks->Insert(iSink, 1))
    {
        punkSink->Release();
        return E_OUTOFMEMORY;
    }

    pgs = rgSinks->GetPtr(iSink);
    pgs->pSink = punkSink; // already AddRef'd from the qi
    pgs->dwCookie = dwCookie;

    *pdwCookie = (iArray << 24) | dwCookie;

    if (ppSink != NULL)
    {
        *ppSink = pgs;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GenericUnadviseSink
//
//----------------------------------------------------------------------------

HRESULT GenericUnadviseSink(CStructArray<GENERICSINK> *rgSinkArrays, UINT cConnectionPts, DWORD dwCookie, UINT_PTR *puPrivate /* = NULL */)
{
    UINT iArray;
    int iMin;
    int iMax;
    int iMid;
    HRESULT hr;
    GENERICSINK *pgs;
    CStructArray<GENERICSINK> *rgSinks;

    if (dwCookie == GENERIC_ERROR_COOKIE)
        return E_INVALIDARG;

    iArray = GenericCookieToGUIDIndex(dwCookie);

    if (iArray >= cConnectionPts)
        return CONNECT_E_NOCONNECTION;

    dwCookie &= 0x00ffffff;
    rgSinks = &rgSinkArrays[iArray];
    hr = CONNECT_E_NOCONNECTION;

    iMid = -1;
    iMin = 0;
    iMax = rgSinks->Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pgs = rgSinks->GetPtr(iMid);

        if (pgs->dwCookie < dwCookie)
        {
            iMin = iMid + 1;
        }
        else if (pgs->dwCookie > dwCookie)
        {
            iMax = iMid;
        }
        else // pgs->dwCookie == dwCookie
        {
            if (puPrivate != NULL)
            {
                *puPrivate = pgs->uPrivate;
            }
            pgs->pSink->Release();

            rgSinks->Remove(iMid, 1);

            hr = S_OK;
            break;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestCookie
//
//----------------------------------------------------------------------------

HRESULT RequestCookie(CStructArray<DWORD> *rgCookies, DWORD *pdwCookie)
{
    DWORD dwCookie;
    int  iId;
    UINT cCookies = rgCookies->Count();
    DWORD *pdw;

    // calculate a cookie
    if (cCookies == 0)
    {
        dwCookie = 0;
        iId = 0;
    }
    else
    {
        // we are guarenteed to break from the loop because we already know
        // that there are fewer than 17M entries
        dwCookie = 0x7fffffff;
        for (iId = cCookies-1; iId >= 0; iId--)
        {
            DWORD dw = *(rgCookies->GetPtr(iId));
            if (dwCookie > dw)
            {
                iId++;
                dwCookie = dw + 1; // keep the cookie as low as possible
                break;
            }
            dwCookie = dw - 1;
        }
        Assert(dwCookie <= 0x00ffffff);
    }
    if (!rgCookies->Insert(iId, 1))
    {
        return E_OUTOFMEMORY;
    }

    pdw = rgCookies->GetPtr(iId);
    *pdw = dwCookie;

    dwCookie |= 0x80000000;
    *pdwCookie = dwCookie;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ReleaseCookie
//
//----------------------------------------------------------------------------

HRESULT ReleaseCookie(CStructArray<DWORD> *rgCookies, DWORD dwCookie)
{
    int iMin;
    int iMax;
    int iMid;
    HRESULT hr = CONNECT_E_NOCONNECTION;

    if (!(dwCookie & 0x80000000))
        return hr;

    dwCookie &= 0x7fffffff;

    iMid = -1;
    iMin = 0;
    iMax = rgCookies->Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        DWORD dw = *(rgCookies->GetPtr(iMid));

        if (dw < dwCookie)
        {
            iMin = iMid + 1;
        }
        else if (dw > dwCookie)
        {
            iMax = iMid;
        }
        else // dw == dwCookie
        {
            rgCookies->Remove(iMid, 1);
            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\syslbar.cpp ===
//
// syslbar.cpp
//

#include "private.h"
#include "syslbar.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CSystemLBarSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSystemLBarSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfSystemLangBarItemSink))
    {
        *ppvObj = SAFECAST(this, ITfSystemLangBarItemSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSystemLBarSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSystemLBarSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSystemLBarSink::CSystemLBarSink(SYSLBARCALLBACK pfn, void *pv)
{
    _pfn = pfn;
    _pv = pv;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSystemLBarSink::~CSystemLBarSink()
{
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CSystemLBarSink::_Advise(ITfThreadMgr *ptim, REFGUID rguid)
{
    HRESULT hr;
    ITfSource *source = NULL;
    ITfLangBarItemMgr *plbimgr = NULL;
    ITfLangBarItem *plbi = NULL;

    _ptim = NULL;
    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfLangBarItemMgr, (void **)&plbimgr)))
        goto Exit;

    if (plbimgr->GetItem(rguid, &plbi) != S_OK)
        goto Exit;

    if (FAILED(plbi->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfSystemLangBarItemSink, this, &_dwCookie)))
        goto Exit;

    hr = S_OK;
    _ptim = ptim;
    _ptim->AddRef();
    _guid = rguid;

Exit:
    SafeRelease(source);
    SafeRelease(plbimgr);
    SafeRelease(plbi);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CSystemLBarSink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;
    ITfLangBarItemMgr *plbimgr = NULL;
    ITfLangBarItem *plbi = NULL;

    hr = E_FAIL;

    if (_ptim == NULL)
        goto Exit;

    if (FAILED(_ptim->QueryInterface(IID_ITfLangBarItemMgr, (void **)&plbimgr)))
        goto Exit;

    if (FAILED(plbimgr->GetItem(_guid, &plbi)))
        goto Exit;

    if (FAILED(plbi->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeRelease(plbimgr);
    SafeRelease(plbi);
    SafeReleaseClear(_ptim);
    return hr;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CSystemLBarSink::InitMenu(ITfMenu *pMenu)
{
    return _pfn(IDSLB_INITMENU, _pv, pMenu, -1);
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CSystemLBarSink::OnMenuSelect(UINT wID)
{
    return _pfn(IDSLB_ONMENUSELECT, _pv, NULL, wID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\regsvr.cpp ===
//
// regsvr.cpp
//

#include "private.h"
#include "regsvr.h"
#include "cregkey.h"
#include <advpub.h>


//+------------------------------------------------------------------------
//
//  Function:   CLSIDToString
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const char szDigits[] = "0123456789ABCDEF";

BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Function:   StringToCLSID
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

BOOL HexStringToDword(LPCSTR &lpsz, DWORD &Value, int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

BOOL StringAToCLSID(char *pchA, GUID *pGUID)
{
    DWORD dw;
    char *lpsz;

    if (*pchA != '{')
        return FALSE;

    lpsz = ++pchA;

    if (!HexStringToDword(lpsz, pGUID->Data1, sizeof(DWORD)*2, '-'))
        return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pGUID->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pGUID->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
        return FALSE;

    pGUID->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '}'))
        return FALSE;

    pGUID->Data4[7] = (BYTE)dw;

    return (*lpsz == '\0');
}

//+------------------------------------------------------------------------
//
//  Function:   CLSIDToString
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

BOOL CLSIDToStringW(REFGUID refGUID, WCHAR *pchW)
{
    int i;
    WCHAR *p = pchW;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = L'{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = L'}';
    *p   = L'\0';

    return TRUE;
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG RecurseDeleteKey(HKEY hParentKey, LPCTSTR lpszKey)
{
    HKEY hKey;
    LONG lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = sizeof(szBuffer);

    if (RegOpenKey(hParentKey, lpszKey, &hKey) != ERROR_SUCCESS)
        return ERROR_SUCCESS; // let's assume we couldn't open it because it's not there

    lRes = ERROR_SUCCESS;
    while (RegEnumKeyEx(hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time)==ERROR_SUCCESS)
    {
        lRes = RecurseDeleteKey(hKey, szBuffer);
        if (lRes != ERROR_SUCCESS)
            break;
        dwSize = sizeof(szBuffer);
    }
    RegCloseKey(hKey);

    return lRes == ERROR_SUCCESS ? RegDeleteKey(hParentKey, lpszKey) : lRes;
}


// set pszDesc == NULL to unregister, otherwise register
BOOL RegisterServer(REFCLSID clsid, LPCTSTR pszDesc, LPCTSTR pszPath, LPCTSTR pszModel, LPCTSTR pszSoftwareKey)
{
    static const TCHAR c_szInfoKeyPrefix[] = TEXT("CLSID\\");
    static const TCHAR c_szInProcSvr32[] = TEXT("InProcServer32");
    static const TCHAR c_szModelName[] = TEXT("ThreadingModel");

    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];
    DWORD dw;
    HKEY hKey;
    HKEY hSubKey;
    BOOL fRet;

    if (!CLSIDToStringA(clsid, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return FALSE;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    if (pszDesc != NULL)
    {
        if (fRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, achIMEKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw)
                == ERROR_SUCCESS)
        {
            fRet &= RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)pszDesc, (lstrlen(pszDesc)+1)*sizeof(TCHAR))
                == ERROR_SUCCESS;

            if (fRet &= RegCreateKeyEx(hKey, c_szInProcSvr32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, &dw)
                == ERROR_SUCCESS)
            {
                fRet &= RegSetValueEx(hSubKey, NULL, 0, REG_SZ, (BYTE *)pszPath, (lstrlen(pszPath)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
                fRet &= RegSetValueEx(hSubKey, c_szModelName, 0, REG_SZ, (BYTE *)pszModel, (lstrlen(pszModel)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
                RegCloseKey(hSubKey);
            }
            RegCloseKey(hKey);
        }
    }
    else
    {
        fRet = (RecurseDeleteKey(HKEY_CLASSES_ROOT, achIMEKey) == ERROR_SUCCESS) &&
               (pszSoftwareKey == NULL || RecurseDeleteKey(HKEY_LOCAL_MACHINE, pszSoftwareKey) == ERROR_SUCCESS);
    }

    return fRet;
}

// set pszDesc == NULL to unregister, otherwise register
BOOL RegisterServerW(REFCLSID clsid, const WCHAR *pszDesc, const WCHAR *pszPath, const WCHAR *pszModel, const WCHAR  *pszSoftwareKey, const WCHAR *pszMenuTextPUI)
{
    static const WCHAR c_wszInfoKeyPrefix[] = L"CLSID\\";
    static const WCHAR c_wszInProcSvr32[] = L"InProcServer32";
    static const WCHAR c_wszModelName[] = L"ThreadingModel";
    static const WCHAR c_wszMenuTextPUI[] = L"MenuTextPUI";

    WCHAR achIMEKey[ARRAYSIZE(c_wszInfoKeyPrefix) + CLSID_STRLEN];
    CMyRegKey hKey;
    CMyRegKey hSubKey;
    BOOL fRet = FALSE;

    if (!CLSIDToStringW(clsid, achIMEKey + ARRAYSIZE(c_wszInfoKeyPrefix) - 1))
        return fRet;

    memcpy(achIMEKey, c_wszInfoKeyPrefix, sizeof(c_wszInfoKeyPrefix)-sizeof(WCHAR));

    if (pszDesc != NULL)
    {
        if (fRet = hKey.CreateW(HKEY_CLASSES_ROOT, achIMEKey, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE) == ERROR_SUCCESS)
        {
            fRet &= hKey.SetValueW(pszDesc) == ERROR_SUCCESS;
            if (pszMenuTextPUI)
                 fRet &= hKey.SetValueW(pszMenuTextPUI, c_wszMenuTextPUI) == ERROR_SUCCESS;

            if (fRet &= hSubKey.CreateW(hKey, c_wszInProcSvr32, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE) == ERROR_SUCCESS)
            {
                fRet &= hSubKey.SetValueW(pszPath) == ERROR_SUCCESS;
                fRet &= hSubKey.SetValueW(pszModel, c_wszModelName) == ERROR_SUCCESS;
            }
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\tes.cpp ===
//
// tes.cpp
//

#include "private.h"
#include "tes.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CTextEventSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTextEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = SAFECAST(this, ITfTextEditSink *);
    }
    else if (IsEqualIID(riid, IID_ITfTextLayoutSink))
    {
        *ppvObj = SAFECAST(this, ITfTextLayoutSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTextEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTextEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTextEventSink::CTextEventSink(TESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CTextEventSink"));

    _cRef = 1;
    _dwEditCookie = TES_INVALID_COOKIE;
    _dwLayoutCookie = TES_INVALID_COOKIE;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// EndEdit
//
//----------------------------------------------------------------------------

STDAPI CTextEventSink::OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    TESENDEDIT ee;

    ee.ecReadOnly = ecReadOnly;
    ee.pEditRecord = pEditRecord;
    ee.pic = pic;

    return _pfnCallback(ICF_TEXTDELTA, _pv, &ee);
}

//+---------------------------------------------------------------------------
//
// OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CTextEventSink::OnLayoutChange(ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView)
{
    UINT uCode;

    switch (lcode)
    {
        case TF_LC_CREATE:
            uCode = ICF_LAYOUTDELTA_CREATE;
            break;
        case TF_LC_CHANGE:
            uCode = ICF_LAYOUTDELTA;
            break;
        case TF_LC_DESTROY:
            uCode = ICF_LAYOUTDELTA_DESTROY;
            break;
        default:
            Assert(0); // no other codes defined
            return E_INVALIDARG;
    }

    return _pfnCallback(uCode, _pv, pView);
}

//+---------------------------------------------------------------------------
//
// CTextEventSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CTextEventSink::_Advise(ITfContext *pic, DWORD dwFlags)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;
    _dwFlags = dwFlags;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (dwFlags & ICF_TEXTDELTA)
    {
        if (FAILED(source->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &_dwEditCookie)))
            goto Exit;
    }
    if (dwFlags & ICF_LAYOUTDELTA)
    {
        if (FAILED(source->AdviseSink(IID_ITfTextLayoutSink, (ITfTextLayoutSink *)this, &_dwLayoutCookie)))
        {
            source->UnadviseSink(_dwEditCookie);
            goto Exit;
        }
    }

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CTextEventSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CTextEventSink::_Unadvise()
{
    HRESULT hr;
    BOOL f;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    f = TRUE;
    
    if (_dwFlags & ICF_TEXTDELTA)
    {
        f = SUCCEEDED(source->UnadviseSink(_dwEditCookie));
    }
    if (_dwFlags & ICF_LAYOUTDELTA)
    {
        f &= SUCCEEDED(source->UnadviseSink(_dwLayoutCookie));
    }

    if (!f)
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pic);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\timsink.cpp ===
//
// des.cpp
//
// CThreadMgrEventSink
//

#include "private.h"
#include "timsink.h"
#include "helpers.h"


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfThreadMgrEventSink))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CThreadMgrEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CThreadMgrEventSink::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CThreadMgrEventSink::CThreadMgrEventSink(DIMCALLBACK pfnDIMCallback, ICCALLBACK pfnICCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CThreadMgrEventSink"));

    _pfnDIMCallback = pfnDIMCallback;
    _pfnICCallback = pfnICCallback;
    _pv = pv;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CThreadMgrEventSink::~CThreadMgrEventSink()
{
}

//+---------------------------------------------------------------------------
//
// OnInitDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnInitDocumentMgr(ITfDocumentMgr *dim)
{
    if (!_pfnDIMCallback)
        return S_OK;

    return _pfnDIMCallback(TIM_CODE_INITDIM, dim, NULL, _pv);
}

//+---------------------------------------------------------------------------
//
// UninitializeDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnUninitDocumentMgr(ITfDocumentMgr *dim)
{
    if (!_pfnDIMCallback)
        return S_OK;

    return _pfnDIMCallback(TIM_CODE_UNINITDIM, dim, NULL, _pv);
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnSetFocus(ITfDocumentMgr *dimFocus, ITfDocumentMgr *dimPrevFocus)
{
    if (!_pfnDIMCallback)
        return S_OK;

    return  _pfnDIMCallback(TIM_CODE_SETFOCUS, dimFocus, dimPrevFocus, _pv);
}

//+---------------------------------------------------------------------------
//
// OnPushContext
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnPushContext(ITfContext *pic)
{
    if (!_pfnICCallback)
        return S_OK;

    return _pfnICCallback(TIM_CODE_INITIC, pic, _pv);
}

//+---------------------------------------------------------------------------
//
// OnPopDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnPopContext(ITfContext *pic)
{
    if (!_pfnICCallback)
        return S_OK;

    return _pfnICCallback(TIM_CODE_UNINITIC, pic, _pv);
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CThreadMgrEventSink::_Advise(ITfThreadMgr *tim)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _tim = NULL;
    hr = E_FAIL;

    if (tim->QueryInterface(IID_ITfSource, (void **)&source) != S_OK)
        goto Exit;

    if (source->AdviseSink(IID_ITfThreadMgrEventSink, this, &_dwCookie) != S_OK)
        goto Exit;

    _tim = tim;
    _tim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CThreadMgrEventSink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_tim == NULL)
        goto Exit;

    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) != S_OK)
        goto Exit;

    if (source->UnadviseSink(_dwCookie) != S_OK)
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_tim);
    return hr;
}

//+---------------------------------------------------------------------------
//
// InitDIMs
//
//  This is a simple helper function to enumerate DIMs and ICs.
//  When the tips is activated, it can call this method to call callbacks
//  for exsiting DIMs and ICs.
//  
//----------------------------------------------------------------------------

HRESULT CThreadMgrEventSink::_InitDIMs(BOOL fInit)
{
    IEnumTfDocumentMgrs *pEnumDim = NULL;
    ITfDocumentMgr *pdim = NULL;
    ITfDocumentMgr *pdimFocus = NULL;

    if (FAILED(_tim->GetFocus(&pdimFocus)))
        goto Exit;

    if (_tim->EnumDocumentMgrs(&pEnumDim) != S_OK)
        goto Exit;

    if (fInit)
    {
        while (pEnumDim->Next(1, &pdim, NULL) == S_OK)
        {
            if (_pfnDIMCallback)
                _pfnDIMCallback(TIM_CODE_INITDIM,  pdim, NULL, _pv);

            if (_pfnICCallback)
            {
                IEnumTfContexts *pEnumIc = NULL;
                if (SUCCEEDED(pdim->EnumContexts(&pEnumIc)))
                {
                    ITfContext *pic = NULL;
                    while (pEnumIc->Next(1, &pic, NULL) == S_OK)
                    {
                        _pfnICCallback(TIM_CODE_INITIC, pic, _pv);
                        pic->Release();
                    }
                    pEnumIc->Release();
                }
            }

            if (_pfnDIMCallback && (pdim == pdimFocus))
            {
                _pfnDIMCallback(TIM_CODE_SETFOCUS, pdim, NULL, _pv);
            }

            pdim->Release();
        }
    }
    else
    {
        while (pEnumDim->Next(1, &pdim, NULL) == S_OK)
        {
            if (_pfnDIMCallback && (pdim == pdimFocus))
            {
                _pfnDIMCallback(TIM_CODE_SETFOCUS, NULL, pdim, _pv);
            }

            if (_pfnICCallback)
            {
                IEnumTfContexts *pEnumIc = NULL;
                if (SUCCEEDED(pdim->EnumContexts(&pEnumIc)))
                {
                    ITfContext *pic = NULL;
                    while (pEnumIc->Next(1, &pic, NULL) == S_OK)
                    {
                        _pfnICCallback(TIM_CODE_UNINITIC, pic, _pv);
                        pic->Release();
                    }
                    pEnumIc->Release();
                }
            }

            if (_pfnDIMCallback)
                _pfnDIMCallback(TIM_CODE_UNINITDIM, pdim, NULL, _pv);

            pdim->Release();
        }
    }

Exit:
    SafeRelease(pEnumDim);
    SafeRelease(pdimFocus);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\xstring.cpp ===
//
// xstring.cpp
//
// Unicode/ansi conversion.
//
#include "private.h"
#include "xstring.h"

//+------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsi
//
//  Synopsis:   Converts unicode to mbcs.  If the supplied ansi buffer
//              is not large enough to accomodate the converted text a new
//              buffer is allocated.
//
//              uLenW -> the length in unicode chars of pchW, not including a '\0' if present.
//                       pchW is not assumed to be null terminated.
//              uSizeA -> the size in ansi chars of the pchAIn array.
//              Pass in uSizeA == 0 to force memory allocation.
//              Use BufferAllocFree to free any allocated memory.
//
//-------------------------------------------------------------------------
char *UnicodeToAnsi(UINT uCodePage, const WCHAR *pchW, UINT uLenW, char *pchAIn, UINT uSizeA)
{
    char *pchA;
    UINT uLenA;
    BOOL fUsedDefault;

    Assert(uSizeA == 0 || (uSizeA && pchAIn));

    uLenA = WideCharToMultiByte(uCodePage, 0, pchW, uLenW, NULL, 0, NULL, NULL);

    pchA = (uLenA >= uSizeA) ? (char *)cicMemAlloc(uLenA + 1) : pchAIn;

    if (pchA == NULL)
        return NULL;

    if ((!WideCharToMultiByte(uCodePage, 0, pchW, uLenW, pchA, uLenA, NULL, &fUsedDefault) && uLenW) ||
        fUsedDefault)
    {
        BufferAllocFree(pchAIn, pchA);
        pchA = NULL;
    }
    else
    {
        pchA[uLenA] = '\0';
    }

    return pchA;
}

//+------------------------------------------------------------------------
//
//  Function:   AnsiToUnicode
//
//  Synopsis:   Converts mbcs to unicode.  If the supplied unicode buffer
//              is not large enough to accomodate the converted text a new
//              buffer is allocated.
//
//              uLenA -> the length in ansi chars of pchA, not including a '\0' if present.
//                       pchA is not assumed to be null terminated.
//              uSizeW -> the size in unicode chars of the pchWIn array.
//              Pass in uSizeW == 0 to force memory allocation.
//              Use BufferAllocFree to free any allocated memory.
//
// Copied from dimm.dll/util.cpp
//-------------------------------------------------------------------------
WCHAR *AnsiToUnicode(UINT uCodePage, const char *pchA, UINT uLenA, WCHAR *pchWIn, UINT uSizeW)
{
    WCHAR *pchW;
    UINT uLenW;

    Assert(uSizeW == 0 || (uSizeW && pchWIn));

    uLenW = MultiByteToWideChar(uCodePage, 0, pchA, uLenA, NULL, 0);

    pchW = (uLenW >= uSizeW) ? (WCHAR *)cicMemAlloc((uLenW + 1) * sizeof(WCHAR)) : pchWIn;

    if (pchW == NULL)
        return NULL;

    if (!MultiByteToWideChar(uCodePage, MB_ERR_INVALID_CHARS, pchA, uLenA, pchW, uLenW) && uLenA)
    {
        BufferAllocFree(pchWIn, pchW);
        pchW = NULL;
    }
    else
    {
        pchW[uLenW] = '\0';
    }

    return pchW;
}

//+------------------------------------------------------------------------
//
//  Function:   BufferAllocFree
//
//  Synopsis:   Frees any memory allocated in a previous call to UnicodeToAnsi.
//
//-------------------------------------------------------------------------
void BufferAllocFree(void *pBuffer, void *pAllocMem)
{
    if (pAllocMem && pAllocMem != pBuffer)
    {
        cicMemFree(pAllocMem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candcomp.h ===
//
// candcomp.h - Candidate UI Compartment Manager
//

#ifndef CANDCOMP_H
#define CANDCOMP_H

#include "candkey.h"


class CCandidateUI;


//
// CCandUICompartmentMgr
//  = candidate UI compartment manager =
//

class CCandUICompartmentMgr
{
public:
	CCandUICompartmentMgr( void );
	virtual ~CCandUICompartmentMgr( void );

	HRESULT Initialize( CCandidateUI *pCandUI );
	HRESULT Uninitialize( void );

	HRESULT SetUIStyle( IUnknown *punk, CANDUISTYLE style );
	HRESULT GetUIStyle( IUnknown *punk, CANDUISTYLE *pstyle );
	HRESULT SetUIOption( IUnknown *punk, DWORD dwOption );
	HRESULT GetUIOption( IUnknown *punk, DWORD *pdwOption );

	HRESULT SetKeyTable( IUnknown *punk, CCandUIKeyTable *pCandUIKeyTable );
	HRESULT GetKeyTable( IUnknown *punk, CCandUIKeyTable **ppCandUIKeyTable );
	HRESULT ClearKeyTable( IUnknown *punk );

protected:
	CCandidateUI *m_pCandUI;
};

#endif // CANDCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candacc.cpp ===
//
//
//

#include "private.h"
#include "immxutil.h"
#include "candacc.h"

//
//
//

static BOOL fMSAAAvail      = FALSE;
static HMODULE hLibUser32   = NULL;
static HMODULE hLibOleAcc   = NULL;
static HMODULE hLibOle32    = NULL;
static HMODULE hLibOleAut32 = NULL;

typedef void    (*LPFN_NOTIFYWINEVENT)( DWORD, HWND, LONG, LONG );
typedef HRESULT (*LPFN_LOADREGTYPELIB)( REFGUID, unsigned short, unsigned short, LCID, ITypeLib FAR* FAR* );
typedef HRESULT (*LPFN_LOADTYPELIB)( OLECHAR FAR*, ITypeLib FAR* FAR* );
typedef HRESULT (*LPFN_CREATESTDACCESSIBLEOBLECT)( HWND, LONG, REFIID, void** );
typedef LRESULT (*LPFN_LRESULTFROMOBJECT)( REFIID, WPARAM, LPUNKNOWN );

static LPFN_NOTIFYWINEVENT             lpfnNotifyWinEvent             = NULL;
static LPFN_LOADREGTYPELIB             lpfnLoadRegTypeLib             = NULL;
static LPFN_LOADTYPELIB                lpfnLoadTypeLib                = NULL;
static LPFN_CREATESTDACCESSIBLEOBLECT  lpfnCreateStdAccessibleObject  = NULL;
static LPFN_LRESULTFROMOBJECT          lpfnLresultFromObject          = NULL;


/*   I N I T  C A N D  A C C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitCandAcc( void )
{
	if (fMSAAAvail) {
		return;
	}

	//
	// load libs
	//
	hLibUser32 = GetSystemModuleHandle( "user32.dll" );
	hLibOleAcc = LoadSystemLibrary( "oleacc.dll" );
	hLibOle32 = LoadSystemLibrary( "ole32.dll" );
	hLibOleAut32 = LoadSystemLibrary( "oleaut32.dll" );

	if (hLibUser32 == NULL || hLibOle32 == NULL || hLibOleAut32 == NULL || hLibOleAcc == NULL) {
		return;
	}

	//
	// get proc address
	//
	lpfnNotifyWinEvent             = (LPFN_NOTIFYWINEVENT)GetProcAddress( hLibUser32, "NotifyWinEvent" );
	lpfnLoadRegTypeLib             = (LPFN_LOADREGTYPELIB)GetProcAddress( hLibOleAut32, "LoadRegTypeLib" );
	lpfnLoadTypeLib                = (LPFN_LOADTYPELIB)GetProcAddress( hLibOleAut32, "LoadTypeLib" );
	lpfnCreateStdAccessibleObject  = (LPFN_CREATESTDACCESSIBLEOBLECT)GetProcAddress( hLibOleAcc, "CreateStdAccessibleObject" );
	lpfnLresultFromObject          = (LPFN_LRESULTFROMOBJECT)GetProcAddress( hLibOleAcc, "LresultFromObject" );

	if( lpfnNotifyWinEvent == NULL ||
		lpfnLoadRegTypeLib == NULL ||
		lpfnLoadTypeLib == NULL ||
		lpfnCreateStdAccessibleObject == NULL ||
		lpfnLresultFromObject == NULL) {
		return;
	}

	fMSAAAvail = TRUE;
}


/*   D O N E  C A N D  A C C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneCandAcc( void )
{
	if (hLibOleAut32 != NULL) {
		FreeLibrary( hLibOleAut32 );
	}

	if (hLibOle32 != NULL) {
		FreeLibrary( hLibOle32 );
	}

	if (hLibOleAcc != NULL) {
		FreeLibrary( hLibOleAcc );
	}

	lpfnNotifyWinEvent             = NULL;
	lpfnLoadRegTypeLib             = NULL;
	lpfnLoadTypeLib                = NULL;
	lpfnCreateStdAccessibleObject  = NULL;
	lpfnLresultFromObject          = NULL;

	fMSAAAvail = FALSE;
}


/*   O U R  N O T I F Y  W I N  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
static __inline void OurNotifyWinEvent( DWORD event, HWND hWnd, LONG idObject, LONG idChild )
{
	if (fMSAAAvail) {
		lpfnNotifyWinEvent( event, hWnd, idObject, idChild );
	}
}


/*   O U R  C R E A T E  S T D  A C C E S S I B L E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
static __inline HRESULT OurCreateStdAccessibleObject( HWND hWnd, LONG idObject, REFIID riid, void** ppvObject )
{
	if (fMSAAAvail) {
		return lpfnCreateStdAccessibleObject( hWnd, idObject, riid, ppvObject );
	}
	return S_FALSE;
}


/*   O U R  L R E S U L T  F R O M  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
static __inline LRESULT OurLresultFromObject( REFIID riid, WPARAM wParam, LPUNKNOWN punk )
{
	if (fMSAAAvail) {
		return lpfnLresultFromObject(riid,wParam,punk);
	}
	return 0;
}


/*   O U R  L O A D  R E G  T Y P E  L I B   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
static __inline HRESULT OurLoadRegTypeLib( REFGUID rguid, unsigned short wVerMajor, unsigned short wVerMinor, LCID lcid, ITypeLib FAR* FAR* pptlib )
{
	if (fMSAAAvail) {
		return lpfnLoadRegTypeLib( rguid, wVerMajor, wVerMinor, lcid, pptlib );
	}
	return S_FALSE;
}


/*   O U R  L O A D  T Y P E  L I B   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
static __inline HRESULT OurLoadTypeLib( OLECHAR FAR *szFile, ITypeLib FAR* FAR* pptlib )
{
	if (fMSAAAvail) {
		return lpfnLoadTypeLib( szFile, pptlib );
	}
	return S_FALSE;
}


//
//
//

/*   C  C A N D  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandAccItem::CCandAccItem( void )
{
	m_pCandAcc = NULL;
	m_iItemID  = 0;
}


/*   ~  C  C A N D  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandAccItem::~CCandAccItem( void )
{
}


/*   I N I T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandAccItem::Init( CCandAccessible *pCandAcc, int iItemID )
{
	m_pCandAcc = pCandAcc;
	m_iItemID  = iItemID;
}


/*   G E T  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CCandAccItem::GetID( void )
{
	return m_iItemID;
}


/*   G E T  A C C  N A M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BSTR CCandAccItem::GetAccName( void )
{
	return SysAllocString( L"" );
}


/*   G E T  A C C  V A L U E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BSTR CCandAccItem::GetAccValue( void )
{
	return NULL;
}


/*   G E T  A C C  R O L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LONG CCandAccItem::GetAccRole( void )
{
	return ROLE_SYSTEM_CLIENT;
}


/*   G E T  A C C  S T A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LONG CCandAccItem::GetAccState( void )
{
	return STATE_SYSTEM_DEFAULT;
}


/*   G E T  A C C  L O C A T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandAccItem::GetAccLocation( RECT *prc )
{
	SetRect( prc, 0, 0, 0, 0 );
}


/*   N O T I F Y  W I N  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandAccItem::NotifyWinEvent( DWORD dwEvent )
{
	if (m_pCandAcc != NULL) {
		m_pCandAcc->NotifyWinEvent( dwEvent, this );
	}
}


//
// CCandAccessible
//

/*   C  C A N D  A C C E S S I B L E   */
/*------------------------------------------------------------------------------

	Constructor of CCandAccessible

------------------------------------------------------------------------------*/
CCandAccessible::CCandAccessible( CCandAccItem *pAccItemSelf )
{
	m_cRef = 1;
	m_hWnd = NULL;
	m_pTypeInfo = NULL;
	m_pDefAccClient = NULL;

	m_fInitialized = FALSE;
	m_nAccItem = 0;

	// register itself

	pAccItemSelf->Init( this, CHILDID_SELF );
	m_rgAccItem[0] = pAccItemSelf;

	m_nAccItem = 1;
}


/*   ~  C  C A N D  A C C E S S I B L E   */
/*------------------------------------------------------------------------------

	Destructor of CCandAccessible

------------------------------------------------------------------------------*/
CCandAccessible::~CCandAccessible( void )
{
	SafeReleaseClear( m_pTypeInfo );
	SafeReleaseClear( m_pDefAccClient );
}


/*   S E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandAccessible::SetWindow( HWND hWnd )
{
	m_hWnd = hWnd;
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	Initialize()
//
//	DESCRIPTION:
//
//		Initializes the state of the CCandAccessible object, performing
//		tasks that might normally be done in a class constructor but
//		are done here to trap any errors.
//
//	PARAMETERS:
//
//		hWnd			Handle to the HWND object with which this
//						  Accessible object is associated.  This
//						  is the handle to our main window.
//
//		hInst			Instance handle for this instance of the
//						  application.
//
//	RETURNS:
//
//		HRESULT			NOERROR if the CCandAccessible object is
//						  initialized successfully, a COM error
//						  code otherwise.
//
//	NOTES:
//
//		It is assumed that this method will be called for the object
//		immediately after and only after the object is constructed.
//
// ----------------------------------------------------------------------

------------------------------------------------------------------------------*/
HRESULT CCandAccessible::Initialize( void )
{
	HRESULT  hr;
	ITypeLib *piTypeLib;

	m_fInitialized = TRUE;

	//-----------------------------------------------------
	//	For our client window, create a system provided
	//	  Accessible object which implements the default
	//	  client window Accessibility behavior.
	//
	//	Our implementation of CCandAccessible will use the
	//	  default object's implementation as needed.  In
	//	  essence, CCandAccessible "inherits" its functionality
	//	  from the standard object, "customizing" or
	//	  "overriding" various methods for which the
	//	  standard implementation is insufficent for the
	//	  specifics of the window for which CCandAccessible
	//	  provides Accessibility.
	//-----------------------------------------------------

	hr = OurCreateStdAccessibleObject( m_hWnd,
									OBJID_CLIENT,
									IID_IAccessible,
									(void **) &m_pDefAccClient );
	if (FAILED( hr )) {
		return hr;
	}

	//-----------------------------------------------------
	//	Obtain an ITypeInfo pointer to our type library.
	//	  The ITypeInfo pointer is used to implement the
	//	  IDispatch interface.
	//-----------------------------------------------------

	//-----------------------------------------------------
	//	First, attempt to load the Accessibility type
	//	  library version 1.0 using the registry.
	//-----------------------------------------------------

	hr = LoadRegTypeLib( LIBID_Accessibility, 1, 0, 0, &piTypeLib );

	//-----------------------------------------------------
	//	If we fail to load the type library from the
	//	  registry information, explicitly try to load
	//	  it from the MSAA system DLL.
	//-----------------------------------------------------

	if (FAILED( hr )) {
		static OLECHAR szOleAcc[] = L"OLEACC.DLL";
		hr = LoadTypeLib( szOleAcc, &piTypeLib );
	}

	//-----------------------------------------------------
	//	If we successfully load the type library, attempt
	//	  to get the IAccessible type description
	//	  (ITypeInfo pointer) from the type library.
	//-----------------------------------------------------

	if (SUCCEEDED( hr )) {
		hr = piTypeLib->GetTypeInfoOfGuid( IID_IAccessible, &m_pTypeInfo );
		piTypeLib->Release();
	}

	return hr;
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	QueryInterface()
//
//	DESCRIPTION:
//
//		Implements the IUnknown interface method QueryInterface().
//
//	PARAMETERS:
//
//		riid			[in]  The requested interface's IID.
//		ppv				[out] If the requested interface is supported,
//						      ppv points to the location of a pointer
//						      to the requested interface.  If the
//						      requested interface is not supported,
//						      ppv is set to NULL.
//
//	RETURNS:
//
//		HRESULT			S_OK if the interface is supported,
//						  E_NOINTERFACE if the interface is not
//						  supported, or some other COM error
//						  if the IEnumVARIANT interface is requested
//						  but cannot be delivered.
//
//	NOTES:
//
//		CCandAccessible correctly supports the IUnknown, IDispatch and
//		IAccessible interfaces.  CCandAccessible also incorrectly supports
//		the IEnumVARIANT interface (to return a VARIANT enumerator
//		containing all its children).  When the IEnumVARIANT
//		interface is requested, an enumerator is created and a
//		pointer to its IEnumVARIANT interface is returned.
//
//		The support for IEnumVARIANT is incorrect because the
//		interface pointer returned is not symmetric with respect
//		to the interface from which it was obtained.  For example,
//		assume that pIA is a pointer to an IAccessible interface.
//		Then, even though pIA->QueryInterface(IID_IEnumVARIANT)
//		succeeds and returns pIEV,
//		pIEV->QueryInterface(IID_Accessibility) will fail because
//		the enumerator has no knowledge of any interface except
//		itself (and IUnknown).
//
//		The original design of MSAA called for IAccessible
//		objects to also be enumerators of their children.  But
//		this design doesn't allow for different clients of the
//		Accessible object to have different enumerations of its
//		children and that is a potentially hazardous situation.
//		(Assume there is an Accessible object that is also a
//		VARIANT enumerator, A, and two clients, C1 and C2.
//		Since C1 and C2 each may be pre-empted will using A,
//		the following is a one of many examples that would pose
//		a problem for at least one client:
//
//			C1:  A->Reset()
//			C1:  A->Skip( 5 )
//			C2:  A->Reset()
//			C1:  A->Next()  ! C1 does not get the child it expects
//
//		So, although it breaks the rules of COM, QueryInterface()
//		as implemented below obtains a distinct VARIANT enumerator
//		for each request.  A better solution to this issue would
//		be if the IAccessible interface provided a method to get
//		the child enumeration or if MSAA provided an exported API
//		to perform this task.
//
// ----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::QueryInterface( REFIID riid, void** ppv )
{
	*ppv = NULL;

	//-----------------------------------------------------
	//	If the IUnknown, IDispatch, or IAccessible
	//	  interface is desired, simply cast the this
	//	  pointer appropriately.
	//-----------------------------------------------------

	if ( riid == IID_IUnknown ) {
		*ppv = (LPUNKNOWN) this;
	} 
	else if ( riid == IID_IDispatch ) {
		*ppv = (IDispatch *) this;
	}
	else if ( riid == IID_IAccessible ) {
		*ppv = (IAccessible *)this;
	}

#ifdef NEVER
	//-----------------------------------------------------
	//	If the IEnumVARIANT interface is desired, create
	//	  a new VARIANT enumerator which contains all
	//	  the Accessible object's children.
	//-----------------------------------------------------

	else if (riid == IID_IEnumVARIANT)
	{
		CEnumVariant*	pcenum;
		HRESULT			hr;

		hr = CreateVarEnumOfAllChildren( &pcenum );

		if ( FAILED( hr ) )
			return hr;

		*ppv = (IEnumVARIANT *) pcenum;
	}
#endif /* NEVER */

	//-----------------------------------------------------
	//	If the desired interface isn't one we know about,
	//	  return E_NOINTERFACE.
	//-----------------------------------------------------

	else {
		return E_NOINTERFACE;
	}

	//-----------------------------------------------------
	//	Increase the reference count of any interface
	//	  returned.
	//-----------------------------------------------------

	((LPUNKNOWN) *ppv)->AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	AddRef()
//
//	DESCRIPTION:
//
//		Implements the IUnknown interface method AddRef().
//
//	PARAMETERS:
//
//		None.
//
//	RETURNS:
//
//		ULONG			Current reference count.
//
//	NOTES:
//
//		The lifetime of the Accessible object is governed by the
//		lifetime of the HWND object for which it provides
//		Accessibility.  The object is created in response to the
//		first WM_GETOBJECT message that the server application
//		is ready to process and is destroyed when the server's
//		main window is destroyed.  Since the object's lifetime
//		is not dependent on a reference count, the object has no
//		internal mechanism for tracking reference counting and
//		AddRef() and Release() always return one.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CCandAccessible::AddRef( void )
{
	return InterlockedIncrement( &m_cRef );
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	Release()
//
//	DESCRIPTION:
//
//		Implements the IUnknown interface method Release().
//
//	PARAMETERS:
//
//		None.
//
//	RETURNS:
//
//		ULONG			Current reference count.
//
//	NOTES:
//
//		The lifetime of the Accessible object is governed by the
//		lifetime of the HWND object for which it provides
//		Accessibility.  The object is created in response to the
//		first WM_GETOBJECT message that the server application
//		is ready to process and is destroyed when the server's
//		main window is destroyed.  Since the object's lifetime
//		is not dependent on a reference count, the object has no
//		internal mechanism for tracking reference counting and
//		AddRef() and Release() always return one.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CCandAccessible::Release( void )
{
	ULONG l = InterlockedDecrement( &m_cRef );
	if (0 < l) {
		return l;
	}

	delete this;
	return 0;    
}


/*   G E T  T Y P E  I N F O  C O U N T   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	GetTypeInfoCount()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetTypeInfoCount().
//
//		Retrieves the number of type information interfaces that an
//		object provides (either 0 or 1).
//
//	PARAMETERS:
//
//		pctInfo		[out] Points to location that receives the
//							number of type information interfaces
//							that the object provides. If the object
//							provides type information, this number
//							is set to 1; otherwise it's set to 0.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeds or 
//							E_INVALIDARG if pctInfo is invalid.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::GetTypeInfoCount( UINT *pctInfo )
{
	if (!pctInfo) {
		return E_INVALIDARG;
	}

	*pctInfo = (m_pTypeInfo == NULL ? 1 : 0);
	return S_OK;
}


/*   G E T  T Y P E  I N F O   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	GetTypeInfo()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetTypeInfo().
//
//		Retrieves a type information object, which can be used to
//		get the type information for an interface.
//
//	PARAMETERS:
//
//		itinfo		[in]  The type information to return. If this value
//							is 0, the type information for the IDispatch
//							implementation is to be retrieved.
//
//		lcid		[in]  The locale ID for the type information.
//
//		ppITypeInfo	[out] Receives a pointer to the type information
//							object requested.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeded (the TypeInfo
//							element exists), TYPE_E_ELEMENTNOTFOUND if
//							itinfo is not equal to zero, or 
//							E_INVALIDARG if ppITypeInfo is invalid.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo )
{
	if (!ppITypeInfo) {
		return E_INVALIDARG;
	}

	*ppITypeInfo = NULL;

	if (itinfo != 0) {
		return TYPE_E_ELEMENTNOTFOUND;
	}
	else if (m_pTypeInfo == NULL) {
		return E_NOTIMPL;
	}

	*ppITypeInfo = m_pTypeInfo;
	m_pTypeInfo->AddRef();

	return S_OK;
}


/*   G E T  I D S  O F  N A M E S   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	GetIDsOfNames()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetIDsOfNames().
//
//		Maps a single member and an optional set of argument names
//		to a corresponding set of integer DISPIDs, which may be used
//		on subsequent calls to IDispatch::Invoke.
//
//	PARAMETERS:
//
//		riid		[in]  Reserved for future use. Must be NULL.
//
//		rgszNames	[in]  Passed-in array of names to be mapped.
//
//		cNames		[in]  Count of the names to be mapped.
//
//		lcid		[in]  The locale context in which to interpret
//							the names.
//
//		rgdispid	[out] Caller-allocated array, each element of
//							which contains an ID corresponding to
//							one of the names passed in the rgszNames
//							array.  The first element represents the
//							member name; the subsequent elements
//							represent each of the member's parameters.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeded,
//							E_OUTOFMEMORY if there is not enough
//							memory to complete the call,
//							DISP_E_UNKNOWNNAME if one or more of
//							the names were not known, or
//							DISP_E_UNKNOWNLCID if the LCID was
//							not recognized.
//
//	NOTES:
//
//		This method simply delegates the call to
//		ITypeInfo::GetIDsOfNames().
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::GetIDsOfNames( REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid )
{
	if (m_pTypeInfo == NULL) {
		return E_NOTIMPL;
	}

	return m_pTypeInfo->GetIDsOfNames( rgszNames, cNames, rgdispid );
}


/*   I N V O K E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	Invoke()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method Invoke().
//
//		Provides access to properties and methods exposed by the
//		Accessible object.
//
//	PARAMETERS:
//
//		dispidMember	[in]  Identifies the dispatch member.
//
//		riid			[in]  Reserved for future use. Must be NULL.
//
//		lcid			[in]  The locale context in which to interpret
//								the names.
//
//		wFlags			[in]  Flags describing the context of the
//									Invoke call.
//
//		pdispparams		[in,] Pointer to a structure containing an
//						[out]	array of arguments, array of argument
//								dispatch IDs for named arguments, and
//								counts for number of elements in the
//								arrays.
//
//		pvarResult		[in,] Pointer to where the result is to be
//						[out]	stored, or NULL if the caller expects
//								no result.  This argument is ignored
//								if DISPATCH_PROPERTYPUT or
//								DISPATCH_PROPERTYPUTREF is specified.
//
//		pexcepinfo		[out] Pointer to a structure containing
//								exception information.  This structure
//								should be filled in if DISP_E_EXCEPTION
//								is returned.
//
//		puArgErr		[out] The index within rgvarg of the first
//								argument that has an error.  Arguments
//								are stored in pdispparams->rgvarg in
//								reverse order, so the first argument
//								is the one with the highest index in
//								the array.
//
//	RETURNS:
//
//		HRESULT			  S_OK on success, dispatch error (DISP_E_*)
//							or E_NOTIMPL otherwise.
//
//	NOTES:
//
//		This method simply delegates the call to ITypeInfo::Invoke().
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::Invoke( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
{
	if (m_pTypeInfo == NULL) {
		return E_NOTIMPL;
	}

	return m_pTypeInfo->Invoke( (IAccessible *)this,
								dispid,
								wFlags,
								pdispparams,
								pvarResult,
								pexcepinfo,
								puArgErr );
}


/*   G E T _ A C C  P A R E N T   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accParent()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accParent().
//
//		Retrieves the IDispatch interface of the current object's
//		parent.
//
//	PARAMETERS:
//
//		ppdispParent	[out] Pointer to the variable that will
//								contain a pointer to the IDispatch
//								interface of CCandAccessible's parent.
//
//	RETURNS:
//
//		HRESULT			The value returned by the standard object's
//						  implementation of get_accParent().
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accParent( IDispatch ** ppdispParent )
{
	//
	// Use the default client window implementation to obtain the parent
	// of our Accessible object.
	//
	return m_pDefAccClient->get_accParent( ppdispParent );
}


/*   G E T _ A C C  C H I L D  C O U N T   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accChildCount()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accChildCount().
//
//		Retrieves the number of children belonging to CCandAccessible.
//
//	PARAMETERS:
//
//		pChildCount		[out] Pointer to the variable that will
//								be filled with the number of children
//								belonging to the CCandAccessible object.
//
//	RETURNS:
//
//		HRESULT			S_OK on success, E_INVALIDARG if pChildCount
//						  is invalid.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accChildCount( long* pChildCount )
{
	if (!pChildCount) {
		return E_INVALIDARG;
	}

	Assert( 0 < m_nAccItem );
	*pChildCount = (m_nAccItem - 1);
	return S_OK;
}


/*   G E T _ A C C  C H I L D   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accChild()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accChild().
//
//		Retrieve an IDispatch interface pointer to the child object
//		that has the given child ID or name.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		ppdispChild		[out] Pointer to the variable that will
//								contain a pointer to the IDispatch
//								interface of specified child object
//								of CCandAccessible.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if ppdispChild is invalid, S_FALSE
//						  otherwise because none of CCandAccessible's
//						  children are objects.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
	if (!ppdispChild) {
		return E_INVALIDARG;
	}

	//-----------------------------------------------------
	//	None of the children of CCandAccessible are objects,
	//	  so none have IDispatch pointers.  Thus, in all
	//	  cases, set the IDispatch pointer to NULL and
	//	  return S_FALSE.
	//-----------------------------------------------------

	*ppdispChild = NULL;
	return S_FALSE;
}


/*   G E T _ A C C  N A M E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accName()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accName().
//
//		Retrieve the name property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszName			[out] Pointer to the BSTR that will contain
//								the child's name property string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid
//						  or the return value from the private method
//						  HrLoadString().
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accName( VARIANT varChild, BSTR *pbstrName )
{
	CCandAccItem *pAccItem;

	if (pbstrName == NULL) {
		return E_INVALIDARG;
	}

	// get acc item

	pAccItem = AccItemFromID( (int)varChild.lVal );
	if (pAccItem == NULL) {
		return E_INVALIDARG;
	}

	// get name of acc item

	*pbstrName = pAccItem->GetAccName();
	return (*pbstrName != NULL) ? S_OK : DISP_E_MEMBERNOTFOUND;
}


/*   G E T _ A C C  V A L U E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accValue()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accValue().
//
//		Retrieves the value property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszValue		[out] Pointer to the BSTR that will contain
//								the child's value property string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid,
//						  DISP_E_MEMBERNOTFOUND if VarChild refers
//						  to any child other than the status bar,
//						  or S_OK.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accValue( VARIANT varChild, BSTR *pbstrValue )
{
	CCandAccItem *pAccItem;

	if (pbstrValue == NULL) {
		return E_INVALIDARG;
	}

	// get acc item

	pAccItem = AccItemFromID( (int)varChild.lVal );
	if (pAccItem == NULL) {
		return E_INVALIDARG;
	}

	// get value of acc item

	*pbstrValue = pAccItem->GetAccValue();
	return (*pbstrValue != NULL) ? S_OK : DISP_E_MEMBERNOTFOUND;
}


/*   G E T _ A C C  D E S C R I P T I O N   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accDescription()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accDescription().
//
//		Retrieves the description property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszDesc			[out] Pointer to the BSTR that will contain
//								the child's description property string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid
//						  or the return value from either the
//						  standard client window implementation of
//						  get_accDescription() or the private method
//						  HrLoadString().
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accDescription( VARIANT varChild, BSTR *pbstrDesc )
{
	if (pbstrDesc == NULL) {
		return E_INVALIDARG;
	}

	return m_pDefAccClient->get_accDescription( varChild, pbstrDesc );
}


/*   G E T _ A C C  R O L E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accRole()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accRole().
//
//		Retrieves the role property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarRole		[out] Pointer to the VARIANT structure that
//								will contain the specified child's
//								role property.  This property may
//								either be in the form of a standard
//								role constant or a custom description
//								string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid,
//						  S_OK if the specified child is the button
//						  or status bar, or the return value from
//						  either the standard client window implementation
//						  of get_accRole() or the private method
//						  HrLoadString().
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accRole( VARIANT varChild, VARIANT *pVarRole )
{
	CCandAccItem *pAccItem;

	if (pVarRole == NULL) {
		return E_INVALIDARG;
	}

	// get acc item

	pAccItem = AccItemFromID( (int)varChild.lVal );
	if (pAccItem == NULL) {
		return E_INVALIDARG;
	}

	// get role of acc item

	pVarRole->vt = VT_I4;
	pVarRole->lVal = pAccItem->GetAccRole();

	return S_OK;
}


//-----------------------------------------------------------------------
//	get_accState()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accState().
//
//		Retrieves the current state for the specified object or child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarState		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the specified child's current state.
//								This information may either be in the
//								form of one or more object state
//								constants or a custom description
//								string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid or
//						  S_OK.
//
//	NOTES:
//
//		Since the icons are HWND based objects, they can never truly
//		have the input focus.  However, if the user clicks one, the main
//		window treats the icon as if it had the focus.  So, the state
//		of the client area should not indicate "focused" when an icon
//		is said to have the focus.
//
//		The push button can have the focus, but it cannot be selected.
//
//-----------------------------------------------------------------------

STDMETHODIMP CCandAccessible::get_accState( VARIANT varChild, VARIANT * pVarState )
{
	CCandAccItem *pAccItem;

	if (pVarState == NULL) {
		return E_INVALIDARG;
	}

	// get acc item

	pAccItem = AccItemFromID( (int)varChild.lVal );
	if (pAccItem == NULL) {
		return E_INVALIDARG;
	}

	// get state of acc item

	pVarState->vt = VT_I4;
	pVarState->lVal = pAccItem->GetAccState();

	return S_OK;
}


/*   G E T _ A C C  H E L P   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accHelp()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accHelp().
//
//		Retrieves the help property string for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszHelp			[out] Pointer to the BSTR that will contain
//								the child's help property string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid,
//						  DISP_E_MEMBERNOTFOUND if VarChild refers
//						  to any icon child, or the return value from
//						  either the standard client window implementation
//						  of get_accHelp() or the private method
//						  HrLoadString().
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accHelp( VARIANT varChild, BSTR *pbstrHelp )
{
	return DISP_E_MEMBERNOTFOUND;	/* no support in candidate UI */
}


/*   G E T _ A C C  H E L P  T O P I C   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accHelpTopic()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accHelpTopic().
//
//		Retrieves the fully qualified path name of the help file
//		associated with the specified object, as well as a pointer
//		to the appropriate topic with in that file.
//
//	PARAMETERS:
//
//		pszHelpFile		[out] Pointer to the BSTR that will contain
//								the fully qualified path name of the
//								help file associated with the child.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pidTopic		[out] Pointer to the value identifying the
//								help file topic associated with the
//								object.
//
//	RETURNS:
//
//		HRESULT			DISP_E_MEMBERNOTFOUND because the help topic
//						  property is not supported for the Accessible
//						  object or any of its children.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accHelpTopic( BSTR* pszHelpFile, VARIANT varChild, long* pidTopic )
{
	return DISP_E_MEMBERNOTFOUND;	/* no support in candidate UI */
}


/*   G E T _ A C C  K E Y B O A R D  S H O R T C U T   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accKeyboardShortcut()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method
//		get_accKeyboardShortcut().
//
//		Retrieves the specified object's keyboard shortcut property.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszShortcut		[out] Pointer to the BSTR that will contain
//								the keyboard shortcut string, or NULL
//								if no keyboard shortcut is associated
//								with this item.
//
//
//	RETURNS:
//
//		HRESULT			DISP_E_MEMBERNOTFOUND because the keyboard
//						  shortcut property is not supported for the
//						  Accessible object or any of its children.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accKeyboardShortcut( VARIANT varChild, BSTR *pbstrShortcut )
{
	return DISP_E_MEMBERNOTFOUND;	/* no support in candidate UI */
}


/*   G E T _ A C C  F O C U S   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accFocus()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accFocus().
//
//		Retrieves the child object that currently has the input focus.
//		Only one object or item within a container can have the current
//		focus at any one time.
//
//	PARAMETERS:
//
//		pVarFocus		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the specified child's current state.
//								This information may either be in the
//								form of one or more object state
//								constants or a custom description
//								string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarFocus parameter is
//						  invalid or S_OK.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accFocus( VARIANT *pVarFocus )
{
	if (pVarFocus == NULL) {
		return E_INVALIDARG;
	}

	pVarFocus->vt = VT_EMPTY;

	pVarFocus->vt = VT_I4;
	pVarFocus->lVal = 2;

	return S_OK;
}


/*   G E T _ A C C  S E L E C T I O N   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accSelection()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accSelection().
//
//		Retrieves the selected children of this object.
//
//	PARAMETERS:
//
//		pVarSel  		[out] Pointer to the VARIANT structure that
//								will be filled with information about
//								the selected child object or objects.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarSel parameter is
//						  invalid or S_OK.
//
//	NOTES:
//
//		Refer to the MSAA SDK documentation for a full description
//		of this method and the possible settings of pVarSel.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accSelection( VARIANT * pVarSel )
{
	if (pVarSel == NULL) {
		return E_INVALIDARG;
	}

	pVarSel->vt = VT_EMPTY;

	pVarSel->vt = VT_I4;
	pVarSel->lVal = 2;


	return S_OK;
}


/*   G E T _ A C C  D E F A U L T  A C T I O N   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	get_accDefaultAction()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accDefaultAction().
//
//		Retrieves a string containing a localized, human-readable sentence
//		that describes the object's default action.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose default action string is
//								to be retrieved.  Since CCandAccessible
//								only supports child IDs, the vt member
//								of this structure must equal VT_I4.
//
//		pszDefAct		[out] Pointer to the BSTR that will contain
//								the child's default action string,
//								or NULL if there is no default action
//								for this object.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either parameter is invalid,
//						  DISP_E_MEMBERNOTFOUND if VarChild refers
//						  to any icon child or the status bar child,
//						  or the return value from either the standard
//						  client window implementation of
//						  get_accDefaultAction() or the private method
//						  HrLoadString().
//
//	NOTES:
//
//		The only CCandAccessible child that has a default action is
//		the push button.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::get_accDefaultAction( VARIANT varChild, BSTR *pbstrDefAct )
{
	if (pbstrDefAct == NULL) {
		return E_INVALIDARG;
	}

	*pbstrDefAct = NULL;
	return DISP_E_MEMBERNOTFOUND;	/* no support in candidate UI */
}


/*   A C C  D O  D E F A U L T  A C T I O N   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	accDoDefaultAction()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accDoDefaultAction().
//
//		Performs the object's default action.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose default action will be
//								invoked.  Since CCandAccessible only
//								supports child IDs, the vt member of
//								this structure must equal VT_I4.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the in-parameter is invalid,
//						  DISP_E_MEMBERNOTFOUND if VarChild refers
//						  to any icon child or the status bar child,
//						  S_OK if VarChild refers to the push button,
//						  or the return value from the standard
//						  client window implementation of
//						  accDoDefaultAction().
//
//	NOTES:
//
//		The only CCandAccessible child that has a default action is
//		the push button.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::accDoDefaultAction( VARIANT varChild )
{
	return DISP_E_MEMBERNOTFOUND;	/* no support in candidate UI */
}


/*   A C C  S E L E C T   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	accSelect()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accSelect().
//
//		Modifies the selection or moves the keyboard focus according
//		to the specified flags.
//
//	PARAMETERS:
//
//		flagsSel		[in]  Value specifying how to change the
//								the current selection.  This parameter
//								can be a combination of the values
//								from the SELFLAG enumerated type.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be selected.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if either of the parameters
//						  is invalid, S_FALSE if the selection
//						  and/or focus cannot be placed at the
//						  requested location, or S_OK if the
//						  selection and/or focus can be placed
//						  at the requested location.
//
//	NOTES:
//
//		For more information on selected objects, please see the
//		MSAA SDK Documentation.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::accSelect( long flagsSel, VARIANT varChild )
{
	//-----------------------------------------------------
	//	Validate the requested selection.
	//	  SELFLAG_ADDSELECTION may not be combined
	//	  with SELFLAG_REMOVESELECTION.
	//-----------------------------------------------------

	if ((flagsSel & SELFLAG_ADDSELECTION) && (flagsSel & SELFLAG_REMOVESELECTION)) {
		return E_INVALIDARG;
	}

	return S_FALSE;
}


/*   A C C  L O C A T I O N   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	accLocation()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accLocation().
//
//		Retrieves the specified child's current screen location in
//		screen coordinates.
//
//	PARAMETERS:
//
//		pxLeft			[out] Address of the child's left most
//								boundary.
//
//		pyTop			[out] Address of the child's upper most
//								boundary.
//
//		pcxWid			[out] Address of the child's width.
//
//		pcyHt			[out] Address of the child's height.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose screen location is to be
//								retrieved.  Since CCandAccessible only
//								supports child IDs, the vt member
//								of this structure must equal VT_I4.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if any of the parameters
//						  are invalid, E_UNEXPECTED if we are for
//						  some reason unable to determine the
//						  window rect of the button or status bar,
//						  S_OK if the screen coordinates of the
//						  child are successfully determined, or
//						  the return value from the standard client
//						  window implementation of accLocation().
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::accLocation( long* pxLeft, long* pyTop, long* pcxWid, long* pcyHt, VARIANT varChild )
{
	CCandAccItem *pAccItem;
	RECT rc;

	if (pxLeft == NULL || pyTop == NULL || pcxWid == NULL || pcyHt == NULL) {
		return E_INVALIDARG;
	}

	//-----------------------------------------------------
	//	If the child ID is CHILDID_SELF, we are being
	//	  asked to retrieve the current screen location
	//	  of the Accessible object itself.   Delegate
	//	  this request to the standard implementation.
	//-----------------------------------------------------

	if (varChild.lVal == CHILDID_SELF) {
		return m_pDefAccClient->accLocation( pxLeft, pyTop, pcxWid, pcyHt, varChild );
	}


	// get acc item

	pAccItem = AccItemFromID( (int)varChild.lVal );
	if (pAccItem == NULL) {
		return E_INVALIDARG;
	}

	// get location of acc item

	pAccItem->GetAccLocation( &rc );
	*pxLeft = rc.left;
	*pyTop  = rc.top;
	*pcxWid = rc.right - rc.left;
	*pcyHt  = rc.bottom - rc.top;

	return S_OK;
}


/*   A C C  N A V I G A T E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	accNavigate()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accNavigate().
//
//		Retrieves the next or previous sibling or child object in a
//		specified direction.  This direction can be spatial order
//		(such as Left and Right) or in navigational order (such as
//		Next and Previous).
//
//	PARAMETERS:
//
//		navDir			[in]  A navigational constant specifying
//								the direction in which to move.
//
//		varStart		[in]  VARIANT structure that identifies the
//								child from which the navigational
//								change will originate.  Since
//								CCandAccessible only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarEndUpAt		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the destination child or object.
//								If the vt member is VT_I4, then the
//								lVal member is a child ID.  If the
//								vt member is VT_EMPTY, then the
//								navigation failed.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the varStart parameter is
//						  invalid, or the return value from the
//						  default implementation of the window client
//						  area default Accessible object,
//						  DISP_E_MEMBERNOTFOUND if the combination
//						  of the navigation flag and the varStart
//						  setting is invalid, S_FALSE if the
//						  navigation fails, or S_OK.
//
//	NOTES:
//
//		Since the CCandAccessible object has no child objects (only child
//		elements), pVarEndUpAt will never be a pointer to a IDispatch
//		interface of a child object.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::accNavigate( long navDir, VARIANT varStart, VARIANT* pVarEndUpAt )
{
	pVarEndUpAt->vt = VT_EMPTY;
	return S_FALSE;		/* no support in candidate UI */
}


/*   A C C  H I T  T E S T   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	accHitTest()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accHitTest().
//
//		Retrieves the ID of the a child at a given point on the screen.
//
//	PARAMETERS:
//
//		xLeft and yTop	[in]  The screen coordinates of the point
//								to be hit tested.
//
//		pVarHit			[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the hit child.  If the vt member is
//								VT_I4, then the lVal member is a child
//								ID.  If the vt member is VT_EMPTY,
//								then the navigation failed.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarHit parameter is
//						  invalid, or S_OK.
//
//	NOTES:
//
//		Since the CCandAccessible object has no child objects (only child
//		elements), pVarHit will never be a pointer to a IDispatch
//		interface of a child object.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::accHitTest( long xLeft, long yTop, VARIANT *pVarHit )
{
	int   i;
	POINT pt;
	RECT  rcWnd;

	if (!pVarHit) {
		return E_INVALIDARG;
	}

	// check point is inside of window

	pt.x = xLeft;
	pt.y = yTop;
	ScreenToClient( m_hWnd, &pt );

	GetClientRect( m_hWnd, &rcWnd );
	if (!PtInRect( &rcWnd, pt )) {
		pVarHit->vt = VT_EMPTY;
	}
	else {
		pVarHit->vt = VT_I4;
		pVarHit->lVal = CHILDID_SELF;

		for (i = 1; i < m_nAccItem; i++) {
			RECT rc;

			Assert( m_rgAccItem[i] != NULL );
			m_rgAccItem[i]->GetAccLocation( &rc );

			if (PtInRect( &rc, pt )) {
				pVarHit->lVal = m_rgAccItem[i]->GetID();
				break;
			}
		}
	}

	return S_OK;
}


/*   P U T _ A C C  N A M E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	put_accName()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method put_accName().
//
//		Sets the name property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose name property is to be
//								set.  Since CCandAccessible only supports
//								child IDs, the vt member of this
//								structure must equal VT_I4.
//
//		szName			[in]  String that specifies the new name for
//								this child.
//
//	RETURNS:
//
//		HRESULT			S_FALSE because the name property for any
//						  child may not be changed.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::put_accName( VARIANT varChild, BSTR szName )
{
	//-----------------------------------------------------
	//	We don't allow clients to change the name
	//	  property of any child so we simply return
	//	  S_FALSE.
	//-----------------------------------------------------

	return S_FALSE;
}


/*   P U T _ A C C  V A L U E   */
/*------------------------------------------------------------------------------

//-----------------------------------------------------------------------
//	put_accValue()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method put_accValue().
//
//		Sets the value property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose value property is to be
//								set.  Since CCandAccessible only supports
//								child IDs, the vt member of this
//								structure must equal VT_I4.
//
//		szValue			[in]  String that specifies the new value for
//								this child.
//
//	RETURNS:
//
//		HRESULT			S_FALSE because the value property for any
//						  child may not be changed.
//
//-----------------------------------------------------------------------

------------------------------------------------------------------------------*/
STDMETHODIMP CCandAccessible::put_accValue( VARIANT varChild, BSTR szValue )
{
	//-----------------------------------------------------
	//	We don't allow clients to change the value
	//	  property of the status bar (the only child that
	//	  has a value property) so we simply return S_FALSE.
	//-----------------------------------------------------

	return S_FALSE;
}


//
//
//

/*   I S  V A L I D  C H I L D  V A R I A N T   */
/*------------------------------------------------------------------------------

	

------------------------------------------------------------------------------*/
BOOL CCandAccessible::IsValidChildVariant( VARIANT * pVar )
{
	return (pVar->vt == VT_I4) && (0 <= pVar->lVal) && (pVar->lVal < m_nAccItem);
}


/*   A C C  I T E M  F R O M  I  D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandAccItem *CCandAccessible::AccItemFromID( int iID )
{
	int i;

	for (i = 0; i < m_nAccItem; i++) {
		if (m_rgAccItem[i]->GetID() == iID) {
			return m_rgAccItem[i];
		}
	}

	return NULL;
}


/*   C L E A R  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandAccessible::ClearAccItem( void )
{
	m_nAccItem = 0;
}


/*   A D D  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandAccessible::AddAccItem( CCandAccItem *pAccItem )
{
	if (CANDACCITEM_MAX <= m_nAccItem) {
		Assert( FALSE ); /* need more buffer */

		return FALSE;
	}

	m_rgAccItem[ m_nAccItem++ ] = pAccItem;
	pAccItem->Init( this, m_nAccItem /* start from 1 */ );
	return TRUE;
}


/*   N O T I F Y  W I N  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandAccessible::NotifyWinEvent( DWORD dwEvent, CCandAccItem *pAccItem )
{
	Assert( pAccItem != NULL );
	OurNotifyWinEvent( dwEvent, m_hWnd, OBJID_CLIENT, pAccItem->GetID() );
}


/*   C R E A T E  R E F  T O  A C C  O B J   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CCandAccessible::CreateRefToAccObj( WPARAM wParam )
{
	return OurLresultFromObject( IID_IAccessible, wParam, (IAccessible *)this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candacc.h ===
//
// candacc.h
//  = accessibility support in candidate ui =
//

#ifndef CANDACC_H
#define CANDACC_H

#include <windows.h>
#include <winable.h>
#include <ole2.h>
#include <oleacc.h>


#define CANDACCITEM_MAX			16		/* REVIEW: KOJIW: enough? */

class CCandAccessible;

//
// CCandAccItem
//

class CCandAccItem 
{
public:
	CCandAccItem( void );
	virtual ~CCandAccItem( void );

	void Init( CCandAccessible *pCandAcc, int iItemID );
	int GetID( void );

	virtual BSTR GetAccName( void );
	virtual BSTR GetAccValue( void );
	virtual LONG GetAccRole( void );
	virtual LONG GetAccState( void );
	virtual void GetAccLocation( RECT *prc );

protected:
	void NotifyWinEvent( DWORD dwEvent );

private:
	CCandAccessible *m_pCandAcc;
	int             m_iItemID;
};


//
// CCandAccessible 
//

class CCandAccessible : public IAccessible
{
public:
	CCandAccessible( CCandAccItem *pAccItemSelf );
	virtual ~CCandAccessible( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void** ppv );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// IDispatch methods
	//
	STDMETHODIMP GetTypeInfoCount( UINT* pctinfo );
	STDMETHODIMP GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** pptinfo );
	STDMETHODIMP GetIDsOfNames( REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid );
	STDMETHODIMP Invoke( DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr );

	//
	// IAccessible methods
	//
	STDMETHODIMP get_accParent( IDispatch ** ppdispParent );
	STDMETHODIMP get_accChildCount( long* pChildCount );
	STDMETHODIMP get_accChild( VARIANT varChild, IDispatch ** ppdispChild );
	STDMETHODIMP get_accName( VARIANT varChild, BSTR* pszName );
	STDMETHODIMP get_accValue( VARIANT varChild, BSTR* pszValue );
	STDMETHODIMP get_accDescription( VARIANT varChild, BSTR* pszDescription );
	STDMETHODIMP get_accRole( VARIANT varChild, VARIANT *pvarRole );
	STDMETHODIMP get_accState( VARIANT varChild, VARIANT *pvarState );
	STDMETHODIMP get_accHelp( VARIANT varChild, BSTR* pszHelp );
	STDMETHODIMP get_accHelpTopic( BSTR* pszHelpFile, VARIANT varChild, long* pidTopic );
	STDMETHODIMP get_accKeyboardShortcut( VARIANT varChild, BSTR* pszKeyboardShortcut );
	STDMETHODIMP get_accFocus( VARIANT * pvarFocusChild );
	STDMETHODIMP get_accSelection( VARIANT * pvarSelectedChildren );
	STDMETHODIMP get_accDefaultAction( VARIANT varChild, BSTR* pszDefaultAction );
	STDMETHODIMP accSelect( long flagsSel, VARIANT varChild );
	STDMETHODIMP accLocation( long* pxLt, long* pyTp, long* pcxWd, long* pcyHt, VARIANT varChild );
	STDMETHODIMP accNavigate( long navDir, VARIANT varStart, VARIANT * pVarEndUpAt );
	STDMETHODIMP accHitTest( long xLeft, long yTop, VARIANT * pvarChildAtPoint );
	STDMETHODIMP accDoDefaultAction( VARIANT varChild );
	STDMETHODIMP put_accName( VARIANT varChild, BSTR szName );
	STDMETHODIMP put_accValue( VARIANT varChild, BSTR pszValue );

	//
	//
	//
	void SetWindow( HWND hWnd );
	HRESULT Initialize( void );
	void NotifyWinEvent( DWORD dwEvent, CCandAccItem *pAccItem );
	
	LRESULT CreateRefToAccObj( WPARAM wParam );

	//
	//
	//

	void ClearAccItem( void );
	BOOL AddAccItem( CCandAccItem *pAccItem );

	//
	//
	//
	__inline BOOL FInitialized( void )
	{
		return m_fInitialized;
	}

protected:
	LONG			m_cRef;
	HWND			m_hWnd;
	IAccessible 	*m_pDefAccClient;
	ITypeInfo		*m_pTypeInfo;

	BOOL			m_fInitialized;
	int				m_nAccItem;
	CCandAccItem	*m_rgAccItem[ CANDACCITEM_MAX ];


	BOOL			IsValidChildVariant( VARIANT * pVar );
	CCandAccItem	*AccItemFromID( int iID );
};



extern void InitCandAcc( void );
extern void DoneCandAcc( void );

#endif /* CANDACC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candcomp.cpp ===
//
// candcomp.cpp
//

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candcomp.h"
#include "computil.h"

/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C O M P A R T M E N T  M G R                            */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C O M P A R T M E N T  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUICompartmentMgr::CCandUICompartmentMgr( void )
{
	m_pCandUI = NULL;
}


/*   ~  C  C A N D  U I  C O M P A R T M E N T  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUICompartmentMgr::~CCandUICompartmentMgr( void )
{
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::Initialize( CCandidateUI *pCandUI )
{
	m_pCandUI = pCandUI;
	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::Uninitialize( void )
{
	m_pCandUI = NULL;
	return S_OK;
}


/*   S E T  U I  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::SetUIStyle( IUnknown *punk, CANDUISTYLE style )
{
	HRESULT hr;

	Assert( punk != NULL );

	hr = SetCompartmentDWORD( 0 /* tid */, punk, GUID_COMPARTMENT_CANDUI_UISTYLE, (DWORD)style , FALSE );

	return (hr == S_OK) ? S_OK : E_FAIL;
}


/*   G E T  U I  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::GetUIStyle( IUnknown *punk, CANDUISTYLE *pstyle )
{
	HRESULT hr;

	Assert( punk != NULL );
	Assert( pstyle != NULL );

	hr = GetCompartmentDWORD( punk, GUID_COMPARTMENT_CANDUI_UISTYLE, (DWORD*)pstyle , FALSE );

	return (hr == S_OK) ? S_OK : E_FAIL;
}


/*   S E T  U I  O P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::SetUIOption( IUnknown *punk, DWORD dwOption )
{
	HRESULT hr;

	Assert( punk != NULL );

	hr = SetCompartmentDWORD( 0 /* tid */, punk, GUID_COMPARTMENT_CANDUI_UIOPTION, dwOption , FALSE );

	return (hr == S_OK) ? S_OK : E_FAIL;
}


/*   G E T  U I  O P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::GetUIOption( IUnknown *punk, DWORD *pdwOption )
{
	HRESULT hr;

	Assert( punk != NULL );
	Assert( pdwOption != NULL );

	hr = GetCompartmentDWORD( punk, GUID_COMPARTMENT_CANDUI_UIOPTION, pdwOption , FALSE );

	return (hr == S_OK) ? S_OK : E_FAIL;
}


/*   S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::SetKeyTable( IUnknown *punk, CCandUIKeyTable *pCandUIKeyTable )
{
	HRESULT hr;

	Assert( punk != NULL );
	Assert( pCandUIKeyTable != NULL );

	ClearCompartment( 0 /* tid */, punk, GUID_COMPARTMENT_CANDUI_KEYTABLE, FALSE );
	hr = SetCompartmentUnknown( 0 /*tid*/, punk, GUID_COMPARTMENT_CANDUI_KEYTABLE, (IUnknown*)pCandUIKeyTable );

	return (hr == S_OK) ? S_OK : E_FAIL;
}


/*   G E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::GetKeyTable( IUnknown *punk, CCandUIKeyTable **ppCandUIKeyTable )
{
	HRESULT hr;

	Assert( punk != NULL );
	Assert( ppCandUIKeyTable != NULL );

	hr = GetCompartmentUnknown( punk, GUID_COMPARTMENT_CANDUI_KEYTABLE, (IUnknown**)ppCandUIKeyTable );

	return (hr == S_OK) ? S_OK : E_FAIL;
}


/*   C L E A R  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUICompartmentMgr::ClearKeyTable( IUnknown *punk )
{
	HRESULT hr;

	hr = ClearCompartment( 0 /* tid */, punk, GUID_COMPARTMENT_CANDUI_KEYTABLE, FALSE );

	return (hr == S_OK) ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candext.h ===
//
// candext.h
//

#ifndef CANDEXT_H
#define CANDEXT_H

#include "propdata.h"
#include "candutil.h"
#include "mscandui.h"
#include "cuilib.h"

class CCandidateUI;
class CCandUIExtensionMgr;
class CCandUIExtensionEventSink;

#define CANDUIEXTENSIONSINK_MAX		4


//
// CCandUIExtension
//  = CandidateUI extension (base class) =
//

class CCandUIExtension
{
public:
	CCandUIExtension( CCandUIExtensionMgr *pExtensionMgr, LONG id );
	virtual ~CCandUIExtension( void );

	HRESULT GetID( LONG *pid );
	HRESULT Enable( void );
	HRESULT Disable( void );
	HRESULT IsEnabled( BOOL *pfEnabled );
	HRESULT Show( void );
	HRESULT Hide( void );
	HRESULT IsVisible( BOOL *pfVisible );
	HRESULT SetPosition( POINT *pptPos );
	HRESULT GetPosition( POINT *pptPos );
	HRESULT SetFont( LOGFONTW *plf );
	HRESULT GetFont( LOGFONTW *plf );
	HRESULT SetText( BSTR bstr );
	HRESULT GetText( BSTR *pbstr );
	HRESULT SetToolTipString( BSTR bstr );
	HRESULT GetToolTipString( BSTR *pbstr );
	HRESULT GetSize( SIZE *psize );
	HRESULT SetSize( SIZE *psize );

	LONG GetID( void );
	BOOL IsEnabled( void );
	BOOL IsVisible( void );
	HFONT GetFont( void );
	LPCWSTR GetText( void );
	LPCWSTR GetToolTipString( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFGUID rguid, void **ppvObj )                   = 0;	/* PURE */
	virtual HRESULT NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam )                  = 0;	/* PURE */

	//
	// UIObject functions
	//
	virtual CUIFObject *CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc )  = 0;	/* PURE */
	virtual void UpdateObjProp( CUIFObject *pUIObject )                                     = 0;	/* PURE */
	virtual void UpdateExtProp( CUIFObject *pUIObject )                                     = 0;	/* PURE */

protected:
	CCandUIExtensionMgr *m_pExtensionMgr;

	struct
	{
		BOOL fAllowEnable       : 1;
		BOOL fAllowDisable      : 1;
		BOOL fAllowIsEnabled    : 1;
		BOOL fAllowShow         : 1;
		BOOL fAllowHide         : 1;
		BOOL fAllowIsVisible    : 1;
		BOOL fAllowSetPosition  : 1;
		BOOL fAllowGetPosition  : 1;
		BOOL fAllowSetSize      : 1;
		BOOL fAllowGetSize      : 1;
		BOOL fAllowSetFont      : 1;
		BOOL fAllowGetFont      : 1;
		BOOL fAllowSetText      : 1;
		BOOL fAllowGetText      : 1;
		BOOL fAllowSetToolTip   : 1;
		BOOL fAllowGetToolTip   : 1;
		BOOL : 0;
	} m_flags;

	CPropLong	m_propID;
	CPropBool	m_propEnabled;
	CPropBool	m_propVisible;
	CPropPoint	m_propPos;
	CPropFont	m_propFont;
	CPropText	m_propText;
	CPropText	m_propToolTip;
	CPropSize	m_propSize;

	__inline CCandUIExtensionMgr *GetExtensionMgr( void )
	{
		return m_pExtensionMgr;
	}
};


//
// CExtensionButton
//  = CandidateUI button extension (base class) =
//

class CExtensionButton : public CCandUIExtension
{
public:
	CExtensionButton( CCandUIExtensionMgr *pExtMgr, LONG id );
	virtual ~CExtensionButton( void );

	HRESULT SetIcon( HICON hIcon );
	HRESULT SetBitmap( HBITMAP hBitmap );
	HRESULT GetToggleState( BOOL *pfToggled );
	HRESULT SetToggleState( BOOL fToggle );

	HICON GetIcon( void );
	HBITMAP GetBitmap( void );
	BOOL IsToggled( void );

	void SetEventSink( ITfCandUIExtButtonEventSink *pSink )
	{
		SafeReleaseClear( m_pSink );

		m_pSink = pSink;
		m_pSink->AddRef();
	}

	ITfCandUIExtButtonEventSink *GetEventSink( void )
	{
		return m_pSink;
	}

	void ReleaseEventSink( void )
	{
		SafeReleaseClear( m_pSink );
	}

protected:
	struct
	{
		BOOL fAllowSetToggleState : 1;
		BOOL fAllowGetToggleState : 1;
		BOOL fAllowSetIcon   : 1;
		BOOL fAllowSetBitmap : 1;
		BOOL : 0;
	} m_flagsEx;

	CPropBool	m_propToggled;
	HICON		m_hIcon;
	HBITMAP		m_hBitmap;

	ITfCandUIExtButtonEventSink *m_pSink;
};


//
// CExtensionSpace
//  = CandidateUI spac extension =
//

class CExtensionSpace : public CCandUIExtension
{
public:
	CExtensionSpace( CCandUIExtensionMgr *pExtMgr, LONG id );
	virtual ~CExtensionSpace( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFGUID rguid, void **ppvObj );
	virtual HRESULT NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam );

	//
	// UIObject functions
	//
	virtual CUIFObject *CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc );
	virtual void UpdateObjProp( CUIFObject *pUIObject );
	virtual void UpdateExtProp( CUIFObject *pUIObject );
};


//
// CExtensionPushButton
//  = CandidateUI push button extension =
//

class CExtensionPushButton : public CExtensionButton
{
public:
	CExtensionPushButton( CCandUIExtensionMgr *pExtMgr, LONG id );
	virtual ~CExtensionPushButton( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFGUID rguid, void **ppvObj );
	virtual HRESULT NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam );

	//
	// UIObject functions
	//
	virtual CUIFObject *CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc );
	virtual void UpdateObjProp( CUIFObject *pUIObject );
	virtual void UpdateExtProp( CUIFObject *pUIObject );
};


//
// CExtensionToggleButton
//  = CandidateUI toggle button extension =
//

class CExtensionToggleButton : public CExtensionButton
{
public:
	CExtensionToggleButton( CCandUIExtensionMgr *pExtMgr, LONG id );
	virtual ~CExtensionToggleButton( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFGUID rguid, void **ppvObj );
	virtual HRESULT NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam );

	//
	// UIObject functions
	//
	virtual CUIFObject *CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc );
	virtual void UpdateObjProp( CUIFObject *pUIObject );
	virtual void UpdateExtProp( CUIFObject *pUIObject );
};


//
// CCandUIExtensionMgr
//  = CandidateUI extension manager =
//

class CCandUIExtensionMgr
{
public:
	CCandUIExtensionMgr( void );
	virtual ~CCandUIExtensionMgr( void );

	HRESULT Initialize( CCandidateUI *pCandUI );
	HRESULT Uninitialize( void );

	//
	// event sink functions
	//
	HRESULT AdviseEventSink( CCandUIExtensionEventSink *pSink );
	HRESULT UnadviseEventSink( CCandUIExtensionEventSink *pSink );
	void NotifyExtensionAdd( LONG iExtension );
	void NotifyExtensionDelete( LONG iExtension );
	void NotifyExtensionUpdate( CCandUIExtension *pExtension );

	//
	// extension management functions
	//
	HRESULT AddExtObject( LONG id, REFIID riid, void **ppvObj );
	HRESULT GetExtObject( LONG id, REFIID riid, void **ppvObj );
	HRESULT DeleteExtObject( LONG id );

	LONG GetExtensionNum( void );
	CCandUIExtension *GetExtension( LONG iExtension );
	CCandUIExtension *FindExtension( LONG id );

	//
	// UIObject functions
	//
	CUIFObject *CreateUIObject( LONG iExtension, CUIFObject *pParent, DWORD dwID, const RECT *prc );
	void UpdateObjProp( LONG iExtension, CUIFObject *pUIObject );
	void UpdateExtProp( LONG iExtension, CUIFObject *pUIObject );

	//
	//
	//
	__inline CCandidateUI *GetCandidateUI( void )
	{
		return m_pCandUI;
	}

protected:
	CCandidateUI						*m_pCandUI;
	CUIFObjectArray<CCandUIExtension>	m_pExtensionList;
	CCandUIExtensionEventSink			*m_rgSink[ CANDUIEXTENSIONSINK_MAX ];

	LONG IndexOfExtension( CCandUIExtension *pExtension );
};


//
// CCandUIExtensionEventSink
//  = extension event sink =
//

class CCandUIExtensionEventSink
{
public:
	CCandUIExtensionEventSink( void );
	virtual ~CCandUIExtensionEventSink( void );

	HRESULT InitEventSink( CCandUIExtensionMgr *pExtensionMgr );
	HRESULT DoneEventSink( void );

	//
	// callback functions
	//
	virtual void OnExtensionAdd( LONG iExtension )      = 0;	/* PURE */
	virtual void OnExtensionDeleted( LONG iExtension )  = 0;	/* PURE */
	virtual void OnExtensionUpdated( LONG iExtension )  = 0;	/* PURE */

protected:
	CCandUIExtensionMgr *m_pExtensionMgr;

	__inline CCandUIExtensionMgr *GetExtensionMgr( void )
	{
		return m_pExtensionMgr;
	}
};

#endif // CANDEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candext.cpp ===
//
// candext.cpp
//

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candext.h"
#include "candui.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T E N S I O N                                       */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T E N S I O N   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIExtension

------------------------------------------------------------------------------*/
CCandUIExtension::CCandUIExtension( CCandUIExtensionMgr *pExtensionMgr, LONG id )
{
	m_pExtensionMgr = pExtensionMgr;

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propID.Set( id );
	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  C A N D  U I  E X T E N S I O N   */
/*------------------------------------------------------------------------------

	Denstructor of CCandUIExtension

------------------------------------------------------------------------------*/
CCandUIExtension::~CCandUIExtension( void )
{
}


/*   G E T  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::GetID( LONG *pid )
{
	return m_propID.Get( pid );
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::Enable( void )
{
	HRESULT hr;

	if (!m_flags.fAllowEnable) {
		return E_FAIL;
	}

	hr = m_propEnabled.Set( TRUE );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   D I S A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::Disable( void )
{
	HRESULT hr;

	if (!m_flags.fAllowDisable) {
		return E_FAIL;
	}

	hr = m_propEnabled.Set( FALSE );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::IsEnabled( BOOL *pfEnabled )
{
	if (!m_flags.fAllowIsEnabled) {
		return E_FAIL;
	}

	return m_propEnabled.Get( pfEnabled );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::SetPosition( POINT *pptPos )
{
	HRESULT hr;

	if (!m_flags.fAllowSetPosition) {
		return E_FAIL;
	}

	hr = m_propPos.Set( pptPos );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::GetPosition( POINT *pptPos )
{
	if (!m_flags.fAllowGetPosition) {
		return E_FAIL;
	}
	return m_propPos.Get( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::SetSize( SIZE *psize )
{
	HRESULT hr;

	if (!m_flags.fAllowSetSize) {
		return E_FAIL;
	}

	hr = m_propSize.Set( psize );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::GetSize( SIZE *psize )
{
	if (!m_flags.fAllowGetSize) {
		return E_FAIL;
	}
	return m_propSize.Get( psize );
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::Show( void )
{
	HRESULT hr;

	if (!m_flags.fAllowShow) {
		return E_FAIL;
	}

	hr = m_propVisible.Set( TRUE );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   H I D E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::Hide( void )
{
	HRESULT hr;

	if (!m_flags.fAllowHide) {
		return E_FAIL;
	}

	hr = m_propVisible.Set( FALSE );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::IsVisible( BOOL *pfVisible )
{
	if (!m_flags.fAllowIsVisible) {
		return E_FAIL;
	}

	return m_propVisible.Get( pfVisible );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::SetFont( LOGFONTW *plf )
{
	HRESULT hr;

	if (!m_flags.fAllowSetFont) {
		return E_FAIL;
	}

	hr = m_propFont.Set( plf );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::GetFont( LOGFONTW *plf )
{
	if (!m_flags.fAllowGetFont) {
		return E_FAIL;
	}
	return m_propFont.Get( plf );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::SetText( BSTR bstr )
{
	HRESULT hr;

	if (!m_flags.fAllowSetText) {
		return E_FAIL;
	}

	hr = m_propText.Set( bstr );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::GetText( BSTR *pbstr )
{
	if (!m_flags.fAllowGetText) {
		return E_FAIL;
	}
	return m_propText.Get( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::SetToolTipString( BSTR bstr )
{
	HRESULT hr;

	if (!m_flags.fAllowSetToolTip) {
		return E_FAIL;
	}

	hr = m_propToolTip.Set( bstr );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtension::GetToolTipString( BSTR *pbstr )
{
	if (!m_flags.fAllowGetToolTip) {
		return E_FAIL;
	}
	return m_propToolTip.Get( pbstr );
}


/*   G E T  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LONG CCandUIExtension::GetID( void )
{
	return m_propID.Get();
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIExtension::IsEnabled( void )
{
	return m_propEnabled.Get();
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIExtension::IsVisible( void )
{
	return m_propVisible.Get();
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HFONT CCandUIExtension::GetFont( void )
{
	return m_propFont.Get();
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CCandUIExtension::GetText( void )
{
	return m_propText.Get();
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CCandUIExtension::GetToolTipString( void )
{
	return m_propToolTip.Get();
}


/*============================================================================*/
/*                                                                            */
/*   C  E X T E N S I O N  B U T T O N                                        */
/*                                                                            */
/*============================================================================*/

/*   C  E X T E N S I O N  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CExtensionButton

------------------------------------------------------------------------------*/
CExtensionButton::CExtensionButton( CCandUIExtensionMgr *pExtMgr, LONG id ) : CCandUIExtension( pExtMgr, id )
{
	SIZE size;

	m_flags.fAllowEnable        = TRUE;
	m_flags.fAllowDisable       = TRUE;
	m_flags.fAllowIsEnabled     = TRUE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = TRUE;
	m_flags.fAllowGetToolTip    = TRUE;

	size.cx  = 16 + 2;
	size.cy  = 16 + 2;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
	m_propSize.Set( &size );

	m_flagsEx.fAllowSetToggleState = FALSE;
	m_flagsEx.fAllowGetToggleState = FALSE;
	m_flagsEx.fAllowSetIcon        = TRUE;
	m_flagsEx.fAllowSetBitmap      = TRUE;

	m_propToggled.Set( FALSE );
	m_hIcon    = NULL;
	m_hBitmap  = NULL;

	m_pSink = NULL;
}


/*   ~  C  E X T E N S I O N  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CExtensionButton

------------------------------------------------------------------------------*/
CExtensionButton::~CExtensionButton( void )
{
	if (m_pSink != NULL) {
		m_pSink->Release();
	}
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionButton::SetIcon( HICON hIcon )
{
	if (!m_flagsEx.fAllowSetIcon) {
		return E_FAIL;
	}

	if (hIcon == NULL) {
		return E_INVALIDARG;
	}

	m_hBitmap = NULL;
	m_hIcon   = hIcon;
	GetExtensionMgr()->NotifyExtensionUpdate( this );
	return S_OK;
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionButton::SetBitmap( HBITMAP hBitmap )
{
	if (!m_flagsEx.fAllowSetBitmap) {
		return E_FAIL;
	}

	if (hBitmap == NULL) {
		return E_INVALIDARG;
	}

	m_hIcon   = NULL;
	m_hBitmap = hBitmap;
	GetExtensionMgr()->NotifyExtensionUpdate( this );
	return S_OK;
}


/*   G E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionButton::GetToggleState( BOOL *pfToggled )
{
	if (!m_flagsEx.fAllowGetToggleState) {
		return E_FAIL;
	}

	return m_propToggled.Get( pfToggled );
}


/*   S E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionButton::SetToggleState( BOOL fToggle )
{
	HRESULT hr;

	if (!m_flagsEx.fAllowSetToggleState) {
		return E_FAIL;
	}

	hr = m_propToggled.Set( fToggle );
	if (hr == S_OK) {
		GetExtensionMgr()->NotifyExtensionUpdate( this );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HICON CExtensionButton::GetIcon( void )
{
	return m_hIcon;
}


/*   G E T  B I T M A P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HBITMAP CExtensionButton::GetBitmap( void )
{
	return m_hBitmap;
}


/*   I S  T O G G L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CExtensionButton::IsToggled( void )
{
	return m_propToggled.Get();
}


/*============================================================================*/
/*                                                                            */
/*   C  E X T E N S I O N  S P A C E                                          */
/*                                                                            */
/*============================================================================*/

/*   C  E X T E N S I O N  S P A C E   */
/*------------------------------------------------------------------------------

	Constructor of CExtensionSpace

------------------------------------------------------------------------------*/
CExtensionSpace::CExtensionSpace( CCandUIExtensionMgr *pExtMgr, LONG id ) : CCandUIExtension( pExtMgr, id )
{
	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = TRUE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  E X T E N S I O N  S P A C E   */
/*------------------------------------------------------------------------------

	Destructor of CExtensionSpace

------------------------------------------------------------------------------*/
CExtensionSpace::~CExtensionSpace( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionSpace::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIExtSpace *pObject;
	HRESULT         hr;

	pObject = new CCandUIExtSpace( GetExtensionMgr()->GetCandidateUI(), this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*   N O T I F Y  E X T E N S I O N  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionSpace::NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam )
{
	return S_OK;
}


/*   C R E A T E  U I  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFObject *CExtensionSpace::CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc )
{
	return NULL;
}


/*   U P D A T E  O B J  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtensionSpace::UpdateObjProp( CUIFObject *pUIObject )
{
}


/*   U P D A T E  E X T  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtensionSpace::UpdateExtProp( CUIFObject *pUIObject )
{
}


/*============================================================================*/
/*                                                                            */
/*   C  E X T E N S I O N  P U S H  B U T T O N                               */
/*                                                                            */
/*============================================================================*/

/*   C  E X T E N S I O N  P U S H  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CExtensionPushButton

------------------------------------------------------------------------------*/
CExtensionPushButton::CExtensionPushButton( CCandUIExtensionMgr *pExtMgr, LONG id ) : CExtensionButton( pExtMgr, id )
{
	m_flagsEx.fAllowSetToggleState = FALSE;
	m_flagsEx.fAllowGetToggleState = FALSE;
	m_flagsEx.fAllowSetIcon        = TRUE;
	m_flagsEx.fAllowSetBitmap      = TRUE;
}


/*   ~  C  E X T E N S I O N  P U S H  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CExtensionPushButton

------------------------------------------------------------------------------*/
CExtensionPushButton::~CExtensionPushButton( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionPushButton::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIExtPushButton *pObject;
	HRESULT              hr;

	pObject = new CCandUIExtPushButton( GetExtensionMgr()->GetCandidateUI(), this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*   N O T I F Y  E X T E N S I O N  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionPushButton::NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam )
{
	if (m_pSink != NULL) {
		m_pSink->OnButtonPushed( GetID() );
	}

	return S_OK;
}


/*   C R E A T E  U I  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFObject *CExtensionPushButton::CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc )
{
	Assert( pParent != NULL );
	Assert( prc != NULL );

	return new CUIFButton2( pParent, dwID, prc, UIBUTTON_PUSH );
}


/*   U P D A T E  O B J  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtensionPushButton::UpdateObjProp( CUIFObject *pUIObject )
{
	CUIFButton *pButton = (CUIFButton *)pUIObject;

	Assert( pButton != NULL );

	// button face

	if (GetIcon() != NULL)  {
		pButton->SetIcon( GetIcon() );
	}
	else if (GetBitmap() != NULL) {
		pButton->SetBitmap( GetBitmap() );
	}

	// tooltip

	pButton->SetToolTip( GetToolTipString() );
}


/*   U P D A T E  E X T  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtensionPushButton::UpdateExtProp( CUIFObject *pUIObject )
{
}


/*============================================================================*/
/*                                                                            */
/*   C  E X T E N S I O N  T O G G L E  B U T T O N                           */
/*                                                                            */
/*============================================================================*/

/*   C  E X T E N S I O N  T O G G L E  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CExtensionToggleButton

------------------------------------------------------------------------------*/
CExtensionToggleButton::CExtensionToggleButton( CCandUIExtensionMgr *pExtMgr, LONG id ) : CExtensionButton( pExtMgr, id )
{
	m_flagsEx.fAllowSetToggleState = TRUE;
	m_flagsEx.fAllowGetToggleState = TRUE;
	m_flagsEx.fAllowSetIcon        = TRUE;
	m_flagsEx.fAllowSetBitmap      = TRUE;
}


/*   ~  C  E X T E N S I O N  T O G G L E  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CExtensionToggleButton

------------------------------------------------------------------------------*/
CExtensionToggleButton::~CExtensionToggleButton( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionToggleButton::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIExtToggleButton *pObject;
	HRESULT                hr;

	pObject = new CCandUIExtToggleButton( GetExtensionMgr()->GetCandidateUI(), this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*   N O T I F Y  E X T E N S I O N  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtensionToggleButton::NotifyExtensionEvent( DWORD dwCommand, LPARAM lParam )
{
	if (m_pSink != NULL) {
		m_pSink->OnButtonPushed( GetID() );
	}

	return S_OK;
}


/*   C R E A T E  U I  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFObject *CExtensionToggleButton::CreateUIObject( CUIFObject *pParent, DWORD dwID, const RECT *prc )
{
	Assert( pParent != NULL );
	Assert( prc != NULL );

	return new CUIFButton2( pParent, dwID, prc, UIBUTTON_TOGGLE );
}


/*   U P D A T E  O B J  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtensionToggleButton::UpdateObjProp( CUIFObject *pUIObject )
{
	CUIFButton *pButton = (CUIFButton *)pUIObject;

	Assert( pButton != NULL );

	// button face

	if (GetIcon() != NULL)  {
		pButton->SetIcon( GetIcon() );
	}
	else if (GetBitmap() != NULL) {
		pButton->SetBitmap( GetBitmap() );
	}

	// toggle state

	pButton->SetToggleState( IsToggled() );

	// tooltip

	pButton->SetToolTip( GetToolTipString() );
}


/*   U P D A T E  E X T  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtensionToggleButton::UpdateExtProp( CUIFObject *pUIObject )
{
	CUIFButton *pButton = (CUIFButton *)pUIObject;

	Assert( pButton != NULL );

	// toggle state

	m_propToggled.Set( pButton->GetToggleState() );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T E N S I O N  M G R                                */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T E N S I O N  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtensionMgr::CCandUIExtensionMgr( void )
{
	int i;

	m_pCandUI = NULL;

	for (i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		m_rgSink[i] = NULL;
	}
}


/*   ~  C  C A N D  U I  E X T E N S I O N  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtensionMgr::~CCandUIExtensionMgr( void )
{
	Uninitialize();
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::Initialize( CCandidateUI *pCandUI )
{
	m_pCandUI = pCandUI;

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		Assert( m_rgSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::Uninitialize( void )
{
	CCandUIExtension *pExtension;

	while (pExtension = m_pExtensionList.GetFirst()) {
		m_pExtensionList.Remove( pExtension );
		delete pExtension;
	}

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		Assert( m_rgSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::AdviseEventSink( CCandUIExtensionEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		if (m_rgSink[i] == NULL) {
			m_rgSink[i] = pSink;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   U N A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::UnadviseEventSink( CCandUIExtensionEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		if (m_rgSink[i] == pSink) {
			m_rgSink[i] = NULL;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   N O T I F Y  E X T E N S I O N  A D D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIExtensionMgr::NotifyExtensionAdd( LONG iExtension )
{
	int i;

	for (i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		if (m_rgSink[i] != NULL) {
			m_rgSink[i]->OnExtensionAdd( iExtension );
		}
	}
}


/*   N O T I F Y  E X T E N S I O N  D E L E T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIExtensionMgr::NotifyExtensionDelete( LONG iExtension )
{
	int i;

	for (i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		if (m_rgSink[i] != NULL) {
			m_rgSink[i]->OnExtensionDeleted( iExtension );
		}
	}
}


/*   N O T I F Y  E X T E N S I O N  U P D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIExtensionMgr::NotifyExtensionUpdate( CCandUIExtension *pExtension )
{
	LONG i;
	LONG iExtension;

	iExtension = IndexOfExtension( pExtension );
	if (iExtension == -1) {
		// extension has not been added yet.
		// do not send notify
		return;
	}

	for (i = 0; i < CANDUIEXTENSIONSINK_MAX; i++) {
		if (m_rgSink[i] != NULL) {
			m_rgSink[i]->OnExtensionUpdated( iExtension );
		}
	}
}


/*   G E T  E X T E N S I O N  N U M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LONG CCandUIExtensionMgr::GetExtensionNum( void )
{
	return m_pExtensionList.GetCount();
}


/*   G E T  E X T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtension *CCandUIExtensionMgr::GetExtension( LONG iExtension )
{
	return m_pExtensionList.Get( iExtension );
}


/*   F I N D  E X T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtension *CCandUIExtensionMgr::FindExtension( LONG id )
{
	int nExt;
	int i;
	CCandUIExtension *pExtension;

	nExt = m_pExtensionList.GetCount();
	for (i = 0; i < nExt; i++) {
		pExtension = m_pExtensionList.Get( i );

		if (pExtension->GetID() == id) {
			return pExtension;
		}
	}

	return NULL;
}


/*   A D D  E X T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::AddExtObject( LONG id, REFIID riid, void **ppvObj )
{
	CCandUIExtension *pExtension;

	if (ppvObj == NULL) {
		return E_INVALIDARG;
	}

	// create extension

	pExtension = NULL;
	if (IsEqualGUID( riid, IID_ITfCandUIExtSpace )) {
		pExtension = new CExtensionSpace( this, id );
	}
	else if (IsEqualGUID( riid, IID_ITfCandUIExtPushButton )) {
		pExtension = new CExtensionPushButton( this, id );
	}
	else if (IsEqualGUID( riid, IID_ITfCandUIExtToggleButton )) {
		pExtension = new CExtensionToggleButton( this, id );
	}
	else {
		return E_INVALIDARG;
	}

	if (pExtension == NULL) {
		return E_OUTOFMEMORY;
	}

	// create interface object

	if (FAILED(pExtension->CreateInterfaceObject( riid, ppvObj ))) {
		delete pExtension;
		return E_FAIL;
	}

	// add extension to list

	m_pExtensionList.Add( pExtension );
	NotifyExtensionAdd( IndexOfExtension( pExtension ) );

	return S_OK;
}


/*   G E T  E X T  O B J E C T   */
/*------------------------------------------------------------------------------

	

------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::GetExtObject( LONG id, REFIID riid, void **ppvObj )
{
	CCandUIExtension *pExtension;

	if (ppvObj == NULL) {
		return E_INVALIDARG;
	}

	// find extension

	pExtension = FindExtension( id );
	if (pExtension == NULL) {
		return E_FAIL;
	}

	// create interface object

	return pExtension->CreateInterfaceObject( riid, ppvObj );
}


/*   D E L E T E  E X T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionMgr::DeleteExtObject( LONG id )
{
	CCandUIExtension *pExtension;
	LONG iExtension;

	// find extension

	pExtension = FindExtension( id );
	if (pExtension == NULL) {
		return E_FAIL;
	}

	// remove from list and delete

	iExtension = IndexOfExtension( pExtension );
	m_pExtensionList.Remove( pExtension );
	delete pExtension;

	// send notify

	NotifyExtensionDelete( iExtension );
	return S_OK;
}


/*   C R E A T E  U I  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFObject *CCandUIExtensionMgr::CreateUIObject( LONG iExtension, CUIFObject *pParent, DWORD dwID, const RECT *prc )
{
	CCandUIExtension *pExtension = GetExtension( iExtension );

	if (pExtension != NULL) {
		return pExtension->CreateUIObject( pParent, dwID, prc );
	}
	else {
		return NULL;
	}
}


/*   U P D A T E  O B J  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIExtensionMgr::UpdateObjProp( LONG iExtension, CUIFObject *pUIObject )
{
	CCandUIExtension *pExtension = GetExtension( iExtension );

	if (pExtension != NULL) {
		pExtension->UpdateObjProp( pUIObject );
	}
}


/*   U P D A T E  E X T  P R O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIExtensionMgr::UpdateExtProp( LONG iExtension, CUIFObject *pUIObject )
{
	CCandUIExtension *pExtension = GetExtension( iExtension );

	if (pExtension != NULL) {
		pExtension->UpdateExtProp( pUIObject );
	}
}


/*   I N D E X  O F  E X T E N S I O N   */
/*------------------------------------------------------------------------------

	

------------------------------------------------------------------------------*/
LONG CCandUIExtensionMgr::IndexOfExtension( CCandUIExtension *pExtension )
{
	return m_pExtensionList.Find( pExtension );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T E N S I O N  E V E N T  S I N K                   */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T E N S I O N  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtensionEventSink::CCandUIExtensionEventSink( void )
{
	m_pExtensionMgr = NULL;
}


/*   ~  C  C A N D  U I  E X T E N S I O N  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtensionEventSink::~CCandUIExtensionEventSink( void )
{
	Assert( m_pExtensionMgr == NULL );
	if (m_pExtensionMgr != NULL) {
		DoneEventSink();
	}
}


/*   I N I T  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionEventSink::InitEventSink( CCandUIExtensionMgr *pExtensionMgr )
{
	Assert( pExtensionMgr != NULL );
	Assert( m_pExtensionMgr == NULL );

	if (pExtensionMgr == NULL) {
		return E_INVALIDARG;
	}

	m_pExtensionMgr = pExtensionMgr;
	return m_pExtensionMgr->AdviseEventSink( this );
}


/*   D O N E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIExtensionEventSink::DoneEventSink( void )
{
	HRESULT hr;

	Assert( m_pExtensionMgr != NULL );
	if (m_pExtensionMgr == NULL) {
		return E_FAIL;
	}

	hr = m_pExtensionMgr->UnadviseEventSink( this );
	m_pExtensionMgr = NULL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candkey.h ===
//
// candkey.h - CandidateUI Key Table
//

#ifndef CANDKEY_H
#define CANDKEY_H

#include "private.h"
#include "globals.h"
#include "mscandui.h"

//
// CCandUIKeyTable
//  = candidate ui key table  =
//

class CCandUIKeyTable : public ITfCandUIKeyTable
{
public:
	CCandUIKeyTable( void );
	virtual ~CCandUIKeyTable( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIKeyTable
	//
	STDMETHODIMP GetKeyDataNum( int *piNum );
	STDMETHODIMP GetKeyData( int iData, CANDUIKEYDATA *pData );

	//
	//
	//
	HRESULT SetKeyTable( const CANDUIKEYDATA *pKeyData, int nKeyData );
	HRESULT SetKeyTable( ITfCandUIKeyTable *pCandUIKeyTable );
	void CommandFromKey( UINT uVkey, WCHAR wch, BYTE *pbKeyState, CANDUIUIDIRECTION uidir, CANDUICOMMAND *pcmd, UINT *pParam );

protected:
	long          m_cRef;
	int           m_nKeyData;
	CANDUIKEYDATA *m_pKeyData;
};


#endif // CANDKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candmenu.cpp ===
//
// lbmenu.cpp
//

#include "private.h"
#include "candmenu.h"
#include "cuimenu.h"
#include "globals.h"
#include "candutil.h"
#include "wcand.h"


//
//
//

#define g_dwMenuStyle   UIWINDOW_TOPMOST | UIWINDOW_TOOLWINDOW | UIWINDOW_OFC10MENU | UIWINDOW_HASSHADOW


//////////////////////////////////////////////////////////////////////////////
//
// CCandMenuItem
//
//////////////////////////////////////////////////////////////////////////////

/*   C  C A N D  M E N U  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandMenuItem::CCandMenuItem( CCandMenu *pCandMenu )
{
	m_pCandMenu = pCandMenu;
}


/*   ~  C  C A N D  M E N U  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandMenuItem::~CCandMenuItem( void ) 
{
}


/*   I N S E R T  T O  U I   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandMenuItem::InsertToUI( CUIFMenu *pCuiMenu )
{
	UINT uFlags = MF_BYPOSITION;

	if (_dwFlags & TF_LBMENUF_SEPARATOR) {
		uFlags |= MF_SEPARATOR;
		pCuiMenu->InsertSeparator();
		return TRUE;
	}

	if (_dwFlags & TF_LBMENUF_SUBMENU) {
		Assert(m_pCandMenu);
		CUIFMenu *pCuiMenuSub = ((CCandMenu *)_pSubMenu)->CreateMenuUI( TRUE /* sub menu */ );

		CUIFMenuItem *pCuiItem = new CUIFMenuItem(pCuiMenu);
		if (!pCuiItem) {
			return FALSE;
		}

		pCuiItem->Initialize();
		pCuiItem->Init((UINT)-1, _bstr);
		pCuiItem->SetSub(pCuiMenuSub);

		if (_hbmp) {
			pCuiItem->SetBitmap(_hbmp);
		}

		if (_hbmpMask) {
			pCuiItem->SetBitmapMask(_hbmpMask);
		}

		pCuiMenu->InsertItem(pCuiItem);

		return TRUE;
	}

	CUIFMenuItem *pCuiItem = new CUIFMenuItem(pCuiMenu);
	if (!pCuiItem) {
		return FALSE;
	}

	pCuiItem->Initialize();
	pCuiItem->Init(_uId, _bstr);

	if (_dwFlags & TF_LBMENUF_GRAYED) {
		pCuiItem->Gray(TRUE);
	}

	if (_dwFlags & TF_LBMENUF_CHECKED) {
		pCuiItem->Check(TRUE);
	}
	else if (_dwFlags & TF_LBMENUF_RADIOCHECKED) {
		pCuiItem->RadioCheck(TRUE);
	}

	if (_hbmp) {
		pCuiItem->SetBitmap(_hbmp);
	}

	if (_hbmpMask) {
		pCuiItem->SetBitmapMask(_hbmpMask);
	}

	pCuiMenu->InsertItem(pCuiItem);
	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//
// CCandMenu
//
//////////////////////////////////////////////////////////////////////////////

/*   C  C A N D  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandMenu::CCandMenu( HINSTANCE hInst )
{
	NONCLIENTMETRICS ncm;

	m_hInst = hInst;
	m_pCUIMenu = NULL;
	memset( &m_lf, 0, sizeof(m_lf) );
	m_pCandWnd = NULL;

	ncm.cbSize = sizeof(ncm);
	if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE)) {
		ConvertLogFontAtoW( &ncm.lfMenuFont, &m_lf );
	}
}


/*   ~  C  C A N D  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandMenu::~CCandMenu()
{
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandMenu::AddRef(void)
{
	return CCicLibMenu::AddRef();
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandMenu::Release(void)
{
	return CCicLibMenu::Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandMenu::QueryInterface(REFIID riid, void **ppvObj)
{
	if (IsEqualIID( riid, IID_ITfCandUIMenuExtension )) {
		if (ppvObj == NULL) {
			return E_POINTER;
		}

		*ppvObj = SAFECAST( this, ITfCandUIMenuExtension* );

		AddRef();
		return S_OK;
	}

	return CCicLibMenu::QueryInterface( riid, ppvObj );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandMenu::SetFont( LOGFONTW *plf )
{
	if (plf == NULL) {
		return E_INVALIDARG;
	}

	m_lf = *plf;
	return S_OK;
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandMenu::GetFont( LOGFONTW *plf )
{
	if (plf == NULL) {
		return E_INVALIDARG;
	}

	*plf = m_lf;
	return S_OK;
}


/*   S H O W  P O P U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
UINT CCandMenu::ShowPopup( CCandWindowBase *pCandWnd, const POINT pt, const RECT *prcArea )
{
	if (m_pCUIMenu) {
		 return 0;
	}

	m_pCandWnd = pCandWnd;

	UINT uRet = 0;
	if (m_pCUIMenu = CreateMenuUI( FALSE /* not sub menu */)) {

		uRet = m_pCUIMenu->ShowModalPopup( m_pCandWnd, prcArea, TRUE );

		delete m_pCUIMenu;
		m_pCUIMenu = NULL;
	}

	m_pCandWnd = NULL;

	return uRet;
}


/*   C L O S E  P O P U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandMenu::ClosePopup( void )
{
	if (m_pCUIMenu != NULL) {
		PostThreadMessage( GetCurrentThreadId(), WM_NULL, 0, 0 );
	}
}


/*   C R E A T E  M E N U  U I   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFMenu *CCandMenu::CreateMenuUI( BOOL fSubMenu )
{
	CUIFCandMenu *pCuiMenu;
	int i;

	if (fSubMenu) {
		pCuiMenu = new CUIFCandMenu( m_hInst, g_dwMenuStyle, 0 );
	}
	else {
		pCuiMenu = new CUIFCandMenuParent( m_hInst, g_dwMenuStyle, 0, m_pCandWnd );
	}

	pCuiMenu->Initialize();
	pCuiMenu->ResetMenuFont( &m_lf );

	for (i = 0; i < _rgItem.Count(); i++) {
		CCandMenuItem *pItem = (CCandMenuItem *)_rgItem.Get(i);
		pItem->InsertToUI( pCuiMenu );
	}

	return pCuiMenu;
}


/*   G E T  M E N U  U I   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFMenu *CCandMenu::GetMenuUI( void )
{
	return m_pCUIMenu;
}


//
//
//

/*   C  U I F  C A N D  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCandMenu::CUIFCandMenu( HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle ) : CUIFMenu( hInst, dwWndStyle, dwMenuStyle )
{
}


/*   ~  C  U I F  C A N D  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCandMenu::~CUIFCandMenu( void )
{
}


/*   R E S E T  M E N U  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandMenu::ResetMenuFont( LOGFONTW *plf )
{
	ClearMenuFont();
	SetFont( OurCreateFontIndirectW( plf ) );
}


//
//
//

/*   C  U I F  C A N D  M E N U  P A R E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCandMenuParent::CUIFCandMenuParent( HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle, CCandWindowBase *pCandWnd ) : CUIFCandMenu( hInst, dwWndStyle, dwMenuStyle )
{
	m_pCandWnd = pCandWnd;
}


/*   ~  C  U I F  C A N D  M E N U  P A R E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCandMenuParent::~CUIFCandMenuParent( void )
{
   UninstallHook();
}


/*   I N I T  S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFCandMenuParent::InitShow( CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical, BOOL fAnimate )
{
	BOOL fSucceed = TRUE;

	if (!CUIFMenu::InitShow( pcuiWndParent, prc, fVertical, fAnimate )) {
		fSucceed = FALSE;
	}

	if (!InstallHook()) {
		fSucceed = FALSE;
	}

	if (m_pCandWnd != NULL) {
		m_pCandWnd->OnMenuOpened();
	}

	return fSucceed;
}


/*   U N I N I T  S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFCandMenuParent::UninitShow()
{
	BOOL fSucceed = TRUE;

	if (!CUIFMenu::UninitShow()) {
		fSucceed = FALSE;
	}

	if (!UninstallHook()) {
		fSucceed = FALSE;
	}

	if (m_pCandWnd != NULL) {
		m_pCandWnd->OnMenuClosed();
	}

	return fSucceed;
}


/*   M O D A L  M E S S A G E  L O O P   */
/*------------------------------------------------------------------------------

	NOTE: we need to use PeekMessage to cancel candidate menu
	in unknown mouse message (w/o eating...)

------------------------------------------------------------------------------*/
void CUIFCandMenuParent::ModalMessageLoop( void )
{
	MSG msg;

	while (TRUE) {
		while (!PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE )) {
			WaitMessage();
		}

		if (PeekMessage( &msg, NULL, 0, 0, PM_REMOVE )) {
			if (msg.message == WM_NULL) {
				break;
			}

			else if (msg.message == WM_QUIT)  {
				PostQuitMessage( (int)msg.wParam );
				break;
			}

			// check hooked mouse message (messages sent to another window)
				
			else if (msg.message == g_msgHookedMouse) {
				if (((msg.wParam != WM_MOUSEMOVE) && (msg.wParam != WM_NCMOUSEMOVE))) {
					CancelMenu();
					break;
				}

				msg.hwnd    = GetWnd();
				msg.message = (UINT)msg.wParam;
				msg.wParam  = 0;
			}

			// check hooked keyboard messages (all keyboard messages)
				
			else if (msg.message == g_msgHookedKey) {
				UINT message;
				CUIFMenu *pMenuObj = GetTopSubMenu();

				if (HIWORD(msg.lParam) & KF_ALTDOWN) {
					message = (HIWORD(msg.lParam) & KF_UP) ? WM_SYSKEYUP : WM_SYSKEYDOWN;
				}
				else {
					message = (HIWORD(msg.lParam) & KF_UP) ? WM_KEYUP : WM_KEYDOWN;
				}

				if (message == WM_SYSKEYDOWN) {
					CancelMenu();
				}

				msg.hwnd    = (pMenuObj != NULL) ? pMenuObj->GetWnd() : NULL;
				msg.message = message;
			}

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
}


/*   I N S T A L L  H O O K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFCandMenuParent::InstallHook( void )
{
	HHOOK hHookKeyboard;
	HHOOK hHookMouse;

	if (!g_ShareMem.Create()) {
		return FALSE;
	}

	if (!g_ShareMem.LockData()) {
		return FALSE;
	}

	hHookKeyboard = SetWindowsHookEx( WH_KEYBOARD, KeyboardProc, m_hInstance, NULL );
	hHookMouse    = SetWindowsHookEx( WH_MOUSE,    MouseProc,    m_hInstance, NULL );

	g_ShareMem.GetData()->dwThreadId = GetCurrentThreadId();
	g_ShareMem.GetData()->hHookKeyboard = hHookKeyboard;
	g_ShareMem.GetData()->hHookMouse = hHookMouse;
	g_ShareMem.GetData()->pMenuParent = this;

	g_ShareMem.UnlockData();

	return (hHookKeyboard != NULL) && (hHookMouse != NULL);
}


/*   U N I N S T A L L  H O O K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFCandMenuParent::UninstallHook( void )
{
	HHOOK hHook;

	if (!g_ShareMem.LockData()) {
		return FALSE;
	}

	if (g_ShareMem.GetData()->dwThreadId != GetCurrentThreadId()) {
		g_ShareMem.UnlockData();
		return FALSE;
	}

	hHook = g_ShareMem.GetData()->hHookKeyboard;
	if (hHook != NULL) {
		UnhookWindowsHookEx( hHook );
	}

	hHook = g_ShareMem.GetData()->hHookMouse;
	if (hHook != NULL) {
		UnhookWindowsHookEx( hHook );
	}

	g_ShareMem.GetData()->dwThreadId    = 0;
	g_ShareMem.GetData()->hHookKeyboard = NULL;
	g_ShareMem.GetData()->hHookMouse    = NULL;
	g_ShareMem.GetData()->pMenuParent   = NULL;

	g_ShareMem.UnlockData();

	g_ShareMem.Close();

	return TRUE;
}


/*   K E Y B O A R D  P R O C   */
/*------------------------------------------------------------------------------

	Hook function for keyboard message
	Forward all keyboard message as g_msgHookedKey to the manu window thread

------------------------------------------------------------------------------*/
LRESULT CALLBACK CUIFCandMenuParent::KeyboardProc( int code, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult = 0;
	BOOL fEatMessage = FALSE;

	if (!g_ShareMem.LockData()) {
		return 0;
	}

	if (code == HC_ACTION || code == HC_NOREMOVE) {
		PostThreadMessage( g_ShareMem.GetData()->dwThreadId, g_msgHookedKey, wParam, lParam );
		fEatMessage = TRUE;
	}

	if ((code < 0) || !fEatMessage) {
		lResult = CallNextHookEx( g_ShareMem.GetData()->hHookKeyboard, code, wParam, lParam );
	}
	else {
		lResult = (LRESULT)TRUE;
	}

	g_ShareMem.UnlockData();

	return lResult;
}


/*   M O U S E  P R O C   */
/*------------------------------------------------------------------------------

	Hook function for mouse message
	Forward mouse message sent to non-menu window (excluding mouse movement)
	as g_msgHookedMouse to the manu window thread

------------------------------------------------------------------------------*/
LRESULT CALLBACK CUIFCandMenuParent::MouseProc( int code, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult = 0;
	BOOL fEatMessage = FALSE;

	if (!g_ShareMem.LockData()) {
		return 0;
	}

	if (code == HC_ACTION || code == HC_NOREMOVE) {
		MOUSEHOOKSTRUCT *pmhs = (MOUSEHOOKSTRUCT *)lParam;
		UINT message = (UINT)wParam;

		if (GetCurrentThreadId() == g_ShareMem.GetData()->dwThreadId) {
			CUIFMenu *pMenuObj = g_ShareMem.GetData()->pMenuParent;

			while ((pMenuObj != NULL) && (pMenuObj->GetWnd() != pmhs->hwnd)) {
				pMenuObj = pMenuObj->GetCurrentSubMenu();
			}

			if (pMenuObj == NULL) {
				if ((message != WM_NCMOUSEMOVE) && (message != WM_MOUSEMOVE)) {
					PostThreadMessage( g_ShareMem.GetData()->dwThreadId, g_msgHookedMouse, wParam, MAKELPARAM(pmhs->pt.x, pmhs->pt.y) );
				}
				else {
					fEatMessage = (message == WM_NCMOUSEMOVE);
				}
			}
		}
		else {
			if ((message != WM_NCMOUSEMOVE) && (message != WM_MOUSEMOVE)) {
				PostThreadMessage( g_ShareMem.GetData()->dwThreadId, g_msgHookedMouse, wParam, MAKELPARAM(pmhs->pt.x, pmhs->pt.y) );
			}
		}
	}

	if ((code < 0) || !fEatMessage) {
		lResult = CallNextHookEx( g_ShareMem.GetData()->hHookMouse, code, wParam, lParam );
	}
	else {
		lResult = (LRESULT)TRUE;
	}

	g_ShareMem.UnlockData();

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candkey.cpp ===
//
// candkey.cpp
//

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candkey.h"
#include "candui.h"

void DllAddRef(void);
void DllRelease(void);

/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  K E Y  T A B L E                                        */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIKeyTable::CCandUIKeyTable( void )
{
	m_cRef = 1;

	m_nKeyData = 0;
	m_pKeyData = NULL;

	DllAddRef();
}


/*   ~  C  C A N D  U I  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIKeyTable::~CCandUIKeyTable( void )
{
	if (m_pKeyData != NULL) {
		delete m_pKeyData;
	}

	DllRelease();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIKeyTable::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIKeyTable )) {
		*ppvObj = SAFECAST( this, ITfCandUIKeyTable* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIKeyTable::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIKeyTable::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   G E T  K E Y  D A T A  N U M   */
/*------------------------------------------------------------------------------

	Get count of key data
	(ITfCandUIKeyTable method)

------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::GetKeyDataNum( int *piNum )
{
	if (piNum == NULL) {
		return E_INVALIDARG;
	}

	*piNum = m_nKeyData;
	return S_OK;
}


/*   G E T  K E Y  D A T A   */
/*------------------------------------------------------------------------------

	Get key data
	(ITfCandUIKeyTable method)

------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::GetKeyData( int iData, CANDUIKEYDATA *pData )
{
	*pData = m_pKeyData[iData];
	return S_OK;
}


/*   S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::SetKeyTable( const CANDUIKEYDATA *pKeyData, int nKeyData )
{
	Assert( 0 <= nKeyData );

	if (m_pKeyData != NULL) {
		delete m_pKeyData;
	}

	// copy data to buffer

	m_nKeyData = nKeyData;
	m_pKeyData = new CANDUIKEYDATA[ nKeyData ];

    if (m_pKeyData)
	    memcpy( m_pKeyData, pKeyData, sizeof(CANDUIKEYDATA)*nKeyData );

	return S_OK;
}


/*   S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::SetKeyTable( ITfCandUIKeyTable *pCandUIKeyTable )
{
	HRESULT       hr;
	int           i;
	int           nKeyData;
	CANDUIKEYDATA *pKeyData;

	Assert( pCandUIKeyTable != NULL );

	if (m_pKeyData != NULL) {
		delete m_pKeyData;
		m_pKeyData = NULL;
		m_nKeyData = 0;
	}

	// get number 

	hr = pCandUIKeyTable->GetKeyDataNum( &nKeyData );
	if (hr != S_OK) {
		return hr;
	}
	if (nKeyData <= 0) {
		return E_FAIL;
	}

	// create buffer

	pKeyData = new CANDUIKEYDATA[ nKeyData ];
	if (pKeyData == NULL) {
		return E_OUTOFMEMORY;
	}

	for (i = 0; i < nKeyData; i++) {
		hr = pCandUIKeyTable->GetKeyData( i, &pKeyData[i] );
		if (hr != S_OK) {
			delete pKeyData;
			return E_FAIL;
		}
	}

	// 

	m_pKeyData = pKeyData;
	m_nKeyData = nKeyData;

	return S_OK;
}


/*   C O M M A N D  F R O M  K E Y   */
/*------------------------------------------------------------------------------

	Get command from key

------------------------------------------------------------------------------*/
void CCandUIKeyTable::CommandFromKey( UINT uVKey, WCHAR wch, BYTE *pbKeyState, CANDUIUIDIRECTION uidir, CANDUICOMMAND *pcmd, UINT *pParam )
{
	BOOL  fShift;
	BOOL  fCtrl;
	int   i;
	int   iRotRelative;

	Assert( pcmd != NULL );
	Assert( pParam != NULL );

	*pcmd = CANDUICMD_NONE;
	*pParam = 0;

	// get keystate

	fShift = (pbKeyState[ VK_SHIFT ] & 0x80) != 0;
	fCtrl  = (pbKeyState[ VK_CONTROL ] & 0x80) != 0;

	// calc rotation for relative direction key

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: {
			iRotRelative = 0;
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT: {
			iRotRelative = 1;
			break;
		}

		case CANDUIDIR_BOTTOMTOTOP: {
			iRotRelative = 2;
			break;
		}

		case CANDUIDIR_LEFTTORIGHT: {
			iRotRelative = 3;
			break;
		}
	}

	// find the key from keymap table

	for (i = 0; i < m_nKeyData; i++) {
		BOOL fMatch = FALSE;

		if (m_pKeyData[i].dwFlag == CANDUIKEY_CHAR) {
			// check character code

			fMatch = ((WCHAR)m_pKeyData[i].uiKey == wch);
		}
		else {
			UINT uVKeyFixed;

			// map directional key when it's relative

			uVKeyFixed = m_pKeyData[i].uiKey;
			if (m_pKeyData[i].dwFlag & CANDUIKEY_RELATIVEDIR) {
				int iKey;
				const UINT rguVKey[4] = {
					VK_DOWN,
					VK_LEFT,
					VK_UP,
					VK_RIGHT
				};

				// find key

				for (iKey = 0; iKey < 4; iKey++) {
					if (uVKeyFixed == rguVKey[iKey]) {
						uVKeyFixed = rguVKey[ (iKey + iRotRelative) % 4 ];
						break;
					}
				}
			}

			// check keycode

			fMatch = (uVKeyFixed == uVKey);

			// check shift state

			if (m_pKeyData[i].dwFlag & CANDUIKEY_SHIFT) {
				fMatch &= fShift;
			}
			else if (m_pKeyData[i].dwFlag & CANDUIKEY_NOSHIFT) {
				fMatch &= (!fShift);
			}

			// check ctrl state

			if (m_pKeyData[i].dwFlag & CANDUIKEY_CTRL) {
				fMatch &= fCtrl;
			}
			else if (m_pKeyData[i].dwFlag & CANDUIKEY_NOCTRL) {
				fMatch &= (!fCtrl);
			}
		}

		// match?

		if (fMatch) {
			*pcmd   = m_pKeyData[i].cmd;
			*pParam = m_pKeyData[i].uiParam;
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candfunc.cpp ===
//
// candfunc.cpp
//

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candmgr.h"
#include "candfunc.h"
#include "candutil.h"
#include "candobj.h"
#include "candui.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  F N  A U T O  F I L T E R                                    */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  F N  A U T O  F I L T E R   */
/*------------------------------------------------------------------------------

	Constructor of CCandFnAutoFilter

------------------------------------------------------------------------------*/
CCandFnAutoFilter::CCandFnAutoFilter( CCandidateUI *pCandUI )
{
	m_pCandUI    = pCandUI;
	m_fEnable    = FALSE;
	m_bstrFilter = NULL;
	m_pSink      = NULL;

	InitEventSink( pCandUI->GetCandListMgr() );
}


/*   ~  C  C A N D  F N  A U T O  F I L T E R   */
/*------------------------------------------------------------------------------

	Destructor of CCandFnAutoFilter

------------------------------------------------------------------------------*/
CCandFnAutoFilter::~CCandFnAutoFilter( void )
{
	ReleaseEventSink();

	ClearFilterString();
	FilterCandidateList();

	DoneEventSink();
}


/*   O N  S E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on SetCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnAutoFilter::OnSetCandidateList( void )
{
	ClearFilterString();
}


/*   O N  C L E A R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on ClearCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnAutoFilter::OnClearCandidateList( void )
{
	ClearFilterString();
}


/*   O N  C A N D  I T E M  U P D A T E   */
/*------------------------------------------------------------------------------

	Callback function of candiate item has been updated
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnAutoFilter::OnCandItemUpdate( void )
{
	// nothing to do...
}


/*   O N  S E L E C T I O N  C H A N G E D   */
/*------------------------------------------------------------------------------

	Callback function of candiate selection has been changed
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnAutoFilter::OnSelectionChanged( void )
{
	ClearFilterString();
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandFnAutoFilter::Enable( BOOL fEnable )
{
	if (m_fEnable != fEnable) {
		m_fEnable = fEnable;

		ClearFilterString();
		FilterCandidateList();

		// notify

		if (fEnable) {
			m_pCandUI->NotifyFilteringEvent( CANDUIFEV_ENABLED ); 
		}
		else {
			m_pCandUI->NotifyFilteringEvent( CANDUIFEV_DISABLED ); 
		}
	}

	return S_OK;
}


/*   G E T  F I L T E R I N G  R E S U L T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandFnAutoFilter::GetFilteringResult( CANDUIFILTERSTR strtype, BSTR *pbstr )
{
	CCandidateItem *pCandItem;
	LPCWSTR pchCandidate;
	LPCWSTR pchFiltering;
	LPCWSTR pchReturn;
	WCHAR szNull[] = L"";
	int iItemSel;

	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	if (!IsEnabled()) {
		return E_FAIL;
	}

	// check if candidate list has been set

	if (GetCandListMgr()->GetCandList() == NULL) {
		return E_FAIL;
	}

	// 

	iItemSel = GetCandListMgr()->GetCandList()->GetSelection();
	pCandItem = GetCandListMgr()->GetCandList()->GetCandidateItem( iItemSel );

    if (pCandItem == NULL)
    {
	    Assert( FALSE );
		return E_FAIL;
    }

	//

	pchCandidate = pCandItem->GetString();
	pchFiltering = GetFilterString(); 
	if (pchFiltering == NULL) {
		pchFiltering = szNull;
	}
	pchReturn = NULL;

	switch (strtype) {
		case CANDUIFST_COMPLETE: {   
			/* complete string */
			pchReturn = pchCandidate;
			break;
		}


		case CANDUIFST_DETERMINED: { 
			/* determined string (filtering string) */
			pchReturn = pchFiltering;
			break;
		}

		case CANDUIFST_UNDETERMINED: {
			/* undetermined string (incoming string) */
			Assert( wcslen(pchFiltering) <= wcslen(pchCandidate) );;
			pchReturn = pchCandidate + wcslen(pchFiltering);
			break;
		}
	}

	if (pchReturn == NULL) {
		return E_FAIL;
	}

	*pbstr = SysAllocString( pchReturn );
	return (*pbstr != NULL) ? S_OK : E_OUTOFMEMORY;
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandFnAutoFilter::IsEnabled( void )
{
	return m_fEnable;
}


/*   S E T  F I L T E R  S T R I N G   */
/*------------------------------------------------------------------------------

	Set filter string
	Note that this never update filter result.  Call FilterCandidateList.

------------------------------------------------------------------------------*/
void CCandFnAutoFilter::SetFilterString( LPCWSTR psz )
{
	ClearFilterString();
	if (psz != NULL && *psz != L'\0') {
		m_bstrFilter = SysAllocString( psz );
	}
}


/*   G E T  F I L T E R  S T R I N G   */
/*------------------------------------------------------------------------------

	Get filter string

------------------------------------------------------------------------------*/
LPCWSTR CCandFnAutoFilter::GetFilterString( void )
{
	return m_bstrFilter;
}


/*   C L E A R  F I L T E R  S T R I N G   */
/*------------------------------------------------------------------------------

	Clear filter string
	Note that this never update filter result.  Call FilterCandidateList.

------------------------------------------------------------------------------*/
void CCandFnAutoFilter::ClearFilterString( void )
{
	if (m_bstrFilter != NULL) {
		SysFreeString( m_bstrFilter );
		m_bstrFilter = NULL;
	}
}


/*   F I L T E R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Do filtering

------------------------------------------------------------------------------*/
int CCandFnAutoFilter::FilterCandidateList( void )
{
	CCandidateList *pCandList;
	int cchFilter;
	int i;
	int nItem;
	int nItemVisible;
	BOOL fFirst;

	pCandList = GetCandListMgr()->GetCandList();
	if (pCandList == NULL) {
		return 0;
	}

	cchFilter = (m_bstrFilter == NULL) ? 0 : wcslen( m_bstrFilter );

	nItem = pCandList->GetItemCount();
	nItemVisible = 0;
	fFirst = TRUE;

	for (i = 0; i < nItem; i++) {
		CCandidateItem *pCandItem = pCandList->GetCandidateItem( i );
		BOOL fMatch = TRUE;

		if (cchFilter != 0) {
			fMatch = (CompareString( pCandItem->GetString(), m_bstrFilter, cchFilter ) == 0);
		}

		pCandItem->SetVisibleState( fMatch );
		if (fMatch) {
			nItemVisible++;

			// select first visible item

			if (fFirst) {
				GetCandListMgr()->SetSelection( i, this );
				fFirst = FALSE;
			}
		}
	}

	GetCandListMgr()->NotifyCandItemUpdate( this );
	return nItemVisible;
}


/*   F  E X I S T  I T E M  M A T C H E S   */
/*------------------------------------------------------------------------------

	Check if item exist matches with the string

------------------------------------------------------------------------------*/
BOOL CCandFnAutoFilter::FExistItemMatches( LPCWSTR psz )
{
	CCandidateList *pCandList;
	int cchFilter;
	int i;
	int nItem;
	int nItemVisible;

	pCandList = GetCandListMgr()->GetCandList();
	if (pCandList == NULL) {
		return 0;
	}

	cchFilter = (psz == NULL) ? 0 : wcslen( psz );

	nItem = pCandList->GetItemCount();
	nItemVisible = 0;

	for (i = 0; i < nItem; i++) {
		CCandidateItem *pCandItem = pCandList->GetCandidateItem( i );
		BOOL fMatch = TRUE;

		if (cchFilter != 0) {
			fMatch = (CompareString( pCandItem->GetString(), psz, cchFilter ) == 0);
		}
		if (fMatch) {
			nItemVisible++;
		}
	}

	return (nItemVisible != 0);
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandFnAutoFilter::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIFnAutoFilter *pObject;
	HRESULT             hr;

	pObject = new CCandUIFnAutoFilter( m_pCandUI, this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  F N  S O R T                                                 */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  F N  S O R T   */
/*------------------------------------------------------------------------------

	Constructor of CCandFnSort

------------------------------------------------------------------------------*/
CCandFnSort::CCandFnSort( CCandidateUI *pCandUI )
{
	m_pCandUI  = pCandUI;
	m_SortType = CANDSORT_NONE;
	m_pSink    = NULL;

	InitEventSink( pCandUI->GetCandListMgr() );
}


/*   ~  C  C A N D  F N  S O R T   */
/*------------------------------------------------------------------------------

	Destructor of CCandFnSort

------------------------------------------------------------------------------*/
CCandFnSort::~CCandFnSort( void )
{
	ReleaseEventSink();

	SortCandidateList( CANDSORT_NONE );

	DoneEventSink();
}


/*   O N  S E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on SetCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnSort::OnSetCandidateList( void )
{
	m_SortType = CANDSORT_NONE;
}


/*   O N  C L E A R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on ClearCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnSort::OnClearCandidateList( void )
{
	m_SortType = CANDSORT_NONE;
}


/*   O N  C A N D  I T E M  U P D A T E   */
/*------------------------------------------------------------------------------

	Callback function of candiate item has been updated
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnSort::OnCandItemUpdate( void )
{
	// nothing to do
}


/*   O N  S E L E C T I O N  C H A N G E D   */
/*------------------------------------------------------------------------------

	Callback function of candiate selection has been changed
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandFnSort::OnSelectionChanged( void )
{
	// nothing to do
}


/*   S O R T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Sort candidate items
	NOTE: Do not call SetSelection during sort to prevent from clearing 
		  filtering string.  Selection will be updated in CCandListMgr, 
		  and candidate window rebuilds candidate list including selection 
		  when candidate item has been updates...

------------------------------------------------------------------------------*/
HRESULT CCandFnSort::SortCandidateList( CANDSORT type )
{
	if (GetCandListMgr()->GetCandList() == NULL) {
		return E_FAIL;
	}

	if (m_SortType != type) {
		// do sort

		m_SortType = type;
		SortProc( 0, GetCandListMgr()->GetCandList()->GetItemCount() - 1 );

		GetCandListMgr()->NotifyCandItemUpdate( this );

		// notify event

		if (m_SortType != CANDSORT_NONE) {
			m_pCandUI->NotifySortEvent( CANDUISEV_SORTED );
		}
		else {
			m_pCandUI->NotifySortEvent( CANDUISEV_RESTORED );
		}
	}

	return S_OK;
}


/*   G E T  S O R T  T Y P E   */
/*------------------------------------------------------------------------------

	Get sort type 

------------------------------------------------------------------------------*/
HRESULT CCandFnSort::GetSortType( CANDSORT *ptype )
{
	if (ptype == NULL) {
		return E_INVALIDARG;
	}

	*ptype = m_SortType;
	return S_OK;
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandFnSort::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIFnSort *pObject;
	HRESULT       hr;

	pObject = new CCandUIFnSort( m_pCandUI, this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*   S O R T  P R O C   */
/*------------------------------------------------------------------------------

	perform quick sort

------------------------------------------------------------------------------*/
void CCandFnSort::SortProc( int iItemFirst, int iItemLast )
{
	CCandidateList *pCandList;
	int i;
	int iItemMid;

	if (iItemFirst >= iItemLast) {
		return;
	}

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	pCandList->SwapCandidateItem( iItemFirst, (iItemFirst + iItemLast)/2 );
	iItemMid = iItemFirst;

	for (i = iItemFirst + 1; i <= iItemLast; i++) {
		CCandidateItem* pCandItem1 = pCandList->GetCandidateItem( iItemFirst );
		CCandidateItem* pCandItem2 = pCandList->GetCandidateItem( i );
		int fMoveUp = FALSE;

		switch (m_SortType) {
			default:
			case CANDSORT_NONE: 

            if (pCandItem1 && pCandItem2)
            {
				fMoveUp = (pCandItem2->GetICandItemOrg() < pCandItem1->GetICandItemOrg());
			}
            break;

			case CANDSORT_ASCENDING:
			case CANDSORT_DESCENDING: 
            if (pCandItem1 && pCandItem2)
            {
				LONG lCompareResult;
				CCandidateStringEx *pCandStrEx1;
				CCandidateStringEx *pCandStrEx2;

				pCandStrEx1 = new CCandidateStringEx( pCandItem1 );
				pCandStrEx2 = new CCandidateStringEx( pCandItem2 );

				if ((m_pSink == NULL) || (m_pSink->CompareItem( pCandStrEx1, pCandStrEx2, &lCompareResult ) != S_OK )) {
					lCompareResult = wcscmp(pCandItem1->GetString(), pCandItem2->GetString());
				}

				if (pCandStrEx1)
				    pCandStrEx1->Release();

				if (pCandStrEx2)
				    pCandStrEx2->Release();

				if (m_SortType == CANDSORT_DESCENDING) {
					fMoveUp = (lCompareResult < 0);
				}
				else {
					fMoveUp = (lCompareResult > 0);
				}
				break;
			}
		}

		if (fMoveUp) {
			iItemMid++;
			pCandList->SwapCandidateItem( i, iItemMid );
		}
	}

	pCandList->SwapCandidateItem( iItemFirst, iItemMid );
	SortProc( iItemFirst, iItemMid-1 );
	SortProc( iItemMid+1, iItemLast );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  F N  S O R T                                                 */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U  I  F U N C T I O N  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFunctionMgr::CCandUIFunctionMgr( void )
{
	m_pCandUI = NULL;
}


/*   ~  C  C A N D  U  I  F U N C T I O N  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFunctionMgr::~CCandUIFunctionMgr( void )
{
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIFunctionMgr::Initialize( CCandidateUI *pCandUI )
{
	m_pCandUI = pCandUI;

	m_pFnAutoFilter = new CCandFnAutoFilter( pCandUI );
	if (m_pFnAutoFilter == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pFnSort = new CCandFnSort( pCandUI );
	if (m_pFnSort == NULL) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIFunctionMgr::Uninitialize( void )
{
	m_pCandUI = NULL;

	if (m_pFnAutoFilter) {
		delete m_pFnAutoFilter;
		m_pFnAutoFilter = NULL;
	}

	if (m_pFnSort) {
		delete m_pFnSort;
		m_pFnSort = NULL;
	}

	return S_OK;
}


/*   G E T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIFunctionMgr::GetObject( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_INVALIDARG;
	}

	// create interface object

	if (IsEqualGUID( riid, IID_ITfCandUIFnAutoFilter )) {
		return m_pFnAutoFilter->CreateInterfaceObject( riid, ppvObj );
	}

	if (IsEqualGUID( riid, IID_ITfCandUIFnSort )) {
		return m_pFnSort->CreateInterfaceObject( riid, ppvObj );
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candmenu.h ===
//
// candmenu.h
//

#ifndef CANDMENU_H
#define CANDMENU_H

#include "mscandui.h"
#include "lbmenu.h"
#include "cuilib.h"

class CCandMenu;
class CUIFMenu;
class CUIFWindow;
class CCandWindowBase;


//////////////////////////////////////////////////////////////////////////////
//
// CCandMenuItem
//
//////////////////////////////////////////////////////////////////////////////

class CCandMenuItem : public CCicLibMenuItem
{
public:
	CCandMenuItem( CCandMenu *pUTBMenu );
	~CCandMenuItem( void );

	BOOL InsertToUI( CUIFMenu *pCuiMenu );

private:
	CCandMenu *m_pCandMenu;
};


//////////////////////////////////////////////////////////////////////////////
//
// CCandMenu
//
//////////////////////////////////////////////////////////////////////////////

class CCandMenu : public CCicLibMenu,
				  public ITfCandUIMenuExtension
{
public:
	CCandMenu( HINSTANCE hInst );
	virtual ~CCandMenu( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );

	//
	// ITfCandUIMenuExtension methods
	//
	STDMETHODIMP SetFont( LOGFONTW *plf );
	STDMETHODIMP GetFont( LOGFONTW *plf );

	UINT ShowPopup( CCandWindowBase *pCandWindow, const POINT pt, const RECT *prcArea );
	void ClosePopup( void );
	CUIFMenu *CreateMenuUI( BOOL fSubMenu );
	CUIFMenu *GetMenuUI( void );

	virtual CCicLibMenu *CreateSubMenu()
	{
		CCandMenu *pSubMenu = new CCandMenu( m_hInst );
		if (pSubMenu != NULL) {
			pSubMenu->SetFont( &m_lf );
		}
		return pSubMenu;
	}

	virtual CCicLibMenuItem *CreateMenuItem()
	{
		return new CCandMenuItem( this );
	}

private:
	HINSTANCE m_hInst;
	CUIFMenu  *m_pCUIMenu;
	LOGFONTW  m_lf;
	CCandWindowBase *m_pCandWnd;
};


//
//
//

class CUIFCandMenu : public CUIFMenu
{
public:
	CUIFCandMenu( HINSTANCE hInst, DWORD dwWndSTyle, DWORD dwMenuStyle );
	virtual ~CUIFCandMenu( void );

	void ResetMenuFont( LOGFONTW *plf );
};


//
//
//

class CUIFCandMenuParent : public CUIFCandMenu
{
public:
	CUIFCandMenuParent( HINSTANCE hInst, DWORD dwWndSTyle, DWORD dwMenuStyle, CCandWindowBase *pCandWnd );
	virtual ~CUIFCandMenuParent( void );

protected:
	virtual void ModalMessageLoop( void );
	virtual BOOL InitShow( CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical, BOOL fAnimate );
	virtual BOOL UninitShow( void );
	BOOL InstallHook( void );
	BOOL UninstallHook( void );

	static LRESULT CALLBACK KeyboardProc( int code, WPARAM wParam, LPARAM lParam );
	static LRESULT CALLBACK MouseProc( int code, WPARAM wParam, LPARAM lParam );

	CCandWindowBase *m_pCandWnd;
};

#endif CANDMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candfunc.h ===
//
// candfunc.h
//

#ifndef CANDFUNC_H
#define CANDFUNC_H

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candmgr.h"

class CCandidateUI;


//
//
//

typedef enum _CANDSORT
{
	CANDSORT_NONE       = 0,
	CANDSORT_ASCENDING  = 1,
	CANDSORT_DESCENDING = 2,
} CANDSORT;


//
// CCandFnAutoFilter
//  = candidate list filtering function =
//

class CCandFnAutoFilter : public CCandListEventSink
{
public:
	CCandFnAutoFilter( CCandidateUI *pCandUI );
	virtual ~CCandFnAutoFilter( void );

	//
	// CCandListEventSink
	//
	virtual void OnSetCandidateList( void );
	virtual void OnClearCandidateList( void );
	virtual void OnCandItemUpdate( void );
	virtual void OnSelectionChanged( void );

	HRESULT Enable( BOOL fEnable );
	HRESULT GetFilteringResult( CANDUIFILTERSTR strtype, BSTR *pbstr );

	BOOL IsEnabled( void );
	void SetFilterString( LPCWSTR psz );
	LPCWSTR GetFilterString( void );
	void ClearFilterString( void );
	int FilterCandidateList( void );
	BOOL FExistItemMatches( LPCWSTR psz );

	//
	// EventSink functions
	//
	void SetEventSink( ITfCandUIAutoFilterEventSink *pSink )
	{
		SafeReleaseClear( m_pSink );

		m_pSink = pSink;
		m_pSink->AddRef();
	}

	ITfCandUIAutoFilterEventSink *GetEventSink( void )
	{
		return m_pSink;
	}

	void ReleaseEventSink( void )
	{
		SafeReleaseClear( m_pSink );
	}

	//
	// interface object functions
	//
	HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	CCandidateUI *m_pCandUI;
	BOOL         m_fEnable;
	BSTR         m_bstrFilter;

	ITfCandUIAutoFilterEventSink *m_pSink;
};


//
// CCandListSort
//  = candidate list sort function =
//

class CCandFnSort : public CCandListEventSink
{
public:
	CCandFnSort( CCandidateUI *pCandUI );
	virtual ~CCandFnSort( void );

	//
	// CCandListEventSink
	//
	virtual void OnSetCandidateList( void );
	virtual void OnClearCandidateList( void );
	virtual void OnCandItemUpdate( void );
	virtual void OnSelectionChanged( void );

	HRESULT SortCandidateList( CANDSORT type );
	HRESULT GetSortType( CANDSORT *ptype );

	//
	// EventSink functions
	//
	void SetEventSink( ITfCandUISortEventSink *pSink )
	{
		SafeReleaseClear( m_pSink );

		m_pSink = pSink;
		m_pSink->AddRef();
	}

	ITfCandUISortEventSink *GetEventSink( void )
	{
		return m_pSink;
	}

	void ReleaseEventSink( void )
	{
		SafeReleaseClear( m_pSink );
	}

	//
	// interface object functions
	//
	HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	CCandidateUI *m_pCandUI;
	CANDSORT     m_SortType;
	ITfCandUISortEventSink	*m_pSink;

	void SortProc( int iItemFirst, int iItemLast );
};


//
// CCandUIFunctionMgr
//  = candidate UI function manager =
//

class CCandUIFunctionMgr
{
public:
	CCandUIFunctionMgr( void );
	virtual ~CCandUIFunctionMgr( void );

	HRESULT Initialize( CCandidateUI *pCandUI );
	HRESULT Uninitialize( void );

	__inline CCandFnAutoFilter *GetCandFnAutoFilter( void ) 
	{
		return m_pFnAutoFilter;
	}

	__inline CCandFnSort *GetCandFnSort( void )
	{
		return m_pFnSort;
	}

	//
	// 
	//
	HRESULT GetObject( REFIID riid, void **ppvObj );

protected:
	CCandidateUI        *m_pCandUI;
	CCandFnAutoFilter   *m_pFnAutoFilter;
	CCandFnSort         *m_pFnSort;
};

#endif // CANDFUNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candmgr.cpp ===
//
// candmgr.cpp
//

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candmgr.h"
#include "candutil.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D I D A T E  I T E M                                            */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D I D A T E  I T E M   */
/*------------------------------------------------------------------------------

	Constructor of CCandidateItem

------------------------------------------------------------------------------*/
CCandidateItem::CCandidateItem( int iCandItem, ITfCandidateString *pCandStr )
{
	ITfCandidateStringFlag          *pCandStrFlag;
	ITfCandidateStringInlineComment *pCandStrInlineComment;
	ITfCandidateStringPopupComment  *pCandStrPopupComment;
	ITfCandidateStringColor         *pCandStrColor;
	ITfCandidateStringFixture       *pCandStrFixture;
	ITfCandidateStringIcon          *pCandStrIcon;
	BSTR  bstr;
	DWORD dwFlag;
	BOOL  fHasFlag;

	Assert( pCandStr != NULL );

	m_iCandItemOrg          = iCandItem;
	m_pCandStr              = pCandStr;
	m_pCandStr->AddRef();

	m_nIndex                = 0;
	m_bstr                  = NULL;
	m_bstrInlineComment     = NULL;
	m_bstrPopupComment      = NULL;
	m_dwPopupCommentGroupID = 0;
	m_fHasColor             = FALSE;
	m_cr                    = RGB( 0, 0, 0 );
	m_bstrPrefix            = NULL;
	m_bstrSuffix            = NULL;
	m_hIcon                 = NULL;

	m_fVisible              = TRUE;
	m_fPopupCommentVisible  = FALSE;

	//
	// get candidate string information 
	//

	// index

	m_pCandStr->GetIndex( &m_nIndex );

	// candidate string

	if (m_pCandStr->GetString( &bstr ) == S_OK && bstr != NULL) {
		m_bstr = SysAllocString( bstr );
		SysFreeString( bstr );
	}

	// flag

	fHasFlag = FALSE;
	if (m_pCandStr->QueryInterface( IID_ITfCandidateStringFlag, (void **)&pCandStrFlag ) == S_OK) {
		fHasFlag = (pCandStrFlag->GetFlag( &dwFlag) == S_OK);
		pCandStrFlag->Release();
	}

	// inline comment 

	if (!fHasFlag || (dwFlag & CANDUISTR_HASINLINECOMMENT) != 0) {
		if (m_pCandStr->QueryInterface( IID_ITfCandidateStringInlineComment, (void **)&pCandStrInlineComment ) == S_OK) {
			if (pCandStrInlineComment->GetInlineCommentString( &bstr ) == S_OK && bstr != NULL) {
				m_bstrInlineComment = SysAllocString( bstr );
				SysFreeString( bstr );
			}

			pCandStrInlineComment->Release();
		}
	}

	// popup comment 

	if (!fHasFlag || (dwFlag & CANDUISTR_HASPOPUPCOMMENT) != 0) {
		if (m_pCandStr->QueryInterface( IID_ITfCandidateStringPopupComment, (void **)&pCandStrPopupComment ) == S_OK) {
			DWORD dwGroupID;

			if (pCandStrPopupComment->GetPopupCommentString( &bstr ) == S_OK && bstr != NULL) {
				m_bstrPopupComment = SysAllocString( bstr );
				SysFreeString( bstr );
			}

			if (pCandStrPopupComment->GetPopupCommentGroupID( &dwGroupID ) == S_OK) {
				m_dwPopupCommentGroupID = dwGroupID;
			}

			pCandStrPopupComment->Release();
		}
	}

	// color

	if (!fHasFlag || (dwFlag & CANDUISTR_HASCOLOR) != 0) {
		if (m_pCandStr->QueryInterface( IID_ITfCandidateStringColor, (void **)&pCandStrColor ) == S_OK) {
			CANDUICOLOR col;

			if (pCandStrColor->GetColor( &col ) == S_OK) {
				switch (col.type) {
					case CANDUICOL_DEFAULT:
					default: {
						break;
					}

					case CANDUICOL_SYSTEM: {
						m_fHasColor = TRUE;
						m_cr = GetSysColor( col.nIndex );
						break;
					}

					case CANDUICOL_COLORREF: {
						m_fHasColor = TRUE;
						m_cr = col.cr;
						break;
					}
				}
			}

			pCandStrColor->Release();
		}
	}

	// prefix/suffix string

	if (!fHasFlag || (dwFlag & CANDUISTR_HASFIXTURE) != 0) {
		if (m_pCandStr->QueryInterface( IID_ITfCandidateStringFixture, (void **)&pCandStrFixture ) == S_OK) {
			if (pCandStrFixture->GetPrefixString( &bstr ) == S_OK && bstr != NULL) {
				m_bstrPrefix = SysAllocString( bstr );
				SysFreeString( bstr );
			}

			if (pCandStrFixture->GetSuffixString( &bstr ) == S_OK && bstr != NULL) {
				m_bstrSuffix = SysAllocString( bstr );
				SysFreeString( bstr );
			}

			pCandStrFixture->Release();
		}
	}

	// icon

	if (!fHasFlag || (dwFlag & CANDUISTR_HASICON) != 0) {
		if (m_pCandStr->QueryInterface( IID_ITfCandidateStringIcon, (void **)&pCandStrIcon ) == S_OK) {
			HICON hIcon = NULL;

			if (pCandStrIcon->GetIcon( &hIcon ) == S_OK && hIcon != NULL) {
				m_hIcon = hIcon;
			}

			pCandStrIcon->Release();
		}
	}
}


/*   ~  C  C A N D I D A T E  I T E M   */
/*------------------------------------------------------------------------------

	Destructor of CCandidateItem

------------------------------------------------------------------------------*/
CCandidateItem::~CCandidateItem( void )
{
	// dispose buffers

	if (m_bstr != NULL) {
		SysFreeString( m_bstr );
	}

	if (m_bstrInlineComment != NULL) {
		SysFreeString( m_bstrInlineComment );
	}

	if (m_bstrPopupComment != NULL) {
		SysFreeString( m_bstrPopupComment );
	}

	if (m_bstrPrefix != NULL) {
		SysFreeString( m_bstrPrefix );
	}

	if (m_bstrSuffix != NULL) {
		SysFreeString( m_bstrSuffix );
	}

	// release candidate string

	m_pCandStr->Release();
}


/*   G E T  I  C A N D  I T E M  O R G   */
/*------------------------------------------------------------------------------

	Get index of candidat item
	NOTE: this is index of candidate item in candidate list
		(use to identify original index of candidate item)

------------------------------------------------------------------------------*/
int CCandidateItem::GetICandItemOrg( void )
{
	return m_iCandItemOrg;
}


/*   G E T  I N D E X   */
/*------------------------------------------------------------------------------

	Get index of item
	NOTE: this is index of candidate item stored in candidate string
		(use to specify candidate item to client in notification)

------------------------------------------------------------------------------*/
ULONG CCandidateItem::GetIndex( void )
{
	return m_nIndex;
}


/*   G E T  S T R I N G   */
/*------------------------------------------------------------------------------

	Get candidate string of item

------------------------------------------------------------------------------*/
LPCWSTR CCandidateItem::GetString( void )
{
	return m_bstr;
}


/*   G E T  I N L I N E  C O M M E N T   */
/*------------------------------------------------------------------------------

	Get inline comment

------------------------------------------------------------------------------*/
LPCWSTR CCandidateItem::GetInlineComment( void )
{
	return m_bstrInlineComment;
}


/*   G E T  P O P U P  C O M M E N T   */
/*------------------------------------------------------------------------------

	Get popup comment

------------------------------------------------------------------------------*/
LPCWSTR CCandidateItem::GetPopupComment( void )
{
	return m_bstrPopupComment;
}


/*   G E T  P O P U P  C O M M E N T  G R O U P  I  D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CCandidateItem::GetPopupCommentGroupID( void )
{
	return m_dwPopupCommentGroupID;
}


/*   G E T  C O L O R   */
/*------------------------------------------------------------------------------

	Get color

------------------------------------------------------------------------------*/
BOOL CCandidateItem::GetColor( COLORREF *pcr )
{
	Assert( pcr != NULL );

	if (m_fHasColor) {
		*pcr = m_cr;
		return TRUE;
	}

	return FALSE;
}


/*   G E T  P R E F I X  S T R I N G   */
/*------------------------------------------------------------------------------

	Get prefix string

------------------------------------------------------------------------------*/
LPCWSTR CCandidateItem::GetPrefixString( void )
{
	return m_bstrPrefix;
}


/*   G E T  S U F F I X  S T R I N G   */
/*------------------------------------------------------------------------------

	Get suffix string

------------------------------------------------------------------------------*/
LPCWSTR CCandidateItem::GetSuffixString( void )
{
	return m_bstrSuffix;
}


/*   G E T  I C O N   */
/*------------------------------------------------------------------------------

	Get icon

------------------------------------------------------------------------------*/
HICON CCandidateItem::GetIcon( void )
{
	return m_hIcon;
}


/*   S E T  V I S I B L E  S T A T E   */
/*------------------------------------------------------------------------------

	Set visible status

------------------------------------------------------------------------------*/
void CCandidateItem::SetVisibleState( BOOL fVisible )
{
	m_fVisible = fVisible;
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible status
	Returns TRUE when the item is visible, FALSE when invisible.

------------------------------------------------------------------------------*/
BOOL CCandidateItem::IsVisible( void )
{
	return m_fVisible;
}


/*   S E T  P O P U P  C O M M E N T  S T A T E   */
/*------------------------------------------------------------------------------

	Set popup comment status

------------------------------------------------------------------------------*/
void CCandidateItem::SetPopupCommentState( BOOL fVisible )
{
	m_fPopupCommentVisible = fVisible;
}


/*   I S  P O P U P  C O M M E N T  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible status of popup comment
	Returns TRUE when the popup comment of item is visible, FALSE when invisible.

------------------------------------------------------------------------------*/
BOOL CCandidateItem::IsPopupCommentVisible( void )
{
	return m_fPopupCommentVisible;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D I D A T E  L I S T                                            */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Constructor of CCandidateList

------------------------------------------------------------------------------*/
CCandidateList::CCandidateList( CCandListMgr *pCandListMgr, ITfCandidateList *pCandList )
{
	Assert( pCandListMgr != NULL );
	Assert( pCandList != NULL );

	m_pCandListMgr      = pCandListMgr;
	m_pOptionsList      = NULL;
	m_pCandList         = pCandList;
	m_rgCandItem        = NULL;
	m_nCandItem         = 0;

	m_pExtraCandItem    = NULL;
	m_bstrTip           = NULL;

	m_fRawData          = FALSE;
	m_bstrRawData       = NULL;
	m_hbmpRawData       = NULL;
	m_hemfRawData       = NULL;
	m_nIndexRawData     = 0;
	m_fIndexRawData     = FALSE;

	m_iItemSel          = ICANDITEM_NULL;

	//

	if (m_pCandList != NULL) {
		m_pCandList->AddRef();
	}
}

CCandidateList::CCandidateList( CCandListMgr *pCandListMgr, ITfOptionsCandidateList *pCandList )
{
	Assert( pCandListMgr != NULL );
	Assert( pCandList != NULL );

	m_pCandListMgr      = pCandListMgr;
	m_pOptionsList      = pCandList;
	m_pCandList         = NULL;
	m_rgCandItem        = NULL;
	m_nCandItem         = 0;

	m_pExtraCandItem    = NULL;
	m_bstrTip           = NULL;

	m_fRawData          = FALSE;
	m_bstrRawData       = NULL;
	m_hbmpRawData       = NULL;
	m_hemfRawData       = NULL;
	m_nIndexRawData     = 0;
	m_fIndexRawData     = FALSE;

	m_iItemSel          = ICANDITEM_NULL;

	//

	if (m_pOptionsList != NULL) {
		m_pOptionsList->AddRef();
	}
}

/*   ~  C  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Destructor of CCandidateList

------------------------------------------------------------------------------*/
CCandidateList::~CCandidateList( void )
{
	Uninitialize();

	if (m_pCandList != NULL) {
		m_pCandList->Release();
	}
	if (m_pOptionsList != NULL) {
		m_pOptionsList->Release();
	}
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

	Initialize CandidateList

------------------------------------------------------------------------------*/
HRESULT CCandidateList::Initialize( void )
{
	ITfCandidateListExtraCandidate *pCandListExtraCand;
	ITfCandidateListTip            *pCandListTip;
	ITfCandidateListRawData        *pCandListRawData;
	ITfCandidateString *pCandStr;
	ULONG nCandItem;
	ULONG i;

	if (m_pCandList == NULL &&
        m_pOptionsList == NULL) {
		return E_INVALIDARG;
	}

	//
	// 
	//

	Assert( m_rgCandItem == NULL );
	Assert( m_nCandItem == 0 );

	// 
	// build options item list (if present)
	//

	if (m_pOptionsList) {
		m_nCandItem = 0;
		m_pOptionsList->GetOptionsCandidateNum( &nCandItem );

		if (nCandItem != 0) {
			m_rgCandItem = new CCandidateItem*[ nCandItem ];

			if (m_rgCandItem == NULL)
				return E_OUTOFMEMORY;

			for (i = 0; i < nCandItem; i++) {
				if (SUCCEEDED(m_pOptionsList->GetOptionsCandidate( i, &pCandStr ))) {
					m_rgCandItem[m_nCandItem] = new CCandidateItem( m_nCandItem, pCandStr );;
					m_nCandItem++;

					pCandStr->Release();
				}
			}
		}
	}

	//
	// build candidate item list
	//

	if (m_pCandList) {
		m_nCandItem = 0;
	    m_pCandList->GetCandidateNum( &nCandItem );

	    if (nCandItem != 0) {
		    m_rgCandItem = new CCandidateItem*[ nCandItem ];

            if (m_rgCandItem == NULL)
                return E_OUTOFMEMORY;

		    for (i = 0; i < nCandItem; i++) {
			    if (SUCCEEDED(m_pCandList->GetCandidate( i, &pCandStr ))) {
				    m_rgCandItem[m_nCandItem] = new CCandidateItem( m_nCandItem, pCandStr );;
				    m_nCandItem++;

				    pCandStr->Release();
			    }
		    }
	    }

	    //
	    // get extended information of candidate list
	    //

	    // extra item

	    if (m_pCandList->QueryInterface( IID_ITfCandidateListExtraCandidate, (void **)&pCandListExtraCand ) == S_OK) {
		    if (pCandListExtraCand->GetExtraCandidate( &pCandStr ) == S_OK) {
			    m_pExtraCandItem = new CCandidateItem( ICANDITEM_EXTRA, pCandStr );
			    pCandStr->Release();
		    }

		    pCandListExtraCand->Release();
	    }

	    // tip string

	    if (m_pCandList->QueryInterface( IID_ITfCandidateListTip, (void **)&pCandListTip ) == S_OK) {
		    BSTR bstr;

		    if (pCandListTip->GetTipString( &bstr ) == S_OK) {
			    m_bstrTip = SysAllocString( bstr );
			    SysFreeString( bstr );
		    }

		    pCandListTip->Release();
	    }

	    // raw data

	    if (m_pCandList->QueryInterface( IID_ITfCandidateListRawData, (void **)&pCandListRawData ) == S_OK) {
		    CANDUIRAWDATA RawData;

		    // raw data

		    if (pCandListRawData->GetRawData( &RawData ) == S_OK) {
			    m_fRawData = TRUE;
			    m_kRawData = RawData.type;

			    switch (RawData.type) {
				    case CANDUIRDT_STRING: {
					    m_bstrRawData = SysAllocString( RawData.bstr );
					    SysFreeString( RawData.bstr );
					    break;
				    }

				    case CANDUIRDT_BITMAP: {
					    m_hbmpRawData = RawData.hbmp;
					    break;
				    }

				    case CANDUIRDT_METAFILE: {
					    m_hemfRawData = RawData.hemf;
					    break;
				    }
			    }
		    }

		    // raw data index

		    if (pCandListRawData->GetRawDataIndex( &m_nIndexRawData ) == S_OK) {
			    m_fIndexRawData = TRUE;
		    }

		    pCandListRawData->Release();
	    }
	}

	// initialize selection

	if (m_pOptionsList)
	{
		m_iItemSel = ICANDITEM_NULL;
	}
	else
	{
		m_iItemSel = 0;
	}

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateList::Uninitialize( void )
{
	int i;

	if (m_rgCandItem == NULL) {
		Assert( m_nCandItem == 0 );
	}

	// dispose canditem objects

	for (i = 0; i < m_nCandItem; i++) {
		delete m_rgCandItem[i];
	}

	// dispose canditem list

	if (m_rgCandItem != NULL) {
		delete m_rgCandItem;
		m_rgCandItem = NULL;
	}
	m_nCandItem = 0;

	// dispose extra item

	if (m_pExtraCandItem != NULL) {
		delete m_pExtraCandItem;
		m_pExtraCandItem = NULL;
	}

	// dispose tip

	if (m_bstrTip != NULL) {
		SysFreeString( m_bstrTip );
		m_bstrTip = NULL;
	}

	// dispose raw data

	m_fRawData = FALSE;

	if (m_bstrRawData != NULL) {
		SysFreeString( m_bstrRawData );
	}
	m_bstrRawData = NULL;
	m_hbmpRawData = NULL;
	m_hemfRawData = NULL;

	m_nIndexRawData = 0;
	m_fIndexRawData = FALSE;

	return S_OK;
}


/*   G E T  I T E M  C O U N T   */
/*------------------------------------------------------------------------------

	Get count of candidate item object

------------------------------------------------------------------------------*/
int CCandidateList::GetItemCount( void )
{
	return m_nCandItem;
}


/*   G E T  C A N D I D A T E  I T E M   */
/*------------------------------------------------------------------------------

	Get candidate item object

------------------------------------------------------------------------------*/
CCandidateItem *CCandidateList::GetCandidateItem( int iItem )
{
	if (0 <= iItem && iItem < m_nCandItem) {
		return m_rgCandItem[ iItem ];
	}
	else if (iItem == ICANDITEM_EXTRA) {
		return m_pExtraCandItem;
	}

	return NULL;
}


/*   S W A P  C A N D I D A T E  I T E M   */
/*------------------------------------------------------------------------------

	Swap two candidate items
	NOTE: Only used from CCandFnSort.
	NOTE: Do not send SetSelection notification here.  It resets filtering
		  string and makes conflict filtering state.

------------------------------------------------------------------------------*/
void CCandidateList::SwapCandidateItem( int iItem1, int iItem2 )
{
	if ((iItem1 != iItem2) &&  (0 <= iItem1 && iItem1 <= m_nCandItem) && (0 <= iItem2 && iItem2 <= m_nCandItem)) {
		CCandidateItem *pCandItem1;
		CCandidateItem *pCandItem2;
		int iItemSel;

		// swap items

		pCandItem1 = m_rgCandItem[ iItem1 ];
		pCandItem2 = m_rgCandItem[ iItem2 ];
		m_rgCandItem[ iItem1 ] = pCandItem2;
		m_rgCandItem[ iItem2 ] = pCandItem1;

		// check selection

		iItemSel = GetSelection();
		if (iItemSel == iItem1) {
			CCandidateList::SetSelection( iItem2 );
		}
		else if (iItemSel == iItem2) {
			CCandidateList::SetSelection( iItem1 );
		}
	}
}


/*   G E T  E X T R A  C A N D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateItem *CCandidateList::GetExtraCandItem( void )
{
	return m_pExtraCandItem;
}


/*   G E T  E X T R A  C A N D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
ULONG CCandidateList::GetExtraCandIndex( void )
{
	if (m_pExtraCandItem == NULL) {
		return 0;
	}

	return m_pExtraCandItem->GetIndex();
}


/*   G E T  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CCandidateList::GetTipString( void )
{
	return m_bstrTip;
}


/*   F  H A S  R A W  D A T A   */
/*------------------------------------------------------------------------------

	Returns TRUE when CandidateList has raw data

------------------------------------------------------------------------------*/
BOOL CCandidateList::FHasRawData( void )
{
	return m_fRawData;
}


/*   G E T  R A W  D A T A  T Y P E   */
/*------------------------------------------------------------------------------

	Get raw data type

------------------------------------------------------------------------------*/
CANDUIRAWDATATYPE CCandidateList::GetRawDataType( void )
{
	return m_kRawData;
}


/*   G E T  R A W  D A T A  S T R I N G   */
/*------------------------------------------------------------------------------

	Get raw data string

------------------------------------------------------------------------------*/
LPCWSTR CCandidateList::GetRawDataString( void )
{
	return m_bstrRawData;
}


/*   G E T  R A W  D A T A  B I T M A P   */
/*------------------------------------------------------------------------------

	Get raw data bitmap

------------------------------------------------------------------------------*/
HBITMAP CCandidateList::GetRawDataBitmap( void )
{
	return m_hbmpRawData;
}


/*   G E T  R A W  D A T A  M E T A F I L E   */
/*------------------------------------------------------------------------------

	Get raw data metafile

------------------------------------------------------------------------------*/
HENHMETAFILE CCandidateList::GetRawDataMetafile( void )
{
	return m_hemfRawData;
}


/*   G E T  R A W  D A T A  I N D E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
ULONG CCandidateList::GetRawDataIndex( void )
{
	return m_nIndexRawData;
}


/*   F  R A W  D A T A  S E L E C T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandidateList::FRawDataSelectable( void )
{
	return (m_fRawData && m_fIndexRawData);
}


/*   S E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandidateList::SetSelection( int iItem )
{
	m_iItemSel = iItem;
}


/*   G E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CCandidateList::GetSelection( void )
{
	return m_iItemSel;
}


/*   M A P  I  I T E M  T O  I N D E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateList::MapIItemToIndex( int iItem, ULONG *pnIndex )
{
	Assert( pnIndex != NULL );

	if (0 <= iItem && iItem < m_nCandItem) {
		*pnIndex = m_rgCandItem[ iItem ]->GetIndex();
		return S_OK;
	}

	return E_FAIL;
}


/*   M A P  I N D E X  T O  I  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateList::MapIndexToIItem( ULONG nIndex, int *piItem )
{
	int iItem;

	for (iItem = 0; iItem < m_nCandItem; iItem++) {
		if (m_rgCandItem[ iItem ]->GetIndex() == nIndex) {
			*piItem = iItem;
			return S_OK;
		}
	}

	return E_FAIL;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  L I S T  M G R                                               */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  L I S T  M G R   */
/*------------------------------------------------------------------------------

	Constructor of CCandListMgr

------------------------------------------------------------------------------*/
CCandListMgr::CCandListMgr( void )
{
	int i;

	m_pCandUI   = NULL;
	m_pCandListObj = NULL;
	m_pOptionsListObj = NULL;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		m_rgCandListSink[i] = NULL;
	}
}


/*   ~  C  C A N D  L I S T  M G R   */
/*------------------------------------------------------------------------------

	Destructor of CCandListMgr

------------------------------------------------------------------------------*/
CCandListMgr::~CCandListMgr( void )
{
	Uninitialize();
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandListMgr::Initialize( CCandidateUI *pCandUI )
{
	m_pCandUI   = pCandUI;

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDLISTSINK_MAX; i++) {
		Assert( m_rgCandListSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandListMgr::Uninitialize( void )
{
	if (m_pOptionsListObj != NULL) {
		delete m_pOptionsListObj;
		m_pOptionsListObj = NULL;
	}

	if (m_pCandListObj != NULL) {
		delete m_pCandListObj;
		m_pCandListObj = NULL;
	}

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDLISTSINK_MAX; i++) {
		Assert( m_rgCandListSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

	Register event sink

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::AdviseEventSink( CCandListEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		if (m_rgCandListSink[i] == NULL) {
			m_rgCandListSink[i] = pSink;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   U N A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

	Unregister event sink

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::UnadviseEventSink( CCandListEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		if (m_rgCandListSink[i] == pSink) {
			m_rgCandListSink[i] = NULL;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   N O T I F Y  S E T  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Notify to candidate functions that candidate list has been set

------------------------------------------------------------------------------*/
void CCandListMgr::NotifySetCandList( void )
{
	int i;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		if (m_rgCandListSink[i] != NULL) {
			m_rgCandListSink[i]->OnSetCandidateList();
		}
	}
}


/*   N O T I F Y  C L E A R  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Notify to candidate functions that candidate list has been cleared

------------------------------------------------------------------------------*/
void CCandListMgr::NotifyClearCandList( void )
{
	int i;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		if (m_rgCandListSink[i] != NULL) {
			m_rgCandListSink[i]->OnClearCandidateList();
		}
	}
}


/*   N O T I F Y  C A N D  I T E M  U P D A T E   */
/*------------------------------------------------------------------------------

	Notify to candidate functions that candidate item has been updated

------------------------------------------------------------------------------*/
void CCandListMgr::NotifyCandItemUpdate( CCandListEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		if (m_rgCandListSink[i] != NULL && m_rgCandListSink[i] != pSink) {
			m_rgCandListSink[i]->OnCandItemUpdate();
		}
	}
}


/*   N O T I F Y  S E L E C T I O N  C H A N G E D   */
/*------------------------------------------------------------------------------

	Notify to candidate functions that selection has been changed

------------------------------------------------------------------------------*/
void CCandListMgr::NotifySelectionChanged( CCandListEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDLISTSINK_MAX; i++) {
		if (m_rgCandListSink[i] != NULL && m_rgCandListSink[i] != pSink) {
			m_rgCandListSink[i]->OnSelectionChanged();
		}
	}
}


/*   S E T  O P T I O N  S E L E C T I O N   */
/*------------------------------------------------------------------------------

	SetSelection

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::SetOptionSelection( int iItem, CCandListEventSink *pSink )
{
	CCandidateItem *pCandItem;

	Assert( GetCandList() != NULL );

	// check if item is valid and visible

	pCandItem = GetOptionsList()->GetCandidateItem( iItem );
	if (pCandItem == NULL || !pCandItem->IsVisible()) {
		return E_FAIL;
	}

	GetOptionsList()->SetSelection( iItem );
//	NotifySelectionChanged( pSink );

	return S_OK;
}


/*   S E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------

	SetSelection

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::SetSelection( int iItem, CCandListEventSink *pSink )
{
	CCandidateItem *pCandItem;

	Assert( GetCandList() != NULL );

	// check if item is valid and visible

	pCandItem = GetCandList()->GetCandidateItem( iItem );
	if (pCandItem == NULL || !pCandItem->IsVisible()) {
		return E_FAIL;
	}

	GetCandList()->SetSelection( iItem );
	NotifySelectionChanged( pSink );

	return S_OK;
}


/*   S E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Set candidate list

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::SetCandidateList( ITfCandidateList *pCandList )
{
	HRESULT hr;

	if ((m_pCandListObj != NULL) || (m_pOptionsListObj !=NULL)) {
		return E_FAIL;
	}

	// create candidate list object

	m_pCandListObj = new CCandidateList( this, pCandList );
	if (m_pCandListObj == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = m_pCandListObj->Initialize();
	if (FAILED(hr)) {
		delete m_pCandListObj;
		m_pCandListObj = NULL;
	}

	CComPtr<ITfOptionsCandidateList> cpOptionsList;
	if (pCandList && pCandList->QueryInterface(IID_ITfOptionsCandidateList, (void **)&cpOptionsList) == S_OK) {
		m_pOptionsListObj = new CCandidateList( this, cpOptionsList);
		if (m_pOptionsListObj == NULL) {
			return E_OUTOFMEMORY;
		}
		hr = m_pOptionsListObj->Initialize();
		if (FAILED(hr)) {
			delete m_pOptionsListObj;
			m_pOptionsListObj = NULL;
		}
	}

	// send notification

	NotifySetCandList();
	return hr;
}


/*   G E T  O P T I O N S  L I S T   */
/*------------------------------------------------------------------------------

	Get candidate list

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::GetOptionsCandidateList( ITfOptionsCandidateList **ppCandList )
{
	if (ppCandList == NULL) {
		return E_INVALIDARG;
	}

	if (GetOptionsList() == NULL) {
		return E_FAIL;
	}

	*ppCandList = GetOptionsList()->GetOptionsCandidateList();
	(*ppCandList)->AddRef();

	return S_OK;
}


/*   G E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Get candidate list

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::GetCandidateList( ITfCandidateList **ppCandList )
{
	if (ppCandList == NULL) {
		return E_INVALIDARG;
	}

	if (GetCandList() == NULL) {
		return E_FAIL;
	}

	*ppCandList = GetCandList()->GetCandidateList();
	(*ppCandList)->AddRef();

	return S_OK;
}


/*   C L E A R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Clear candidate list

------------------------------------------------------------------------------*/
HRESULT CCandListMgr::ClearCandiateList( void )
{
	HRESULT hr = S_OK;

	if ((m_pCandListObj == NULL) && (NULL == m_pOptionsListObj)) {
		return S_OK;
	}

	// dispose candidate list object

    if (m_pCandListObj) {
	    hr = m_pCandListObj->Uninitialize();

	    delete m_pCandListObj;
	    m_pCandListObj = NULL;
    }

    if ((S_OK == hr) && m_pOptionsListObj) {
        // disponse options list object if any
        hr = m_pOptionsListObj->Uninitialize();
        
        delete m_pOptionsListObj;
        m_pOptionsListObj = NULL;
    }

	if (hr == S_OK) {
		// send notification

		NotifyClearCandList();
	}

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  S T Y L E  E V E N T  S I N K                           */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  S T Y L E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

	Constructor of CCandListEventSink

------------------------------------------------------------------------------*/
CCandListEventSink::CCandListEventSink( void )
{
	m_pCandListMgr = NULL;
}


/*   ~  C  C A N D  U I  S T Y L E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

	Destructor of CCandListEventSink

------------------------------------------------------------------------------*/
CCandListEventSink::~CCandListEventSink( void )
{
	Assert( m_pCandListMgr == NULL );
	if (m_pCandListMgr != NULL) {
		DoneEventSink();
	}
}


/*   I N I T  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

	Register candidate UI style event sink

------------------------------------------------------------------------------*/
HRESULT CCandListEventSink::InitEventSink( CCandListMgr *pCandListMgr )
{
	Assert( pCandListMgr != NULL );
	Assert( m_pCandListMgr == NULL );

	if (pCandListMgr == NULL) {
		return E_FAIL;
	}

	m_pCandListMgr = pCandListMgr;
	return m_pCandListMgr->AdviseEventSink( this );
}


/*   D O N E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

	Unregister candidate UI style event sink

------------------------------------------------------------------------------*/
HRESULT CCandListEventSink::DoneEventSink( void )
{
	HRESULT hr;

	Assert( m_pCandListMgr != NULL );

	if (m_pCandListMgr == NULL) {
		return E_FAIL;
	}

	hr = m_pCandListMgr->UnadviseEventSink( this );
	m_pCandListMgr = NULL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candmgr.h ===
//
// candmgr.h - Candidate List Manager
//

#ifndef CANDMGR_H
#define CANDMGR_H

#include "private.h"
#include "mscandui.h"


class CCandidateUI;
class CCandListMgr;
class CCandListEventSink;

#define CANDLISTSINK_MAX	5

#define ICANDITEM_NULL		(-1)
#define ICANDITEM_EXTRA		(-2)


//
// CCandidateItem
//  = candidate item object = 
//

class CCandidateItem
{
public:
	CCandidateItem( int iCandItem, ITfCandidateString *pCandStr );
	virtual ~CCandidateItem( void );

	int GetICandItemOrg( void );

	// ITfCandidateString
	ULONG GetIndex( void );
	LPCWSTR GetString( void );

	// ITfCandidateStringInlineComment
	LPCWSTR GetInlineComment( void );

	// ITfCandidateStringPopupComment
	LPCWSTR GetPopupComment( void );
	DWORD GetPopupCommentGroupID( void );

	// ITfCandidateStringColor
	BOOL GetColor( COLORREF *pcr );

	// ITfCandidateStringFixture
	LPCWSTR GetPrefixString( void );
	LPCWSTR GetSuffixString( void );

	// ITfCandidateStringIcon
	HICON GetIcon( void );

	//
	// internal property
	//
	void SetVisibleState( BOOL fVisible );
	BOOL IsVisible( void );
	void SetPopupCommentState( BOOL fVisible );
	BOOL IsPopupCommentVisible( void );

protected:
	ITfCandidateString  *m_pCandStr;
	int                 m_iCandItemOrg;

	// ITfCandidateString
	ULONG               m_nIndex;
	BSTR                m_bstr;

	// ITfCandidateStringInlineComment
	BSTR                m_bstrInlineComment;

	// ITfCandidateStringPopupComment
	BSTR                m_bstrPopupComment;
	DWORD               m_dwPopupCommentGroupID;

	// ITfCandidateStringColor
	BOOL                m_fHasColor;
	COLORREF            m_cr;

	// ITfCandidateStringFixture
	BSTR                m_bstrPrefix;
	BSTR                m_bstrSuffix;

	// ITfCandidateStringIcon
	HICON               m_hIcon;

	// internal property
	BOOL                m_fVisible;
	BOOL                m_fPopupCommentVisible;
};


//
// CCandidateList
//  = candidate list property =
//

class CCandidateList
{
public:
	CCandidateList( CCandListMgr *pCandListMgr, ITfCandidateList *pCandList );
	CCandidateList( CCandListMgr *pCandListMgr, ITfOptionsCandidateList *pCandList );
	virtual ~CCandidateList( void );

	HRESULT Initialize( void );
	HRESULT Uninitialize( void );

	//
	// candidate item
	//
	int GetItemCount( void );
	CCandidateItem *GetCandidateItem( int iItem );
	void SwapCandidateItem( int iItem1, int iItem2 );

	//
	// extra candidate item
	//
	CCandidateItem *GetExtraCandItem( void );
	ULONG GetExtraCandIndex( void );

	//
	// candidate list tip 
	//
	LPCWSTR GetTipString( void );

	//
	// rawdata
	//
	BOOL FHasRawData( void );
	CANDUIRAWDATATYPE GetRawDataType( void );
	LPCWSTR GetRawDataString( void );
	HBITMAP GetRawDataBitmap( void );
	HENHMETAFILE GetRawDataMetafile( void );
	ULONG GetRawDataIndex( void );
	BOOL FRawDataSelectable( void );

	//
	// internal property
	//
	void SetSelection( int iItem );
	int GetSelection( void );

	//
	//
	//
	HRESULT MapIItemToIndex( int iItem, ULONG *pnIndex );
	HRESULT MapIndexToIItem( ULONG nIndex, int *piItem );

	//
	//
	//
	__inline ITfOptionsCandidateList *GetOptionsCandidateList( void )
	{
		return m_pOptionsList;
	}
	__inline ITfCandidateList *GetCandidateList( void )
	{
		return m_pCandList;
	}

protected:
	CCandListMgr        *m_pCandListMgr;
	ITfOptionsCandidateList *m_pOptionsList;
	ITfCandidateList    *m_pCandList;

	// candidate item
	CCandidateItem      **m_rgCandItem;
	int                 m_nCandItem;

	// extra candidate item
	CCandidateItem      *m_pExtraCandItem;

	// candidate list tip
	BSTR                m_bstrTip;

	// rawdata
	BOOL                m_fRawData;
	CANDUIRAWDATATYPE   m_kRawData;
	BSTR                m_bstrRawData;
	HBITMAP             m_hbmpRawData;
	HENHMETAFILE        m_hemfRawData;
	ULONG               m_nIndexRawData;
	BOOL                m_fIndexRawData;

	// internal property
	int                 m_iItemSel;

	void BuildCandItem( void );
	void ClearCandItem( void );

	__inline CCandListMgr *GetCandListMgr( void )
	{
		return m_pCandListMgr;
	}
};


//
// CCandListMgr 
//  = candidate list manager =
//

class CCandListMgr
{
public:
	CCandListMgr( void );
	~CCandListMgr( void );

	HRESULT Initialize( CCandidateUI *pCandUI );
	HRESULT Uninitialize( void );

	//
	// event sink functions
	//
	HRESULT AdviseEventSink( CCandListEventSink *pSink );
	HRESULT UnadviseEventSink( CCandListEventSink *pSink );
	void NotifySetCandList( void );
	void NotifyClearCandList( void );
	void NotifyCandItemUpdate( CCandListEventSink *pSink );
	void NotifySelectionChanged( CCandListEventSink *pSink );

	//
	// CandidateList handling functions
	//
	HRESULT SetCandidateList( ITfCandidateList *pCandList );
	HRESULT GetOptionsCandidateList( ITfOptionsCandidateList **ppCandList );
	HRESULT GetCandidateList( ITfCandidateList **ppCandList );
	HRESULT ClearCandiateList( void );
	HRESULT SetOptionSelection( int iItem, CCandListEventSink *pSink );
	HRESULT SetSelection( int iItem, CCandListEventSink *pSink );

	//
	//
	//
	__inline CCandidateUI *GetCandidateUI( void )
	{
		return m_pCandUI;
	}

	__inline CCandidateList *GetCandList( void )
	{
		return m_pCandListObj;
	}

	__inline CCandidateList *GetOptionsList( void )
	{
		return m_pOptionsListObj;
	}

protected:
	CCandidateUI       *m_pCandUI;
	CCandidateList     *m_pOptionsListObj;
	CCandidateList     *m_pCandListObj;
	CCandListEventSink *m_rgCandListSink[ CANDLISTSINK_MAX ];
};


//
// CCandListEventSink
//  = candidate list event sink =
//

class CCandListEventSink
{
public:
	CCandListEventSink( void );
	virtual ~CCandListEventSink( void );

	HRESULT InitEventSink( CCandListMgr *pCandListMgr );
	HRESULT DoneEventSink( void );

	//
	// callback functions
	//
	virtual void OnSetCandidateList( void )      = 0;	/* PURE */
	virtual void OnClearCandidateList( void )    = 0;	/* PURE */
	virtual void OnCandItemUpdate( void )        = 0;	/* PURE */
	virtual void OnSelectionChanged( void )      = 0;	/* PURE */

protected:
	CCandListMgr *m_pCandListMgr;

	__inline CCandListMgr *GetCandListMgr( void )
	{
		return m_pCandListMgr;
	}
};

#endif // CANDMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candui.h ===
//
// candui.h
//

#ifndef CANDUI_H
#define CANDUI_H

#include "private.h"
#include "mscandui.h"
#include "globals.h"
#include "ico.h"
#include "tes.h"
#include "editcb.h"
#include "cuilib.h"

#include "candmgr.h"
#include "candprop.h"
#include "candext.h"
#include "candkey.h"
#include "candobj.h"
#include "candfunc.h"
#include "wcand.h"
#include "sptask.h"
#include "candcomp.h"

//
//
//

#define ESCB_RESETTARGETPOS                 0
#define ESCB_COMPARERANGEANDCLOSECANDIDATE  1
#define ESCB_TEXTEVENT                      2


class CSpTask;


//
// CCandidateUI
//

class CCandidateUI : public ITfCandidateUI,
					 public ITfContextOwner,
					 public ITfContextKeyEventSink,
					 public ITfTextEditSink,
					 public ITfTextLayoutSink,
					 public ITfEditTransactionSink,
					 public CComObjectRoot_CreateInstance<CCandidateUI>,
					 public CCandListMgr,
					 public CCandUIObjectMgr,
					 public CCandUIPropertyMgr,
					 public CCandUICompartmentMgr,
					 public CCandUIFunctionMgr,
					 public CCandUIExtensionMgr
{
public:
	CCandidateUI( void );
	virtual ~CCandidateUI( void );

	BEGIN_COM_MAP_IMMX( CCandidateUI )
		COM_INTERFACE_ENTRY( ITfCandidateUI )
		COM_INTERFACE_ENTRY( ITfContextOwner )
		COM_INTERFACE_ENTRY( ITfContextKeyEventSink )
		COM_INTERFACE_ENTRY( ITfTextEditSink )
		COM_INTERFACE_ENTRY( ITfTextLayoutSink )
		COM_INTERFACE_ENTRY( ITfEditTransactionSink )
	END_COM_MAP_IMMX()

	ITfThreadMgr *_ptim;

	//
	// ITfCandidateUIEx methods
	//
	STDMETHODIMP SetClientId( TfClientId tid );
	STDMETHODIMP OpenCandidateUI( HWND hWnd, ITfDocumentMgr *pdim, TfEditCookie ec, ITfRange *pRange );
	STDMETHODIMP CloseCandidateUI( void );
	STDMETHODIMP SetCandidateList( ITfCandidateList *pCandList );
	STDMETHODIMP SetSelection( ULONG nIndex );
	STDMETHODIMP GetSelection( ULONG *pnIndex );
	STDMETHODIMP SetTargetRange( ITfRange *pRange );
	STDMETHODIMP GetTargetRange( ITfRange **ppRange );
	STDMETHODIMP GetUIObject( REFIID riid, IUnknown **ppunk );
	STDMETHODIMP GetFunction( REFIID riid, IUnknown **ppunk );
	STDMETHODIMP ProcessCommand( CANDUICOMMAND cmd, INT iParam );

	// key config function methods

	HRESULT SetKeyTable( ITfContext *pic, ITfCandUIKeyTable *pCandUIKeyTable );
	HRESULT GetKeyTable( ITfContext *pic, ITfCandUIKeyTable **ppCandUIKeyTable );
	HRESULT ResetKeyTable( ITfContext *pic );

	// UI config function methods

	HRESULT SetUIStyle( ITfContext *pic, CANDUISTYLE style );
	HRESULT GetUIStyle( ITfContext *pic, CANDUISTYLE *pstyle );
	HRESULT SetUIOption( ITfContext *pic, DWORD dwOption );
	HRESULT GetUIOption( ITfContext *pic, DWORD *pdwOption );

	//
	// input context eventsink
	//
	HRESULT InitContextEventSinks( ITfContext *pic );
	HRESULT DoneContextEventSinks( ITfContext *pic );
	STDMETHODIMP GetACPFromPoint( const POINT *pt, DWORD dwFlags, LONG *pacp );
	STDMETHODIMP GetScreenExt( RECT *prc );
	STDMETHODIMP GetTextExt( LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped );
	STDMETHODIMP GetStatus( TF_STATUS *pdcs );
	STDMETHODIMP GetWnd( HWND *phwnd );
	STDMETHODIMP GetAttribute( REFGUID rguidAttribute, VARIANT *pvarValue );
	STDMETHODIMP OnKeyDown( WPARAM wParam, LPARAM lParam, BOOL *pfEaten );
	STDMETHODIMP OnKeyUp( WPARAM wParam, LPARAM lParam, BOOL *pfEaten );
	STDMETHODIMP OnTestKeyDown( WPARAM wParam, LPARAM lParam, BOOL *pfEaten );
	STDMETHODIMP OnTestKeyUp( WPARAM wParam, LPARAM lParam, BOOL *pfEaten );
	static HRESULT TextEventCallback( UINT uCode, VOID *pv, VOID *pvData );


	//
	// text eventsink
	//
	HRESULT InitTextEventSinks( ITfContext *pic );
	HRESULT DoneTextEventSinks( ITfContext *pic );
	STDMETHODIMP OnEndEdit( ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord );
	STDMETHODIMP OnLayoutChange( ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView );
	STDMETHODIMP OnStartEditTransaction( ITfContext *pic );
	STDMETHODIMP OnEndEditTransaction( ITfContext *pic );

	//
	// edit session callback
	//
	static HRESULT EditSessionCallback( TfEditCookie ec, CEditSession *pes );

	void ClearWndCand( void )
	{
		if (m_pCandWnd) {
			m_pCandWnd->Release();
			m_pCandWnd = NULL;
		}
	}

	// accessed from CCandWnd

	HRESULT NotifyCancelCand( void );
	HRESULT NotifySelectCand( int iCandItem );
	HRESULT NotifyCompleteOption( int iCandItem );
	HRESULT NotifyCompleteCand( int iCandItem );
	HRESULT NotifyExtensionEvent( int iExtension, DWORD dwCommand, LPARAM lParam );
	HRESULT NotifyFilteringEvent( CANDUIFILTEREVENT ev );
	HRESULT NotifySortEvent( CANDUISORTEVENT sort );
	HRESULT NotifyCompleteRawData( void );
	HRESULT NotifyCompleteExtraCand( void );

	void EndCandidateList();

	HRESULT NotifySpeechCmd(SPPHRASE *pPhrase, const WCHAR *pszRuleName, ULONG ulRuleId);
	HRESULT FHandleSpellingChar( WCHAR ch );


	void EnsureSpeech(void);

	HRESULT CreateCandWindowObject( ITfContext *pic, CCandWindowBase** ppCandWnd );
	HRESULT InitCandWindow( void );

	__inline CCandListMgr *GetCandListMgr( void )
	{
		return this;
	}

	__inline CCandUIObjectMgr *GetUIObjectMgr( void )
	{
		return this;
	}

	__inline CCandUIPropertyMgr *GetPropertyMgr( void )
	{
		return this;
	}

	__inline CCandUICompartmentMgr *GetCompartmentMgr( void )
	{
		return this;
	}

	__inline CCandUIFunctionMgr *GetFunctionMgr( void )
	{
		return this;
	}

	__inline CCandUIExtensionMgr *GetExtensionMgr( void )
	{
		return this;
	}

	void PostCommand( CANDUICOMMAND cmd, INT iParam );

	__inline CCandWindowBase *GetCandWindow( void )
	{
		return m_pCandWnd;
	}

protected:
	// internal use

	HRESULT CloseCandidateUIProc( void );
	HRESULT CallSetOptionResult( int nIndex, TfCandidateResult imcr );
	HRESULT CallSetResult( int nIndex, TfCandidateResult imcr );

	HRESULT OnKeyEvent( UINT uCode, WPARAM wParam, LPARAM lParam, BOOL *pfEaten );
	BOOL FHandleKeyEvent( UINT uCode, UINT uVKey, BYTE *pbKeyState, BOOL *pfEatKey );
	BOOL HandleTextDeltas( TfEditCookie ec, ITfContext *pic, IEnumTfRanges *pEnumText );

	//

	void SetSelectionCur( ITfRange *pRange );
	void ClearSelectionCur( void );
	ITfRange *GetSelectionCur( void );

	// transaction functions

	void SetSelectionStart( ITfRange *pRange );
	void ClearSelectionStart( void );
	ITfRange *GetSelectionStart( void );

	void EnterEditTransaction( ITfRange *pSelection );
	void LeaveEditTransaction( void );
	__inline BOOL IsInEditTransaction( void )
	{
		return m_fInTransaction;
	}

	// filtering functions

	BOOL FHandleFilteringKey( UINT uCode, UINT uVKey, BYTE *pbKeyState, BOOL *pfEatKey );
	HRESULT AddFilteringChar( WCHAR wch, BOOL *pfUpdateList );
	HRESULT DelFilteringChar( BOOL *pfUpdateList );
	HRESULT FilterCandidateList( void );

	//

	WCHAR CharFromKey( UINT uVKey, BYTE *pbKeyState );
	CCandUIKeyTable *GetKeyTableProc( ITfContext *pic );
	void CommandFromKey( UINT uVkey, BYTE *pbKeyState, CANDUICOMMAND *pcmd, UINT *pParam );
	void CommandFromRule( LPCWSTR szRule, CANDUICOMMAND *pcmd, UINT *pParam );

	// members

	CCandUIKeyTable				*m_pCandUIKeyTable;

	TfClientId					m_tidClient;

	ITfContext					*m_pic;
	ITfDocumentMgr				*m_pdim;
	HWND						m_hWndParent;
	CCandWindowBase			    *m_pCandWnd;

	ITfContext					*m_picParent;
	ITfRange					*m_pTargetRange;
	UINT						m_codepage;

	//

	BOOL						m_fContextEventSinkAdvised;
	DWORD						m_dwCookieContextOwnerSink;
	DWORD						m_dwCookieContextKeySink;

	//

	BOOL						m_fTextEventSinkAdvised;
	DWORD						m_dwCookieTextEditSink;
	DWORD						m_dwCookieTextLayoutSink;
	DWORD						m_dwCookieTransactionSink;

	//

	CTextEventSink				*m_pTextEventSink;

	//

	ITfRange					*m_pSelectionCur;

	//

	BOOL						m_fInTransaction;
	ITfRange					*m_pSelectionStart;

	//

	BOOL						m_fInCallback;

	CSpTask						*m_pSpTask;
};

#endif // CANDUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candobj.cpp ===
//
// candobj.cpp
//

#include "private.h"
#include "globals.h"
#include "candobj.h"
#include "candui.h"
#include "candprop.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D I D A T E  S T R I N G  E X                                   */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D I D A T E  S T R I N G  E X   */
/*------------------------------------------------------------------------------

	Construotor of CCandidateStringEx

------------------------------------------------------------------------------*/
CCandidateStringEx::CCandidateStringEx( CCandidateItem *pCandItem )
{
	m_cRef      = 1;
	m_pCandItem = pCandItem;
}


/*   ~  C  C A N D I D A T E  S T R I N G  E X   */
/*------------------------------------------------------------------------------

	Destruotor of CCandidateStringEx

------------------------------------------------------------------------------*/
CCandidateStringEx::~CCandidateStringEx()
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandidateStringEx::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandidateString )) {
		*ppvObj = SAFECAST( this, ITfCandidateString* );
	}
	else if (IsEqualIID( riid, IID_ITfCandidateStringInlineComment )) {
		*ppvObj = SAFECAST( this, ITfCandidateStringInlineComment* );
	}
	else if (IsEqualIID( riid, IID_ITfCandidateStringPopupComment )) {
		*ppvObj = SAFECAST( this, ITfCandidateStringPopupComment* );
	}
	else if (IsEqualIID( riid, IID_ITfCandidateStringColor )) {
		*ppvObj = SAFECAST( this, ITfCandidateStringColor* );
	}
	else if (IsEqualIID( riid, IID_ITfCandidateStringFixture )) {
		*ppvObj = SAFECAST( this, ITfCandidateStringFixture* );
	}
	else if (IsEqualIID( riid, IID_ITfCandidateStringIcon)) {
		*ppvObj = SAFECAST( this, ITfCandidateStringIcon* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateStringEx::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateStringEx::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   G E T  S T R I N G   */
/*------------------------------------------------------------------------------

	Get string of candidate item
	(ITfCandidateString method)

------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetString( BSTR *pbstr )
{
	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	*pbstr = SysAllocString( m_pCandItem->GetString() );
	return S_OK;
}


/*   G E T  I N D E X   */
/*------------------------------------------------------------------------------

	Get index of candidate item
	(ITfCandidateString method)

------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetIndex( ULONG *pnIndex )
{
	if (pnIndex == NULL) {
		return E_INVALIDARG;
	}

	*pnIndex = m_pCandItem->GetIndex();
	return S_OK;
}


/*   G E T  I N L I N E  C O M M E N T  S T R I N G   */
/*------------------------------------------------------------------------------

	Get inline comment string
	(ITfCandidateStringInlineComment method)

	Returns S_OK if inline comment is available, or S_FALSE if not avaiable.

------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetInlineCommentString( BSTR *pbstr )
{
	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	if (m_pCandItem->GetInlineComment() == NULL) {
		return S_FALSE;
	}

	*pbstr = SysAllocString( m_pCandItem->GetInlineComment() );
	return S_OK;
}


/*   G E T  P O P U P  C O M M E N T  S T R I N G   */
/*------------------------------------------------------------------------------

	Get popup comment string
	(ITfCandidateStringPopupComment method)

	Returns S_OK if popup comment is available, or S_FALSE if not avaiable.

------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPopupCommentString( BSTR *pbstr )
{
	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	if (m_pCandItem->GetPopupComment() == NULL) {
		return S_FALSE;
	}

	*pbstr = SysAllocString( m_pCandItem->GetPopupComment() );
	return S_OK;
}


/*   G E T  P O P U P  C O M M E N T  G R O U P  I D   */
/*------------------------------------------------------------------------------

	Get popup comment group id
	(ITfCandidateStringPopupComment method)

	Returns S_OK if popup comment is available, or S_FALSE if not avaiable.

------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPopupCommentGroupID( DWORD *pdwGroupID )
{
	if (pdwGroupID == NULL) {
		return E_INVALIDARG;
	}

	*pdwGroupID = m_pCandItem->GetPopupCommentGroupID();
	return S_OK;
}


/*   G E T  C O L O R   */
/*------------------------------------------------------------------------------

	Get color
	(ITfCandidateStringCollor method)

	Returns S_OK if color information is available, or S_FALSE of not avaiable.

------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetColor( CANDUICOLOR *pcol )
{
	COLORREF cr;

	if (pcol == NULL) {
		return E_INVALIDARG;
	}

	if (!m_pCandItem->GetColor( &cr )) {
		return S_FALSE;
	}

	pcol->type = CANDUICOL_COLORREF;
	pcol->cr   = cr;
    return S_OK;
}


/*   G E T  P R E F I X  S T R I N G   */
/*------------------------------------------------------------------------------

	Get prefix string
	(ITfCandidateStringFixture method)

	Returns S_OK if prefix is available, or S_FALSE of not avaiable.

------------------------------------------------------------------------------*/
STDMETHODIMP CCandidateStringEx::GetPrefixString( BSTR *pbstr )
{
	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	if (m_pCandItem->GetPrefixString() == NULL) {
		return S_FALSE;
	}

	*pbstr = SysAllocString( m_pCandItem->GetPrefixString() );
	return S_OK;
}


/*   G E T  S U F F I X  S T R I N G   */
/*------------------------------------------------------------------------------

	Get suffix string
	(ITfCandidateStringFixture method)

	Returns S_OK if suffix is available, or S_FALSE of not avaiable.

------------------------------------------------------------------------------*/
STDMETHODIMP CCandidateStringEx::GetSuffixString( BSTR *pbstr )
{
	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	if (m_pCandItem->GetSuffixString() == NULL) {
		return S_FALSE;
	}

	*pbstr = SysAllocString( m_pCandItem->GetSuffixString() );
	return S_OK;
}


/*   G E T  I C O N   */
/*------------------------------------------------------------------------------

	Get icon 
	(ITfCandidateStringIcon method)

	Returns S_OK if icon is available, or S_FALSE of not avaiable.

------------------------------------------------------------------------------*/
STDMETHODIMP CCandidateStringEx::GetIcon( HICON *phIcon )
{
	if (phIcon == NULL) {
		return E_INVALIDARG;
	}

	if (m_pCandItem->GetIcon() == NULL) {
		return S_FALSE;
	}

	*phIcon = m_pCandItem->GetIcon();
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A N D  W I N D O W                                    */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICandWindow

------------------------------------------------------------------------------*/
CCandUICandWindow::CCandUICandWindow( CCandWindowProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICandWindow

------------------------------------------------------------------------------*/
CCandUICandWindow::~CCandUICandWindow( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICandWindow )) {
		*ppvObj = SAFECAST( this, ITfCandUICandWindow* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandWindow::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandWindow::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*   G E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetWindow( HWND *phWnd )
{
	return m_pProp->GetWindow( phWnd );
}


/*   S E T  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::SetUIDirection( CANDUIUIDIRECTION uidir )
{
	return m_pProp->SetUIDirection( uidir );
}


/*   G E T  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::GetUIDirection( CANDUIUIDIRECTION *puidir )
{
	return m_pProp->GetUIDirection( puidir );
}


/*   E N A B L E  A U T O  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::EnableAutoMove( BOOL fEnable )
{
	return m_pProp->EnableAutoMove( fEnable );
}


/*   I S  A U T O  M O V E  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandWindow::IsAutoMoveEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsAutoMoveEnabled( pfEnabled );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A N D  L I S T  B O X                                 */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A N D  L I S T  B O X   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICandListBox

------------------------------------------------------------------------------*/
CCandUICandListBox::CCandUICandListBox( CCandListBoxProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A N D  L I S T  B O X   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICandListBox

------------------------------------------------------------------------------*/
CCandUICandListBox::~CCandUICandListBox( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICandListBox )) {
		*ppvObj = SAFECAST( this, ITfCandUICandListBox* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandListBox::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandListBox::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*   S E T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::SetHeight( LONG lLines )
{
	return m_pProp->SetHeight( lLines );
}


/*   G E T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetHeight( LONG *plLines )
{
	return m_pProp->GetHeight( plLines );
}


/*   G E T  C A N D I D A T E  S T R I N G  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandListBox::GetCandidateStringRect( ULONG nIndex, RECT *prc )
{
	return m_pProp->GetCandidateStringRect( nIndex, prc );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A N D  S T R I N G                                    */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A N D  S T R I N G   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICandString

------------------------------------------------------------------------------*/
CCandUICandString::CCandUICandString( CCandStringProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A N D  S T R I N G   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICandString

------------------------------------------------------------------------------*/
CCandUICandString::~CCandUICandString( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICandString )) {
		*ppvObj = SAFECAST( this, ITfCandUICandString* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandString::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandString::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandString::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A N D  I N D E X                                      */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A N D  I N D E X   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICandString

------------------------------------------------------------------------------*/
CCandUICandIndex::CCandUICandIndex( CCandIndexProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A N D  I N D E X   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICandIndex

------------------------------------------------------------------------------*/
CCandUICandIndex::~CCandUICandIndex( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICandIndex )) {
		*ppvObj = SAFECAST( this, ITfCandUICandIndex* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandIndex::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandIndex::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandIndex::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  I N L I N E  C O M M E N T                              */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  I N L I N E  C O M M E N T   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIInlineComment

------------------------------------------------------------------------------*/
CCandUIInlineComment::CCandUIInlineComment( CInlineCommentProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  I N L I N E  C O M M E N T   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIInlineComment

------------------------------------------------------------------------------*/
CCandUIInlineComment::~CCandUIInlineComment( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIInlineComment )) {
		*ppvObj = SAFECAST( this, ITfCandUIInlineComment* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIInlineComment::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIInlineComment::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIInlineComment::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  P O P U P  C O M M E N T  W I N D O W                   */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  P O P U P  C O M M E N T  W I N D O W   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIPopupCommentWindow

------------------------------------------------------------------------------*/
CCandUIPopupCommentWindow::CCandUIPopupCommentWindow( CPopupCommentWindowProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  P O P U P  C O M M E N T  W I N D O W   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIPopupCommentWindow

------------------------------------------------------------------------------*/
CCandUIPopupCommentWindow::~CCandUIPopupCommentWindow( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIPopupCommentWindow )) {
		*ppvObj = SAFECAST( this, ITfCandUIPopupCommentWindow* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIPopupCommentWindow::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIPopupCommentWindow::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*   G E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetWindow( HWND *phWnd )
{
	return m_pProp->GetWindow( phWnd );
}


/*   S E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::SetDelayTime( LONG lTime )
{
	return m_pProp->SetDelayTime( lTime );
}


/*   G E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::GetDelayTime( LONG *plTime )
{
	return m_pProp->GetDelayTime( plTime );
}


/*   E N A B L E  A U T O  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::EnableAutoMove( BOOL fEnable )
{
	return m_pProp->EnableAutoMove( fEnable );
}


/*   I S  A U T O  M O V E  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentWindow::IsAutoMoveEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsAutoMoveEnabled( pfEnabled );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  P O P U P  C O M M E N T  T I T L E                     */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  P O P U P  C O M M E N T  T I T L E   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIPopupCommentTitle

------------------------------------------------------------------------------*/
CCandUIPopupCommentTitle::CCandUIPopupCommentTitle( CPopupCommentTitleProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  P O P U P  C O M M E N T  T I T L E   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIPopupCommentTitle

------------------------------------------------------------------------------*/
CCandUIPopupCommentTitle::~CCandUIPopupCommentTitle( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIPopupCommentTitle )) {
		*ppvObj = SAFECAST( this, ITfCandUIPopupCommentTitle* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIPopupCommentTitle::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIPopupCommentTitle::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}


/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentTitle::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  P O P U P  C O M M E N T  T E X T                       */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  P O P U P  C O M M E N T  T E X T   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIPopupCommentText

------------------------------------------------------------------------------*/
CCandUIPopupCommentText::CCandUIPopupCommentText( CPopupCommentTextProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  P O P U P  C O M M E N T  T E X T   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIPopupCommentText

------------------------------------------------------------------------------*/
CCandUIPopupCommentText::~CCandUIPopupCommentText( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIPopupCommentText )) {
		*ppvObj = SAFECAST( this, ITfCandUIPopupCommentText* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIPopupCommentText::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIPopupCommentText::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIPopupCommentText::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  T O O L  T I P                                          */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  T O O L  T I P   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIToolTip

------------------------------------------------------------------------------*/
CCandUIToolTip::CCandUIToolTip( CToolTipProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  T O O L  T I P   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIToolTip

------------------------------------------------------------------------------*/
CCandUIToolTip::~CCandUIToolTip( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIToolTip )) {
		*ppvObj = SAFECAST( this, ITfCandUIToolTip* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIToolTip::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIToolTip::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIToolTip::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A P T I O N                                           */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A P T I O N   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICaption

------------------------------------------------------------------------------*/
CCandUICaption::CCandUICaption( CWindowCaptionProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A P T I O N   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICaption

------------------------------------------------------------------------------*/
CCandUICaption::~CCandUICaption( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICaption )) {
		*ppvObj = SAFECAST( this, ITfCandUICaption* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICaption::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICaption::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICaption::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T R A  C A N D I D A T E                            */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T R A  C A N D I D A T E   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIExtraCandidate

------------------------------------------------------------------------------*/
CCandUIExtraCandidate::CCandUIExtraCandidate( CExtraCandidateProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  E X T R A  C A N D I D A T E   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIExtraCandidate

------------------------------------------------------------------------------*/
CCandUIExtraCandidate::~CCandUIExtraCandidate( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtraCandidate )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtraCandidate* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtraCandidate::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtraCandidate::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtraCandidate::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  R A W  D A T A                                          */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  R A W  D A T A   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIRawData

------------------------------------------------------------------------------*/
CCandUIRawData::CCandUIRawData( CCandRawDataProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  R A W  D A T A   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIRawData

------------------------------------------------------------------------------*/
CCandUIRawData::~CCandUIRawData( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIRawData )) {
		*ppvObj = SAFECAST( this, ITfCandUIRawData* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIRawData::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIRawData::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIRawData::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  M E N U  B U T T O N                                    */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  M E N U  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CCandUIMenuButton

------------------------------------------------------------------------------*/
CCandUIMenuButton::CCandUIMenuButton( CMenuButtonProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  M E N U  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CCandUIMenuButton

------------------------------------------------------------------------------*/
CCandUIMenuButton::~CCandUIMenuButton( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIMenuButton )) {
		*ppvObj = SAFECAST( this, ITfCandUIMenuButton* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIMenuButton::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIMenuButton::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*   A D V I S E   */
/*------------------------------------------------------------------------------

	Advise eventsink for candidate menu
	(ITfCandUIMenuButton method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::Advise( ITfCandUIMenuEventSink *pSink )
{
	if (pSink == NULL) {
		return E_INVALIDARG;
	}

	m_pProp->SetEventSink( pSink );
	return S_OK;
}


/*   U N A D V I S E   */
/*------------------------------------------------------------------------------

	Unadvise eventsink for candidate menu
	(ITfCandUIMenuButton method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuButton::Unadvise( void )
{
	m_pProp->ReleaseEventSink();
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A N D  T I P  W I N D O W                             */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A N D  T I P  W I N D O W   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICandTipWindow

------------------------------------------------------------------------------*/
CCandUICandTipWindow::CCandUICandTipWindow( CCandTipWindowProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A N D  T I P  W I N D O W   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICandTipWindow

------------------------------------------------------------------------------*/
CCandUICandTipWindow::~CCandUICandTipWindow( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICandTipWindow )) {
		*ppvObj = SAFECAST( this, ITfCandUICandTipWindow* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandTipWindow::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandTipWindow::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*   G E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUICandTipWindow::GetWindow( HWND *phWnd )
{
	return m_pProp->GetWindow( phWnd );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  C A N D  T I P  B U T T O N                             */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  C A N D  T I P  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CCandUICandTipWindow

------------------------------------------------------------------------------*/
CCandUICandTipButton::CCandUICandTipButton( CCandTipButtonProperty *pProp )
{
	m_cRef  = 1;
	m_pProp = pProp;
}


/*   ~  C  C A N D  U I  C A N D  T I P  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CCandUICandTipButton

------------------------------------------------------------------------------*/
CCandUICandTipButton::~CCandUICandTipButton( void )
{
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUICandTipButton )) {
		*ppvObj = SAFECAST( this, ITfCandUICandTipButton* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandTipButton::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUICandTipButton::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pProp->Enable();
	}
	else {
		return m_pProp->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::IsEnabled( BOOL *pfEnabled )
{
	return m_pProp->IsEnabled( pfEnabled );
}

/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::Show( BOOL fShow )
{
	if (fShow) {
		return m_pProp->Show();
	}
	else {
		return m_pProp->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::IsVisible( BOOL *pfVisible )
{
	return m_pProp->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::SetPosition( POINT *pptPos )
{
	return m_pProp->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::GetPosition( POINT *pptPos )
{
	return m_pProp->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::SetSize( SIZE *psize )
{
	return m_pProp->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::GetSize( SIZE *psize )
{
	return m_pProp->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::SetFont( LOGFONTW *pLogFont )
{
	return m_pProp->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::GetFont( LOGFONTW *pLogFont )
{
	return m_pProp->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::SetText( BSTR bstr )
{
	return m_pProp->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::GetText( BSTR *pbstr )
{
	return m_pProp->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::SetToolTipString( BSTR bstr )
{
	return m_pProp->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of object
	(ITfCandUIObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUICandTipButton::GetToolTipString( BSTR *pbstr )
{
	return m_pProp->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  F N  A U T O  F I L T E R                               */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  F N  A U T O  F I L T E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnAutoFilter::CCandUIFnAutoFilter( CCandidateUI *pCandUI, CCandFnAutoFilter *pFnFilter )
{
	m_cRef          = 1;
	m_pCandUI       = pCandUI;
	m_pFnAutoFilter = pFnFilter;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  F N  A U T O  F I L T E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnAutoFilter::~CCandUIFnAutoFilter( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIFnAutoFilter::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIFnAutoFilter )) {
		*ppvObj = SAFECAST( this, ITfCandUIFnAutoFilter* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnAutoFilter::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnAutoFilter::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   A D V I S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnAutoFilter::Advise( ITfCandUIAutoFilterEventSink *pSink )
{
	if (pSink == NULL) {
		return E_INVALIDARG;
	}

	m_pFnAutoFilter->SetEventSink( pSink );
	return S_OK;
}


/*   U N A D V I S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnAutoFilter::Unadvise( void )
{
	m_pFnAutoFilter->ReleaseEventSink();
	return S_OK;
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnAutoFilter::Enable( BOOL fEnable )
{
	// enable/disable filtering function

	return m_pFnAutoFilter->Enable( fEnable );
}


/*   G E T  F I L T E R I N G  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnAutoFilter::GetFilteringString( CANDUIFILTERSTR strtype, BSTR *pbstr )
{
	return m_pFnAutoFilter->GetFilteringResult( strtype, pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  F N  S O R T                                            */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  F N  S O R T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnSort::CCandUIFnSort( CCandidateUI *pCandUI, CCandFnSort *pFnSort )
{
	m_cRef    = 1;
	m_pCandUI = pCandUI;
	m_pFnSort = pFnSort;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  F N  S O R T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnSort::~CCandUIFnSort( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIFnSort::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIFnSort )) {
		*ppvObj = SAFECAST( this, ITfCandUIFnSort* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnSort::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnSort::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   A D V I S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnSort::Advise( ITfCandUISortEventSink *pSink )
{
	if (pSink == NULL) {
		return E_INVALIDARG;
	}

	m_pFnSort->SetEventSink( pSink );
	return S_OK;
}


/*   U N A D V I S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnSort::Unadvise( void )
{
	m_pFnSort->ReleaseEventSink();
	return S_OK;
}


/*   S O R T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnSort::SortCandidateList( BOOL fSort )
{
	return m_pFnSort->SortCandidateList( fSort ? CANDSORT_ASCENDING : CANDSORT_NONE );
}


/*   I S  C A N D I D A T E  L I S T  S O R T E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnSort::IsCandidateListSorted( BOOL *pfSorted )
{
	CANDSORT type;

	if (pfSorted == NULL) {
		return E_INVALIDARG;
	}

	if (FAILED(m_pFnSort->GetSortType( &type ))) {
		return E_FAIL;
	}

	*pfSorted = (type != CANDSORT_NONE);
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  F N  E X T E N S I O N                                  */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  F N  E X T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnExtension::CCandUIFnExtension( CCandidateUI *pCandUI, CCandUIExtensionMgr *pExtensionMgr )
{
	m_cRef          = 1;
	m_pCandUI       = pCandUI;
	m_pExtensionMgr = pExtensionMgr;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  F N  E X T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnExtension::~CCandUIFnExtension( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIFnExtension::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIFnExtension )) {
		*ppvObj = SAFECAST( this, ITfCandUIFnExtension* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnExtension::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnExtension::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   A D D  E X T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnExtension::AddExtObject( LONG id, REFIID riid, IUnknown **ppunk )
{
	return m_pExtensionMgr->AddExtObject( id, riid, (void**)ppunk );
}


/*   G E T  E X T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnExtension::GetExtObject( LONG id, REFIID riid, IUnknown **ppunk )
{
	return m_pExtensionMgr->GetExtObject( id, riid, (void**)ppunk );
}


/*   D E L E T E  E X T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnExtension::DeleteExtObject( LONG id )
{
	return m_pExtensionMgr->DeleteExtObject( id );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  F N  K E Y  C O N F I G                                 */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  F N  K E Y  C O N F I G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnKeyConfig::CCandUIFnKeyConfig( CCandidateUI *pCandUI )
{
	m_cRef    = 1;
	m_pCandUI = pCandUI;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  F N  K E Y  C O N F I G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnKeyConfig::~CCandUIFnKeyConfig( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIFnKeyConfig::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIFnKeyConfig )) {
		*ppvObj = SAFECAST( this, ITfCandUIFnKeyConfig* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnKeyConfig::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnKeyConfig::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnKeyConfig::SetKeyTable( ITfContext *pic, ITfCandUIKeyTable *pCandUIKeyTable )
{
	return m_pCandUI->SetKeyTable( pic, pCandUIKeyTable );
}


/*   G E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnKeyConfig::GetKeyTable( ITfContext *pic, ITfCandUIKeyTable **ppCandUIKeyTable)
{
	return m_pCandUI->GetKeyTable( pic, ppCandUIKeyTable );
}


/*   R E S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnKeyConfig::ResetKeyTable( ITfContext *pic )
{
	return m_pCandUI->ResetKeyTable( pic );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  F N  U I  C O N F I G                                   */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  F N  U I  C O N F I G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnUIConfig::CCandUIFnUIConfig( CCandidateUI *pCandUI )
{
	m_cRef    = 1;
	m_pCandUI = pCandUI;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  F N  U I  C O N F I G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIFnUIConfig::~CCandUIFnUIConfig( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIFnUIConfig::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIFnUIConfig )) {
		*ppvObj = SAFECAST( this, ITfCandUIFnUIConfig* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnUIConfig::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIFnUIConfig::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   S E T  U I  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnUIConfig::SetUIStyle( ITfContext *pic, CANDUISTYLE style )
{
	return m_pCandUI->SetUIStyle( pic, style );
}


/*   G E T  U I  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnUIConfig::GetUIStyle( ITfContext *pic, CANDUISTYLE *pstyle )
{
	return m_pCandUI->GetUIStyle( pic, pstyle );
}


/*   S E T  U  I  O P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnUIConfig::SetUIOption( ITfContext *pic, DWORD dwOption )
{
	return m_pCandUI->SetUIOption( pic, dwOption );
}


/*   G E T  U  I  O P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIFnUIConfig::GetUIOption( ITfContext *pic, DWORD *pdwOption )
{
	return m_pCandUI->GetUIOption( pic, pdwOption );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T  S P A C E                                        */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T  S P A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtSpace::CCandUIExtSpace( CCandidateUI *pCandUI, CExtensionSpace *pExtension )
{
	m_cRef       = 1;
	m_pCandUI    = pCandUI;
	m_pExtension = pExtension;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  E X T  S P A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtSpace::~CCandUIExtSpace( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtSpace )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtSpace* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtSpace::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtSpace::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   G E T  I D   */
/*------------------------------------------------------------------------------

	Get id of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::GetID( LONG *pid )
{
	return m_pExtension->GetID( pid );
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pExtension->Enable();
	}
	else {
		return m_pExtension->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::IsEnabled( BOOL *pfEnabled )
{
	return m_pExtension->IsEnabled( pfEnabled );
}


/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::Show( BOOL fShow )
{
	if (fShow) {
		return m_pExtension->Show();
	}
	else {
		return m_pExtension->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::IsVisible( BOOL *pfVisible )
{
	return m_pExtension->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::SetPosition( POINT *pptPos )
{
	return m_pExtension->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::GetPosition( POINT *pptPos )
{
	return m_pExtension->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::SetSize( SIZE *psize )
{
	return m_pExtension->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::GetSize( SIZE *psize )
{
	return m_pExtension->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::SetFont( LOGFONTW *pLogFont )
{
	return m_pExtension->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::GetFont( LOGFONTW *pLogFont )
{
	return m_pExtension->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::SetText( BSTR bstr )
{
	return m_pExtension->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::GetText( BSTR *pbstr )
{
	return m_pExtension->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::SetToolTipString( BSTR bstr )
{
	return m_pExtension->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtSpace::GetToolTipString( BSTR *pbstr )
{
	return m_pExtension->GetToolTipString( pbstr );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T  P U S H  B U T T O N                             */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T  P U S H  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtPushButton::CCandUIExtPushButton( CCandidateUI *pCandUI, CExtensionPushButton *pExtension )
{
	m_cRef       = 1;
	m_pCandUI    = pCandUI;
	m_pExtension = pExtension;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  E X T  P U S H  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtPushButton::~CCandUIExtPushButton( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtPushButton )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtPushButton* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtPushButton::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtPushButton::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   G E T  I D   */
/*------------------------------------------------------------------------------

	Get id of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::GetID( LONG *pid )
{
	return m_pExtension->GetID( pid );
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pExtension->Enable();
	}
	else {
		return m_pExtension->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::IsEnabled( BOOL *pfEnabled )
{
	return m_pExtension->IsEnabled( pfEnabled );
}


/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::Show( BOOL fShow )
{
	if (fShow) {
		return m_pExtension->Show();
	}
	else {
		return m_pExtension->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::IsVisible( BOOL *pfVisible )
{
	return m_pExtension->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetPosition( POINT *pptPos )
{
	return m_pExtension->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::GetPosition( POINT *pptPos )
{
	return m_pExtension->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetSize( SIZE *psize )
{
	return m_pExtension->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::GetSize( SIZE *psize )
{
	return m_pExtension->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetFont( LOGFONTW *pLogFont )
{
	return m_pExtension->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::GetFont( LOGFONTW *pLogFont )
{
	return m_pExtension->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetText( BSTR bstr )
{
	return m_pExtension->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::GetText( BSTR *pbstr )
{
	return m_pExtension->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetToolTipString( BSTR bstr )
{
	return m_pExtension->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::GetToolTipString( BSTR *pbstr )
{
	return m_pExtension->GetToolTipString( pbstr );
}


/*   A D V I S E   */
/*------------------------------------------------------------------------------

	Advise eventsink for candidate menu
	(CCandUIExtPushButton method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::Advise( ITfCandUIExtButtonEventSink *pSink )
{
	if (pSink == NULL) {
		return E_INVALIDARG;
	}

	m_pExtension->SetEventSink( pSink );
	return S_OK;
}


/*   U N A D V I S E   */
/*------------------------------------------------------------------------------

	Unadvise eventsink for candidate menu
	(CCandUIExtPushButton method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::Unadvise( void )
{
	m_pExtension->ReleaseEventSink();
	return S_OK;
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetIcon( HICON hIcon )
{
	return m_pExtension->SetIcon( hIcon );
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIExtPushButton::SetBitmap( HBITMAP hBitmap )
{
	return m_pExtension->SetBitmap( hBitmap );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T  T O G G L E  B U T T O N                         */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  E X T  T O G G L E  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtToggleButton::CCandUIExtToggleButton( CCandidateUI *pCandUI, CExtensionToggleButton *pExtension )
{
	m_cRef       = 1;
	m_pCandUI    = pCandUI;
	m_pExtension = pExtension;

	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  U I  E X T  T O G G L E  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIExtToggleButton::~CCandUIExtToggleButton( void )
{
	m_pCandUI->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

	Query interface
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::QueryInterface( REFIID riid, void **ppvObj )
{
	if (ppvObj == NULL) {
		return E_POINTER;
	}

	*ppvObj = NULL;

	if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtObject )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtObject* );
	}
	else if (IsEqualIID( riid, IID_ITfCandUIExtToggleButton )) {
		*ppvObj = SAFECAST( this, ITfCandUIExtToggleButton* );
	}

	if (*ppvObj == NULL) {
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtToggleButton::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtToggleButton::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   G E T  I D   */
/*------------------------------------------------------------------------------

	Get id of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetID( LONG *pid )
{
	return m_pExtension->GetID( pid );
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

	Enable/disable extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::Enable( BOOL fEnable )
{
	if (fEnable) {
		return m_pExtension->Enable();
	}
	else {
		return m_pExtension->Disable();
	}
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------

	Get enable status of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::IsEnabled( BOOL *pfEnabled )
{
	return m_pExtension->IsEnabled( pfEnabled );
}


/*   S H O W   */
/*------------------------------------------------------------------------------

	Show/hide extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::Show( BOOL fShow )
{
	if (fShow) {
		return m_pExtension->Show();
	}
	else {
		return m_pExtension->Hide();
	}
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible state of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::IsVisible( BOOL *pfVisible )
{
	return m_pExtension->IsVisible( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Set position of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetPosition( POINT *pptPos )
{
	return m_pExtension->SetPosition( pptPos );
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------

	Get position of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetPosition( POINT *pptPos )
{
	return m_pExtension->GetPosition( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------

	Set size of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetSize( SIZE *psize )
{
	return m_pExtension->SetSize( psize );
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------

	Get size of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetSize( SIZE *psize )
{
	return m_pExtension->GetSize( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

	Set font of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetFont( LOGFONTW *pLogFont )
{
	return m_pExtension->SetFont( pLogFont );
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------

	Get font of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetFont( LOGFONTW *pLogFont )
{
	return m_pExtension->GetFont( pLogFont );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetText( BSTR bstr )
{
	return m_pExtension->SetText( bstr );
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetText( BSTR *pbstr )
{
	return m_pExtension->GetText( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Set tooltip string of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetToolTipString( BSTR bstr )
{
	return m_pExtension->SetToolTipString( bstr );
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------

	Get tooltip string of extension object
	(ITfCandUIExtObject method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetToolTipString( BSTR *pbstr )
{
	return m_pExtension->GetToolTipString( pbstr );
}


/*   A D V I S E   */
/*------------------------------------------------------------------------------

	Advise eventsink for candidate menu
	(CCandUIExtToggleButton method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::Advise( ITfCandUIExtButtonEventSink *pSink )
{
	if (pSink == NULL) {
		return E_INVALIDARG;
	}

	m_pExtension->SetEventSink( pSink );
	return S_OK;
}


/*   U N A D V I S E   */
/*------------------------------------------------------------------------------

	Unadvise eventsink for candidate menu
	(CCandUIExtToggleButton method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::Unadvise( void )
{
	m_pExtension->ReleaseEventSink();
	return S_OK;
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetIcon( HICON hIcon )
{
	return m_pExtension->SetIcon( hIcon );
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetBitmap( HBITMAP hBitmap )
{
	return m_pExtension->SetBitmap( hBitmap );
}


/*   S E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::SetToggleState( BOOL fToggle )
{
	return m_pExtension->SetToggleState( fToggle );
}


/*   G E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandUIExtToggleButton::GetToggleState( BOOL *pfToggled )
{
	return m_pExtension->GetToggleState( pfToggled );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candobj.h ===
//
// candobj.h
//

#ifndef CANDOBJ_H
#define CANDOBJ_H

#include "mscandui.h"
#include "candprop.h"
#include "candfunc.h"
#include "candext.h"


class CCandidateUI;

//
// CCandidateStringEx
//

class CCandidateStringEx : public ITfCandidateString,
						   public ITfCandidateStringInlineComment,
						   public ITfCandidateStringPopupComment,
						   public ITfCandidateStringColor,
						   public ITfCandidateStringFixture,
						   public ITfCandidateStringIcon
{
public:
	CCandidateStringEx( CCandidateItem *pCandItem );
	virtual ~CCandidateStringEx( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandidateString methods
	//
	STDMETHODIMP GetString( BSTR *pbstr );
	STDMETHODIMP GetIndex( ULONG *pnIndex );

	//
	// ITfCandidateStringInlineComment methods
	//
	STDMETHODIMP GetInlineCommentString( BSTR *pbstr );

	//
	// ITfCandidateStringPopupComment methods
	//
	STDMETHODIMP GetPopupCommentString( BSTR *pbstr );
	STDMETHODIMP GetPopupCommentGroupID( DWORD *pdwGroupID );

	//
	// ITfCandidateStringColor methods
	//
	STDMETHODIMP GetColor( CANDUICOLOR *pcol );

	//
	// ITfCandidateStringFixture methods
	//
	STDMETHODIMP GetPrefixString( BSTR *pbstr );
	STDMETHODIMP GetSuffixString( BSTR *pbstr );

	//
	// ITfCandidateStringIcon methods
	//
	STDMETHODIMP GetIcon( HICON *phIcon );

protected:
	long            m_cRef;
	CCandidateItem  *m_pCandItem;
};


//
// CCandUICandWindow
//

class CCandUICandWindow : public ITfCandUICandWindow
{
public:
	CCandUICandWindow( CCandWindowProperty *pProp );
	virtual ~CCandUICandWindow( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUIWindow methods
	//
	STDMETHODIMP GetWindow( HWND *phWnd );
	STDMETHODIMP SetUIDirection( CANDUIUIDIRECTION textflow );
	STDMETHODIMP GetUIDirection( CANDUIUIDIRECTION *ptextflow );
	STDMETHODIMP EnableAutoMove( BOOL fEnable );
	STDMETHODIMP IsAutoMoveEnabled( BOOL *pfEnabled );

protected:
	long                    m_cRef;
	CCandWindowProperty     *m_pProp;
};


//
// CCandUICandListBox
//

class CCandUICandListBox : public ITfCandUICandListBox
{
public:
	CCandUICandListBox( CCandListBoxProperty *pProp );
	virtual ~CCandUICandListBox( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUICandListBox methods
	//
	STDMETHODIMP SetHeight( LONG lLines );
	STDMETHODIMP GetHeight( LONG *plLines );
	STDMETHODIMP GetCandidateStringRect( ULONG nIndex, RECT *prc );

protected:
	long                    m_cRef;
	CCandListBoxProperty    *m_pProp;
};


//
// CCandUICandString
//

class CCandUICandString : public ITfCandUICandString
{
public:
	CCandUICandString( CCandStringProperty *pProp );
	virtual ~CCandUICandString( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CCandStringProperty     *m_pProp;
};


//
// CCandUICandIndex
//

class CCandUICandIndex : public ITfCandUICandIndex
{
public:
	CCandUICandIndex( CCandIndexProperty *pProp );
	virtual ~CCandUICandIndex( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CCandIndexProperty      *m_pProp;
};


//
// CCandUIInlineComment
//

class CCandUIInlineComment : public ITfCandUIInlineComment
{
public:
	CCandUIInlineComment( CInlineCommentProperty *pProp );
	virtual ~CCandUIInlineComment( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CInlineCommentProperty  *m_pProp;
};


//
// CCandUIPopupCommentWindow
//

class CCandUIPopupCommentWindow : public ITfCandUIPopupCommentWindow
{
public:
	CCandUIPopupCommentWindow( CPopupCommentWindowProperty *pProp );
	virtual ~CCandUIPopupCommentWindow( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUIPopupCommentWindow methods
	//
	STDMETHODIMP GetWindow( HWND *phWnd );
	STDMETHODIMP SetDelayTime( LONG lTime );
	STDMETHODIMP GetDelayTime( LONG *plTime );
	STDMETHODIMP EnableAutoMove( BOOL fEnable );
	STDMETHODIMP IsAutoMoveEnabled( BOOL *pfEnabled );

protected:
	long                        m_cRef;
	CPopupCommentWindowProperty *m_pProp;
};


//
// CCandUIPopupCommentTitle
//

class CCandUIPopupCommentTitle : public ITfCandUIPopupCommentTitle
{
public:
	CCandUIPopupCommentTitle( CPopupCommentTitleProperty *pProp );
	virtual ~CCandUIPopupCommentTitle( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                        m_cRef;
	CPopupCommentTitleProperty  *m_pProp;
};


//
// CCandUIPopupCommentText
//

class CCandUIPopupCommentText : public ITfCandUIPopupCommentText
{
public:
	CCandUIPopupCommentText( CPopupCommentTextProperty *pProp );
	virtual ~CCandUIPopupCommentText( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                        m_cRef;
	CPopupCommentTextProperty   *m_pProp;
};


//
// CCandUIToolTip
//

class CCandUIToolTip : public ITfCandUIToolTip
{
public:
	CCandUIToolTip( CToolTipProperty *pProp );
	virtual ~CCandUIToolTip( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );


protected:
	long                    m_cRef;
	CToolTipProperty        *m_pProp;
};


//
// CCandUICaption
//

class CCandUICaption : public ITfCandUICaption
{
public:
	CCandUICaption( CWindowCaptionProperty *pProp );
	virtual ~CCandUICaption( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CWindowCaptionProperty  *m_pProp;
};


//
// CCandUIMenuButton
//

class CCandUIMenuButton : public ITfCandUIMenuButton
{
public:
	CCandUIMenuButton( CMenuButtonProperty *pProp );
	virtual ~CCandUIMenuButton( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUIMenuButton methods
	//
	STDMETHODIMP Advise( ITfCandUIMenuEventSink *pSink );
	STDMETHODIMP Unadvise( void );

protected:
	long                    m_cRef;
	CMenuButtonProperty     *m_pProp;
};


//
// CCandUIExtraCandidate
//

class CCandUIExtraCandidate : public ITfCandUIExtraCandidate
{
public:
	CCandUIExtraCandidate( CExtraCandidateProperty *pProp );
	virtual ~CCandUIExtraCandidate( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CExtraCandidateProperty *m_pProp;
};


//
// CCandUIRawData
//

class CCandUIRawData : public ITfCandUIRawData
{
public:
	CCandUIRawData( CCandRawDataProperty *pProp );
	virtual ~CCandUIRawData( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CCandRawDataProperty    *m_pProp;
};


//
// CCandUICandTipWindow
//

class CCandUICandTipWindow : public ITfCandUICandTipWindow
{
public:
	CCandUICandTipWindow( CCandTipWindowProperty *pProp );
	virtual ~CCandUICandTipWindow( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUICandTipWindow methods
	//
	STDMETHODIMP GetWindow( HWND *phWnd );

protected:
	long                   m_cRef;
	CCandTipWindowProperty *m_pProp;
};


//
// CCandUICandTipButton
//

class CCandUICandTipButton : public ITfCandUICandTipButton
{
public:
	CCandUICandTipButton( CCandTipButtonProperty *pProp );
	virtual ~CCandUICandTipButton( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIObject methods
	//
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CCandTipButtonProperty  *m_pProp;
};


//
//
//

class CCandUIFnAutoFilter : public ITfCandUIFnAutoFilter
{
public:
	CCandUIFnAutoFilter( CCandidateUI *pCandUI, CCandFnAutoFilter *pFnFilter );
	virtual ~CCandUIFnAutoFilter( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIFnAutoFilter methods
	//
	STDMETHODIMP Advise( ITfCandUIAutoFilterEventSink *pSink );
	STDMETHODIMP Unadvise( void );
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP GetFilteringString( CANDUIFILTERSTR strtype, BSTR *pbstr );

protected:
	long              m_cRef;
	CCandidateUI      *m_pCandUI;
	CCandFnAutoFilter *m_pFnAutoFilter;
};


//
// CCandUIFnSort
//

class CCandUIFnSort : public ITfCandUIFnSort
{
public:
	CCandUIFnSort( CCandidateUI *pCandUI, CCandFnSort *pFnSort );
	virtual ~CCandUIFnSort( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandFnSort methods
	//
	STDMETHODIMP Advise( ITfCandUISortEventSink *pSink );
	STDMETHODIMP Unadvise( void );
	STDMETHODIMP SortCandidateList( BOOL fSort );
	STDMETHODIMP IsCandidateListSorted( BOOL *pfSorted );

protected:
	long            m_cRef;
	CCandidateUI    *m_pCandUI;
	CCandFnSort     *m_pFnSort;
};


//
// CCandUIFnExtension
//

class CCandUIFnExtension : public ITfCandUIFnExtension
{
public:
	CCandUIFnExtension( CCandidateUI *pCandUI, CCandUIExtensionMgr *pExtensionMgr );
	virtual ~CCandUIFnExtension( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIFnExtension methods
	//
	STDMETHODIMP AddExtObject( LONG id, REFIID riid, IUnknown **ppunk );
	STDMETHODIMP GetExtObject( LONG id, REFIID riid, IUnknown **ppunk );
	STDMETHODIMP DeleteExtObject( LONG id );

protected:
	long                m_cRef;
	CCandidateUI        *m_pCandUI;
	CCandUIExtensionMgr *m_pExtensionMgr;
};


//
// CCandUIFnKeyConfig
//

class CCandUIFnKeyConfig : public ITfCandUIFnKeyConfig
{
public:
	CCandUIFnKeyConfig( CCandidateUI *pCandUI );
	virtual ~CCandUIFnKeyConfig( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// CCandUIFnKeyConfig methods
	//
	STDMETHODIMP SetKeyTable( ITfContext *pic, ITfCandUIKeyTable *pCandUIKeyTable );
	STDMETHODIMP GetKeyTable( ITfContext *pic, ITfCandUIKeyTable **ppCandUIKeyTable);
	STDMETHODIMP ResetKeyTable( ITfContext *pic );

protected:
	long                m_cRef;
	CCandidateUI        *m_pCandUI;
};


//
// CCandUIFnUIConfig
//

class CCandUIFnUIConfig : public ITfCandUIFnUIConfig
{
public:
	CCandUIFnUIConfig( CCandidateUI *pCandUI );
	virtual ~CCandUIFnUIConfig( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// CCandUIFnUIConfig methods
	//
	STDMETHODIMP SetUIStyle( ITfContext *pic, CANDUISTYLE style );
	STDMETHODIMP GetUIStyle( ITfContext *pic, CANDUISTYLE *pstyle );
	STDMETHODIMP SetUIOption( ITfContext *pic, DWORD dwOption );
	STDMETHODIMP GetUIOption( ITfContext *pic, DWORD *pdwOption );

protected:
	long                m_cRef;
	CCandidateUI        *m_pCandUI;
};


//
// CCandUIExtSpace
//

class CCandUIExtSpace : public ITfCandUIExtSpace
{
public:
	CCandUIExtSpace( CCandidateUI *pCandUI, CExtensionSpace *pExtension );
	virtual ~CCandUIExtSpace( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIExtObject methods
	//
	STDMETHODIMP GetID( LONG *pid );
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

protected:
	long                    m_cRef;
	CCandidateUI            *m_pCandUI;
	CExtensionSpace         *m_pExtension;
};


//
// CCandUIExtPushButton
//

class CCandUIExtPushButton : public ITfCandUIExtPushButton
{
public:
	CCandUIExtPushButton( CCandidateUI *pCandUI, CExtensionPushButton *pExtension );
	virtual ~CCandUIExtPushButton( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIExtObject methods
	//
	STDMETHODIMP GetID( LONG *pid );
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUIExtPushButton method
	//
	STDMETHODIMP Advise( ITfCandUIExtButtonEventSink *pSink );
	STDMETHODIMP Unadvise( void );
	STDMETHODIMP SetIcon( HICON hIcon );
	STDMETHODIMP SetBitmap( HBITMAP hBitmap );

protected:
	long                    m_cRef;
	CCandidateUI            *m_pCandUI;
	CExtensionPushButton    *m_pExtension;
};


//
// CCandUIExtToggleButton
//

class CCandUIExtToggleButton : public ITfCandUIExtToggleButton
{
public:
	CCandUIExtToggleButton( CCandidateUI *pCandUI, CExtensionToggleButton *pExtension );
	virtual ~CCandUIExtToggleButton( void );

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIExtObject methods
	//
	STDMETHODIMP GetID( LONG *pid );
	STDMETHODIMP Enable( BOOL fEnable );
	STDMETHODIMP IsEnabled( BOOL *pfEnabled );
	STDMETHODIMP Show( BOOL fShow );
	STDMETHODIMP IsVisible( BOOL *pfVisible );
	STDMETHODIMP SetPosition( POINT *pptPos );
	STDMETHODIMP GetPosition( POINT *pptPos );
	STDMETHODIMP SetSize( SIZE *psize );
	STDMETHODIMP GetSize( SIZE *psize );
	STDMETHODIMP SetFont( LOGFONTW *pLogFont );
	STDMETHODIMP GetFont( LOGFONTW *pLogFont );
	STDMETHODIMP SetText( BSTR bstr );
	STDMETHODIMP GetText( BSTR *pbstr );
	STDMETHODIMP SetToolTipString( BSTR bstr );
	STDMETHODIMP GetToolTipString( BSTR *pbstr );

	//
	// ITfCandUIExtToggleButton method
	//
	STDMETHODIMP Advise( ITfCandUIExtButtonEventSink *pSink );
	STDMETHODIMP Unadvise( void );
	STDMETHODIMP SetIcon( HICON hIcon );
	STDMETHODIMP SetBitmap( HBITMAP hBitmap );
	STDMETHODIMP SetToggleState( BOOL fToggle );
	STDMETHODIMP GetToggleState( BOOL *pfToggled );

protected:
	long                    m_cRef;
	CCandidateUI            *m_pCandUI;
	CExtensionToggleButton  *m_pExtension;
};

#endif // CANDOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candprop.cpp ===
//
// candprop.cpp
//

#include "private.h"
#include "globals.h"
#include "mscandui.h"
#include "candprop.h"
#include "candobj.h"
#include "candutil.h"

#include "candui.h"
#include "wcand.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  O B J E C T  P R O P E R T Y                            */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  O B J E C T  P R O P E R T Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectProperty::CCandUIObjectProperty( CCandUIPropertyMgr *pPropMgr )
{
	m_pPropMgr = pPropMgr;

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;
}


/*   ~  C  C A N D  U I  O B J E C T  P R O P E R T Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectProperty::~CCandUIObjectProperty( void )
{
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::Enable( void )
{
	HRESULT hr;

	if (!m_flags.fAllowEnable) {
		return E_FAIL;
	}

	hr = m_propEnabled.Set( TRUE );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEENABLESTATE );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   D I S A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::Disable( void )
{
	HRESULT hr;

	if (!m_flags.fAllowDisable) {
		return E_FAIL;
	}

	hr = m_propEnabled.Set( FALSE );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEENABLESTATE );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::IsEnabled( BOOL *pfEnabled )
{
	if (!m_flags.fAllowIsEnabled) {
		return E_FAIL;
	}

	return m_propEnabled.Get( pfEnabled );
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::Show( void )
{
	HRESULT hr;

	if (!m_flags.fAllowShow) {
		return E_FAIL;
	}

	hr = m_propVisible.Set( TRUE );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEVISIBLESTATE );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   H I D E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::Hide( void )
{
	HRESULT hr;

	if (!m_flags.fAllowHide) {
		return E_FAIL;
	}

	hr = m_propVisible.Set( FALSE );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEVISIBLESTATE );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::IsVisible( BOOL *pfVisible )
{
	if (!m_flags.fAllowIsVisible) {
		return E_FAIL;
	}

	return m_propVisible.Get( pfVisible );
}


/*   S E T  P O S I T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::SetPosition( POINT *pptPos )
{
	HRESULT hr;

	if (!m_flags.fAllowSetPosition) {
		return E_FAIL;
	}

	hr = m_propPos.Set( pptPos );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEPOSITION );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  P O S I T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::GetPosition( POINT *pptPos )
{
	if (!m_flags.fAllowGetPosition) {
		return E_FAIL;
	}
	return m_propPos.Get( pptPos );
}


/*   S E T  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::SetSize( SIZE *psize )
{
	HRESULT hr;

	if (!m_flags.fAllowSetSize) {
		return E_FAIL;
	}

	hr = m_propSize.Set( psize );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATESIZE );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::GetSize( SIZE *psize )
{
	if (!m_flags.fAllowGetSize) {
		return E_FAIL;
	}
	return m_propSize.Get( psize );
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::SetFont( LOGFONTW *plf )
{
	HRESULT hr;

	if (!m_flags.fAllowSetFont) {
		return E_FAIL;
	}

	hr = m_propFont.Set( plf );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEFONT );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::GetFont( LOGFONTW *plf )
{
	if (!m_flags.fAllowGetFont) {
		return E_FAIL;
	}
	return m_propFont.Get( plf );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::SetText( BSTR bstr )
{
	HRESULT hr;

	if (!m_flags.fAllowSetText) {
		return E_FAIL;
	}

	hr = m_propText.Set( bstr );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATETEXT );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::GetText( BSTR *pbstr )
{
	if (!m_flags.fAllowGetText) {
		return E_FAIL;
	}
	return m_propText.Get( pbstr );
}


/*   S E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::SetToolTipString( BSTR bstr )
{
	HRESULT hr;

	if (!m_flags.fAllowSetToolTip) {
		return E_FAIL;
	}

	hr = m_propToolTip.Set( bstr );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATETOOLTIP );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectProperty::GetToolTipString( BSTR *pbstr )
{
	if (!m_flags.fAllowGetToolTip) {
		return E_FAIL;
	}
	return m_propToolTip.Get( pbstr );
}


/*   I S  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIObjectProperty::IsEnabled( void )
{
	return m_propEnabled.Get();
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIObjectProperty::IsVisible( void )
{
	return m_propVisible.Get();
}


/*   G E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HFONT CCandUIObjectProperty::GetFont( void )
{
	return m_propFont.Get();
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CCandUIObjectProperty::GetText( void )
{
	return m_propText.Get();
}


/*   G E T  T O O L  T I P  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CCandUIObjectProperty::GetToolTipString( void )
{
	return m_propToolTip.Get();
}


/*   O N  P R O P E R T Y  U P D A T E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIObjectProperty::OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )
{
}


/*   N O T I F Y  U P D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIObjectProperty::NotifyUpdate( CANDUIPROPERTYEVENT event )
{
	GetPropertyMgr()->NotifyPropertyUpdate( GetPropType(), event );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  W I N D O W  P R O P E R T Y                                 */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  W I N D O W  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandWindowProperty

------------------------------------------------------------------------------*/
CCandWindowProperty::CCandWindowProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = TRUE;
	m_flags.fAllowHide          = TRUE;
	m_flags.fAllowIsVisible     = TRUE;
	m_flags.fAllowSetPosition   = TRUE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	m_uidir = CANDUIDIR_TOPTOBOTTOM;
	m_propAutoMoveEnabled.Set( TRUE );
	m_hWnd = NULL;

	//

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  C A N D  W I N D O W  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandWindowProperty

------------------------------------------------------------------------------*/
CCandWindowProperty::~CCandWindowProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   G E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowProperty::GetWindow( HWND *phWnd )
{
	if (phWnd == NULL) {
		return E_INVALIDARG;
	}

	*phWnd = m_hWnd;
	return (*phWnd != NULL) ? S_OK : E_FAIL;
}


/*   S E T  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowProperty::SetUIDirection( CANDUIUIDIRECTION uidir )
{
	if (m_uidir != uidir) {
		m_uidir = uidir;
		NotifyUpdate( CANDUIPROPEV_UPDATETEXTFLOW );
	}
	return S_OK;
}


/*   G E T  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowProperty::GetUIDirection( CANDUIUIDIRECTION *puidir )
{
	if (puidir == NULL) {
		return E_INVALIDARG;
	}

	*puidir = m_uidir;
	return S_OK;
}


/*   E N A B L E  A U T O  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowProperty::EnableAutoMove( BOOL fEnable )
{
	return m_propAutoMoveEnabled.Set( fEnable );
}


/*   I S  A U T O  M O V E  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowProperty::IsAutoMoveEnabled( BOOL *pfEnabled )
{
	return m_propAutoMoveEnabled.Get( pfEnabled );
}


/*   G E T  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CANDUIUIDIRECTION CCandWindowProperty::GetUIDirection( void )
{
	return m_uidir;
}


/*   I S  A U T O  M O V E  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandWindowProperty::IsAutoMoveEnabled( void )
{
	return m_propAutoMoveEnabled.Get();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_CANDWINDOW) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			if (GetUIObjectMgr()->GetCandWindowObj()) {
				RECT rc;

				m_hWnd = GetUIObjectMgr()->GetCandWindowObj()->GetWnd();

				GetWindowRect( m_hWnd, &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_hWnd = NULL;
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_hWnd = NULL;
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			RECT rc;

			GetWindowRect( m_hWnd, &rc );
			m_propPos.Set( rc.left, rc.top );
			m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICandWindow *pObject;
	HRESULT           hr;

	pObject = new CCandUICandWindow( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  L I S T  B O X  P R O P E R T Y                              */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  L I S T  B O X  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandListBoxProperty

------------------------------------------------------------------------------*/
CCandListBoxProperty::CCandListBoxProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propPos.Set( 0, 0 );
	m_propSize.Set( 0, 0 );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	m_propHeight.Set( -1 );

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  C A N D  L I S T  B O X  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandListBoxProperty

------------------------------------------------------------------------------*/
CCandListBoxProperty::~CCandListBoxProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   S E T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandListBoxProperty::SetHeight( LONG lLines )
{
	HRESULT hr;

	if ((lLines != -1) && ((lLines < 1) || (9 <lLines))) {
		return E_INVALIDARG;
	}

	hr = m_propHeight.Set( lLines );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATECANDLINES );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandListBoxProperty::GetHeight( LONG *plLines )
{
	return m_propHeight.Get( plLines );
}


/*   G E T  C A N D I D A T E  S T R I N G  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandListBoxProperty::GetCandidateStringRect( ULONG nIndex, RECT *prc )
{
	HRESULT hr;
	int iCandItem;

	if (prc == NULL) {
		return E_INVALIDARG;
	}

	// check if candidate list has been set

	if (GetPropertyMgr()->GetCandidateUI()->GetCandListMgr()->GetCandList() == NULL) {
		return E_FAIL;
	}

	// map index to icanditem

	hr = GetPropertyMgr()->GetCandidateUI()->GetCandListMgr()->GetCandList()->MapIndexToIItem( nIndex, &iCandItem );
	if (FAILED(hr)) {
		return E_FAIL;
	}

	// get item rect

	if (GetUIObjectMgr()->GetCandWindowObj() && GetUIObjectMgr()->GetCandListBoxObj()) {
		ULONG iListItem = GetUIObjectMgr()->GetCandWindowObj()->ListItemFromCandItem( iCandItem );

		GetUIObjectMgr()->GetCandListBoxObj()->GetItemRect( iListItem, prc );

		return S_OK;
	}

	return E_FAIL;
}


/*   G E T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LONG CCandListBoxProperty::GetHeight( void )
{
	return m_propHeight.Get();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandListBoxProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_CANDLISTBOX) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			CUIFCandListBase *pUIObject = GetUIObjectMgr()->GetCandListBoxObj();

			if ((pUIObject != NULL) && pUIObject->IsVisible()) {
				RECT rc;

				pUIObject->GetRect( &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandListBoxProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICandListBox *pObject;
	HRESULT            hr;

	pObject = new CCandUICandListBox( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  S T R I N G  P R O P E R T Y                                 */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  S T R I N G  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandStringProperty

------------------------------------------------------------------------------*/
CCandStringProperty::CCandStringProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_MENU, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_ORT0 );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  C A N D  S T R I N G  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandStringProperty

------------------------------------------------------------------------------*/
CCandStringProperty::~CCandStringProperty( void )
{
}


/*   O N  P R O P E R T Y  U P D A T E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandStringProperty::OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )
{
	// change font direction when UI direction is changed

	if ((prop == CANDUIPROP_CANDWINDOW) && (event == CANDUIPROPEV_UPDATETEXTFLOW)) {
		CANDUIUIDIRECTION      uidir = GetPropertyMgr()->GetCandWindowProp()->GetUIDirection();
		PROPFONTORIENTATION ort;

		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				ort = PROPFONTORT_ORT0;
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				ort = PROPFONTORT_ORT180;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				ort = PROPFONTORT_ORT270;
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				ort = PROPFONTORT_ORT90;
				break;
			}
		}

		m_propFont.SetOrientation( ort );
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandStringProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICandString *pObject;
	HRESULT           hr;

	pObject = new CCandUICandString( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  I N L I N E  C O M M E N T  P R O P E R T Y                           */
/*                                                                            */
/*============================================================================*/

/*   C  I N L I N E  C O M M E N T  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CInlineCommentProperty

------------------------------------------------------------------------------*/
CInlineCommentProperty::CInlineCommentProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_MENU, &lf );
	lf.lfHeight = lf.lfHeight * 3 / 4;

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_ORT0 );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  I N L I N E  C O M M E N T  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CInlineCommentProperty

------------------------------------------------------------------------------*/
CInlineCommentProperty::~CInlineCommentProperty( void )
{
}


/*   O N  P R O P E R T Y  U P D A T E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CInlineCommentProperty::OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )
{
	// change font direction when UI direction is changed

	if ((prop == CANDUIPROP_CANDWINDOW) && (event == CANDUIPROPEV_UPDATETEXTFLOW)) {
		CANDUIUIDIRECTION      uidir = GetPropertyMgr()->GetCandWindowProp()->GetUIDirection();
		PROPFONTORIENTATION ort;

		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				ort = PROPFONTORT_ORT0;
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				ort = PROPFONTORT_ORT180;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				ort = PROPFONTORT_ORT270;
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				ort = PROPFONTORT_ORT90;
				break;
			}
		}

		m_propFont.SetOrientation( ort );
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CInlineCommentProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIInlineComment *pObject;
	HRESULT              hr;

	pObject = new CCandUIInlineComment( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  I N D E X  P R O P E R T Y                                   */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  I N D E X  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandIndexProperty

------------------------------------------------------------------------------*/
CCandIndexProperty::CCandIndexProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_MENU, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  C A N D  I N D E X  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandIndexProperty

------------------------------------------------------------------------------*/
CCandIndexProperty::~CCandIndexProperty( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandIndexProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICandIndex *pObject;
	HRESULT           hr;

	pObject = new CCandUICandIndex( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  P O P U P  C O M M E N T  W I N D O W  P R O P E R T Y                */
/*                                                                            */
/*============================================================================*/

/*   C  P O P U P  C O M M E N T  W I N D O W  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CPopupCommentWindowProperty

------------------------------------------------------------------------------*/
CPopupCommentWindowProperty::CPopupCommentWindowProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_MESSAGE, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	m_propDelayTime.Set( 500 /* 500ms */ );
	m_propAutoMoveEnabled.Set( TRUE );
	m_hWnd = NULL;

	//

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  P O P U P  C O M M E N T  W I N D O W  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CPopupCommentWindowProperty

------------------------------------------------------------------------------*/
CPopupCommentWindowProperty::~CPopupCommentWindowProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   G E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentWindowProperty::GetWindow( HWND *phWnd )
{
	if (phWnd == NULL) {
		return E_INVALIDARG;
	}

	*phWnd = m_hWnd;
	return (*phWnd != NULL) ? S_OK : E_FAIL;
}


/*   S E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentWindowProperty::SetDelayTime( LONG lTime )
{
	HRESULT hr;

	if (lTime == -1) {
		lTime = 500; /* 500ms */
	}

	hr = m_propDelayTime.Set( lTime );
	if (hr == S_OK) {
		NotifyUpdate( CANDUIPROPEV_UPDATEPOPUPDELAY );
	}

	return (SUCCEEDED(hr) ? S_OK : hr);
}


/*   G E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentWindowProperty::GetDelayTime( LONG *plTime )
{
	return m_propDelayTime.Get( plTime );
}


/*   E N A B L E  A U T O  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentWindowProperty::EnableAutoMove( BOOL fEnable )
{
	return m_propAutoMoveEnabled.Set( fEnable );
}


/*   I S  A U T O  M O V E  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentWindowProperty::IsAutoMoveEnabled( BOOL *pfEnabled )
{
	return m_propAutoMoveEnabled.Get( pfEnabled );
}


/*   G E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LONG CPopupCommentWindowProperty::GetDelayTime( void )
{
	return m_propDelayTime.Get();
}


/*   I S  A U T O  M O V E  E N A B L E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CPopupCommentWindowProperty::IsAutoMoveEnabled( void )
{
	return m_propAutoMoveEnabled.Get();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CPopupCommentWindowProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_POPUPCOMMENTWINDOW) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			if (GetUIObjectMgr()->GetPopupCommentWindowObj()) {
				RECT rc;

				m_hWnd = GetUIObjectMgr()->GetPopupCommentWindowObj()->GetWnd();

				GetWindowRect( m_hWnd, &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_hWnd = NULL;
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_hWnd = NULL;
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			RECT rc;

			GetWindowRect( m_hWnd, &rc );
			m_propPos.Set( rc.left, rc.top );
			m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentWindowProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIPopupCommentWindow *pObject;
	HRESULT                   hr;

	pObject = new CCandUIPopupCommentWindow( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  P O P U P  C O M M E N T  T I T L E  P R O P E R T Y                  */
/*                                                                            */
/*============================================================================*/

/*   C  P O P U P  C O M M E N T  T I T L E  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CPopupCommentTitleProperty

------------------------------------------------------------------------------*/
CPopupCommentTitleProperty::CPopupCommentTitleProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_MESSAGE, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  P O P U P  C O M M E N T  T I T L E  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CPopupCommentTitleProperty

------------------------------------------------------------------------------*/
CPopupCommentTitleProperty::~CPopupCommentTitleProperty( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentTitleProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIPopupCommentTitle *pObject;
	HRESULT                  hr;

	pObject = new CCandUIPopupCommentTitle( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  P O P U P  C O M M E N T  T E X T  P R O P E R T Y                    */
/*                                                                            */
/*============================================================================*/

/*   C  P O P U P  C O M M E N T  T E X T  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CPopupCommentTextProperty

------------------------------------------------------------------------------*/
CPopupCommentTextProperty::CPopupCommentTextProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_MENU, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  P O P U P  C O M M E N T  T E X T  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CPopupCommentTextProperty

------------------------------------------------------------------------------*/
CPopupCommentTextProperty::~CPopupCommentTextProperty( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPopupCommentTextProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIPopupCommentText *pObject;
	HRESULT                 hr;

	pObject = new CCandUIPopupCommentText( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  W I N D O W  C A P T I O N  P R O P E R T Y                           */
/*                                                                            */
/*============================================================================*/

/*   C  W I N D O W  C A P T I O N  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CWindowCaptionProperty

------------------------------------------------------------------------------*/
CWindowCaptionProperty::CWindowCaptionProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_SMCAPTION, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = TRUE;
	m_flags.fAllowHide          = TRUE;
	m_flags.fAllowIsVisible     = TRUE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = TRUE;
	m_flags.fAllowGetText       = TRUE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( FALSE );
	m_propPos.Set( 0, 0 );
	m_propSize.Set( 0, 0 );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  W I N D O W  C A P T I O N  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CWindowCaptionProperty

------------------------------------------------------------------------------*/
CWindowCaptionProperty::~CWindowCaptionProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CWindowCaptionProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_CANDCAPTION) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			CUIFWndCaption *pUIObject = GetUIObjectMgr()->GetCaptionObj();

			if ((pUIObject != NULL) && pUIObject->IsVisible()) {
				RECT rc;

				pUIObject->GetRect( &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CWindowCaptionProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICaption *pObject;
	HRESULT        hr;

	pObject = new CCandUICaption( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  M E N U  B U T T O N  P R O P E R T Y                                 */
/*                                                                            */
/*============================================================================*/

/*   C  M E N U  B U T T O N  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CMenuButtonProperty

------------------------------------------------------------------------------*/
CMenuButtonProperty::CMenuButtonProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	m_flags.fAllowEnable        = TRUE;
	m_flags.fAllowDisable       = TRUE;
	m_flags.fAllowIsEnabled     = TRUE;
	m_flags.fAllowShow          = TRUE;
	m_flags.fAllowHide          = TRUE;
	m_flags.fAllowIsVisible     = TRUE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = TRUE;
	m_flags.fAllowGetToolTip    = TRUE;

	m_propEnabled.Set( FALSE );
	m_propVisible.Set( FALSE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	m_pSink = NULL;

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  M E N U  B U T T O N  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CMenuButtonProperty

------------------------------------------------------------------------------*/
CMenuButtonProperty::~CMenuButtonProperty( void )
{
	ReleaseEventSink();
	CCandUIObjectEventSink::DoneEventSink();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CMenuButtonProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_MENUBUTTON) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			CUIFButton *pUIObject = GetUIObjectMgr()->GetMenuButtonObj();

			if ((pUIObject != NULL) && pUIObject->IsVisible()) {
				RECT rc;

				pUIObject->GetRect( &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CMenuButtonProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIMenuButton *pObject;
	HRESULT           hr;

	pObject = new CCandUIMenuButton( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  E X T R A  C A N D I D A T E  P R O P E R T Y                         */
/*                                                                            */
/*============================================================================*/

/*   C  E X T R A  C A N D I D A T E  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CExtraCandidateProperty

------------------------------------------------------------------------------*/
CExtraCandidateProperty::CExtraCandidateProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  E X T R A  C A N D I D A T E  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CExtraCandidateProperty

------------------------------------------------------------------------------*/
CExtraCandidateProperty::~CExtraCandidateProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CExtraCandidateProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_EXTRACANDIDATE) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			CUIFCandListBase *pUIObject = GetUIObjectMgr()->GetExtraCandidateObj();

			if ((pUIObject != NULL) && pUIObject->IsVisible()) {
				RECT rc;

				pUIObject->GetRect( &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CExtraCandidateProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIExtraCandidate *pObject;
	HRESULT               hr;

	pObject = new CCandUIExtraCandidate( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  R A W  D A T A  P R O P E R T Y                              */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  R A W  D A T A  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandRawDataProperty

------------------------------------------------------------------------------*/
CCandRawDataProperty::CCandRawDataProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  C A N D  R A W  D A T A  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandRawDataProperty

------------------------------------------------------------------------------*/
CCandRawDataProperty::~CCandRawDataProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandRawDataProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_CANDRAWDATA) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			CUIFCandRawData *pUIObject = GetUIObjectMgr()->GetCandRawDataObj();

			if ((pUIObject != NULL) && pUIObject->IsVisible()) {
				RECT rc;

				pUIObject->GetRect( &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandRawDataProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIRawData *pObject;
	HRESULT        hr;

	pObject = new CCandUIRawData( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  T O O L  T I P  P R O P E R T Y                                       */
/*                                                                            */
/*============================================================================*/

/*   C  T O O L  T I P  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructror of CToolTipProperty

------------------------------------------------------------------------------*/
CToolTipProperty::CToolTipProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_STATUS, &lf );

	m_flags.fAllowEnable        = TRUE;
	m_flags.fAllowDisable       = TRUE;
	m_flags.fAllowIsEnabled     = TRUE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = FALSE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = FALSE;
	m_flags.fAllowSetFont       = TRUE;
	m_flags.fAllowGetFont       = TRUE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( FALSE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );
}


/*   ~  C  T O O L  T I P  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CToolTipProperty

------------------------------------------------------------------------------*/
CToolTipProperty::~CToolTipProperty( void )
{
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CToolTipProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUIToolTip *pObject;
	HRESULT        hr;

	pObject = new CCandUIToolTip( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  T I P  W I N D O W  P R O P E R T Y                          */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  T I P  W I N D O W  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandTipWindowProperty

------------------------------------------------------------------------------*/
CCandTipWindowProperty::CCandTipWindowProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	LOGFONTW lf;

	GetNonClientLogFont( NCFONT_STATUS, &lf );

	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = TRUE;
	m_flags.fAllowHide          = TRUE;
	m_flags.fAllowIsVisible     = TRUE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = FALSE;
	m_flags.fAllowGetToolTip    = FALSE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( &lf );
	m_propFont.SetOrientation( PROPFONTORT_DONTCARE );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	m_hWnd = NULL;

	//

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  C A N D  T I P  W I N D O W  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandTipWindowProperty

------------------------------------------------------------------------------*/
CCandTipWindowProperty::~CCandTipWindowProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   G E T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandTipWindowProperty::GetWindow( HWND *phWnd )
{
	if (phWnd == NULL) {
		return E_INVALIDARG;
	}

	*phWnd = m_hWnd;
	return (*phWnd != NULL) ? S_OK : E_FAIL;
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandTipWindowProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_CANDTIPWINDOW) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			if (GetUIObjectMgr()->GetCandTipWindowObj()) {
				RECT rc;

				m_hWnd = GetUIObjectMgr()->GetCandTipWindowObj()->GetWnd();

				GetWindowRect( m_hWnd, &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_hWnd = NULL;
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_hWnd = NULL;
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			RECT rc;

			GetWindowRect( m_hWnd, &rc );
			m_propPos.Set( rc.left, rc.top );
			m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandTipWindowProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICandTipWindow *pObject;
	HRESULT              hr;

	pObject = new CCandUICandTipWindow( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  T I P  B U T T O N  P R O P E R T Y                          */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  T I P  B U T T O N  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Constructor of CCandTipButtonProperty

------------------------------------------------------------------------------*/
CCandTipButtonProperty::CCandTipButtonProperty( CCandUIPropertyMgr *pPropMgr ) : CCandUIObjectProperty( pPropMgr )
{
	m_flags.fAllowEnable        = FALSE;
	m_flags.fAllowDisable       = FALSE;
	m_flags.fAllowIsEnabled     = FALSE;
	m_flags.fAllowShow          = FALSE;
	m_flags.fAllowHide          = FALSE;
	m_flags.fAllowIsVisible     = FALSE;
	m_flags.fAllowSetPosition   = FALSE;
	m_flags.fAllowGetPosition   = TRUE;
	m_flags.fAllowSetSize       = FALSE;
	m_flags.fAllowGetSize       = TRUE;
	m_flags.fAllowSetFont       = FALSE;
	m_flags.fAllowGetFont       = FALSE;
	m_flags.fAllowSetText       = FALSE;
	m_flags.fAllowGetText       = FALSE;
	m_flags.fAllowSetToolTip    = TRUE;
	m_flags.fAllowGetToolTip    = TRUE;

	m_propEnabled.Set( TRUE );
	m_propVisible.Set( TRUE );
	m_propFont.Set( NULL );
	m_propText.Set( NULL );
	m_propToolTip.Set( NULL );

	CCandUIObjectEventSink::InitEventSink( pPropMgr->GetCandidateUI()->GetUIObjectMgr() );
}


/*   ~  C  C A N D  T I P  B U T T O N  P R O P E R T Y   */
/*------------------------------------------------------------------------------

	Destructor of CCandTipButtonProperty

------------------------------------------------------------------------------*/
CCandTipButtonProperty::~CCandTipButtonProperty( void )
{
	CCandUIObjectEventSink::DoneEventSink();
}


/*   O N  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandTipButtonProperty::OnObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (obj != CANDUIOBJ_CANDTIPBUTTON) {
		return;
	}

	switch (event) {
		case CANDUIOBJEV_CREATED: {
			break;
		}

		case CANDUIOBJEV_DESTROYED: {
			m_propPos.Set( 0, 0 );
			m_propSize.Set( 0, 0 );
			break;
		}

		case CANDUIOBJEV_UPDATED: {
			CUIFButton *pUIObject = GetUIObjectMgr()->GetCandTipButtonObj();

			if ((pUIObject != NULL) && pUIObject->IsVisible()) {
				RECT rc;

				pUIObject->GetRect( &rc );
				m_propPos.Set( rc.left, rc.top );
				m_propSize.Set( rc.right - rc.left, rc.bottom - rc.top );
			}
			else {
				m_propPos.Set( 0, 0 );
				m_propSize.Set( 0, 0 );
			}
			break;
		}
	}
}


/*   C R E A T E  I N T E R F A C E  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandTipButtonProperty::CreateInterfaceObject( REFIID riid, void **ppvObj )
{
	CCandUICandTipButton *pObject;
	HRESULT              hr;

	pObject = new CCandUICandTipButton( this );
	if (pObject == NULL) {
		return E_OUTOFMEMORY;
	}

	hr = pObject->QueryInterface( riid, ppvObj );
	pObject->Release();

	return hr;
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  P R O P E R T Y  M G R                                  */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  P R O P E R T Y  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIPropertyMgr::CCandUIPropertyMgr( void )
{
	int i;

	m_pCandUI                 = NULL;
	m_pCandWindowProp         = NULL;
	m_pCandListBoxProp        = NULL;
	m_pCandStringProp         = NULL;
	m_pCandIndexProp          = NULL;
	m_pInlineCommentProp      = NULL;
	m_pPopupCommentWindowProp = NULL;
	m_pPopupCommentTitleProp  = NULL;
	m_pPopupCommentTextProp   = NULL;
	m_pMenuButtonProp         = NULL;
	m_pWindowCaptionProp      = NULL;
	m_pToolTipProp            = NULL;
	m_pExtraCandidateProp     = NULL;
	m_pCandRawDataProp        = NULL;
	m_pCandTipWindowProp      = NULL;
	m_pCandTipButtonProp      = NULL;

	for (i = 0; i < CANDUIPROPSINK_MAX; i++) {
		m_rgSink[i] = NULL;
	}
}


/*   ~  C  C A N D  U I  P R O P E R T Y  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIPropertyMgr::~CCandUIPropertyMgr( void )
{
	Uninitialize();
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyMgr::Initialize( CCandidateUI *pCandUI )
{
	m_pCandUI  = pCandUI;

	m_pCandWindowProp = new CCandWindowProperty( this );
	if (m_pCandWindowProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pCandListBoxProp = new CCandListBoxProperty( this );
	if (m_pCandListBoxProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pCandStringProp = new CCandStringProperty( this );
	if (m_pCandStringProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pCandIndexProp = new CCandIndexProperty( this );
	if (m_pCandIndexProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pInlineCommentProp = new CInlineCommentProperty( this );
	if (m_pInlineCommentProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pPopupCommentWindowProp = new CPopupCommentWindowProperty( this );
	if (m_pPopupCommentWindowProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pPopupCommentTitleProp = new CPopupCommentTitleProperty( this );
	if (m_pPopupCommentTitleProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pPopupCommentTextProp = new CPopupCommentTextProperty( this );
	if (m_pPopupCommentTextProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pMenuButtonProp = new CMenuButtonProperty( this );
	if (m_pMenuButtonProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pWindowCaptionProp = new CWindowCaptionProperty( this );
	if (m_pWindowCaptionProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pToolTipProp = new CToolTipProperty( this );
	if (m_pToolTipProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pExtraCandidateProp = new CExtraCandidateProperty( this );
	if (m_pExtraCandidateProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pCandRawDataProp = new CCandRawDataProperty( this );
	if (m_pCandRawDataProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pCandTipWindowProp = new CCandTipWindowProperty( this );
	if (m_pCandTipWindowProp == NULL) {
		return E_OUTOFMEMORY;
	}

	m_pCandTipButtonProp = new CCandTipButtonProperty( this );
	if (m_pCandTipButtonProp == NULL) {
		return E_OUTOFMEMORY;
	}

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDUIPROPSINK_MAX; i++) {
		Assert( m_rgSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyMgr::Uninitialize( void )
{
	if (m_pCandWindowProp != NULL) {
		delete m_pCandWindowProp;
		m_pCandWindowProp = NULL;
	}

	if (m_pCandListBoxProp != NULL) {
		delete m_pCandListBoxProp;
		m_pCandListBoxProp = NULL;
	}

	if (m_pCandStringProp != NULL) {
		delete m_pCandStringProp;
		m_pCandStringProp = NULL;
	}

	if (m_pCandIndexProp != NULL) {
		delete m_pCandIndexProp;
		m_pCandIndexProp = NULL;
	}

	if (m_pInlineCommentProp != NULL) {
		delete m_pInlineCommentProp;
		m_pInlineCommentProp = NULL;
	}

	if (m_pPopupCommentWindowProp != NULL) {
		delete m_pPopupCommentWindowProp;
		m_pPopupCommentWindowProp = NULL;
	}

	if (m_pPopupCommentTitleProp != NULL) {
		delete m_pPopupCommentTitleProp;
		m_pPopupCommentTitleProp = NULL;
	}

	if (m_pPopupCommentTextProp != NULL) {
		delete m_pPopupCommentTextProp;
		m_pPopupCommentTextProp = NULL;
	}

	if (m_pMenuButtonProp != NULL) {
		delete m_pMenuButtonProp;
		m_pMenuButtonProp = NULL;
	}

	if (m_pWindowCaptionProp != NULL) {
		delete m_pWindowCaptionProp;
		m_pWindowCaptionProp = NULL;
	}

	if (m_pToolTipProp != NULL) {
		delete m_pToolTipProp;
		m_pToolTipProp = NULL;
	}

	if (m_pExtraCandidateProp != NULL) {
		delete m_pExtraCandidateProp;
		m_pExtraCandidateProp = NULL;
	}

	if (m_pCandRawDataProp != NULL) {
		delete m_pCandRawDataProp;
		m_pCandRawDataProp = NULL;
	}

	if (m_pCandTipWindowProp != NULL) {
		delete m_pCandTipWindowProp;
		m_pCandTipWindowProp = NULL;
	}

	if (m_pCandTipButtonProp != NULL) {
		delete m_pCandTipButtonProp;
		m_pCandTipButtonProp = NULL;
	}

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDUIPROPSINK_MAX; i++) {
		Assert( m_rgSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyMgr::AdviseEventSink( CCandUIPropertyEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDUIPROPSINK_MAX; i++) {
		if (m_rgSink[i] == NULL) {
			m_rgSink[i] = pSink;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   U N A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyMgr::UnadviseEventSink( CCandUIPropertyEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDUIPROPSINK_MAX; i++) {
		if (m_rgSink[i] == pSink) {
			m_rgSink[i] = NULL;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   N O T I F Y  P R O P E R T Y  U P D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIPropertyMgr::NotifyPropertyUpdate( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )
{
	int i;

	if (m_pCandWindowProp) {
		m_pCandWindowProp->OnPropertyUpdated( prop, event );
	}

	if (m_pCandListBoxProp) {
		m_pCandListBoxProp->OnPropertyUpdated( prop, event );
	}

	if (m_pCandStringProp) {
		m_pCandStringProp->OnPropertyUpdated( prop, event );
	}

	if (m_pCandIndexProp) {
		m_pCandIndexProp->OnPropertyUpdated( prop, event );
	}

	if (m_pInlineCommentProp) {
		m_pInlineCommentProp->OnPropertyUpdated( prop, event );
	}

	if (m_pPopupCommentWindowProp) {
		m_pPopupCommentWindowProp->OnPropertyUpdated( prop, event );
	}

	if (m_pPopupCommentTitleProp) {
		m_pPopupCommentTitleProp->OnPropertyUpdated( prop, event );
	}

	if (m_pPopupCommentTextProp) {
		m_pPopupCommentTextProp->OnPropertyUpdated( prop, event );
	}

	if (m_pMenuButtonProp) {
		m_pMenuButtonProp->OnPropertyUpdated( prop, event );
	}

	if (m_pWindowCaptionProp) {
		m_pWindowCaptionProp->OnPropertyUpdated( prop, event );
	}

	if (m_pToolTipProp) {
		m_pToolTipProp->OnPropertyUpdated( prop, event );
	}

	if (m_pExtraCandidateProp) {
		m_pExtraCandidateProp->OnPropertyUpdated( prop, event );
	}

	if (m_pCandRawDataProp) {
		m_pCandRawDataProp->OnPropertyUpdated( prop, event );
	}

	if (m_pCandTipWindowProp) {
		m_pCandTipWindowProp->OnPropertyUpdated( prop, event );
	}

	if (m_pCandTipButtonProp) {
		m_pCandTipButtonProp->OnPropertyUpdated( prop, event );
	}

	for (i = 0; i < CANDUIPROPSINK_MAX; i++) {
		if (m_rgSink[i] != NULL) {
			m_rgSink[i]->OnPropertyUpdated( prop, event );
		}
	}
}


/*   G E T  O B J E C T   */
/*------------------------------------------------------------------------------

	

------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyMgr::GetObject( REFIID riid, void **ppvObj )
{
	CCandUIObjectProperty *pProperty = NULL;

	if (ppvObj == NULL) {
		return E_INVALIDARG;
	}

	// find property

	if (IsEqualGUID( riid, IID_ITfCandUICandWindow )) {
		pProperty = m_pCandWindowProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUICandListBox )) {
		pProperty = m_pCandListBoxProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUICandString )) {
		pProperty = m_pCandStringProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUICandIndex )) {
		pProperty = m_pCandIndexProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIInlineComment )) {
		pProperty = m_pInlineCommentProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIPopupCommentWindow )) {
		pProperty = m_pPopupCommentWindowProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIPopupCommentTitle )) {
		pProperty = m_pPopupCommentTitleProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIPopupCommentText )) {
		pProperty = m_pPopupCommentTextProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIMenuButton )) {
		pProperty = m_pMenuButtonProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUICaption )) {
		pProperty = m_pWindowCaptionProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIToolTip )) {
		pProperty = m_pToolTipProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIExtraCandidate )) {
		pProperty = m_pExtraCandidateProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUIRawData )) {
		pProperty = m_pCandRawDataProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUICandTipWindow )) {
		pProperty = m_pCandTipWindowProp;
	}

	if (IsEqualGUID( riid, IID_ITfCandUICandTipButton )) {
		pProperty = m_pCandTipButtonProp;
	}

	if (pProperty == NULL) {
		return E_FAIL;
	}

	// create interface object

	return pProperty->CreateInterfaceObject( riid, ppvObj );
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  P R O P E R T Y  E V E N T  S I N K                     */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  P R O P E R T Y  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIPropertyEventSink::CCandUIPropertyEventSink( void )
{
	m_pPropertyMgr = NULL;
}


/*   ~  C  C A N D  U I  P R O P E R T Y  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIPropertyEventSink::~CCandUIPropertyEventSink( void )
{
	Assert( m_pPropertyMgr == NULL );
	if (m_pPropertyMgr != NULL) {
		DoneEventSink();
	}
}


/*   I N I T  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyEventSink::InitEventSink( CCandUIPropertyMgr *pPropertyMgr )
{
	Assert( pPropertyMgr != NULL );
	Assert( m_pPropertyMgr == NULL );

	if (pPropertyMgr == NULL) {
		return E_INVALIDARG;
	}

	m_pPropertyMgr = pPropertyMgr;
	return m_pPropertyMgr->AdviseEventSink( this );
}


/*   D O N E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIPropertyEventSink::DoneEventSink( void )
{
	HRESULT hr;

	Assert( m_pPropertyMgr != NULL );
	if (m_pPropertyMgr == NULL) {
		return E_FAIL;
	}

	hr = m_pPropertyMgr->UnadviseEventSink( this );
	m_pPropertyMgr = NULL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candui.cpp ===
//
// candui.cpp
//

#include "private.h"
#include "globals.h"
#include "candui.h"
#include "wcand.h"
#include "immxutil.h"
#include "computil.h"
#include "candutil.h"
#include "candobj.h"
#include "msctfp.h"

//
// default key command definition
//

// key command definition in list style

const CANDUIKEYDATA rgKeyDefList[] =
{
/*
{ flag,								keydata,		command,					paramater }
    */
    { CANDUIKEY_VKEY,					VK_ESCAPE,		CANDUICMD_CANCEL,			0 },
    { CANDUIKEY_VKEY,					VK_RETURN,		CANDUICMD_COMPLETE,			0 },
    { CANDUIKEY_VKEY|CANDUIKEY_SHIFT,	VK_CONVERT,		CANDUICMD_MOVESELPREV,		0 },
    { CANDUIKEY_VKEY,					VK_CONVERT,		CANDUICMD_MOVESELNEXT,		0 },
    { CANDUIKEY_VKEY|CANDUIKEY_SHIFT,	VK_SPACE,		CANDUICMD_MOVESELPREV,		0 },
    { CANDUIKEY_VKEY,					VK_SPACE,		CANDUICMD_MOVESELNEXT,		0 },
    { CANDUIKEY_VKEY,					VK_UP,			CANDUICMD_MOVESELUP,		0 },	// horz only
    { CANDUIKEY_VKEY,					VK_DOWN,		CANDUICMD_MOVESELDOWN,		0 },	// horz only
    { CANDUIKEY_VKEY,					VK_LEFT,		CANDUICMD_MOVESELLEFT,		0 },	// vert only
    { CANDUIKEY_VKEY,					VK_RIGHT,		CANDUICMD_MOVESELRIGHT,		0 },	// vert only
    { CANDUIKEY_VKEY,					VK_PRIOR,		CANDUICMD_MOVESELPREVPG,	0 },
    { CANDUIKEY_VKEY,					VK_NEXT,		CANDUICMD_MOVESELNEXTPG,	0 },
    { CANDUIKEY_VKEY,					VK_HOME,		CANDUICMD_MOVESELFIRST,		0 },
    { CANDUIKEY_VKEY,					VK_END,			CANDUICMD_MOVESELLAST,		0 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'1',			CANDUICMD_SELECTLINE,		1 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'2',			CANDUICMD_SELECTLINE,		2 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'3',			CANDUICMD_SELECTLINE,		3 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'4',			CANDUICMD_SELECTLINE,		4 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'5',			CANDUICMD_SELECTLINE,		5 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'6',			CANDUICMD_SELECTLINE,		6 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'7',			CANDUICMD_SELECTLINE,		7 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'8',			CANDUICMD_SELECTLINE,		8 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'9',			CANDUICMD_SELECTLINE,		9 },
    { CANDUIKEY_VKEY|CANDUIKEY_NOSHIFT|CANDUIKEY_NOCTRL,	L'0',			CANDUICMD_SELECTEXTRACAND,	0 },
    { CANDUIKEY_VKEY,					VK_OEM_MINUS,	CANDUICMD_SELECTRAWDATA,	0 },
    { CANDUIKEY_VKEY,					VK_NUMPAD1,		CANDUICMD_SELECTLINE,		1 },
    { CANDUIKEY_VKEY,					VK_NUMPAD2,		CANDUICMD_SELECTLINE,		2 },
    { CANDUIKEY_VKEY,					VK_NUMPAD3,		CANDUICMD_SELECTLINE,		3 },
    { CANDUIKEY_VKEY,					VK_NUMPAD4,		CANDUICMD_SELECTLINE,		4 },
    { CANDUIKEY_VKEY,					VK_NUMPAD5,		CANDUICMD_SELECTLINE,		5 },
    { CANDUIKEY_VKEY,					VK_NUMPAD6,		CANDUICMD_SELECTLINE,		6 },
    { CANDUIKEY_VKEY,					VK_NUMPAD7,		CANDUICMD_SELECTLINE,		7 },
    { CANDUIKEY_VKEY,					VK_NUMPAD8,		CANDUICMD_SELECTLINE,		8 },
    { CANDUIKEY_VKEY,					VK_NUMPAD9,		CANDUICMD_SELECTLINE,		9 },
    { CANDUIKEY_VKEY,					VK_NUMPAD0,		CANDUICMD_SELECTEXTRACAND,	0 },
    { CANDUIKEY_VKEY,					VK_SUBTRACT,	CANDUICMD_SELECTRAWDATA,	0 },
    { CANDUIKEY_VKEY,					VK_APPS,		CANDUICMD_OPENCANDMENU,		0 },
};


// key command definition in row style

const CANDUIKEYDATA rgKeyDefRow[] =
{
/*
{ flag,								keydata,		command,					paramater }
    */
    { CANDUIKEY_VKEY,					VK_ESCAPE,		CANDUICMD_CANCEL,			0 },
    { CANDUIKEY_VKEY,					VK_RETURN,		CANDUICMD_CANCEL,			0 },
    { CANDUIKEY_VKEY,					VK_SPACE,		CANDUICMD_COMPLETE,			0 },	
    { CANDUIKEY_VKEY,					VK_UP,			CANDUICMD_MOVESELLEFT,		0 },	// horz only
    { CANDUIKEY_VKEY,					VK_DOWN,		CANDUICMD_MOVESELRIGHT,		0 },	// horz only
    { CANDUIKEY_VKEY,					VK_LEFT,		CANDUICMD_MOVESELUP,		0 },	// vert only
    { CANDUIKEY_VKEY,					VK_RIGHT,		CANDUICMD_MOVESELDOWN,		0 },	// vert only
    { CANDUIKEY_VKEY,					VK_PRIOR,		CANDUICMD_MOVESELPREVPG,	0 },
    { CANDUIKEY_VKEY,					VK_NEXT,		CANDUICMD_MOVESELNEXTPG,	0 },
    //	{ CANDUIKEY_CHAR,					L'1',			CANDUICMD_SELECTLINE,		1 },
    //	{ CANDUIKEY_CHAR,					L'2',			CANDUICMD_SELECTLINE,		2 },
    //	{ CANDUIKEY_CHAR,					L'3',			CANDUICMD_SELECTLINE,		3 },
    //	{ CANDUIKEY_CHAR,					L'4',			CANDUICMD_SELECTLINE,		4 },
    //	{ CANDUIKEY_CHAR,					L'5',			CANDUICMD_SELECTLINE,		5 },
    //	{ CANDUIKEY_CHAR,					L'6',			CANDUICMD_SELECTLINE,		6 },
    //	{ CANDUIKEY_CHAR,					L'7',			CANDUICMD_SELECTLINE,		7 },
    //	{ CANDUIKEY_CHAR,					L'8',			CANDUICMD_SELECTLINE,		8 },
    //	{ CANDUIKEY_CHAR,					L'9',			CANDUICMD_SELECTLINE,		9 },
    { CANDUIKEY_VKEY,					L'1',			CANDUICMD_SELECTLINE,		1 },
    { CANDUIKEY_VKEY,					L'2',			CANDUICMD_SELECTLINE,		2 },
    { CANDUIKEY_VKEY,					L'3',			CANDUICMD_SELECTLINE,		3 },
    { CANDUIKEY_VKEY,					L'4',			CANDUICMD_SELECTLINE,		4 },
    { CANDUIKEY_VKEY,					L'5',			CANDUICMD_SELECTLINE,		5 },
    { CANDUIKEY_VKEY,					L'6',			CANDUICMD_SELECTLINE,		6 },
    { CANDUIKEY_VKEY,					L'7',			CANDUICMD_SELECTLINE,		7 },
    { CANDUIKEY_VKEY,					L'8',			CANDUICMD_SELECTLINE,		8 },
    { CANDUIKEY_VKEY,					L'9',			CANDUICMD_SELECTLINE,		9 },
    { CANDUIKEY_VKEY,					VK_NUMPAD1,		CANDUICMD_SELECTLINE,		1 },
    { CANDUIKEY_VKEY,					VK_NUMPAD2,		CANDUICMD_SELECTLINE,		2 },
    { CANDUIKEY_VKEY,					VK_NUMPAD3,		CANDUICMD_SELECTLINE,		3 },
    { CANDUIKEY_VKEY,					VK_NUMPAD4,		CANDUICMD_SELECTLINE,		4 },
    { CANDUIKEY_VKEY,					VK_NUMPAD5,		CANDUICMD_SELECTLINE,		5 },
    { CANDUIKEY_VKEY,					VK_NUMPAD6,		CANDUICMD_SELECTLINE,		6 },
    { CANDUIKEY_VKEY,					VK_NUMPAD7,		CANDUICMD_SELECTLINE,		7 },
    { CANDUIKEY_VKEY,					VK_NUMPAD8,		CANDUICMD_SELECTLINE,		8 },
    { CANDUIKEY_VKEY,					VK_NUMPAD9,		CANDUICMD_SELECTLINE,		9 },
    { CANDUIKEY_CHAR,					L'-',			CANDUICMD_MOVESELPREVPG,	0 },
    { CANDUIKEY_CHAR,					L'_',			CANDUICMD_MOVESELPREVPG,	0 },
    { CANDUIKEY_CHAR,					L'[',			CANDUICMD_MOVESELPREVPG,	0 },
    { CANDUIKEY_CHAR,					L'+',			CANDUICMD_MOVESELNEXTPG,	0 },
    { CANDUIKEY_CHAR,					L'=',			CANDUICMD_MOVESELNEXTPG,	0 },
    { CANDUIKEY_CHAR,					L']',			CANDUICMD_MOVESELNEXTPG,	0 },
    { CANDUIKEY_VKEY,					VK_APPS,		CANDUICMD_OPENCANDMENU,		0 },
};


//
// rule definitions
//

typedef struct _RULEDEF
{
    LPCWSTR			szRuleName;
    CANDUICOMMAND	cmd;
    UINT			uiParam;
} RULEDEF;


// rule definition in normal state

const RULEDEF rgRuleNorm[] =
{
/*
{ "rule name",		command,					paramater }
    */
    { L"Finalize",		CANDUICMD_COMPLETE,			0 },
    { L"Cancel",		CANDUICMD_CANCEL,			0 },
    { L"Next",			CANDUICMD_MOVESELNEXT,		0 },
    { L"Prev",			CANDUICMD_MOVESELPREV,		0 },
    { L"First",			CANDUICMD_MOVESELFIRST,		0 },
    { L"Last",			CANDUICMD_MOVESELLAST,		0 },
    { L"Menu",			CANDUICMD_OPENCANDMENU,		0 },
    { L"Select1",		CANDUICMD_SELECTLINE,		1 },
    { L"Select2",		CANDUICMD_SELECTLINE,		2 },
    { L"Select3",		CANDUICMD_SELECTLINE,		3 },
    { L"Select4",		CANDUICMD_SELECTLINE,		4 },
    { L"Select5",		CANDUICMD_SELECTLINE,		5 },
    { L"Select6",		CANDUICMD_SELECTLINE,		6 },
    { L"Select7",		CANDUICMD_SELECTLINE,		7 },
    { L"Select8",		CANDUICMD_SELECTLINE,		8 },
    { L"Select9",		CANDUICMD_SELECTLINE,		9 },
    { L"PageDown",      CANDUICMD_MOVESELNEXTPG,    0 },
    { L"PageUp",        CANDUICMD_MOVESELPREVPG,    0 },
};


//
//
//

class CTfCandidateUIContextOwner : public ITfCandidateUIContextOwner
{
public:
    CTfCandidateUIContextOwner( CCandidateUI *pCandUI );
    virtual ~CTfCandidateUIContextOwner( void );

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );

    //
    // ITfCandidateUIContextOwner methods
    //
    STDMETHODIMP ProcessCommand(CANDUICOMMAND cmd, INT iParam);
    STDMETHODIMP TestText(BSTR bstr, BOOL *pfHandles);

protected:
    ULONG        m_cRef;
    CCandidateUI *m_pCandUI;
};


/*============================================================================*/
/*                                                                            */
/*   C  C A N D I D A T E  U I                                                */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D I D A T E  U I   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
CCandidateUI::CCandidateUI()
{
    Dbg_MemSetThisName(TEXT("CCandidateUI"));
    
    TF_CreateThreadMgr(&_ptim);
    m_hWndParent                = NULL;
    m_pCandWnd                  = NULL;
    
    m_pic                       = NULL;
    m_pdim                      = NULL;
    m_picParent                 = NULL;
    m_pTargetRange              = NULL;
    m_codepage                  = GetACP();
    
    m_fContextEventSinkAdvised  = FALSE;
    m_dwCookieContextOwnerSink  = 0;
    m_dwCookieContextKeySink    = 0;
    
    m_fTextEventSinkAdvised     = FALSE;
    m_dwCookieTextEditSink      = 0;
    m_dwCookieTextLayoutSink    = 0;
    m_dwCookieTransactionSink   = 0;
    
    m_pTextEventSink            = NULL;
    
    m_pCandUIKeyTable           = NULL;
    
    m_fInTransaction            = FALSE;
    m_pSelectionStart           = NULL;
    m_pSelectionCur             = NULL;
    
    m_fInCallback               = FALSE;
    m_pSpTask                   = NULL;
    
    // create candidate list manager, function manager, functions
    
    CCandListMgr::Initialize( this );
    CCandUIObjectMgr::Initialize( this );
    CCandUIPropertyMgr::Initialize( this );
    CCandUICompartmentMgr::Initialize( this );
    CCandUIFunctionMgr::Initialize( this );
    CCandUIExtensionMgr::Initialize( this );
}


/*   ~ C  C A N D I D A T E  U I   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
CCandidateUI::~CCandidateUI()
{
//  this call was for the case that CandidateUI was released wihtout 
//  CloseCandidateUI() call, but it should not happn (because it will be 
//  referenced by event sink or interfnal objects by OpenCandidateUI(), so 
//  ref count nevet be zero unless CloseCandidateUI() call...

    // CloseCandidateUIProc();
    
    //
    
    SafeReleaseClear( m_pCandUIKeyTable );
    
    //
    
    CCandUIExtensionMgr::Uninitialize();
    CCandUIFunctionMgr::Uninitialize();
    CCandUICompartmentMgr::Uninitialize();
    CCandUIPropertyMgr::Uninitialize();
    CCandUIObjectMgr::Uninitialize();
    CCandListMgr::Uninitialize();
    
    // remove ref to this in TLS
    
    SafeRelease( _ptim );
    SafeRelease( m_pTargetRange );
    DoneTextEventSinks( m_picParent );
    ClearSelectionCur();
    ClearWndCand();
    
    // release speech
    
    if(m_pSpTask) {
        delete m_pSpTask;
    }
}


/*   E N D  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::EndCandidateList()
{
    DoneContextEventSinks( m_pic );
    ClearCompartment( m_tidClient, m_pic, GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXTOWNER, FALSE );
    
    DoneTextEventSinks( m_picParent );
    ClearSelectionCur();
    
    SafeReleaseClear( m_pic );
    SafeReleaseClear( m_pTargetRange );
    SafeReleaseClear( m_pCandUIKeyTable );
    
    if (m_pdim) {
        m_pdim->Pop(0);
        m_pdim->Release();
        m_pdim = NULL;
        
        SafeRelease( m_picParent );
    }
}


/*   S E T  C L I E N T  I D   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::SetClientId( TfClientId tid )
{
    m_tidClient = tid;
    return S_OK;
}


/*   O P E N  C A N D I D A T E  U I   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::OpenCandidateUI( HWND hWndParent, ITfDocumentMgr *pdim, TfEditCookie ec, ITfRange *pRange )
{
    ITfInputProcessorProfiles *pProfile;
    ITfRange *pSelection = NULL;
    HRESULT hr = E_FAIL;
    
    Assert(!m_pic);
    Assert(!m_pdim);
    
    // sanity check
    
    if ((pdim == NULL) || (pRange == NULL)) {
        return E_INVALIDARG;
    }
    
    // check if candidate list has been set
    
    if (GetCandListMgr()->GetCandList() == NULL) {
        return E_FAIL;
    }
    
    // fail when it's opening candidate window already
    
    if (m_pCandWnd != NULL) {
        return E_FAIL;
    }
    
    // ensure that speech is enabled
    
    // BUGBUG - THIS IS TOO LATE TO ENSURE ENGINE IS FORCED TO SYNC VIA A RECOSTATE(INACTIVE) CALL.
    EnsureSpeech();
    
    //
    //
    //
    
    m_pdim = pdim;
    m_pdim->AddRef();
    
    // store current top IC
    
    GetTopIC( pdim, &m_picParent );
    
    //
    // create candidate window
    //
    
    ClearWndCand();
    if (CreateCandWindowObject( m_picParent, &m_pCandWnd ) == S_OK) {
        BOOL  fClipped;
        RECT  rc;
        
        SetCompartmentDWORD( m_tidClient, m_picParent, GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW, 0x00000001, FALSE );

        m_pCandWnd->Initialize();
        
        // set target clause poisition
        
        GetTextExtInActiveView( ec, pRange, &rc, &fClipped );
        m_pCandWnd->SetTargetRect( &rc, fClipped );
        
        // initialize candidate list
        
        m_pCandWnd->InitCandidateList();
        
        // create window
        
        m_pCandWnd->CreateWnd( m_hWndParent );
        
        hr = S_OK;
    }
    
    //
    // create context for CandidteUI
    //
    
    SafeReleaseClear( m_pic );
    if (SUCCEEDED(hr)) {
        TfEditCookie ecTmp;
        
        // create context
        
        hr = pdim->CreateContext( m_tidClient, 0, NULL, &m_pic, &ecTmp );
        
        // disable keyboard while candidate UI open
        
        if (SUCCEEDED(hr)) {
            SetCompartmentDWORD( m_tidClient, m_pic, GUID_COMPARTMENT_KEYBOARD_DISABLED,     0x00000001, FALSE );
            SetCompartmentDWORD( m_tidClient, m_pic, GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXT, 0x00000001, FALSE );
        }
        
        // create context owner instance

        if (SUCCEEDED(hr)) {
            CTfCandidateUIContextOwner *pCxtOwner;

            pCxtOwner = new CTfCandidateUIContextOwner( this );
            if (pCxtOwner == NULL) {
                hr = E_OUTOFMEMORY;
            }
            else {
                SetCompartmentUnknown( m_tidClient, m_pic, GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXTOWNER, (IUnknown*)pCxtOwner );
            }
        }

        // init context event sinks
        
        if (SUCCEEDED(hr)) {
            hr = InitContextEventSinks( m_pic );
        }
        
        // push context
        
        if (SUCCEEDED(hr)) {
            hr = pdim->Push( m_pic );
        }
    }
    
    //
    // cleanup all when failed
    //
    
    if (FAILED(hr)) {
        // cleanup context
        
        if (m_pic != NULL) {
            DoneContextEventSinks( m_pic );
            ClearCompartment( m_tidClient, m_pic, GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXTOWNER, FALSE );
            SafeReleaseClear( m_pic );
        }
        
        // cleanup candidate window
        
        if (m_pCandWnd != NULL) {
            m_pCandWnd->DestroyWnd();
            ClearWndCand();
        }

        // release objects
        
        SafeReleaseClear( m_picParent );
        SafeReleaseClear( m_pdim );
        
        return hr;
    }
    
    // 
    // initialize miscs
    //
    
    // get current codepage from current assembly
    
    m_codepage = GetACP();
    if (SUCCEEDED(CoCreateInstance( CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, IID_ITfInputProcessorProfiles, (void **)&pProfile ))) {
        LANGID langid;
        char   szCpg[ 16 ];
        
        if (pProfile->GetCurrentLanguage( &langid ) == S_OK) {
            if (GetLocaleInfo( MAKELCID(langid, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szCpg, ARRAYSIZE(szCpg) ) != 0) {
                m_codepage = atoi( szCpg );
            }
        }
        pProfile->Release();
    }

    // get key table
    
    SafeRelease( m_pCandUIKeyTable );
    m_pCandUIKeyTable = GetKeyTableProc( m_picParent );
    
    // make copy target range
    
    pRange->Clone( &m_pTargetRange );
    
    // store selection first
    
    ClearSelectionCur();
    if (GetSelectionSimple( ec, m_picParent, &pSelection ) == S_OK) {
        SetSelectionCur( pSelection );
        SafeRelease( pSelection );
    }
    
    // init text event sinks
    
    DoneTextEventSinks( m_picParent );
    InitTextEventSinks( m_picParent );
    
    //
    // show candidate window at last
    //
    
    m_pCandWnd->Show( GetPropertyMgr()->GetCandWindowProp()->IsVisible() );
    m_pCandWnd->UpdateAllWindow();
    
    // notify initial seletion
    
    NotifySelectCand( GetCandListMgr()->GetCandList()->GetSelection() );
    
    return hr;
}


/*   C L O S E  C A N D I D A T E  U I   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::CloseCandidateUI( void )
{
    HRESULT hr;

    // Windows#502340
    // CandidateUI will be released during DestroyWindow().  As result, 
    // ref count will be zero and instance will be disposed during closeing UI.
    // prevent from it, keep one refcount until closing process will finished.

    AddRef();
    hr = CloseCandidateUIProc();
    Release();

    return hr;
}


/*   S E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::SetCandidateList( ITfCandidateList *pCandList )
{
    // release before change candidate list
    
    GetCandListMgr()->ClearCandiateList();
    
    // set new candidate list
    
    return GetCandListMgr()->SetCandidateList( pCandList );
}


/*   S E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::SetSelection( ULONG nIndex )
{
    HRESULT hr;
    int iCandItem;
    
    // check if candidate list has been set
    
    if (GetCandListMgr()->GetCandList() == NULL) {
        return E_FAIL;
    }
    
    // map index to icanditem
    
    hr = GetCandListMgr()->GetCandList()->MapIndexToIItem( nIndex, &iCandItem );
    if (FAILED(hr)) {
        Assert( FALSE );
        return hr;
    }
    
    return GetCandListMgr()->SetSelection( iCandItem, NULL /* no cand function */ );
}


/*   G E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::GetSelection( ULONG *pnIndex )
{
    HRESULT hr;
    int iCandItem;
    ULONG nIndex;
    
    if (pnIndex == NULL) {
        return E_INVALIDARG;
    }
    
    // check if candidate list has been set
    
    if (GetCandListMgr()->GetCandList() == NULL) {
        return E_FAIL;
    }
    
    iCandItem = GetCandListMgr()->GetCandList()->GetSelection();
    
    hr = GetCandListMgr()->GetCandList()->MapIItemToIndex( iCandItem, &nIndex );
    if (FAILED(hr)) {
        Assert( FALSE );
        return hr;
    }
    
    *pnIndex = nIndex;
    return S_OK;
}


/*   S E T  T A R G E T  R A N G E   */
/*------------------------------------------------------------------------------

  Set target range
  Memo: This method works while candidate UI is opened.
  
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::SetTargetRange( ITfRange *pRange )
{
    CEditSession *pes;
    
    if (pRange == NULL) {
        return E_FAIL;
    }
    
    if (m_pCandWnd == NULL) {
        return E_FAIL;
    }
    
    SafeReleaseClear( m_pTargetRange );
    pRange->Clone( &m_pTargetRange );
    
    // move candidate window
    
    if (pes = new CEditSession( EditSessionCallback )) {
        HRESULT hr;
        
        pes->_state.u      = ESCB_RESETTARGETPOS;
        pes->_state.pv     = this;
        pes->_state.wParam = 0;
        pes->_state.pRange = m_pTargetRange;
        pes->_state.pic    = m_picParent;
        
        m_picParent->RequestEditSession( m_tidClient, pes, TF_ES_READ | TF_ES_SYNC, &hr );
        
        pes->Release();
    }
    
    return S_OK;
}


/*   G E T  T A R G E T  R A N G E   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::GetTargetRange( ITfRange **ppRange )
{
    if (m_pTargetRange == NULL) {
        return E_FAIL;
    }
    
    Assert( ppRange != NULL );
    return m_pTargetRange->Clone( ppRange );
}


/*   G E T  U I  O B J E C T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::GetUIObject( REFIID riid, IUnknown **ppunk )
{
    return GetPropertyMgr()->GetObject( riid, (void **)ppunk );
}


/*   G E T  F U N C T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::GetFunction( REFIID riid, IUnknown **ppunk )
{
    if (ppunk == NULL) {
        return E_INVALIDARG;
    }
    
    // extension manager
    
    if (IsEqualGUID( riid, IID_ITfCandUIFnExtension )) {
        CCandUIFnExtension *pObject;
        HRESULT            hr;
        
        pObject = new CCandUIFnExtension( this, GetExtensionMgr() );
        if (pObject == NULL) {
            return E_OUTOFMEMORY;
        }
        
        hr = pObject->QueryInterface( riid, (void **)ppunk );
        pObject->Release();
        
        return hr;
    }
    
    // key config
    
    if (IsEqualGUID( riid, IID_ITfCandUIFnKeyConfig )) {
        CCandUIFnKeyConfig *pObject;
        HRESULT            hr;
        
        pObject = new CCandUIFnKeyConfig( this );
        if (pObject == NULL) {
            return E_OUTOFMEMORY;
        }
        
        hr = pObject->QueryInterface( riid, (void **)ppunk );
        pObject->Release();
        
        return hr;
    }
    
    // UI config
    
    if (IsEqualGUID( riid, IID_ITfCandUIFnUIConfig )) {
        CCandUIFnUIConfig *pObject;
        HRESULT           hr;
        
        pObject = new CCandUIFnUIConfig( this );
        if (pObject == NULL) {
            return E_OUTOFMEMORY;
        }
        
        hr = pObject->QueryInterface( riid, (void **)ppunk );
        pObject->Release();
        
        return hr;
    }
    
    // regular functions
    
    return GetFunctionMgr()->GetObject( riid, (void **)ppunk );
}


/*   P R O C E S S  C O M M A N D   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
STDAPI CCandidateUI::ProcessCommand( CANDUICOMMAND cmd, INT iParam )
{
    //
    
    if (cmd == CANDUICMD_NONE) {
        return E_INVALIDARG;
    }
    
    if (m_pCandWnd == NULL) {
        return E_FAIL;
    }
    
    return m_pCandWnd->ProcessCommand( cmd, iParam );
}


/*   C L O S E  C A N D I D A T E  U  I  P R O C   */
/*------------------------------------------------------------------------------

	close candidate u i proc

------------------------------------------------------------------------------*/
HRESULT CCandidateUI::CloseCandidateUIProc( void )
{
    if (m_picParent && m_pCandWnd) {
        SetCompartmentDWORD( m_tidClient, m_picParent, GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW, 0x00000000, FALSE );
    }

    if (m_pCandWnd) {
        m_pCandWnd->DestroyWnd();
        ClearWndCand();
        EndCandidateList();
    }
    
    GetCandListMgr()->ClearCandiateList();
    
    if (m_pSpTask)
        m_pSpTask->_Activate(FALSE);

    return S_OK;
}

//
// key config function methods
//

/*   S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::SetKeyTable( ITfContext *pic, ITfCandUIKeyTable *pCandUIKeyTable )
{
    HRESULT hr;
    CCandUIKeyTable *pCandUIKeyTableCopy;
    
    if ((pic == NULL) || (pCandUIKeyTable == NULL)) {
        return E_INVALIDARG;
    }
    
    if (GetCompartmentMgr() == NULL) {
        return E_FAIL;
    }
    
    // store copy of key table to input context
    
    pCandUIKeyTableCopy = new CCandUIKeyTable();
    if (pCandUIKeyTableCopy == NULL) {
        return E_OUTOFMEMORY;
    }
    
    hr = pCandUIKeyTableCopy->SetKeyTable( pCandUIKeyTable );
    if (FAILED( hr )) {
        pCandUIKeyTableCopy->Release();
        return hr;
    }
    
    hr = GetCompartmentMgr()->SetKeyTable( pic, pCandUIKeyTableCopy );
    if (FAILED( hr )) {
        pCandUIKeyTableCopy->Release();
        return hr;
    }
    pCandUIKeyTableCopy->Release();
    
    // reload key table if exist
    
    // REVIEW: KOJIW: If we support changing keytable of candidate UI in other IC,
    // need to do this in compartment event sink.
    
    if (m_pCandUIKeyTable != NULL) {
        m_pCandUIKeyTable->Release();
        
        Assert( m_picParent != NULL );
        m_pCandUIKeyTable = GetKeyTableProc( m_picParent );
    }
    
    return S_OK;
}


/*   G E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT  CCandidateUI::GetKeyTable( ITfContext *pic, ITfCandUIKeyTable **ppCandUIKeyTable)
{
    if ((pic == NULL) || (ppCandUIKeyTable == NULL)) {
        return E_INVALIDARG;
    }
    
    // load key table from input context
    
    *ppCandUIKeyTable = GetKeyTableProc( pic );
    return (*ppCandUIKeyTable != NULL) ? S_OK : E_FAIL;
}


/*   R E S E T  K E Y  T A B L E   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::ResetKeyTable( ITfContext *pic )
{
    HRESULT hr;
    
    if (pic == NULL) {
        return E_INVALIDARG;
    }
    
    if (GetCompartmentMgr() == NULL) {
        return E_FAIL;
    }
    
    hr = GetCompartmentMgr()->ClearKeyTable( pic );
    if (FAILED( hr )) {
        return hr;
    }
    
    // reload key table if exist
    
    if (m_pCandUIKeyTable != NULL) {
        m_pCandUIKeyTable->Release();
        
        Assert( m_picParent != NULL );
        m_pCandUIKeyTable = GetKeyTableProc( m_picParent );
    }
    
    return S_OK;
}


//
// UI config function methods
//

/*   S E T  U I  S T Y L E   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::SetUIStyle( ITfContext *pic, CANDUISTYLE style )
{
    HRESULT hr = S_OK;
    
    if (pic == NULL) {
        return E_INVALIDARG;
    }
    
    if (GetCompartmentMgr() == NULL) {
        return E_FAIL;
    }
    
    // store ui style to input context
    
    GetCompartmentMgr()->SetUIStyle( pic, style );
    
    // rebuild candidate window
    
    // REVIEW: KOJIW: If we support changing ui style of candidate UI in other IC,
    // need to do this in compartment event sink.
    
    if ((m_picParent == pic) && (m_pCandWnd != NULL)) {
        // destory candidate window object
        
        m_pCandWnd->DestroyWnd();
        ClearWndCand();
        
        // create and initialize window object
        
        hr = CreateCandWindowObject( m_picParent, &m_pCandWnd );
        if (SUCCEEDED(hr)) {
            hr = InitCandWindow();
        }
    }
    
    return hr;
}


/*   G E T  U I  S T Y L E   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetUIStyle( ITfContext *pic, CANDUISTYLE *pstyle )
{
    if ((pic == NULL) || (pstyle == NULL)) {
        return E_INVALIDARG;
    }
    
    if (GetCompartmentMgr() == NULL) {
        return E_FAIL;
    }
    
    if (FAILED( GetCompartmentMgr()->GetUIStyle( pic, pstyle ))) {
        *pstyle = CANDUISTY_LIST;
    }
    
    return S_OK;
}


/*   S E T  U I  O P T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::SetUIOption( ITfContext *pic, DWORD dwOption )
{
    HRESULT hr = S_OK;
    
    if (pic == NULL) {
        return E_INVALIDARG;
    }
    
    if (GetCompartmentMgr() == NULL) {
        return E_FAIL;
    }
    
    // store ui style to input context
    
    GetCompartmentMgr()->SetUIOption( pic, dwOption );
    
    // rebuild candidate window
    
    // REVIEW: KOJIW: If we support changing ui style of candidate UI in other IC,
    // need to do this in compartment event sink.
    
    if ((m_picParent == pic) && (m_pCandWnd != NULL)) {
        // destory candidate window object
        
        m_pCandWnd->DestroyWnd();
        ClearWndCand();
        
        // create and initialize window object
        
        hr = CreateCandWindowObject( m_picParent, &m_pCandWnd );
        if (SUCCEEDED(hr)) {
            hr = InitCandWindow();
        }
    }
    
    return hr;
}


/*   G E T  U I  O P T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetUIOption( ITfContext *pic, DWORD *pdwOption )
{
    if ((pic == NULL) || (pdwOption == NULL)) {
        return E_INVALIDARG;
    }
    
    if (GetCompartmentMgr() == NULL) {
        return E_FAIL;
    }
    
    if (FAILED( GetCompartmentMgr()->GetUIOption( pic, pdwOption ))) {
        *pdwOption = 0;
    }
    
    return S_OK;
}


//
// callback functions
//

/*   I N I T  C O N T E X T  E V E N T  S I N K S   */
/*------------------------------------------------------------------------------

  initialize sinks for input context events
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::InitContextEventSinks( ITfContext *pic )
{
    HRESULT hr = E_FAIL;
    ITfSource *pSource = NULL;
    
    Assert( pic == m_picParent );
    Assert( !m_fContextEventSinkAdvised );
    
    m_fContextEventSinkAdvised = FALSE;
    if (pic->QueryInterface( IID_ITfSource, (void **)&pSource) == S_OK) {
        if (FAILED(pSource->AdviseSink( IID_ITfContextOwner, (ITfContextOwner *)this, &m_dwCookieContextOwnerSink ))) {
            pSource->Release();
            return hr;
        }
        
        if (FAILED(pSource->AdviseSink( IID_ITfContextKeyEventSink, (ITfContextKeyEventSink *)this, &m_dwCookieContextKeySink ))) {
            pSource->UnadviseSink( m_dwCookieContextOwnerSink );
            pSource->Release();
            return hr;
        }
        pSource->Release();
        
        m_fContextEventSinkAdvised = TRUE;
        hr = S_OK;
    }
    
    // advise text event sink for own IC
    
    // NOTE: This is a temporary fix for Satori#3644 (Cicero#3407) to handle 
    // a text event from HW Tip.  So the detect logic is very tiny (it just 
    // handles half-width alphanumeric numbers).  In the next version of Cicero, 
    // we will use commanding feature to do same thing...
    // (related functions: TextEventCallback, HandleTextDeltas)
    
    m_pTextEventSink = new CTextEventSink( TextEventCallback, this );
    if (m_pTextEventSink != NULL) {
        m_pTextEventSink->_Advise( pic, ICF_TEXTDELTA );
    }
    
    return hr;
}


/*   D O N E  C O N T E X T  E V E N T  S I N K S   */
/*------------------------------------------------------------------------------

  uninitialize sinks for input context events
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::DoneContextEventSinks( ITfContext *pic )
{
    HRESULT hr = E_FAIL;
    ITfSource *pSource;
    
    Assert( pic == m_picParent );
    
    // unadvise text event sink for own IC
    
    if (m_pTextEventSink != NULL) {
        m_pTextEventSink->_Unadvise();
        SafeReleaseClear( m_pTextEventSink );
    }
    
    if (!m_fContextEventSinkAdvised) {
        return S_OK;
    }
    
    if (pic->QueryInterface( IID_ITfSource, (void **)&pSource) == S_OK) {
        pSource->UnadviseSink( m_dwCookieContextOwnerSink );
        pSource->UnadviseSink( m_dwCookieContextKeySink );
        pSource->Release();
        
        m_fContextEventSinkAdvised = FALSE;
        hr = S_OK;
    }
    
    return hr;
}


/*   G E T  A  C  P  F R O M  P O I N T   */
/*------------------------------------------------------------------------------

  Get acp from point 
  (ITfContextOwner method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetACPFromPoint( const POINT *pt, DWORD dwFlags, LONG *pacp )
{
    return E_FAIL;
}


/*   G E T  S C R E E N  E X T   */
/*------------------------------------------------------------------------------

  Get screen extent of context
  (ITfContextOwner method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetScreenExt( RECT *prc )
{
    return E_FAIL;
}


/*   G E T  T E X T  E X T   */
/*------------------------------------------------------------------------------

  Get text externt of context
  (ITfContextOwner method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetTextExt( LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped )
{
    return E_FAIL;
}


/*   G E T  S T A T U S   */
/*------------------------------------------------------------------------------

  Get status of context
  (ITfContextOwner method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetStatus( TF_STATUS *pdcs )
{
    if (pdcs == NULL) {
        return E_POINTER;
    }
    
    memset(pdcs, 0, sizeof(*pdcs));
    pdcs->dwDynamicFlags = 0;
    pdcs->dwStaticFlags  = 0;
    
    return S_OK;
}


/*   G E T  W N D   */
/*------------------------------------------------------------------------------

  Get window of context
  (ITfContextOwner method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetWnd( HWND *phwnd )
{
    if (phwnd == NULL) {
        return E_POINTER;
    }
    
    *phwnd = NULL;
    if (m_pCandWnd != NULL) {
        *phwnd = m_pCandWnd->GetWnd();
    }
    
    return S_OK;
}


/*   G E T  A T T R I B U T E   */
/*------------------------------------------------------------------------------

  Get attribute of context
  (ITfContextOwner method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::GetAttribute( REFGUID rguidAttribute, VARIANT *pvarValue )
{
    return E_NOTIMPL;
}


/*   O N  K E Y  D O W N   */
/*------------------------------------------------------------------------------

  event sink for key down event
  (ITfContextKeyEventSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnKeyDown( WPARAM wParam, LPARAM lParam, BOOL *pfEaten )
{
    return OnKeyEvent( ICO_KEYDOWN, wParam, lParam, pfEaten );
}


/*   O N  K E Y  U P   */
/*------------------------------------------------------------------------------

  event sink for key up event
  (ITfContextKeyEventSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnKeyUp( WPARAM wParam, LPARAM lParam, BOOL *pfEaten )
{
    return OnKeyEvent( ICO_KEYUP, wParam, lParam, pfEaten );
}


/*   O N  T E S T  K E Y  D O W N   */
/*------------------------------------------------------------------------------

  event sink for key down testing event
  (ITfContextKeyEventSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnTestKeyDown( WPARAM wParam, LPARAM lParam, BOOL *pfEaten )
{
    return OnKeyEvent( ICO_TESTKEYDOWN, wParam, lParam, pfEaten );
}


/*   O N  T E S T  K E Y  U P   */
/*------------------------------------------------------------------------------

  event sink for key up testing event
  (ITfContextKeyEventSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnTestKeyUp( WPARAM wParam, LPARAM lParam, BOOL *pfEaten )
{
    return OnKeyEvent( ICO_TESTKEYUP, wParam, lParam, pfEaten );
}


/*   T E X T  E V E N T  C A L L B A C K   */
/*------------------------------------------------------------------------------

  text event (for own IC) callback function
  (static function)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::TextEventCallback( UINT uCode, VOID *pv, VOID *pvData )
{
    HRESULT      hr;
    CCandidateUI *pCandUI;
    
    // 
    
    pCandUI = (CCandidateUI *)pv;
    Assert( pCandUI != NULL );
    
    // ignore event of myself
    
    if (uCode == ICF_TEXTDELTA) {
        TESENDEDIT    *pTESEndEdit = (TESENDEDIT*)pvData;
        IEnumTfRanges *pEnumRanges;
        
        if (SUCCEEDED(pTESEndEdit->pEditRecord->GetTextAndPropertyUpdates( TF_GTP_INCL_TEXT, NULL, 0, &pEnumRanges ))) {
            CEditSession *pes;
            
            if (pes = new CEditSession(EditSessionCallback)) {
                pes->_state.u   = ESCB_TEXTEVENT;
                pes->_state.pv  = (void *)pCandUI;
                pes->_state.pic = pCandUI->m_pic;
                pes->_state.pv1 = pEnumRanges;     // DONT FORGET TO RELESE IT IN EDIT SESSION!!!
                
                pCandUI->m_pic->RequestEditSession( 0, pes, TF_ES_READ | TF_ES_SYNC, &hr );
                
                pes->Release();
            }
            else {
                pEnumRanges->Release();
            }
        }
    }
    
    return S_OK;
}


//
// text event sink functions
//

/*   I N I T  T E X T  E V E N T  S I N K S   */
/*------------------------------------------------------------------------------

  initialize sinks for text events
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::InitTextEventSinks( ITfContext *pic )
{
    HRESULT hr = E_FAIL;
    ITfSource *pSource = NULL;
    
    Assert( pic == m_picParent );
    Assert( !m_fTextEventSinkAdvised );
    Assert( !IsInEditTransaction() );
    
    m_fTextEventSinkAdvised = FALSE;
    LeaveEditTransaction();
    
    if (pic->QueryInterface( IID_ITfSource, (void **)&pSource) == S_OK) {
        if (FAILED(pSource->AdviseSink( IID_ITfTextEditSink, (ITfTextEditSink *)this, &m_dwCookieTextEditSink ))) {
            pSource->Release();
            return hr;
        }
        
        if (FAILED(pSource->AdviseSink( IID_ITfTextLayoutSink, (ITfTextLayoutSink *)this, &m_dwCookieTextLayoutSink ))) {
            pSource->UnadviseSink( m_dwCookieTextEditSink );
            pSource->Release();
            return hr;
        }
        
        if (FAILED(pSource->AdviseSink( IID_ITfEditTransactionSink, (ITfEditTransactionSink *)this, &m_dwCookieTransactionSink ))) {
            pSource->UnadviseSink( m_dwCookieTextEditSink );
            pSource->UnadviseSink( m_dwCookieTextLayoutSink );
            pSource->Release();
            return hr;
        }
        pSource->Release();
        
        m_fTextEventSinkAdvised = TRUE;
        hr = S_OK;
    }
    
    return hr;
}


/*   D O N E  T E X T  E V E N T  S I N K S   */
/*------------------------------------------------------------------------------

  uninitialize sinks for text events
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::DoneTextEventSinks( ITfContext *pic )
{
    HRESULT hr = E_FAIL;
    ITfSource *pSource;
    
    Assert( pic == m_picParent );
    
    LeaveEditTransaction();
    
    if (!m_fTextEventSinkAdvised) {
        return S_OK;
    }
    
    if (pic->QueryInterface( IID_ITfSource, (void **)&pSource) == S_OK) {
        pSource->UnadviseSink( m_dwCookieTextEditSink );
        pSource->UnadviseSink( m_dwCookieTextLayoutSink );
        pSource->UnadviseSink( m_dwCookieTransactionSink );
        pSource->Release();
        
        m_fTextEventSinkAdvised = FALSE;
        hr = S_OK;
    }
    
    return hr;
}


/*   O N  E N D  E D I T   */
/*------------------------------------------------------------------------------

  event sink for text edit event
  (ITfTextEditSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnEndEdit( ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord )
{
    BOOL fInWriteSession = FALSE;
    BOOL fSelChanged = FALSE;
    
    // get selection status
    
    if (FAILED(pEditRecord->GetSelectionStatus(&fSelChanged))) {
        return S_OK;
    }
    
    // keep current selection always
    
    if (fSelChanged) {
        ITfRange *pSelection = NULL;
        
        if (GetSelectionSimple( ecReadOnly, pic, &pSelection ) == S_OK) {
            SetSelectionCur( pSelection );
        }
        
        SafeRelease( pSelection );
    }
    
    // ignore events during edit transaction
    
    if (IsInEditTransaction()) {
        return S_OK;
    }
    
    // ignore events made by client tip
    
    pic->InWriteSession( m_tidClient, &fInWriteSession );
    if (fInWriteSession) {
        return S_OK;
    }
    
    // cancel candidate session when selection has been moved
    
    if (fSelChanged) {
        NotifyCancelCand();
    }
    
    return S_OK;
}


/*   O N  L A Y O U T  C H A N G E   */
/*------------------------------------------------------------------------------

  event sink for text layout event
  (ITfTextLayoutSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnLayoutChange( ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView )
{
    BOOL fInWriteSession = FALSE;
    CEditSession *pes;
    
    // ignore events made by client tip
    
    pic->InWriteSession( m_tidClient, &fInWriteSession );
    if (fInWriteSession) {
        return S_OK;
    }
    
    // we only care about the active view
    
    if (!IsActiveView( m_picParent, (ITfContextView *)pView )) {
        return S_OK;
    }
    
    // move candidate window
    
    Assert( m_pCandWnd != NULL );
    if (pes = new CEditSession( EditSessionCallback )) {
        HRESULT hr;
        
        pes->_state.u      = ESCB_RESETTARGETPOS;
        pes->_state.pv     = this;
        pes->_state.wParam = 0;
        pes->_state.pRange = m_pTargetRange;
        pes->_state.pic    = m_picParent;
        
        m_picParent->RequestEditSession( m_tidClient, pes, TF_ES_READ | TF_ES_SYNC, &hr );
        
        pes->Release();
    }
    
    return S_OK;
}


/*   O N  S T A R T  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------

  event sink for start of application transaction
  (ITfEditTransactionSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnStartEditTransaction( ITfContext *pic )
{
    // enter transaction session
    
    Assert( !IsInEditTransaction() );
    EnterEditTransaction( GetSelectionCur() );
    
    return S_OK;
}


/*   O N  E N D  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------

  event sink for end of application transaction
  (ITfEditTransactionSink method)
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnEndEditTransaction( ITfContext *pic )
{
    CEditSession *pes;
    // sanity check
    
    if (!IsInEditTransaction()) {
        return S_OK;
    }
    
    // check selection movement
    
    if (pes = new CEditSession( EditSessionCallback )) {
        HRESULT hr;
        
        pes->_state.u   = ESCB_COMPARERANGEANDCLOSECANDIDATE;
        pes->_state.pv  = this;
        pes->_state.pv1 = GetSelectionStart();
        pes->_state.pv2 = GetSelectionCur();
        pes->_state.pic = m_picParent;
        
        m_picParent->RequestEditSession( m_tidClient, pes, TF_ES_READ | TF_ES_ASYNC, &hr );
        
        pes->Release();
    }
    
    // leave transaction session
    
    LeaveEditTransaction();
    
    return S_OK;
}


//
// edit session
//

/*   E D I T  S E S S I O N  C A L L B A C K   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::EditSessionCallback( TfEditCookie ec, CEditSession *pes )
{
    CCandidateUI *pCandUI;
    
    switch (pes->_state.u)
    {
        case ESCB_RESETTARGETPOS:
        {
            pCandUI = (CCandidateUI *)pes->_state.pv;
            RECT rc;
            BOOL fClipped;
        
            if (pes->_state.pRange == NULL || pCandUI->m_pCandWnd == NULL) {
                break;
            }
        
            if (!pCandUI->GetPropertyMgr()->GetCandWindowProp()->IsAutoMoveEnabled()) {
                break;
            }
        
            // reset target clause poisition
        
            GetTextExtInActiveView( ec, pes->_state.pRange, &rc, &fClipped );
            pCandUI->m_pCandWnd->SetTargetRect( &rc, fClipped );
            break;
        }
        
        case ESCB_COMPARERANGEANDCLOSECANDIDATE:
        {
            ITfContext *pic = pes->_state.pic;
            BOOL       fRangeIdentical = FALSE;
            ITfRange   *pRange1 = (ITfRange*)pes->_state.pv1;
            ITfRange   *pRange2 = (ITfRange*)pes->_state.pv2;
            LONG       lStart;
            LONG       lEnd;
            CCandidateUI *_this = (CCandidateUI *)pes->_state.pv;
        
            pRange1->CompareStart( ec, pRange2, TF_ANCHOR_START, &lStart );
            pRange1->CompareEnd( ec, pRange2, TF_ANCHOR_END, &lEnd );
        
            fRangeIdentical = (lStart == 0) && (lEnd == 0);
        
            // Since we made this call asynchronous, we need 
            if (!fRangeIdentical) 
            {
                _this->NotifyCancelCand();
            }
        
            break;
        }
        
        case ESCB_TEXTEVENT: 
        {
            pCandUI = (CCandidateUI *)pes->_state.pv;
            ITfContext *pic = pes->_state.pic;
            IEnumTfRanges *pEnumRanges = (IEnumTfRanges *)pes->_state.pv1;
        
            // handle textevent
            pCandUI->HandleTextDeltas( ec, pic, pEnumRanges );
        
            pEnumRanges->Release();
            break;
        }
    }
    
    return S_OK;
}


//
// selection
//

/*   S E T  S E L E C T I O N  C U R   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::SetSelectionCur( ITfRange *pSelection )
{
    SafeReleaseClear( m_pSelectionCur );
    m_pSelectionCur = pSelection;
    if (m_pSelectionCur != NULL) {
        m_pSelectionCur->AddRef();
    }
}


/*   C L E A R  S E L E C T I O N  C U R   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::ClearSelectionCur( void )
{
    SafeReleaseClear( m_pSelectionCur );
}


/*   G E T  S E L E C T I O N  C U R   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
ITfRange *CCandidateUI::GetSelectionCur( void )
{
    return m_pSelectionCur;
}


//
// transaction session functions
//

/*   S E T  S E L E C T I O N  S T A R T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::SetSelectionStart( ITfRange *pSelection )
{
    SafeReleaseClear( m_pSelectionStart );
    m_pSelectionStart = pSelection;
    if (m_pSelectionStart != NULL) {
        m_pSelectionStart->AddRef();
    }
}


/*   C L E A R  S E L E C T I O N  S T A R T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::ClearSelectionStart( void )
{
    SafeReleaseClear( m_pSelectionStart );
}


/*   G E T  S E L E C T I O N  S T A R T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
ITfRange *CCandidateUI::GetSelectionStart( void )
{
    return m_pSelectionStart;
}


/*   E N T E R  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::EnterEditTransaction( ITfRange *pSelection )
{
    Assert( !m_fInTransaction );
    
    if (pSelection == NULL) {
        return;
    }
    
    m_fInTransaction = TRUE;
    SetSelectionStart( pSelection );
}


/*   L E A V E  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::LeaveEditTransaction( void )
{
    m_fInTransaction = FALSE;
    ClearSelectionStart();
}


//
// notification function (notification to client)
//

/*   N O T I F Y  C A N C E L  C A N D   */
/*------------------------------------------------------------------------------

  Send notification (callback) to TIP that to cancel candidate
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyCancelCand( void )
{
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    return CallSetResult( 0, CAND_CANCELED );
}


/*   N O T I F Y  S E L E C T  C A N D   */
/*------------------------------------------------------------------------------

  Send notification (callback) to TIP that selection has been changed
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifySelectCand( int iCandItem )
{
    HRESULT hr;
    ULONG nIndex;
    
    // NOTE: Do not send a notification to TIP to prevent from updating inline 
    // text during filtering.
    // This will be called by filtering candidates, and aslo sorting candidates 
    // because selection in UI will be changed by sorting.  But the actual selected 
    // item never changed by sorting.  When the selection has been changed by 
    // user action such as hitting arrow key, the filtering string has already 
    // been reset.  So, we can send notify correctly in that case.
    
    if (GetFunctionMgr()->GetCandFnAutoFilter()->IsEnabled()) {
        if (GetFunctionMgr()->GetCandFnAutoFilter()->GetFilterString() != NULL) {
            return S_OK;
        }
    }
    
    Assert( GetCandListMgr()->GetCandList() != NULL );
    
    hr = GetCandListMgr()->GetCandList()->MapIItemToIndex( iCandItem, &nIndex );
    if (FAILED(hr)) {
        Assert( FALSE );
        return hr;
    }
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    return CallSetResult( nIndex, CAND_SELECTED );
}


/*   N O T I F Y  C O M P L E T E  O P T I O N   */
/*------------------------------------------------------------------------------

  Send notification (callback) to TIP that to complete option
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyCompleteOption( int iCandItem )
{
    HRESULT hr;
    ULONG nIndex;
    
    Assert( GetCandListMgr()->GetOptionsList() != NULL );
    
    hr = GetCandListMgr()->GetOptionsList()->MapIItemToIndex( iCandItem, &nIndex );
    if (FAILED(hr)) {
        Assert( FALSE );
        return hr;
    }
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    return CallSetOptionResult( nIndex, CAND_FINALIZED );
}


/*   N O T I F Y  C O M P L E T E  C A N D   */
/*------------------------------------------------------------------------------

  Send notification (callback) to TIP that to complete candidate
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyCompleteCand( int iCandItem )
{
    HRESULT hr;
    ULONG nIndex;
    
    Assert( GetCandListMgr()->GetCandList() != NULL );
    
    hr = GetCandListMgr()->GetCandList()->MapIItemToIndex( iCandItem, &nIndex );
    if (FAILED(hr)) {
        Assert( FALSE );
        return hr;
    }
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    return CallSetResult( nIndex, CAND_FINALIZED );
}


/*   N O T I F Y  E X T E N S I O N  E V E N T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyExtensionEvent( int iExtension, DWORD dwCommand, LPARAM lParam )
{
    CCandUIExtension *pExtension;
    HRESULT          hr = E_FAIL;
    
    pExtension = GetExtensionMgr()->GetExtension( iExtension );
    if (pExtension != NULL) {
        hr = pExtension->NotifyExtensionEvent( dwCommand, lParam );
    }
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    return hr;
}


/*   N O T I F Y  F I L T E R I N G  E V E N T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyFilteringEvent( CANDUIFILTEREVENT ev )
{
    Assert( GetFunctionMgr()->GetCandFnAutoFilter()->IsEnabled() );
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    if (GetFunctionMgr()->GetCandFnAutoFilter()->GetEventSink() != NULL) {
        return GetFunctionMgr()->GetCandFnAutoFilter()->GetEventSink()->OnFilterEvent( ev );
    }
    else {
        return S_OK;
    }
}


/*   N O T I F Y  S O R T  E V E N T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifySortEvent( CANDUISORTEVENT ev )
{
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    if (GetFunctionMgr()->GetCandFnSort()->GetEventSink() != NULL) {
        return GetFunctionMgr()->GetCandFnSort()->GetEventSink()->OnSortEvent( ev );
    }
    else {
        return S_OK;
    }
}


/*   N O T I F Y  C O M P L E T E  R A W  D A T A   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyCompleteRawData( void )
{
    HRESULT hr;
    
    Assert( GetCandListMgr()->GetCandList() != NULL );
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    hr = CallSetResult( GetCandListMgr()->GetCandList()->GetRawDataIndex(), CAND_FINALIZED );
    
    return hr;
}


/*   N O T I F Y  C O M P L E T E  E X T R A  C A N D   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifyCompleteExtraCand( void )
{
    HRESULT hr;
    
    Assert( GetCandListMgr()->GetCandList() != NULL );
    
    if (m_pCandWnd) {
        m_pCandWnd->UpdateAllWindow();
    }
    
    hr = CallSetResult( GetCandListMgr()->GetCandList()->GetExtraCandIndex(), CAND_FINALIZED );
    
    return hr;
}


/*   C A L L  S E T  R E S U L T   */
/*------------------------------------------------------------------------------

  Send notification to TIP
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::CallSetOptionResult( int nIndex, TfCandidateResult imcr )
{
    HRESULT hr = E_FAIL;
    
    AddRef();
    
    if (!m_fInCallback) {
        ITfOptionsCandidateList *pCandList;
        
        m_fInCallback = TRUE;
        if (SUCCEEDED(GetCandListMgr()->GetOptionsCandidateList( &pCandList ))) {
            hr = pCandList->SetOptionsResult( nIndex, imcr );
            pCandList->Release();
        }
        m_fInCallback = FALSE;
    }
    
    Release();
    return hr;
}


/*   C A L L  S E T  R E S U L T   */
/*------------------------------------------------------------------------------

  Send notification to TIP
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::CallSetResult( int nIndex, TfCandidateResult imcr )
{
    HRESULT hr = E_FAIL;
    
    AddRef();
    
    if (!m_fInCallback) {
        ITfCandidateList *pCandList;
        
        m_fInCallback = TRUE;
        if (SUCCEEDED(GetCandListMgr()->GetCandidateList( &pCandList ))) {
            hr = pCandList->SetResult( nIndex, imcr );
            pCandList->Release();
        }
        m_fInCallback = FALSE;
    }
    
    Release();
    return hr;
}


//
// internal functions
//

/*   C R E A T E  C A N D  W I N D O W  O B J E C T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::CreateCandWindowObject( ITfContext *pic, CCandWindowBase** ppCandWnd )
{
    CANDUISTYLE style;
    DWORD       dwOption;
    DWORD       dwStyle;
    
    Assert( ppCandWnd );
    *ppCandWnd = NULL;
    
    if (FAILED( GetCompartmentMgr()->GetUIStyle( pic, &style ))) {
        style = CANDUISTY_LIST;
    }
    
    if (FAILED( GetCompartmentMgr()->GetUIOption( pic, &dwOption ))) {
        dwOption = 0;
    }
    
    dwStyle = 0;
    if ((dwOption & CANDUIOPT_ENABLETHEME) != 0) {
        dwStyle |= UIWINDOW_WHISTLERLOOK;
    }
    
    switch (style) {
    default:
    case CANDUISTY_LIST: {
        *ppCandWnd = new CCandWindow( this, dwStyle );
        break;
                         }
        
    case CANDUISTY_ROW: {
        *ppCandWnd = new CChsCandWindow( this, dwStyle );
        break;
                        }
    }
    
    return (*ppCandWnd != NULL) ? S_OK : E_OUTOFMEMORY;
}


/*   I N I T  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::InitCandWindow( void )
{
    CEditSession *pes;
    
    if (m_pCandWnd == NULL) {
        return E_FAIL;
    }
    
    m_pCandWnd->Initialize();
    
    // move candidate window
    
    Assert( m_pCandWnd != NULL );
    if (pes = new CEditSession( EditSessionCallback )) {
        HRESULT hr;
        
        pes->_state.u      = ESCB_RESETTARGETPOS;
        pes->_state.pv     = this;
        pes->_state.wParam = 0;
        pes->_state.pRange = m_pTargetRange;
        pes->_state.pic    = m_picParent;
        
        m_picParent->RequestEditSession( m_tidClient, pes, TF_ES_READ | TF_ES_SYNC, &hr );
        
        pes->Release();
    }
    
    // initialize candidate list
    
    m_pCandWnd->InitCandidateList();
    
    // create window
    
    m_pCandWnd->CreateWnd( m_hWndParent );
    m_pCandWnd->Show( GetPropertyMgr()->GetCandWindowProp()->IsVisible() );
    m_pCandWnd->UpdateAllWindow();
    
    return S_OK;
}


//
//
//

/*   O N  K E Y  E V E N T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::OnKeyEvent( UINT uCode, WPARAM wParam, LPARAM lParam, BOOL *pfEaten )
{
    HRESULT hr = E_FAIL;
    BOOL fHandled = FALSE;
    BYTE rgbKeyState[ 256 ];
    
    Assert( pfEaten != NULL );
    Assert( uCode == ICO_KEYDOWN || uCode == ICO_KEYUP || uCode == ICO_TESTKEYDOWN || uCode == ICO_TESTKEYUP );
    
    if (pfEaten == NULL) {
        return E_POINTER;
    }
    
    *pfEaten = FALSE;
    
    if (m_pCandWnd == NULL) {
        return hr;
    }
    
    if (GetKeyboardState( rgbKeyState )) {
        if (GetFunctionMgr()->GetCandFnAutoFilter()->IsEnabled()) {
            fHandled = FHandleFilteringKey( uCode, (int)wParam, rgbKeyState, pfEaten );
        }
        
        if (!fHandled) {
            fHandled = FHandleKeyEvent( uCode, (int)wParam, rgbKeyState, pfEaten );
        }
        
        // cancel candidate when unknown key has come
        
        if (!fHandled) {
            NotifyCancelCand();
        }
        
        hr = S_OK;
    }
    
    return hr;
}


/*   H A N D L E  K E Y  E V E N T   */
/*------------------------------------------------------------------------------

  Handling key event
  return S_OK when processed the key event.
  
------------------------------------------------------------------------------*/
BOOL CCandidateUI::FHandleKeyEvent( UINT uCode, UINT uVKey, BYTE *pbKeyState, BOOL *pfEatKey )
{
    CANDUICOMMAND cmd;
    UINT uiParam;
    
    // NOTE: KOJIW: We need to ignore keyup events to not close candidate UI
    // immediately after TIP opens CandidateUI with KEYDOWN of unknown key.
    
    if (uCode == ICO_KEYUP || uCode == ICO_TESTKEYUP) {
        return TRUE;
    }
    
    // process command on keydown
    
    CommandFromKey( uVKey, pbKeyState, &cmd, &uiParam );
    if (cmd == CANDUICMD_NONE) {
        switch (uVKey) {
        case VK_SHIFT:
        case VK_CONTROL: {
            return TRUE;
                         }
            
        default: {
            return FALSE;
                 }
        }
    }
    
    if (uCode == ICO_KEYDOWN) {
        *pfEatKey = SUCCEEDED(m_pCandWnd->ProcessCommand( cmd, uiParam ));
    }
    else {
        *pfEatKey = TRUE;
    }
    
    return *pfEatKey;
}


/*   H A N D L E  T E X T  D E L T A S   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
BOOL CCandidateUI::HandleTextDeltas( TfEditCookie ec, ITfContext *pic, IEnumTfRanges *pEnumRanges )
{
    ULONG     ulFetched;
    ITfRange *pRange;
    
    pEnumRanges->Reset();
    while (pEnumRanges->Next( 1, &pRange, &ulFetched ) == S_OK) {
        WCHAR szText[ 256 ];
        ULONG cch;
        
        // check text in the range
        
        szText[0] = L'\0';
        cch = 0;
        if (pRange != NULL) {
            pRange->GetText( ec, 0, szText, ARRAYSIZE(szText), &cch );
            pRange->Release();
        }
        
        // 
        
        if (0 < cch) {
            int i = 0;
            ULONG ich;
            
            for (ich = 0; ich < cch; ich++) {
                if ((L'0' <= szText[ich]) && (szText[ich] <= L'9')) {
                    i = i * 10 + (szText[ich] - L'0');
                }
                else if (szText[ich] == L' ') {
                    break;
                }
                else {
                    i = -1;
                    break;
                }
            }
            
            if (0 <= i) {
                if (i == 0) {
                    PostCommand( CANDUICMD_SELECTEXTRACAND, 0 );
                } 
                else {
                    PostCommand( CANDUICMD_SELECTLINE, i );
                }
            }
        }
    }
    
    return TRUE;
}


/*   P O S T  C O M M A N D   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::PostCommand( CANDUICOMMAND cmd, INT iParam )
{
    if ((cmd != CANDUICMD_NONE) && (m_pCandWnd != NULL)) {
        PostMessage( m_pCandWnd->GetWnd(), WM_USER, (WPARAM)cmd, (LPARAM)iParam );
    }
}


//
// Auto filtering functions
//

/*   H A N D L E  F I L T E R I N G  K E Y   */
/*------------------------------------------------------------------------------

  Handle key event for filtering
  Returns TRUE to eat the event (when key has been handled)
  
------------------------------------------------------------------------------*/
BOOL CCandidateUI::FHandleFilteringKey( UINT uCode, UINT uVKey, BYTE *pbKeyState, BOOL *pfEatKey )
{
    BOOL fHandled = FALSE;
    BOOL fUpdateList = FALSE;
    
    switch (uVKey) {
    case VK_RETURN: {
        break;
                    }
        
    case VK_TAB: {
        if (GetCandListMgr()->GetCandList() != NULL) {
            if (uCode == ICO_KEYDOWN) {
                int iCandItem;
                
                iCandItem = GetCandListMgr()->GetCandList()->GetSelection();
                NotifyCompleteCand( iCandItem );
                
                *pfEatKey = TRUE;
            }
            else {
                *pfEatKey = TRUE;
            }
            
            fHandled = TRUE;
        }
        break;
                 }
        
    case VK_BACK: {
        if (uCode == ICO_KEYDOWN) {
            *pfEatKey = (DelFilteringChar( &fUpdateList ) == S_OK);
        }
        else {
            *pfEatKey = TRUE;
        }
        
        fHandled = TRUE;
        break;
                  }
        
    default: {
        WCHAR wch;
        
        // Check this is not a control + key combination as we do not want to pass this on to the filtering system.

        if (pbKeyState[VK_CONTROL] & 0x80) {
            break;
        }
        
        // convert key to char

        wch = CharFromKey( uVKey, pbKeyState );
        if (wch == L'\0') {
            break;
        }
        
        // add filtering character
        
        if (uCode == ICO_KEYDOWN) {
            *pfEatKey = (AddFilteringChar( wch, &fUpdateList ) == S_OK);
        }
        else {
            *pfEatKey = TRUE;   
        }
        
        fHandled = *pfEatKey;
        break;
             }
    }
    
    // update candidate list 
    
    if (fUpdateList) {
        *pfEatKey &= (FilterCandidateList() == S_OK);
    }
    
    return fHandled;
}


/*   A D D  F I L T E R I N G  C H A R   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::AddFilteringChar( WCHAR wch, BOOL *pfUpdateList )
{
    HRESULT hr = S_FALSE;
    LPCWSTR szFilterCur;
    WCHAR   *szFilterNew;
    int     cch;
    
    *pfUpdateList = FALSE;
    if (!GetFunctionMgr()->GetCandFnAutoFilter()->IsEnabled()) {
        return S_FALSE;
    }
    
    // append a character and set filtering string
    
    szFilterCur = GetFunctionMgr()->GetCandFnAutoFilter()->GetFilterString();
    if (szFilterCur == NULL) {
        cch = 0;
        szFilterNew = new WCHAR[ 2 ];
    }
    else {
        cch = wcslen(szFilterCur);
        szFilterNew = new WCHAR[ cch + 2 ];
    }
    
    if (szFilterNew == NULL) {
        return E_OUTOFMEMORY;
    }
    
    if (szFilterCur != NULL) {
        StringCchCopyW( szFilterNew, cch+2, szFilterCur );
    }
    *(szFilterNew + cch) = wch;
    *(szFilterNew + cch + 1) = L'\0';
    
    // Satori#3632: check if there is item matches with new filter string
    // (return S_FALSE when no item matches to pass key event to keyboard command handler)
    
    if (GetFunctionMgr()->GetCandFnAutoFilter()->FExistItemMatches( szFilterNew )) {
        GetFunctionMgr()->GetCandFnAutoFilter()->SetFilterString( szFilterNew );
        *pfUpdateList = TRUE;
        hr = S_OK;
    }
    else {

        // Only when alpha, punctation, space key is pressed,
        // and there is no alternate match because of this input, 
        // we want to notify client of NONMATCH event, so that 
        // client can inject the previous filter string to document,
        //
        // for all other key input, we don't notify that event. 

        if ( iswalpha(wch) || iswpunct(wch) )
        {
          // Notify client of non-matching.
          NotifyFilteringEvent( CANDUIFEV_NONMATCH );
          NotifyCancelCand();
        }

        hr = S_FALSE;
        
    }
    
    delete szFilterNew;
    
    //
    
    return hr;
}


/*   D E L  F I L T E R I N G  C H A R   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::DelFilteringChar( BOOL *pfUpdateList )
{
    LPCWSTR szFilterCur;
    WCHAR   *szFilterNew;
    int cch;
    
    *pfUpdateList = FALSE;
    if (!GetFunctionMgr()->GetCandFnAutoFilter()->IsEnabled()) {
        return S_OK;
    }
    
    // get current filtering string
    
    szFilterCur = GetFunctionMgr()->GetCandFnAutoFilter()->GetFilterString();
    if (szFilterCur == NULL) {
        NotifyCancelCand();
        return S_FALSE;
    }
    
    // delete last character and set filtering string
    
    cch = wcslen(szFilterCur);
    Assert( 0 < cch );
    
    szFilterNew = new WCHAR[ cch + 1 ];
    if (szFilterNew == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    StringCchCopyW( szFilterNew, cch+1, szFilterCur );
    *(szFilterNew + cch - 1) = L'\0';
    
    GetFunctionMgr()->GetCandFnAutoFilter()->SetFilterString( szFilterNew );
    
    delete szFilterNew;
    
    //
    
    *pfUpdateList = TRUE;
    return S_OK;
}


/*   F I L T E R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::FilterCandidateList( void )
{
    int nItemVisible;
    
    if (!GetFunctionMgr()->GetCandFnAutoFilter()->IsEnabled()) {
        return S_OK;
    }
    
    Assert( GetCandListMgr()->GetCandList() != NULL );
    
    // build candidate list with filtering
    
    nItemVisible = GetFunctionMgr()->GetCandFnAutoFilter()->FilterCandidateList();
    
    // close candidate when no item has been mathced
    
    if (nItemVisible == 0) {
        NotifyCancelCand();
        return E_FAIL;
    }
    
    // complete candidate when only one item matched and user typed fully
    
    if (nItemVisible == 1) {
        CCandidateItem *pCandItem;
        int iCandItem;
        BOOL fComplete = FALSE;
        
        iCandItem = GetCandListMgr()->GetCandList()->GetSelection();
        pCandItem = GetCandListMgr()->GetCandList()->GetCandidateItem( iCandItem );
        Assert( pCandItem != NULL );
        
        if ((pCandItem != NULL) && (GetFunctionMgr()->GetCandFnAutoFilter()->GetFilterString() != NULL)) {
            fComplete = (wcslen(pCandItem->GetString()) == wcslen(GetFunctionMgr()->GetCandFnAutoFilter()->GetFilterString()));
        }
        
        if (fComplete) {
            NotifyCompleteCand( iCandItem );
            return S_OK;
        }
    }
    
    // notify TIP that filtering has been updated
    
    NotifyFilteringEvent( CANDUIFEV_UPDATED );
    return S_OK;
}


/* FHandleSpellingChar */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::FHandleSpellingChar(WCHAR ch)
{
    BOOL fUpdateList = FALSE;
    
    if (S_OK == AddFilteringChar( ch, &fUpdateList ) && fUpdateList) {
        return FilterCandidateList();
    }
    return E_FAIL;
}


/*
**
** Speech handling functions
**
**
*/

/*   E N S U R E  S P E E C H   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
void CCandidateUI::EnsureSpeech(void)
{
    if (m_pSpTask)
    {
        // make sure grammars are up/running
        m_pSpTask->_LoadGrammars();
        m_pSpTask->_Activate(TRUE);
        return;
        
    }
    
    m_pSpTask = new CSpTask(this);
    if (m_pSpTask)
    {
        if (!m_pSpTask->IsSpeechInitialized())
        {
            m_pSpTask->InitializeSpeech();
        }
    }
}


/*   N O T I F Y  S P E E C H  C M D   */
/*------------------------------------------------------------------------------

  Speech command handler
  
------------------------------------------------------------------------------*/
HRESULT CCandidateUI::NotifySpeechCmd(SPPHRASE *pPhrase, const WCHAR *pszRuleName, ULONG ulRuleId)
{
    HRESULT hr = S_OK;
    CANDUICOMMAND cmd;
    UINT uiParam;
    
    if (m_pCandWnd == NULL) {
        return E_FAIL;
    }
    
    CommandFromRule( pszRuleName, &cmd, &uiParam );
    if (cmd != CANDUICMD_NONE) {
        m_pCandWnd->ProcessCommand( cmd, uiParam );
    }
    
    return hr;
}


/*   C H A R  F R O M  K E Y   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
WCHAR CCandidateUI::CharFromKey( UINT uVKey, BYTE *pbKeyState )
{
    WORD  wBuf;
    char  rgch[2];
    WCHAR wch;
    int   cch;
    int   cwch;
    
    cch = ToAscii( uVKey, 0, pbKeyState, &wBuf, 0 );
    
    rgch[0] = LOBYTE(wBuf);
    rgch[1] = HIBYTE(wBuf);
    cwch = MultiByteToWideChar( m_codepage, 0, rgch, cch, &wch, 1 );
    if (cwch != 1) {
        wch = L'\0';
    }
    
    return wch;
}


/*   G E T  K E Y  C O N F I G  P R O C   */
/*------------------------------------------------------------------------------

  
    
------------------------------------------------------------------------------*/
CCandUIKeyTable *CCandidateUI::GetKeyTableProc( ITfContext *pic )
{
    CCandUIKeyTable *pCandUIKeyTable;
    CANDUISTYLE style;
    
    // check key table in input context 
    
    if (GetCompartmentMgr() != NULL) {
        if (SUCCEEDED(GetCompartmentMgr()->GetKeyTable( pic, &pCandUIKeyTable ))) {
            return pCandUIKeyTable;
        }
    }
    
    // use default key table
    
    if (FAILED(GetCompartmentMgr()->GetUIStyle( pic, &style ))) {
        style = CANDUISTY_LIST;
    }
    
    pCandUIKeyTable = new CCandUIKeyTable();
    if (pCandUIKeyTable)
    {
        switch (style) {
        default:
        case CANDUISTY_LIST: {
            pCandUIKeyTable->SetKeyTable( rgKeyDefList, ARRAYSIZE(rgKeyDefList) );
            break;
                             }
            
        case CANDUISTY_ROW: {
            pCandUIKeyTable->SetKeyTable( rgKeyDefRow, ARRAYSIZE(rgKeyDefRow) );
            break;
                            }
        }
    }
    
    return pCandUIKeyTable;
}


/*   C O M M A N D  F R O M  K E Y   */
/*------------------------------------------------------------------------------

  Get command from key
  
------------------------------------------------------------------------------*/
void CCandidateUI::CommandFromKey( UINT uVKey, BYTE *pbKeyState, CANDUICOMMAND *pcmd, UINT *pParam )
{
    Assert( pcmd != NULL );
    Assert( pParam != NULL );
    Assert( pbKeyState != NULL );
    
    *pcmd = CANDUICMD_NONE;
    *pParam = 0;
    
    // check special keys
    
    switch( uVKey) {
    case VK_TAB: {
        *pcmd = CANDUICMD_NOP;
        break;
                 }
    }
    
    if (*pcmd != CANDUICMD_NONE) {
        return;
    }
    
    // find from key table 
    
    if (m_pCandUIKeyTable != NULL) {
        WCHAR wch = CharFromKey( uVKey, pbKeyState );
        
        m_pCandUIKeyTable->CommandFromKey( uVKey, wch, pbKeyState, GetPropertyMgr()->GetCandWindowProp()->GetUIDirection(), pcmd, pParam );
    }
}


/*   C O M M A N D  F R O M  R U L E   */
/*------------------------------------------------------------------------------

  Get command from speech rule
  
------------------------------------------------------------------------------*/
void CCandidateUI::CommandFromRule( LPCWSTR szRule, CANDUICOMMAND *pcmd, UINT *pParam )
{
    const RULEDEF *pRuleDef = NULL;
    int nRuleDef = 0;
    
    Assert( pcmd != NULL );
    Assert( pParam != NULL );
    
    *pcmd = CANDUICMD_NONE;
    *pParam = 0;
    
    //
    // find ruledef table from current state
    //
    
    // NOTE: Currently CandidateUI doesn't have candidate Menu... only Normal state is available
    if (!m_pCandWnd->FCandMenuOpen()) {
        pRuleDef = rgRuleNorm;
        nRuleDef = ARRAYSIZE(rgRuleNorm);
    }
    
    //
    // get command from ruledef table
    //
    
    if (pRuleDef != NULL) {
        while (0 < nRuleDef) {
            if (wcscmp( szRule, pRuleDef->szRuleName ) == 0) {
                *pcmd   = pRuleDef->cmd;
                *pParam = pRuleDef->uiParam;
                break;
            }
            nRuleDef--;
            pRuleDef++;
        }
    }
}


//
//
//

/*   C  T F  C A N D I D A T E  U  I  C O N T E X T  O W N E R   */
/*------------------------------------------------------------------------------

    constructor of CTfCandidateUIContextOwner

------------------------------------------------------------------------------*/
CTfCandidateUIContextOwner::CTfCandidateUIContextOwner( CCandidateUI *pCandUI )
{
    m_pCandUI = pCandUI;
    if (m_pCandUI != NULL) {
        m_pCandUI->AddRef();
    }
}


/*   ~  C  T F  C A N D I D A T E  U  I  C O N T E X T  O W N E R   */
/*------------------------------------------------------------------------------

    destructor of CTfCandidateUIContextOwner

------------------------------------------------------------------------------*/
CTfCandidateUIContextOwner::~CTfCandidateUIContextOwner( void )
{
    if (m_pCandUI != NULL) {
        m_pCandUI->Release();
    }
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    Query interface
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CTfCandidateUIContextOwner::QueryInterface( REFIID riid, void **ppvObj )
{
    if (ppvObj == NULL) {
        return E_POINTER;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandidateUIContextOwner )) {
        *ppvObj = SAFECAST( this, ITfCandidateUIContextOwner* );
    }

    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CTfCandidateUIContextOwner::AddRef( void )
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CTfCandidateUIContextOwner::Release( void )
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}



/*   P R O C E S S  C O M M A N D   */
/*------------------------------------------------------------------------------

    process command

------------------------------------------------------------------------------*/
STDAPI CTfCandidateUIContextOwner::ProcessCommand(CANDUICOMMAND cmd, INT iParam)
{
    HRESULT hr;

    if (m_pCandUI != NULL) {
        m_pCandUI->PostCommand( cmd, iParam );
        hr = S_OK;
    }
    else {
        hr = E_FAIL;
    }

    return hr;
}


/*   T E S T  T E X T   */
/*------------------------------------------------------------------------------

    test text

------------------------------------------------------------------------------*/
STDAPI CTfCandidateUIContextOwner::TestText(BSTR bstr, BOOL *pfHandles)
{
    HRESULT hr;
    int i;
    ULONG ich;
    ULONG cch;

    if (bstr == NULL || pfHandles == NULL) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (m_pCandUI == NULL) {
        hr = E_FAIL;
        goto Exit;
    }

    *pfHandles = FALSE;

    i = 0;
    cch = SysStringLen( bstr );
    for (ich = 0; ich < cch; ich++) {
        if ((L'0' <= bstr[ich]) && (bstr[ich] <= L'9')) {
            i = i * 10 + (bstr[ich] - L'0');
        }
        else if (bstr[ich] == L' ') {
            break;
        }
        else {
            i = -1;
            break;
        }
    }

    if (0 <= i) {
        if (i == 0) {
            if (m_pCandUI->GetCandListMgr()->GetCandList() != NULL) {
                *pfHandles = (m_pCandUI->GetCandListMgr()->GetCandList()->GetExtraCandItem() != NULL);
            }
        }
        else {
            if (m_pCandUI->GetCandWindow() != NULL) {
                m_pCandUI->GetCandWindow()->IsIndexValid( i, pfHandles );
            }
        }
    }

    hr = S_OK;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candutil.cpp ===
//
// candutil.cpp 
//

#include "private.h"
#include "candutil.h"
#include "globals.h"
#include "cuilib.h"


//
//
//

/*   F  I S  W I N D O W S  N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL FIsWindowsNT( void )
{
	static BOOL fInitialized = FALSE;
	static BOOL fWindowsNT = FALSE;

	if (!fInitialized) {
		OSVERSIONINFO OSVerInfo = {0};

		OSVerInfo.dwOSVersionInfoSize = sizeof(OSVerInfo);
		if (GetVersionEx( &OSVerInfo )) {
			fWindowsNT = (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
		}

		fInitialized = TRUE;
	}

	return fWindowsNT;
}


/*   C P G  F R O M  C H S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
UINT CpgFromChs( BYTE chs )
{
	DWORD dwChs = chs;
	CHARSETINFO ChsInfo = {0};

	if (chs != SYMBOL_CHARSET && TranslateCharsetInfo( &dwChs, &ChsInfo, TCI_SRCCHARSET )) {
		return ChsInfo.ciACP;
	}

	return GetACP();
}


/*   C O N V E R T  L O G  F O N T  W T O  A   */
/*------------------------------------------------------------------------------

	Convert LOGFONTW to LOGFONTA

------------------------------------------------------------------------------*/
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA )
{
	UINT cpg;

	plfA->lfHeight         = plfW->lfHeight;
	plfA->lfWidth          = plfW->lfWidth;
	plfA->lfEscapement     = plfW->lfEscapement;
	plfA->lfOrientation    = plfW->lfOrientation;
	plfA->lfWeight         = plfW->lfWeight;
	plfA->lfItalic         = plfW->lfItalic;
	plfA->lfUnderline      = plfW->lfUnderline;
	plfA->lfStrikeOut      = plfW->lfStrikeOut;
	plfA->lfCharSet        = plfW->lfCharSet;
	plfA->lfOutPrecision   = plfW->lfOutPrecision;
	plfA->lfClipPrecision  = plfW->lfClipPrecision;
	plfA->lfQuality        = plfW->lfQuality;
	plfA->lfPitchAndFamily = plfW->lfPitchAndFamily;

	cpg = CpgFromChs( plfW->lfCharSet );
	WideCharToMultiByte( cpg, 0, plfW->lfFaceName, -1, plfA->lfFaceName, ARRAYSIZE(plfA->lfFaceName), NULL, NULL );
}


/*   C O N V E R T  L O G  F O N T  A T O  W   */
/*------------------------------------------------------------------------------

	Convert LOGFONTA to LOGFONTW

------------------------------------------------------------------------------*/
void ConvertLogFontAtoW( CONST LOGFONTA *plfA, LOGFONTW *plfW )
{
	UINT cpg;

	plfW->lfHeight         = plfA->lfHeight;
	plfW->lfWidth          = plfA->lfWidth;
	plfW->lfEscapement     = plfA->lfEscapement;
	plfW->lfOrientation    = plfA->lfOrientation;
	plfW->lfWeight         = plfA->lfWeight;
	plfW->lfItalic         = plfA->lfItalic;
	plfW->lfUnderline      = plfA->lfUnderline;
	plfW->lfStrikeOut      = plfA->lfStrikeOut;
	plfW->lfCharSet        = plfA->lfCharSet;
	plfW->lfOutPrecision   = plfA->lfOutPrecision;
	plfW->lfClipPrecision  = plfA->lfClipPrecision;
	plfW->lfQuality        = plfA->lfQuality;
	plfW->lfPitchAndFamily = plfA->lfPitchAndFamily;

	cpg = CpgFromChs( plfA->lfCharSet );
	MultiByteToWideChar( cpg, 0, plfA->lfFaceName, -1, plfW->lfFaceName, ARRAYSIZE(plfW->lfFaceName) );
}


/*   O U R  C R E A T E  F O N T  I N D I R E C T  W   */
/*------------------------------------------------------------------------------

	Create font from LOGFONTW

------------------------------------------------------------------------------*/
HFONT OurCreateFontIndirectW( CONST LOGFONTW *plfW )
{
	if (!FIsWindowsNT()) {
		LOGFONTA lfA;

		ConvertLogFontWtoA( plfW, &lfA );
		return CreateFontIndirectA( &lfA );
	}

	return CreateFontIndirectW( plfW );
}


/*   G E T  F O N T  H E I G H T  O F  F O N T   */
/*------------------------------------------------------------------------------

	Get font height of the font

------------------------------------------------------------------------------*/
int GetFontHeightOfFont( HDC hDC, HFONT hFont )
{
	HFONT hFontOld;
	TEXTMETRIC tm;
	BOOL fReleaseDC = FALSE;

	if (hDC == NULL) 
		{
		hDC = GetDC( NULL );
		fReleaseDC = TRUE;
		}

	hFontOld = (HFONT)SelectObject( hDC, hFont );
	GetTextMetrics( hDC, &tm );
	SelectObject( hDC, hFontOld );

	if (fReleaseDC) 
		{
		ReleaseDC( NULL, hDC );
		}

	return tm.tmHeight + tm.tmExternalLeading;
}


/*   C O M P A R E  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CompareString( LPCWSTR pchStr1, LPCWSTR pchStr2, int cch )
{
	int cchStr1 = wcslen( pchStr1 ) + 1;
	int cchStr2 = wcslen( pchStr2 ) + 1;

	__try {
		LPWSTR pchBuf1 = (LPWSTR)alloca( cchStr1*sizeof(WCHAR) );
		LPWSTR pchBuf2 = (LPWSTR)alloca( cchStr2*sizeof(WCHAR) );
		LPWSTR pch;

		memcpy( pchBuf1, pchStr1, cchStr1*sizeof(WCHAR) );
		for (pch = pchBuf1; *pch != L'\0'; pch++) {
			if (L'A' <= *pch && *pch <= L'Z') {
				*pch = *pch - L'A' + L'a';
			}
		}

		memcpy( pchBuf2, pchStr2, cchStr2*sizeof(WCHAR) );
		for (pch = pchBuf2; *pch != L'\0'; pch++) {
			if (L'A' <= *pch && *pch <= L'Z') {
				*pch = *pch - L'A' + L'a';
			}
		}

		return wcsncmp( pchBuf1, pchBuf2, cch );
	} 
	__except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
		_resetstkoflw();
		return -1; // treat different
	}
}


//
//
//

/*   C B  D I B  C O L O R  T A B L E   */
/*------------------------------------------------------------------------------

	Calc the size of color table of bitmap

------------------------------------------------------------------------------*/
static int CbDIBColorTable( BITMAPINFOHEADER *pbmih )
{
	WORD nColor;

	Assert( pbmih->biSize == sizeof(BITMAPINFOHEADER) );
	if (pbmih->biPlanes != 1) {
		Assert( FALSE );
		return 0;
	}

	if (pbmih->biClrUsed == 0) {
		if (pbmih->biBitCount == 1 || pbmih->biBitCount == 4 || pbmih->biBitCount == 8) {
			nColor = (WORD) (1 << pbmih->biBitCount);
		}
		else {
			nColor = 0;
		}
	}
	else if (pbmih->biBitCount != 24) {
		nColor = (WORD)pbmih->biClrUsed;
	}
	else {
		nColor = 0;
	}
		
	return (nColor * sizeof(RGBQUAD));
}


/*   P D I  B I T S   */
/*------------------------------------------------------------------------------

	Returns pointer of DIBits from DIB data

------------------------------------------------------------------------------*/
static LPVOID PDIBits( LPVOID pDIB )
{
	return ((BYTE*)pDIB + (sizeof(BITMAPINFOHEADER) + CbDIBColorTable( (BITMAPINFOHEADER *)pDIB )));
}


/*   C R E A T E  D I B  F R O M  B M P   */
/*------------------------------------------------------------------------------

	Create DIB from Bitmap

------------------------------------------------------------------------------*/
static HANDLE CreateDIBFromBmp( HDC hDC, HBITMAP hBmp, HPALETTE hPalette )
{
	HDC hDCMem;
	BITMAP             bmp;
	BITMAPINFOHEADER   bmih = {0};
	LPBITMAPINFOHEADER pbmih;
	HANDLE             hDIB;
	void               *pDIB;
	void               *pDIBits;
	HPALETTE           hPaletteOld = NULL;
	DWORD              cbImage;
	DWORD              cbColorTable;
	DWORD              cbBits;

	if (hBmp == NULL) {
		return NULL;
	}

	//

	hDCMem = CreateCompatibleDC( hDC );

	// initialize bmi

	GetObject( hBmp, sizeof(bmp), &bmp );

	bmih.biSize          = sizeof(BITMAPINFOHEADER);
	bmih.biWidth         = bmp.bmWidth;
	bmih.biHeight        = bmp.bmHeight;
	bmih.biPlanes        = 1;
	bmih.biBitCount      = bmp.bmPlanes * bmp.bmBitsPixel;
	bmih.biCompression   = BI_RGB;
	bmih.biSizeImage     = 0;
	bmih.biXPelsPerMeter = 0;
	bmih.biYPelsPerMeter = 0;
	bmih.biClrUsed       = 0;
	bmih.biClrImportant  = 0;

	if (hPalette) {
		hPaletteOld = SelectPalette( hDCMem, hPalette, FALSE );
		RealizePalette( hDCMem );
	}

	//

	cbColorTable = CbDIBColorTable( &bmih );

	cbBits = bmih.biWidth * (DWORD)bmih.biBitCount;
	cbImage = (((cbBits + 31) >> 5) << 2) * bmih.biHeight;
	hDIB = GlobalAlloc( GMEM_ZEROINIT, sizeof(bmih) + cbColorTable + cbImage );

	if (hDIB)
	{

		// get dibits

		pDIB = GlobalLock( hDIB );
		pbmih  = (BITMAPINFOHEADER *)pDIB;
		*pbmih = bmih;
		pDIBits = PDIBits( pDIB );

		if (GetDIBits( hDCMem, hBmp, 0, bmp.bmHeight, pDIBits, (BITMAPINFO *)pbmih, DIB_RGB_COLORS )) {
			GlobalUnlock( hDIB );
		}
		else {
			GlobalUnlock( hDIB );
			GlobalFree( hDIB );
			hDIB = NULL;
		}

		if (hPaletteOld != NULL) {
			SelectPalette( hDCMem, hPaletteOld, FALSE );
		}
	}
	DeleteDC( hDCMem );
	return hDIB;
}


/*   C R E A T E  B M P  F R O M  D I B   */
/*------------------------------------------------------------------------------

	Create Bitmap from DIB

------------------------------------------------------------------------------*/
static HBITMAP CreateBmpFromDIB( HDC hDC, HANDLE hDIB, HPALETTE hPalette )
{
	void             *pDIB;
	void             *pDIBits;
	HDC              hDCMem;
	BITMAPINFOHEADER *pbmih;
	HPALETTE         hPaletteOld = NULL;
	HBITMAP          hBmp;
	HBITMAP          hBmpOld;

	if (hDIB == NULL) {
		return NULL;
	}

	//

	pDIB = GlobalLock( hDIB );
	pbmih = (BITMAPINFOHEADER *)pDIB;
	pDIBits = PDIBits( pDIB );

	//

	hBmp = CreateBitmap( pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, NULL );
	if (hBmp == NULL) {
		GlobalUnlock( hDIB );
		return NULL;
	}

	//

	hDCMem = CreateCompatibleDC( hDC );
	if (hDCMem)
	{
		if (hPalette != NULL) {
			hPaletteOld = SelectPalette( hDCMem, hPalette, FALSE );
			RealizePalette( hDCMem );
		}

		hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmp );
		StretchDIBits( hDCMem, 0, 0, pbmih->biWidth, pbmih->biHeight, 0, 0, pbmih->biWidth, pbmih->biHeight, pDIBits, (BITMAPINFO *)pbmih, DIB_RGB_COLORS, SRCCOPY );
		SelectObject( hDCMem, hBmpOld );

		GlobalUnlock( hDIB );
		DeleteDC( hDCMem );
	}
	return hBmp;
}


/*   C R E A T E  D I B 8  F R O M  D I B 1   */
/*------------------------------------------------------------------------------

	Create DIB-8bpp from DIB-1bpp

------------------------------------------------------------------------------*/
static HANDLE CreateDIB8FromDIB1( BITMAPINFOHEADER *pbmihSrc, void *pDIBitsSrc )
{
	HANDLE           hDIBDst;
	void             *pDIBDst;
	BITMAPINFOHEADER *pbmihDst;
	BYTE             *pbPixelsSrc;
	BYTE             *pbPixelsDst;
	WORD             cbits;
	int              cbLnSrc;
	int              cbLnDst;
	int              cx;
	int              cy;
	int              x;
	int              y;
	int              i;

	Assert( pbmihSrc->biBitCount == 1 );

	cx = pbmihSrc->biHeight;
	cy = pbmihSrc->biWidth;
	cbits = pbmihSrc->biBitCount;

	// count of bytes of line (DWORD aligned)
	
	cbLnSrc = ((cx + 31) / 32) * 4;
	cbLnDst = (((cx<<3) + 31) / 32) * 4;

	//

	hDIBDst = GlobalAlloc( GMEM_ZEROINIT, sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD) + ((DWORD)cbLnDst * cy) );
	if (hDIBDst)
	{
		pDIBDst = GlobalLock( hDIBDst );

		// store bitmap info header

		pbmihDst = (BITMAPINFOHEADER *)pDIBDst;
		*pbmihDst = *pbmihSrc;
		pbmihDst->biBitCount     = 8;
		pbmihDst->biSizeImage    = 0;
		pbmihDst->biClrUsed      = 0;
		pbmihDst->biClrImportant = 0;

		// copy palette

		for (i = 0; i < (1 << cbits); i++) {
			((BITMAPINFO *)pbmihDst)->bmiColors[i] = ((BITMAPINFO *)pbmihSrc)->bmiColors[i];
		}

		//

		pbPixelsSrc = (BYTE *)pDIBitsSrc;
		pbPixelsDst = (BYTE *)PDIBits( pDIBDst );
		for (y = 0; y < cy; y++) {
			BYTE *pbSrc = pbPixelsSrc + ((DWORD)cbLnSrc) * y;
			BYTE *pbDst = pbPixelsDst + ((DWORD)cbLnDst) * y;
			BYTE bMask;

			for (x = 0, bMask = (BYTE)0x80; x < cx; x++) {
				if (*pbSrc & bMask) {
					*pbDst = 1;
				}
  
				pbDst++;
				bMask = bMask >> 1;

				if (bMask < 1) {
					pbSrc++;
					bMask = (BYTE)0x80;
				}
			}
		}

		GlobalUnlock( hDIBDst );
	}
	return hDIBDst;
}


/*   C R E A T E  D I B 8  F R O M  D I B 4   */
/*------------------------------------------------------------------------------

	Create DIB-8bpp from DIB-4bpp

------------------------------------------------------------------------------*/
static HANDLE CreateDIB8FromDIB4( BITMAPINFOHEADER *pbmihSrc, void *pDIBitsSrc )
{
	HANDLE           hDIBDst;
	void             *pDIBDst;
	BITMAPINFOHEADER *pbmihDst;
	BYTE             *pbPixelsSrc;
	BYTE             *pbPixelsDst;
	WORD             cbits;
	int              cbLnSrc;
	int              cbLnDst;
	int              cx;
	int              cy;
	int              x;
	int              y;
	int              i;

	Assert( pbmihSrc->biBitCount == 4 );

	cx = pbmihSrc->biHeight;
	cy = pbmihSrc->biWidth;
	cbits = pbmihSrc->biBitCount;

	// count of bytes of line (DWORD aligned)
	
	cbLnSrc = (((cx<<2) + 31) / 32) * 4;
	cbLnDst = (((cx<<3) + 31) / 32) * 4;

	//

	hDIBDst = GlobalAlloc( GMEM_ZEROINIT, sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD) + ((DWORD)cbLnDst * cy) );
	if (hDIBDst)
	{
		pDIBDst = GlobalLock( hDIBDst );

		// store bitmap info header

		pbmihDst = (BITMAPINFOHEADER *)pDIBDst;
		*pbmihDst = *pbmihSrc;
		pbmihDst->biBitCount     = 8;
		pbmihDst->biSizeImage    = 0;
		pbmihDst->biClrUsed      = 0;
		pbmihDst->biClrImportant = 0;

		// copy palette

		for (i = 0; i < (1 << cbits); i++) {
			((BITMAPINFO *)pbmihDst)->bmiColors[i] = ((BITMAPINFO *)pbmihSrc)->bmiColors[i];
		}

		//

		pbPixelsSrc = (BYTE *)pDIBitsSrc;
		pbPixelsDst = (BYTE *)PDIBits( pDIBDst );
		for (y = 0; y < cy; y++) {
			BYTE *pbSrc = pbPixelsSrc + ((DWORD)cbLnSrc) * y;
			BYTE *pbDst = pbPixelsDst + ((DWORD)cbLnDst) * y;

			for (x = 0; x < cx; x+=2 ) {
				*(pbDst++) = ((*pbSrc & 0xf0) >> 4);
				*(pbDst++) = (*(pbSrc++) & 0x0f);
			}
		}

		GlobalUnlock( hDIBDst );
	}
	return hDIBDst;
}


/*   C R E A T E  R O T A T E  D I B   */
/*------------------------------------------------------------------------------

	Create a rotated DIB from DIB

------------------------------------------------------------------------------*/
static HANDLE CreateRotateDIB( HANDLE hDIBSrc, CANDANGLE angle )
{
	HANDLE           hDIB8 = NULL;
	void             *pDIBSrc;
	BITMAPINFOHEADER bmihSrc;
	void             *pDIBitsSrc;
	int              cxSrc;
	int              cySrc;
	long             cbLnSrc;

	HANDLE           hDIBDst;
	void             *pDIBDst;
	BITMAPINFOHEADER *pbmihDst;
	void             *pDIBitsDst;
	int              cxDst;
	int              cyDst;
	long             cbLnDst;

	int              cBitsPixel;	/* number of bits per pixel */
	int              cbPixel;		/* number of bytes per pixel */
	BYTE             *pbPixelSrc;
	BYTE             *pbPixelDst;
	int              cbNextPixel;
	int              cbNextLine;
	int              x;
	int              y;

	// sanity check

	if (hDIBSrc == NULL) {
		return NULL;
	}

	// 
	// prepare source DIB
	//

	pDIBSrc = GlobalLock( hDIBSrc );
	bmihSrc = *((BITMAPINFOHEADER *)pDIBSrc);
	pDIBitsSrc = PDIBits( pDIBSrc );

	// if bit depth is less than eight convert to an 8bpp image so that we can rotate.

	if (bmihSrc.biBitCount < 8) {
		hDIB8 = (bmihSrc.biBitCount == 4) ? CreateDIB8FromDIB4( &bmihSrc, PDIBits(pDIBSrc) ) 
										  : CreateDIB8FromDIB1( &bmihSrc, PDIBits(pDIBSrc) );

		GlobalUnlock( hDIBSrc );

		// satori81#312 / prefix#179976
		if (hDIB8 == NULL) {
			return NULL;
		}

		hDIBSrc = hDIB8;
		pDIBSrc = GlobalLock( hDIB8 );
		bmihSrc = *((BITMAPINFOHEADER *)pDIBSrc);
		pDIBitsSrc = PDIBits( pDIBSrc );
	}

	cxSrc = bmihSrc.biWidth;
	cySrc = bmihSrc.biHeight;

	//
	// create rotated DIB
	//

	// calc DIBits size

	cBitsPixel = bmihSrc.biBitCount;
	cbPixel    = cBitsPixel/8;

	switch (angle) {
		default:
		case CANGLE0:
		case CANGLE180: {
			cxDst = cxSrc;
			cyDst = cySrc;
			break;
		}

		case CANGLE90:
		case CANGLE270: {
			cxDst = cySrc;
			cyDst = cxSrc;
			break;
		}
	}

	// count of bytes of line (DWORD aligned)

	cbLnSrc = (((cxSrc * bmihSrc.biBitCount) + 31) / 32) * 4;
	cbLnDst = (((cxDst * bmihSrc.biBitCount) + 31) / 32) * 4;

	// allocate memory for new dib bits

	hDIBDst = GlobalAlloc( GMEM_ZEROINIT, sizeof(BITMAPINFOHEADER) + CbDIBColorTable( &bmihSrc ) + ((DWORD)cbLnDst * cyDst) );
	if (!hDIBDst) {
		//satori81#258 / prefix#179977
		GlobalUnlock( hDIBSrc );
		if (hDIB8 != NULL) {
			GlobalFree( hDIB8 );
		}
		return NULL;
	}
	pDIBDst = GlobalLock( hDIBDst );
	pbmihDst   = (BITMAPINFOHEADER *)pDIBDst;

	// store bitmap infoheader (including color table)

	memcpy( pDIBDst, pDIBSrc, sizeof(BITMAPINFOHEADER) + CbDIBColorTable( &bmihSrc ) );
	pbmihDst->biHeight    = cyDst;
	pbmihDst->biWidth     = cxDst;
	pbmihDst->biSizeImage = 0;

	pDIBitsDst = PDIBits( pDIBDst );

	//
	// create rotated DIBits
	//

	pbPixelSrc = (BYTE *)pDIBitsSrc;
	switch (angle) {
		default:
		case CANGLE0: {
			cbNextPixel = cbPixel;
			cbNextLine  = cbLnDst;

			pbPixelDst = (BYTE*)pDIBitsDst;
			break;
		}

		case CANGLE90: {
			cbNextPixel = cbLnDst;
			cbNextLine  = -cbPixel;

			pbPixelDst = (BYTE*)pDIBitsDst + ((DWORD)cbPixel*(cxDst - 1));
			break;
		}

		case CANGLE180: {
			cbNextPixel = -cbPixel;
			cbNextLine  = -cbLnDst;

			pbPixelDst = (BYTE*)pDIBitsDst + ((DWORD)cbPixel*(cxDst - 1) + (DWORD)cbLnDst*(cyDst - 1));
			break;
		}

		case CANGLE270: {
			cbNextPixel = -cbLnDst;
			cbNextLine  = cbPixel;

			pbPixelDst = (BYTE*)pDIBitsDst + ((DWORD)cbLnDst*(cyDst - 1));
		}
	}

	// copy bits

	for (y = 0; y < cySrc; y++) {
		BYTE *pbPixelSrcLine = pbPixelSrc;
		BYTE *pbPixelDstLine = pbPixelDst;

		for (x = 0; x < cxSrc; x++) {
			memcpy( pbPixelDst, pbPixelSrc, cbPixel );

			pbPixelSrc += cbPixel;
			pbPixelDst += cbNextPixel;
		}

		pbPixelSrc = pbPixelSrcLine + cbLnSrc;
		pbPixelDst = pbPixelDstLine + cbNextLine;
	}

	//
	// finish creating new DIB
	//

	GlobalUnlock( hDIBDst );
	GlobalUnlock( hDIBSrc );

	// dispose temporary DIB

	if (hDIB8 != NULL) {
		GlobalFree( hDIB8 );
	}

	return hDIBDst;
}


/*   C R E A T E  R O T A T E  B I T M A P   */
/*------------------------------------------------------------------------------

	Create a rotated bitmap from bitmap

------------------------------------------------------------------------------*/
HBITMAP CreateRotateBitmap( HBITMAP hBmpSrc, HPALETTE hPalette, CANDANGLE angle )
{
	HDC     hDC;
	HBITMAP hBmpDst;
	HANDLE  hDIBSrc;
	HANDLE  hDIBDst;

	hDC = CreateDC( "DISPLAY", NULL, NULL, NULL );
	// satori81#256 / prefix#110692
	if (hDC == NULL) {
		return NULL;
	}

	// create dib from bitmap

	if ((hDIBSrc = CreateDIBFromBmp( hDC, hBmpSrc, hPalette )) == NULL) {
		DeleteDC( hDC );
		return NULL;
	}

	// rotate bitmap

	hDIBDst = CreateRotateDIB( hDIBSrc, angle );

	// create bitmap from dib

	hBmpDst = CreateBmpFromDIB( hDC, hDIBDst, hPalette );

	// dispose temp objects

	GlobalFree( hDIBSrc );
	GlobalFree( hDIBDst );

	if (hDC)
		DeleteDC( hDC );

	return hBmpDst;
}


/*   G E T  T E X T  E X T E N T   */
/*------------------------------------------------------------------------------

	Get text extent of the given wide string with specified font

------------------------------------------------------------------------------*/
void GetTextExtent( HFONT hFont, LPCWSTR pwchText, int cch, SIZE *psize, BOOL fHorizontal )
{
	HDC   hDC;
	HFONT hFontOld;
	const int nOffOneBugShield = 1;

	psize->cx = 0;
	psize->cy = 0;

	if (pwchText != NULL) {
		hDC = GetDC(NULL);
		hFontOld = (HFONT)SelectObject(hDC, hFont);

		FLGetTextExtentPoint32(hDC, pwchText, cch, psize);

		SelectObject(hDC, hFontOld);
		ReleaseDC(NULL, hDC);

		//  HACK
		//  FLGetTextExtentPoint32() is suspected have off-one bug in calculation with "vertical" font.
		if ( !fHorizontal ) {
			psize->cx += nOffOneBugShield;
		}
	}

	return;
}


/*   G E T  W O R K  A R E A  F R O M  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void GetWorkAreaFromWindow( HWND hWindow, RECT *prc )
{
	HMONITOR hMonitor = NULL;

	SystemParametersInfo( SPI_GETWORKAREA, 0, prc, 0 );
	hMonitor = CUIMonitorFromWindow( hWindow, MONITOR_DEFAULTTONEAREST );
	if (hMonitor != NULL) {
		MONITORINFO MonitorInfo = {0};

		MonitorInfo.cbSize = sizeof(MONITORINFO);
		if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
			*prc = MonitorInfo.rcWork;
		}
	}
}


/*   G E T  W O R K  A R E A  F R O M  P O I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void GetWorkAreaFromPoint( POINT pt, RECT *prc )
{
	HMONITOR hMonitor = NULL;

    // We want the screen size - not the working area as we can and do want to overlap toolbars etc.
    // We use the basic function first as a fail-safe.
    prc->left = prc->top = 0;
    prc->right = GetSystemMetrics(SM_CXSCREEN);
    prc->bottom = GetSystemMetrics(SM_CYSCREEN);

    // Now we use the more intelligent function to deal with multiple monitors properly.
    hMonitor = CUIMonitorFromPoint( pt, MONITOR_DEFAULTTONEAREST );
	if (hMonitor != NULL) 
    {
		MONITORINFO MonitorInfo = {0};

		MonitorInfo.cbSize = sizeof(MONITORINFO);
		if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) 
        {
			*prc = MonitorInfo.rcMonitor;
		}
	}
}


/*   A D J U S T  W I N D O W  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void AdjustWindowRect( HWND hWindow, RECT *prc, POINT *pptRef, BOOL fResize )
{
	RECT  rcWorkArea;
	int   cxWindow;
	int   cyWindow;

	cxWindow = prc->right - prc->left;
	cyWindow = prc->bottom - prc->top;

	// get work area

	if (pptRef == NULL) {
		GetWorkAreaFromWindow( hWindow, &rcWorkArea );
	}
	else {
		GetWorkAreaFromPoint( *pptRef, &rcWorkArea );
	}

	// check vertical pos

	if (rcWorkArea.bottom < prc->bottom) {
		if (!fResize) {
			prc->top    = rcWorkArea.bottom - cyWindow;
		}
		prc->bottom = rcWorkArea.bottom;
	}
	if (prc->top < rcWorkArea.top) {
		prc->top    = rcWorkArea.top;
		if (!fResize) {
			prc->bottom = rcWorkArea.top + cyWindow;
		}
	}

	// check horizontal pos

	if (rcWorkArea.right < prc->right) {
		if (!fResize) {
			prc->left  = rcWorkArea.right - cxWindow;
		}
		prc->right = rcWorkArea.right;
	}
	if (prc->left < rcWorkArea.left) {
		prc->left  = rcWorkArea.left;
		if (!fResize) {
			prc->right = rcWorkArea.left + cxWindow;
		}
	}
}


/*   C A L C  W I N D O W  R E C T   */
/*------------------------------------------------------------------------------

	Calculate window rect to fit in the screen

------------------------------------------------------------------------------*/
void CalcWindowRect( RECT *prcDst, const RECT *prcSrc, int cxWindow, int cyWindow, int cxOffset, int cyOffset, WNDALIGNH HAlign, WNDALIGNV VAlign )
{
	RECT  rcNew;
	RECT  rcWorkArea;
	POINT ptRef;

	Assert( prcDst != NULL );
	Assert( prcSrc != NULL );

	// calc rect and reference point

	switch (HAlign) {
		default:
		case ALIGN_LEFT: {
			rcNew.left  = prcSrc->left + cxOffset;
			rcNew.right = prcSrc->left + cxOffset + cxWindow;

			ptRef.x = prcSrc->left;
			break;
		}

		case ALIGN_RIGHT: {
			rcNew.left  = prcSrc->right + cxOffset - cxWindow;
			rcNew.right = prcSrc->right + cxOffset;

			ptRef.x = prcSrc->right;
			break;
		}

		case LOCATE_LEFT: {
			rcNew.left  = prcSrc->left + cxOffset - cxWindow;
			rcNew.right = prcSrc->left + cxOffset;

			ptRef.x = prcSrc->right;
			break;
		}

		case LOCATE_RIGHT: {
			rcNew.left  = prcSrc->right + cxOffset;
			rcNew.right = prcSrc->right + cxOffset + cxWindow;

			ptRef.x = prcSrc->left;
			break;
		}
	}

	switch (VAlign) {
		default:
		case ALIGN_TOP: {
			rcNew.top    = prcSrc->top + cyOffset;
			rcNew.bottom = prcSrc->top + cyOffset + cyWindow;

			ptRef.y = prcSrc->top;
			break;
		}

		case ALIGN_BOTTOM: {
			rcNew.top    = prcSrc->bottom + cyOffset - cyWindow;
			rcNew.bottom = prcSrc->bottom + cyOffset;

			ptRef.y = prcSrc->bottom;
			break;
		}

		case LOCATE_ABOVE: {
			rcNew.top    = prcSrc->top + cyOffset - cyWindow;
			rcNew.bottom = prcSrc->top + cyOffset;

			ptRef.y = prcSrc->bottom;
			break;
		}

		case LOCATE_BELLOW: {
			rcNew.top    = prcSrc->bottom + cyOffset;
			rcNew.bottom = prcSrc->bottom + cyOffset + cyWindow;

			ptRef.y = prcSrc->top;
			break;
		}
	}

	// get work area

	GetWorkAreaFromPoint( ptRef, &rcWorkArea );

	// check vertical pos

	if (rcWorkArea.bottom < rcNew.bottom) {
		if ((VAlign == LOCATE_BELLOW) && (rcWorkArea.top <= prcSrc->top - cyWindow)) {
			rcNew.top    = min( prcSrc->top, rcWorkArea.bottom ) - cyWindow;
			rcNew.bottom = rcNew.top + cyWindow;
		}
		else {
			rcNew.top    = rcWorkArea.bottom - cyWindow;
			rcNew.bottom = rcNew.top + cyWindow;
		}
	}
	if (rcNew.top < rcWorkArea.top) {
		if ((VAlign == LOCATE_ABOVE) && (prcSrc->bottom + cyWindow <= rcWorkArea.bottom)) {
			rcNew.top    = max( prcSrc->bottom, rcWorkArea.top );
			rcNew.bottom = rcNew.top + cyWindow;
		} 
		else {
			rcNew.top    = rcWorkArea.top;
			rcNew.bottom = rcNew.top + cyWindow;
		}
	}

	// check horizontal pos

	if (rcWorkArea.right < rcNew.right) {
		if ((HAlign == LOCATE_RIGHT) && (rcWorkArea.left <= prcSrc->left - cxWindow)) {
			rcNew.left  = min( prcSrc->left, rcWorkArea.right ) - cxWindow;
			rcNew.right = rcNew.left + cxWindow;
		}
		else {
			rcNew.left  = rcWorkArea.right - cxWindow;
			rcNew.right = rcNew.left + cxWindow;
		}
	}
	if (rcNew.left < rcWorkArea.left) {
		if ((HAlign == LOCATE_LEFT) && (prcSrc->right + cxWindow <= rcWorkArea.right)) {
			rcNew.left  = max( prcSrc->right, rcWorkArea.left );
			rcNew.right = rcNew.left + cxWindow;
		}
		else {
			rcNew.left  = rcWorkArea.left;
			rcNew.right = rcNew.left + cxWindow;
		}
	}

	*prcDst = rcNew;
}


/*   G E T  L O G  F O N T   */
/*------------------------------------------------------------------------------

	Get logfont of font

------------------------------------------------------------------------------*/
void GetLogFont( HFONT hFont, LOGFONTW *plf )
{
	if (!FIsWindowsNT()) {
		LOGFONTA lfA;

		GetObjectA( hFont, sizeof(LOGFONTA), &lfA );
		ConvertLogFontAtoW( &lfA, plf );
		return;
	}

	GetObjectW( hFont, sizeof(LOGFONTW), plf );
}


/*   G E T  N O N  C L I E N T  L O G  F O N T   */
/*------------------------------------------------------------------------------

	Get logfont of non-client font 

------------------------------------------------------------------------------*/
void GetNonClientLogFont( NONCLIENTFONT ncfont, LOGFONTW *plf )
{
	if (!FIsWindowsNT()) {
		NONCLIENTMETRICSA ncmA = {0};
		LOGFONTA lf;

		ncmA.cbSize = sizeof(ncmA);
		SystemParametersInfoA( SPI_GETNONCLIENTMETRICS, sizeof(ncmA), &ncmA, 0 );

		switch (ncfont) {
			default:
			case NCFONT_CAPTION: {
				lf = ncmA.lfCaptionFont;
				break;
			}
			case NCFONT_SMCAPTION: {
				lf = ncmA.lfSmCaptionFont;
				break;
			}
			case NCFONT_MENU: {
				lf = ncmA.lfMenuFont;
				break;
			}
			case NCFONT_STATUS: {
				lf = ncmA.lfStatusFont;
				break;
			}
			case NCFONT_MESSAGE: {
				lf = ncmA.lfMessageFont;
				break;
			}
		}

		ConvertLogFontAtoW( &lf, plf );
	}
	else {
		NONCLIENTMETRICSW ncmW = {0};
		LOGFONTW lf;

		ncmW.cbSize = sizeof(ncmW);
		SystemParametersInfoW( SPI_GETNONCLIENTMETRICS, sizeof(ncmW), &ncmW, 0 );

		switch (ncfont) {
			default:
			case NCFONT_CAPTION: {
				lf = ncmW.lfCaptionFont;
				break;
			}
			case NCFONT_SMCAPTION: {
				lf = ncmW.lfSmCaptionFont;
				break;
			}
			case NCFONT_MENU: {
				lf = ncmW.lfMenuFont;
				break;
			}
			case NCFONT_STATUS: {
				lf = ncmW.lfStatusFont;
				break;
			}
			case NCFONT_MESSAGE: {
				lf = ncmW.lfMessageFont;
				break;
			}
		}

		*plf = lf;
	}
}


void DrawTriangle( HDC hDC, const RECT *prc, COLORREF col, DWORD dwFlag )
{
	HPEN  hPen;
	HPEN  hPenOld;
	POINT ptTriOrg;
	int   nTriHeight;
	int   nTriWidth;
	SIZE  size;
	int   i;

	size.cx = prc->right - prc->left;
	size.cy = prc->bottom - prc->top;

	switch ( dwFlag ) {

	case UIFDCTF_RIGHTTOLEFT:
	case UIFDCTF_LEFTTORIGHT:
		nTriHeight = min ( size.cx, size.cy ) / 3;
		nTriHeight = nTriHeight - ( nTriHeight % 2 ) + 1;   //  Make an odd number
		nTriWidth  = nTriHeight / 2 + 1;
		break;

	case UIFDCTF_BOTTOMTOTOP:
	case UIFDCTF_TOPTOBOTTOM:
		nTriWidth  = min ( size.cx, size.cy ) / 3;
		nTriWidth  = nTriWidth - ( nTriWidth % 2 ) + 1;
		nTriHeight = nTriWidth / 2 + 1;
		break;

	case UIFDCTF_MENUDROP:
		nTriWidth  = 5;
		nTriHeight = 3;
		break;
	}

	ptTriOrg.x = prc->left + (size.cx - nTriWidth) / 2;
	ptTriOrg.y = prc->top + (size.cy - nTriHeight) / 2;

	hPen = CreatePen( PS_SOLID, 0, col );
	hPenOld = (HPEN)SelectObject(hDC, hPen);

	switch ( dwFlag & UIFDCTF_DIRMASK ) {

	case UIFDCTF_RIGHTTOLEFT:
		for (i = 0; i < nTriWidth; i++) {
			MoveToEx( hDC, ptTriOrg.x + nTriWidth - i, ptTriOrg.y + i, NULL );
			LineTo( hDC,   ptTriOrg.x + nTriWidth - i, ptTriOrg.y + nTriHeight - i );
		}
		break;

	case UIFDCTF_BOTTOMTOTOP:
		for (i = 0; i < nTriHeight; i++) {
			MoveToEx( hDC, ptTriOrg.x + i, ptTriOrg.y + nTriHeight - i, NULL );
			LineTo( hDC,   ptTriOrg.x + nTriWidth - i, ptTriOrg.y + nTriHeight - i );
		}
		break;

	case UIFDCTF_LEFTTORIGHT:
		for (i = 0; i < nTriWidth; i++) {
			MoveToEx( hDC, ptTriOrg.x + i, ptTriOrg.y + i, NULL );
			LineTo( hDC,   ptTriOrg.x + i, ptTriOrg.y + nTriHeight - i );
		}
		break;

	case UIFDCTF_TOPTOBOTTOM:
		for (i = 0; i < nTriHeight; i++) {
			MoveToEx( hDC, ptTriOrg.x + i, ptTriOrg.y + i, NULL );
			LineTo( hDC,   ptTriOrg.x + nTriWidth - i, ptTriOrg.y + i );
		}
		break;
	}

	SelectObject( hDC, hPenOld );
	DeleteObject( hPen );
}


/*   O U R  C R E A T E  S I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
static PSID OurCreateSid( DWORD dwSubAuthority )
{
	PSID        psid;
	BOOL        fResult;
	SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

	//
	// allocate and initialize an SID
	// 
	fResult = AllocateAndInitializeSid( &SidAuthority,
										1,
										dwSubAuthority,
										0,0,0,0,0,0,0,
										&psid );
	if ( ! fResult ) {
		return NULL;
	}

	if ( ! IsValidSid( psid ) ) {
		FreeSid( psid );
		return NULL;
	}

	return psid;
}


/*   C R E A T E  S E C U R I T Y  A T T R I B U T E S   */
/*------------------------------------------------------------------------------

//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//

------------------------------------------------------------------------------*/

#if 0

static PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
	PSECURITY_ATTRIBUTES psa;
	PSECURITY_DESCRIPTOR psd;
	PACL                 pacl;
	DWORD                cbacl;

	PSID                 psid1, psid2, psid3, psid4;
	BOOL                 fResult;

	psid1 = OurCreateSid( SECURITY_INTERACTIVE_RID );
	if ( psid1 == NULL ) {
		return NULL;
	} 

	psid2 = OurCreateSid( SECURITY_LOCAL_SYSTEM_RID );
	if ( psid2 == NULL ) {
		FreeSid ( psid1 );
		return NULL;
	} 

	psid3 = OurCreateSid( SECURITY_SERVICE_RID );
	if ( psid3 == NULL ) {
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		return NULL;
	}

	psid4 = OurCreateSid( SECURITY_NETWORK_RID );
	if ( psid4 == NULL ) {
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		return NULL;
	}
	//
	// allocate and initialize an access control list (ACL) that will 
	// contain the SIDs we've just created.
	//
	cbacl =  sizeof(ACL) + 
			 (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 4 + 
			 GetLengthSid(psid1) + GetLengthSid(psid2) + GetLengthSid(psid3) + GetLengthSid(psid4);

	pacl = (PACL)LocalAlloc( LMEM_FIXED, cbacl );
	if ( pacl == NULL ) {
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		FreeSid ( psid4 );
		return NULL;
	}

	fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
	if ( ! fResult ) {
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		FreeSid ( psid4 );
		LocalFree( pacl );
		return NULL;
	}

	//
	// adds an access-allowed ACE for interactive users to the ACL
	// 
	fResult = AddAccessAllowedAce( pacl,
								   ACL_REVISION,
								   GENERIC_ALL,
								   psid1 );

	if ( !fResult ) {
		LocalFree( pacl );
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		FreeSid ( psid4 );
		return NULL;
	}

	//
	// adds an access-allowed ACE for operating system to the ACL
	// 
	fResult = AddAccessAllowedAce( pacl,
								   ACL_REVISION,
								   GENERIC_ALL,
								   psid2 );

	if ( !fResult ) {
		LocalFree( pacl );
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		FreeSid ( psid4 );
		return NULL;
	}

	//
	// adds an access-allowed ACE for operating system to the ACL
	// 
	fResult = AddAccessAllowedAce( pacl,
								   ACL_REVISION,
								   GENERIC_ALL,
								   psid3 );

	if ( !fResult ) {
		LocalFree( pacl );
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		FreeSid ( psid4 );
		return NULL;
	}

	//
	// adds an access-allowed ACE for operating system to the ACL
	// 
	fResult = AddAccessAllowedAce( pacl,
								   ACL_REVISION,
								   GENERIC_ALL,
								   psid4 );

	if ( !fResult ) {
		LocalFree( pacl );
		FreeSid ( psid1 );
		FreeSid ( psid2 );
		FreeSid ( psid3 );
		FreeSid ( psid4 );
		return NULL;
	}

	//
	// Those SIDs have been copied into the ACL. We don't need'em any more.
	//
	FreeSid ( psid1 );
	FreeSid ( psid2 );
	FreeSid ( psid3 );
	FreeSid ( psid4 );

	//
	// Let's make sure that our ACL is valid.
	//
	if (!IsValidAcl(pacl)) {
		LocalFree( pacl );
		return NULL;
	}

	//
	// allocate security attribute
	//
	psa = (PSECURITY_ATTRIBUTES)LocalAlloc( LMEM_FIXED, sizeof( SECURITY_ATTRIBUTES ) );
	if ( psa == NULL ) {
		LocalFree( pacl );
		return NULL;
	}
	
	//
	// allocate and initialize a new security descriptor
	//
	psd = LocalAlloc( LMEM_FIXED, SECURITY_DESCRIPTOR_MIN_LENGTH );
	if ( psd == NULL ) {
		LocalFree( pacl );
		LocalFree( psa );
		return NULL;
	}

	if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
		LocalFree( pacl );
		LocalFree( psa );
		LocalFree( psd );
		return NULL;
	}


	fResult = SetSecurityDescriptorDacl( psd,
										 TRUE,
										 pacl,
										 FALSE );

	// The discretionary ACL is referenced by, not copied 
	// into, the security descriptor. We shouldn't free up ACL
	// after the SetSecurityDescriptorDacl call. 

	if ( ! fResult ) {
		LocalFree( pacl );
		LocalFree( psa );
		LocalFree( psd );
		return NULL;
	} 

	if (!IsValidSecurityDescriptor(psd)) {
		LocalFree( pacl );
		LocalFree( psa );
		LocalFree( psd );
		return NULL;
	}

	//
	// everything is done
	//
	psa->nLength = sizeof( SECURITY_ATTRIBUTES );
	psa->lpSecurityDescriptor = (PVOID)psd;
	psa->bInheritHandle = TRUE;

	return psa;
}

#endif // 0

/*   F R E E  S E C U R I T Y  A T T R I B U T E S   */
/*------------------------------------------------------------------------------

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//

------------------------------------------------------------------------------*/

#if 0

static void FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
	BOOL fResult;
	BOOL fDaclPresent;
	BOOL fDaclDefaulted;
	PACL pacl;

	fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
										 &fDaclPresent,
										 &pacl,
										 &fDaclDefaulted );                  
	if ( fResult ) {
		if ( pacl != NULL )
			LocalFree( pacl );
	}

	LocalFree( psa->lpSecurityDescriptor );
	LocalFree( psa );
}

#endif // 0

/*   I N I T  C A N D  U I  S E C U R I T Y  A T T R I B U T E S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitCandUISecurityAttributes( void )
{
	g_psa = NULL;

    // disabled for whistler bug 305970
    // CreateSecurityAttributes creates a sid with SECURITY_INTERACTIVE_RID, which
    // allows any user access to the mutex.  But g_psa is only used to guard
    // some shared memory and a mutex that are used on a single desktop (the
    // objects have names that are unique to their desktops).  So we can just
    // leave g_psa NULL so long as it is only used for objects on a single
    // desktop.
#if 0
	if (FIsWindowsNT()) {
		g_psa = CreateSecurityAttributes();
	}
#endif // 0
}


/*   D O N E  C A N D  U I  S E C U R I T Y  A T T R I B U T E S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneCandUISecurityAttributes( void )
{
#if 0
	if (g_psa != NULL) {
		FreeSecurityAttributes( g_psa );
		g_psa = NULL;
	}
#endif // 0
}


/*   G E T  C A N D  U I  S E C U R I T Y  A T T R I B U T E S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
PSECURITY_ATTRIBUTES GetCandUISecurityAttributes( void )
{
	return g_psa;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candprop.h ===
//
// candprop.h - CandidateUI Property Manager
//

#ifndef CANDPROP_H
#define CANDPROP_H

#include "propdata.h"
#include "candutil.h"

class CCandidateUI;
class CCandUIObjectMgr;
class CCandUIPropertyMgr;
class CCandUIPropertyEventSink;

#define CANDUIPROPSINK_MAX		4


//
// CandidateUI property
//

typedef enum _CANDUIPROPERTY
{
	CANDUIPROP_CANDWINDOW,
	CANDUIPROP_CANDLISTBOX,
	CANDUIPROP_CANDSTRING,
	CANDUIPROP_CANDINDEX,
	CANDUIPROP_INLINECOMMENT,
	CANDUIPROP_POPUPCOMMENTWINDOW,
	CANDUIPROP_POPUPCOMMENTTITLE,
	CANDUIPROP_POPUPCOMMENTTEXT,
	CANDUIPROP_MENUBUTTON,
	CANDUIPROP_EXTRACANDIDATE,
	CANDUIPROP_CANDRAWDATA,
	CANDUIPROP_WINDOWCAPTION,
	CANDUIPROP_TOOLTIP,
	CANDUIPROP_CANDTIPWINDOW,
	CANDUIPROP_CANDTIPBUTTON,
} CANDUIPROPERTY;


//
// CandidateUI property event
//

typedef enum _CANDUIPROPERTYEVENT
{
	CANDUIPROPEV_UPDATEENABLESTATE,
	CANDUIPROPEV_UPDATEVISIBLESTATE,
	CANDUIPROPEV_UPDATEPOSITION,
	CANDUIPROPEV_UPDATESIZE,
	CANDUIPROPEV_UPDATEFONT,
	CANDUIPROPEV_UPDATETEXT,
	CANDUIPROPEV_UPDATETOOLTIP,
	CANDUIPROPEV_UPDATETEXTFLOW,
	CANDUIPROPEV_UPDATECANDLINES,
	CANDUIPROPEV_UPDATEPOPUPDELAY,
} CANDUIPROPERTYEVENT;


//
// CCandUIObjectEventSink
//  = object event sink =
//

class CCandUIObjectEventSink
{
public:
	CCandUIObjectEventSink( void );
	virtual ~CCandUIObjectEventSink( void );

	HRESULT InitEventSink( CCandUIObjectMgr *pObjectMgr );
	HRESULT DoneEventSink( void );

	//
	// callback functions
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event )   = 0;	/* PURE */

protected:
	CCandUIObjectMgr *m_pObjectMgr;

	__inline CCandUIObjectMgr *GetUIObjectMgr( void )
	{
		return m_pObjectMgr;
	}
};


//
// CCandUIObjectProperty
//  = property of CandidateUI object (base class) =
//

class CCandUIObjectProperty
{
public:
	CCandUIObjectProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandUIObjectProperty( void );

	HRESULT Enable( void );
	HRESULT Disable( void );
	HRESULT IsEnabled( BOOL *pfEnabled );
	HRESULT Show( void );
	HRESULT Hide( void );
	HRESULT IsVisible( BOOL *pfVisible );
	HRESULT SetPosition( POINT *pptPos );
	HRESULT GetPosition( POINT *pptPos );
	HRESULT SetSize( SIZE *psize );
	HRESULT GetSize( SIZE *psize );
	HRESULT SetFont( LOGFONTW *plf );
	HRESULT GetFont( LOGFONTW *plf );
	HRESULT SetText( BSTR bstr );
	HRESULT GetText( BSTR *pbstr );
	HRESULT SetToolTipString( BSTR bstr );
	HRESULT GetToolTipString( BSTR *pbstr );

	BOOL IsEnabled( void );
	BOOL IsVisible( void );
	HFONT GetFont( void );
	LPCWSTR GetText( void );
	LPCWSTR GetToolTipString( void );

	virtual void OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj ) = 0;	/* PURE */

protected:
	CCandUIPropertyMgr *m_pPropMgr;

	struct
	{
		BOOL fAllowEnable       : 1;
		BOOL fAllowDisable      : 1;
		BOOL fAllowIsEnabled    : 1;
		BOOL fAllowShow         : 1;
		BOOL fAllowHide         : 1;
		BOOL fAllowIsVisible    : 1;
		BOOL fAllowSetPosition  : 1;
		BOOL fAllowGetPosition  : 1;
		BOOL fAllowSetSize      : 1;
		BOOL fAllowGetSize      : 1;
		BOOL fAllowSetFont      : 1;
		BOOL fAllowGetFont      : 1;
		BOOL fAllowSetText      : 1;
		BOOL fAllowGetText      : 1;
		BOOL fAllowSetToolTip   : 1;
		BOOL fAllowGetToolTip   : 1;
		BOOL : 0;
	} m_flags;

	CPropBool	m_propEnabled;
	CPropBool	m_propVisible;
	CPropPoint	m_propPos;
	CPropSize	m_propSize;
	CPropFont	m_propFont;
	CPropText	m_propText;
	CPropText	m_propToolTip;

	void NotifyUpdate( CANDUIPROPERTYEVENT event );

	__inline CCandUIPropertyMgr *GetPropertyMgr( void )
	{
		return m_pPropMgr;
	}

	__inline virtual CANDUIPROPERTY GetPropType( void ) = 0;	/* PURE */
};


//
// CCandWindowProperty
//  = property of candidate window =
//

class CCandWindowProperty : public CCandUIObjectProperty,
							public CCandUIObjectEventSink
{
public:
	CCandWindowProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandWindowProperty( void );

	HRESULT GetWindow( HWND *phWnd );
	HRESULT SetUIDirection( CANDUIUIDIRECTION uidir );
	HRESULT GetUIDirection( CANDUIUIDIRECTION *puidir );
	HRESULT EnableAutoMove( BOOL fEnable );
	HRESULT IsAutoMoveEnabled( BOOL *pfEnabled );

	CANDUIUIDIRECTION GetUIDirection( void );
	BOOL IsAutoMoveEnabled( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	CANDUIUIDIRECTION m_uidir;
	CPropBool         m_propAutoMoveEnabled;
	HWND              m_hWnd;

	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDWINDOW;
	}
};


//
// CCandListBoxProperty
//  = property of candidate list box =
//

class CCandListBoxProperty : public CCandUIObjectProperty,
							 public CCandUIObjectEventSink
{
public:
	CCandListBoxProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandListBoxProperty( void );

	HRESULT SetHeight( LONG lLines );
	HRESULT GetHeight( LONG *plLines );
	HRESULT GetCandidateStringRect( ULONG nIndex, RECT *prc );

	LONG GetHeight( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	CPropLong      m_propHeight;

	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDLISTBOX;
	}
};


//
// CCandStringProperty
//  = property of candidate string =
//

class CCandStringProperty : public CCandUIObjectProperty
{
public:
	CCandStringProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandStringProperty( void );

	virtual void OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDSTRING;
	}
};


//
// CInlineCommentProperty
//  = property of inline comment =
//

class CInlineCommentProperty : public CCandUIObjectProperty
{
public:
	CInlineCommentProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CInlineCommentProperty( void );

	virtual void OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_INLINECOMMENT;
	}
};


//
// CCandIndexProperty
//  = property of candidate index =
//

class CCandIndexProperty : public CCandUIObjectProperty
{
public:
	CCandIndexProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandIndexProperty( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDINDEX;
	}
};


//
// CPopupCommentWindowProperty
//  = property of popup comment window =
//

class CPopupCommentWindowProperty : public CCandUIObjectProperty,
									public CCandUIObjectEventSink
{
public:
	CPopupCommentWindowProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CPopupCommentWindowProperty( void );

	HRESULT GetWindow( HWND *phWnd );
	HRESULT SetDelayTime( LONG lTime );
	HRESULT GetDelayTime( LONG *plTime );
	HRESULT EnableAutoMove( BOOL fEnable );
	HRESULT IsAutoMoveEnabled( BOOL *pfEnabled );

	LONG GetDelayTime( void );
	BOOL IsAutoMoveEnabled( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	CPropLong m_propDelayTime;
	CPropBool m_propAutoMoveEnabled;
	HWND      m_hWnd;

	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_POPUPCOMMENTWINDOW;
	}
};


//
// CPopupCommentTitleProperty
//  = property of popup comment title =
//

class CPopupCommentTitleProperty : public CCandUIObjectProperty
{
public:
	CPopupCommentTitleProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CPopupCommentTitleProperty( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_POPUPCOMMENTTITLE;
	}
};


//
// CPopupCommentTextProperty
//  = property of popup comment text =
//

class CPopupCommentTextProperty : public CCandUIObjectProperty
{
public:
	CPopupCommentTextProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CPopupCommentTextProperty( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_POPUPCOMMENTTEXT;
	}
};


//
// CWindowCaptionProperty
//  = property of window caption =
//

class CWindowCaptionProperty : public CCandUIObjectProperty,
							   public CCandUIObjectEventSink

{
public:
	CWindowCaptionProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CWindowCaptionProperty( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_WINDOWCAPTION;
	}
};


//
// CMenuButtonProperty
//  = property of menu button =
//

class CMenuButtonProperty : public CCandUIObjectProperty,
							public CCandUIObjectEventSink

{
public:
	CMenuButtonProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CMenuButtonProperty( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

	//
	// temp
	//
	void SetEventSink( ITfCandUIMenuEventSink *pSink )
	{
		SafeReleaseClear( m_pSink );

		m_pSink = pSink;
		m_pSink->AddRef();
	}

	ITfCandUIMenuEventSink *GetEventSink( void )
	{
		return m_pSink;
	}

	void ReleaseEventSink( void )
	{
		SafeReleaseClear( m_pSink );
	}

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_MENUBUTTON;
	}

	ITfCandUIMenuEventSink	*m_pSink;
};


//
// CExtraCandidateProperty
//  = property of extra candidate list =
//

class CExtraCandidateProperty : public CCandUIObjectProperty,
								public CCandUIObjectEventSink

{
public:
	CExtraCandidateProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CExtraCandidateProperty( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_EXTRACANDIDATE;
	}
};


//
// CCandRawDataProperty
//  = property of candidate rawdata =
//

class CCandRawDataProperty : public CCandUIObjectProperty,
							 public CCandUIObjectEventSink

{
public:
	CCandRawDataProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandRawDataProperty( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDRAWDATA;
	}
};


//
// CToolTipProperty
//  = property of tooltip =
//

class CToolTipProperty : public CCandUIObjectProperty
{
public:
	CToolTipProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CToolTipProperty( void );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_TOOLTIP;
	}
};


//
// CCandTipWindowProperty
//  = property of candtip window =
//

class CCandTipWindowProperty : public CCandUIObjectProperty,
							   public CCandUIObjectEventSink
{
public:
	CCandTipWindowProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandTipWindowProperty( void );

	HRESULT GetWindow( HWND *phWnd );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	HWND      m_hWnd;

	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDTIPWINDOW;
	}
};


//
// CCandTipButtonProperty
//  = property of candtip button =
//

class CCandTipButtonProperty : public CCandUIObjectProperty,
							   public CCandUIObjectEventSink

{
public:
	CCandTipButtonProperty( CCandUIPropertyMgr *pPropMgr );
	virtual ~CCandTipButtonProperty( void );

	//
	// CCandUIObjectEventSink method
	//
	virtual void OnObjectEvent( enum _CANDUIOBJECT obj, enum _CANDUIOBJECTEVENT event );

	//
	// interface object functions
	//
	virtual HRESULT CreateInterfaceObject( REFIID riid, void **ppvObj );

protected:
	__inline virtual CANDUIPROPERTY GetPropType( void )
	{
		return CANDUIPROP_CANDTIPBUTTON;
	}
};


//
// CCandUIPropertyMgr
//  = CandidateUI property manager =
//

class CCandUIPropertyMgr
{
public:
	CCandUIPropertyMgr( void );
	virtual ~CCandUIPropertyMgr( void );

	HRESULT Initialize( CCandidateUI *pCandUI );
	HRESULT Uninitialize( void );

	HRESULT AdviseEventSink( CCandUIPropertyEventSink *pSink );
	HRESULT UnadviseEventSink( CCandUIPropertyEventSink *pSink );
	void NotifyPropertyUpdate( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event );

	__inline CCandWindowProperty *GetCandWindowProp( void )
	{
		return m_pCandWindowProp;
	}

	__inline CCandListBoxProperty *GetCandListBoxProp( void )
	{
		return m_pCandListBoxProp;
	}

	__inline CCandStringProperty *GetCandStringProp( void )
	{
		return m_pCandStringProp;
	}

	__inline CCandIndexProperty *GetCandIndexProp( void )
	{
		return m_pCandIndexProp;
	}

	__inline CInlineCommentProperty *GetInlineCommentProp( void )
	{
		return m_pInlineCommentProp;
	}

	__inline CPopupCommentWindowProperty *GetPopupCommentWindowProp( void )
	{
		return m_pPopupCommentWindowProp;
	}

	__inline CPopupCommentTitleProperty *GetPopupCommentTitleProp( void )
	{
		return m_pPopupCommentTitleProp;
	}

	__inline CPopupCommentTextProperty *GetPopupCommentTextProp( void )
	{
		return m_pPopupCommentTextProp;
	}

	__inline CMenuButtonProperty *GetMenuButtonProp( void )
	{
		return m_pMenuButtonProp;
	}

	__inline CWindowCaptionProperty *GetWindowCaptionProp( void )
	{
		return m_pWindowCaptionProp;
	}

	__inline CToolTipProperty *GetToolTipProp( void )
	{
		return m_pToolTipProp;
	}

	__inline CExtraCandidateProperty *GetExtraCandidateProp( void )
	{
		return m_pExtraCandidateProp;
	}

	__inline CCandRawDataProperty *GetCandRawDataProp( void )
	{
		return m_pCandRawDataProp;
	}

	__inline CCandTipWindowProperty *GetCandTipWindowProp( void )
	{
		return m_pCandTipWindowProp;
	}

	__inline CCandTipButtonProperty *GetCandTipButtonProp( void )
	{
		return m_pCandTipButtonProp;
	}


	//
	// 
	//
	HRESULT GetObject( REFIID riid, void **ppvObj );

	//
	//
	//
	__inline CCandidateUI *GetCandidateUI( void )
	{
		return m_pCandUI;
	}

protected:
	CCandidateUI                *m_pCandUI;
	CCandUIPropertyEventSink    *m_rgSink[ CANDUIPROPSINK_MAX ];

	CCandWindowProperty         *m_pCandWindowProp;
	CCandListBoxProperty        *m_pCandListBoxProp;
	CCandStringProperty         *m_pCandStringProp;
	CCandIndexProperty          *m_pCandIndexProp;
	CInlineCommentProperty      *m_pInlineCommentProp;
	CPopupCommentWindowProperty *m_pPopupCommentWindowProp;
	CPopupCommentTitleProperty  *m_pPopupCommentTitleProp;
	CPopupCommentTextProperty   *m_pPopupCommentTextProp;
	CMenuButtonProperty         *m_pMenuButtonProp;
	CWindowCaptionProperty      *m_pWindowCaptionProp;
	CToolTipProperty            *m_pToolTipProp;
	CExtraCandidateProperty     *m_pExtraCandidateProp;
	CCandRawDataProperty        *m_pCandRawDataProp;
	CCandTipWindowProperty      *m_pCandTipWindowProp;
	CCandTipButtonProperty      *m_pCandTipButtonProp;
};


//
// CCandUIPropertyEventSink
//  = property event sink =
//

class CCandUIPropertyEventSink
{
public:
	CCandUIPropertyEventSink( void );
	virtual ~CCandUIPropertyEventSink( void );

	HRESULT InitEventSink( CCandUIPropertyMgr *pPropertyMgr );
	HRESULT DoneEventSink( void );

	//
	// callback functions
	//
	virtual void OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )   = 0;	/* PURE */

protected:
	CCandUIPropertyMgr *m_pPropertyMgr;

	__inline CCandUIPropertyMgr *GetPropertyMgr( void )
	{
		return m_pPropertyMgr;
	}
};

#endif // CANDPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\candutil.h ===
//
// candutil.h
//

#ifndef CANDUTIL_H
#define CANDUTIL_H

#include "private.h"


//
// definitions 
//

// direction (CreateRotateBitmap)

typedef enum {
	CANGLE0,
	CANGLE90,
	CANGLE180,
	CANGLE270,
} CANDANGLE;


// window alignment (CalcWindowRect)

typedef enum {
	ALIGN_LEFT,
	ALIGN_RIGHT,
	LOCATE_LEFT,
	LOCATE_RIGHT,
} WNDALIGNH;

typedef enum {
	ALIGN_TOP,
	ALIGN_BOTTOM,
	LOCATE_ABOVE,
	LOCATE_BELLOW,
} WNDALIGNV;


// non-client font

typedef enum _NONCLIENTFONT {
	NCFONT_CAPTION,
	NCFONT_SMCAPTION,
	NCFONT_MENU,
	NCFONT_STATUS,
	NCFONT_MESSAGE,
} NONCLIENTFONT;


// DrawCtrlTriangle flags

#define UIFDCTF_RIGHTTOLEFT                 0x00000000
#define UIFDCTF_BOTTOMTOTOP                 0x00000001
#define UIFDCTF_LEFTTORIGHT                 0x00000002
#define UIFDCTF_TOPTOBOTTOM                 0x00000003

#define UIFDCTF_MENUDROP                    0x00010003

#define UIFDCTF_DIRMASK                     0x00000003


//
// theme API definition
//

typedef HANDLE HTHEME;          // handle to a section of theme data for class


//
// functions
//

extern BOOL FIsWindowsNT( void );
extern UINT CpgFromChs( BYTE chs );
extern void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA );
extern void ConvertLogFontAtoW( CONST LOGFONTA *plfA, LOGFONTW *plfW );
extern HFONT OurCreateFontIndirectW( CONST LOGFONTW *plfW );
extern int GetFontHeightOfFont( HDC hDC, HFONT hFont );
extern int CompareString( LPCWSTR pchStr1, LPCWSTR pchStr2, int cch );
extern HBITMAP CreateRotateBitmap( HBITMAP hBmpSrc, HPALETTE hPalette, CANDANGLE angle );
extern void GetTextExtent( HFONT hFont, LPCWSTR pwchText, int cch, SIZE *psize, BOOL fHorizontal );
extern void GetWorkAreaFromWindow( HWND hWindow, RECT *prc );
extern void GetWorkAreaFromPoint( POINT pt, RECT *prcWorkArea );
extern void AdjustWindowRect( HWND hWindow, RECT *prc, POINT *pptRef, BOOL fResize );
extern void CalcWindowRect( RECT *prcTrg, const RECT *prcSrc, int cxWindow, int cyWindow, int cxOffset, int cyOffset, WNDALIGNH HAlign, WNDALIGNV VAlign );
extern void GetLogFont( HFONT hFont, LOGFONTW *plf );
extern void GetNonClientLogFont( NONCLIENTFONT ncfont, LOGFONTW *plf );
extern void DrawTriangle( HDC hDC, const RECT *prc, COLORREF col, DWORD dwDirection );
extern void InitCandUISecurityAttributes( void );
extern void DoneCandUISecurityAttributes( void );
PSECURITY_ATTRIBUTES GetCandUISecurityAttributes( void );


#if 0
//
// theme API functions
//

extern BOOL FIsThemeAPIAvail( void );
extern BOOL OurIsThemeActive( void );
extern HTHEME OurOpenThemeData( HWND hwnd, LPCWSTR pszClassList );
extern HRESULT OurCloseThemeData( HTHEME hTheme );
extern HRESULT OurDrawThemeBackground( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pRect, DWORD dwBgFlags );
extern HRESULT OurDrawThemeText( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
extern HRESULT OurDrawThemeIcon( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex );
extern HRESULT OurGetThemeBackgroundExtent( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pContentRect, RECT *pExtentRect );
extern HRESULT OurGetThemeBackgroundContentRect( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
extern HRESULT OurGetThemeTextExtent( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect );
extern HRESULT OurGetThemePartSize( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, enum THEMESIZE eSize, SIZE *pSize );
#endif 

#endif /* CANDUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "sharemem.h"
#include "ciccs.h"

extern HINSTANCE g_hInst;
extern CCicCriticalSectionStatic g_cs;

// shared data

extern CCandUIShareMem g_ShareMem;

// private message

extern UINT g_msgHookedMouse;
extern UINT g_msgHookedKey;

// security attribute

extern PSECURITY_ATTRIBUTES g_psa;

// guid data

extern const GUID GUID_COMPARTMENT_CANDUI_KEYTABLE;
extern const GUID GUID_COMPARTMENT_CANDUI_UISTYLE;
extern const GUID GUID_COMPARTMENT_CANDUI_UIOPTION;

// name definition

#define SZNAME_SHAREDDATA_MMFILE	TEXT( "{DEDD9EF2-F937-4b49-81D4-EAB8E12A4E10}." )
#define SZNAME_SHAREDDATA_MUTEX		TEXT( "{D90415F2-C66C-45bd-8A84-61FE5137E440}." )
#define SZMSG_HOOKEDMOUSE			TEXT( "MSCandUI.MouseEvent" )
#define SZMSG_HOOKEDKEY				TEXT( "MSCandUI.KeyEvent" )

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\cuicand.cpp ===
//
// cuicand.cpp - ui frame object for candidate UI
//

#include "private.h"
#include "cuilib.h"
#include "cuicand.h"

#include "candutil.h"
#include "wcand.h"


//
//
//

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S M A R T  S C R O L L  B U T T O N                             */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSmartScrollButton
//

/*   C  U I F  S M A R T  S C R O L L  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CUIFSmartScrollButton

------------------------------------------------------------------------------*/
CUIFSmartScrollButton::CUIFSmartScrollButton( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle ) : CUIFScrollButton( pUIScroll, prc, dwStyle )
{
	SetActiveTheme(L"scrollbar", SBP_ARROWBTN);
}


/*   ~  C  U I F  S M A R T  S C R O L L  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CUIFSmartScrollButton

------------------------------------------------------------------------------*/
CUIFSmartScrollButton::~CUIFSmartScrollButton( void )
{
}


/*   O N  P A I N T  N O T H E M E */
/*------------------------------------------------------------------------------

	Paint procedure of smart scoll button object (default)

------------------------------------------------------------------------------*/
void CUIFSmartScrollButton::OnPaintNoTheme( HDC hDC )
{
	UINT uState = 0;

	switch (m_dwStyle & UISCROLLBUTTON_DIRMASK) {
		case UISCROLLBUTTON_LEFT: {
			uState = DFCS_SCROLLLEFT;
			break;
		}

		case UISCROLLBUTTON_UP: {
			uState = DFCS_SCROLLUP;
			break;
		}

		case UISCROLLBUTTON_RIGHT: {
			uState = DFCS_SCROLLRIGHT;
			break;
		}

		case UISCROLLBUTTON_DOWN: {
			uState = DFCS_SCROLLDOWN;
			break;
		}
	}

	//

	uState |= ((m_dwStatus == UIBUTTON_DOWN) ? DFCS_PUSHED | DFCS_FLAT : 0);
	uState |= ((!IsEnabled()) ? DFCS_INACTIVE : 0);

    RECT rc = GetRectRef();
	DrawFrameControl( hDC, &rc, DFC_SCROLL, uState | DFCS_FLAT );
	DrawEdge( hDC, &rc, (m_dwStatus == UIBUTTON_DOWN) ? BDR_SUNKENINNER : BDR_RAISEDINNER, BF_RECT );

}


/*   O N  P A I N T  T H E M E */
/*------------------------------------------------------------------------------

	Paint procedure of smart scoll button object (Whistler)

------------------------------------------------------------------------------*/
BOOL CUIFSmartScrollButton::OnPaintTheme( HDC hDC )
{
	BOOL   fRet = FALSE;

	if (!IsThemeActive()) {
		return FALSE;
	}

    if (SUCCEEDED(EnsureThemeData( GetUIWnd()->GetWnd()))) {
		int    iStateID;

		switch (m_dwStyle & UISCROLLBUTTON_DIRMASK) {
			case UISCROLLBUTTON_LEFT: {
				iStateID = ABS_LEFTNORMAL;
				break;
			}

			case UISCROLLBUTTON_UP: {
				iStateID = ABS_UPNORMAL;
				break;
			}

			case UISCROLLBUTTON_RIGHT: {
				iStateID = ABS_RIGHTNORMAL;
				break;
			}

			case UISCROLLBUTTON_DOWN: {
				iStateID = ABS_DOWNNORMAL;
				break;
			}
		}

		if (!IsEnabled()) {
			iStateID += 3;
		}
		else if (m_dwStatus == UIBUTTON_DOWN) {
			iStateID += 2;
		}
//		else if (m_dwStatus != UIBUTTON_NORMAL) {
//			iStateID += 1;
//		}

		fRet = SUCCEEDED(DrawThemeBackground(hDC, iStateID, &GetRectRef(), 0));

	}

	return fRet;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S M A R T  S C R O L L  T H U M B                               */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSmartScrollThumb
//

/*   C  U I F  S M A R T  S C R O L L  T H U M B   */
/*------------------------------------------------------------------------------

	Constructor of CUIFSmartScrollThumb

------------------------------------------------------------------------------*/
CUIFSmartScrollThumb::CUIFSmartScrollThumb( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle ) : CUIFScrollThumb( pUIScroll, prc, dwStyle )
{
	m_fMouseIn = FALSE;
	SetActiveTheme(L"scrollbar");
}


/*   ~  C  U I F  S M A R T  S C R O L L  T H U M B   */
/*------------------------------------------------------------------------------

	Destructor of CUIFSmartScrollThumb

------------------------------------------------------------------------------*/
CUIFSmartScrollThumb::~CUIFSmartScrollThumb( void )
{
}


/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFSmartScrollThumb::OnMouseIn( POINT pt )
{
	m_fMouseIn = TRUE;
	CallOnPaint();

	CUIFScrollThumb::OnMouseIn( pt );
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFSmartScrollThumb::OnMouseOut( POINT pt )
{
	m_fMouseIn = FALSE;
	CallOnPaint();

	CUIFScrollThumb::OnMouseOut( pt );
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

	Paint procedure of smart scoll thumb object

------------------------------------------------------------------------------*/
void CUIFSmartScrollThumb::OnPaint( HDC hDC )
{
	if (!IsEnabled()) {
		return;
	}

    CUIFObject::OnPaint( hDC );
}


/*   O N  P A I N T  D E F A U L T   */
/*------------------------------------------------------------------------------

	Paint procedure of smart scoll thumb object (default)

------------------------------------------------------------------------------*/
void CUIFSmartScrollThumb::OnPaintNoTheme( HDC hDC )
{
	RECT rc = GetRectRef();

	FillRect( hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1) );
	DrawEdge( hDC, &rc, BDR_RAISEDINNER, BF_RECT );

}


/*   O N  P A I N T  W H I S T L E R   */
/*------------------------------------------------------------------------------

	Paint procedure of smart scoll thumb object (Whistler)

------------------------------------------------------------------------------*/
BOOL CUIFSmartScrollThumb::OnPaintTheme( HDC hDC )
{
	BOOL   fRet = FALSE;

	if (!IsThemeActive()) {
		return FALSE;
	}

    if (SUCCEEDED(EnsureThemeData( GetUIWnd()->GetWnd()))) {
		int    iStateID;
		RECT   rcContent;
		SIZE   sizeGrip;
		RECT   rcGrip;

		// iStateID = IsCapture() ? SCRBS_PRESSED : m_fMouseIn ? SCRBS_HOT : SCRBS_NORMAL;
		iStateID = IsCapture() ? SCRBS_PRESSED : m_fMouseIn ? SCRBS_NORMAL : SCRBS_NORMAL;

		// draw thumb

        SetDefThemePartID(((m_dwStyle & UISMARTSCROLLTHUMB_HORZ) != 0) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT);
		fRet = SUCCEEDED(DrawThemeBackground(hDC, iStateID, &GetRectRef(), 0));

		// draw gripper

		GetThemeBackgroundContentRect( hDC, iStateID, &GetRectRef(), &rcContent );

        SetDefThemePartID(((m_dwStyle & UISMARTSCROLLTHUMB_HORZ) != 0) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT);
		GetThemePartSize( hDC, iStateID, NULL, TS_TRUE, &sizeGrip );

		sizeGrip.cx = min( sizeGrip.cx, rcContent.right - rcContent.left);
		sizeGrip.cy = min( sizeGrip.cy, rcContent.bottom - rcContent.top);
		rcGrip.left   = ((rcContent.left + rcContent.right) - sizeGrip.cx) / 2;
		rcGrip.top    = ((rcContent.top + rcContent.bottom) - sizeGrip.cy) / 2;
		rcGrip.right  = rcGrip.left + sizeGrip.cx;
		rcGrip.bottom = rcGrip.top  + sizeGrip.cy;
		fRet &= SUCCEEDED(DrawThemeBackground( hDC, iStateID, &rcGrip, 0 ));
	}

	return fRet;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S M A R T  S C R O L L                                          */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSmartScroll
//

/*   C  U I F  S M A R T  S C R O L L   */
/*------------------------------------------------------------------------------

	Constructor of CUIFSmartScroll

------------------------------------------------------------------------------*/
CUIFSmartScroll::CUIFSmartScroll( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFScroll( pParent, dwID, prc, dwStyle )
{
	SetActiveTheme(L"scrollbar");
}


/*   ~  C  U I F  S M A R T  S C R O L L   */
/*------------------------------------------------------------------------------

	Destructor of CUIFSmartScroll

------------------------------------------------------------------------------*/
CUIFSmartScroll::~CUIFSmartScroll( void )
{
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

	Initialize CUIFSmartScroll object

------------------------------------------------------------------------------*/
CUIFObject *CUIFSmartScroll::Initialize( void )
{
	RECT rc;
	DWORD dwThumbStyle;

	switch (m_dwStyle & UISCROLL_DIRMASK) {
		default:
		case UISCROLL_VERTTB:
		case UISCROLL_VERTBT: {
			dwThumbStyle = UISMARTSCROLLTHUMB_VERT;
			break;
		}

		case UISCROLL_HORZLR:
		case UISCROLL_HORZRL: {
			dwThumbStyle = UISMARTSCROLLTHUMB_HORZ;
			break;
		}
	}

	GetBtnUpRect( &rc );
	m_pBtnUp = new CUIFSmartScrollButton( this, &rc, GetScrollUpBtnStyle() );
	m_pBtnUp->Initialize();
	AddUIObj( m_pBtnUp );

	GetBtnDnRect( &rc );
	m_pBtnDn = new CUIFSmartScrollButton( this, &rc, GetScrollDnBtnStyle() );
	m_pBtnDn->Initialize();
	AddUIObj( m_pBtnDn );

	GetThumbRect( &rc );
	m_pThumb = new CUIFSmartScrollThumb( this, &rc, GetScrollThumbStyle() | dwThumbStyle );
	m_pThumb->Initialize();
	AddUIObj( m_pThumb );

	return CUIFObject::Initialize();
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFSmartScroll::SetStyle( DWORD dwStyle )
{
	CUIFScroll::SetStyle( dwStyle );

	DWORD dwThumbStyle;

	switch (m_dwStyle & UISCROLL_DIRMASK) {
		default:
		case UISCROLL_VERTTB:
		case UISCROLL_VERTBT: {
			dwThumbStyle = UISMARTSCROLLTHUMB_VERT;
			break;
		}

		case UISCROLL_HORZLR:
		case UISCROLL_HORZRL: {
			dwThumbStyle = UISMARTSCROLLTHUMB_HORZ;
			break;
		}
	}

	m_pThumb->SetStyle( GetScrollThumbStyle() | dwThumbStyle );
}


/*   O N  P A I N T  D E F A U L T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll object (default)

------------------------------------------------------------------------------*/
void CUIFSmartScroll::OnPaintNoTheme( HDC hDC )
{
	HBRUSH hBrush;

	// paint scroll bar back

	hBrush = (HBRUSH)DefWindowProc( m_pUIWnd->GetWnd(), WM_CTLCOLORSCROLLBAR, (WPARAM)hDC, (LPARAM)m_pUIWnd->GetWnd() );
	if (hBrush == NULL) {
		// never happen?  just in case...
		hBrush = GetSysColorBrush(COLOR_SCROLLBAR);
	}

	FillRect( hDC, &GetRectRef(), hBrush );
	DeleteObject( hBrush );

	// paint scroll area

	if (m_fScrollPage) {
		RECT rc;

		switch (m_dwScrollDir) {
			case UISCROLL_PAGEUP: {
				GetPageUpArea( &rc );
				break;
			}

			case UISCROLL_PAGEDOWN: {
				GetPageDnArea( &rc );
				break;
			}
		}
		InvertRect( hDC, &rc );
	}

}


/*   O N  P A I N T  W H I S T L E R   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll object (Whistler)

------------------------------------------------------------------------------*/
BOOL CUIFSmartScroll::OnPaintTheme( HDC hDC )
{
	BOOL   fRet = FALSE;

	if (!IsThemeActive()) {
		return FALSE;
	}

    if (SUCCEEDED(EnsureThemeData( GetUIWnd()->GetWnd()))) {
		int    iStateID;
		RECT   rc;

		switch (m_dwStyle & UISCROLL_DIRMASK) {
			default:
			case UISCROLL_VERTTB: {
				SetDefThemePartID(SBP_UPPERTRACKVERT);
				break;
			}

			case UISCROLL_VERTBT: {
				SetDefThemePartID(SBP_LOWERTRACKHORZ);
				break;
			}

			case UISCROLL_HORZLR: {
				SetDefThemePartID(SBP_UPPERTRACKHORZ);
				break;
			}

			case UISCROLL_HORZRL: {
				SetDefThemePartID(SBP_LOWERTRACKHORZ);
				break;
			}
		}

		iStateID = (m_fScrollPage && (m_dwScrollDir == UISCROLL_PAGEUP)) ? SCRBS_PRESSED : SCRBS_NORMAL;
		GetPageUpArea( &rc );
		fRet = SUCCEEDED(DrawThemeBackground( hDC, iStateID, &rc, 0 ));

		switch (m_dwStyle & UISCROLL_DIRMASK) {
			default:
			case UISCROLL_VERTTB: {
				SetDefThemePartID(SBP_LOWERTRACKHORZ);
				break;
			}

			case UISCROLL_VERTBT: {
				SetDefThemePartID(SBP_UPPERTRACKVERT);
				break;
			}

			case UISCROLL_HORZLR: {
				SetDefThemePartID(SBP_LOWERTRACKHORZ);
				break;
			}

			case UISCROLL_HORZRL: {
				SetDefThemePartID(SBP_UPPERTRACKHORZ);
				break;
			}
		}

		iStateID = (m_fScrollPage && (m_dwScrollDir == UISCROLL_PAGEDOWN)) ? 3/* PRESSED */ : 1/* NORMAL */;
		GetPageDnArea( &rc );
		fRet = SUCCEEDED(DrawThemeBackground( hDC, iStateID, &rc, 0 ));
	}

	return fRet;

}

/*============================================================================*/
/*                                                                            */
/*   C  C A N D  L I S T  A C C  I T E M                                      */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  L I S T  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandListAccItem::CCandListAccItem( CUIFCandListBase *pListUIObj, int iLine )
{
	m_pListUIObj = pListUIObj;
	m_iLine      = iLine;
}


/*   ~  C  C A N D  L I S T  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandListAccItem::~CCandListAccItem( void )
{
}


/*   G E T  A C C  N A M E   */
/*------------------------------------------------------------------------------

	Get acc item name
	(CCandAccItem method)

------------------------------------------------------------------------------*/
BSTR CCandListAccItem::GetAccName( void )
{
	return m_pListUIObj->GetAccNameProc( m_iLine );
}


/*   G E T  A C C  V A L U E   */
/*------------------------------------------------------------------------------

	Get acc value

------------------------------------------------------------------------------*/
BSTR CCandListAccItem::GetAccValue( void )
{
	return m_pListUIObj->GetAccValueProc( m_iLine );
}


/*   G E T  A C C  R O L E   */
/*------------------------------------------------------------------------------

	Get acc item role
	(CCandAccItem method)

------------------------------------------------------------------------------*/
LONG CCandListAccItem::GetAccRole( void )
{
	return m_pListUIObj->GetAccRoleProc( m_iLine );
}


/*   G E T  A C C  S T A T E   */
/*------------------------------------------------------------------------------

	Get acc item state
	(CCandAccItem method)

------------------------------------------------------------------------------*/
LONG CCandListAccItem::GetAccState( void )
{
	return m_pListUIObj->GetAccStateProc( m_iLine );
}


/*   G E T  A C C  L O C A T I O N   */
/*------------------------------------------------------------------------------

	Get acc location
	(CCandAccItem method)

------------------------------------------------------------------------------*/
void CCandListAccItem::GetAccLocation( RECT *prc )
{
	m_pListUIObj->GetAccLocationProc( m_iLine, prc );
}


/*   O N  S E L E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandListAccItem::OnSelect( void )
{
	NotifyWinEvent( EVENT_OBJECT_SELECTION );
}

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C A N D  L I S T                                                */
/*                                                                             */
/*=============================================================================*/

//
// CUIFCandListBase
//

/*   C  U I F  C A N D  L I S T  B A S E   */
/*------------------------------------------------------------------------------

	Constructor of CUIFCandListBase

------------------------------------------------------------------------------*/
CUIFCandListBase::CUIFCandListBase( void )
{
	int i;

	m_hFontInlineComment = (HFONT)GetStockObject( DEFAULT_GUI_FONT );

	for (i = 0; i < CANDLISTACCITEM_MAX; i++) {
		m_rgListAccItem[i] = NULL;
	}
}


/*   ~  C  U I F  C A N D  L I S T  B A S E   */
/*------------------------------------------------------------------------------

	Destructor of CUIFCandListBase

------------------------------------------------------------------------------*/
CUIFCandListBase::~CUIFCandListBase( void )
{
	int i;

	for (i = 0; i < CANDLISTACCITEM_MAX; i++) {
		if (m_rgListAccItem[i] != NULL) {
			delete m_rgListAccItem[i];
		}
	}
}


/*   G E T  C A N D I D A T E  I T E M   */
/*------------------------------------------------------------------------------

	Get candidate item of candidate list item

------------------------------------------------------------------------------*/
CCandidateItem *CUIFCandListBase::GetCandidateItem( int iItem )
{
	CCandListItem *pListItem = GetCandItem( iItem );

	return (pListItem != NULL) ? pListItem->GetCandidateItem() : NULL;
}


/*   S E T  I C O N  P O P U P  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandListBase::SetIconPopupComment( HICON hIconOn, HICON hIconOff )
{
	m_hIconPopupOn  = hIconOn;
	m_hIconPopupOff = hIconOff;
}


/*   I N I T  A C C  I T E M S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandListBase::InitAccItems( CCandAccessible *pCandAcc )
{
	int i;

	for (i = 0; i < CANDLISTACCITEM_MAX; i++) {
		m_rgListAccItem[i] = new CCandListAccItem( this, i );

		pCandAcc->AddAccItem( m_rgListAccItem[i] );
	}
}

/*   G E T  L I S T  A C C  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandListAccItem *CUIFCandListBase::GetListAccItem( int i )
{
	if (0 <= i && i < CANDLISTACCITEM_MAX) {
		return m_rgListAccItem[i];
	}
	return NULL;
}


//
// CUIFCandList
//

/*   C  U I F  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Constructor of CUIFCandList

------------------------------------------------------------------------------*/
CUIFCandList::CUIFCandList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFListBase( pParent, dwID, prc, dwStyle )
{
	m_iIndexStart        = 1;
	m_nExtTopSpace       = 0;
	m_nExtBottomSpace    = 0;
	m_cxInlineCommentPos = -1;
	m_iItemHover         = -1;
}


/*   ~  C  U I F  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Destructor of CUIFCandList

------------------------------------------------------------------------------*/
CUIFCandList::~CUIFCandList( void )
{
}


/*   A D D  C A N D  I T E M   */
/*------------------------------------------------------------------------------

	Add new candidate item
	(CUIFCandListBase method)

	Returns index of candidate item added

------------------------------------------------------------------------------*/
int CUIFCandList::AddCandItem( CCandListItem *pCandListItem )
{
	return AddItem( pCandListItem );
}


/*   G E T  I T E M  C O U N T   */
/*------------------------------------------------------------------------------

	Returns number of candidate item
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
int CUIFCandList::GetItemCount( void )
{
    return GetCount();
}


/*   I S  I T E M  S E L E C T A B L E   */
/*------------------------------------------------------------------------------

	Returns TRUE, if candidate item with given index could be selected.
	Otherwise, returns FALSE.
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
BOOL CUIFCandList::IsItemSelectable( int iListItem )
{
	int iListItemMax = GetItemCount();

	return (0 <= iListItem) && (iListItem < iListItemMax);
}


/*   G E T  C A N D  I T E M   */
/*------------------------------------------------------------------------------

	Get candidate item
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
CCandListItem* CUIFCandList::GetCandItem( int iItem )
{
    return (CCandListItem*)GetItem( iItem );
}


/*   D E L  A L L  C A N D  I T E M   */
/*------------------------------------------------------------------------------

	Delete all candidate items
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::DelAllCandItem( void )
{
	DelAllItem();
}


/*   S E T  C U R  S E L   */
/*------------------------------------------------------------------------------

	Set current selection
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::SetCurSel( int iSelection )
{
	CCandListAccItem *pAccItem;

	SetSelection( iSelection, TRUE );

	//

	pAccItem = GetListAccItem( GetSelection() - GetTopItem() );
	if (pAccItem != NULL) {
		pAccItem ->OnSelect();
	}
}


/*   G E T  C U R  S E L   */
/*------------------------------------------------------------------------------

	Get current selection
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
int CUIFCandList::GetCurSel( void )
{
	return GetSelection();
}


/*   G E T  T O P  I T E M   */
/*------------------------------------------------------------------------------

	Get item displayed at the top of list
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
int CUIFCandList::GetTopItem( void )
{
	return GetTop();
}


/*   G E T  B O T T O M  I T E M   */
/*------------------------------------------------------------------------------

	Get item displayed at the bottom of list
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
int CUIFCandList::GetBottomItem( void )
{
	return GetBottom();
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------

	Get visible status of object
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
BOOL CUIFCandList::IsVisible( void )
{
	return CUIFListBase::IsVisible();
}


/*   G E T  R E C T   */
/*------------------------------------------------------------------------------

	Get rect of object
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::GetRect( RECT *prc )
{
	CUIFListBase::GetRect( prc );
}


/*   G E T  I T E M  R E C T   */
/*------------------------------------------------------------------------------

	Get item rect
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::GetItemRect( int iItem, RECT *prc )
{
	Assert( prc != NULL );

	::SetRect( prc, 0, 0, 0, 0 );
	if (GetTopItem() <= iItem && iItem <= GetBottomItem()) {
		GetLineRect( iItem - GetTopItem(), prc );
	}
}


/*   S E T  I N L I N E  C O M M E N T  P O S   */
/*------------------------------------------------------------------------------

	Set (horizontal) position to draw inline comment
	NOTE: if cx has negative value, inline comment will be aligned to right.
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::SetInlineCommentPos( int cx )
{
	m_cxInlineCommentPos = cx;
}


/*   S E T  I N L I N E  C O M M E N T  F O N T   */
/*------------------------------------------------------------------------------

	Set font for inline comment
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::SetInlineCommentFont( HFONT hFont )
{
	if (hFont == NULL) {
		hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
	}
	m_hFontInlineComment = hFont;

	CallOnPaint();
}


/*   S E T  I N D E X  F O N T   */
/*------------------------------------------------------------------------------

	Set font for index
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
void CUIFCandList::SetIndexFont( HFONT hFont )
{
	if (hFont == NULL) {
		hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
	}
	m_hFontIndex = hFont;

	CallOnPaint();
}


/*   S E T  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Set candidate list

------------------------------------------------------------------------------*/
void CUIFCandList::SetCandList( CCandidateList *pCandList )
{
	int nCandItem;
	int i;
	CCandidateItem *pCandItem;

	ASSERT( pCandList );

	nCandItem = pCandList->GetItemCount();
	for (i = 0; i < nCandItem; i++) {
		pCandItem = pCandList->GetCandidateItem( i );
		if (pCandItem->IsVisible()) {
			CCandListItem *pCandListItem = new CCandListItem( GetItemCount(), i, pCandItem );
			AddCandItem( pCandListItem );
		}
	}
}


/*   G E T  A C C  N A M E  P R O C   */
/*------------------------------------------------------------------------------

	Get acc item name

------------------------------------------------------------------------------*/
BSTR CUIFCandList::GetAccNameProc( int iItem )
{
	CCandidateItem *pCandItem;
	int iListItem = GetTopItem() + iItem;

	pCandItem = GetCandidateItem( iListItem );

	return (pCandItem != NULL) ? SysAllocString( pCandItem->GetString() ) : NULL;
}


/*   G E T  A C C  V A L U E  P R O C   */
/*------------------------------------------------------------------------------

	Get acc value

------------------------------------------------------------------------------*/
BSTR CUIFCandList::GetAccValueProc( int iItem )
{
	CCandidateItem *pCandItem;
	int iListItem = GetTopItem() + iItem;

	pCandItem = GetCandidateItem( iListItem );

	return (pCandItem != NULL) ? SysAllocString( pCandItem->GetString() ) : NULL;
}


/*   G E T  A C C  R O L E  P R O C   */
/*------------------------------------------------------------------------------

	Get acc item role

------------------------------------------------------------------------------*/
LONG CUIFCandList::GetAccRoleProc( int iItem )
{
	return ROLE_SYSTEM_LISTITEM;
}


/*   G E T  A C C  S T A T E  P R O C   */
/*------------------------------------------------------------------------------

	Get acc item state
	(CCandAccItem method)

------------------------------------------------------------------------------*/
LONG CUIFCandList::GetAccStateProc( int iItem )
{
	int iCurSel  = GetCurSel();
	int iTopItem = GetTopItem();
	int iItemMax = GetItemCount();

	if (iTopItem + iItem == iCurSel) {
		return STATE_SYSTEM_SELECTED;
	}
	else if (iTopItem + iItem < iItemMax) {
		return STATE_SYSTEM_SELECTABLE;
	}
	else {
		return STATE_SYSTEM_UNAVAILABLE;
	}
}


/*   G E T  A C C  L O C A T I O N  P R O C   */
/*------------------------------------------------------------------------------

	Get acc location

------------------------------------------------------------------------------*/
void CUIFCandList::GetAccLocationProc( int iItem, RECT *prc )
{
	GetLineRect( iItem, prc );
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::OnLButtonDown( POINT pt )
{
	SetItemHover( -1 );

	CUIFListBase::OnLButtonDown( pt );
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::OnLButtonUp( POINT pt )
{
	SetItemHover( ListItemFromPoint( pt ) );

	CUIFListBase::OnLButtonUp( pt );
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------

	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFCandList::OnMouseMove( POINT pt )
{
	if (!IsCapture()) {
		SetItemHover( ListItemFromPoint( pt ) );
	}

	CUIFListBase::OnMouseMove( pt );
}


/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------

	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFCandList::OnMouseIn( POINT pt )
{
	if (!IsCapture()) {
		SetItemHover( ListItemFromPoint( pt ) );
	}

	CUIFListBase::OnMouseMove( pt );
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------

	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFCandList::OnMouseOut( POINT pt )
{
	if (!IsCapture()) {
		SetItemHover( -1 );
	}

	CUIFListBase::OnMouseMove( pt );
}


/*   S E T  S T A R T  I N D E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::SetStartIndex( int iIndexStart )
{
	m_iIndexStart = iIndexStart;
}


/*   S E T  E X T R A  T O P  S P A C E      */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::SetExtraTopSpace( int nSpace )
{
	RECT rcScroll;

	m_nExtTopSpace = nSpace;

	GetScrollBarRect( &rcScroll );
	m_pUIScroll->SetRect( &rcScroll );
}


/*   S E T  E X T R A  B O T T O M  S P A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::SetExtraBottomSpace( int nSpace )
{
	RECT rcScroll;

	m_nExtBottomSpace = nSpace;

	GetScrollBarRect( &rcScroll );
	m_pUIScroll->SetRect( &rcScroll );
}


/*   G E T  E X T R A  T O P  S P A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFCandList::GetExtraTopSpace( void )
{
	return m_nExtTopSpace;
}


/*   G E T  E X T R A  B O T T O M  S P A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFCandList::GetExtraBottomSpace( void )
{
	return m_nExtBottomSpace;
}


/*   G E T  L I N E  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::GetLineRect( int iLine, RECT *prc )
{
	CUIFListBase::GetLineRect( iLine, prc );

	// exclude a space about scrollbar when it has space at top/bottom of scrollbar

	if ((m_nExtBottomSpace != 0) || (m_nExtTopSpace != 0)) {
		switch (m_dwStyle & UILIST_DIRMASK) {
			default:
			case UILIST_HORZTB:
			case UILIST_HORZBT: {
				prc->right  = GetRectRef().right - GetSystemMetrics(SM_CXVSCROLL);
				break;
			}

			case UILIST_VERTLR:
			case UILIST_VERTRL: {
				prc->top    = GetRectRef().top;
				prc->bottom = GetRectRef().bottom - GetSystemMetrics(SM_CYHSCROLL);
				break;
			}
		}
	}
}


/*   G E T  S C R O L L  B A R  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::GetScrollBarRect( RECT *prc )
{
	switch (m_dwStyle & UILIST_DIRMASK) {
		default:
		case UILIST_HORZTB:
		case UILIST_HORZBT: {
			prc->left   = GetRectRef().right - GetSystemMetrics(SM_CXVSCROLL);
			prc->top    = GetRectRef().top + m_nExtTopSpace;
			prc->right  = GetRectRef().right;
			prc->bottom = GetRectRef().bottom - m_nExtBottomSpace;
			break;
		}

		case UILIST_VERTLR:
		case UILIST_VERTRL: {
			prc->left   = GetRectRef().left + m_nExtBottomSpace;
			prc->top    = GetRectRef().bottom - GetSystemMetrics(SM_CYHSCROLL);
			prc->right  = GetRectRef().right - m_nExtTopSpace;
			prc->bottom = GetRectRef().bottom;
			break;
		}
	}
}


/*   G E T  S C R O L L  B A R  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFCandList::GetScrollBarStyle( void )
{
	DWORD dwScrollStyle;

	switch (m_dwStyle & UILIST_DIRMASK) {
		default:
		case UILIST_HORZTB: {
			dwScrollStyle = UISCROLL_VERTTB;
			break;
		}

		case UILIST_HORZBT: {
			dwScrollStyle = UISCROLL_VERTBT;
			break;
		}

		case UILIST_VERTLR: {
			dwScrollStyle = UISCROLL_HORZLR;
			break;
		}

		case UILIST_VERTRL: {
			dwScrollStyle = UISCROLL_HORZRL;
			break;
		}
	}

	return dwScrollStyle;
}


/*   C R E A T E  S C R O L L  B A R  O B J   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFScroll *CUIFCandList::CreateScrollBarObj( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle )
{
	return new CUIFSmartScroll( pParent, dwID, prc, dwStyle );
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

	Paint procedure of candidate list 

------------------------------------------------------------------------------*/
void CUIFCandList::OnPaint( HDC hDC )
{
	HDC     hDCMem;
	HBITMAP hBmpMem;
	HBITMAP hBmpOld;
	SIZE    size;
	RECT    rc;
	int     iLine;
	HFONT   hFontOld;
	RECT    rcBorder;

	// prepare memory dc

	rc = GetRectRef();
	size.cx = rc.right - rc.left;
	size.cy = rc.bottom - rc.top;

	hDCMem = CreateCompatibleDC( hDC );
    if (!hDCMem)
        return ;

	hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
	hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

	SetWindowOrgEx( hDCMem, rc.left, rc.top, NULL );
	hFontOld = (HFONT)SelectObject( hDCMem, GetFont() );

	// paint background

	m_pUIFScheme->FillRect( hDCMem, &rc, UIFCOLOR_WINDOW );

	// paint index bkgnd

	switch (m_dwStyle & UILIST_DIRMASK) {
		default:
		case UILIST_HORZTB:
		case UILIST_HORZBT: {
			rcBorder.left   = rc.left;
			rcBorder.top    = rc.top;
			rcBorder.right  = rc.left + (GetLineHeight()) + 4;
			rcBorder.bottom = rc.bottom;
			break;
		}

		case UILIST_VERTLR:
		case UILIST_VERTRL: {
			rcBorder.left   = rc.left;
			rcBorder.top    = rc.top;
			rcBorder.right  = rc.right;
			rcBorder.bottom = rc.top + (GetLineHeight()) + 4;
			break;
		}
	}

	m_pUIFScheme->FillRect( hDCMem, &rcBorder, UIFCOLOR_MENUBARSHORT );

	// paint items

	for (iLine = 0; iLine < m_nItemVisible + 1; iLine++) {
		CCandListItem *pItem;
		int iItem = m_iItemTop + iLine;
		RECT rcLine;

		pItem = GetCandItem( iItem );
		if (pItem != NULL) {
			GetLineRect( iLine, &rcLine );
			if (!IsRectEmpty( &rcLine )) {
				PaintItemProc( hDCMem, &rcLine, iLine + m_iIndexStart, pItem, (iItem == m_iItemSelect) );
			}
		}
	}

	// 

	BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, rc.left, rc.top, SRCCOPY );

	SelectObject( hDCMem, hFontOld );
	SelectObject( hDCMem, hBmpOld );
	DeleteObject( hBmpMem );
	DeleteDC( hDCMem );
}


/*   P A I N T  I T E M  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::PaintItemProc( HDC hDC, RECT *prc, int iIndex, CCandListItem *pItem, BOOL fSelected )
{
	CCandidateItem *pCandItem;
	RECT  rcClip;
	RECT  rcText;
	RECT  rcIndex;
	int   iBkModeOld;

	iBkModeOld = SetBkMode( hDC, TRANSPARENT );

	// get candidate item

	pCandItem = pItem->GetCandidateItem();
	Assert( pCandItem != NULL );

	// calc rects

	switch (m_dwStyle & UILIST_DIRMASK) {
		default:
		case UILIST_HORZTB:
		case UILIST_HORZBT: {
			rcIndex.left   = prc->left;
			rcIndex.top    = prc->top;
			rcIndex.right  = prc->left + GetLineHeight() + 4;
			rcIndex.bottom = prc->bottom;

			rcClip.left    = rcIndex.right;
			rcClip.top     = prc->top;
			rcClip.right   = prc->right;
			rcClip.bottom  = prc->bottom;

			rcText.left    = rcIndex.right + 8;
			rcText.top     = prc->top;
			rcText.right   = prc->right - 8;
			rcText.bottom  = prc->bottom;
			break;
		}

		case UILIST_VERTLR:
		case UILIST_VERTRL: {
			rcIndex.left   = prc->left;
			rcIndex.top    = prc->top;
			rcIndex.right  = prc->right;
			rcIndex.bottom = prc->top + GetLineHeight() + 4;

			rcClip.left    = prc->left;
			rcClip.top     = rcIndex.bottom;
			rcClip.right   = prc->right;
			rcClip.bottom  = prc->bottom;

			rcText.left    = prc->left;
			rcText.top     = rcIndex.bottom + 8;
			rcText.right   = prc->right;
			rcText.bottom  = prc->bottom - 8;
			break;
		}
	}

	// paint selection

	if (fSelected) {
		RECT rc = *prc;

		rc.left   += 1;
		rc.right  -= 1;
		rc.bottom -= 1;
		m_pUIFScheme->DrawSelectionRect( hDC, &rc, FALSE /* over */ );
	}

	// paint index
	if ((m_dwStyle & UILIST_ICONSNOTNUMBERS) == 0)
	{
	    if (0 <= iIndex && iIndex <= 9) {
		    SIZE  size;
		    POINT ptOrg;
		    WCHAR wchIndex = L'0' + iIndex;
		    COLORREF colTextOld;
		    HFONT hFontOld;

		    // index

		    hFontOld = (HFONT)SelectObject( hDC, m_hFontIndex );
		    FLGetTextExtentPoint32( hDC, &wchIndex, 1, &size );
		    ptOrg.x = (rcIndex.right + rcIndex.left - size.cx) / 2;
		    ptOrg.y = (rcIndex.bottom + rcIndex.top - size.cy) / 2;

		    colTextOld = SetTextColor( hDC, GetUIFColor( UIFCOLOR_CTRLTEXT ) );
		    FLExtTextOutW( hDC, ptOrg.x, ptOrg.y, ETO_CLIPPED, &rcIndex, &wchIndex, 1, NULL );
		    SetTextColor( hDC, colTextOld );
		    SelectObject( hDC, hFontOld );
	    }
	}

	// paint candidate item

	PaintItemText( hDC, &rcText, &rcClip, &rcIndex, pCandItem, fSelected );

	//

	SetBkMode( hDC, iBkModeOld );
}


/*   P A I N T  I T E M  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::PaintItemText( HDC hDC, RECT *prcText, RECT *prcClip, RECT *prcIndex, CCandidateItem *pCandItem, BOOL fSelected )
{
	COLORREF col;
	COLORREF colText;
	COLORREF colPrefix;
	COLORREF colTextOld;
	int      iBkModeOld;
	LPCWSTR  psz;
	HICON    hIcon;
	SIZE     size;
	POINT    ptOrg;
	POINT    ptCenter;
	SIZE     sizeComment = {0};
	POINT    ptComment;
	int      cxyOrigin = 0;

	// set color

	if (fSelected) {
		colText = GetUIFColor( UIFCOLOR_MOUSEOVERTEXT );
		colPrefix = GetUIFColor( UIFCOLOR_CTRLTEXTDISABLED );
	}
	else {
		colText = GetUIFColor( UIFCOLOR_CTRLTEXT );
		colPrefix = GetUIFColor( UIFCOLOR_CTRLTEXTDISABLED );
	}
	if (pCandItem->GetColor( &col )) {
		colText = col;
	}

	colTextOld = GetTextColor( hDC );
	iBkModeOld = SetBkMode( hDC, TRANSPARENT );

	// calc center

	switch (m_dwStyle & UILIST_DIRMASK) {
		default:
		case UILIST_HORZTB: {
			ptCenter.x = (prcText->left + prcText->right) / 2;
			ptCenter.y = prcText->top + GetLineHeight() / 2;
			break;
		}

		case UILIST_HORZBT: {
			ptCenter.x = (prcText->left + prcText->right) / 2;
			ptCenter.y = prcText->bottom - GetLineHeight() / 2;
			break;
		}

		case UILIST_VERTLR: {
			ptCenter.x = prcText->left + GetLineHeight() / 2;
			ptCenter.y = (prcText->top + prcText->bottom) / 2;
			break;
		}

		case UILIST_VERTRL: {
			ptCenter.x = prcText->right - GetLineHeight() / 2;
			ptCenter.y = (prcText->top + prcText->bottom) / 2;
			break;
		}
	}

	// paint icon

	hIcon = pCandItem->GetIcon();
	if (hIcon != NULL) {
		RECT rcIcon;

		size.cx = 16;
		size.cy = 16;
		if (GetLineHeight()-2 < size.cx) {
			size.cx = size.cy = GetLineHeight()-2;
		}

		switch (m_dwStyle & UILIST_DIRMASK) {
			default:
			case UILIST_HORZTB: {
				if (m_dwStyle & UILIST_ICONSNOTNUMBERS)
				{
					rcIcon.left   = prcIndex->left;
					rcIcon.right  = prcIndex->right;
				}
				else
				{
					rcIcon.left   = prcText->left;
					rcIcon.right  = prcText->left + GetLineHeight();
				}
				rcIcon.top    = prcText->top;
				rcIcon.bottom = prcText->top + GetLineHeight();
				break;
			}

			case UILIST_HORZBT: {
				if (m_dwStyle & UILIST_ICONSNOTNUMBERS)
				{
					rcIcon.left   = prcIndex->left;
					rcIcon.right  = prcIndex->right;
				}
				else
				{
					rcIcon.left   = prcText->left;
					rcIcon.right  = prcText->left + GetLineHeight();
				}
				rcIcon.top    = prcText->bottom - GetLineHeight();
				rcIcon.bottom = prcText->bottom;
				break;
			}

			case UILIST_VERTLR: {
				rcIcon.left   = prcText->left;
				rcIcon.right  = prcText->left + GetLineHeight();
				if (m_dwStyle & UILIST_ICONSNOTNUMBERS)
				{
				    rcIcon.top    = prcIndex->bottom - GetLineHeight();
				    rcIcon.bottom = prcIndex->bottom;
				}
                else
                {
				    rcIcon.top    = prcText->bottom - GetLineHeight();
				    rcIcon.bottom = prcText->bottom;
                }
				break;
			}

			case UILIST_VERTRL: {
				rcIcon.left   = prcText->right - GetLineHeight();
				rcIcon.right  = prcText->right;
				if (m_dwStyle & UILIST_ICONSNOTNUMBERS)
				{
				    rcIcon.top    = prcIndex->top;
				    rcIcon.bottom = prcIndex->top + GetLineHeight();
				}
				else
				{
				    rcIcon.top    = prcText->top;
				    rcIcon.bottom = prcText->top + GetLineHeight();
				}
				break;
			}
		}

		ptOrg.x = (rcIcon.left + rcIcon.right - size.cx) / 2;
		ptOrg.y = (rcIcon.top + rcIcon.bottom - size.cx) / 2;

		DrawIconEx( hDC, ptOrg.x, ptOrg.y, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL|DI_COMPAT );

		if ((m_dwStyle & UILIST_ICONSNOTNUMBERS) == 0)
		{
			cxyOrigin += GetLineHeight();
		}
	}

	// paint prefix string

	psz = pCandItem->GetPrefixString();
	if (psz != NULL) {
		FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
		switch (m_dwStyle & UILIST_DIRMASK) {
			default:
			case UILIST_HORZTB: {
				ptOrg.x = prcText->left + cxyOrigin;
				ptOrg.y = ptCenter.y - size.cy/2;
				break;
			}

			case UILIST_HORZBT: {
				ptOrg.x = prcText->right - cxyOrigin;
				ptOrg.y = ptCenter.y + size.cy/2;
				break;
			}

			case UILIST_VERTLR: {
				ptOrg.x = ptCenter.x - size.cy/2;
				ptOrg.y = prcText->bottom - cxyOrigin;
				break;
			}

			case UILIST_VERTRL: {
				ptOrg.x = ptCenter.x + size.cy/2;
				ptOrg.y = prcText->top + cxyOrigin;
				break;
			}
		}

		SetTextColor( hDC, colPrefix );
		FLExtTextOutW( hDC, ptOrg.x, ptOrg.y, ETO_CLIPPED, prcClip, psz, wcslen(psz), NULL );

		cxyOrigin += size.cx;
	}

	// paint candidate string

	psz = pCandItem->GetString();
	FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
	switch (m_dwStyle & UILIST_DIRMASK) {
		default:
		case UILIST_HORZTB: {
			ptOrg.x = prcText->left + cxyOrigin;
			ptOrg.y = ptCenter.y - size.cy/2;
			break;
		}

		case UILIST_HORZBT: {
			ptOrg.x = prcText->right - cxyOrigin;
			ptOrg.y = ptCenter.y + size.cy/2;
			break;
		}

		case UILIST_VERTLR: {
			ptOrg.x = ptCenter.x - size.cy/2;
			ptOrg.y = prcText->bottom - cxyOrigin;
			break;
		}

		case UILIST_VERTRL: {
			ptOrg.x = ptCenter.x + size.cy/2;
			ptOrg.y = prcText->top + cxyOrigin;
			break;
		}
	}

	SetTextColor( hDC, colText );
	FLExtTextOutW( hDC, ptOrg.x, ptOrg.y, ETO_CLIPPED, prcClip, psz, wcslen(psz), NULL );

	cxyOrigin += size.cx;

	// paint suffix string

	psz = pCandItem->GetSuffixString();
	if (psz != NULL) {
		FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
		switch (m_dwStyle & UILIST_DIRMASK) {
			default:
			case UILIST_HORZTB: {
				ptOrg.x = prcText->left + cxyOrigin;
				ptOrg.y = ptCenter.y - size.cy/2;
				break;
			}

			case UILIST_HORZBT: {
				ptOrg.x = prcText->right - cxyOrigin;
				ptOrg.y = ptCenter.y + size.cy/2;
				break;
			}

			case UILIST_VERTLR: {
				ptOrg.x = ptCenter.x - size.cy/2;
				ptOrg.y = prcText->bottom - cxyOrigin;
				break;
			}

			case UILIST_VERTRL: {
				ptOrg.x = ptCenter.x + size.cy/2;
				ptOrg.y = prcText->top + cxyOrigin;
				break;
			}
		}

		SetTextColor( hDC, colPrefix );
		FLExtTextOutW( hDC, ptOrg.x, ptOrg.y, ETO_CLIPPED, prcClip, psz, wcslen(psz), NULL );

		cxyOrigin += size.cx;
	}

	// paint comment

	psz = pCandItem->GetInlineComment();
	if (psz != NULL) {
		HFONT hFontOld = (HFONT)SelectObject( hDC, m_hFontInlineComment );

		FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeComment );
		switch (m_dwStyle & UILIST_DIRMASK) {
			default:
			case UILIST_HORZTB: {
				ptComment.x = (0 <= m_cxInlineCommentPos ? prcText->left + m_cxInlineCommentPos : prcText->right - sizeComment.cx);
				ptComment.y = ptOrg.y + size.cy - sizeComment.cy;
				break;
			}
	
			case UILIST_HORZBT: {
				ptComment.x = (0 <= m_cxInlineCommentPos ? prcText->right - m_cxInlineCommentPos : prcText->left + sizeComment.cx);
				ptComment.y = ptOrg.y;
				break;
			}
	
			case UILIST_VERTLR: {
				ptComment.x = ptCenter.x - sizeComment.cy/2;
				ptComment.y = (0 <= m_cxInlineCommentPos ? prcText->bottom - m_cxInlineCommentPos : prcText->top + sizeComment.cx);
				break;
			}
	
			case UILIST_VERTRL: {
				ptComment.x = ptCenter.x + sizeComment.cy/2;
				ptComment.y = (0 <= m_cxInlineCommentPos ? prcText->top + m_cxInlineCommentPos : prcText->bottom - sizeComment.cx);
				break;
			}
		}

		SetTextColor( hDC, colText );
		FLExtTextOutW( hDC, ptComment.x, ptComment.y, ETO_CLIPPED, prcClip, psz, wcslen(psz), NULL );

		SelectObject( hDC, hFontOld );
	}

	// paint popup comment icon

	psz = pCandItem->GetPopupComment();
	if (psz != NULL) {
		HICON hIconPopup;
		RECT rcIcon;

		size.cx = 16;
		size.cy = 16;
		if (GetLineHeight()-2 < size.cx) {
			size.cx = size.cy = GetLineHeight()-2;
		}

		switch (m_dwStyle & UILIST_DIRMASK) {
			default:
			case UILIST_HORZTB: {
				rcIcon.left   = prcText->right - GetLineHeight();
				rcIcon.top    = prcText->top;
				rcIcon.right  = prcText->right;
				rcIcon.bottom = prcText->top + GetLineHeight();
				break;
			}

			case UILIST_HORZBT: {
				rcIcon.left   = prcText->left;
				rcIcon.top    = prcText->bottom - GetLineHeight();
				rcIcon.right  = prcText->left +  GetLineHeight();
				rcIcon.bottom = prcText->bottom;
				break;
			}

			case UILIST_VERTLR: {
				rcIcon.left   = prcText->left;
				rcIcon.top    = prcText->top;
				rcIcon.right  = prcText->left + GetLineHeight();
				rcIcon.bottom = prcText->top + GetLineHeight();
				break;
			}

			case UILIST_VERTRL: {
				rcIcon.left   = prcText->right - GetLineHeight();
				rcIcon.top    = prcText->bottom - GetLineHeight();
				rcIcon.right  = prcText->right;
				rcIcon.bottom = prcText->bottom;
				break;
			}
		}

		ptOrg.x = (rcIcon.left + rcIcon.right - size.cx) / 2;
		ptOrg.y = (rcIcon.top + rcIcon.bottom - size.cx) / 2;

		hIconPopup = pCandItem->IsPopupCommentVisible() ? m_hIconPopupOn : m_hIconPopupOff;
		DrawIconEx( hDC, ptOrg.x, ptOrg.y, hIconPopup, size.cx, size.cy, 0, NULL, DI_NORMAL|DI_COMPAT );
	}

	// restore device context settings

	SetTextColor( hDC, colTextOld );
	SetBkMode( hDC, iBkModeOld );
}


/*   S E T  I T E M  H O V E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandList::SetItemHover( int iItem )
{
	if (m_iItemHover != iItem) {
		m_iItemHover = iItem;
		NotifyCommand( UICANDLIST_HOVERITEM, m_iItemHover );
	}
}


//
// CUIFExtCandList
//

/*   C  U I F  E X T  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Constructor of CUIFExtCandList

------------------------------------------------------------------------------*/
CUIFExtCandList::CUIFExtCandList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFCandList( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  E X T  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Destructor of CUIFExtCandList

------------------------------------------------------------------------------*/
CUIFExtCandList::~CUIFExtCandList( void )
{
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------

	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFExtCandList::OnTimer( void )
{
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFExtCandList::OnLButtonUp( POINT pt )
{
	ClearSelection( TRUE );
	CUIFCandList::OnLButtonUp( pt );
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------

	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFExtCandList::OnMouseMove( POINT pt )
{
	if (!PtInObject( pt )) {
		ClearSelection( TRUE );
	}
	else {
		CUIFCandList::OnMouseMove( pt );
	}
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------

	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFExtCandList::OnMouseOut( POINT pt )
{
	ClearSelection( TRUE );
	CUIFCandList::OnMouseMove( pt );
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C A N D  R A W  D A T A                                         */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  C A N D  R A W  D A T A   */
/*------------------------------------------------------------------------------

	Constructor of CUIFCandRawData

------------------------------------------------------------------------------*/
CUIFCandRawData::CUIFCandRawData( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
	m_pwchText     = NULL;
	m_hBitmap      = NULL;
	m_hEnhMetaFile = NULL;
	m_hBmpCache    = NULL;
}


/*   ~  C  U I F  C A N D  R A W  D A T A   */
/*------------------------------------------------------------------------------

	Destructor of CUIFCandRawData

------------------------------------------------------------------------------*/
CUIFCandRawData::~CUIFCandRawData( void )
{
	ClearData();
	ClearCache();
}


/*   C L E A R  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::ClearData( void )
{
	if (m_pwchText != NULL) {
		delete m_pwchText;
		m_pwchText = NULL;
	}

	m_hBitmap      = NULL;
	m_hEnhMetaFile = NULL;
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

	Set text to display

------------------------------------------------------------------------------*/
void CUIFCandRawData::SetText( LPCWSTR pwchText )
{
	int cwch;

	if (pwchText == NULL) {
		return;
	}

	ClearData();
	ClearCache();

	cwch = wcslen( pwchText ) + 1;
	m_pwchText = new WCHAR[ cwch ];
    if (m_pwchText)
    {
	    memcpy( m_pwchText, pwchText, cwch * sizeof(WCHAR) );
    }

	// update window

	CallOnPaint();
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::SetBitmap( HBITMAP hBitmap )
{
	if (hBitmap == NULL) {
		return;
	}

	ClearData();
	ClearCache();

	m_hBitmap = hBitmap;

	// update window

	CallOnPaint();
}


/*   S E T  M E T A  F I L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::SetMetaFile( HENHMETAFILE hEnhMetaFile )
{
	if (hEnhMetaFile == NULL) {
		return;
	}

	ClearData();
	ClearCache();

	m_hEnhMetaFile = hEnhMetaFile;

	// update window

	CallOnPaint();
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

	Get text

------------------------------------------------------------------------------*/
int CUIFCandRawData::GetText( LPWSTR pwchBuf, int cwchBuf )
{
	int cwchText = (m_pwchText == NULL) ? 0 : wcslen(m_pwchText);

	if (cwchBuf <= 0) {
		// return text length in cwch (not including null-terminater)

		return cwchText;
	}
	else if (pwchBuf == NULL) {
		// return error code

		return (-1);
	}

	if (0 < cwchText) {
		cwchText = min( cwchText, cwchBuf-1 );
		memcpy( pwchBuf, m_pwchText, cwchText * sizeof(WCHAR) );
		*(pwchBuf + cwchText) = L'\0';      // always null terminate
	}

	return cwchText;
}


/*   G E T  B I T M A P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HBITMAP CUIFCandRawData::GetBitmap( void )
{
	return m_hBitmap;
}


/*   G E T  M E T A  F I L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HENHMETAFILE CUIFCandRawData::GetMetaFile( void )
{
	return m_hEnhMetaFile;
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::SetFont( HFONT hFont )
{
	ClearCache();
	CUIFObject::SetFont( hFont );
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::SetStyle( DWORD dwStyle )
{
	ClearCache();
	CUIFObject::SetStyle( dwStyle );
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

	Paint procedure of static object

------------------------------------------------------------------------------*/
void CUIFCandRawData::OnPaint( HDC hDC )
{
	HDC     hDCMem;
	HBITMAP hBmpOld;

	hDCMem = CreateCompatibleDC( hDC );

	if (hDCMem == NULL) {
		return; // nothing we can do
	}

	// crate cached image

	if (m_hBmpCache == NULL) {
		HBITMAP hBmp;
		SIZE    size;
		RECT    rc;

		// draw horizontal in memory dc

		switch (m_dwStyle) {
			default:
			case UICANDRAWDATA_HORZTB:
			case UICANDRAWDATA_HORZBT: {
				size.cx = GetRectRef().right - GetRectRef().left;
				size.cy = GetRectRef().bottom - GetRectRef().top;
				break;
			}

			case UICANDRAWDATA_VERTLR:
			case UICANDRAWDATA_VERTRL: {
				size.cx = GetRectRef().bottom - GetRectRef().top;
				size.cy = GetRectRef().right - GetRectRef().left;
				break;
			}
		}
		::SetRect( &rc, 0, 0, size.cx, size.cy ); 

		// prepare memory dc

		hBmp = CreateCompatibleBitmap( hDC, size.cx, size.cy );
        if (!hBmp)
            return;

		hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmp );

		m_pUIFScheme->FillRect( hDCMem, &rc, UIFCOLOR_WINDOW );

		// draw rawdata image

		if (m_pwchText != NULL) {
			DrawTextProc( hDCMem, &rc );
		}
		else if (m_hBitmap != NULL) {
			DrawBitmapProc( hDCMem, &rc );
		}
		else if (m_hEnhMetaFile != NULL) {
			DrawMetaFileProc( hDCMem, &rc );
		}

		// create bitmap cache

		SelectObject( hDCMem, hBmpOld );

		switch (m_dwStyle) {
			default:
			case UICANDRAWDATA_HORZTB: {
				m_hBmpCache = hBmp;
				break;
			}

			case UICANDRAWDATA_HORZBT: {
				m_hBmpCache = CreateRotateBitmap( hBmp, NULL, CANGLE180 );
				DeleteObject( hBmp );
				break;
			}

			case UICANDRAWDATA_VERTLR: {
				m_hBmpCache = CreateRotateBitmap( hBmp, NULL, CANGLE90 );
				DeleteObject( hBmp );
				break;
			}

			case UICANDRAWDATA_VERTRL: {
				m_hBmpCache = CreateRotateBitmap( hBmp, NULL, CANGLE270 );
				DeleteObject( hBmp );
				break;
			}
		}
	}

	// draw cached image

	if (m_hBmpCache == NULL) {
		DeleteDC( hDCMem );
		return;
	}

	hBmpOld = (HBITMAP)SelectObject( hDCMem, m_hBmpCache );

	BitBlt( hDC, GetRectRef().left, GetRectRef().top, GetRectRef().right - GetRectRef().left, GetRectRef().bottom - GetRectRef().top,
			hDCMem, 0, 0, SRCCOPY );

	SelectObject( hDCMem, hBmpOld );
	DeleteDC( hDCMem );
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::OnLButtonDown( POINT pt )
{
	StartCapture();
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandRawData::OnLButtonUp( POINT pt )
{
	if (IsCapture()) {
		EndCapture();

		if (PtInObject( pt )) {
			NotifyCommand( UICANDRAWDATA_CLICKED, 0 );
		}
	}
}



/*   C L E A R  C A C H E   */
/*------------------------------------------------------------------------------

	Claear cached rawdata image

------------------------------------------------------------------------------*/
void CUIFCandRawData::ClearCache( void )
{
	if (m_hBmpCache != NULL) {
		DeleteObject( m_hBmpCache );
		m_hBmpCache = NULL;
	}
}


/*   D R A W  T E X T  P R O C   */
/*------------------------------------------------------------------------------

	Draw text rawdata
	NOTE: Rotation will be done in cached bitmap. Draw horizontal image here.

------------------------------------------------------------------------------*/
void CUIFCandRawData::DrawTextProc( HDC hDC, const RECT *prc )
{
	HFONT hFontOld;
	int xAlign;
	int yAlign;
	SIZE size;
	int cwch;

	if (m_pwchText == NULL) {
		return;
	}

	cwch = wcslen( m_pwchText );

	// prepare objects

	hFontOld= (HFONT)SelectObject( hDC, GetFont() );

	// calc alignment

	GetTextExtentPointW( hDC, m_pwchText, cwch, &size );
	xAlign = 0;
	yAlign = (prc->bottom - prc->top - size.cy) / 2;

	// draw

	SetBkMode( hDC, TRANSPARENT );
	SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );

	FLExtTextOutW( hDC,
				prc->left + xAlign,
				prc->top + yAlign,
				ETO_CLIPPED,
				prc,
				m_pwchText,
				cwch,
				NULL );

	// restore objects

	SelectObject( hDC, hFontOld );
}


/*   D R A W  B I T M A P  P R O C   */
/*------------------------------------------------------------------------------

	Draw bitmap rawdata
	NOTE: Rotation will be done in cached bitmap. Draw horizontal image here.

------------------------------------------------------------------------------*/
void CUIFCandRawData::DrawBitmapProc( HDC hDC, const RECT *prc )
{
	HDC hDCBmp;
	HBITMAP hBmpOld;
	BITMAP bmp;
	SIZE sizeSrc;
	SIZE sizeDst;
	int aDen;
	int aNum;

	if (m_hBitmap == NULL) {
		return;
	}

	// get bitmap size

	GetObject( m_hBitmap, sizeof(bmp), &bmp );
	sizeSrc.cx = bmp.bmWidth;
	sizeSrc.cy = bmp.bmHeight;

	if (sizeSrc.cx <= 0 || sizeSrc.cy <= 0) {
		return;
	}

	// calc destination size (keep aspect ratio)

	sizeDst.cx = (prc->right - prc->left);
	sizeDst.cy = (prc->bottom - prc->top);

	if (sizeDst.cx*sizeSrc.cy < sizeDst.cy*sizeSrc.cx) { /* sizeDst.cx/sizeSrc.cx < sizeDst.cy/sizeSrc.cy */
		aDen = sizeSrc.cx;
		aNum = sizeDst.cx;
	} 
	else {
		aDen = sizeSrc.cy;
		aNum = sizeDst.cy;
	}
	sizeDst.cx = (sizeSrc.cx * aNum) / aDen;
	sizeDst.cy = (sizeSrc.cy * aNum) / aDen;
	Assert((sizeDst.cx==(prc->right - prc->left)) || (sizeDst.cy==(prc->bottom - prc->top)));
	Assert((sizeDst.cx<=(prc->right - prc->left)) && (sizeDst.cy<=(prc->bottom - prc->top)));

	// draw

	hDCBmp = CreateCompatibleDC( hDC );
    if (hDCBmp)
    {
	    hBmpOld = (HBITMAP)SelectObject( hDCBmp, m_hBitmap );

	    StretchBlt( hDC, prc->left, prc->top, sizeDst.cx, sizeDst.cy, 
				hDCBmp, 0, 0, sizeSrc.cx, sizeSrc.cy, SRCCOPY );

	    SelectObject( hDCBmp, hBmpOld );
	    DeleteDC( hDCBmp );
    }
}


/*   D R A W  M E T A  F I L E  P R O C   */
/*------------------------------------------------------------------------------

	Draw metafile rawdata
	NOTE: Rotation will be done in cached bitmap. Draw horizontal image here.

------------------------------------------------------------------------------*/
void CUIFCandRawData::DrawMetaFileProc( HDC hDC, const RECT *prc )
{
	ENHMETAHEADER emh;
	SIZE sizeSrc;
	SIZE sizeDst;
	int aDen;
	int aNum;
	RECT rcDst;

	if (m_hEnhMetaFile == NULL) {
		return;
	}

	// get bitmap size

	GetEnhMetaFileHeader( m_hEnhMetaFile, sizeof(emh), &emh );
	sizeSrc.cx = (emh.rclFrame.right - emh.rclFrame.left);
	sizeSrc.cy = (emh.rclFrame.bottom - emh.rclFrame.top);

	if (sizeSrc.cx <= 0 || sizeSrc.cy <= 0) {
		return;
	}

	// calc destination size (keep aspect ratio)

	sizeDst.cx = (prc->right - prc->left);
	sizeDst.cy = (prc->bottom - prc->top);

	if (sizeDst.cx*sizeSrc.cy < sizeDst.cy*sizeSrc.cx) { /* sizeDst.cx/sizeSrc.cx < sizeDst.cy/sizeSrc.cy */
		aDen = sizeSrc.cx;
		aNum = sizeDst.cx;
	} 
	else {
		aDen = sizeSrc.cy;
		aNum = sizeDst.cy;
	}
	sizeDst.cx = (sizeSrc.cx * aNum) / aDen;
	sizeDst.cy = (sizeSrc.cy * aNum) / aDen;
	Assert((sizeDst.cx==(prc->right - prc->left)) || (sizeDst.cy==(prc->bottom - prc->top)));
	Assert((sizeDst.cx<=(prc->right - prc->left)) && (sizeDst.cy<=(prc->bottom - prc->top)));

	// draw

	rcDst.left   = prc->left;
	rcDst.top    = prc->top;
	rcDst.right  = rcDst.left + sizeDst.cx;
	rcDst.bottom = rcDst.top  + sizeDst.cy;

	PlayEnhMetaFile( hDC, m_hEnhMetaFile, &rcDst );
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C A N D  B O R D E R                                            */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  C A N D  B O R D E R   */
/*------------------------------------------------------------------------------

    Constructor of CUIFCandBorder

------------------------------------------------------------------------------*/
CUIFCandBorder::CUIFCandBorder( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFBorder( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  C A N D  B O R D E R   */
/*------------------------------------------------------------------------------

    Destructor of CUIFCandBorder

------------------------------------------------------------------------------*/
CUIFCandBorder::~CUIFCandBorder( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of border object

------------------------------------------------------------------------------*/
void CUIFCandBorder::OnPaint( HDC hDC )
{
	RECT rc = GetRectRef();

	switch (m_dwStyle & UIBORDER_DIRMASK) {
		default:
		case UIBORDER_HORZ: {
			if (rc.top == rc.bottom) {
				break;
			}

			rc.top = (rc.top + rc.bottom) / 2;
			rc.bottom = rc.top + 1;

			GetUIFScheme()->FillRect( hDC, &rc, UIFCOLOR_SPLITTERLINE );
			break;
		}

		case UIBORDER_VERT: {
			if (rc.left == rc.right) {
				break;
			}

			rc.left = (rc.right + rc.left) / 2;
			rc.right = rc.left + 1;

			GetUIFScheme()->FillRect( hDC, &rc, UIFCOLOR_SPLITTERLINE );
			break;
		}
	}
}


/*============================================================================*/
/*                                                                            */
/*   C  U I F  C A N D  M E N U  B U T T O N                                  */
/*                                                                            */
/*============================================================================*/

/*   C  U I F  C A N D  M E N U  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCandMenuButton::CUIFCandMenuButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton2( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  C A N D  M E N U  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCandMenuButton::~CUIFCandMenuButton( void )
{
}


/*   G E T  A C C  N A M E   */
/*------------------------------------------------------------------------------

	Get acc item name
	(CCandAccItem method)

------------------------------------------------------------------------------*/
BSTR CUIFCandMenuButton::GetAccName( void )
{
	return (GetToolTip() != NULL) ? SysAllocString( GetToolTip() ) : NULL;
}


/*   G E T  A C C  V A L U E   */
/*------------------------------------------------------------------------------

	Get acc value

------------------------------------------------------------------------------*/
BSTR CUIFCandMenuButton::GetAccValue( void )
{
	return SysAllocString( L"" );
}


/*   G E T  A C C  R O L E   */
/*------------------------------------------------------------------------------

	Get acc item role
	(CCandAccItem method)

------------------------------------------------------------------------------*/
LONG CUIFCandMenuButton::GetAccRole( void )
{
	return ROLE_SYSTEM_PUSHBUTTON;
}


/*   G E T  A C C  S T A T E   */
/*------------------------------------------------------------------------------

	Get acc item state
	(CCandAccItem method)

------------------------------------------------------------------------------*/
LONG CUIFCandMenuButton::GetAccState( void )
{
	return (m_dwStatus == UIBUTTON_DOWN) ? STATE_SYSTEM_PRESSED : 0;
}


/*   G E T  A C C  L O C A T I O N   */
/*------------------------------------------------------------------------------

	Get acc location
	(CCandAccItem method)

------------------------------------------------------------------------------*/
void CUIFCandMenuButton::GetAccLocation( RECT *prc )
{
	GetRect( prc );
}


/*   S E T  S T A T U S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCandMenuButton::SetStatus( DWORD dwStatus )
{
	CUIFButton2::SetStatus( dwStatus );
	NotifyWinEvent( EVENT_OBJECT_STATECHANGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\dllmain.cpp ===
//
// dllmain.cpp
//

#include "private.h"
#include "globals.h"
#include "candui.h"
#include "osver.h"

DECLARE_OSVER();

#ifdef DEBUG
//
// for prvlib.lib
//
DWORD    g_dwThreadDllMain = 0;
#endif

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
	CcshellGetDebugFlags();
	Dbg_MemInit(TEXT("MSUIMUI"), NULL);
		   
    if (!g_cs.Init())
		return FALSE;

	g_hInst = hInstance;

	InitOSVer();

	// shared data

	InitCandUISecurityAttributes();
    g_ShareMem.Initialize();
	g_ShareMem.Open();

	// initialize messages

	g_msgHookedMouse = RegisterWindowMessage( SZMSG_HOOKEDMOUSE );
	g_msgHookedKey   = RegisterWindowMessage( SZMSG_HOOKEDKEY );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDetach
//
//----------------------------------------------------------------------------

void ProcessDetach(HINSTANCE hInstance)
{
	g_ShareMem.Close();
	DoneCandUISecurityAttributes();

	g_cs.Delete();
	Dbg_MemUninit();
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{

#ifdef DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif

	switch (dwReason) {
		case DLL_PROCESS_ATTACH: {
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDetach(hInstance);
                return FALSE;
            }
			break;
		}

		case DLL_THREAD_ATTACH: {
			break;
		}

		case DLL_THREAD_DETACH: {
			break;
		}

		case DLL_PROCESS_DETACH: {
            ProcessDetach(hInstance);
			break;
		}
	}

#ifdef DEBUG
    g_dwThreadDllMain = 0;
#endif

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSCANDUI"
#define SZ_MODULE       "MSCANDUI"
#define DECLARE_DEBUG
#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\cuicand2.cpp ===
//
// cuicand2.cpp - ui frame object for candidate UI
//

#include "private.h"
#include "cuilib.h"
#include "cuicand2.h"
#include "candutil.h"

#ifndef IDUIF_CANDNUMBUTTON
#define IDUIF_CANDNUMBUTTON 0x00000001
#endif

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S M A R T  M E N U  B U T T O N                                 */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSmartMenuButton
//

/*   C  U I F  S M A R T  M E N U  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CUIFSmartMenuButton

------------------------------------------------------------------------------*/
CUIFSmartMenuButton::CUIFSmartMenuButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton2( pParent, dwID, prc, dwStyle )
{
    m_pUIFScheme = CreateUIFScheme( UIFSCHEME_OFC10TOOLBAR );
    Assert( m_pUIFScheme != NULL );
}


/*   ~  C  U I F  S M A R T  M E N U  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CUIFSmartMenuButton

------------------------------------------------------------------------------*/
CUIFSmartMenuButton::~CUIFSmartMenuButton( void )
{
    // dispose scheme

    delete m_pUIFScheme;
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

	Paint procedure of smart menu button object

------------------------------------------------------------------------------*/
void CUIFSmartMenuButton::OnPaint( HDC hDC )
{
    DWORD    dwState = 0;
    HDC      hDCMem;
    HBITMAP  hBmpMem;
    HBITMAP  hBmpOld;
    SIZE     size;
    RECT     rc;
    COLORREF col;

    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_HOVER:
        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= (IsEnabled() ? 0 : UIFDCS_DISABLED);

    // prepare memory dc

    size.cx = GetRectRef().right - GetRectRef().left;
    size.cy = GetRectRef().bottom - GetRectRef().top;

    hDCMem = CreateCompatibleDC( hDC );
    hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

    ::SetRect( &rc, 0, 0, size.cx, size.cy );

    // paint background

    m_pUIFScheme->DrawCtrlBkgd( hDCMem, &rc, UIFDCF_BUTTON, dwState );

    // paint face

    if (dwState & UIFDCS_DISABLED) {
        col = GetUIFColor( UIFCOLOR_CTRLTEXTDISABLED );
    }
    else {
        col = GetUIFColor( UIFCOLOR_CTRLTEXT );
    }
    DrawTriangle( hDCMem, &rc, col, UIFDCTF_MENUDROP );

    // draw button edge

    m_pUIFScheme->DrawCtrlEdge( hDCMem, &rc, UIFDCF_BUTTON, dwState );

    //

    BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, 0, 0, SRCCOPY );

    SelectObject( hDCMem, hBmpOld );
    if (hBmpMem)
        DeleteObject( hBmpMem );

    DeleteDC( hDCMem );
}

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S M A R T  P A G E  B U T T O N                                 */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSmartPageButton
//

/*   C  U I F  S M A R T  P A G E  B U T T O N   */
/*------------------------------------------------------------------------------

	Constructor of CUIFSmartPageButton

------------------------------------------------------------------------------*/
CUIFSmartPageButton::CUIFSmartPageButton( CUIFObject *pParent, const RECT *prc, DWORD dwStyle ) : CUIFButton2( pParent, 0, prc, dwStyle )
{
    m_pUIFScheme = CreateUIFScheme( UIFSCHEME_OFC10TOOLBAR );
    Assert( m_pUIFScheme != NULL );
}


/*   ~  C  U I F  S M A R T  P A G E  B U T T O N   */
/*------------------------------------------------------------------------------

	Destructor of CUIFSmartPageButton

------------------------------------------------------------------------------*/
CUIFSmartPageButton::~CUIFSmartPageButton( void )
{
    // dispose scheme

    delete m_pUIFScheme;
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

	Paint procedure of smart page button object

------------------------------------------------------------------------------*/
void CUIFSmartPageButton::OnPaint( HDC hDC )
{
    DWORD    dwState = 0;
    DWORD    dwFlag;
    HDC      hDCMem;
    HBITMAP  hBmpMem;
    HBITMAP  hBmpOld;
    SIZE     size;
    RECT     rc;
    COLORREF col;

    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_HOVER:
        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= IsEnabled() ? 0 : UIFDCS_DISABLED;

    // prepare memory dc

    size.cx = GetRectRef().right - GetRectRef().left;
    size.cy = GetRectRef().bottom - GetRectRef().top;

    hDCMem = CreateCompatibleDC( hDC );
    hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

    ::SetRect( &rc, 0, 0, size.cx, size.cy );

    // paint background

    m_pUIFScheme->DrawCtrlBkgd( hDCMem, &rc, UIFDCF_BUTTON, dwState );

    // paint face

	switch (m_dwStyle & UISCROLLBUTTON_DIRMASK) {
		case UISCROLLBUTTON_LEFT: {
            dwFlag = UIFDCTF_RIGHTTOLEFT;
			break;
		}

		case UISCROLLBUTTON_UP: {
            dwFlag = UIFDCTF_BOTTOMTOTOP;
			break;
		}

		case UISCROLLBUTTON_RIGHT: {
            dwFlag = UIFDCTF_LEFTTORIGHT;
			break;
		}

		case UISCROLLBUTTON_DOWN: {
            dwFlag = UIFDCTF_TOPTOBOTTOM;
			break;
		}
	}

    if (dwState & UIFDCS_DISABLED) {
        col = GetUIFColor( UIFCOLOR_CTRLTEXTDISABLED );
    }
    else {
        col = GetUIFColor( UIFCOLOR_CTRLTEXT );
    }

    DrawTriangle( hDCMem, &rc, col, dwFlag );

    // draw button edge

    m_pUIFScheme->DrawCtrlEdge( hDCMem, &rc, UIFDCF_BUTTON, dwState );

    //

    BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, 0, 0, SRCCOPY );

    SelectObject( hDCMem, hBmpOld );
    if (hBmpMem)
        DeleteObject( hBmpMem );
    DeleteDC( hDCMem );
}

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  R O W  B U T T O N                                              */
/*                                                                             */
/*=============================================================================*/

//
//  CUIFRowButton
//

/*   C  U I F  R O W  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFRowButton::CUIFRowButton( CUIFObject *pParent, DWORD dwID, DWORD dwStyle) : CUIFButton2( pParent, dwID, NULL, dwStyle )
{
    m_pCandListItem      = NULL;
	m_hFontInlineComment = NULL;
    m_cxInlineCommentPos = -1;
    m_fSelected          = FALSE;

    UpdateText();
}


/*   ~  C  U I F  R O W  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFRowButton::~CUIFRowButton( void )
{
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::SetStyle( DWORD dwStyle )
{
    CUIFObject::SetStyle( dwStyle );

    UpdateText();
}


/*   U P D A T E  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::UpdateText( void )
{
    WCHAR pwch[3];

    pwch[0] = (WCHAR)'0' + (WORD)(GetID() % 10);
    pwch[1] = (WCHAR)' ';
    pwch[2] = (WCHAR)'\0';

    SetText(pwch);
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::OnLButtonDown( POINT pt )
{
    CUIFButton2::OnLButtonDown(pt);

    NotifyCommand( UILIST_SELCHANGED, m_pCandListItem->GetIListItem() );
}


/*   S E T  I N L I N E  C O M M E N T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::SetInlineCommentFont( HFONT hFont )
{
	Assert(hFont != NULL);
	m_hFontInlineComment = hFont;
}


/*   S E T  I N L I N E  C O M M E N T  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::SetInlineCommentPos( int cx )
{
	m_cxInlineCommentPos = cx;
}


/*   S E T  C A N D  L I S T  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::SetCandListItem( CCandListItem* pItem )
{
    m_pCandListItem = pItem;
}


/*   G E T  E X T E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::GetExtent(
    SIZE *psize)
{
    SIZE    size;
    LPCWSTR psz;
    BOOL    fHorizontal = (m_dwStyle & UIBUTTON_VCENTER) ? TRUE : FALSE;

    Assert(psize);

    psize->cx = 0;
    psize->cy = 0;

    GetTextExtent( m_hFont, GetText(), wcslen( GetText() ), psize, fHorizontal );

    if (m_pCandListItem != NULL) {
        psz = m_pCandListItem->GetCandidateItem()->GetString();
        GetTextExtent( m_hFont, psz, wcslen( psz ), &size, fHorizontal );
        psize->cx += size.cx;
        psize->cy = max(psize->cy, size.cy);

	    if ( psz = m_pCandListItem->GetCandidateItem()->GetPrefixString() ) {
            GetTextExtent( m_hFont, psz, wcslen( psz ), &size, fHorizontal );
            psize->cx += size.cx;
            psize->cy = max(psize->cy, size.cy);
        }
	    if ( psz = m_pCandListItem->GetCandidateItem()->GetSuffixString() ) {
            GetTextExtent( m_hFont, psz, wcslen( psz ), &size, fHorizontal );
            psize->cx += size.cx;
            psize->cy = max(psize->cy, size.cy);
        }
	    if ( psz = m_pCandListItem->GetCandidateItem()->GetInlineComment() ) {
            GetTextExtent( m_hFontInlineComment, psz, wcslen( psz ), &size, fHorizontal );
            psize->cx += size.cx;
	        if (m_cxInlineCommentPos > 0) {
		        psize->cx += m_cxInlineCommentPos;
	        }
            psize->cy = max(psize->cy, size.cy);
        }
    }

    Assert(psize->cx);
    Assert(psize->cy);

    psize->cx += 2;     // width of button borders
	psize->cy += 2;     // height of button borders
}


/*   S E L E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::SetSelected( BOOL fSelected )
{
    m_fSelected = fSelected;
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowButton::OnPaint( HDC hDC )
{
    HFONT		hFontOld;
	COLORREF	colTextOld;
	COLORREF	colText;
    int         nBkModeOld;
	LPCWSTR		psz;
	SIZE		size;
    BOOL		fHorizontal = (m_dwStyle & UIBUTTON_VCENTER) ? TRUE : FALSE;
	const int	ccxMargin = 1;
	const int	ccyMargin = 1;
	POINT		ptOrg;
    RECT        rc;
    DWORD       dwState = 0;

	Assert( m_pCandListItem != NULL );

    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= m_fSelected ? UIFDCS_MOUSEOVER : 0;
    dwState |= IsEnabled() ? 0 : UIFDCS_DISABLED;

    GetRect(&rc);

    // paint background

    m_pUIFScheme->DrawCtrlBkgd( hDC, &rc, UIFDCF_BUTTON, dwState );

    //
    //  paint index text
    //

    if (fHorizontal) {
		ptOrg.x = GetRectRef().left + ccxMargin;
		ptOrg.y = GetRectRef().top  + ccyMargin;
    }
    else {
		ptOrg.x = GetRectRef().right - ccxMargin;
		ptOrg.y = GetRectRef().top   + ccyMargin;
    }

    colText = GetUIFColor( UIFCOLOR_CTRLTEXT );

	colTextOld = SetTextColor( hDC, colText );
	nBkModeOld = SetBkMode( hDC, TRANSPARENT );
    hFontOld   = (HFONT)SelectObject( hDC, m_hFont );

    GetTextExtent( m_hFont, GetText(), wcslen( GetText() ), &size, fHorizontal );

    if (fHorizontal) {
        FLTextOutW( hDC, ptOrg.x + size.cx / 4, ptOrg.y, GetText(), wcslen( GetText() ) );

		ptOrg.x += size.cx;
    }
    else {
        FLTextOutW( hDC, ptOrg.x, ptOrg.y + size.cx / 4, GetText(), wcslen( GetText() ) );

        ptOrg.y += size.cx;
    }

    //
	//  paint prefix string
    //

	psz = m_pCandListItem->GetCandidateItem()->GetPrefixString();
	if (psz != NULL) {
		colText = GetUIFColor( UIFCOLOR_CTRLTEXTDISABLED );
		SetTextColor( hDC, colText );

		FLTextOutW( hDC, ptOrg.x, ptOrg.y, psz, wcslen(psz) );

		GetTextExtent( m_hFont, psz, wcslen( psz ), &size, fHorizontal );
		if (fHorizontal) {
			ptOrg.x += size.cx;
		}
		else {
			ptOrg.y += size.cx;
		}
	}

    //
    //  paint cand list item string
    //

    if ( dwState & UIFDCS_MOUSEDOWN ) {
        colText = GetUIFColor( UIFCOLOR_MOUSEDOWNTEXT );
    }
    else if ( dwState & UIFDCS_MOUSEOVER ) {
        colText = GetUIFColor( UIFCOLOR_MOUSEOVERTEXT );
    }
	else if (m_pCandListItem->GetCandidateItem()->GetColor( &colText )) {
    }
    else {
        colText = GetUIFColor( UIFCOLOR_CTRLTEXT );
    }
    SetTextColor( hDC, colText );

    psz = m_pCandListItem->GetCandidateItem()->GetString();
	FLTextOutW( hDC, ptOrg.x, ptOrg.y, psz, wcslen(psz) );

    GetTextExtent( m_hFont, psz, wcslen( psz ), &size, fHorizontal );
	if (fHorizontal) {
		ptOrg.x += size.cx;
	}
	else {
		ptOrg.y += size.cx;
	}

    //
	//  paint prefix string
    //

	psz = m_pCandListItem->GetCandidateItem()->GetSuffixString();
	if (psz != NULL) {
		colText = GetUIFColor( UIFCOLOR_CTRLTEXTDISABLED );
		SetTextColor( hDC, colText );

		FLTextOutW( hDC, ptOrg.x, ptOrg.y, psz, wcslen(psz) );

		GetTextExtent( m_hFont, psz, wcslen( psz ), &size, fHorizontal );
		if (fHorizontal) {
			ptOrg.x += size.cx;
		}
		else {
			ptOrg.y += size.cx;
		}
    }

    //
    //  paint cand list item string
    //

	psz = m_pCandListItem->GetCandidateItem()->GetInlineComment();
	if (psz != NULL) {
		int cxInlineCommentPos;
        int nFontHeight;

        SelectObject( hDC, m_hFontInlineComment );

        colText = GetUIFColor( UIFCOLOR_CTRLTEXT );
	    SetTextColor( hDC, colText );

		//	Don't do things while (m_cxInlineCommentPos < 0)
		cxInlineCommentPos = max( m_cxInlineCommentPos, 0 );

		//	Get the font height.
        GetTextExtent( m_hFontInlineComment, L"1", 1, &size, fHorizontal );
        nFontHeight = max(size.cx, size.cy);

		if (fHorizontal) {
			ptOrg.x += cxInlineCommentPos;
            ptOrg.y += ( (GetRectRef().bottom - GetRectRef().top) - nFontHeight ) / 2;
			FLTextOutW( hDC, ptOrg.x, ptOrg.y, psz, wcslen(psz) );
		}
		else {
            ptOrg.x -= ( (GetRectRef().right - GetRectRef().left) - nFontHeight ) / 2;
			ptOrg.y += cxInlineCommentPos;
			FLTextOutW( hDC, ptOrg.x, ptOrg.y, psz, wcslen(psz) );
		}
    }

	SetTextColor( hDC, colTextOld );
	SetBkMode( hDC, nBkModeOld );
    SelectObject( hDC, hFontOld );

    // draw button edge

    m_pUIFScheme->DrawCtrlEdge( hDC, &rc, UIFDCF_BUTTON, dwState );

}

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  R O W  L I S T                                                  */
/*                                                                             */
/*=============================================================================*/

//
// CUIFRowList
//

/*   C  U I F  R O W  L I S T   */
/*------------------------------------------------------------------------------

    Constructor of CUIFRowList

------------------------------------------------------------------------------*/
CUIFRowList::CUIFRowList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_nItem        = 0;

    m_pcpCurPage   = NULL;
    m_iItemSelect  = -1;

    m_cpPageHead.iPageStart = 0;
    m_cpPageHead.nPageSize  = 0;
    m_cpPageHead.pPrev      = NULL;
    m_cpPageHead.pNext      = NULL;

    m_pCandPageUpBtn = NULL;
    m_pCandPageDnBtn = NULL;

    for (int i = 0; i < NUM_CANDSTR_MAX; i++) {
        m_rgpButton[i] = NULL;
    }
}


/*   ~  C  U I F  L I S T   */
/*------------------------------------------------------------------------------

    Destructor of CUIFRowList

------------------------------------------------------------------------------*/
CUIFRowList::~CUIFRowList( void )
{
    CListItemBase *pItem;

    while (pItem = m_listItem.GetFirst()) {
        m_listItem.Remove(pItem);
        delete pItem;
    }

    ClearPageInfo();
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize list object

------------------------------------------------------------------------------*/
CUIFObject *CUIFRowList::Initialize( void )
{
    RECT rc = { 0 };

	//
	// create candidate page up button
	//

    m_pCandPageUpBtn = new CUIFSmartPageButton( this, &rc, GetPageUpBtnStyle() );
	m_pCandPageUpBtn->Initialize();
	AddUIObj( m_pCandPageUpBtn );

    //
	// create candidate page down button
	//

    m_pCandPageDnBtn = new CUIFSmartPageButton( this, &rc, GetPageDnBtnStyle() );
	m_pCandPageDnBtn->Initialize();
	AddUIObj( m_pCandPageDnBtn );

    for (int i = 0; i < NUM_CANDSTR_MAX; i++) {
        m_rgpButton[i] = new CUIFRowButton( this, 1 + i, GetRowButtonStyle() );
	    m_rgpButton[i]->Initialize();
	    AddUIObj( m_rgpButton[i] );
    }

    return CUIFObject::Initialize();
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::SetStyle( DWORD dwStyle )
{
    RECT rc;

    CUIFObject::SetStyle( dwStyle );

    // change page button style either

    m_pCandPageUpBtn->SetStyle( GetPageUpBtnStyle() );
    m_pCandPageDnBtn->SetStyle( GetPageDnBtnStyle() );

    for (int i = 0; i < NUM_CANDSTR_MAX; i++) {
        m_rgpButton[i]->SetStyle( GetRowButtonStyle() );
    }

    // set page up button position

    GetPageUpBtnRect( &rc );
    m_pCandPageUpBtn->SetRect( &rc );

    // set page down button position

    GetPageDnBtnRect( &rc );
    m_pCandPageDnBtn->SetRect( &rc );

    // repage

    Repage();

    // update window

    CallOnPaint();
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::SetRect( const RECT *prc )
{
    RECT rc;

    CUIFObject::SetRect( prc );

    // set page up button position

    GetPageUpBtnRect( &rc );
    m_pCandPageUpBtn->SetRect( &rc );

    // set page down button position

    GetPageDnBtnRect( &rc );
    m_pCandPageDnBtn->SetRect( &rc );

    // update window

    CallOnPaint();
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFRowList::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    LRESULT lResult = -1;

	DWORD dwID = pUIObj->GetID();

    if (IDUIF_CANDNUMBUTTON <= dwID && dwID < (DWORD)(IDUIF_CANDNUMBUTTON + NUM_CANDSTR_MAX)) {
        switch (dwCommand) {
            case UILIST_SELCHANGED: {
                SetCurSel( (LONG)(LONG_PTR)(lParam) );
                lResult = 0;
                break;
            }
        }
    }
    else if (pUIObj == m_pCandPageUpBtn) {
        switch (dwCommand) {
            case UIBUTTON_PRESSED: {
                ShiftPage( -1 );
                lResult = 0;
                break;
            }
        }
    }
    else if (pUIObj == m_pCandPageDnBtn) {
        switch (dwCommand) {
            case UIBUTTON_PRESSED: {
                ShiftPage( +1 );
                lResult = 0;
                break;
            }
        }
    }

    if (lResult != 0) {
        Assert(m_pParent != NULL);
        lResult = m_pParent->OnObjectNotify( pUIObj, dwCommand, lParam );
    }

    return lResult;
}


/*   R E P A G E   */
/*------------------------------------------------------------------------------

    Refresh the page info link

------------------------------------------------------------------------------*/
void CUIFRowList::Repage( void )
{
    SIZE          sizeItem;
    BOOL          fPageFull;
    CANDPAGE      *pTrace, *pPageNew;
    int           nPageLimit, nPageOccupied, nItemOnPage, nItemSize;
    CCandListItem *pItem;
    BOOL          fHorizontal;

    ClearPageInfo();

    if (IsRectEmpty( &GetRectRef() )) {
        return;
    }

    pItem = (CCandListItem*)m_listItem.GetFirst();
    if (pItem == NULL) {
        return;
    }

    nPageOccupied = 0;
    nItemOnPage   = 0;
    fPageFull     = FALSE;
    pTrace        = NULL;

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
            Assert(FALSE);

        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            fHorizontal = TRUE;
            nPageLimit  = (GetRectRef().right - GetRectRef().left) - (GetRectRef().bottom - GetRectRef().top) * 2;
            break;
        }
        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            fHorizontal = FALSE;
            nPageLimit  = (GetRectRef().bottom - GetRectRef().top) - (GetRectRef().right - GetRectRef().left) * 2;
            break;
        }
    }

    //
    //  Use the object pointed to m_rgpButton[0] for repaging calculation.
    //
    do {
        if (m_rgpButton[nItemOnPage] == NULL) {
            ClearPageInfo();
            return;
        }

        m_rgpButton[nItemOnPage]->SetCandListItem( pItem );
        m_rgpButton[nItemOnPage]->GetExtent(&sizeItem);

        nItemSize = sizeItem.cx;

        if ( nPageOccupied + nItemSize > nPageLimit ) {
            fPageFull = TRUE;
        }
        else {
            nPageOccupied += nItemSize + HCAND_ITEM_MARGIN;

            nItemOnPage++;
//          pItem = (CCandListItem*)pItem->GetNext();
            int iItem = m_listItem.Find( pItem );
            if (0 <= iItem) {
                pItem = (CCandListItem*)m_listItem.Get( iItem+1 );
            }
            else {
                pItem = NULL;
            }

			//  Reach the max item limit?
            if (nItemOnPage >= NUM_CANDSTR_MAX) {
                fPageFull = TRUE;
            }

			//  Reach the end of cand list?
            if (pItem == NULL) {
                fPageFull = TRUE;
            }
        }

        if (fPageFull) {
            //
            //  Create a new page info node
            //
            pPageNew = new CANDPAGE;
            if (pPageNew == NULL) {
                ClearPageInfo();
                return;
            }

            pPageNew->pNext = NULL;
            pPageNew->pPrev = pTrace;

            if (pTrace != NULL) {
                pPageNew->iPageStart = pTrace->iPageStart + pTrace->nPageSize;
                pTrace->pNext = pPageNew;
            }
            else {
                pPageNew->iPageStart = 0;
                m_cpPageHead.pNext = pPageNew;
            }

            pPageNew->nPageSize = nItemOnPage;

            m_cpPageHead.pPrev = pPageNew;

            pTrace = pPageNew;

            //
            //  Restart the accumulation for next page
            //
            nPageOccupied = 0;
            nItemOnPage   = 0;
            fPageFull     = FALSE;
        }
    } while (pItem != NULL);

    m_pcpCurPage   = m_cpPageHead.pNext;  //  Current page is the 1st.
    m_iItemSelect  = m_pcpCurPage->iPageStart;

    // layout current page row buttons position, and page button status

    LayoutCurPage();
}


/*   S H I F T  I T E M   */
/*------------------------------------------------------------------------------

    shift current item by nItem (+/-)

------------------------------------------------------------------------------*/
void CUIFRowList::ShiftItem( int nItem )
{
    SetCurSel( m_iItemSelect + nItem );
}


/*   S H I F T  P A G E   */
/*------------------------------------------------------------------------------

    shift current page by nPage (+/-)

------------------------------------------------------------------------------*/
void CUIFRowList::ShiftPage( int nPage )
{
    CANDPAGE *pPage;
    int      nPageOffset = nPage;

    pPage = m_pcpCurPage;

    while (pPage != NULL) {
        if (nPageOffset < 0) {
            pPage = pPage->pPrev;
            nPageOffset++;
        }
        else if (nPageOffset > 0) {
            pPage = pPage->pNext;
            nPageOffset--;
        }
        else {
            m_pcpCurPage   = pPage;
            m_iItemSelect  = m_pcpCurPage->iPageStart;
            break;
        }
    }

    // layout current page row buttons position, and page button status

    LayoutCurPage();

    NotifyCommand( UILIST_SELCHANGED, m_iItemSelect );
}


/*   G E T  P A G E  U P  B T N  R E C T   */
/*------------------------------------------------------------------------------

    Get page-up button position

------------------------------------------------------------------------------*/
void CUIFRowList::GetPageUpBtnRect( RECT *prc )
{
    Assert( prc != NULL );

    GetRect(prc);

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
            Assert(FALSE);

        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            prc->right -= GetRectRef().bottom - GetRectRef().top;
            prc->left   = prc->right - (GetRectRef().bottom - GetRectRef().top);
            break;
        }
        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            prc->bottom -= GetRectRef().right - GetRectRef().left;
            prc->top     = prc->bottom - (GetRectRef().right - GetRectRef().left);
            break;
        }
    }
}


/*   G E T  P A G E  D O W N  B T N  R E C T   */
/*------------------------------------------------------------------------------

    Get page-down button position

------------------------------------------------------------------------------*/
void CUIFRowList::GetPageDnBtnRect( RECT *prc )
{
    Assert( prc != NULL );

    GetRect(prc);

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
            Assert(FALSE);

        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            prc->left = GetRectRef().right - (GetRectRef().bottom - GetRectRef().top);
            break;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            prc->top = GetRectRef().bottom - (GetRectRef().right - GetRectRef().left);
            break;
        }
    }
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

    Set font for UI and candidate list

------------------------------------------------------------------------------*/
void CUIFRowList::SetFont( HFONT hFont )
{
    CUIFObject::SetFont( hFont );

    // repage

    Repage();

    // update window

    CallOnPaint();
}


/*   G E T  P A G E  U P  B T N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get page up button style

------------------------------------------------------------------------------*/
DWORD CUIFRowList::GetPageUpBtnStyle( void )
{
    switch (m_dwStyle) {
        default:
            Assert(FALSE);

        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            return UISCROLLBUTTON_LEFT;
            break;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            return UISCROLLBUTTON_UP;
        }
    }
}


/*   G E T  P A G E  D N  B T N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get page-down button style

------------------------------------------------------------------------------*/
DWORD CUIFRowList::GetPageDnBtnStyle( void )
{
    switch (m_dwStyle) {
        default:
            Assert(FALSE);

        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            return UISCROLLBUTTON_RIGHT;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            return UISCROLLBUTTON_DOWN;
        }
    }
}


/*   G E T  R O W  B U T T O N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get row button style

------------------------------------------------------------------------------*/
DWORD CUIFRowList::GetRowButtonStyle( void )
{
    switch ( m_dwStyle ) {
        default:
            Assert(FALSE);

        case UILIST_HORZTB:
        case UILIST_HORZBT:
            return UIBUTTON_PUSH | UIBUTTON_VCENTER | UIBUTTON_LEFT;

        case UILIST_VERTLR:
        case UILIST_VERTRL:
            return UIBUTTON_PUSH | UIBUTTON_CENTER | UIBUTTON_TOP;
    }
}


/*   C L E A R  P A G E  I N F O   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::ClearPageInfo( void )
{
    CANDPAGE *pPage;

    while (pPage = m_cpPageHead.pNext) {
        m_cpPageHead.pNext = pPage->pNext;
        delete pPage;
    }
    m_cpPageHead.pPrev = NULL;

    m_pcpCurPage   = NULL;
    m_iItemSelect  = -1;
}

/*   R E  L A Y O U T  C U R  P A G E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::LayoutCurPage( void )
{
    int           i;
    CCandListItem *pItem;
    RECT          rc;
    SIZE          size;

    if (IsRectEmpty( &GetRectRef() )) {
        return;
    }

    i = 0;

    if (m_pcpCurPage != NULL) {
        GetRect( &rc );
        switch ( m_dwStyle ) {
            default:
                Assert(FALSE);

            case UILIST_HORZTB:
            case UILIST_HORZBT:
                rc.right = rc.left - HCAND_ITEM_MARGIN;
                break;
            case UILIST_VERTLR:
            case UILIST_VERTRL:
                rc.bottom = rc.top - HCAND_ITEM_MARGIN;
                break;
        }

        for (NULL; i < m_pcpCurPage->nPageSize; i++) {
            pItem = (CCandListItem*)GetCandItem( m_pcpCurPage->iPageStart + i );

            Assert(pItem != NULL);

            m_rgpButton[i]->SetCandListItem(pItem);
            m_rgpButton[i]->GetExtent( &size );
            m_rgpButton[i]->SetSelected( (m_pcpCurPage->iPageStart + i == m_iItemSelect) ? TRUE : FALSE );

            switch ( m_dwStyle ) {
                default:
                    Assert(FALSE);

                case UILIST_HORZTB:
                case UILIST_HORZBT: {
                    rc.left  = rc.right + HCAND_ITEM_MARGIN;
                    rc.right = rc.left + size.cx;
                    break;
                }
                case UILIST_VERTLR:
                case UILIST_VERTRL: {
                    rc.top    = rc.bottom + HCAND_ITEM_MARGIN;
                    rc.bottom = rc.top + size.cx;
                    break;
                }
            }

            m_rgpButton[i]->SetRect( &rc );
            m_rgpButton[i]->Show( TRUE );
        }
    }

    for (NULL; i < NUM_CANDSTR_MAX; i++) {
        m_rgpButton[i]->SetSelected( FALSE );
        m_rgpButton[i]->Show( FALSE );
    }

    //
    // update paging buttons enable/disable status
    //

    if (m_pcpCurPage) {
        //  m_cpPageHead.pPrev is the first page
        m_pCandPageUpBtn->Enable( (m_pcpCurPage != m_cpPageHead.pNext) ? TRUE : FALSE );

        //  m_cpPageHead.pPrev is the last page
        m_pCandPageDnBtn->Enable( (m_pcpCurPage != m_cpPageHead.pPrev) ? TRUE : FALSE );
    }
	else {
        m_pCandPageUpBtn->Enable( FALSE );
        m_pCandPageDnBtn->Enable( FALSE );
    }

    // update window

    CallOnPaint();
}


/*   S E T  I N L I N E  C O M M E N T  F O N T   */
/*------------------------------------------------------------------------------

	Set font for inline comment

------------------------------------------------------------------------------*/
void CUIFRowList::SetInlineCommentFont( HFONT hFont )
{
	if (hFont == NULL) {
		hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
	}

    for (int i = 0; i < NUM_CANDSTR_MAX; i++) {
        if (m_rgpButton[i] != NULL) {
            m_rgpButton[i]->SetInlineCommentFont( hFont );
        }
    }

    // repage

    Repage();

    // update window

    CallOnPaint();
}


/*   S E T  I N L I N E  C O M M E N T  P O S   */
/*------------------------------------------------------------------------------

	Set (horizontal) position to draw inline comment
	NOTE: if cx has negative value, inline comment will be on the left of item text.

------------------------------------------------------------------------------*/
void CUIFRowList::SetInlineCommentPos( int cx )
{
    for (int i = 0; i < NUM_CANDSTR_MAX; i++) {
        if (m_rgpButton[i] != NULL) {
            m_rgpButton[i]->SetInlineCommentPos( cx );
        }
    }

    // repage

    Repage();

    // update window

    CallOnPaint();
}


/*   S E T  I N D E X  F O N T   */
/*------------------------------------------------------------------------------

	Set font for index

------------------------------------------------------------------------------*/
void CUIFRowList::SetIndexFont( HFONT hFont )
{
}


/*   A D D  C A N D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFRowList::AddCandItem( CCandListItem *pCandListItem )
{
	int nId = m_nItem;
	m_listItem.Add( pCandListItem );
	m_nItem++;

	return nId;
}


/*   S E T  C A N D  L I S T   */
/*------------------------------------------------------------------------------

	Set candidate list

------------------------------------------------------------------------------*/
void CUIFRowList::SetCandList( CCandidateList *pCandList )
{
	int nCandItem;
	int i;
	CCandidateItem *pCandItem;

    ASSERT( pCandList );

    nCandItem = pCandList->GetItemCount();
	for (i = 0; i < nCandItem; i++) {

        pCandItem = pCandList->GetCandidateItem( i );
		if (pCandItem->IsVisible()) {
			CCandListItem *pCandListItem = new CCandListItem( GetItemCount(), i, pCandItem );

			AddCandItem( pCandListItem );
		}
	}

    //  update page info

    Repage();

    // update window

    CallOnPaint();

    return;
}


/*   S E T  C U R  S E L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::SetCurSel( int iSelection )
{
    CANDPAGE *pPage;

    m_iItemSelect = min(iSelection, m_nItem - 1);
    m_iItemSelect = max(0, m_iItemSelect);

    pPage = m_pcpCurPage;

    while (pPage != NULL) {
        if (m_iItemSelect < pPage->iPageStart) {
            pPage = pPage->pPrev;
        }
        else if (m_iItemSelect >= pPage->iPageStart + pPage->nPageSize) {
            pPage = pPage->pNext;
        }
        else {
            m_pcpCurPage = pPage;
            break;
        }
    }

    // layout current page row buttons position, and page button status

    LayoutCurPage();

    NotifyCommand( UILIST_SELCHANGED, m_iItemSelect );
}


/*   D E L  A L L  C A N D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::DelAllCandItem( void )
{
    CListItemBase *pItem;

    while (pItem = m_listItem.GetFirst()) {
        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;
    }
    Assert(!m_nItem);

    m_pcpCurPage   = NULL;
    m_iItemSelect  = -1;

    // layout current page row buttons position, and page button status

    LayoutCurPage();
}


/*   G E T  C A N D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandListItem *CUIFRowList::GetCandItem( int nId )
{
    int nItem;
    int i;
    CListItemBase *pItem;

    nItem = m_listItem.GetCount();
    for (i = 0; i < nItem; i++) {
        pItem = m_listItem.Get( i );
        if (nId == (int)((CCandListItem*)pItem)->GetIListItem()) {
            return (CCandListItem*)pItem;
        }
    }

    return NULL;
}


/*   G E T  C U R  S E L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFRowList::GetCurSel( void )
{
    return m_iItemSelect;
}


/*   G E T  T O P  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFRowList::GetTopItem( void )
{
    if (m_pcpCurPage != NULL) {
        return m_pcpCurPage->iPageStart;
    }
    else {
        return -1;
    }
}


/*   G E T  B O T O M  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFRowList::GetBottomItem( void )
{
    if (m_pcpCurPage != NULL) {
        return m_pcpCurPage->iPageStart + m_pcpCurPage->nPageSize;
    }
    else {
        return -1;
    }
}


/*   I S  V I S I B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFRowList::IsVisible( void )
{
    return CUIFObject::IsVisible();
}


/*   G E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::GetRect( RECT *prc )
{
    CUIFObject::GetRect( prc );
}


/*   G E T  I T E M  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFRowList::GetItemRect( int iItem, RECT *prc )
{
    Assert( prc != NULL );

    ::SetRect( prc, 0, 0, 0, 0 );
    if (GetTopItem() <= iItem && iItem <= GetBottomItem()) {
        int iButton = iItem - GetTopItem();
        if ((0 <= iButton && iButton < NUM_CANDSTR_MAX)  && m_rgpButton[iButton]->IsVisible()) {
            m_rgpButton[iButton]->GetRect( prc );
        }
    }
}


/*   G E T  I T E M  C O U N T   */
/*------------------------------------------------------------------------------

	Returns number of candidate item
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
int CUIFRowList::GetItemCount( void )
{
    return m_nItem;
}


/*   I S  I T E M  S E L E C T A B L E   */
/*------------------------------------------------------------------------------

    Returns TRUE, if candidate item with given index could be selected.
    Otherwise, returns FALSE.
	(CUIFCandListBase method)

------------------------------------------------------------------------------*/
BOOL CUIFRowList::IsItemSelectable( int iListItem )
{
	// Satori#3632(Cicero#3413)
	if (m_pcpCurPage == NULL) {
		return FALSE;
	}

    if ( iListItem < m_pcpCurPage->iPageStart ) {
    } else if ((m_pcpCurPage->iPageStart + m_pcpCurPage->nPageSize) <= iListItem) {
    } else {
		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\cuicand2.h ===
//
//  cuicand2.h
//  candidate UI object library - define UI objects for CHS candidate UI
//
//      CUIFObject
//        +- CUIFButton                 button object
//        |    +- CUIFRowButton         CHS candidate UI row button object (used in CUIFRowList)
//        +- CUIFRowList                CHS candidate UI row control 
//


#ifndef CUICAND2_H
#define CUICAND2_H

#include "private.h"
#include "cuilib.h"

#include "cuicand.h"


#ifndef NUM_CANDSTR_MAX
#define NUM_CANDSTR_MAX     9
#endif

#define HCAND_ITEM_MARGIN   6

//
// CUIFSmartMenuButton
//

class CUIFSmartMenuButton : public CUIFButton2
{
public:
	CUIFSmartMenuButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFSmartMenuButton( void );

	virtual void OnPaint(HDC hDC);
};


//
// CUIFSmartPageButton
//

class CUIFSmartPageButton : public CUIFButton2
{
public:
	CUIFSmartPageButton( CUIFObject *pParent, const RECT *prc, DWORD dwStyle );
	~CUIFSmartPageButton( void );

	virtual void OnPaint( HDC hDC );
};


//
// CUIFRowButton
//

class CUIFRowButton : public CUIFButton2
{
public:
	CUIFRowButton( CUIFObject *pParent, DWORD dwID, DWORD dwStyle );
	~CUIFRowButton(void);

	void    OnPaint( HDC hDC );
	void    SetStyle( DWORD dwStyle );
	void    OnLButtonDown( POINT pt );

	void    SetCandListItem( CCandListItem* pItem );
	virtual void    SetInlineCommentPos( int cx );
	virtual void    SetInlineCommentFont( HFONT hFont );

	void    GetExtent( SIZE *psize );
	void    SetSelected( BOOL );

protected:
	void    UpdateText( void );

	CCandListItem *m_pCandListItem;
	HFONT         m_hFontInlineComment;
	int           m_cxInlineCommentPos;
	BOOL          m_fSelected;
};

//
// CANDPAGE
//

struct tagCANDPAGE;

typedef struct tagCANDPAGE {
	int          iPageStart;
	int          nPageSize;
	tagCANDPAGE* pPrev;
	tagCANDPAGE* pNext;
} CANDPAGE;

//
// CUIFRowList
//

class CUIFRowList : public CUIFObject,
	                public CUIFCandListBase
{
public:
	CUIFRowList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	~CUIFRowList( void );

	//
	//  CUIFObject members
	//
	
	CUIFObject *Initialize( void );
	void    SetRect( const RECT *prc );
	void    SetStyle( DWORD dwStyle );
	void    SetFont( HFONT hFontUI );
	LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

	//
	//  CUIFCandListBase members
	//

	virtual int       GetCurSel( void );
	virtual int       GetTopItem( void );
	virtual int       GetBottomItem( void );
	virtual BOOL      IsVisible( void );
	virtual void      GetRect( RECT *prc );
	virtual void      GetItemRect( int iItem, RECT *prc );
	virtual int       GetItemCount( void );
    virtual BOOL      IsItemSelectable( int iListItem );
	virtual int       AddCandItem( CCandListItem *pCandListItem );
	virtual CCandListItem *GetCandItem( int iItem );
	virtual void      DelAllCandItem( void );
	virtual void      SetCurSel( int iSelection );
	virtual void      SetInlineCommentPos( int cx );
	virtual void      SetInlineCommentFont( HFONT hFont );
	virtual void      SetIndexFont( HFONT hFont );
	virtual void      SetCandList( CCandidateList *pCandList );

	virtual BSTR      GetAccNameProc( int iItem )					{ return NULL; }
	virtual BSTR      GetAccValueProc( int iItem )					{ return NULL; }
	virtual LONG      GetAccRoleProc( int iItem  )					{ return ROLE_SYSTEM_CLIENT; }
	virtual LONG      GetAccStateProc( int iItem  )					{ return STATE_SYSTEM_DEFAULT; }
	virtual void      GetAccLocationProc( int iItem, RECT *prc )	{ ::SetRect( prc, 0, 0, 0, 0 ); }

	//
	//
	//

	void    ShiftItem( int nItem );
	void    ShiftPage( int nPage );

protected:
	void    ClearPageInfo( void );
	void    Repage( void );
	void    LayoutCurPage( void );

	void    GetPageUpBtnRect( RECT *prc );
	void    GetPageDnBtnRect( RECT *prc );

	DWORD   GetPageUpBtnStyle( void );
	DWORD   GetPageDnBtnStyle( void );
	DWORD   GetRowButtonStyle( void );

	int m_nItem;
	int m_iItemSelect;

	CUIFSmartPageButton *m_pCandPageUpBtn;
	CUIFSmartPageButton *m_pCandPageDnBtn;
	CUIFRowButton       *m_rgpButton[NUM_CANDSTR_MAX];

	CUIFObjectArray<CListItemBase> m_listItem;
	CANDPAGE *m_pcpCurPage;
	CANDPAGE m_cpPageHead;
};


#endif /* CUICAND2_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\cuicand.h ===
//
// cuiobj.h
//  UI object library - define UI objects
//
//      CUIFObject
//        +- CUIFBorder                 border object
//        +- CUIFStatic                 static object
//        +- CUIFButton                 button object
//        |    +- CUIFScrollButton      scrollbar button object (used in CUIFScroll)
//        +- CUIFScrollButton               scrollbar thumb object (used in CUIFScroll)
//        +- CUIFScroll                 scrollbar object
//        +- CUIFList                   listbox object
//        +- CUIFWindow                 window frame object (need to be at top of parent)
//


#ifndef CUICAND_H
#define CUICAND_H

#include "private.h"
#include "cuilib.h"

#include "candmgr.h"
#include "candacc.h"


#define CANDLISTACCITEM_MAX		9

class CUIFCandListBase;


//
// CUIFSmartScrollButton
//

class CUIFSmartScrollButton : public CUIFScrollButton
{
public:
	CUIFSmartScrollButton( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle );
	~CUIFSmartScrollButton( void );

protected:
	void OnPaintNoTheme( HDC hDC );
	BOOL OnPaintTheme( HDC hDC );
};


//
// CUIFScrollThumb
//

#define UISMARTSCROLLTHUMB_VERT		0x00000000
#define UISMARTSCROLLTHUMB_HORZ		0x00010000


class CUIFSmartScrollThumb : public CUIFScrollThumb
{
public:
	CUIFSmartScrollThumb( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFSmartScrollThumb( void );

	virtual void OnMouseIn( POINT pt );
	virtual void OnMouseOut( POINT pt );
	virtual void OnPaint( HDC hDC );

protected:
	void OnPaintNoTheme( HDC hDC );
	BOOL OnPaintTheme( HDC hDC );

	BOOL m_fMouseIn;
};


//
// CUIFSmartScroll
//

class CUIFSmartScroll : public CUIFScroll
{
public:
	CUIFSmartScroll( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFSmartScroll( void );

	virtual void SetStyle( DWORD dwStyle );

	virtual CUIFObject *Initialize( void );

protected:
	void OnPaintNoTheme( HDC hDC );
	BOOL OnPaintTheme( HDC hDC );
};


//
// CCandListItem
//  = candidate list item object =
//

class CCandListItem : public CListItemBase
{
public:
	CCandListItem( int iListItem, int iCandItem, CCandidateItem *pCandItem )
	{
		Assert( pCandItem != NULL );

		m_iListItem = iListItem;
		m_iCandItem = iCandItem;
		m_pCandItem = pCandItem;
	}

	virtual ~CCandListItem( void )
	{
	}

	int GetIListItem( void )
	{
		return m_iListItem;
	}

	int GetICandItem( void )
	{
		return m_iCandItem;
	}

	CCandidateItem *GetCandidateItem( void )
	{
		return m_pCandItem;
	}

protected:
	int            m_iListItem;
	int            m_iCandItem;
	CCandidateItem *m_pCandItem;
};


//
// CCandListAccItem
//  = candidate list accessible item =
//

class CCandListAccItem : public CCandAccItem
{
public:
	CCandListAccItem( CUIFCandListBase *pListUIObj, int iLine );
	virtual ~CCandListAccItem( void );

	//
	// CandAccItem method
	//
	virtual BSTR GetAccName( void );
	virtual BSTR GetAccValue( void );
	virtual LONG GetAccRole( void );
	virtual LONG GetAccState( void );
	virtual void GetAccLocation( RECT *prc );

	void OnSelect( void );

protected:
	CUIFCandListBase *m_pListUIObj;
	CUIFCandListBase *m_pOptionsListUIObj;
	int               m_iLine;
};


//
// CUIFCandListBase
//  = candidate list UI object base class =
//

class CUIFCandListBase
{
public:
	CUIFCandListBase( void );
	virtual ~CUIFCandListBase( void );

	//
	//
	//
	virtual int AddCandItem( CCandListItem *pCandListItem )     = 0;	/* PURE */
	virtual int GetItemCount( void )                            = 0;	/* PURE */
	virtual BOOL IsItemSelectable( int iListItem )              = 0;	/* PURE */
	virtual CCandListItem *GetCandItem( int iItem )             = 0;	/* PURE */
	virtual void DelAllCandItem( void )                         = 0;	/* PURE */
	virtual void SetCurSel( int iSelection )                    = 0;	/* PURE */
	virtual int GetCurSel( void )                               = 0;	/* PURE */
	virtual int GetTopItem( void )                              = 0;	/* PURE */
	virtual int GetBottomItem( void )                           = 0;	/* PURE */
	virtual BOOL IsVisible( void )                              = 0;	/* PURE */
	virtual void GetRect( RECT *prc )                           = 0;	/* PURE */
	virtual void GetItemRect( int iItem, RECT *prc )            = 0;	/* PURE */
	virtual void SetInlineCommentPos( int cx )                  = 0;	/* PURE */
	virtual void SetInlineCommentFont( HFONT hFont )            = 0;	/* PURE */
	virtual void SetIndexFont( HFONT hFont )                    = 0;	/* PURE */
	virtual void SetCandList( CCandidateList *pCandList )       = 0;	/* PURE */

	// accessibility functions
	virtual BSTR GetAccNameProc( int iItem )                    = 0;	/* PURE */
	virtual BSTR GetAccValueProc( int iItem )                   = 0;	/* PURE */
	virtual LONG GetAccRoleProc( int iItem  )                   = 0;	/* PURE */
	virtual LONG GetAccStateProc( int iItem  )                  = 0;	/* PURE */
	virtual void GetAccLocationProc( int iItem, RECT *prc )     = 0;	/* PURE */

	void InitAccItems( CCandAccessible *pCandAcc );
	CCandListAccItem *GetListAccItem( int i );

	CCandidateItem *GetCandidateItem( int iItem );
	void SetIconPopupComment( HICON hIconOn, HICON hIconOff );

protected:
	CCandListAccItem *m_rgListAccItem[ CANDLISTACCITEM_MAX ];
	HFONT m_hFontInlineComment; 
	HFONT m_hFontIndex;
	HICON m_hIconPopupOn;
	HICON m_hIconPopupOff;
};


//
// CUIFCandList
//  = candidate list UI object =
//

// notification code
#define UICANDLIST_HOVERITEM			0x00010000

class CUIFCandList : public CUIFListBase,
					 public CUIFCandListBase
{
public:
	CUIFCandList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFCandList( void );

	//
	// CUIFCandListBase methods
	//
	virtual int AddCandItem( CCandListItem *pCandListItem );
	virtual int GetItemCount( void );
	virtual BOOL IsItemSelectable( int iListItem );
	virtual CCandListItem *GetCandItem( int iItem );
	virtual void DelAllCandItem( void );
	virtual void SetCurSel( int iSelection );
	virtual int GetCurSel( void );
	virtual int GetTopItem( void );
	virtual int GetBottomItem( void );
	virtual BOOL IsVisible( void );
	virtual void GetRect( RECT *prc );
	virtual void GetItemRect( int iItem, RECT *prc );
	virtual void SetInlineCommentPos( int cx );
	virtual void SetInlineCommentFont( HFONT hFont );
	virtual void SetIndexFont( HFONT hFont );
	virtual void SetCandList( CCandidateList *pCandList );

	virtual BSTR GetAccNameProc( int iItem );
	virtual BSTR GetAccValueProc( int iItem );
	virtual LONG GetAccRoleProc( int iItem  );
	virtual LONG GetAccStateProc( int iItem  );
	virtual void GetAccLocationProc( int iItem, RECT *prc );

	//
	// CUIFObject methods
	//
	virtual void OnLButtonDown( POINT pt );
	virtual void OnLButtonUp( POINT pt );
	virtual void OnMouseMove( POINT pt );
	virtual void OnMouseIn( POINT pt );
	virtual void OnMouseOut( POINT pt );
	virtual void OnPaint( HDC hDC );

	void SetStartIndex( int iIndexStart );
	void SetExtraTopSpace( int nSize );
	void SetExtraBottomSpace( int nSize );
	int GetExtraTopSpace( void );
	int GetExtraBottomSpace( void );

protected:
	//
	// CUIFListBase methods
	//
	virtual void GetLineRect( int iLine, RECT *prc );
	virtual void GetScrollBarRect( RECT *prc );
	virtual DWORD GetScrollBarStyle( void );
	virtual CUIFScroll *CreateScrollBarObj( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle );

	void PaintItemProc( HDC hDC, RECT *prc, int iIndex, CCandListItem *pItem, BOOL fSelected );
	void PaintItemText( HDC hDC, RECT *prcText, RECT *prcClip, RECT *prcIndex, CCandidateItem *pCandItem, BOOL fSelected );
	void SetItemHover( int iItem );

	int   m_iIndexStart;
	int   m_nExtTopSpace;
	int   m_nExtBottomSpace;
	int   m_cxInlineCommentPos;
	int   m_iItemHover;
};


//
//
//

class CUIFExtCandList : public CUIFCandList
{
public:
	CUIFExtCandList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFExtCandList( void );

	//
	// CUIFObject methods
	//
	virtual void OnTimer( void );
	virtual void OnLButtonUp( POINT pt );
	virtual void OnMouseMove( POINT pt );
	virtual void OnMouseOut( POINT pt );
};


//
// CUIFCandRawData
//  = candidate raw data UI object =
//

#define UICANDRAWDATA_HORZTB	0x00000000
#define UICANDRAWDATA_HORZBT	0x00000001
#define UICANDRAWDATA_VERTLR	0x00000002
#define UICANDRAWDATA_VERTRL	0x00000003

#define UICANDRAWDATA_CLICKED	0x00000001


class CUIFCandRawData : public CUIFObject
{
public:
	CUIFCandRawData( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFCandRawData( void );

	void ClearData( void );
	void SetText( LPCWSTR pwchText );
	void SetBitmap( HBITMAP hBitmap );
	void SetMetaFile( HENHMETAFILE hEnhMetaFile );
	int GetText( LPWSTR pwchBuf, int cwchBuf );
	HBITMAP GetBitmap( void );
	HENHMETAFILE GetMetaFile( void );

	virtual void SetFont( HFONT hFont );
	virtual void SetStyle( DWORD dwStyle );
	virtual void OnPaint( HDC hDC );
	virtual void OnLButtonDown( POINT pt );
	virtual void OnLButtonUp( POINT pt );

protected:
	LPWSTR       m_pwchText;
	HBITMAP      m_hBitmap;
	HENHMETAFILE m_hEnhMetaFile;
	HBITMAP      m_hBmpCache;

	void ClearCache( void );
	void DrawTextProc( HDC hDC, const RECT *prc );
	void DrawBitmapProc( HDC hDC, const RECT *prc );
	void DrawMetaFileProc( HDC hDC, const RECT *prc );
};


//
// CUIFCandBorder
//  = border object in candidate UI =
//

class CUIFCandBorder : public CUIFBorder
{
public:
	CUIFCandBorder( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFCandBorder( void );

	void OnPaint( HDC hDC );
};


//
// CUIFCandMenuButton
//  = candidate menu button =
//

class CUIFCandMenuButton : public CUIFButton2, public CCandAccItem
{
public:
	CUIFCandMenuButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFCandMenuButton( void );

	//
	// CandAccItem method
	//
	virtual BSTR GetAccName( void );
	virtual BSTR GetAccValue( void );
	virtual LONG GetAccRole( void );
	virtual LONG GetAccState( void );
	virtual void GetAccLocation( RECT *prc );

protected:
	virtual void SetStatus( DWORD dwStatus );
};


#endif /* CUIOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "initguid.h"
#include "mscandui.h"
#include "globals.h"

HINSTANCE g_hInst = NULL;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

CCandUIShareMem g_ShareMem;
UINT g_msgHookedMouse = WM_NULL;
UINT g_msgHookedKey   = WM_NULL;

PSECURITY_ATTRIBUTES g_psa = NULL;


/* 94bed74a-5b62-4f0e-b2fa-9302d406369c */
const GUID GUID_COMPARTMENT_CANDUI_KEYTABLE = { 
	0x94bed74a,
	0x5b62, 
	0x4f0e, 
	{ 0xb2, 0xfa, 0x93, 0x02, 0xd4, 0x06, 0x36, 0x9c }
};

/* 66fe171c-5757-4bfe-a049-0da6c3cbe18f */
const GUID GUID_COMPARTMENT_CANDUI_UISTYLE = {
	0x66fe171c,
	0x5757,
	0x4bfe,
	{ 0xa0, 0x49, 0x0d, 0xa6, 0xc3, 0xcb, 0xe1, 0x8f }
};

/* 8265d817-7982-42cc-bccc-91ad52f561bd */
const GUID GUID_COMPARTMENT_CANDUI_UIOPTION = {
	0x8265d817,
	0x7982,
	0x42cc,
	{ 0xbc, 0xcc, 0x91, 0xad, 0x52, 0xf5, 0x61, 0xbd }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\ids.h ===
// res ids
// grammar ids
#define GRAM_ID_CANDCC         1 // general grammar id
#define GRAM_ID_DICT           2 // dictation grammar id

// string ids
#define IDS_CMD_EXT            1000

// cfgs
#define ID_DICTATION_COMMAND_CFG       2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "cuilib.h"
#include "candutil.h"
#include "candacc.h"

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() == 1)
    {
        fRet = TFInitLib();
        InitUIFLib();
        InitCandAcc();
    }

    LeaveCriticalSection(GetServerCritSec());
    
    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() == 0)
    {
        TFUninitLib();
        DoneUIFLib();
        DoneCandAcc();
    }

    LeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for immx project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define OEMRESOURCE 1
#include <windows.h>
#include <ccstock.h>
#include <debug.h>
#include <olectl.h>
#include <richedit.h>
#include <commctrl.h>
#ifdef __cplusplus
#include <atlbase.h>
#endif // __cplusplus
#include "msctf.h"
#include "helpers.h"
#include "fontlink.h"
#include "combase.h"
#include "mem.h"  // put this last because it macros "new" in DEBUG
#include "chkobj.h"

#ifdef __cplusplus
#include "sapi.h"
#include "sphelper.h"
#endif /* __cplusplus */
#include "strsafe.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\propdata.cpp ===
//
// propdata.cpp
//

#include "private.h"
#include "propdata.h"
#include "candutil.h"

/*============================================================================*/
/*                                                                            */
/*   C  P R O P  B O O L                                                      */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  B O O L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropBool::CPropBool( void )
{
	m_flag = FALSE;
}


/*   ~  C  P R O P  B O O L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropBool::~CPropBool( void )
{
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropBool::Set( BOOL flag )
{
	if (m_flag == flag) {
		return S_FALSE;
	}

	m_flag = flag;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropBool::Get( BOOL *pflag )
{
	if (pflag == NULL) {
		return E_INVALIDARG;
	}
	*pflag = m_flag;
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  P R O P  U I N T                                                      */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  U I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropUINT::CPropUINT( void )
{
	m_val = 0;
}


/*   ~  C  P R O P  U I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropUINT::~CPropUINT( void )
{
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropUINT::Set( UINT val )
{
	if (m_val == val) {
		return S_FALSE;
	}

	m_val = val;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropUINT::Get( UINT *pval )
{
	if (pval == NULL) {
		return E_INVALIDARG;
	}
	*pval = m_val;
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  P R O P  L O N G                                                      */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  L O N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropLong::CPropLong( void )
{
	m_val = 0;
}


/*   ~  C  P R O P  L O N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropLong::~CPropLong( void )
{
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropLong::Set( LONG val )
{
	if (m_val == val) {
		return S_FALSE;
	}

	m_val = val;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropLong::Get( LONG *pval )
{
	if (pval == NULL) {
		return E_INVALIDARG;
	}
	*pval = m_val;
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  P R O P  S I Z E                                                      */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropSize::CPropSize( void )
{
	m_size.cx = 0;
	m_size.cy = 0;
}


/*   ~  C  P R O P  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropSize::~CPropSize( void )
{
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropSize::Set( SIZE *psize )
{
	if (psize == NULL) {
		return E_INVALIDARG;
	}

	if (m_size.cx == psize->cx && m_size.cy == psize->cy) {
		return S_FALSE;
	}

	m_size = *psize;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropSize::Get( SIZE *psize )
{
	if (psize == NULL) {
		return E_INVALIDARG;
	}

	*psize = m_size;
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  P R O P  P O I N T                                                    */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  P O I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropPoint::CPropPoint( void )
{
	m_pt.x = 0;
	m_pt.y = 0;
}


/*   ~  C  P R O P  P O I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropPoint::~CPropPoint( void )
{
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropPoint::Set( POINT *ppt )
{
	if (ppt == NULL) {
		return E_INVALIDARG;
	}

	if (m_pt.x == ppt->x && m_pt.y == ppt->y) {
		return S_FALSE;
	}

	m_pt = *ppt;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropPoint::Get( POINT *ppt )
{
	if (ppt == NULL) {
		return E_INVALIDARG;
	}

	*ppt = m_pt;
	return S_OK;
}


/*============================================================================*/
/*                                                                            */
/*   C  P R O P  T E X T                                                      */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropText::CPropText( void )
{
	m_pwch = NULL;
}


/*   ~  C  P R O P  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropText::~CPropText( void )
{
	if (m_pwch != NULL) {
		delete m_pwch;
		m_pwch = NULL;
	}
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropText::Set( BSTR bstr )
{
	LPWSTR pwchNew = NULL;

	if (bstr != NULL) {
		int l = wcslen((LPCWSTR)bstr);
		pwchNew = new WCHAR[ l + 1 ];
		if (pwchNew == NULL) {
			return E_OUTOFMEMORY;
		}

		StringCchCopyW( pwchNew, l+1, (LPCWSTR)bstr );
	}

	if (m_pwch != NULL) {
		delete m_pwch;
	}
	m_pwch = pwchNew;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropText::Get( BSTR *pbstr )
{
	if (pbstr == NULL) {
		return E_INVALIDARG;
	}

	*pbstr = SysAllocString( ((m_pwch == NULL) ? L"" : m_pwch) );
	return (*pbstr != NULL) ? S_OK : E_OUTOFMEMORY;
}


/*============================================================================*/
/*                                                                            */
/*   C  P R O P  F O N T                                                      */
/*                                                                            */
/*============================================================================*/

/*   C  P R O P  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropFont::CPropFont( void )
{
	memset( &m_lf, 0, sizeof(m_lf) );
	m_ort   = PROPFONTORT_DONTCARE;
	m_hFont = NULL;
}


/*   ~  C  P R O P  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CPropFont::~CPropFont( void )
{
	if (m_hFont != NULL) {
		DeleteObject( m_hFont );
	}
}


/*   S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropFont::Set( LOGFONTW *plf )
{
	HFONT hFontNew;

	if (plf == NULL) {
		return E_INVALIDARG;
	}

	if ((memcmp( &m_lf, plf, sizeof(LOGFONTW)-LF_FACESIZE*sizeof(WCHAR) ) == 0)
		&& wcscmp( m_lf.lfFaceName, plf->lfFaceName ) == 0) {
		return S_OK;
	}

	hFontNew = CreateFontProc( plf, m_ort );
	if (hFontNew == NULL) {
		return E_FAIL;
	}

	if (m_hFont) {
		DeleteObject( m_hFont );
	}

	m_lf = *plf;
	m_hFont = hFontNew;
	return S_OK;
}


/*   G E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropFont::Get( LOGFONTW *plf )
{
	if (plf == NULL) {
		return E_INVALIDARG;
	}

	*plf = m_lf;
	return S_OK;
}


/*   S E T  O R I E N T A T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CPropFont::SetOrientation( PROPFONTORIENTATION ort )
{
	HFONT hFontNew;

	if (m_ort == ort) {
		return S_FALSE;
	}

	hFontNew = CreateFontProc( &m_lf, ort );
	if (hFontNew == NULL) {
		return E_FAIL;
	}

	if (m_hFont) {
		DeleteObject( m_hFont );
	}

	m_ort = ort;
	m_hFont = hFontNew;
	return S_OK;
}


/*   C R E A T E  F O N T  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HFONT CPropFont::CreateFontProc( const LOGFONTW *plf, PROPFONTORIENTATION ort )
{
	LOGFONTW lf;

	lf = *plf;
	switch (ort) {
		case PROPFONTORT_DONTCARE: {
			break;
		}

		case PROPFONTORT_ORT0: {
			lf.lfEscapement = lf.lfOrientation = 0;
			break;
		}

		case PROPFONTORT_ORT90: {
			lf.lfEscapement = lf.lfOrientation = 900;
			break;
		}

		case PROPFONTORT_ORT180: {
			lf.lfEscapement = lf.lfOrientation = 1800;
			break;
		}

		case PROPFONTORT_ORT270: {
			lf.lfEscapement = lf.lfOrientation = 2700;
			break;
		}
	}

	return OurCreateFontIndirectW( &lf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\propdata.h ===
//
// propdata.h - CandidateUI property data type
//

#ifndef PROPDATA_H
#define PROPDATA_H

//
//
//

typedef enum _PROPFONTORIENTATION
{
	PROPFONTORT_DONTCARE,
	PROPFONTORT_ORT0,
	PROPFONTORT_ORT90,
	PROPFONTORT_ORT180,
	PROPFONTORT_ORT270,
} PROPFONTORIENTATION;


//
// CPropBool
//  = CandidateUI property data - boolean =
//

class CPropBool
{
public:
	CPropBool( void );
	virtual ~CPropBool( void );

	HRESULT Set( BOOL flag );
	HRESULT Get( BOOL *pflag );
	__inline BOOL Get( void )
	{
		return m_flag;
	}

protected:
	BOOL m_flag;
};


//
// CPropUINT
//  = CandidateUI property data - UINT =
//

class CPropUINT
{
public:
	CPropUINT( void );
	virtual ~CPropUINT( void );

	HRESULT Set( UINT val );
	HRESULT Get( UINT *pval );
	__inline UINT Get( void )
	{
		return m_val;
	}

protected:
	UINT m_val;
};


//
// CPropLong
//  = CandidateUI property data - Long =
//

class CPropLong
{
public:
	CPropLong( void );
	virtual ~CPropLong( void );

	HRESULT Set( LONG val );
	HRESULT Get( LONG *pval );
	__inline LONG Get( void )
	{
		return m_val;
	}

protected:
	LONG m_val;
};


//
// CPropSize
//  = CandidateUI property data - size =
//

class CPropSize
{
public:
	CPropSize( void );
	virtual ~CPropSize( void );

	HRESULT Set( SIZE *psize );
	HRESULT Get( SIZE *psize );
	__inline LONG GetWidth( void )
	{
		return m_size.cx;
	}
	__inline LONG GetHeight( void )
	{
		return m_size.cy;
	}
	__inline Set( LONG cx, LONG cy )
	{
		m_size.cx = cx;
		m_size.cy = cy;
	}

protected:
	SIZE m_size;
};


//
// CPropPoint
//  = CandidateUI property data - point =
//

class CPropPoint
{
public:
	CPropPoint( void );
	virtual ~CPropPoint( void );

	HRESULT Set( POINT *ppt );
	HRESULT Get( POINT *ppt );
	__inline LONG GetX( void )
	{
		return m_pt.x;
	}
	__inline LONG GetY( void )
	{
		return m_pt.y;
	}
	__inline Set( LONG px, LONG py )
	{
		m_pt.x = px;
		m_pt.y = py;
	}

protected:
	POINT m_pt;
};


//
// CPropText
//  = CandidateUI property data - text =
//

class CPropText
{
public:
	CPropText( void );
	virtual ~CPropText( void );

	HRESULT Set( BSTR bstr );
	HRESULT Get( BSTR *pbstr );
	__inline LPCWSTR Get( void )
	{
		return m_pwch;
	}

protected:
	LPWSTR m_pwch;
};


//
// CPropFont
//  = CandidateUI property data - font =
//

class CPropFont
{
public:
	CPropFont( void );
	virtual ~CPropFont( void );

	HRESULT Set( LOGFONTW *plf );
	HRESULT Get( LOGFONTW *plf );
	HRESULT SetOrientation( PROPFONTORIENTATION ort );
	__inline HFONT Get( void )
	{
		return m_hFont;
	}

protected:
	LOGFONTW            m_lf;
	PROPFONTORIENTATION m_ort;
	HFONT               m_hFont;

	HFONT CreateFontProc( const LOGFONTW *plf, PROPFONTORIENTATION ort );
};

#endif // PROPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "candui.h"

BEGIN_COCLASSFACTORY_TABLE
	DECLARE_COCLASSFACTORY_ENTRY( CLSID_TFCandidateUI, CCandidateUI, TEXT("Microsoft Shared Correction UI") )
END_COCLASSFACTORY_TABLE

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

STDAPI DllRegisterServer(void)
{
    return COMBase_DllRegisterServer();
}

STDAPI DllUnregisterServer(void)
{
    return COMBase_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\res.h ===
#ifndef RES_H
#define RES_H 

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

#define IDI_ICONMENU		1
#define IDI_ICONPOPUPON		2
#define IDI_ICONPOPUPOFF	3
#define IDI_ICONCLOSE		4
#define IDI_ICONTIPON		5
#define IDI_ICONTIPOFF		6

#endif /* RES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\sharemem.cpp ===
//
//
//

#include "private.h"
#include "sharemem.h"
#include "globals.h"
#include "candutil.h"


//+---------------------------------------------------------------------------
//
// GetDesktopUniqueName
//
//----------------------------------------------------------------------------

void GetDesktopUniqueName(const TCHAR *pchPrefix, ULONG cchPrefix, TCHAR *pch, ULONG cchPch)
{
    StringCchCopy(pch, cchPch, pchPrefix);

    if (FIsWindowsNT() && cchPrefix < cchPch)
    {
        TCHAR ach[MAX_PATH];
        DWORD dwLength;
        HDESK hdesk;
        hdesk = GetThreadDesktop(GetCurrentThreadId());

        if (GetUserObjectInformation(hdesk, UOI_NAME, ach, sizeof(ach) /* byte count */, &dwLength))
        {
            StringCchCopy(pch + cchPrefix, cchPch - cchPrefix, ach);
        }
    }
}

//
// CCandUIMMFile
//

/*   C  C A N D  U I  M M  F I L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIMMFile::CCandUIMMFile( void )
{
    m_hFile = NULL;
    m_pvData = NULL;
}


/*   ~  C  C A N D  U I  M M  F I L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIMMFile::~CCandUIMMFile( void )
{
    Close();
}


/*   O P E N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMMFile::Open( LPSTR szName, DWORD dwFlag )
{
    TCHAR achDesktopUniqueName[MAX_PATH];
    DWORD dwDesiredAccess;

    if (m_hFile != NULL) {
        return FALSE;
    }

    // access flag

    if ((dwFlag & CANDUIMM_READWRITE) != 0) {
        dwDesiredAccess = FILE_MAP_ALL_ACCESS;
    }
    else {
        dwDesiredAccess = FILE_MAP_READ;
    }

    // open file 

    GetDesktopUniqueName(szName, lstrlen(szName), achDesktopUniqueName, ARRAYSIZE(achDesktopUniqueName));

    m_hFile = OpenFileMapping( dwDesiredAccess, FALSE, achDesktopUniqueName );
    if (m_hFile == NULL) {
        return FALSE;
    }

    // memory mapping

    m_pvData = MapViewOfFile( m_hFile, dwDesiredAccess, 0, 0, 0 );
    if (m_pvData == NULL) {
        Close();
        return FALSE;
    }

    return TRUE;
}


/*   C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMMFile::Create( LPSTR szName, DWORD dwFlag, SECURITY_ATTRIBUTES *psa, DWORD dwSize )
{
    DWORD flProtect;
    DWORD dwDesiredAccess;
    TCHAR achDesktopUniqueName[MAX_PATH];

    if (m_hFile != NULL) {
        return FALSE;
    }

    // access flag

    if ((dwFlag & CANDUIMM_READWRITE) != 0) {
        flProtect       = PAGE_READWRITE;
        dwDesiredAccess = FILE_MAP_ALL_ACCESS;
    }
    else {
        flProtect       = PAGE_READONLY;
        dwDesiredAccess = FILE_MAP_READ;
    }

    // create file 

    GetDesktopUniqueName(szName, lstrlen(szName), achDesktopUniqueName, ARRAYSIZE(achDesktopUniqueName));

    m_hFile = CreateFileMapping( 
        INVALID_HANDLE_VALUE,
        psa,
        flProtect,
        0,
        dwSize,
        achDesktopUniqueName );

    if (m_hFile == NULL) {
        return FALSE;
    }

    // memory mapping

    m_pvData = MapViewOfFile( m_hFile, dwDesiredAccess, 0, 0, 0 );
    if (m_pvData == NULL) {
        Close();
        return FALSE;
    }

    // initialize

    memset( m_pvData, 0, dwSize );
    return TRUE;
}


/*   C L O S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMMFile::Close( void )
{
    if (m_pvData != NULL) {
        UnmapViewOfFile( m_pvData );
        m_pvData = NULL;
    }

    if (m_hFile != NULL) {
        CloseHandle( m_hFile );
        m_hFile = NULL;
    }

    return TRUE;
}


//
// CCandUIMutex
//

/*   C  C A N D  U I  M U T E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIMutex::CCandUIMutex( void )
{
    m_hMutex = NULL;
}


/*   ~  C  C A N D  U I  M U T E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIMutex::~CCandUIMutex( void )
{
    Close();
}


/*   C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMutex::Create( LPSTR szName, SECURITY_ATTRIBUTES *psa )
{
    TCHAR achDesktopUniqueName[MAX_PATH];

    if (m_hMutex != NULL) {
        return FALSE;
    }

    GetDesktopUniqueName(szName, lstrlen(szName), achDesktopUniqueName, ARRAYSIZE(achDesktopUniqueName));

    m_hMutex = CreateMutex( psa, FALSE, achDesktopUniqueName );
    return (m_hMutex != NULL);
}


/*   C L O S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMutex::Close( void )
{
    if (m_hMutex != NULL) {
        CloseHandle( m_hMutex );
        m_hMutex = NULL;
    }

    return TRUE;
}


/*   L O C K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMutex::Lock( void )
{
    DWORD dwResult;

    if (m_hMutex == NULL) {
        return FALSE;
    }

    dwResult = WaitForSingleObject( m_hMutex, INFINITE );
    switch (dwResult) {
        case WAIT_OBJECT_0:
        case WAIT_ABANDONED: {
            return TRUE;
        }

        default:
        case WAIT_TIMEOUT: {
            return FALSE;
        }
    }
}


/*   U N L O C K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIMutex::Unlock( void )
{
    if (m_hMutex == NULL) {
        return FALSE;
    }

    ReleaseMutex( m_hMutex );
    return TRUE;
}


//
// CCandUIShareMem
//

/*   C  C A N D  U I  S H A R E  M E M   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIShareMem

------------------------------------------------------------------------------*/
CCandUIShareMem::CCandUIShareMem( void )
{
}


/*   ~  C  C A N D  U I  S H A R E  M E M   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIShareMem

------------------------------------------------------------------------------*/
CCandUIShareMem::~CCandUIShareMem( void )
{
    m_Mutex.Close();
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIShareMem::Initialize( void )
{
    return m_Mutex.Create( SZNAME_SHAREDDATA_MUTEX, GetCandUISecurityAttributes() );
}


/*   O P E N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIShareMem::Open( void )
{
    return m_MMFile.Open( SZNAME_SHAREDDATA_MMFILE, CANDUIMM_READONLY );
}


/*   C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIShareMem::Create( void )
{
    BOOL fResult = FALSE;

    if (!m_Mutex.Lock()) {
        return FALSE;
    }

    fResult = m_MMFile.Create( SZNAME_SHAREDDATA_MMFILE, CANDUIMM_READWRITE, GetCandUISecurityAttributes(), sizeof(SHAREDDATA) );

    m_Mutex.Unlock();

    return fResult;
}


/*   C L O S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIShareMem::Close( void )
{
    return m_MMFile.Close();
}


/*   L O C K  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIShareMem::LockData( void )
{
    return m_MMFile.IsValid() && m_Mutex.Lock();
}


/*   U N L O C K  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandUIShareMem::UnlockData( void )
{
    return m_MMFile.IsValid() && m_Mutex.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\sptask.h ===
//
// sptask.h
// speech related class for mscandui
//
#ifndef SPTASK_H
#define SPTASK_H

#include "private.h"
#include "sapi.h"
#include "sphelper.h"
#include "globals.h"
#include "candui.h"
#include "tes.h"
#include "editcb.h"

// SAPI5.0 speech notification interface
//
class CSpTask : public ISpNotifyCallback
{
public:
    CSpTask(CCandidateUI *pcui);
    ~CSpTask(void);

    // this has to be the first in vtable
    STDMETHODIMP NotifyCallback( WPARAM wParam, LPARAM lParam );


    HRESULT InitializeSAPIObjects();
    HRESULT InitializeCallback();
    

    HRESULT _Activate(BOOL fActive);
    HRESULT _LoadGrammars(void);
    
    HRESULT _OnSpEventRecognition(CSpEvent &event);
    HRESULT _DoCommand(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _DoDictation(ISpRecoResult *pResult);

    WCHAR *_GetCmdFileName(LANGID langid);
    
    BOOL   IsSpeechInitialized(void) { return m_fSapiInitialized; }
    HRESULT InitializeSpeech();

    
    HRESULT _GetSapilayrEngineInstance(ISpRecognizer **pRecoEngine);

    void    _ReleaseGrammars(void);
    
private:
    // SAPI 50 object pointers
    CComPtr<ISpRecoContext>     m_cpRecoCtxt;
    CComPtr<ISpRecognizer>      m_cpRecoEngine;
    CComPtr<ISpVoice>           m_cpVoice;
    CComPtr<ISpRecoGrammar>     m_cpCmdGrammar;
    CComPtr<ISpRecoGrammar>     m_cpDictGrammar;
    
    // TRUE if sapi is initialized
    BOOL m_fSapiInitialized;
    
    // other data members
    DWORD m_dwStatus;
    BOOL m_fActive;
    
    // save the current user LANGID for the fallback case
    LANGID m_langid;
    
    WCHAR m_szCmdFile[MAX_PATH];
    
    CCandidateUI  *m_pcui;

    BOOL m_fInCallback;
};

#endif // SPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\sptask.cpp ===
//
// sptask.cpp
// 
// implements a notification callback ISpTask
//
// created: 12/1/99
//
//


#include "private.h"
#include "globals.h"
#include "sptask.h"
#include "candui.h"
#include "ids.h"
#include "computil.h"

//
// ctor
//
//
CSpTask::CSpTask(CCandidateUI *pcui)
{
    //  CSpTask is initialized with an TFX instance
    //  so store the pointer to the TFX   

    // init data members here
    m_pcui     = pcui;

    m_fSapiInitialized  = FALSE;
    
    m_fActive  = FALSE;
    m_fInCallback = FALSE; 
}

CSpTask::~CSpTask()
{
    _ReleaseGrammars();
}


//
// CSpTask::_InitializeSAPIObjects
//
// initialize SAPI objects for SR
// later we'll get other objects initialized here
// (TTS, audio etc)
//
HRESULT CSpTask::InitializeSAPIObjects(void)
{
#ifdef _WIN64
    return E_NOTIMPL;
#else

    if (m_fSapiInitialized == TRUE)
        return m_cpRecoCtxt ? S_OK : E_FAIL;

    // do not try again even in failure
    m_fSapiInitialized  = TRUE;

    // m_xxx are CComPtrs from ATL
    //

    HRESULT hr = _GetSapilayrEngineInstance(&m_cpRecoEngine);

    // create the recognition context
    if( S_OK == hr )
    {
        hr = m_cpRecoEngine->CreateRecoContext( &m_cpRecoCtxt );
    }

    if ( hr == S_OK )
    {
        SPRECOGNIZERSTATUS stat;

        if (S_OK == m_cpRecoEngine->GetStatus(&stat))
        {
            m_langid = stat.aLangID[0];
        } 
    }

    return hr;
#endif // _WIN64
}

//
// CSpTask::NotifyCallback
//
// INotifyControl object calls back here
// returns S_OK when it handles notifications
//
//
HRESULT CSpTask::NotifyCallback( WPARAM wParam, LPARAM lParam )
{
    USES_CONVERSION;


    // we can't delete reco context while we're in this callback
    //
    m_fInCallback = TRUE;

    // also we can't terminate candidate UI object while in the callback
    m_pcui->AddRef();

    {
    CSpEvent event;


    while ( m_cpRecoCtxt && event.GetFrom(m_cpRecoCtxt) == S_OK )
    {
        switch (event.eEventId)
        {
            case SPEI_RECOGNITION:
                _OnSpEventRecognition(event);
                break;

            default:
                break;
        }
    }
    }
    m_fInCallback = FALSE;
    m_pcui->Release();
    
    return S_OK;
}

HRESULT CSpTask::_OnSpEventRecognition(CSpEvent &event)
{
    HRESULT hr = S_OK;
    ISpRecoResult *pResult = event.RecoResult();

    if (pResult)
    {
        static const WCHAR szUnrecognized[] = L"<Unrecognized>";
        SPPHRASE *pPhrase;
        hr = pResult->GetPhrase(&pPhrase);
        if (S_OK == hr)
        {

            if (pPhrase->ullGrammarID == GRAM_ID_CANDCC)
            {
                if (SUCCEEDED(hr) && pPhrase)
                {
                    // retrieve LANGID from phrase
                    LANGID langid = pPhrase->LangID;
        
                    hr = _DoCommand(pPhrase, langid);
                }
            }
            else if(pPhrase->ullGrammarID == GRAM_ID_DICT)
            {
                if (m_pcui->_ptim != NULL) {    
                    // Windows bug#508709
                    // Ignore dictation event during SPTip is in commanding mode
                    DWORD dwSpeechGlobalState;
                    GetCompartmentDWORD(m_pcui->_ptim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwSpeechGlobalState, TRUE);

                    if (dwSpeechGlobalState & TF_DICTATION_ON) {
                        hr = _DoDictation(pResult);
                    }
                }
            }
            ::CoTaskMemFree( pPhrase );
        }
    }
    
    return hr;
}

const WCHAR c_szRuleName[] = L"ID_Candidate";
//
// CSpTask::_DoCommand
//
// review: the rulename may need to be localizable?
//
HRESULT CSpTask::_DoCommand(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;
    
    if ( wcscmp(pPhrase->Rule.pszName, c_szRuleName) == 0)
    {
        if (m_pcui)
        {
            
            hr = m_pcui->NotifySpeechCmd(pPhrase, 
                                         pPhrase->pProperties[0].pszValue, 
                                         pPhrase->pProperties[0].ulId);
        }
    }
    return hr;
}
//
// CSpTask::_DoDictation
//
// support spelling 
//
HRESULT CSpTask::_DoDictation(ISpRecoResult *pResult)
{
    HRESULT hr = E_FAIL;
    BYTE    bAttr;  // no need?
    Assert(pResult);
    
    // this cotaskmemfree's text we get
    CSpDynamicString dstr; 
    
    hr = pResult->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstr, &bAttr);
    if (S_OK  == hr)
    {
        WCHAR sz[2]={0};
        StringCchCopyW(sz, ARRAYSIZE(sz), dstr);
        Assert(m_pcui);
        hr = m_pcui->FHandleSpellingChar(sz[0]);
    }
    return hr;
}
//
//    CSpTask::InitializeCallback
//
//
HRESULT CSpTask::InitializeCallback()
{
#ifdef _WIN64
    return E_NOTIMPL;
#else
    // set recognition notification
    CComPtr<ISpNotifyTranslator> cpNotify;
    HRESULT hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

    // set this class instance to notify control object
    if (SUCCEEDED(hr))
    {
        hr = cpNotify->InitSpNotifyCallback( (ISpNotifyCallback *)this, 0, 0 );
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoCtxt->SetNotifySink(cpNotify);
    }

    // set the events we're interested in
    if( SUCCEEDED( hr ) )
    {
        const ULONGLONG ulInterest = SPFEI(SPEI_RECOGNITION);

        hr = m_cpRecoCtxt->SetInterest(ulInterest, ulInterest);
    }
    else
    {
        m_cpRecoCtxt.Release();
    }

    if( SUCCEEDED( hr ) )
    {
        hr = _LoadGrammars();
    }

    return hr;
#endif // _WIN64
}

//
// _LoadGrammars
//
// synopsis - load CFG for dictation and commands available during dictation
//
HRESULT CSpTask::_LoadGrammars()
{
   // do not initialize grammars more than once
   //
   if (m_cpDictGrammar || m_cpCmdGrammar)
       return S_OK;
   
   HRESULT hr = E_FAIL;

   if (m_cpRecoCtxt)
   {
       
       //
       // create grammar object
       //

       if ( m_langid != 0x0804 )   // Chinese Engine doesn't support spelling grammar.
       {
            hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_DICT, &m_cpDictGrammar);
            if (S_OK == hr)
            {
                // specify spelling mode
                hr = m_cpDictGrammar->LoadDictation(L"Spelling", SPLO_STATIC);
            }

            if (SUCCEEDED(hr))
            {
                hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_CANDCC, &m_cpCmdGrammar);
            }
       }
       else
           hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_CANDCC, &m_cpCmdGrammar);


       // load the command grammar
       //
       if (SUCCEEDED(hr) )
       {
           // Load it from the resource first to speed up the initialization.

           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
                hr = m_cpCmdGrammar->LoadCmdFromResource(
                                        g_hInst, 
                                 (const WCHAR*)MAKEINTRESOURCE(ID_DICTATION_COMMAND_CFG), 
                                        L"SRGRAMMAR", 
                                        m_langid, 
                                        SPLO_DYNAMIC);
           }

           // in case LoadCmdFromResource returns wrong.
           if (!SUCCEEDED(hr))
           {
               if(!_GetCmdFileName(m_langid))
               {
                   hr = E_FAIL;
               }

               if (m_szCmdFile[0])
               {
                   hr = m_cpCmdGrammar->LoadCmdFromFile(_GetCmdFileName(m_langid), SPLO_DYNAMIC);
               }

               if (!SUCCEEDED(hr))
               {
                  m_cpCmdGrammar.Release();
               }
           }

           hr = S_OK;
       }
                          
   }
   return hr;
}

void CSpTask::_ReleaseGrammars(void)
{
    if (!m_fInCallback)
    {
        m_cpDictGrammar.Release();
        m_cpCmdGrammar.Release();
        if (m_cpRecoCtxt)
        {
            m_cpRecoCtxt->SetNotifySink(NULL);
            m_cpRecoCtxt.Release();
        }
    }
}

WCHAR * CSpTask::_GetCmdFileName(LANGID langid)
{

    if (!m_szCmdFile[0])
    {
        // now we only have a command file for English/Japanese
        // when cfgs are available, we'll get the name of cmd file
        // and the rule names from resources using findresourceex
        //
        if (PRIMARYLANGID(langid) == LANG_ENGLISH
        || PRIMARYLANGID(langid) == LANG_JAPANESE
        || PRIMARYLANGID(langid) == LANG_CHINESE)
        {
            char szFilePath[MAX_PATH];
            char *pszExt;
            char szCp[MAX_PATH];
            int  ilen;

            if (!GetModuleFileName(g_hInst, szFilePath, ARRAYSIZE(szFilePath)))
                return NULL;
            
            // find extension
            // is this dbcs safe?
            pszExt = strrchr(szFilePath, (int)'.');
            
            if (pszExt)
            {
                *pszExt = '\0';
            }

            ilen = lstrlen(szFilePath);
            
            if (!pszExt)
            {
                pszExt = szFilePath+ilen;
            }
            
            LoadStringA(g_hInst, IDS_CMD_EXT, pszExt, ARRAYSIZE(szFilePath)-ilen);
                    
            if (GetLocaleInfo(langid, LOCALE_IDEFAULTANSICODEPAGE, szCp, ARRAYSIZE(szCp))>0)
            {
                int iACP = atoi(szCp); 
            
                if (MultiByteToWideChar(iACP, NULL, szFilePath, -1, m_szCmdFile, ARRAYSIZE(m_szCmdFile)) == 0) {
                    m_szCmdFile[0] = 0;
                    return NULL;
                }
            }
        }
    }
    return m_szCmdFile;
}


HRESULT CSpTask::_Activate(BOOL fActive)
{
    HRESULT hr = E_FAIL;

    if (m_cpRecoCtxt)
    {
        // Need SAPI bug# for this workaround.
        //
        m_fActive = fActive;
        // 
        // Is the NULL rulename fine?
        //
        if (m_cpCmdGrammar)
            hr = m_cpCmdGrammar->SetRuleState(NULL, NULL,  m_fActive ? SPRS_ACTIVE : SPRS_INACTIVE);

        if (m_cpDictGrammar)
            hr = m_cpDictGrammar->SetDictationState(m_fActive? SPRS_ACTIVE : SPRS_INACTIVE);
    }

    return hr;
}


HRESULT CSpTask::InitializeSpeech()
{
    HRESULT hr = E_FAIL;

#ifdef _WIN64
    hr = E_NOTIMPL;
#else
    hr = InitializeSAPIObjects();

    // set callback
    if (hr == S_OK)
       hr = InitializeCallback();
         
    // activate grammars
    if (hr == S_OK)
       hr = _Activate(TRUE);
#endif // _WIN64
           
    return hr;
}

//
// _GetSapilayrEngineInstance
//
//
//
HRESULT CSpTask::_GetSapilayrEngineInstance(ISpRecognizer **ppRecoEngine)
{
#ifdef _WIN64
    return E_NOTIMPL;
#else
    HRESULT hr = E_FAIL;
    CComPtr<ITfFunctionProvider> cpFuncPrv;
    CComPtr<ITfFnGetSAPIObject>  cpGetSAPI;


    // we shouldn't release this until we terminate ourselves
    // so we don't use comptr here

    if (m_pcui->_ptim != NULL) {    
        hr = m_pcui->_ptim->GetFunctionProvider(CLSID_SapiLayr, &cpFuncPrv);

        if (S_OK == hr)
        {
            hr = cpFuncPrv->GetFunction(GUID_NULL, IID_ITfFnGetSAPIObject, (IUnknown **)&cpGetSAPI);
        }

        if (S_OK == hr)
        {
            hr = cpGetSAPI->Get(GETIF_RECOGNIZERNOINIT, (IUnknown **)ppRecoEngine);
        }
    }
 
    return hr;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\wcand.cpp ===
//
// wcand.cpp
//

#include "private.h"
#include "wcand.h"
#include "globals.h"
#include "res.h"
#include "candutil.h"

#include "candui.h"
#include "wpopup.h"
#include "candmenu.h"
#include "cuishadw.h"

#define NUM_CANDSTR_MAX 9


// UI object IDs

#define IDUIF_CANDNUMBUTTON		0x00000001
#define IDUIF_CANDIDATELIST		0x00000010
#define IDUIF_CANDIDATEMENU		0x00000011
#define IDUIF_RAWDATA			0x00000012
#define IDUIF_EXTCANDIDATELIST	0x00000013
#define IDUIF_OPTIONSLIST		0x00000014
#define IDUIF_BORDERLEFT		0x00000020
#define IDUIF_BORDERBOTTOM		0x00000021
#define IDUIF_BORDERRAWDATA		0x00000022
#define IDUIF_BORDER			0x00000023
#define IDUIF_CAPTION			0x00000024
#define IDUIF_BORDEREXTRACAND	0x00000025
#define IDUIF_CANDTIPBTN		0x00000026
#define IDUIF_BORDEROPTIONSCAND	0x00000027
#define IDUIF_EXTENDED			0x10000000

#define IDTIMER_POPUPCOMMENT_SELECT	0x6749
#define IDTIMER_POPUPCOMMENT_HOVER	0x674a
#define IDTIMER_MENU_HOVER		0x674b
// The menu hover timer is used by the options list object to emulate menu items
// much more closely. Otherwise there may be a 1 second pause before they lose
// highlighting when the standard cuilib mouseout timer kicks in to detect the
// mouse leave event. It is set to 50ms currently and this causes the menus to
// behave identically to normal menu items. It *only* affects the options menu
// items - everything else gets the existing 1 second timer.

#define CX_COMMENTWINDOW		200



/*   C  C A N D  U I  O B J E C T  P A R E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectParent::CCandUIObjectParent( void )
{
	m_pUIObjectMgr = NULL;
}


/*   ~  C  C A N D  U I  O B J E C T  P A R E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectParent::~CCandUIObjectParent( void )
{
	Uninitialize();
}


/*   I N T I I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectParent::Initialize( CCandUIObjectMgr *pUIObjectMgr )
{
	Assert( pUIObjectMgr );

	m_pUIObjectMgr = pUIObjectMgr;
	m_pUIObjectMgr->SetUIObjectParent( this );

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectParent::Uninitialize( void )
{
	if (m_pUIObjectMgr != NULL) {
		m_pUIObjectMgr->SetUIObjectParent( NULL );
		m_pUIObjectMgr = NULL;
	}

	return S_OK;
}


/*   N O T I F Y  U I  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIObjectParent::NotifyUIObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	if (m_pUIObjectMgr != NULL) {
		m_pUIObjectMgr->NotifyUIObjectEvent( obj, event );
	}
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  W I N D O W  B A S E                                         */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  W I N D O W  B A S E   */
/*------------------------------------------------------------------------------

	Constructor of CCandWindowBase

------------------------------------------------------------------------------*/
CCandWindowBase::CCandWindowBase( CCandidateUI *pCandUI, DWORD dwStyle ) : CUIFWindow( g_hInst, dwStyle | UIWINDOW_HASTOOLTIP | UIWINDOW_HASSHADOW )
{
	int cxyIconMenuSize;

	m_cRef           = 1;
	m_pCandUI        = pCandUI;
	m_pCandAcc       = NULL;
	m_pCandMenuBtn   = NULL;
	m_pCandMenu      = NULL;
	m_fCandMenuOpen  = FALSE;
	m_nExtUIObj      = 0;
	m_pCandRawData   = NULL;
	m_fHasRawData    = FALSE;
	m_fTargetClipped = FALSE;
	m_fOnSelectionChanged = FALSE;
	::SetRect( &m_rcTarget, 0, 0, 0, 0 );

	// initialize event sinks

	CCandListEventSink::InitEventSink( m_pCandUI->GetCandListMgr() );
	CCandUIPropertyEventSink::InitEventSink( m_pCandUI->GetPropertyMgr() );
	CCandUIExtensionEventSink::InitEventSink( m_pCandUI->GetExtensionMgr() );

	// initialize resources

	cxyIconMenuSize = GetMenuIconSize();
	m_hIconMenu     = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONMENU),     IMAGE_ICON, cxyIconMenuSize, cxyIconMenuSize, 0 );
	m_hIconPopupOn  = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONPOPUPON),  IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS );
	m_hIconPopupOff = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONPOPUPOFF), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS );
	m_hIconCandTipOn  = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONTIPON),    IMAGE_ICON, cxyIconMenuSize, cxyIconMenuSize, 0 );
	m_hIconCandTipOff = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONTIPOFF),   IMAGE_ICON, cxyIconMenuSize, cxyIconMenuSize, 0 );

	// initialize accessibility object

	m_pCandAcc = new CCandAccessible( this );

	// initialize as object parent

	CCandUIObjectParent::Initialize( m_pCandUI->GetUIObjectMgr() );
	m_pCandUI->AddRef();
}


/*   ~  C  C A N D  W I N D O W  B A S E   */
/*------------------------------------------------------------------------------

	Destructor of CCandWindowBase

------------------------------------------------------------------------------*/
CCandWindowBase::~CCandWindowBase()
{
	// uninitialize as object parent

	CCandUIObjectParent::Uninitialize();

	// dispose resources

	DestroyIcon( m_hIconMenu );
	DestroyIcon( m_hIconPopupOn );
	DestroyIcon( m_hIconPopupOff );
	DestroyIcon( m_hIconCandTipOn );
	DestroyIcon( m_hIconCandTipOff );

	// 

	CCandUIExtensionEventSink::DoneEventSink();
	CCandUIPropertyEventSink::DoneEventSink();
	CCandListEventSink::DoneEventSink();

	if (m_pCandAcc != NULL) {
		m_pCandAcc->Release();
		m_pCandAcc = NULL;
	}

	m_pCandUI->Release();
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

	Increment reference count
	(local method)

------------------------------------------------------------------------------*/
ULONG CCandWindowBase::AddRef( void )
{
	m_cRef++;
	return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

	Decrement reference count and release object
	(local method)

------------------------------------------------------------------------------*/
ULONG CCandWindowBase::Release( void )
{
	m_cRef--;
	if (0 < m_cRef) {
		return m_cRef;
	}

	delete this;
	return 0;    
}


/*   O N  S E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on SetCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandWindowBase::OnSetCandidateList( void )
{
	Assert( FInitialized() );

	SetCandidateListProc();
	LayoutWindow();
	SetSelectionProc();
}


/*   O N  C L E A R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on ClearCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandWindowBase::OnClearCandidateList( void )
{
	Assert( FInitialized() );

	ClearCandidateListProc();
}


/*   O N  C A N D  I T E M  U P D A T E   */
/*------------------------------------------------------------------------------

	Callback function of candiate item has been updated
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandWindowBase::OnCandItemUpdate( void )
{
	Assert( FInitialized() );

	SetCandidateListProc();
	SetSelectionProc();
}


/*   O N  S E L E C T I O N  C H A N G E D   */
/*------------------------------------------------------------------------------

	Callback function of candiate selection has been changed
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CCandWindowBase::OnSelectionChanged( void )
{
	Assert( FInitialized() );
	Assert( !m_fOnSelectionChanged );

	m_fOnSelectionChanged = TRUE;
	SetSelectionProc();
	m_fOnSelectionChanged = FALSE;
}


/*   O N  P R O P E R T Y  U P D A T E D   */
/*------------------------------------------------------------------------------

	Callback function on update CandiateUI property
	(CCandUIPropertyEventSink method)

------------------------------------------------------------------------------*/
void CCandWindowBase::OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )
{
	Assert( FInitialized() );

	switch (prop) {
		case CANDUIPROP_CANDWINDOW: {
			if (event == CANDUIPROPEV_UPDATEVISIBLESTATE) {
				Show( GetPropertyMgr()->GetCandWindowProp()->IsVisible() );
			}
			else if (event == CANDUIPROPEV_UPDATEPOSITION) {
				POINT pt;

				GetPropertyMgr()->GetCandWindowProp()->GetPosition( &pt );
				SetWindowPos( pt );
			}
			else {
				LayoutWindow();
			}
			break;
		}

		case CANDUIPROP_TOOLTIP: {
			CUIFToolTip *pWndToolTip = GetToolTipWnd();
			CUIFBalloonWindow *pWndCandTip = GetCandTipWindowObj();

			if (pWndToolTip != NULL) {
				pWndToolTip->SetFont( GetPropertyMgr()->GetToolTipProp()->GetFont() );
				pWndToolTip->Enable( GetPropertyMgr()->GetToolTipProp()->IsEnabled() );
			}

			if (pWndCandTip != NULL) {
				pWndCandTip->SetFont( GetPropertyMgr()->GetToolTipProp()->GetFont() );
			}
			break;
		}

		default: {
			LayoutWindow();
			break;
		}
	}
}


/*   O N  E X T E N S I O N  A D D   */
/*------------------------------------------------------------------------------

	Callback function on create extension
	(CCandUIExtensionEventSink method)

------------------------------------------------------------------------------*/
void CCandWindowBase::OnExtensionAdd( LONG iExtension )
{
	// NOTE: need to rebuild all UI objects to match index correctly

	DeleteExtensionObjects();
	CreateExtensionObjects();

	LayoutWindow();
}


/*   O N  E X T E N S I O N  D E L E T E D   */
/*------------------------------------------------------------------------------

	Callback function on delete extension
	(CCandUIExtensionEventSink method)

------------------------------------------------------------------------------*/
void CCandWindowBase::OnExtensionDeleted( LONG iExtension )
{
	// NOTE: need to rebuild all UI objects to match index correctly

	DeleteExtensionObjects();
	CreateExtensionObjects();

	LayoutWindow();
}


/*   O N  E X T E N S I O N  U P D A T E D   */
/*------------------------------------------------------------------------------

	Callback function on update extension
	(CCandUIExtensionEventSink method)

------------------------------------------------------------------------------*/
void CCandWindowBase::OnExtensionUpdated( LONG iExtension )
{
	SetExtensionObjectProps();

	LayoutWindow();
}


/*   G E T  C L A S S  N A M E   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
LPCTSTR CCandWindowBase::GetClassName( void )
{
	return _T( WNDCLASS_CANDWND );
}


/*   G E T  W N D  T I T L E   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
LPCTSTR CCandWindowBase::GetWndTitle( void )
{
	return _T( WNDTITLE_CANDWND );
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

	Initialize UI objects

------------------------------------------------------------------------------*/
CUIFObject *CCandWindowBase::Initialize( void )
{
        //
        // Here register candidate window class.
        //
        WNDCLASSEX WndClass;
        LPCTSTR pszClassName = GetClassName();

        memset(&WndClass, 0, sizeof(WndClass));

        WndClass.cbSize = sizeof(WndClass);
        WndClass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_IME;
        WndClass.lpfnWndProc   = WindowProcedure;
        WndClass.cbClsExtra    = 0;
        WndClass.cbWndExtra    = 8;
        WndClass.hInstance     = g_hInst;
        WndClass.hIcon         = NULL;
        WndClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        WndClass.hbrBackground = NULL;
        WndClass.lpszMenuName  = NULL;
        WndClass.lpszClassName = pszClassName;
        WndClass.hIconSm       = NULL;

        RegisterClassEx(&WndClass);

	CUIFObject  *pUIObjRet;
	CUIFToolTip *pWndToolTip;

	// call CUIFWindow::Initialize() to create tooltip window

	pUIObjRet = CUIFWindow::Initialize();

	// set tooltip font

	pWndToolTip = GetToolTipWnd();
	if (GetToolTipWnd() != NULL) {
		pWndToolTip->SetFont( GetPropertyMgr()->GetToolTipProp()->GetFont() );
		pWndToolTip->Enable( GetPropertyMgr()->GetToolTipProp()->IsEnabled() );
	}

	return pUIObjRet;
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::Show( BOOL fShow )
{
	if (!fShow && (m_pCandMenu != NULL)) {
		m_pCandMenu->ClosePopup();
	}

	CUIFWindow::Show( fShow );
}


/*   O N  C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::OnCreate( HWND hWnd )
{
	SetProp( hWnd, (LPCTSTR)GlobalAddAtom(_T("MicrosoftTabletPenServiceProperty")), (HANDLE)1 );

	if (m_pCandAcc != NULL) {
		m_pCandAcc->SetWindow( hWnd );
	}

	NotifyUIObjectEvent( CANDUIOBJ_CANDWINDOW, CANDUIOBJEV_CREATED );
}


/*   O N  D E S T R O Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::OnDestroy( HWND hWnd )
{
	NotifyUIObjectEvent( CANDUIOBJ_CANDWINDOW, CANDUIOBJEV_DESTROYED );

	//

	NotifyWinEvent( EVENT_OBJECT_DESTROY );
	if (m_pCandAcc != NULL) {
		m_pCandAcc->ClearAccItem();
		m_pCandAcc->SetWindow( NULL );
	}
}


/*   O N  N  C  D E S T R O Y   */
/*------------------------------------------------------------------------------

	on n c destroy

------------------------------------------------------------------------------*/
void CCandWindowBase::OnNCDestroy( HWND hWnd )
{
	RemoveProp( hWnd, (LPCTSTR)GlobalAddAtom(_T("MicrosoftTabletPenServiceProperty")) );
}


/*   O N  S Y S  C O L O R  C H A N G E   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
void CCandWindowBase::OnSysColorChange()
{
	int cxyIconMenuSize;

	// reload menu button icon

	DestroyIcon( m_hIconMenu );
	DestroyIcon( m_hIconCandTipOn );
	DestroyIcon( m_hIconCandTipOff );

	cxyIconMenuSize = GetMenuIconSize();
	m_hIconMenu     = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONMENU), IMAGE_ICON, cxyIconMenuSize, cxyIconMenuSize, 0 );
	m_hIconCandTipOn  = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONTIPON),    IMAGE_ICON, cxyIconMenuSize, cxyIconMenuSize, 0 );
	m_hIconCandTipOff = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONTIPOFF),   IMAGE_ICON, cxyIconMenuSize, cxyIconMenuSize, 0 );


	if (m_pCandMenuBtn) {
		m_pCandMenuBtn->SetIcon( m_hIconMenu );
	}

	// re-layout objects

	LayoutWindow();
}


/*   O N  S H O W  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CCandWindowBase::OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	// MSAA support

	if (wParam) {
		NotifyWinEvent( EVENT_OBJECT_SHOW );

		// REVIEW: KOJIW: Unless we send notify EVENT_OBJECT_FOCUS, we never 
		// receive WM_GETOBJECT message.  Why???

		NotifyWinEvent( EVENT_OBJECT_FOCUS );
	}
	else {
		NotifyWinEvent( EVENT_OBJECT_HIDE );
	}

	return CUIFWindow::OnShowWindow( hWnd, uMsg, wParam, lParam );
}


/*   O N  W I N D O W  P O S  C H A N G E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CCandWindowBase::OnWindowPosChanged( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult = CUIFWindow::OnWindowPosChanged( hWnd, uMsg, wParam, lParam );

	NotifyUIObjectEvent( CANDUIOBJ_CANDWINDOW, CANDUIOBJEV_UPDATED );

	return lResult;
}


/*   O N  G E T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CCandWindowBase::OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult = 0;

	switch (lParam) {
		//-----------------------------------------------------
		//	We process the OBJID_CLIENT object identifier;
		//	  this is the client area of our application
		//	  window.
		//-----------------------------------------------------

		case OBJID_CLIENT: {
			HRESULT hr;

			if (m_pCandAcc == NULL) {
				lResult = (LRESULT)E_OUTOFMEMORY;
				break;
			}

			if (!m_pCandAcc->FInitialized()) {
				//-----------------------------------------------------
				//	Initialize our Accessible object.  If the
				//	  initialization fails, delete the Accessible
				//	  object and return the failure code.
				//-----------------------------------------------------

				hr = m_pCandAcc->Initialize();
				if (FAILED( hr )) {
					m_pCandAcc->Release();
					m_pCandAcc = NULL;

					lResult = (LRESULT)hr;
					break;
				}

				//-----------------------------------------------------
				//	Send an EVENT_OBJECT_CREATE WinEvent for the
				//	  creation of the Accessible object for the
				//	  client area.
				//-----------------------------------------------------

				NotifyWinEvent( EVENT_OBJECT_CREATE );
			}

			//-----------------------------------------------------
			//	Call LresultFromObject() to create reference to
			//	  our Accessible object that MSAA will marshal to
			//	  the client.
			//-----------------------------------------------------

			lResult = m_pCandAcc->CreateRefToAccObj( wParam );
			break;
		}

		default: {
			lResult = (LRESULT)0L;
		}
	}

	return lResult;
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
LRESULT CCandWindowBase::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
	DWORD dwID = pUIObj->GetID();

	// candidate num buttons

	if (IDUIF_CANDNUMBUTTON <= dwID && dwID < (IDUIF_CANDNUMBUTTON + NUM_CANDSTR_MAX)) {
		int iListItem = GetUIListObj()->GetTopItem() + (dwID - 1);

		if (SelectItemProc( iListItem )) {
			CompleteCandidate();
		}
	}

	// candidate menu button

	else if (dwID == IDUIF_CANDIDATEMENU) {
		if (m_pCandMenuBtn->GetToggleState()) {
			OpenCandidateMenu();
		}
	}

	// candidate list

	else if (dwID == IDUIF_CANDIDATELIST) {
		switch (dwCommand) {
			case UILIST_SELECTED: {
				CompleteCandidate();
				break;
			}

			case UILIST_SELCHANGED: {
				SelectCandidate();
				break;
			}
		}
	}

	// options candidate list

	else if (dwID == IDUIF_OPTIONSLIST) {
		switch (dwCommand) {
			case UILIST_SELECTED: {
				CompleteOptionCandidate();
				break;
			}

			case UILIST_SELCHANGED: {
				SelectCandidate();
				break;
			}
		}
	}

	// candidate rawdata

	else if (dwID == IDUIF_RAWDATA) {
		switch (dwCommand) {
			case UICANDRAWDATA_CLICKED: {
				if (GetCandListMgr()->GetCandList()->FRawDataSelectable()) {
					m_pCandUI->NotifyCompleteRawData();
				}
				break;
			}
		}
	}

	// extended UI objects

	else if (IDUIF_EXTENDED <= dwID && dwID < (DWORD)(IDUIF_EXTENDED + GetExtensionMgr()->GetExtensionNum())) {
		LONG iExtension = dwID - IDUIF_EXTENDED;

		GetExtensionMgr()->UpdateExtProp( iExtension, pUIObj );
		m_pCandUI->NotifyExtensionEvent( iExtension, dwCommand, lParam );
	}

	return 0;
}


/*   O N  U S E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::OnUser(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	if (uMsg == WM_USER) {
		ProcessCommand( (CANDUICOMMAND)wParam, (int)lParam );
	}
}


/*   I N I T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Initialize candidate list data in candidate window

------------------------------------------------------------------------------*/
void CCandWindowBase::InitCandidateList( void )
{
	// set candidate list data

	SetCandidateListProc();

	// prepare to layout window 
	// NOTE: Call it only once when initializing.

	PrepareLayout();

	// layout ui objects

	LayoutWindow();

	// set the selection

	SetSelectionProc();
}


/*   P R O C E S S  C O M M A N D   */
/*------------------------------------------------------------------------------

	Process candidate commands

	Return value:
		S_OK    : command processed successfully
		S_FALSE : command has not processed but not error
		E_FAIL  : command is failed

------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::ProcessCommand( CANDUICOMMAND cmd, INT iParam )
{
	HRESULT hr = E_FAIL;

	AddRef();

	switch (MapCommand( cmd )) {
		case CANDUICMD_NONE: {
			hr = E_FAIL;
			break;
		}

		case CANDUICMD_NOP: {
			// no operation
			hr = S_OK;
			break;
		}

		case CANDUICMD_COMPLETE: {
			CompleteCandidate();
			hr = S_OK;
			break;
		}

		case CANDUICMD_CANCEL: {
			CancelCandidate();
			hr = S_OK;
			break;
		}

		case CANDUICMD_MOVESELNEXT: {
			SelectItemNext();
			hr = S_OK;
			break;
		}

		case CANDUICMD_MOVESELPREV: {
			SelectItemPrev();
			hr = S_OK;
			break;
		}

		case CANDUICMD_MOVESELPREVPG: {
			SelectPagePrev();
			hr = S_OK;
			break;
		}

		case CANDUICMD_MOVESELNEXTPG: {
			SelectPageNext();
			hr = S_OK;
			break;
		}

		case CANDUICMD_MOVESELFIRST: {
			SelectItemTop();
			hr = S_OK;
			break;
		}

		case CANDUICMD_MOVESELLAST: {
			SelectItemEnd();
			hr = S_OK;
			break;
		}

		case CANDUICMD_SELECTITEM: {
			if (SelectItemProc( iParam )) {
				CompleteCandidate();
				hr = S_OK;
			}
			else {
				hr = S_FALSE;
			}
			break;
		}

		case CANDUICMD_SELECTLINE: {
			if (SelectItemProc( GetUIListObj()->GetTopItem() + iParam - 1 )) {
				CompleteCandidate();
				hr = S_OK;
			}
			else {
				hr = S_FALSE;
			}
			break;
		}

		case CANDUICMD_OPENCANDMENU: {
			if (!FCandMenuOpen()) {
				OpenCandidateMenu();
				hr = S_OK;
			}
			else {
				hr = S_FALSE;
			}
			break;
		}

		case CANDUICMD_SELECTRAWDATA: {
			Assert( GetCandListMgr()->GetCandList() != NULL );

			// not eat key when rawdata is not selectable

			if (GetCandListMgr()->GetCandList()->FRawDataSelectable()) {
				hr = m_pCandUI->NotifyCompleteRawData();
			}
			else {
				hr = E_FAIL;
			}
			break;
		}

		case CANDUICMD_SELECTEXTRACAND: {
			Assert( GetCandListMgr()->GetCandList() != NULL );

			// not eat key when rawdata is not selectable

			if (GetCandListMgr()->GetCandList()->GetExtraCandItem() != NULL) {
				hr = m_pCandUI->NotifyCompleteExtraCand();
			}
			else {
				hr = S_FALSE;
			}
			break;
		}

		default: {
			// unknown command has come
			Assert( FALSE );
			break;
		}
	}

	Release();

	return hr;
}


/*   I S  I N D E X  V A L I D   */
/*------------------------------------------------------------------------------

	is index valid

------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::IsIndexValid( int i, BOOL *pfValid )
{
	Assert( pfValid != NULL );

	*pfValid = FALSE;
	if (GetUIListObj() == NULL) {
		return E_FAIL;
	}

	int iListItem = GetUIListObj()->GetTopItem() + i - 1;

	*pfValid = GetUIListObj()->IsItemSelectable( iListItem );
	return S_OK;
}


/*   D E S T R O Y  W N D   */
/*------------------------------------------------------------------------------

	Destroy candidate window

------------------------------------------------------------------------------*/
void CCandWindowBase::DestroyWnd( void )
{
	if (m_pCandMenu != NULL) {
		m_pCandMenu->ClosePopup();
	}

	DestroyWindow( GetWnd() );
}


/*   U P D A T E  A L L  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::UpdateAllWindow( void )
{
	UpdateWindow();
}


/*   O P E N  C A N D I D A T E  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::OpenCandidateMenu( void )
{
	CMenuButtonProperty *pMenuBtnProp;
	UINT  uiCmd;
	RECT  rc;
	POINT pt;
	BOOL  fNotify = FALSE;

	// sanity check

	if (m_pCandMenuBtn == NULL) {
		return;
	}

	// do not open menu when button is not enabled and visible

	if (!m_pCandMenuBtn->IsEnabled() || !m_pCandMenuBtn->IsVisible()) {
		return;
	}

	pMenuBtnProp = GetPropertyMgr()->GetMenuButtonProp();
	Assert( pMenuBtnProp != NULL );

	Assert( pMenuBtnProp->IsEnabled() );
	Assert( pMenuBtnProp->GetEventSink() );
	if ( pMenuBtnProp->GetEventSink() == NULL ) {
		return;
	}

	// calc position to display

	m_pCandMenuBtn->GetRect( &rc );
	ClientToScreen( m_hWnd, (POINT*)&rc.left );
	ClientToScreen( m_hWnd, (POINT*)&rc.right );
	pt.x = rc.left;
	pt.y = rc.bottom;

	// pushdown the menu button

	AddRef();

	Assert( m_pCandMenuBtn->GetToggleState() );
	m_pCandMenuBtn->SetToggleState( TRUE );
	m_fCandMenuOpen = TRUE;

	// create and popup menu

	UpdateWindow();

	m_pCandMenu = new CCandMenu( g_hInst );
	if (m_pCandMenu != NULL) {
		if (pMenuBtnProp->GetEventSink()->InitMenu( m_pCandMenu ) == S_OK) {
			uiCmd = m_pCandMenu->ShowPopup( this, pt, &rc );
			fNotify = TRUE;
		}
		m_pCandMenu->Release();
		m_pCandMenu = NULL;
	}

	// restore the menu button

	m_fCandMenuOpen = FALSE;
	m_pCandMenuBtn->SetToggleState( FALSE );

	//
	//
	//

	if (fNotify) {
		pMenuBtnProp->GetEventSink()->OnMenuCommand( uiCmd );
	}

	Release();
}


/*   F  C A N D  M E N U  O P E N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CCandWindowBase::FCandMenuOpen( void )
{
	return m_fCandMenuOpen;
}


/*   G E T  C A N D  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandMenu *CCandWindowBase::GetCandMenu( void )
{
	return m_pCandMenu;
}


/*   G E T  I C O N  M E N U   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HICON CCandWindowBase::GetIconMenu( void )
{
	return m_hIconMenu;
}


/*   G E T  I C O N  P O P U P  O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HICON CCandWindowBase::GetIconPopupOn( void )
{
	return m_hIconPopupOn;
}


/*   G E T  I C O N  P O P U P  O F F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HICON CCandWindowBase::GetIconPopupOff( void )
{
	return m_hIconPopupOff;
}
 

/*   F I N D  U I  O B J E C T   */
/*------------------------------------------------------------------------------

	Find UI object which has an ID
	When no UI object found, returns NULL.

------------------------------------------------------------------------------*/
CUIFObject *CCandWindowBase::FindUIObject( DWORD dwID )
{
	int nChild;
	int i;

	nChild = m_ChildList.GetCount();
	for (i = 0; i < nChild; i++) {
		CUIFObject *pUIObj = m_ChildList.Get( i );

		Assert( pUIObj );
		if (pUIObj->GetID() == dwID) {
			return pUIObj;
		}
	}

	return NULL;
}


/*   O P T I O N  I T E M  F R O M  L I S T  I T E M   */
/*------------------------------------------------------------------------------

	Get index of options candidate item in candidate list data 
		from index of item in UIList object

------------------------------------------------------------------------------*/
int CCandWindowBase::OptionItemFromListItem( int iListItem )
{
	CUIFCandListBase *pUIListObj = GetUIOptionsListObj();
	CCandListItem *pListItem;

	pListItem = pUIListObj->GetCandItem( iListItem );

	return (pListItem != NULL) ? pListItem->GetICandItem() : ICANDITEM_NULL;
}


/*   C A N D  I T E M  F R O M  L I S T  I T E M   */
/*------------------------------------------------------------------------------

	Get index of candidate item in candidate list data 
		from index of item in UIList object

------------------------------------------------------------------------------*/
int CCandWindowBase::CandItemFromListItem( int iListItem )
{
	CUIFCandListBase *pUIListObj = GetUIListObj();
	CCandListItem *pListItem;

	pListItem = pUIListObj->GetCandItem( iListItem );

	return (pListItem != NULL) ? pListItem->GetICandItem() : ICANDITEM_NULL;
}


/*   L I S T  I T E M  F R O M  C A N D  I T E M   */
/*------------------------------------------------------------------------------

	Get index of item in UIList object 
		from index of candidate item in candidate list data

------------------------------------------------------------------------------*/
int CCandWindowBase::ListItemFromCandItem( int iCandItem )
{
	CUIFCandListBase *pUIListObj = GetUIListObj();
	int iListItem;
	int nListItem;

	nListItem = pUIListObj->GetItemCount();
	for (iListItem = 0; iListItem < nListItem; iListItem++) {
		CCandListItem *pListItem = pUIListObj->GetCandItem( iListItem );

		if (pListItem != NULL && pListItem->GetICandItem() == iCandItem) {
			return iListItem;
		}
	}

	return -1; /* not found */
}


/*   O N  M E N U  O P E N E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::OnMenuOpened( void )
{
}


/*   O N  M E N U  C L O S E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::OnMenuClosed( void )
{
}


/*   S E T  C A N D I D A T E  L I S T  P R O C   */
/*------------------------------------------------------------------------------

	Set candidate list

------------------------------------------------------------------------------*/
void CCandWindowBase::SetCandidateListProc( void )
{
	CUIFCandListBase *pUIListObj = GetUIListObj();
	CUIFCandListBase *pUIOptionsListObj = GetUIOptionsListObj();
	CCandidateList *pCandList;
	CCandidateList *pOptionsList;
	int i;
	int nListItem;

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	pOptionsList = GetCandListMgr()->GetOptionsList();
	Assert( pOptionsList != NULL);
	// reset list item

	pUIListObj->DelAllCandItem();
	pUIListObj->SetCandList(pCandList);

	// reset options list item

	if (pOptionsList)
	{
		pUIOptionsListObj->DelAllCandItem();
		pUIOptionsListObj->SetCandList(pOptionsList);
		pUIOptionsListObj->SetCurSel(-1);
	}

	// rawdata

	m_fHasRawData = pCandList->FHasRawData();
	if (m_fHasRawData) {
		switch (pCandList->GetRawDataType()) {
			case CANDUIRDT_STRING: {
				m_pCandRawData->SetText( pCandList->GetRawDataString() );
				break;
			}

			case CANDUIRDT_BITMAP: {
				m_pCandRawData->SetBitmap( pCandList->GetRawDataBitmap() );
				break;
			}

			case CANDUIRDT_METAFILE: {
				m_pCandRawData->SetMetaFile( pCandList->GetRawDataMetafile() );
				break;
			}
		}
	}

	// enable/disable candidate number button

	nListItem = pUIListObj->GetItemCount();
	for (i = 0; i < NUM_CANDSTR_MAX; i++) {
		CUIFObject *pUIObj = FindUIObject( IDUIF_CANDNUMBUTTON + i );

		if (pUIObj != NULL) {
			pUIObj->Enable( i < nListItem );
		}
	}

	// update window

	if (m_hWnd != NULL) {
		InvalidateRect( m_hWnd, NULL, TRUE );
	}
}


/*   C L E A R  C A N D I D A T E  L I S T  P R O C   */
/*------------------------------------------------------------------------------

	Clear candidte list

------------------------------------------------------------------------------*/
void CCandWindowBase::ClearCandidateListProc( void )
{
	GetUIListObj()->DelAllCandItem();
}


/*   S E T  S E L E C T I O N  P R O C   */
/*------------------------------------------------------------------------------

	Set selection

------------------------------------------------------------------------------*/
void CCandWindowBase::SetSelectionProc( void )
{
	int iCandItem;
	int iListItem;

	Assert( GetCandListMgr()->GetCandList() != NULL );

	iCandItem = GetCandListMgr()->GetCandList()->GetSelection();
	iListItem = ListItemFromCandItem( iCandItem );

	SelectItemProc( iListItem );
}


/*   S E L E C T  I T E M  P R O C   */
/*------------------------------------------------------------------------------

	Select item procedure

------------------------------------------------------------------------------*/
BOOL CCandWindowBase::SelectItemProc( int iListItem )
{
	if (GetUIListObj()->IsItemSelectable( iListItem )) {
		GetUIListObj()->SetCurSel( iListItem );
		return TRUE;
	}

	return FALSE;
}


/*   S E L E C T  I T E M  T O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::SelectItemTop( void )
{
	SelectItemProc( 0 );
}


/*   S E L E C T  I T E M  E N D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::SelectItemEnd( void )
{
	SelectItemProc( GetUIListObj()->GetItemCount() - 1 );
}


/*   S E L E C T  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::SelectOptionCandidate( void )
{
	int iListItem;
	int iCandItem;

	iListItem = GetUIOptionsListObj()->GetCurSel();
	iCandItem = OptionItemFromListItem( iListItem );

	// NOTE: KOJIW: do not set selection again when the selection in listbox
	// is changed by selection update notification...

	if (m_fOnSelectionChanged) {
		return S_OK;
	}

	GetCandListMgr()->SetOptionSelection( iCandItem, this );

	// We do not want to send a selection notification for options.
	return S_OK;
}


/*   S E L E C T  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::SelectCandidate( void )
{
	int iListItem;
	int iCandItem;

	iListItem = GetUIListObj()->GetCurSel();
	iCandItem = CandItemFromListItem( iListItem );

	// NOTE: KOJIW: do not set selection again when the selection in listbox
	// is changed by selection update notification...

	if (m_fOnSelectionChanged) {
		return S_OK;
	}

	GetCandListMgr()->SetSelection( iCandItem, this );

	return m_pCandUI->NotifySelectCand( iCandItem );
}


/*   C O M P L E T E  O P T I O N  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::CompleteOptionCandidate( void )
{
	int iCandItem;
	int iListItem;

	iListItem = GetUIOptionsListObj()->GetCurSel();
	iCandItem = OptionItemFromListItem( iListItem );

	return m_pCandUI->NotifyCompleteOption( iCandItem );
}


/*   C O M P L E T E  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::CompleteCandidate( void )
{
	int iCandItem;
	int iListItem;

	iListItem = GetUIListObj()->GetCurSel();
	iCandItem = CandItemFromListItem( iListItem );

	return m_pCandUI->NotifyCompleteCand( iCandItem );
}


/*   C A N C E L  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandWindowBase::CancelCandidate( void )
{
	return m_pCandUI->NotifyCancelCand();
}


/*   G E T  M E N U  I C O N  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CCandWindowBase::GetMenuIconSize( void )
{
	const int iIconResSize = 12;		// icon size in resource 
	const int iDefBtnSize  = 14;		// button size of default
	int  iIconSize;
	SIZE size;

	// reload menu button icon

	size.cx = GetSystemMetrics( SM_CXVSCROLL );
	size.cy = GetSystemMetrics( SM_CYHSCROLL );

	iIconSize = min( size.cx, size.cy ) - 2;
	iIconSize = iIconSize * iIconResSize / iDefBtnSize;

	return iIconSize;
}


/*   C R E A T E  E X T E N S I O N  O B J E C T S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::CreateExtensionObjects( void )
{
	LONG nExtension;
	LONG i;

	Assert( m_nExtUIObj == 0 );

	nExtension = GetExtensionMgr()->GetExtensionNum();
	m_nExtUIObj = 0;

	for (i = 0; i < nExtension; i++) {
		CUIFObject *pUIObj = NULL;
		RECT rc = {0};

		pUIObj = GetExtensionMgr()->CreateUIObject( i, this, IDUIF_EXTENDED + i, &rc );
		if (pUIObj != NULL) {
			pUIObj->Initialize();

			GetExtensionMgr()->UpdateObjProp( i, pUIObj );

			AddUIObj( pUIObj );
			m_nExtUIObj++;
		}
	}
}


/*   D E L E T E  E X T E N S I O N  O B J E C T S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::DeleteExtensionObjects( void )
{
	LONG nExtension;
	LONG i;

	nExtension = GetExtensionMgr()->GetExtensionNum();
	for (i = 0; i < nExtension; i++) {
		CUIFObject *pUIObj = FindUIObject( IDUIF_EXTENDED + i );

		if (pUIObj != NULL) {
			RemoveUIObj( pUIObj );
			delete pUIObj;

			m_nExtUIObj--;
		}
	}

	Assert( m_nExtUIObj == 0 );
	m_nExtUIObj = 0;
}


/*   S E T  E X T E N S I O N  O B J E C T  P R O P S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindowBase::SetExtensionObjectProps( void )
{
	LONG nExtension;
	LONG i;

	nExtension = GetExtensionMgr()->GetExtensionNum();
	for (i = 0; i < nExtension; i++) {
		CUIFObject *pUIObj = FindUIObject( IDUIF_EXTENDED + i );

		if (pUIObj != NULL) {
			GetExtensionMgr()->UpdateObjProp( i, pUIObj );
		}
	}
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  W I N D O W                                                  */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

	Constructor of CCandWindow

------------------------------------------------------------------------------*/
CCandWindow::CCandWindow( CCandidateUI *pCandUI, DWORD dwStyle ) : CCandWindowBase( pCandUI, dwStyle | UIWINDOW_TOPMOST | UIWINDOW_TOOLWINDOW | UIWINDOW_OFC10MENU )
{
	m_pOptionsListUIObj = NULL;
	m_pListUIObj      = NULL;
	m_pExtListUIObj   = NULL;
	m_pWndFrame       = NULL;
	m_pCaptionObj     = NULL;
	m_cxWndOffset     = 0;
	m_cyWndOffset     = 0;
	m_nItemShow       = 1;
	m_pCommentWnd     = NULL;
	m_fCommentWndOpen = FALSE;
	m_iItemAttensionSelect = -1;
	m_iItemAttensionHover  = -1;
	m_pCandTipWnd     = NULL;
	m_pCandTipBtn     = NULL;
	m_fCandTipWndOpen = FALSE;
}


/*   ~ C  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

	Destructor of CCandWindow

------------------------------------------------------------------------------*/
CCandWindow::~CCandWindow()
{
	//
	// Notify UI object destroy
	//

	NotifyUIObjectEvent( CANDUIOBJ_OPTIONSLISTBOX,  CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDLISTBOX,     CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDCAPTION,     CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_MENUBUTTON,      CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_EXTRACANDIDATE,  CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDRAWDATA,     CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDTIPBUTTON,   CANDUIOBJEV_DESTROYED );

	if (m_pCommentWnd) {
		delete m_pCommentWnd;
	}

	if (m_pCandTipWnd) {
		delete m_pCandTipWnd;
	}
}


/*   C R E A T E  W N D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HWND CCandWindow::CreateWnd( HWND hWndParent )
{
	HWND hWnd = CCandWindowBase::CreateWnd( hWndParent );

	Assert( GetCandListMgr()->GetCandList() != NULL );

	// make timer to popup comment window

	SetAttensionBySelect( GetCandListMgr()->GetCandList()->GetSelection() );

	return hWnd;
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::Show( BOOL fShow )
{
	if (m_fCommentWndOpen) {
		m_pCommentWnd->Show( fShow );
	}

	if (fShow) {
		if (m_fCandTipWndOpen) {
			OpenCandTipWindow();
		}
	}
	else {
		if (m_fCandTipWndOpen) {
			CloseCandTipWindow();
		}
	}

	CCandWindowBase::Show( fShow );
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

	Initialize UI objects

------------------------------------------------------------------------------*/
CUIFObject *CCandWindow::Initialize( void )
{
	RECT rc = {0};
#ifdef NEVER
	CUIFButton *pButton;
#endif
	CUIFBorder *pBorder;

	//
	// create window frame
	//

	m_pWndFrame = new CUIFWndFrame( this, &rc, UIWNDFRAME_THIN | UIWNDFRAME_NORESIZE );
	if (m_pWndFrame != NULL) {
		m_pWndFrame->Initialize();
		AddUIObj( m_pWndFrame );
	}

#ifdef NEVER
	if (!FHasStyle( UIWINDOW_OFFICENEWLOOK )) {
		int  i;

		//
		// create candidate num buttons
		//

		for (i = 0; i < NUM_CANDSTR_MAX; i++) {
			WCHAR szNum[2];

			pButton = new CUIFButton( this, IDUIF_CANDNUMBUTTON + i, &rc, UIBUTTON_CENTER | UIBUTTON_VCENTER );
            if (pButton)
            {
			    pButton->Initialize();
 
			    szNum[0] = L'1' + i;
			    szNum[1] = L'\0';
			    pButton->SetText( szNum );

			    AddUIObj( pButton );
            }
		}

		//
		// create border
		//

		pBorder = new CUIFBorder( this, IDUIF_BORDERLEFT, &rc, UIBORDER_VERT );
		pBorder->Initialize();
		AddUIObj( pBorder );
	}
#endif
 
	//
	// create options candidate list
	//

	m_pOptionsListUIObj = new CUIFCandList( this, IDUIF_OPTIONSLIST, &rc, UILIST_HORZTB );
	if (m_pOptionsListUIObj != NULL) {
		m_pOptionsListUIObj->Initialize();
		AddUIObj( m_pOptionsListUIObj );

//		m_pOptionsListUIObj->SetIconPopupComment( m_hIconPopupOn, m_hIconPopupOff );
	}

	//
	// create options candidate list border
	//

	pBorder = new CUIFCandBorder( this, IDUIF_BORDEROPTIONSCAND, &rc, UIBORDER_HORZ );
	if (pBorder != NULL) {
		pBorder->Initialize();
		AddUIObj( pBorder );
	}

	//
	// create candidate list
	//

	m_pListUIObj = new CUIFCandList( this, IDUIF_CANDIDATELIST, &rc, UILIST_HORZTB );
	if (m_pListUIObj != NULL) {
		m_pListUIObj->Initialize();
		AddUIObj( m_pListUIObj );

		m_pListUIObj->SetIconPopupComment( m_hIconPopupOn, m_hIconPopupOff );
	}

	//
	// create extra candidate list
	//

	m_pExtListUIObj = new CUIFExtCandList( this, IDUIF_EXTCANDIDATELIST, &rc, UILIST_HORZTB );
	if (m_pExtListUIObj != NULL) {
		m_pExtListUIObj->Initialize();
		AddUIObj( m_pExtListUIObj );
	}

	//
	// create extra candidate list border
	//

	pBorder = new CUIFCandBorder( this, IDUIF_BORDEREXTRACAND, &rc, UIBORDER_HORZ );
	if (pBorder != NULL) {
		pBorder->Initialize();
		AddUIObj( pBorder );
	}

	//
	// create candidate menu button
	//

	m_pCandMenuBtn = new CUIFCandMenuButton( this, IDUIF_CANDIDATEMENU, &rc, UIBUTTON_TOGGLE | UIBUTTON_CENTER | UIBUTTON_VCENTER );
	if (m_pCandMenuBtn != NULL) {
		m_pCandMenuBtn->Initialize();
		AddUIObj( m_pCandMenuBtn );

		if (m_pCandAcc != NULL) {
			m_pCandAcc->AddAccItem( (CUIFCandMenuButton*)m_pCandMenuBtn );
		}

		m_pCandMenuBtn->SetIcon( m_hIconMenu );
	}

	//
	// create raw data border
	//

	pBorder = new CUIFCandBorder( this, IDUIF_BORDERRAWDATA, &rc, UIBORDER_HORZ );
	if (pBorder != NULL) {
		pBorder->Initialize();
		AddUIObj( pBorder );
	} 
    
	//
	// creare raw data statics
	//

	m_pCandRawData = new CUIFCandRawData( this, IDUIF_RAWDATA, &rc, UICANDRAWDATA_HORZTB );
	if (m_pCandRawData != NULL) {
		m_pCandRawData->Initialize();
		AddUIObj( m_pCandRawData );
	}

	//
	// create extension border
	//

	pBorder = new CUIFCandBorder( this, IDUIF_BORDERBOTTOM, &rc, UIBORDER_HORZ );
	if (pBorder != NULL) {
		pBorder->Initialize();
		AddUIObj( pBorder );
	}

	//
	// create extension items
	//

	if (0 < GetExtensionMgr()->GetExtensionNum()) {
		CreateExtensionObjects();
	}

	//
	// create caption
	//

	m_pCaptionObj = new CUIFWndCaption( this, IDUIF_CAPTION, &rc, UIWNDCAPTION_INACTIVE );
	if (m_pCaptionObj != NULL) {
		m_pCaptionObj->Initialize();
		AddUIObj( m_pCaptionObj );
	}

	//
	//
	//

	m_pCandTipBtn = new CUIFButton2( this, IDUIF_CANDTIPBTN, &rc, UIBUTTON_CENTER | UIBUTTON_VCENTER );
	if (m_pCandTipBtn != NULL) {
		m_pCandTipBtn->Initialize();
		AddUIObj( m_pCandTipBtn );

		m_pCandTipBtn->SetIcon( m_hIconCandTipOff );
	}

	//
	// create candidate tip window
	//

	m_pCandTipWnd = new CUIFBalloonWindow( g_hInst, 0 );
	if (m_pCandTipWnd) {
		m_pCandTipWnd->Initialize();
		m_pCandTipWnd->SetFont( GetPropertyMgr()->GetToolTipProp()->GetFont() );
	}

	//
	// create poupup window
	//
	m_pCommentWnd = new CPopupCommentWindow( this, m_pCandUI );
	if (m_pCommentWnd != NULL) {
		m_pCommentWnd->Initialize();
	}

	//
	// Initialize accessibility item
	//

	if (m_pCandAcc != NULL) {
		m_pListUIObj->InitAccItems( m_pCandAcc );
	}

	//
	// Notify UI object creation
	//

	NotifyUIObjectEvent( CANDUIOBJ_OPTIONSLISTBOX,  CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDLISTBOX,     CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDCAPTION,     CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_MENUBUTTON,      CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_EXTRACANDIDATE,  CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDRAWDATA,     CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDTIPBUTTON,   CANDUIOBJEV_CREATED );

	return CCandWindowBase::Initialize();
}


/*   G E T  W N D  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CCandWindow::GetWndStyle( void )
{
	return CCandWindowBase::GetWndStyle() & ~WS_BORDER;
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OnTimer( UINT uiTimerID )
{
	if (uiTimerID == IDTIMER_POPUPCOMMENT_SELECT || uiTimerID == IDTIMER_POPUPCOMMENT_HOVER) {
		int iItem;

		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_SELECT );
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );

		iItem = (uiTimerID == IDTIMER_POPUPCOMMENT_SELECT) ? m_iItemAttensionSelect : m_iItemAttensionHover;
		OpenCommentWindow( iItem );
	}
	else if (uiTimerID == IDTIMER_MENU_HOVER) {
		// Check mouse position.
		POINT pt;
		RECT rc;
		GetCursorPos(&pt);
		ScreenToClient(m_hWnd, &pt);
		m_pOptionsListUIObj->GetRect(&rc);
		pt.x -= rc.left;
		pt.y -= rc.top;
		if (pt.x < 0 || pt.y < 0 || pt.x > (rc.right - rc.left) || pt.y > (rc.bottom - rc.top))
		{
			KillTimer(m_hWnd, IDTIMER_MENU_HOVER);
			// Send messages that Cicero does on the mouse monitoring timer to trigger correct behavior and 
			// unselect the menu item.
			SetObjectPointed( NULL, pt );
			OnMouseOutFromWindow( pt );
		}
		else
		{
			SetTimer(m_hWnd, IDTIMER_MENU_HOVER, 50, NULL);
		}
	}
}


/*   O N  S Y S  C O L O R  C H A N G E   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
void CCandWindow::OnSysColorChange()
{
	CCandWindowBase::OnSysColorChange();

	if (m_pCandTipBtn) {
		m_pCandTipBtn->SetIcon( m_fCandTipWndOpen ? m_hIconCandTipOn : m_hIconCandTipOff );
	}
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CCandWindow::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
	// check hovering item
	if (pUIObj->GetID() == IDUIF_OPTIONSLIST) {
		if (dwCommand == UICANDLIST_HOVERITEM) {
			int iCandItem = OptionItemFromListItem( (int)lParam );

			SetOptionsAttensionByHover( iCandItem );
		}
	}
	else if (pUIObj->GetID() == IDUIF_CANDIDATELIST) {
		if (dwCommand == UICANDLIST_HOVERITEM) {
			int iCandItem = CandItemFromListItem( (int)lParam );

			SetAttensionByHover( iCandItem );
		}
		else if (dwCommand == UILIST_SELCHANGED) {
			int iCandItem = CandItemFromListItem( (int)lParam );

			SetAttensionBySelect( iCandItem );
		}
	}
	else if (pUIObj->GetID() == IDUIF_EXTCANDIDATELIST) {
		if (dwCommand == UILIST_SELECTED) {
			m_pCandUI->NotifyCompleteExtraCand();
			return 0;
		}
	}
	else if (pUIObj->GetID() == IDUIF_CANDTIPBTN) {
		if (m_fCandTipWndOpen) {
			CloseCandTipWindow();
			m_fCandTipWndOpen = FALSE;
		}
		else {
			OpenCandTipWindow();
			m_fCandTipWndOpen = TRUE;
		}

		m_pCandTipBtn->SetIcon( m_fCandTipWndOpen ? m_hIconCandTipOn : m_hIconCandTipOff );
	}

	return CCandWindowBase::OnObjectNotify( pUIObj, dwCommand, lParam );
}


/*   S E T  T A R G E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SetTargetRect( RECT *prc, BOOL fClipped )
{
	SIZE sizeWnd;

	sizeWnd.cx = _nWidth;
	sizeWnd.cy = _nHeight;

	if (IsShadowEnabled() && m_pWndShadow) {
		SIZE sizeShadow;

		m_pWndShadow->GetShift( &sizeShadow );
		sizeWnd.cx += sizeShadow.cx;
		sizeWnd.cy += sizeShadow.cy;
	}

	m_rcTarget = *prc;
	m_fTargetClipped = fClipped;

	if (m_hWnd != NULL) {
		RECT rc;

		// move window here...

		switch (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection()) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				CalcWindowRect( &rc, &m_rcTarget, sizeWnd.cx, sizeWnd.cy, m_cxWndOffset, m_cyWndOffset, ALIGN_LEFT, LOCATE_BELLOW );
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				CalcWindowRect( &rc, &m_rcTarget, sizeWnd.cx, sizeWnd.cy, m_cxWndOffset, m_cyWndOffset, ALIGN_RIGHT, LOCATE_ABOVE );
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				CalcWindowRect( &rc, &m_rcTarget, sizeWnd.cx, sizeWnd.cy, m_cxWndOffset, m_cyWndOffset, LOCATE_LEFT, ALIGN_TOP );
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				CalcWindowRect( &rc, &m_rcTarget, sizeWnd.cx, sizeWnd.cy, m_cxWndOffset, m_cyWndOffset, LOCATE_RIGHT, ALIGN_BOTTOM );
				break;
			}
		}

		if (rc.left != _xWnd || rc.top != _yWnd) {
			Move( rc.left, rc.top, -1, -1 );

			//

			if (m_pCommentWnd != NULL) {
				m_pCommentWnd->OnCandWindowMove( TRUE );
			}

			if (m_pCandTipWnd != NULL) {
				MoveCandTipWindow();
			}
		}
	}
}


/*   S E T  W I N D O W  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SetWindowPos( POINT pt )
{
	if (m_hWnd != NULL) {
		RECT rc;

		rc.left   = pt.x;
		rc.top    = pt.y;
		rc.right  = pt.x + _nWidth;
		rc.bottom = pt.y + _nHeight;

		AdjustWindowRect( NULL, &rc, &pt, FALSE );
		if (rc.left != _xWnd || rc.top != _yWnd) {
			Move( rc.left, rc.top, -1, -1 );

			//

			if (m_pCommentWnd != NULL) {
				m_pCommentWnd->OnCandWindowMove( TRUE );
			}

			if (m_pCandTipWnd != NULL) {
				MoveCandTipWindow();
			}
		}
	}
}


/*   P R E P A R E  L A Y O U T   */
/*------------------------------------------------------------------------------

	Prepare to layout window
	NOTE: This method will be called just once after created (not called when 
	candidate list has updated) 

------------------------------------------------------------------------------*/
void CCandWindow::PrepareLayout( void )
{
	// determine lines of options list ui object

	m_nOptionsItemShow = m_pOptionsListUIObj->GetCount();

	// determine lines of list ui object

	if (GetPropertyMgr()->GetCandListBoxProp()->GetHeight() == -1) {
		m_nItemShow = min( m_pListUIObj->GetCount(), NUM_CANDSTR_MAX );
		m_nItemShow = max( m_nItemShow, 1 );
	}
	else {
		m_nItemShow = GetPropertyMgr()->GetCandListBoxProp()->GetHeight();
	}

	Assert((1 <= m_nItemShow) && (m_nItemShow <= 9));

	// determine candtip window open status

	m_fCandTipWndOpen = (GetCandListMgr()->GetCandList()->GetTipString() != NULL);
}


/*   L A Y O U T  W I N D O W   */
/*------------------------------------------------------------------------------

	Layout window

------------------------------------------------------------------------------*/
void CCandWindow::LayoutWindow( void )
{
	HDC   hDC = GetDC( m_hWnd );
    int   nChild;
	int   i;
	CUIFObject *pUIObj;

	// metrics

	SIZE sizeMetText;
	SIZE sizeMetCaptionText;
	SIZE sizeMetCandItem;
#ifdef NEVER
	SIZE sizeMetCandNum;
#endif
	SIZE sizeMetSmButton;
	SIZE sizeMetScroll;
	SIZE sizeMetBorder;
#ifdef NEVER
	SIZE sizeMetMargin;
#endif
	SIZE sizeMetWndFrame;

	SIZE sizeCaptionObj       = {0};
	SIZE sizeExtCandListObj   = {0};
	SIZE sizeExtCandListBdr   = {0};
	SIZE sizeOptionsListObj   = {0};
	SIZE sizeOptionsListBdr   = {0};
	SIZE sizeCandListObj      = {0};
	SIZE sizeRawDataObj       = {0};
	SIZE sizeRawDataBdr       = {0};

	SIZE sizeCandListArea     = {0};
	SIZE sizeExtensionArea    = {0};

	SIZE sizeWindow           = {0};
	RECT rcClient             = {0};
	RECT rcWindow             = {0};

	RECT rcCaptionObj         = {0};
	RECT rcOptionsListBdr     = {0};
	RECT rcCandListArea       = {0};
	RECT rcExtensionArea      = {0};

	RECT rcExtCandListObj     = {0};
	RECT rcExtCandListBdr     = {0};
	RECT rcOptionsListObj     = {0};
	RECT rcCandListObj        = {0};
	RECT rcRawDataObj         = {0};
	RECT rcRawDataBdr         = {0};

	int cxMax                 = 0;
	int cxMaxCandString       = 0;
	int cxMaxInlineComment    = 0;
	int cxInlineCommentPos    = 0;
	int cxyExtraTopSpace      = 0;
	int cxyExtraBottomSpace   = 0;

	DWORD dwListStyle;
	DWORD dwBdrStyle;

	CANDUIUIDIRECTION uidir   = GetPropertyMgr()->GetCandWindowProp()->GetUIDirection();
#ifdef NEVER
	BOOL  fShowNumber         = !FHasStyle( UIWINDOW_OFFICENEWLOOK );
#endif
	BOOL  fShowCaption        = GetPropertyMgr()->GetWindowCaptionProp()->IsVisible();
	BOOL  fShowCandTip        = (GetCandListMgr()->GetCandList() != NULL) ? (GetCandListMgr()->GetCandList()->GetTipString() != NULL) : FALSE;
	HFONT hFontUI             = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
	HFONT hFontCandidateList  = GetPropertyMgr()->GetCandStringProp()->GetFont();
	HFONT hFontInlineComment  = GetPropertyMgr()->GetInlineCommentProp()->GetFont();
	HFONT hFontIndex          = GetPropertyMgr()->GetCandIndexProp()->GetFont();
	HFONT hFontCaption        = GetPropertyMgr()->GetWindowCaptionProp()->GetFont();
	BOOL  fHasExtension       = (0 < GetExtensionMgr()->GetExtensionNum());
	BOOL  fShowExtCandList    = FALSE;
	BOOL  fShowOptionsCandList = FALSE;
	BOOL  fHasPopupComment    = FALSE;

	Assert( 1 <= m_nItemShow );

	//
	// set font of UI object
	//

	nChild = m_ChildList.GetCount();
	for (i = 0; i < nChild; i++) {
		CUIFObject *pUIObjTmp = m_ChildList.Get( i );

		Assert( pUIObjTmp != NULL );
		if (pUIObjTmp == m_pListUIObj)  {
			m_pListUIObj->SetFont( hFontCandidateList );
			m_pListUIObj->SetInlineCommentFont( hFontInlineComment );
			m_pListUIObj->SetIndexFont( hFontIndex );
		}
		else if (pUIObjTmp == m_pOptionsListUIObj)  {
			m_pOptionsListUIObj->SetFont( hFontCandidateList );
			m_pOptionsListUIObj->SetInlineCommentFont( hFontInlineComment );
			m_pOptionsListUIObj->SetIndexFont( hFontIndex );
		}
		else if (pUIObjTmp == m_pExtListUIObj)  {
			m_pExtListUIObj->SetFont( hFontCandidateList );
			m_pExtListUIObj->SetInlineCommentFont( hFontInlineComment );
			m_pExtListUIObj->SetIndexFont( hFontIndex );
		}
		else if (pUIObjTmp == m_pCaptionObj) {
			pUIObjTmp->SetFont( hFontCaption );
		}
		else {
			pUIObjTmp->SetFont( hFontUI );
		}
	}


	//
	// calculate metrics
	//

	// window frame

	sizeMetWndFrame.cx = 0;
	sizeMetWndFrame.cy = 0;
	if (m_pWndFrame != NULL) {
		m_pWndFrame->GetFrameSize( &sizeMetWndFrame );
	}

	// candidate item

	sizeMetText.cx = GetFontHeightOfFont( hDC, hFontCandidateList );
	sizeMetText.cy = GetFontHeightOfFont( hDC, hFontCandidateList );
	sizeMetCandItem.cx = sizeMetText.cy * 4;
	sizeMetCandItem.cy = m_pUIFScheme->CyMenuItem( sizeMetText.cy );

	// Options list.

	if (m_pOptionsListUIObj != NULL) {
		HFONT hFontOld = (HFONT)GetCurrentObject( hDC, OBJ_FONT );
		int  nItem = m_pOptionsListUIObj->GetCount();
		LPCWSTR psz;
		SIZE size;
		CCandidateItem *pOptionsItem;

		fShowOptionsCandList = (0 < nItem);

		// get candidate string width

		SelectObject( hDC, hFontCandidateList );
		for (i = 0; i < nItem; i++) {
			pOptionsItem = m_pOptionsListUIObj->GetCandidateItem( i );
			// can't really do anything if this is null
			//
			if ( !pOptionsItem )
				continue;

			psz = pOptionsItem->GetString();
			if (psz != NULL) {
				SIZE sizeT;

				FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );

				if (pOptionsItem->GetIcon() != NULL) {
					size.cx += sizeMetCandItem.cy;
				}

				if (psz = pOptionsItem->GetPrefixString()) {
					FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeT );
					size.cx += sizeT.cx;
				}

				if (psz = pOptionsItem->GetSuffixString()) {
					FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeT );
					size.cx += sizeT.cx;
				}

				cxMaxCandString = max( cxMaxCandString, size.cx );

				// check if it has popup comment

				if (pOptionsItem->GetPopupComment() != NULL) {
					fHasPopupComment = TRUE;
				}
			}
		}

		// get inline comment width

		SelectObject( hDC, hFontInlineComment );
		for (i = 0; i < nItem; i++) {
			pOptionsItem = m_pOptionsListUIObj->GetCandidateItem( i );

			if (pOptionsItem) {
			    psz = pOptionsItem->GetInlineComment();
			    if (psz != NULL) {
				    FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
				    cxMaxInlineComment = max( cxMaxInlineComment, size.cx );
			    }
			}
		}

		SelectObject( hDC, hFontOld );
	}

	// Main candidate list.

	if (m_pListUIObj != NULL) {
		HFONT hFontOld = (HFONT)GetCurrentObject( hDC, OBJ_FONT );
		int  nItem = m_pListUIObj->GetCount();
		LPCWSTR psz;
		SIZE size;
		CCandidateItem *pCandItem;

		// get candidate string width

		SelectObject( hDC, hFontCandidateList );
		for (i = 0; i < nItem; i++) {
			pCandItem = m_pListUIObj->GetCandidateItem( i );
            // can't really do anything if this is null
            //
            if ( !pCandItem )
                continue;

			psz = pCandItem->GetString();
			if (psz != NULL) {
				SIZE sizeT;

				FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );

				if (pCandItem->GetIcon() != NULL) {
					size.cx += sizeMetCandItem.cy;
				}

				if (psz = pCandItem->GetPrefixString()) {
					FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeT );
					size.cx += sizeT.cx;
				}

				if (psz = pCandItem->GetSuffixString()) {
					FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeT );
					size.cx += sizeT.cx;
				}

				cxMaxCandString = max( cxMaxCandString, size.cx );

				// check if it has popup comment

				if (pCandItem->GetPopupComment() != NULL) {
					fHasPopupComment = TRUE;
				}
			}
		}

		// get inline comment width

		SelectObject( hDC, hFontInlineComment );
		for (i = 0; i < nItem; i++) {
			pCandItem = m_pListUIObj->GetCandidateItem( i );

            if (pCandItem) {
			    psz = pCandItem->GetInlineComment();
			    if (psz != NULL) {
				    FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
				    cxMaxInlineComment = max( cxMaxInlineComment, size.cx );
			    }
			}
		}

		SelectObject( hDC, hFontOld );
	}

	// extra candidate item

	if (m_pExtListUIObj != NULL) {
		HFONT hFontOld = (HFONT)GetCurrentObject( hDC, OBJ_FONT );
		int  nItem = m_pExtListUIObj->GetCount();
		LPCWSTR psz;
		SIZE size;
		CCandidateItem *pCandItem;

		fShowExtCandList = (0 < nItem);
		Assert( nItem <= 1 );

		// get candidate string width

		SelectObject( hDC, hFontCandidateList );
		for (i = 0; i < nItem; i++) {
			pCandItem = m_pExtListUIObj->GetCandidateItem( i );

            // can't really do anything if this is null
            //
            if ( !pCandItem )
                continue;

			psz = pCandItem->GetString();
			if (psz != NULL) {
				SIZE sizeT;

				FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );

				if (pCandItem->GetIcon() != NULL) {
					size.cx += sizeMetCandItem.cy;
				}

				if (psz = pCandItem->GetPrefixString()) {
					FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeT );
					size.cx += sizeT.cx;
				}

				if (psz = pCandItem->GetSuffixString()) {
					FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &sizeT );
					size.cx += sizeT.cx;
				}

				cxMaxCandString = max( cxMaxCandString, size.cx );

				// check if it has popup comment

				if (pCandItem->GetPopupComment() != NULL) {
					fHasPopupComment = TRUE;
				}
			}
		}

		// get inline comment width

		SelectObject( hDC, hFontInlineComment );
		for (i = 0; i < nItem; i++) {
			pCandItem = m_pExtListUIObj->GetCandidateItem( i );

            if (pCandItem) {
    			psz = pCandItem->GetInlineComment();
	    		if (psz != NULL) {
		    		FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
			    	cxMaxInlineComment = max( cxMaxInlineComment, size.cx );
			    }
			}
		}

		SelectObject( hDC, hFontOld );
	}

	// calc width of candidate item and inline comment

	if (0 < cxMaxInlineComment) {
		int cxT = (cxMaxCandString + sizeMetText.cy / 2 + cxMaxInlineComment);

		cxT += 8 /* margen at left */ + (fHasPopupComment ? sizeMetText.cy / 2 + sizeMetCandItem.cy : 0) + 8 /* margin at right */;

		cxInlineCommentPos = cxMaxCandString + sizeMetText.cy / 2;
		sizeMetCandItem.cx = max( sizeMetCandItem.cx, cxT );
	}
	else {
		int cxT = cxMaxCandString;

		cxT += 8 /* margen at left */ + (fHasPopupComment ? sizeMetText.cy / 2 + sizeMetCandItem.cy : 0) + 8 /* margin at right */;

		cxInlineCommentPos = 0;
		sizeMetCandItem.cx = max( sizeMetCandItem.cx, cxT );
	}

#ifdef NEVER
	// number button

	sizeMetCandNum.cx = sizeMetCandItem.cy;
	sizeMetCandNum.cy = sizeMetCandItem.cy;
#endif

	// scrollbar

	sizeMetScroll.cx = GetSystemMetrics( SM_CXVSCROLL );
	sizeMetScroll.cy = GetSystemMetrics( SM_CYHSCROLL );

	// candidate menu button

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM:
		case CANDUIDIR_BOTTOMTOTOP: {
			sizeMetSmButton.cx = sizeMetSmButton.cy = sizeMetScroll.cx;
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT:
		case CANDUIDIR_LEFTTORIGHT: {
			sizeMetSmButton.cx = sizeMetSmButton.cy = sizeMetScroll.cy;
			break;
		}
	}

	// caption text

	if (m_pCaptionObj != NULL) {
		HFONT hFontOld = (HFONT)SelectObject( hDC, hFontCaption );
		LPCWSTR psz;
		SIZE size;

		psz = GetPropertyMgr()->GetWindowCaptionProp()->GetText();
		if (psz != NULL) {
			FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );
		}
		else {
			FLGetTextExtentPoint32( hDC, L" ", 1, &size );
		}

		sizeMetCaptionText.cx = size.cx;
		sizeMetCaptionText.cy = size.cy;

		SelectObject( hDC, hFontOld);
	}

	// border

	sizeMetBorder.cx = 3;
	sizeMetBorder.cy = 3;

#ifdef NEVER
	// object margin

	sizeMetMargin.cx = 1;
	sizeMetMargin.cy = 1;
#endif

	//
	// calculate sizes of objects
	//

	// caption

	sizeCaptionObj.cx = 0;
	sizeCaptionObj.cy = 0;

	if (fShowCaption) {
		sizeCaptionObj.cx = sizeMetCaptionText.cx + 16;
		sizeCaptionObj.cy = sizeMetCaptionText.cy + 2;
	}

	// extra candidate list

	sizeExtCandListObj.cx = 0;
	sizeExtCandListObj.cy = 0;
	sizeExtCandListBdr.cx = 0;
	sizeExtCandListBdr.cy = 0;

	if (fShowExtCandList) {
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				sizeExtCandListObj.cx = sizeMetCandItem.cx + sizeMetScroll.cx + sizeMetCandItem.cy + 4;
				sizeExtCandListObj.cy = sizeMetCandItem.cy;

				sizeExtCandListBdr.cx = sizeExtCandListObj.cx;
				sizeExtCandListBdr.cy = sizeMetBorder.cy;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				sizeExtCandListObj.cx = sizeMetCandItem.cy;
				sizeExtCandListObj.cy = sizeMetCandItem.cx + sizeMetScroll.cx + sizeMetCandItem.cy + 4;

				sizeExtCandListBdr.cx = sizeMetBorder.cx;
				sizeExtCandListBdr.cy = sizeExtCandListObj.cy;
				break;
			}
		}
	}

	// Options candidate list

#ifdef NEVER
	if (FHasStyle( UIWINDOW_OFFICENEWLOOK )) {
#endif
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				sizeOptionsListObj.cx = sizeMetCandItem.cx + sizeMetScroll.cx + sizeMetCandItem.cy + 4;
				sizeOptionsListObj.cy = sizeMetCandItem.cy * m_nOptionsItemShow;

				sizeOptionsListBdr.cx = sizeOptionsListObj.cx;
                sizeOptionsListBdr.cy = fShowOptionsCandList ? sizeMetBorder.cy : 0;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				sizeOptionsListObj.cx = sizeMetCandItem.cy * m_nOptionsItemShow;
				sizeOptionsListObj.cy = sizeMetCandItem.cx + sizeMetScroll.cy + sizeMetCandItem.cy + 4;

                sizeOptionsListBdr.cx = fShowOptionsCandList ? sizeMetBorder.cx : 0;
				sizeOptionsListBdr.cy = sizeOptionsListObj.cy;
				break;
			}
		}
#ifdef NEVER
	}
	else {
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				sizeOptionsListObj.cx = sizeMetCandItem.cx + sizeMetScroll.cx;
				sizeOptionsListObj.cy = sizeMetCandItem.cy * m_nOptionsItemShow;

				sizeOptionsListBdr.cx = sizeOptionsListObj.cx;
				sizeOptionsListBdr.cy = sizeMetBorder.cy;

				m_cxWndOffset = -(sizeMetWndFrame.cx + (fShowNumber ? sizeMetCandNum.cx + sizeMetMargin.cx + sizeMetBorder.cx + sizeMetMargin.cx : 0));
				m_cyWndOffset = 0;
				break;
				}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				sizeOptionsListObj.cx = sizeMetCandItem.cy * m_nOptionsItemShow;
				sizeOptionsListObj.cy = sizeMetCandItem.cx + sizeMetScroll.cy;

                sizeOptionsListBdr.cx = sizeMetBorder.cx;
				sizeOptionsListBdr.cy = sizeOptionsListObj.cy;

				m_cxWndOffset = 0;
				m_cyWndOffset = -(sizeMetWndFrame.cy + (fShowNumber ? sizeMetCandNum.cy + sizeMetMargin.cy + sizeMetBorder.cy + sizeMetMargin.cy : 0));
				break;
			}
		}
	}
#endif

	// candidate list

#ifdef NEVER
	if (FHasStyle( UIWINDOW_OFFICENEWLOOK )) {
#endif
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				sizeCandListObj.cx = sizeMetCandItem.cx + sizeMetScroll.cx + sizeMetCandItem.cy + 4;
				sizeCandListObj.cy = sizeMetCandItem.cy * m_nItemShow;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				sizeCandListObj.cx = sizeMetCandItem.cy * m_nItemShow;
				sizeCandListObj.cy = sizeMetCandItem.cx + sizeMetScroll.cy + sizeMetCandItem.cy + 4;
				break;
			}
		}
#ifdef NEVER
	}
	else {
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				sizeCandListObj.cx = sizeMetCandItem.cx + sizeMetScroll.cx;
				sizeCandListObj.cy = sizeMetCandItem.cy * m_nItemShow;

				m_cxWndOffset = -(sizeMetWndFrame.cx + (fShowNumber ? sizeMetCandNum.cx + sizeMetMargin.cx + sizeMetBorder.cx + sizeMetMargin.cx : 0));
				m_cyWndOffset = 0;
				break;
				}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				sizeCandListObj.cx = sizeMetCandItem.cy * m_nItemShow;
				sizeCandListObj.cy = sizeMetCandItem.cx + sizeMetScroll.cy;

				m_cxWndOffset = 0;
				m_cyWndOffset = -(sizeMetWndFrame.cy + (fShowNumber ? sizeMetCandNum.cy + sizeMetMargin.cy + sizeMetBorder.cy + sizeMetMargin.cy : 0));
				break;
			}
		}
	}
#endif

	// raw data

	sizeRawDataObj.cx = 0;
	sizeRawDataObj.cy = 0;
	sizeRawDataBdr.cx = 0;
	sizeRawDataBdr.cy = 0;

	if (m_fHasRawData) {
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				sizeRawDataObj.cx = sizeCandListObj.cx + 2;
				sizeRawDataObj.cy = sizeMetText.cy * 3 / 2;

				sizeRawDataBdr.cx = sizeRawDataObj.cx;
				sizeRawDataBdr.cy = sizeMetBorder.cy;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				sizeRawDataObj.cx = sizeMetText.cy * 3 / 2;
				sizeRawDataObj.cy = sizeCandListObj.cy + 2;

				sizeRawDataBdr.cx = sizeMetBorder.cx;
				sizeRawDataBdr.cy = sizeRawDataObj.cy;
				break;
			}
		}
	}


	//
	// calc offsets
	//

#ifdef NEVER
	if (FHasStyle( UIWINDOW_OFFICENEWLOOK )) {
#endif
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				m_cxWndOffset = -(sizeMetWndFrame.cx + sizeMetCandItem.cy + 4 + 8);
				m_cyWndOffset = 0;
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				m_cxWndOffset = +(sizeMetWndFrame.cx + sizeMetScroll.cx + 4);
				m_cyWndOffset = 0;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				m_cxWndOffset = 0;
				m_cyWndOffset = -(sizeMetWndFrame.cy + sizeMetCandItem.cy + 4 + 8);
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				m_cxWndOffset = 0;
				m_cyWndOffset = +(sizeMetWndFrame.cy + sizeMetScroll.cy + 4);
				break;
			}
		}
#ifdef NEVER
	}
	else {
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				m_cxWndOffset = -(sizeMetWndFrame.cx + (fShowNumber ? sizeMetCandNum.cx + sizeMetMargin.cx + sizeMetBorder.cx + sizeMetMargin.cx : 0));
				m_cyWndOffset = 0;
				break;
				}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				m_cxWndOffset = 0;
				m_cyWndOffset = -(sizeMetWndFrame.cy + (fShowNumber ? sizeMetCandNum.cy + sizeMetMargin.cy + sizeMetBorder.cy + sizeMetMargin.cy : 0));
				break;
			}
		}
	}
#endif

	//
	// calculate sizes of areas
	//

	// candlist area

#ifdef NEVER
	if (FHasStyle( UIWINDOW_OFFICENEWLOOK )) {
#endif
		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {
				// candidate list

				sizeCandListArea.cx = sizeCandListObj.cx;
				sizeCandListArea.cy = sizeCandListObj.cy;

				// options candidate list
				sizeCandListArea.cx = max( sizeCandListArea.cx, sizeOptionsListObj.cx );
				sizeCandListArea.cy += sizeOptionsListObj.cy + sizeOptionsListBdr.cy;

				// extra candidate list

				sizeCandListArea.cx = max( sizeCandListArea.cx, sizeExtCandListObj.cx );
				sizeCandListArea.cy += sizeExtCandListObj.cy + sizeExtCandListBdr.cy;

				// raw data

				sizeCandListArea.cx = max( sizeCandListArea.cx, sizeRawDataObj.cx );
				sizeCandListArea.cy += sizeRawDataObj.cy + sizeRawDataBdr.cy;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {
				// candidate list

				sizeCandListArea.cx = sizeCandListObj.cx;
				sizeCandListArea.cy = sizeCandListObj.cy;

				// options candidate list

				sizeCandListArea.cx += sizeOptionsListObj.cx + sizeOptionsListBdr.cx;
				sizeCandListArea.cy = max( sizeCandListArea.cy, sizeOptionsListObj.cy );

				// extra candidate list

				sizeCandListArea.cx += sizeExtCandListObj.cx + sizeExtCandListBdr.cx;
				sizeCandListArea.cy = max( sizeCandListArea.cy, sizeExtCandListObj.cy );

				// raw data

				sizeCandListArea.cx += sizeRawDataObj.cx + sizeRawDataBdr.cx;
				sizeCandListArea.cy = max( sizeCandListArea.cy, sizeRawDataObj.cy );
				break;
			}
		}
#ifdef NEVER
	}
	else {
		sizeCandListArea.cx = sizeCandListObj.cx;  /* be adjusted later */
		sizeCandListArea.cy = sizeCandListObj.cy;  /* be adjusted later */

		if (fShowNumber) {
			switch (uidir) {
				default:
				case CANDUIDIR_TOPTOBOTTOM: 
				case CANDUIDIR_BOTTOMTOTOP: {
					sizeCandListArea.cx += sizeMetCandNum.cx + sizeMetMargin.cx + sizeMetBorder.cx + sizeMetMargin.cx;
					break;
				}

				case CANDUIDIR_RIGHTTOLEFT:
				case CANDUIDIR_LEFTTORIGHT: {
					sizeCandListArea.cy += sizeMetCandNum.cy + sizeMetMargin.cy + sizeMetBorder.cy + sizeMetMargin.cy;
					break;
				}
			}
		}
	}
#endif

	// extension area

	sizeExtensionArea.cx = 0;
	sizeExtensionArea.cy = 0;

	if (fHasExtension) {
		SIZE size;
		LONG nExtension;
		LONG iExtension;

		nExtension = GetExtensionMgr()->GetExtensionNum();
		for (iExtension = 0; iExtension < nExtension; iExtension++) {
			CCandUIExtension *pExtension = GetExtensionMgr()->GetExtension( iExtension );

			pExtension->GetSize( &size );
			sizeExtensionArea.cx += size.cx;
			sizeExtensionArea.cy = max( sizeExtensionArea.cy, size.cy );
		}

		if (0 < nExtension) {
			sizeExtensionArea.cx += 2;
			sizeExtensionArea.cy += sizeMetBorder.cy;
		}
	}


	//
	// adjust object/area size
	//

	// max width

	cxMax = sizeCaptionObj.cx;
	cxMax = max( cxMax, sizeCandListArea.cx );
	cxMax = max( cxMax, sizeExtensionArea.cx );

	// size of areas

	sizeCaptionObj.cx     = cxMax;
	sizeCandListArea.cx   = cxMax;
	sizeExtensionArea.cx  = cxMax;

	// objects in candidate list areas

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: 
		case CANDUIDIR_BOTTOMTOTOP: {
			sizeExtCandListObj.cx = sizeCandListArea.cx;
			sizeExtCandListBdr.cx = sizeCandListArea.cx;
			sizeOptionsListObj.cx = sizeCandListArea.cx;
			sizeOptionsListBdr.cx = sizeCandListArea.cx;
			sizeCandListObj.cx    = sizeCandListArea.cx;
			sizeRawDataObj.cx     = sizeCandListArea.cx;
			sizeRawDataBdr.cx     = sizeCandListArea.cx;
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT:
		case CANDUIDIR_LEFTTORIGHT: {
			sizeExtCandListObj.cy = sizeCandListArea.cy;
			sizeExtCandListBdr.cy = sizeCandListArea.cy;
			sizeOptionsListObj.cy = sizeCandListArea.cy;
			sizeOptionsListBdr.cy = sizeCandListArea.cy;
			sizeCandListObj.cy    = sizeCandListArea.cy;
			sizeRawDataObj.cy     = sizeCandListArea.cy;
			sizeRawDataBdr.cy     = sizeCandListArea.cy;
			break;
		}
	}


	//
	// calculate window size, client area
	//

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: 
		case CANDUIDIR_BOTTOMTOTOP: {
			// window size

			sizeWindow.cx = sizeMetWndFrame.cx * 2 + cxMax;
			sizeWindow.cy = sizeMetWndFrame.cy * 2 + sizeCaptionObj.cy + sizeCandListArea.cy + sizeExtensionArea.cy;

			// margin at top and bottom

			sizeWindow.cy += 2;

			// client area

			rcClient.left   = sizeMetWndFrame.cx;
			rcClient.top    = sizeMetWndFrame.cy + 1;
			rcClient.right  = sizeWindow.cx - sizeMetWndFrame.cx;
			rcClient.bottom = sizeWindow.cy - sizeMetWndFrame.cy - 1;
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT:
		case CANDUIDIR_LEFTTORIGHT: {
			// window size

			sizeWindow.cx = sizeMetWndFrame.cx * 2 + cxMax;
			sizeWindow.cy = sizeMetWndFrame.cy * 2 + sizeCaptionObj.cy + sizeCandListArea.cy + sizeExtensionArea.cy;

			// margin at top and bottom

			sizeWindow.cx += 2;

			// client area

			rcClient.left   = sizeMetWndFrame.cx + 1;
			rcClient.top    = sizeMetWndFrame.cy;
			rcClient.right  = sizeWindow.cx - sizeMetWndFrame.cx + 1;
			rcClient.bottom = sizeWindow.cy - sizeMetWndFrame.cy;
			break;
		}
	}


	//
	// calculate area/object rects
	//

	// caption

	rcCaptionObj.left   = rcClient.left;
	rcCaptionObj.top    = rcClient.top;
	rcCaptionObj.right  = rcCaptionObj.left + sizeCaptionObj.cx;
	rcCaptionObj.bottom = rcCaptionObj.top  + sizeCaptionObj.cy;

	// candidate list area

	rcCandListArea.left   = rcClient.left;
	rcCandListArea.top    = rcCaptionObj.bottom;
	rcCandListArea.right  = rcCandListArea.left + sizeCandListArea.cx;
	rcCandListArea.bottom = rcCandListArea.top  + sizeCandListArea.cy;

	// extension area

	rcExtensionArea.left   = rcClient.left;
	rcExtensionArea.top    = rcCandListArea.bottom;
	rcExtensionArea.right  = rcExtensionArea.left + sizeExtensionArea.cx;
	rcExtensionArea.bottom = rcExtensionArea.top  + sizeExtensionArea.cy;


	//
	// calculate object rects in candidate list area
	//

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: {
			int py = rcCandListArea.top;

			// extra candidate list

			rcExtCandListObj.left   = rcCandListArea.left;
			rcExtCandListObj.top    = py;
			rcExtCandListObj.right  = rcExtCandListObj.left + sizeExtCandListObj.cx;
			rcExtCandListObj.bottom = rcExtCandListObj.top  + sizeExtCandListObj.cy;
			py = rcExtCandListObj.bottom;

			rcExtCandListBdr.left   = rcCandListArea.left;
			rcExtCandListBdr.top    = py;
			rcExtCandListBdr.right  = rcExtCandListBdr.left + sizeExtCandListBdr.cx;
			rcExtCandListBdr.bottom = rcExtCandListBdr.top  + sizeExtCandListBdr.cy;
			py = rcExtCandListBdr.bottom;

			// candidate list

			rcCandListObj.left   = rcCandListArea.left;
			rcCandListObj.top    = py;
			rcCandListObj.right  = rcCandListObj.left + sizeCandListObj.cx;
			rcCandListObj.bottom = rcCandListObj.top  + sizeCandListObj.cy;
			py = rcCandListObj.bottom;

			// rawdata

			rcRawDataBdr.left   = rcCandListArea.left;
			rcRawDataBdr.top    = py;
			rcRawDataBdr.right  = rcRawDataBdr.left + sizeRawDataBdr.cx;
			rcRawDataBdr.bottom = rcRawDataBdr.top  + sizeRawDataBdr.cy;
			py = rcRawDataBdr.bottom;

			rcRawDataObj.left   = rcCandListArea.left;
			rcRawDataObj.top    = py;
			rcRawDataObj.right  = rcRawDataObj.left + sizeRawDataObj.cx;
			rcRawDataObj.bottom = rcRawDataObj.top  + sizeRawDataObj.cy;
			py = rcRawDataObj.bottom;

			// options candidate list

			rcOptionsListBdr.left   = rcCandListArea.left;
			rcOptionsListBdr.top    = py;
			rcOptionsListBdr.right  = rcOptionsListBdr.left + sizeOptionsListBdr.cx;
			rcOptionsListBdr.bottom = rcOptionsListBdr.top  + sizeOptionsListBdr.cy;
			py = rcOptionsListBdr.bottom;

			rcOptionsListObj.left   = rcCandListArea.left;
			rcOptionsListObj.top    = py;
			rcOptionsListObj.right  = rcOptionsListObj.left + sizeOptionsListObj.cx;
			rcOptionsListObj.bottom = rcOptionsListObj.top  + sizeOptionsListObj.cy;
			py = rcOptionsListObj.bottom;

			break;
		}

		case CANDUIDIR_BOTTOMTOTOP: {
			int py = rcCandListArea.top;

			// options candidate list

			rcOptionsListObj.left   = rcCandListArea.left;
			rcOptionsListObj.top    = py;
			rcOptionsListObj.right  = rcOptionsListObj.left + sizeOptionsListObj.cx;
			rcOptionsListObj.bottom = rcOptionsListObj.top  + sizeOptionsListObj.cy;
			py = rcOptionsListObj.bottom;

			rcOptionsListBdr.left   = rcCandListArea.left;
			rcOptionsListBdr.top    = py;
			rcOptionsListBdr.right  = rcOptionsListBdr.left + sizeOptionsListBdr.cx;
			rcOptionsListBdr.bottom = rcOptionsListBdr.top  + sizeOptionsListBdr.cy;
			py = rcOptionsListBdr.bottom;

			// rawdata

			rcRawDataObj.left   = rcCandListArea.left;
			rcRawDataObj.top    = py;
			rcRawDataObj.right  = rcRawDataObj.left + sizeRawDataObj.cx;
			rcRawDataObj.bottom = rcRawDataObj.top  + sizeRawDataObj.cy;
			py = rcRawDataObj.bottom;

			rcRawDataBdr.left   = rcCandListArea.left;
			rcRawDataBdr.top    = py;
			rcRawDataBdr.right  = rcRawDataBdr.left + sizeRawDataBdr.cx;
			rcRawDataBdr.bottom = rcRawDataBdr.top  + sizeRawDataBdr.cy;
			py = rcRawDataBdr.bottom;

			// candidate list

			rcCandListObj.left   = rcCandListArea.left;
			rcCandListObj.top    = py;
			rcCandListObj.right  = rcCandListObj.left + sizeCandListObj.cx;
			rcCandListObj.bottom = rcCandListObj.top  + sizeCandListObj.cy;
			py = rcCandListObj.bottom;

			// extra candidate list

			rcExtCandListBdr.left   = rcCandListArea.left;
			rcExtCandListBdr.top    = py;
			rcExtCandListBdr.right  = rcExtCandListBdr.left + sizeExtCandListBdr.cx;
			rcExtCandListBdr.bottom = rcExtCandListBdr.top  + sizeExtCandListBdr.cy;
			py = rcExtCandListBdr.bottom;

			rcExtCandListObj.left   = rcCandListArea.left;
			rcExtCandListObj.top    = py;
			rcExtCandListObj.right  = rcExtCandListObj.left + sizeExtCandListObj.cx;
			rcExtCandListObj.bottom = rcExtCandListObj.top  + sizeExtCandListObj.cy;
			py = rcExtCandListObj.bottom;

			break;
		}

		case CANDUIDIR_RIGHTTOLEFT: {
			int px = rcCandListArea.right;

			// extra candidate list

			rcExtCandListObj.left   = px - sizeExtCandListObj.cx;
			rcExtCandListObj.top    = rcCandListArea.top;
			rcExtCandListObj.right  = rcExtCandListObj.left + sizeExtCandListObj.cx;
			rcExtCandListObj.bottom = rcExtCandListObj.top  + sizeExtCandListObj.cy;
			px = rcExtCandListObj.left;

			rcExtCandListBdr.left   = px - sizeExtCandListBdr.cx;
			rcExtCandListBdr.top    = rcCandListArea.top;
			rcExtCandListBdr.right  = rcExtCandListBdr.left + sizeExtCandListBdr.cx;
			rcExtCandListBdr.bottom = rcExtCandListBdr.top  + sizeExtCandListBdr.cy;
			px = rcExtCandListBdr.left;

			// candidate list

			rcCandListObj.left   = px - sizeCandListObj.cx;
			rcCandListObj.top    = rcCandListArea.top;
			rcCandListObj.right  = rcCandListObj.left + sizeCandListObj.cx;
			rcCandListObj.bottom = rcCandListObj.top  + sizeCandListObj.cy;
			px = rcCandListObj.left;

			// rawdata

			rcRawDataBdr.left   = px - sizeRawDataBdr.cx;
			rcRawDataBdr.top    = rcCandListArea.top;
			rcRawDataBdr.right  = rcRawDataBdr.left + sizeRawDataBdr.cx;
			rcRawDataBdr.bottom = rcRawDataBdr.top  + sizeRawDataBdr.cy;
			px = rcRawDataBdr.left;

			rcRawDataObj.left   = px - sizeRawDataObj.cx;
			rcRawDataObj.top    = rcCandListArea.top;
			rcRawDataObj.right  = rcRawDataObj.left + sizeRawDataObj.cx;
			rcRawDataObj.bottom = rcRawDataObj.top  + sizeRawDataObj.cy;
			px = rcRawDataObj.left;

			// options candidate list

			rcOptionsListBdr.left   = px - sizeOptionsListBdr.cx;
			rcOptionsListBdr.top    = rcCandListArea.top;
			rcOptionsListBdr.right  = rcOptionsListBdr.left + sizeOptionsListBdr.cx;
			rcOptionsListBdr.bottom = rcOptionsListBdr.top  + sizeOptionsListBdr.cy;
			px = rcOptionsListBdr.left;

			rcOptionsListObj.left   = px - sizeOptionsListObj.cx;
			rcOptionsListObj.top    = rcCandListArea.top;
			rcOptionsListObj.right  = rcOptionsListObj.left + sizeOptionsListObj.cx;
			rcOptionsListObj.bottom = rcOptionsListObj.top  + sizeOptionsListObj.cy;
			px = rcOptionsListObj.left;

			break;
		}

		case CANDUIDIR_LEFTTORIGHT: {
			int px = rcCandListArea.left;

			// extra candidate list

			rcExtCandListObj.left   = px;
			rcExtCandListObj.top    = rcCandListArea.top;
			rcExtCandListObj.right  = rcExtCandListObj.left + sizeExtCandListObj.cx;
			rcExtCandListObj.bottom = rcExtCandListObj.top  + sizeExtCandListObj.cy;
			px = rcExtCandListObj.right;

			rcExtCandListBdr.left   = px;
			rcExtCandListBdr.top    = rcCandListArea.top;
			rcExtCandListBdr.right  = rcExtCandListBdr.left + sizeExtCandListBdr.cx;
			rcExtCandListBdr.bottom = rcExtCandListBdr.top  + sizeExtCandListBdr.cy;
			px = rcExtCandListBdr.right;

			// candidate list

			rcCandListObj.left   = px;
			rcCandListObj.top    = rcCandListArea.top;
			rcCandListObj.right  = rcCandListObj.left + sizeCandListObj.cx;
			rcCandListObj.bottom = rcCandListObj.top  + sizeCandListObj.cy;
			px = rcCandListObj.right;

			// rawdata

			rcRawDataBdr.left   = px;
			rcRawDataBdr.top    = rcCandListArea.top;
			rcRawDataBdr.right  = rcRawDataBdr.left + sizeRawDataBdr.cx;
			rcRawDataBdr.bottom = rcRawDataBdr.top  + sizeRawDataBdr.cy;
			px = rcRawDataBdr.right;

			rcRawDataObj.left   = px;
			rcRawDataObj.top    = rcCandListArea.top;
			rcRawDataObj.right  = rcRawDataObj.left + sizeRawDataObj.cx;
			rcRawDataObj.bottom = rcRawDataObj.top  + sizeRawDataObj.cy;
			px = rcRawDataObj.right;

			// options candidate list

			rcOptionsListBdr.left   = px;
			rcOptionsListBdr.top    = rcCandListArea.top;
			rcOptionsListBdr.right  = rcOptionsListBdr.left + sizeOptionsListBdr.cx;
			rcOptionsListBdr.bottom = rcOptionsListBdr.top  + sizeOptionsListBdr.cy;
			px = rcOptionsListBdr.right;

			rcOptionsListObj.left   = px;
			rcOptionsListObj.top    = rcCandListArea.top;
			rcOptionsListObj.right  = rcOptionsListObj.left + sizeOptionsListObj.cx;
			rcOptionsListObj.bottom = rcOptionsListObj.top  + sizeOptionsListObj.cy;
			px = rcOptionsListObj.right;

			break;
		}
	}


	//
	// change window position and size
	//

	// window position

	SIZE sizeTotal = sizeWindow;
	if (IsShadowEnabled() && m_pWndShadow) {
		SIZE sizeShadow;

		m_pWndShadow->GetShift( &sizeShadow );
		sizeTotal.cx += sizeShadow.cx;
		sizeTotal.cy += sizeShadow.cy;
	}

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: {
			CalcWindowRect( &rcWindow, &m_rcTarget, sizeTotal.cx, sizeTotal.cy, m_cxWndOffset, m_cyWndOffset, ALIGN_LEFT, LOCATE_BELLOW );
			break;
		}

		case CANDUIDIR_BOTTOMTOTOP: {
			CalcWindowRect( &rcWindow, &m_rcTarget, sizeTotal.cx, sizeTotal.cy, m_cxWndOffset, m_cyWndOffset, ALIGN_RIGHT, LOCATE_ABOVE );
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT: {
			CalcWindowRect( &rcWindow, &m_rcTarget, sizeTotal.cx, sizeTotal.cy, m_cxWndOffset, m_cyWndOffset, LOCATE_LEFT, ALIGN_TOP );
			break;
		}

		case CANDUIDIR_LEFTTORIGHT: {
			CalcWindowRect( &rcWindow, &m_rcTarget, sizeTotal.cx, sizeTotal.cy, m_cxWndOffset, m_cyWndOffset, LOCATE_RIGHT, ALIGN_BOTTOM );
			break;
		}
	}

	// rcWindow now include the shadow size.  restore to original size
	rcWindow.right = rcWindow.left + sizeWindow.cx;
	rcWindow.bottom = rcWindow.top + sizeWindow.cy;

	Move( rcWindow.left, rcWindow.top, rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top );

	// layout window frame

	if (m_pWndFrame != NULL) {
		RECT rc;

		rc.left   = 0;
		rc.top    = 0;
		rc.right  = rcWindow.right - rcWindow.left;
		rc.bottom = rcWindow.bottom - rcWindow.top;
		m_pWndFrame->SetRect( &rc );
		m_pWndFrame->Show( TRUE );
	}


	//
	// misc
	//

	// list/border style

	switch (uidir) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: {
			dwListStyle = UILIST_HORZTB;
			dwBdrStyle = UIBORDER_HORZ;
			break;
		}

		case CANDUIDIR_BOTTOMTOTOP: {
			dwListStyle = UILIST_HORZBT;
			dwBdrStyle = UIBORDER_HORZ;
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT: {
			dwListStyle = UILIST_VERTRL;
			dwBdrStyle = UIBORDER_VERT;
			break;
		}

		case CANDUIDIR_LEFTTORIGHT: {
			dwListStyle = UILIST_VERTLR;
			dwBdrStyle = UIBORDER_VERT;
			break;
		}
	}

	//
	// layout objects
	//

	// caption

	if (m_pCaptionObj != NULL) {
		m_pCaptionObj->SetRect( &rcCaptionObj );
		m_pCaptionObj->Show( fShowCaption );
		m_pCaptionObj->SetText( GetPropertyMgr()->GetWindowCaptionProp()->GetText() );
	}

	// extra candidate list object

	if (m_pExtListUIObj != NULL) {
		m_pExtListUIObj->SetStyle( dwListStyle );
		m_pExtListUIObj->SetLineHeight( sizeMetCandItem.cy );
		m_pExtListUIObj->SetInlineCommentPos( cxInlineCommentPos );
		m_pExtListUIObj->SetRect( &rcExtCandListObj );
		m_pExtListUIObj->Show( fShowExtCandList );
	}

	// extra candidate list border

	pUIObj = FindUIObject( IDUIF_BORDEREXTRACAND );
	if (pUIObj != NULL) {
		pUIObj->SetStyle( dwBdrStyle );
		pUIObj->SetRect( &rcExtCandListBdr );
		pUIObj->Show( fShowExtCandList );
	}

	// candidate menu button

	if (m_pCandMenuBtn != NULL) {
		RECT rc;
		BOOL fExtraSpace = GetPropertyMgr()->GetMenuButtonProp()->IsVisible();

		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				rc.left   = rcCandListObj.right  - sizeMetSmButton.cx;
				rc.top    = rcCandListObj.bottom - sizeMetSmButton.cy;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraBottomSpace = (fExtraSpace ? sizeMetSmButton.cy : 0);
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				rc.left   = rcCandListObj.right  - sizeMetSmButton.cx;
				rc.top    = rcCandListObj.top;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraTopSpace = (fExtraSpace ? sizeMetSmButton.cy : 0);
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				rc.left   = rcCandListObj.left;
				rc.top    = rcCandListObj.bottom - sizeMetSmButton.cy;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraBottomSpace = (fExtraSpace ? sizeMetSmButton.cx : 0);
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				rc.left   = rcCandListObj.right  - sizeMetSmButton.cx;
				rc.top    = rcCandListObj.bottom - sizeMetSmButton.cy;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraTopSpace = (fExtraSpace ? sizeMetSmButton.cx : 0);
				break;
			}
		}

		m_pCandMenuBtn->SetRect( &rc );
		m_pCandMenuBtn->Show( GetPropertyMgr()->GetMenuButtonProp()->IsVisible() );
		m_pCandMenuBtn->Enable( GetPropertyMgr()->GetMenuButtonProp()->IsEnabled() );
		m_pCandMenuBtn->SetToolTip( GetPropertyMgr()->GetMenuButtonProp()->GetToolTipString() );
	}

	// layout candidate tip button

	if (m_pCandTipBtn != NULL) {
		RECT rc;
		BOOL fExtraSpace = FALSE;

		if (m_pExtListUIObj && m_pExtListUIObj->IsVisible()) {
			m_pExtListUIObj->GetRect( &rc );
		}
		else {
			rc = rcCandListObj;
			fExtraSpace = fShowCandTip;
		}

		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				rc.left   = rc.right - sizeMetSmButton.cx;
				rc.top    = rc.top;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraTopSpace = (fExtraSpace ? sizeMetSmButton.cy : 0);
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				rc.left   = rc.right - sizeMetSmButton.cx;
				rc.top    = rc.bottom - sizeMetSmButton.cy;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraBottomSpace = (fExtraSpace ? sizeMetSmButton.cy : 0);
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				rc.left   = rc.right  - sizeMetSmButton.cx;
				rc.top    = rc.bottom - sizeMetSmButton.cy;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraTopSpace = (fExtraSpace ? sizeMetSmButton.cy : 0);
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				rc.left   = rc.left;
				rc.top    = rc.bottom - sizeMetSmButton.cy;
				rc.right  = rc.left + sizeMetSmButton.cx;
				rc.bottom = rc.top  + sizeMetSmButton.cy;

				cxyExtraBottomSpace = (fExtraSpace ? sizeMetSmButton.cy : 0);
				break;
			}
		}

		m_pCandTipBtn->SetRect( &rc );
		m_pCandTipBtn->SetIcon( m_fCandTipWndOpen ? m_hIconCandTipOn : m_hIconCandTipOff );
		m_pCandTipBtn->Show( fShowCandTip );
		m_pCandTipBtn->Enable( TRUE );
//		m_pCandTipBtn->SetToolTip( GetPropertyMgr()->GetMenuButtonProp()->GetToolTipString() );
	}

	// candidate list

	if (m_pListUIObj != NULL) {
		m_pListUIObj->SetStyle( dwListStyle );
		m_pListUIObj->SetLineHeight( sizeMetCandItem.cy );
		m_pListUIObj->SetInlineCommentPos( cxInlineCommentPos );
		m_pListUIObj->SetRect( &rcCandListObj );

		m_pListUIObj->SetExtraTopSpace( cxyExtraTopSpace );
		m_pListUIObj->SetExtraBottomSpace( cxyExtraBottomSpace );
	}

	// rawdata object

	if (m_pCandRawData != NULL) {
		DWORD dwStyle;
		RECT  rc;

		rc = rcRawDataObj;
		switch (uidir) {
			default: 
			case CANDUIDIR_TOPTOBOTTOM: {
				dwStyle = UICANDRAWDATA_HORZTB;
				InflateRect( &rc, -1, 0 );
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				dwStyle = UICANDRAWDATA_HORZBT;
				InflateRect( &rc, -1, 0 );
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				dwStyle = UICANDRAWDATA_VERTRL;
				InflateRect( &rc, 0, -1 );
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				dwStyle = UICANDRAWDATA_VERTLR;
				InflateRect( &rc, 0, -1 );
				break;
			}
		}

		m_pCandRawData->SetStyle( dwStyle );
		m_pCandRawData->SetRect( &rc );
		m_pCandRawData->Show( m_fHasRawData );
	}

	// rawdata border

	pUIObj = FindUIObject( IDUIF_BORDERRAWDATA );
	if (pUIObj != NULL) {
		pUIObj->SetStyle( dwBdrStyle );
		pUIObj->SetRect( &rcRawDataBdr );
		pUIObj->Show( m_fHasRawData );
	}

	// options candidate list border

	pUIObj = FindUIObject( IDUIF_BORDEROPTIONSCAND );
	if (pUIObj != NULL) {
		pUIObj->SetStyle( dwBdrStyle );
		pUIObj->SetRect( &rcOptionsListBdr );
		pUIObj->Show( fShowOptionsCandList );
	}

	// options candidate list

	if (m_pOptionsListUIObj != NULL) {
		m_pOptionsListUIObj->SetStyle( dwListStyle | UILIST_ICONSNOTNUMBERS );
		m_pOptionsListUIObj->SetLineHeight( sizeMetCandItem.cy );
		m_pOptionsListUIObj->SetInlineCommentPos( cxInlineCommentPos );
		m_pOptionsListUIObj->SetRect( &rcOptionsListObj );

		m_pOptionsListUIObj->SetExtraTopSpace( cxyExtraTopSpace );
		m_pOptionsListUIObj->SetExtraBottomSpace( cxyExtraBottomSpace );
	}

	// extension area border

	pUIObj = FindUIObject( IDUIF_BORDERBOTTOM );
	if (pUIObj != NULL) {
		RECT rc;

		rc.left   = rcExtensionArea.left;
		rc.top    = rcExtensionArea.top;
		rc.right  = rcExtensionArea.right;
		rc.bottom = rc.top + sizeMetBorder.cy;

		pUIObj->SetRect( &rc );
		pUIObj->Show( fHasExtension );
	}

	// extension objects

	if (fHasExtension) {
		SIZE  size;
		LONG  nExtension;
		LONG  iExtension;
		POINT pt;
		RECT  rc;

		pt.x = rcExtensionArea.left + 1;
		pt.y = rcExtensionArea.top + sizeMetBorder.cy;

		nExtension = GetExtensionMgr()->GetExtensionNum();
		for (iExtension = 0; iExtension < nExtension; iExtension++) {
			CCandUIExtension *pExtension = GetExtensionMgr()->GetExtension( iExtension );
			CUIFObject       *pUIObjExt;

			pExtension->GetSize( &size );
			rc.left   = pt.x;
			rc.top    = pt.y;
			rc.right  = rc.left + size.cx;
			rc.bottom = rc.top  + size.cy;

			pUIObjExt = FindUIObject( IDUIF_EXTENDED + iExtension );
			if (pUIObjExt != NULL) {
				pUIObjExt->SetRect( &rc );
			}

			pt.x += size.cx;
		}
	}


#ifdef NEVER
	// layout candidate num buttons and border

	if (fShowNumber) {
		RECT rc;
		DWORD dwStyle;

		// buttons

		for (i = 0; i < NUM_CANDSTR_MAX; i++) {
			switch (uidir) {
				default:
				case CANDUIDIR_TOPTOBOTTOM:
				case CANDUIDIR_BOTTOMTOTOP: {		/* NOTE: KOJIW: unconfirmed */
					rc.left   = rcCandListArea.left;
					rc.top    = rcCandListArea.top + sizeMetCandNum.cy * i;
					rc.right  = rc.left + sizeMetCandNum.cx;
					rc.bottom = rc.top  + sizeMetCandNum.cy;
					break;
				}
	
				case CANDUIDIR_RIGHTTOLEFT:
				case CANDUIDIR_LEFTTORIGHT: {		/* NOTE: KOJIW: unconfirmed */
					rc.left   = rcCandListArea.right - sizeMetCandNum.cy * (i+1);
					rc.top    = rcCandListArea.top;
					rc.right  = rc.left + sizeMetCandNum.cx;
					rc.bottom = rc.top  + sizeMetCandNum.cy;
					break;
				}
			}

			pUIObj = FindUIObject( IDUIF_CANDNUMBUTTON + i );
			if (pUIObj != NULL) {
				pUIObj->Show( (i < m_nItemShow) );
				pUIObj->SetRect( &rc );
			}
		}

		// border

		switch (uidir) {
			default:
			case CANDUIDIR_TOPTOBOTTOM:
			case CANDUIDIR_BOTTOMTOTOP: {		/* NOTE: KOJIW: unconfirmed */
				rc.left   = rcCandListArea.left + sizeMetCandNum.cx + sizeMetMargin.cx;
				rc.top    = rcCandListArea.top;
				rc.right  = rc.left + sizeMetBorder.cx;
				rc.bottom = rcCandListArea.bottom;
	
				dwStyle = UIBORDER_VERT;
				break;
			}
	
			case CANDUIDIR_RIGHTTOLEFT:
			case CANDUIDIR_LEFTTORIGHT: {		/* NOTE: KOJIW: unconfirmed */
				rc.left   = rcCandListArea.left;
				rc.top    = rcCandListArea.top + sizeMetCandNum.cy + sizeMetMargin.cy;
				rc.right  = rcCandListArea.right;
				rc.bottom = rc.top + sizeMetBorder.cy;
	
				dwStyle = UIBORDER_HORZ;
				break;
			}
		}
	
		pUIObj = FindUIObject( IDUIF_BORDERLEFT );
		if (pUIObj != NULL) {
			pUIObj->Show( TRUE );
			pUIObj->SetStyle( dwStyle );
			pUIObj->SetRect( &rc );
		}
	}
	else {
		// buttons

		for (i = 0; i < NUM_CANDSTR_MAX; i++) {
			pUIObj = FindUIObject( IDUIF_CANDNUMBUTTON + i );
			if (pUIObj != NULL) {
				pUIObj->Show( FALSE );
			}
		}

		// border

		pUIObj = FindUIObject( IDUIF_BORDERLEFT );
		if (pUIObj != NULL) {
			pUIObj->Show( FALSE );
		}
	}
#endif

	//
	// Notify UI object update
	//

	NotifyUIObjectEvent( CANDUIOBJ_OPTIONSLISTBOX,  CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDLISTBOX,     CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDCAPTION,     CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_MENUBUTTON,      CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_EXTRACANDIDATE,  CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDRAWDATA,     CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDTIPBUTTON,   CANDUIOBJEV_UPDATED );

	//

	if (m_pCandTipWnd != NULL) {
		MoveCandTipWindow();
	}

	ReleaseDC( m_hWnd, hDC );
}


/*   S E L E C T  I T E M  N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SelectItemNext( void )
{
	int iCurSel = m_pListUIObj->GetSelection();
	int iVisTop = m_pListUIObj->GetTop();
	int iVisBtm = m_pListUIObj->GetBottom();
	int iSelMax = m_pListUIObj->GetCount() - 1;

	int iSelNew = iCurSel + 1;
	if (iSelMax < iSelNew) {
		ScrollToTop();
		iSelNew = 0;
	}
	else if (iVisBtm < iSelNew) {
		ScrollPageNext();
	}

	SelectItemProc( iSelNew );
}


/*   S E L E C T  I T E M  P R E V   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SelectItemPrev( void )
{
	int iCurSel = m_pListUIObj->GetSelection();
	int iVisTop = m_pListUIObj->GetTop();
	int iVisBtm = m_pListUIObj->GetBottom();
	int iSelMax = m_pListUIObj->GetItemCount() - 1;

	int iSelNew = iCurSel - 1;
	if (iSelNew < 0) {
		ScrollToEnd();
		iSelNew = iSelMax;
	}
	else if (iSelNew < iVisTop) {
		ScrollPagePrev();
	}

	SelectItemProc( iSelNew );
}


/*   S E L E C T  P A G E  N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SelectPageNext( void )
{
	int iCurSel = m_pListUIObj->GetSelection();
	int iVisTop = m_pListUIObj->GetTop();
	int iVisBtm = m_pListUIObj->GetBottom();
	int iSelMax = m_pListUIObj->GetItemCount() - 1;
	int iItemPage = m_pListUIObj->GetVisibleCount();

	if (iCurSel == iSelMax) {
		SelectItemTop();
	}
	else {
		int iSelNew;
		if (iCurSel == iVisBtm) {
			iSelNew = min( iCurSel + iItemPage, iSelMax );
		}
		else {
			iSelNew = iVisBtm;
		}
		SelectItemProc( iSelNew );
	}
}


/*   S E L E C T  P A G E  P R E V   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SelectPagePrev( void )
{
	int iCurSel = m_pListUIObj->GetSelection();
	int iVisTop = m_pListUIObj->GetTop();
	int iVisBtm = m_pListUIObj->GetBottom();
	int iSelMax = m_pListUIObj->GetItemCount() - 1;
	int iItemPage = m_pListUIObj->GetVisibleCount();

	if (iCurSel == 0) {
		SelectItemEnd();
	}
	else {
		int iSelNew;
		if (iCurSel == iVisTop) {
			iSelNew = max( 0, iCurSel - iItemPage );
		}
		else {
			iSelNew = iVisTop;
		}
		SelectItemProc( iSelNew );
	}
}


/*   M A P  C O M M A N D   */
/*------------------------------------------------------------------------------

	Map directional command to undirectional command
	(CUIFWindowBase method)

------------------------------------------------------------------------------*/
CANDUICOMMAND CCandWindow::MapCommand( CANDUICOMMAND cmd )
{
	CANDUIUIDIRECTION uidir = GetPropertyMgr()->GetCandWindowProp()->GetUIDirection();

	switch (cmd) {
		case CANDUICMD_MOVESELUP: {
			switch (uidir) {
				default:
				case CANDUIDIR_TOPTOBOTTOM: {
					cmd = CANDUICMD_MOVESELPREV;
					break;
				}

				case CANDUIDIR_BOTTOMTOTOP: {
					cmd = CANDUICMD_MOVESELNEXT;
					break;
				}

				case CANDUIDIR_RIGHTTOLEFT:
				case CANDUIDIR_LEFTTORIGHT: {
					cmd = CANDUICMD_NONE;
					break;
				}
			}
			break;
		}

		case CANDUICMD_MOVESELDOWN: {
			switch (uidir) {
				default:
				case CANDUIDIR_TOPTOBOTTOM: {
					cmd = CANDUICMD_MOVESELNEXT;
					break;
				}

				case CANDUIDIR_BOTTOMTOTOP: {
					cmd = CANDUICMD_MOVESELPREV;
					break;
				}

				case CANDUIDIR_RIGHTTOLEFT:
				case CANDUIDIR_LEFTTORIGHT: {
					cmd = CANDUICMD_NONE;
					break;
				}
			}
			break;
		}

		case CANDUICMD_MOVESELLEFT: {
			switch (uidir) {
				default:
				case CANDUIDIR_TOPTOBOTTOM:
				case CANDUIDIR_BOTTOMTOTOP: {
					cmd = CANDUICMD_NONE;
					break;
				}

				case CANDUIDIR_RIGHTTOLEFT: {
					cmd = CANDUICMD_MOVESELNEXT;
					break;
				}
				case CANDUIDIR_LEFTTORIGHT: {
					cmd = CANDUICMD_MOVESELPREV;
					break;
				}
			}
			break;
		}

		case CANDUICMD_MOVESELRIGHT: {
			switch (uidir) {
				default:
				case CANDUIDIR_TOPTOBOTTOM:
				case CANDUIDIR_BOTTOMTOTOP: {
					cmd = CANDUICMD_NONE;
					break;
				}

				case CANDUIDIR_RIGHTTOLEFT: {
					cmd = CANDUICMD_MOVESELPREV;
					break;
				}
				case CANDUIDIR_LEFTTORIGHT: {
					cmd = CANDUICMD_MOVESELNEXT;
					break;
				}
			}
			break;
		}
	}

	return cmd;
}


/*   U P D A T E  A L L  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::UpdateAllWindow( void )
{
	CCandWindowBase::UpdateAllWindow();

	if (m_pCommentWnd != NULL) {
		m_pCommentWnd->UpdateWindow();
	}
}


/*   G E T  C A N D  W I N D O W  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CCandWindowBase *CCandWindow::GetCandWindowObj( void )
{
	return this;
}


/*   G E T  P O P U P  C O M M E N T  W I N D O W  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CPopupCommentWindow *CCandWindow::GetPopupCommentWindowObj( void )
{
	return m_pCommentWnd;
}


/*   G E T  O P T I O N S  L I S T  B O X  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandListBase *CCandWindow::GetOptionsListBoxObj( void )
{
	return m_pOptionsListUIObj;
}


/*   G E T  C A N D  L I S T  B O X  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandListBase *CCandWindow::GetCandListBoxObj( void )
{
	return m_pListUIObj;
}


/*   G E T  C A P T I O N  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFWndCaption *CCandWindow::GetCaptionObj( void )
{
	return m_pCaptionObj;
}


/*   G E T  M E N U  B U T T O N  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFButton *CCandWindow::GetMenuButtonObj( void )
{
	return m_pCandMenuBtn;
}


/*   G E T  E X T R A  C A N D I D A T E  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandListBase *CCandWindow::GetExtraCandidateObj( void )
{
	return m_pExtListUIObj;
}


/*   G E T  C A N D  R A W  D A T A  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandRawData *CCandWindow::GetCandRawDataObj( void )
{
	return m_pCandRawData;
}


/*   G E T  C A N D  T I P  W I N D O W  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFBalloonWindow *CCandWindow::GetCandTipWindowObj( void )
{
	return m_pCandTipWnd;
}


/*   G E T  C A N D  T I P  B U T T O N  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFButton *CCandWindow::GetCandTipButtonObj( void )
{
	return m_pCandTipBtn;
}


/*   S C R O L L  P A G E  N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::ScrollPageNext( void )
{
	int iCurSel = m_pListUIObj->GetSelection();
	int iVisTop = m_pListUIObj->GetTop();
	int iVisBtm = m_pListUIObj->GetBottom();
	int iSelMax = m_pListUIObj->GetItemCount() - 1;
	int iItemPage = m_pListUIObj->GetVisibleCount();

	int iTopNew = iVisTop + iItemPage;
	if (iSelMax - iItemPage < iTopNew) {
		ScrollToEnd();
	}
	else {
		m_pListUIObj->SetTop( iTopNew, TRUE );
	}
}


/*   S C R O L L  P A G E  P R E V   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::ScrollPagePrev( void )
{
	int iCurSel = m_pListUIObj->GetSelection();
	int iVisTop = m_pListUIObj->GetTop();
	int iVisBtm = m_pListUIObj->GetBottom();
	int iSelMax = m_pListUIObj->GetItemCount() - 1;
	int iItemPage = m_pListUIObj->GetVisibleCount();

	int iTopNew = iVisTop - iItemPage;
	if (iTopNew < 0) {
		ScrollToTop();
	}
	else {
		m_pListUIObj->SetTop( iTopNew, TRUE );
	}
}


/*   S C R O L L  T O  T O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::ScrollToTop( void )
{
	m_pListUIObj->SetTop( 0, TRUE );
}


/*   S C R O L L  T O  E N D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::ScrollToEnd( void )
{
	int iSelMax = m_pListUIObj->GetItemCount() - 1;
	int iItemPage = m_pListUIObj->GetVisibleCount();

	m_pListUIObj->SetTop( iSelMax - iItemPage + 1, TRUE );
}


/*   O N  C O M M E N T  W I N D O W  M O V E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OnCommentWindowMoved( void )
{
	NotifyUIObjectEvent( CANDUIOBJ_POPUPCOMMENTWINDOW, CANDUIOBJEV_UPDATED );
}


/*   O N  C O M M E N T  S E L E C T E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OnCommentSelected( int iCandItem )
{
	m_pCandUI->NotifyCompleteCand( iCandItem );
}


/*   O N  C O M M E N T  C L O S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OnCommentClose( void )
{
	CloseCommentWindow();
}


/*   O N  M E N U  O P E N E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OnMenuOpened( void )
{
	if (m_pCommentWnd != NULL) {
		m_pCommentWnd->OnCandWindowMove( FALSE );
	}
}


/*   O N  M E N U  C L O S E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OnMenuClosed( void )
{
	if (m_pCommentWnd != NULL) {
		m_pCommentWnd->OnCandWindowMove( FALSE );
	}
}


/*   S E T  C A N D I D A T E  L I S T  P R O C   */
/*------------------------------------------------------------------------------

	Set candidate list

------------------------------------------------------------------------------*/
void CCandWindow::SetCandidateListProc( void )
{
	CCandidateList *pCandList;
	CCandidateItem *pCandItem;

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	// reset list item

	if (m_pExtListUIObj) {
		m_pExtListUIObj->DelAllCandItem();

		pCandItem = pCandList->GetExtraCandItem();
		if (pCandItem != NULL) {
			if (pCandItem->IsVisible()) {
				CCandListItem *pCandListItem = new CCandListItem( m_pExtListUIObj->GetItemCount(), ICANDITEM_EXTRA, pCandItem );
				m_pExtListUIObj->AddCandItem( pCandListItem );
			}

			m_pExtListUIObj->ClearSelection( FALSE );
			m_pExtListUIObj->SetStartIndex( 0 );
		}
	}

	CCandWindowBase::SetCandidateListProc();
}


/*   C L E A R  C A N D I D A T E  L I S T  P R O C   */
/*------------------------------------------------------------------------------

	Clear candidte list

------------------------------------------------------------------------------*/
void CCandWindow::ClearCandidateListProc( void )
{
	if (m_pExtListUIObj) {
		m_pExtListUIObj->DelAllCandItem();
	}
	CCandWindowBase::ClearCandidateListProc();
}


/*   S E T  A T T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SetAttensionBySelect( int iItem )
{
	CCandidateList *pCandList;
	CCandidateItem *pCandItem;
	BOOL           fHasPopupComment;

	// Satori#3928
	// do nothing when candidate list is already cleared

	if (GetCandListMgr()->GetCandList() == NULL) {
		m_iItemAttensionSelect = -1;
		m_iItemAttensionHover  = -1;
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_SELECT );
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );
		return;
	}

	m_iItemAttensionSelect = iItem;

	// check if item has popup comment

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	pCandItem = pCandList->GetCandidateItem( m_iItemAttensionSelect );
	fHasPopupComment = (pCandItem != NULL && pCandItem->GetPopupComment() != NULL);

	//

	if (m_fCommentWndOpen) {
		if (fHasPopupComment) {
			// update comment window contents

			SetCommentStatus( iItem );
		}
		else {
			// close comment window

			CloseCommentWindow();
		}
	}
	else {
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_SELECT );
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );

		// make timer to wait to open comment

		if (fHasPopupComment) {
			if (IsWindow(m_hWnd)) {
				SetTimer( m_hWnd, IDTIMER_POPUPCOMMENT_SELECT, GetPropertyMgr()->GetPopupCommentWindowProp()->GetDelayTime(), NULL );
			}
		}
	}
}


/*   S E T  A T T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SetOptionsAttensionByHover( int iItem )
{
	CCandidateList *pCandList;
	CCandidateItem *pCandItem;
	BOOL           fHasPopupComment;

	// Satori#3928
	// do nothing when candidate list is already cleared

	if (GetCandListMgr()->GetOptionsList() == NULL) {
		m_iItemAttensionSelect = -1;
		m_iItemAttensionHover  = -1;
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_SELECT );
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );
		return;
	}

	m_iItemAttensionHover = iItem;

	// check if item has popup comment

	pCandList = GetCandListMgr()->GetOptionsList();
	Assert( pCandList != NULL );

	pCandItem = pCandList->GetCandidateItem( m_iItemAttensionHover );
	fHasPopupComment = (pCandItem != NULL && pCandItem->GetPopupComment() != NULL);

	//

	if (m_fCommentWndOpen) {
		if (fHasPopupComment) {
			// update comment window contents

			SetCommentStatus( iItem );
		}
	}
	else {
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );

		// make timer to wait to open comment

		if (fHasPopupComment) {
			if (IsWindow(m_hWnd)) {
				SetTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER, GetPropertyMgr()->GetPopupCommentWindowProp()->GetDelayTime(), NULL );
			}
		}
	}

	if (iItem != -1)
	{
		SetTimer(m_hWnd, IDTIMER_MENU_HOVER, 50, NULL);
	}
	else
	{
		KillTimer( m_hWnd, IDTIMER_MENU_HOVER);
	}

	GetUIOptionsListObj()->SetCurSel(iItem);
}


/*   S E T  A T T E N S I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SetAttensionByHover( int iItem )
{
	CCandidateList *pCandList;
	CCandidateItem *pCandItem;
	BOOL           fHasPopupComment;

	// Satori#3928
	// do nothing when candidate list is already cleared

	if (GetCandListMgr()->GetCandList() == NULL) {
		m_iItemAttensionSelect = -1;
		m_iItemAttensionHover  = -1;
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_SELECT );
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );
		return;
	}

	m_iItemAttensionHover = iItem;

	// check if item has popup comment

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	pCandItem = pCandList->GetCandidateItem( m_iItemAttensionHover );
	fHasPopupComment = (pCandItem != NULL && pCandItem->GetPopupComment() != NULL);

	//

	if (m_fCommentWndOpen) {
		if (fHasPopupComment) {
			// update comment window contents

			SetCommentStatus( iItem );
		}
	}
	else {
		KillTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER );

		// make timer to wait to open comment

		if (fHasPopupComment) {
			if (IsWindow(m_hWnd)) {
				SetTimer( m_hWnd, IDTIMER_POPUPCOMMENT_HOVER, GetPropertyMgr()->GetPopupCommentWindowProp()->GetDelayTime(), NULL );
			}
		}
	}
}


/*   O P E N  C O M M E N T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OpenCommentWindow( int iItem )
{
	if (m_pCommentWnd->GetWnd() == NULL) {
		Assert( !m_fCommentWndOpen );

		// create comment window

		m_pCommentWnd->CreateWnd( m_hWnd );
		m_pCommentWnd->Move( 0, 0, CX_COMMENTWINDOW, 0 );
		m_pCommentWnd->OnCandWindowMove( TRUE );

		NotifyUIObjectEvent( CANDUIOBJ_POPUPCOMMENTWINDOW, CANDUIOBJEV_CREATED );
	}

	SetCommentStatus( iItem );

	if (!m_fCommentWndOpen) {
		m_pCommentWnd->Show( TRUE );
		m_fCommentWndOpen = TRUE;
	}
}


/*   C L O S E  C O M M E N T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::CloseCommentWindow( void )
{
	if (m_fCommentWndOpen) {
		Assert( m_pCommentWnd->GetWnd() != NULL );

		m_pCommentWnd->Show( FALSE );
		ClearCommentStatus();
	}

	m_fCommentWndOpen = FALSE;

	if (m_pCommentWnd->GetWnd() != NULL) {
		m_pCommentWnd->DestroyWnd();

		NotifyUIObjectEvent( CANDUIOBJ_POPUPCOMMENTWINDOW, CANDUIOBJEV_DESTROYED );
	}
}


/*   S E T  C O M M E N T  S T A T U S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::SetCommentStatus( int iItem )
{
	CCandidateList *pCandList;
	CCandidateItem *pCandItem;
	int i;
	int nItem;
	DWORD dwGroupID = 0;

	// get comment group id

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	pCandItem = pCandList->GetCandidateItem( iItem );
	if (pCandItem == NULL) {
		Assert( FALSE );
		ClearCommentStatus();
	}
	else {
		dwGroupID = pCandItem->GetPopupCommentGroupID();
	}

	// show popup comment in same group

	nItem = pCandList->GetItemCount();
	for (i = 0; i < nItem; i++) {
		pCandItem = pCandList->GetCandidateItem( i );

		if (pCandItem != NULL) {
			BOOL fMatch = ((pCandItem->GetPopupCommentGroupID() & dwGroupID) != 0);

			pCandItem->SetPopupCommentState( fMatch );
		}
	}

	// repaint list box and notify

	if (m_pListUIObj != NULL) {
		m_pListUIObj->CallOnPaint();
		UpdateWindow();
	}

	GetCandListMgr()->NotifyCandItemUpdate( this );
}


/*   C L E A R  C O M M E N T  S T A T U S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::ClearCommentStatus( void )
{
	CCandidateList *pCandList;
	CCandidateItem *pCandItem;
	int i;
	int nItem;

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	// hide all popup comment

	nItem = pCandList->GetItemCount();
	for (i = 0; i < nItem; i++) {
		pCandItem = pCandList->GetCandidateItem( i );

		if (pCandItem != NULL) {
			pCandItem->SetPopupCommentState( FALSE );
		}
	}

	// repaint list box and notify

	if (m_pListUIObj != NULL) {
		m_pListUIObj->CallOnPaint();
		UpdateWindow();
	}

	GetCandListMgr()->NotifyCandItemUpdate( this );
}


/*   O P E N  C A N D  T I P  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::OpenCandTipWindow( void )
{
	if (GetCandListMgr()->GetCandList() == NULL) {
		return;
	}

	if (m_pCandTipWnd->GetWnd() == NULL) {
		m_pCandTipWnd->CreateWnd( m_hWnd );

		NotifyUIObjectEvent( CANDUIOBJ_CANDTIPWINDOW, CANDUIOBJEV_CREATED );
	}

	m_pCandTipWnd->SetText( GetCandListMgr()->GetCandList()->GetTipString() );
	ShowCandTipWindow( TRUE );

	//

	if (m_pCommentWnd != NULL) {
		m_pCommentWnd->OnCandWindowMove( FALSE );
	}
}


/*   C L O S E  C A N D  T I P  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::CloseCandTipWindow( void )
{
	if (m_pCandTipWnd->GetWnd() != NULL) {
		DestroyWindow( m_pCandTipWnd->GetWnd() );

		NotifyUIObjectEvent( CANDUIOBJ_CANDTIPWINDOW, CANDUIOBJEV_DESTROYED );
	}

	//

	if (m_pCommentWnd != NULL) {
		m_pCommentWnd->OnCandWindowMove( FALSE );
	}
}


/*   M O V E  C A N D  T I P  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::MoveCandTipWindow( void )
{
	RECT rcWnd;
	RECT rcBtn;
	POINT pt;
	BALLOONWNDPOS pos;
	BALLOONWNDALIGN align;

	if (m_pCandTipWnd->GetWnd() == NULL) {
		return;
	}

	GetWindowRect( GetWnd(), &rcWnd );

	m_pCandTipBtn->GetRect( &rcBtn );
	pt.x = rcWnd.left + (rcBtn.left + rcBtn.right) / 2;
	pt.y = rcWnd.top  + (rcBtn.top + rcBtn.bottom) / 2;

	switch (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection()) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: {
			pos = BALLOONPOS_RIGHT;
			align = BALLOONALIGN_TOP;
			break;
		}

		case CANDUIDIR_BOTTOMTOTOP: {
			pos = BALLOONPOS_RIGHT;
			align = BALLOONALIGN_BOTTOM;
			break;
		}
	
		case CANDUIDIR_RIGHTTOLEFT: {
			pos = BALLOONPOS_BELLOW;
			align = BALLOONALIGN_RIGHT;
			break;
		}

		case CANDUIDIR_LEFTTORIGHT: {
			pos = BALLOONPOS_BELLOW;
			align = BALLOONALIGN_LEFT;
			break;
		}
	}

	m_pCandTipWnd->SetBalloonPos( pos );
	m_pCandTipWnd->SetBalloonAlign( align );

	m_pCandTipWnd->SetExcludeRect( &rcWnd );
	m_pCandTipWnd->SetTargetPos( pt );

	NotifyUIObjectEvent( CANDUIOBJ_CANDTIPWINDOW, CANDUIOBJEV_UPDATED );
}


/*   S H O W  C A N D  T I P  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandWindow::ShowCandTipWindow( BOOL fShow )
{
	if (m_pCandTipWnd->GetWnd() == NULL) {
		return;
	}

	if (fShow) {
		MoveCandTipWindow();
		m_pCandTipWnd->Show( TRUE );
	}
	else {
		m_pCandTipWnd->Show( FALSE );
	}
}


/*============================================================================*/
/*                                                                            */
/*   C  C H S  C A N D  W I N D O W                                           */
/*                                                                            */
/*============================================================================*/

/*   C  C H S  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

	Constructor of CChsCandWindow

------------------------------------------------------------------------------*/
CChsCandWindow::CChsCandWindow( CCandidateUI *pCandUIEx, DWORD dwStyle ) : CCandWindowBase( pCandUIEx, dwStyle | UIWINDOW_TOPMOST | UIWINDOW_TOOLWINDOW | UIWINDOW_OFC10MENU )
{
	m_pListUIObj = NULL;
}


/*   ~ C  C H S  C A N D  W I N D O W   */
/*------------------------------------------------------------------------------

	Destructor of CChsCandWindow

------------------------------------------------------------------------------*/
CChsCandWindow::~CChsCandWindow()
{
	//
	// Notify UI object destroy
	//

	NotifyUIObjectEvent( CANDUIOBJ_CANDLISTBOX,    CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_MENUBUTTON,     CANDUIOBJEV_DESTROYED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDRAWDATA,    CANDUIOBJEV_DESTROYED );
}


/*   I N I T  U I  O B J E C T S   */
/*------------------------------------------------------------------------------

	Create UI objects

------------------------------------------------------------------------------*/
CUIFObject *CChsCandWindow::Initialize( void )
{
	RECT rc = {0};
	CUIFBorder *pBorder;

	//
	// create border
	//

	pBorder = new CUIFBorder( this, IDUIF_BORDER, &rc, UIBORDER_VERT );
    if(pBorder)
    {
	    pBorder->Initialize();
	    AddUIObj( pBorder );
    }
 
	//
	// create candidate list
	//

	m_pListUIObj = new CUIFRowList( this, IDUIF_CANDIDATELIST, &rc, UILIST_HORZTB );
    if (m_pListUIObj)
    {
	    m_pListUIObj->Initialize();
	    AddUIObj( m_pListUIObj );
    }

	//
	// create candidate menu button
	//

	m_pCandMenuBtn = new CUIFSmartMenuButton( this, IDUIF_CANDIDATEMENU, &rc, UIBUTTON_TOGGLE );
    if (m_pCandMenuBtn)
    {
	    m_pCandMenuBtn->Initialize();
	    AddUIObj( m_pCandMenuBtn );

	    m_pCandMenuBtn->SetIcon( m_hIconMenu );
    }

	//
	// create raw data statics
	//

	m_pCandRawData = new CUIFCandRawData( this, IDUIF_RAWDATA, &rc, UICANDRAWDATA_HORZTB );
    if (m_pCandRawData)
    {
	    m_pCandRawData->Initialize();
	    AddUIObj( m_pCandRawData );
    }

	//
	// add extensions
	//

	CreateExtensionObjects();

	//
	// Notify UI object creation
	//

	NotifyUIObjectEvent( CANDUIOBJ_CANDLISTBOX,    CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_MENUBUTTON,     CANDUIOBJEV_CREATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDRAWDATA,    CANDUIOBJEV_CREATED );

	return CCandWindowBase::Initialize();
}


/*   L A Y O U T  W I N D O W   */
/*------------------------------------------------------------------------------

	Layout window

------------------------------------------------------------------------------*/
void CChsCandWindow::LayoutWindow( void )
{
	HDC   hDC = GetDC( m_hWnd );
	RECT  rc;
	DWORD dwStyle;
	CUIFObject *pUIObj;
	SIZE  size;
	LONG  nExtension;

	HFONT hFontUI            = GetPropertyMgr()->GetCandIndexProp()->GetFont();
	HFONT hFontCandidateList = GetPropertyMgr()->GetCandStringProp()->GetFont();
	BOOL  fHorizontal = ((GetPropertyMgr()->GetCandWindowProp()->GetUIDirection() == CANDUIDIR_RIGHTTOLEFT) || (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection() == CANDUIDIR_LEFTTORIGHT)) ? FALSE : TRUE;

	// calc metrics

	int cyText;
	int cxObjectMargin = 1;
	int cyObjectMargin = 1;
	int cxBorder       = 2;		// border width of vertical border
	int cyBorder       = 2;		// border height of horizontal border
	int cxCandRow;
	int cyCandRow;
	int cxMenuBtn;
	int cyMenuBtn;
	int cxStatus  = 0;
	int cyStatus  = 0;
	int cxWindow  = 0;
	int cyWindow  = 0;

	GetTextExtent( hFontCandidateList, L"1", 1, &size, fHorizontal );
	cyText = max(size.cx, size.cy);

	cxMenuBtn = cyText / 2;
	cyMenuBtn = cyText / 2;

	//
	// font settings
	//

	int nChild = m_ChildList.GetCount();
	for (int i = 0; i < nChild; i++) {
		CUIFObject *pUIObjTmp = m_ChildList.Get( i );

		Assert( pUIObjTmp != NULL );
		if (pUIObjTmp != m_pListUIObj)  {
			pUIObjTmp->SetFont( hFontUI );
		}
		else {
			m_pListUIObj->SetFont( hFontCandidateList );
			m_pListUIObj->SetInlineCommentFont( GetPropertyMgr()->GetInlineCommentProp()->GetFont() );
			m_pListUIObj->SetIndexFont( GetPropertyMgr()->GetCandIndexProp()->GetFont() );
		}
	}

	//
	// calculate the size of candidate row
	//

	if (fHorizontal)
		{
		cyCandRow = cyBorder + cyText;
		cxCandRow = ( cxBorder + cyText + cyText + HCAND_ITEM_MARGIN ) * NUM_CANDSTR_MAX + cyCandRow * 2;
		}
	else
		{
		cxCandRow = cxBorder + cyText;
		cyCandRow = ( cyBorder + cyText + cyText + HCAND_ITEM_MARGIN ) * NUM_CANDSTR_MAX + cxCandRow * 2;
		}

	// 
	// calculate the size of status area
	//

	// extension items

	nExtension = GetExtensionMgr()->GetExtensionNum();
	if (0 < nExtension) {
		LONG i;

		for (i = 0; i < nExtension; i++) {
			CCandUIExtension *pExtension = GetExtensionMgr()->GetExtension( i );

			pExtension->GetSize( &size );

			if (fHorizontal) {
				cxStatus += size.cx + cxBorder;
				cyStatus  = max( cyStatus, size.cy + cxBorder );
			}
			else {
				cxStatus  = max( cxStatus, size.cx + cxBorder );
				cyStatus += size.cy + cxBorder;
			}
		}

		if (fHorizontal) {
			cyStatus += cyObjectMargin + cyBorder + cyObjectMargin;
		}
		else {
			cxStatus += cxObjectMargin + cxBorder + cxObjectMargin;
		}
	}
	else if (m_fHasRawData) {
		if (fHorizontal) {
			cxStatus = cxCandRow;
			cyStatus = GetSystemMetrics( SM_CXHSCROLL ) + cyObjectMargin + cyBorder + cyObjectMargin;
		}
		else {
			cxStatus = GetSystemMetrics( SM_CXHSCROLL ) + cxObjectMargin + cxBorder + cxObjectMargin;
			cyStatus = cyCandRow;
		}
	}
	else {
	}

	//
	// calculate window size, considering margins/border size
	//

	if (fHorizontal) {
		cxWindow = max( cxBorder + cxMenuBtn + cxCandRow, cxStatus );
		cyWindow = cyCandRow + cyStatus;

		rc.left  = m_rcTarget.left;
		rc.top   = m_rcTarget.bottom;
	}
	else {
		cxWindow = cxCandRow + cxStatus;
		cyWindow = max( cxBorder + cyMenuBtn + cyCandRow, cyStatus );

		rc.left  = m_rcTarget.left - cxWindow;
		rc.top   = m_rcTarget.top;
	}
	
	//
	// change window position and size
	//

	rc.right  = rc.left + cxWindow + cxBorder;
	rc.bottom = rc.top  + cyWindow + cyBorder;
	Move( rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top );

	//
	// layout candidate menu button
	// (uses rc of window. do this after layouting window)
	//

	if (fHorizontal) {
		rc.left   = 0;
		rc.top    = 0;
		rc.right  = cxMenuBtn + cxBorder;
		rc.bottom = cyCandRow;
	}
	else {
		rc.right  = cxWindow;
		rc.top    = 0;
		rc.left   = rc.right - cxCandRow;
		rc.bottom = cyMenuBtn + cyBorder;
	}

	if (m_pCandMenuBtn != NULL) {
		m_pCandMenuBtn->SetRect( &rc );
		m_pCandMenuBtn->Show( TRUE );
		m_pCandMenuBtn->Enable( GetPropertyMgr()->GetMenuButtonProp()->IsEnabled() );
		m_pCandMenuBtn->SetToolTip( GetPropertyMgr()->GetMenuButtonProp()->GetToolTipString() );
	}

	//
	// layout candidate row
	// (uses rc of window. do this after layouting candidate menu button )

	if (fHorizontal) {
		rc.left   = rc.right;
		rc.right  = rc.left + cxCandRow;

		dwStyle   = UILIST_HORZTB;
	}
	else {
		rc.top    = rc.bottom;
		rc.bottom = rc.top + cyCandRow;

		dwStyle   = UILIST_VERTRL;
	}

	if (m_pListUIObj != NULL) {
		m_pListUIObj->SetRect( &rc );
		m_pListUIObj->SetStyle( dwStyle );
		m_pListUIObj->Show( TRUE );
	}

	//
	// layout extensions
	//

	pUIObj = FindUIObject( IDUIF_BORDER );
	if ((0 < nExtension) || m_fHasRawData) {
		//
		// layout border
		//

		if (fHorizontal) {
			rc.left   = 0;
			rc.top    = cyCandRow + cyObjectMargin;
			rc.right  = cxWindow;
			rc.bottom = rc.top + cyBorder;

			dwStyle = UIBORDER_HORZ;
		}
		else {
			rc.right  = cxStatus - cyObjectMargin;
			rc.left   = rc.right - cxBorder;
			rc.top    = 0;
			rc.bottom = cyWindow;

			dwStyle = UIBORDER_VERT;
		}

		if (pUIObj != NULL) {
			pUIObj->SetStyle( dwStyle );
			pUIObj->SetRect( &rc );
			pUIObj->Show( TRUE );
		}
	} else {
		if (pUIObj != NULL) {
			pUIObj->Show( FALSE );
		}
	}

	if (0 < nExtension) {
		LONG i;

		// layout rawdata object

		if (m_fHasRawData) {
			if (fHorizontal) {
				rc.left   = 0;
				rc.top    = cyCandRow + cyObjectMargin + cyBorder + cyObjectMargin;
				rc.right  = cxWindow - cxStatus;
				rc.bottom = cyWindow;
				
				dwStyle = UICANDRAWDATA_HORZTB;
			}
			else {
				rc.left   = 0;
				rc.top    = 0;
				rc.right  = cxStatus - cyObjectMargin - cyBorder - cyObjectMargin;
				rc.bottom = cyWindow - cyStatus;

				dwStyle = UICANDRAWDATA_VERTRL;
			}

			Assert(m_pCandRawData != NULL);
			m_pCandRawData->SetStyle( dwStyle );
			m_pCandRawData->SetRect( &rc );
			m_pCandRawData->Show( TRUE );
		} else {
			m_pCandRawData->Show( FALSE );
		}

		//
		// layout extension items
		//

		if (fHorizontal) {
			rc.left   = cxWindow - cxStatus;
			rc.top    = cyCandRow + cyObjectMargin + cyBorder + cyObjectMargin;
			rc.right  = rc.left;
			rc.bottom = cyWindow;
		}
		else {
			rc.left   = 0;
			rc.top    = cyWindow - cyStatus;
			rc.right  = cxStatus - cyObjectMargin - cyBorder - cyObjectMargin;
			rc.bottom = rc.top;
		}

		for (i = 0; i < nExtension; i++) {
			CCandUIExtension *pExtension = GetExtensionMgr()->GetExtension( i );
			CUIFObject *pUIObjExt = FindUIObject( IDUIF_EXTENDED + i );

			pExtension->GetSize( &size );
			if (fHorizontal) {
				rc.left   = rc.right;
				rc.top    = rc.top;
				rc.right  = rc.right + size.cx + cxBorder;
				rc.bottom = rc.top   + size.cy + cyBorder;
			}
			else {
				rc.left   = rc.left;
				rc.top    = rc.bottom;
				rc.right  = rc.left + size.cx + cxBorder;
				rc.bottom = rc.bottom + size.cy + cxBorder;
			}

			if (pUIObjExt != NULL) {
				pUIObjExt->SetRect( &rc );
			}
		}
	}
	else {
		// layout rawdata object

		if (m_fHasRawData) {
			if (fHorizontal) {
				rc.left   = 0;
				rc.top    = cyCandRow + cyObjectMargin + cyBorder + cyObjectMargin;
				rc.right  = cxWindow;
				rc.bottom = cyWindow;
				
				dwStyle = UICANDRAWDATA_HORZTB;
			}
			else {
				rc.left   = 0;
				rc.top    = 0;
				rc.right  = cxStatus - cyObjectMargin - cyBorder - cyObjectMargin;
				rc.bottom = cyWindow;

				dwStyle = UICANDRAWDATA_VERTRL;
			}

			Assert(m_pCandRawData != NULL);
			m_pCandRawData->SetStyle( dwStyle );
			m_pCandRawData->SetRect( &rc );
			m_pCandRawData->Show( TRUE );
		} else {
			m_pCandRawData->Show( FALSE );
		}
	}

	//
	// Notify UI object update
	//

	NotifyUIObjectEvent( CANDUIOBJ_CANDLISTBOX,    CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_MENUBUTTON,     CANDUIOBJEV_UPDATED );
	NotifyUIObjectEvent( CANDUIOBJ_CANDRAWDATA,    CANDUIOBJEV_UPDATED );

	ReleaseDC( m_hWnd, hDC );
}


/*   S E L E C T  I T E M  N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CChsCandWindow::SelectItemNext( void )
{
	((CUIFRowList*)m_pListUIObj)->ShiftItem( 1 );
}


/*   S E L E C T  I T E M  P R E V   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CChsCandWindow::SelectItemPrev( void )
{
	((CUIFRowList*)m_pListUIObj)->ShiftItem( -1 );
}


/*   S E L E C T  P A G E  N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CChsCandWindow::SelectPageNext( void )
{
	((CUIFRowList*)m_pListUIObj)->ShiftPage( 1 );
}


/*   S E L E C T  P A G E  P R E V   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CChsCandWindow::SelectPagePrev( void )
{
	((CUIFRowList*)m_pListUIObj)->ShiftPage( -1 );
}


/*   M A P  C O M M A N D   */
/*------------------------------------------------------------------------------

	Map directional command to undirectional command
	(CUIFWindowBase method)

------------------------------------------------------------------------------*/
CANDUICOMMAND CChsCandWindow::MapCommand( CANDUICOMMAND cmd )
{
	BOOL fVertical = (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection() == CANDUIDIR_RIGHTTOLEFT)
						|| (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection() == CANDUIDIR_LEFTTORIGHT);

	switch (cmd) {
		case CANDUICMD_MOVESELUP: {
			cmd = (fVertical ? CANDUICMD_MOVESELPREV : CANDUICMD_NONE);
			break;
		}

		case CANDUICMD_MOVESELDOWN: {
			cmd = (fVertical ? CANDUICMD_MOVESELNEXT : CANDUICMD_NONE);
			break;
		}

		case CANDUICMD_MOVESELLEFT: {
			cmd = (fVertical ? CANDUICMD_NONE : CANDUICMD_MOVESELPREV);
			break;
		}

		case CANDUICMD_MOVESELRIGHT: {
			cmd = (fVertical ? CANDUICMD_NONE : CANDUICMD_MOVESELNEXT);
			break;
		}
	}

	return cmd;
}


/*   G E T  C A N D  W I N D O W  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CCandWindowBase *CChsCandWindow::GetCandWindowObj( void )
{
	return this;
}


/*   G E T  P O P U P  C O M M E N T  W I N D O W  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CPopupCommentWindow *CChsCandWindow::GetPopupCommentWindowObj( void )
{
	return NULL;
}


/*   G E T  O P T I O N S  L I S T  B O X  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandListBase *CChsCandWindow::GetOptionsListBoxObj( void )
{
	return NULL;
}


/*   G E T  C A N D  L I S T  B O X  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandListBase *CChsCandWindow::GetCandListBoxObj( void )
{
	return m_pListUIObj;
}


/*   G E T  C A P T I O N  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFWndCaption *CChsCandWindow::GetCaptionObj( void )
{
	return NULL;
}


/*   G E T  M E N U  B U T T O N  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFButton *CChsCandWindow::GetMenuButtonObj( void )
{
	return m_pCandMenuBtn;
}


/*   G E T  E X T R A  C A N D I D A T E  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandListBase *CChsCandWindow::GetExtraCandidateObj( void )
{
	return NULL;
}


/*   G E T  C A N D  R A W  D A T A  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFCandRawData *CChsCandWindow::GetCandRawDataObj( void )
{
	return m_pCandRawData;
}


/*   G E T  C A N D  T I P  W I N D O W  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFBalloonWindow *CChsCandWindow::GetCandTipWindowObj( void )
{
	return NULL;
}


/*   G E T  C A N D  T I P  B U T T O N  O B J   */
/*------------------------------------------------------------------------------

	(CCandUIObjectParent method)

------------------------------------------------------------------------------*/
CUIFButton *CChsCandWindow::GetCandTipButtonObj( void )
{
	return NULL;
}


/*   S E T  T A R G E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CChsCandWindow::SetTargetRect( RECT *prc, BOOL fClipped )
{
	m_rcTarget = *prc;
	m_fTargetClipped = fClipped;

	if (m_hWnd != NULL) {
		int nLeft;
		int nTop;

		// move window here...

		switch (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection()) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: 
			case CANDUIDIR_BOTTOMTOTOP: {
				nLeft = m_rcTarget.left;
				nTop  = m_rcTarget.bottom;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: 
			case CANDUIDIR_LEFTTORIGHT: {
				nLeft = m_rcTarget.left - _nWidth;
				nTop  = m_rcTarget.top;
				break;
			}
		}

		Move( nLeft, nTop, -1, -1 );
	}
}


/*   S E T  W I N D O W  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CChsCandWindow::SetWindowPos( POINT pt )
{
	if (m_hWnd != NULL) {
		Move( pt.x, pt.y, -1, -1 );
	}
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  O B J E C T  M G R                                      */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  O B J E C T  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectMgr::CCandUIObjectMgr( void )
{
	int i;

	m_pCandUI         = NULL;
	m_pUIObjectParent = NULL;

	for (i = 0; i < CANDUIOBJSINK_MAX; i++) {
		m_rgSink[i] = NULL;
	}
}


/*   ~  C  C A N D  U I  O B J E C T  M G R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectMgr::~CCandUIObjectMgr( void )
{
	Uninitialize();
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectMgr::Initialize( CCandidateUI *pCandUI )
{
	m_pCandUI         = pCandUI;
	m_pUIObjectParent = NULL;

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDUIOBJSINK_MAX; i++) {
		Assert( m_rgSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   U N I N I T I A L I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectMgr::Uninitialize( void )
{
	m_pCandUI         = NULL;
	m_pUIObjectParent = NULL;

#if defined(DEBUG) || defined(_DEBUG)
	// check all reference object are unregistered

	for (int i = 0; i < CANDUIOBJSINK_MAX; i++) {
		Assert( m_rgSink[i] == NULL );
	}
#endif

	return S_OK;
}


/*   A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectMgr::AdviseEventSink( CCandUIObjectEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDUIOBJSINK_MAX; i++) {
		if (m_rgSink[i] == NULL) {
			m_rgSink[i] = pSink;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   U N A D V I S E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectMgr::UnadviseEventSink( CCandUIObjectEventSink *pSink )
{
	int i;

	for (i = 0; i < CANDUIOBJSINK_MAX; i++) {
		if (m_rgSink[i] == pSink) {
			m_rgSink[i] = NULL;
			return S_OK;
		}
	}

	Assert( FALSE );
	return E_FAIL;
}


/*   N O T I F Y  U I  O B J E C T  E V E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CCandUIObjectMgr::NotifyUIObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event )
{
	int i;

	for (i = 0; i < CANDUIOBJSINK_MAX; i++) {
		if (m_rgSink[i] != NULL) {
			m_rgSink[i]->OnObjectEvent( obj, event );
		}
	}
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  P R O P E R T Y  E V E N T  S I N K                     */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  O B J E C T  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectEventSink::CCandUIObjectEventSink( void )
{
	m_pObjectMgr = NULL;
}


/*   ~  C  C A N D  U I  O B J E C T  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIObjectEventSink::~CCandUIObjectEventSink( void )
{
	Assert( m_pObjectMgr == NULL );
	if (m_pObjectMgr != NULL) {
		DoneEventSink();
	}
}


/*   I N I T  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectEventSink::InitEventSink( CCandUIObjectMgr *pObjectMgr )
{
	Assert( pObjectMgr != NULL );
	Assert( m_pObjectMgr == NULL );

	if (pObjectMgr == NULL) {
		return E_INVALIDARG;
	}

	m_pObjectMgr = pObjectMgr;
	return m_pObjectMgr->AdviseEventSink( this );
}


/*   D O N E  E V E N T  S I N K   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIObjectEventSink::DoneEventSink( void )
{
	HRESULT hr;

	Assert( m_pObjectMgr != NULL );
	if (m_pObjectMgr == NULL) {
		return E_FAIL;
	}

	hr = m_pObjectMgr->UnadviseEventSink( this );
	m_pObjectMgr = NULL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\sharemem.h ===
//
//
//

#ifndef SHAREMEM_H
#define SHAREMEM_H


//
// shared data definition
//

class CUIFCandMenuParent;

typedef struct _SHAREDDATA
{
	DWORD              dwThreadId;
	HHOOK              hHookKeyboard;
	HHOOK              hHookMouse;
	CUIFCandMenuParent *pMenuParent;
} SHAREDDATA;



//
// CCandUIMMFile
//

#define CANDUIMM_READONLY		0x00000000
#define CANDUIMM_READWRITE		0x00000001

class CCandUIMMFile
{
public:
	CCandUIMMFile( void );
	virtual ~CCandUIMMFile( void );

	BOOL Open( LPSTR szName, DWORD dwFlag );
	BOOL Create( LPSTR szName, DWORD dwFlag, SECURITY_ATTRIBUTES *psa, DWORD dwSize );
	BOOL Close( void );

	__inline BOOL IsValid( void )
	{
		return (GetData() != NULL);
	}

	__inline void *GetData( void )
	{
		return m_pvData;
	}

private:
	HANDLE  m_hFile;
	void    *m_pvData;
};


//
// CCandUIMutex
//

class CCandUIMutex
{
public:
	CCandUIMutex( void );
	virtual ~CCandUIMutex( void );

	BOOL Create( LPSTR szName, SECURITY_ATTRIBUTES *psa );
	BOOL Close( void );
	BOOL Lock( void );
	BOOL Unlock( void );

private:
	HANDLE m_hMutex;
};


//
// CCandUIShareMem
//

class CCandUIShareMem 
{
public:
	CCandUIShareMem( void );
	virtual ~CCandUIShareMem( void );

	BOOL Initialize( void );
	BOOL Open( void );
	BOOL Create( void );
	BOOL Close( void );
	BOOL LockData( void );
	BOOL UnlockData( void );

	__inline SHAREDDATA *GetData( void ) 
	{
		return (SHAREDDATA*)m_MMFile.GetData();
	}

protected:
	CCandUIMMFile	m_MMFile;
	CCandUIMutex	m_Mutex;
};

#endif /* SHAREMEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\wcand.h ===
//
// wcand.h
//

#ifndef WCAND_H
#define WCAND_H

#include "private.h"
#include "mscandui.h"
#include "cuilib.h"

#include "cuicand.h"
#include "cuicand2.h"
#include "candmgr.h"
#include "candprop.h"
#include "candext.h"
#include "candacc.h"
#include "wpopup.h"

class CCandidateUI;
class CCandWindowBase;
class CCandUIObjectMgr;
class CCandUIObjectEventSink;
class CCandMenu;

//
// window class name/title
//

#define WNDCLASS_CANDWND	"MSCandUIWindow_Candidate"
#define WNDTITLE_CANDWND	""
#define WNDCLASS_POPUPWND	"MSCandUIWindow_Comment"
#define WNDTITLE_POPUPWND	""


#define CANDUIOBJSINK_MAX	10

//
//
//

typedef enum _CANDUIOBJECT
{
	CANDUIOBJ_CANDWINDOW,
	CANDUIOBJ_POPUPCOMMENTWINDOW,
	CANDUIOBJ_CANDLISTBOX,
	CANDUIOBJ_CANDCAPTION,
	CANDUIOBJ_MENUBUTTON,
	CANDUIOBJ_EXTRACANDIDATE,
	CANDUIOBJ_CANDRAWDATA,
	CANDUIOBJ_CANDTIPWINDOW,
	CANDUIOBJ_CANDTIPBUTTON,
	CANDUIOBJ_OPTIONSLISTBOX
} CANDUIOBJECT;


//
//
//

typedef enum _CANDUIOBJECTEVENT
{
	CANDUIOBJEV_CREATED,
	CANDUIOBJEV_DESTROYED,
	CANDUIOBJEV_UPDATED,
} CANDUIOBJECTEVENT;


//
// CCandUIObjectParent
//  = CandidateUI UI object parent =
//

class CCandUIObjectParent
{
public:
	CCandUIObjectParent( void );
	virtual ~CCandUIObjectParent( void );

	HRESULT Initialize( CCandUIObjectMgr *pUIObjectMgr );
	HRESULT Uninitialize( void );
	void NotifyUIObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event );

	virtual CCandWindowBase *GetCandWindowObj( void )               = 0;	/* PURE */
	virtual CPopupCommentWindow *GetPopupCommentWindowObj( void )   = 0;	/* PURE */
	virtual CUIFCandListBase *GetOptionsListBoxObj( void )          = 0;	/* PURE */
	virtual CUIFCandListBase *GetCandListBoxObj( void )             = 0;	/* PURE */
	virtual CUIFWndCaption *GetCaptionObj( void )                   = 0;	/* PURE */
	virtual CUIFButton *GetMenuButtonObj( void )                    = 0;	/* PURE */
	virtual CUIFCandListBase *GetExtraCandidateObj( void )          = 0;	/* PURE */
	virtual CUIFCandRawData *GetCandRawDataObj( void )              = 0;	/* PURE */
	virtual CUIFBalloonWindow *GetCandTipWindowObj( void )          = 0;	/* PURE */
	virtual CUIFButton *GetCandTipButtonObj( void )                 = 0;	/* PURE */

protected:
	CCandUIObjectMgr *m_pUIObjectMgr;
};


//
// CCandWindowBase
//  = candidate window base class =
//

class CCandWindowBase : public CUIFWindow,
						public CCandListEventSink,
						public CCandUIPropertyEventSink,
						public CCandUIExtensionEventSink,
						public CCandUIObjectParent,
						public CCandAccItem
{
public:
	CCandWindowBase( CCandidateUI *pCandUI, DWORD dwStyle );
	virtual ~CCandWindowBase( void );

	//
	//
	//
	ULONG AddRef( void );
	ULONG Release( void );

	//
	// CCandListEventSink methods
	//
	virtual void OnSetCandidateList( void );
	virtual void OnClearCandidateList( void );
	virtual void OnCandItemUpdate( void );
	virtual void OnSelectionChanged( void );

	//
	// CCandUIPropertyEventSink methods
	//
	virtual void OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event );

	//
	// CCandUIExtensionEventSink methods
	//
	virtual void OnExtensionAdd( LONG iExtension );
	virtual void OnExtensionDeleted( LONG iExtension );
	virtual void OnExtensionUpdated( LONG iExtension );

	//
	// CUIFWindow methods
	//
	virtual LPCTSTR GetClassName( void );
	virtual LPCTSTR GetWndTitle( void );
	virtual CUIFObject *Initialize( void );
	virtual void Show( BOOL fShow );
	virtual void OnCreate( HWND hWnd );
	virtual void OnDestroy( HWND hWnd );
	virtual void OnNCDestroy( HWND hWnd );
	virtual void OnSysColorChange( void );
	virtual LRESULT OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
	virtual LRESULT OnWindowPosChanged( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
	virtual LRESULT OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
	virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );
	virtual void OnUser(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

	void InitCandidateList( void );
	HRESULT ProcessCommand( CANDUICOMMAND cmd, INT iParam );
	void DestroyWnd( void );
	void OpenCandidateMenu( void );
	BOOL FCandMenuOpen( void );
	CCandMenu *GetCandMenu( void );
	HICON GetIconMenu( void );
	HICON GetIconPopupOn( void );
	HICON GetIconPopupOff( void );

	virtual CUIFCandListBase *GetUIOptionsListObj( void )           = 0;	/* PURE */
	virtual CUIFCandListBase *GetUIListObj( void )                  = 0;	/* PURE */
	virtual void SetTargetRect( RECT *prc, BOOL fClipped )          = 0;	/* PURE */
	virtual void SetWindowPos( POINT pt )                           = 0;	/* PURE */
	virtual void PrepareLayout( void )                              = 0;	/* PURE */
	virtual void LayoutWindow( void )                               = 0;	/* PURE */
	virtual void SelectItemNext( void )                             = 0;	/* PURE */
	virtual void SelectItemPrev( void )                             = 0;	/* PURE */
	virtual void SelectPageNext( void )                             = 0;	/* PURE */
	virtual void SelectPagePrev( void )                             = 0;	/* PURE */
	virtual CANDUICOMMAND MapCommand( CANDUICOMMAND cmd )           = 0;	/* PURE */
	virtual void UpdateAllWindow( void );

	int OptionItemFromListItem( int iListItem );
	int CandItemFromListItem( int iListItem );
	int ListItemFromCandItem( int iCandItem );

	virtual void OnMenuOpened( void );
	virtual void OnMenuClosed( void );

	virtual LRESULT WindowProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
	{
		LRESULT lResult;

		AddRef();
		lResult = CUIFWindow::WindowProc( hWnd, uMsg, wParam, lParam );
		Release();

		return lResult;
	}

	HRESULT IsIndexValid( int i, BOOL *pfValid );

protected:
	ULONG				m_cRef;
	CCandidateUI		*m_pCandUI;
	CCandAccessible		*m_pCandAcc;
	CUIFButton			*m_pCandMenuBtn;
	CCandMenu			*m_pCandMenu;
	CUIFCandRawData		*m_pCandRawData;
	BOOL				m_fCandMenuOpen;
	BOOL				m_fHasRawData;
	LONG				m_nExtUIObj;
	RECT 				m_rcTarget;
	BOOL				m_fTargetClipped;
	BOOL				m_fOnSelectionChanged;
	HICON				m_hIconMenu;
	HICON				m_hIconPopupOn;
	HICON				m_hIconPopupOff;
	HICON				m_hIconCandTipOn;
	HICON				m_hIconCandTipOff;

	CUIFObject *FindUIObject( DWORD dwID );

	virtual void SetCandidateListProc( void );
	virtual void ClearCandidateListProc( void );
	virtual void SetSelectionProc( void );

	BOOL SelectItemProc( INT iSel );
	void SelectItemTop( void );
	void SelectItemEnd( void );

	HRESULT SelectOptionCandidate( void );
	HRESULT SelectCandidate( void );
	HRESULT CompleteOptionCandidate( void );
	HRESULT CompleteCandidate( void );
	HRESULT CancelCandidate( void );
	virtual int GetMenuIconSize( void );

	virtual void CreateExtensionObjects( void );
	virtual void DeleteExtensionObjects( void );
	virtual void SetExtensionObjectProps( void );
};


//
// CCandWindow
//  = candidate window class =
//

class CCandWindow : public CCandWindowBase
{
public:
	CCandWindow( CCandidateUI *pCandUIEx, DWORD dwStyle );
	virtual ~CCandWindow( void );

	//
	// CUIFWindow methods
	//
	virtual HWND CreateWnd( HWND hWndParent );
	virtual void Show( BOOL fShow );
	virtual CUIFObject *Initialize( void );
	virtual DWORD GetWndStyle( void );
	virtual void OnTimer( UINT uiTimerID );
	virtual void OnSysColorChange( void );
	virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

	//
	// CCandWindowBase methods
	//
	virtual CUIFCandListBase *GetUIOptionsListObj( void ) { return (CUIFCandListBase*)m_pOptionsListUIObj; }
	virtual CUIFCandListBase *GetUIListObj( void ) { return (CUIFCandListBase*)m_pListUIObj; }
	virtual void SetTargetRect( RECT *prc, BOOL fClipped );
	virtual void SetWindowPos( POINT pt );
	virtual void PrepareLayout( void );
	virtual void LayoutWindow( void );
	virtual void SelectItemNext( void );
	virtual void SelectItemPrev( void );
	virtual void SelectPageNext( void );
	virtual void SelectPagePrev( void );
	virtual CANDUICOMMAND MapCommand( CANDUICOMMAND cmd );
	virtual void UpdateAllWindow( void );

	//
	// CCandUIObjectParent methods
	//
	virtual CCandWindowBase *GetCandWindowObj( void );
	virtual CPopupCommentWindow *GetPopupCommentWindowObj( void );
	virtual CUIFCandListBase *GetOptionsListBoxObj( void );
	virtual CUIFCandListBase *GetCandListBoxObj( void );
	virtual CUIFWndCaption *GetCaptionObj( void );
	virtual CUIFButton *GetMenuButtonObj( void );
	virtual CUIFCandListBase *GetExtraCandidateObj( void );
	virtual CUIFCandRawData *GetCandRawDataObj( void );
	virtual CUIFBalloonWindow *GetCandTipWindowObj( void );
	virtual CUIFButton *GetCandTipButtonObj( void );

	void ScrollPageNext( void );
	void ScrollPagePrev( void );
	void ScrollToTop( void );
	void ScrollToEnd( void );

	//
	// popup comment window callbacks
	//
	void OnCommentWindowMoved( void );
	void OnCommentSelected( int iCandItem );
	void OnCommentClose( void );

	//
	//
	//

	virtual void OnMenuOpened( void );
	virtual void OnMenuClosed( void );

protected:
	CUIFCandList        *m_pOptionsListUIObj;
	CUIFCandList        *m_pListUIObj;
	CUIFCandList        *m_pExtListUIObj;
	CUIFWndFrame        *m_pWndFrame;
	CUIFWndCaption      *m_pCaptionObj;
	int                 m_cxWndOffset;
	int                 m_cyWndOffset;
	int                 m_nOptionsItemShow;
	int                 m_nItemShow;
	CPopupCommentWindow *m_pCommentWnd;
	BOOL                m_fCommentWndOpen;
	int                 m_iItemAttensionSelect;
	int                 m_iItemAttensionHover;
	CUIFBalloonWindow   *m_pCandTipWnd;
	CUIFButton          *m_pCandTipBtn;
	BOOL                m_fCandTipWndOpen;

	virtual void SetCandidateListProc( void );
	virtual void ClearCandidateListProc( void );

	// popup comment functions

	void SetOptionsAttensionByHover( int iItem );
	void SetAttensionBySelect( int iItem );
	void SetAttensionByHover( int iItem );
	void OpenCommentWindow( int iItem );
	void CloseCommentWindow( void );
	void SetCommentStatus( int iItem );
	void ClearCommentStatus( void );
	void OpenCandTipWindow( void );
	void CloseCandTipWindow( void );
	void MoveCandTipWindow( void );
	void ShowCandTipWindow( BOOL fShow );
};


//
//
//

class CChsCandWindow : public CCandWindowBase
{
public:
	CChsCandWindow( CCandidateUI *pCandUIEx, DWORD dwStyle );
	~CChsCandWindow();

	//
	// CUIFWindow methods
	//
	virtual CUIFObject *Initialize( void );

	//
	// CCandWindowBase methods
	//
	virtual CUIFCandListBase *GetUIOptionsListObj( void ) { return (CUIFCandListBase*)m_pOptionsListUIObj; }
	virtual CUIFCandListBase *GetUIListObj( void ) { return (CUIFCandListBase*)m_pListUIObj; }
	virtual void SetTargetRect( RECT *prc, BOOL fClipped );
	virtual void SetWindowPos( POINT pt );
	virtual void PrepareLayout( void ) {}
	virtual void LayoutWindow( void );
	virtual void SelectItemNext( void );
	virtual void SelectItemPrev( void );
	virtual void SelectPageNext( void );
	virtual void SelectPagePrev( void );
	virtual CANDUICOMMAND MapCommand( CANDUICOMMAND cmd );

	//
	// CCandUIObjectParent methods
	//
	virtual CCandWindowBase *GetCandWindowObj( void );
	virtual CPopupCommentWindow *GetPopupCommentWindowObj( void );
	virtual CUIFCandListBase *GetOptionsListBoxObj( void );
	virtual CUIFCandListBase *GetCandListBoxObj( void );
	virtual CUIFWndCaption *GetCaptionObj( void );
	virtual CUIFButton *GetMenuButtonObj( void );
	virtual CUIFCandListBase *GetExtraCandidateObj( void );
	virtual CUIFCandRawData *GetCandRawDataObj( void );
	virtual CUIFBalloonWindow *GetCandTipWindowObj( void );
	virtual CUIFButton *GetCandTipButtonObj( void );

protected:
	CUIFRowList         *m_pOptionsListUIObj;
	CUIFRowList         *m_pListUIObj;
};


//
// CCandUIObjectMgr
//  = CandidateUI UI object manager =
//

class CCandUIObjectMgr
{
public:
	CCandUIObjectMgr( void );
	virtual ~CCandUIObjectMgr( void );

	HRESULT Initialize( CCandidateUI *pCandUI );
	HRESULT Uninitialize( void );

	HRESULT AdviseEventSink( CCandUIObjectEventSink *pSink );
	HRESULT UnadviseEventSink( CCandUIObjectEventSink *pSink );
	void NotifyUIObjectEvent( CANDUIOBJECT obj, CANDUIOBJECTEVENT event );

	__inline CCandWindowBase *GetCandWindowObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetCandWindowObj() : NULL;
	}

	__inline CPopupCommentWindow *GetPopupCommentWindowObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetPopupCommentWindowObj() : NULL;
	}

	__inline CUIFCandListBase *GetOptionsListBoxObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetOptionsListBoxObj() : NULL;
	}

	__inline CUIFCandListBase *GetCandListBoxObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetCandListBoxObj() : NULL;
	}

	__inline CUIFWndCaption *GetCaptionObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetCaptionObj() : NULL;
	}

	__inline CUIFButton *GetMenuButtonObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetMenuButtonObj() : NULL;
	}

	__inline CUIFCandListBase *GetExtraCandidateObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetExtraCandidateObj() : NULL;
	}

	__inline CUIFCandRawData *GetCandRawDataObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetCandRawDataObj() : NULL;
	}

	__inline CUIFBalloonWindow *GetCandTipWindowObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetCandTipWindowObj() : NULL;
	}

	__inline CUIFButton *GetCandTipButtonObj( void )
	{
		return (m_pUIObjectParent != NULL) ? m_pUIObjectParent->GetCandTipButtonObj() : NULL;
	}

	//
	//
	//
	__inline CCandidateUI *GetCandidateUI( void )
	{
		return m_pCandUI;
	}

	__inline SetUIObjectParent( CCandUIObjectParent *pUIObjectParent )
	{
		m_pUIObjectParent = pUIObjectParent;
	}

protected:
	CCandidateUI           *m_pCandUI;
	CCandUIObjectEventSink *m_rgSink[ CANDUIOBJSINK_MAX ];
	CCandUIObjectParent    *m_pUIObjectParent;
};

#endif // WCAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\wpopup.cpp ===
//
// wpopup.cpp
//

#include "private.h"
#include "wpopup.h"
#include "wcand.h"
#include "globals.h"
#include "res.h"
#include "candutil.h"

#include "candui.h"
#include "candmenu.h"

// UI object IDs

#define IDUIF_COMMENTLIST		0x00000001
#define IDUIF_CLOSEBUTTON		0x00000002


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C O M M E N T  L I S T                                          */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  C O M M E N T  L I S T   */
/*------------------------------------------------------------------------------

	Constructor of CUIFCommentList

------------------------------------------------------------------------------*/
CUIFCommentList::CUIFCommentList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFListBase( pParent, dwID, prc, dwStyle )
{
	m_cyTitle = 0;
	m_cyTitleMargin   = 1;
	m_cxCommentMargin = 9;
	m_cyCommentMargin = 6;
	m_hFontTitle = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
	m_hFontText  = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
}


/*   ~  C  U I F  C O M M E N T  L I S T   */
/*------------------------------------------------------------------------------

	Destructor of CUIFCommentList

------------------------------------------------------------------------------*/
CUIFCommentList::~CUIFCommentList( void )
{
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------

	Set rect of UI object
	(CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFCommentList::SetRect( const RECT *prc )
{
	BOOL fChangeWidth = ((GetRectRef().right - GetRectRef().left) != (prc->right - prc->left));

	CUIFListBase::SetRect( prc );

	if (fChangeWidth) {
		CalcItemHeight();
	}
}


/*   A D D  C O M M E N T  I T E M   */
/*------------------------------------------------------------------------------

	Add comment item

------------------------------------------------------------------------------*/
void CUIFCommentList::AddCommentItem( CCommentListItem *pListItem )
{
	AddItem( pListItem );
}


/*   G E T  C O M M E N T  I T E M   */
/*------------------------------------------------------------------------------

	Get comment item

------------------------------------------------------------------------------*/
CCommentListItem *CUIFCommentList::GetCommentItem( int iListItem )
{
	return (CCommentListItem *)GetItem( iListItem );
}


/*   I N I T  I T E M  H E I G H T   */
/*------------------------------------------------------------------------------

	Intitalize item height
	NOTE: This must be called after set all comment list items

------------------------------------------------------------------------------*/
void CUIFCommentList::InitItemHeight( void )
{
	CalcTitleHeight();
	CalcItemHeight();
}


/*   G E T  T O T A L  H E I G H T   */
/*------------------------------------------------------------------------------

	Get height of all items

------------------------------------------------------------------------------*/
int CUIFCommentList::GetTotalHeight( void )
{
	int nHeight = 0;
	int nItem = GetCount();
	int iItem;

	for (iItem = 0; iItem < nItem; iItem++) {
		nHeight += GetItemHeight( iItem );
	}

	return nHeight;
}


/*   G E T  M I N I M U M  W I D T H   */
/*------------------------------------------------------------------------------

	Get minimum width

------------------------------------------------------------------------------*/
int CUIFCommentList::GetMinimumWidth( void )
{
	return CalcMinimumWidth();
}


/*   S E T  T I T L E  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCommentList::SetTitleFont( HFONT hFont )
{
	m_hFontTitle = hFont; 
}


/*   S E T  T E X T  F O N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCommentList::SetTextFont( HFONT hFont )
{
	m_hFontText = hFont;
}


/*   G E T  I T E M  H E I G H T   */
/*------------------------------------------------------------------------------

	Get height of item
	(CUIFListBase method)

------------------------------------------------------------------------------*/
int CUIFCommentList::GetItemHeight( int iItem )
{
	CCommentListItem *pItem = GetCommentItem( iItem );

	Assert( pItem != NULL );
	return (pItem != NULL) ? pItem->GetHeight() + m_cyTitle : 0;
}


/*   P A I N T  I T E M  P R O C   */
/*------------------------------------------------------------------------------

	Paint list item
	(CUIFListBase method )

------------------------------------------------------------------------------*/
void CUIFCommentList::PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected )
{
	CCommentListItem *pListItem = (CCommentListItem *)pItem;
	CCandidateItem *pCandItem;

	HFONT    hFontOld;
	COLORREF colTextOld;
	int      iBkModeOld;
	RECT     rc;

	Assert( pListItem != NULL );

	pCandItem = pListItem->GetCandidateItem();
	Assert( pCandItem != NULL );

	hFontOld = (HFONT)GetCurrentObject( hDC, OBJ_FONT );
	colTextOld = GetTextColor( hDC );
	iBkModeOld = SetBkMode( hDC, TRANSPARENT );

	// paint title

	rc = *prc;
	rc.bottom = rc.top + m_cyTitle;
	if (IntersectRect( &rc, &rc, prc )) {
		LPCWSTR psz = pCandItem->GetString();
		HPEN    hPen;
		HPEN    hPenOld;
		SIZE    size;

		InflateRect( &rc, 0, -m_cyTitleMargin );

		// draw title text

		SelectObject( hDC, m_hFontTitle );
		SetTextColor( hDC, GetUIFColor( UIFCOLOR_CTRLTEXT ) );
		FLExtTextOutW( hDC, rc.left,   rc.top, ETO_CLIPPED, &rc, psz, wcslen(psz), NULL );
		FLExtTextOutW( hDC, rc.left+1, rc.top, ETO_CLIPPED, &rc, psz, wcslen(psz), NULL );

		// draw underline

		FLGetTextExtentPoint32( hDC, psz, wcslen(psz), &size );

		hPen = CreatePen( PS_SOLID, 0, GetUIFColor( UIFCOLOR_BORDEROUTER ) );
		hPenOld = (HPEN)SelectObject( hDC, hPen );

		MoveToEx( hDC, rc.left, rc.top + size.cy, NULL );
		LineTo( hDC, rc.right, rc.top + size.cy );

		SelectObject( hDC, hPenOld );
		DeleteObject( hPen );
	}

	// paint comment

	rc = *prc;
	rc.top = rc.top + m_cyTitle;
	if (IntersectRect( &rc, &rc, prc )){
		LPCWSTR psz;

		rc.left   += m_cxCommentMargin;
		rc.top    += m_cyCommentMargin;
		rc.bottom -= m_cyCommentMargin;

		SelectObject( hDC, m_hFontText );
		SetTextColor( hDC, GetSysColor( COLOR_WINDOWTEXT ) );

		psz = pCandItem->GetPopupComment();
		PaintCommentProc( hDC, &rc, psz, FALSE );
	}

	// restore device context settings

	SelectObject( hDC, hFontOld );
	SetTextColor( hDC, colTextOld );
	SetBkMode( hDC, iBkModeOld );
}


/*   P A I N T  C O M M E N T  P R O C   */
/*------------------------------------------------------------------------------

	Paint comment text proc
	returns height of comment text

------------------------------------------------------------------------------*/
int CUIFCommentList::PaintCommentProc( HDC hDC, const RECT *prc, LPCWSTR pwch, BOOL fCalcOnly )
{
	return FLDrawTextW( hDC, pwch, wcslen(pwch), prc, DT_TOP | DT_LEFT | DT_WORDBREAK | DT_EDITCONTROL | (fCalcOnly ? DT_CALCRECT : 0) );
}


/*   C A L C  M I N I M U M  W I D T H   */
/*------------------------------------------------------------------------------

	Calculate minimum width

------------------------------------------------------------------------------*/
int CUIFCommentList::CalcMinimumWidth( void )
{
	HDC hDC = GetDC( NULL );
	int nItem = GetCount();
	int iItem;
	HFONT hFontOld;
	int cxTitle = 0;

	// prepare DC

	hFontOld = (HFONT)SelectObject( hDC, m_hFontTitle );

	// calc height of all items

	for (iItem = 0; iItem < nItem; iItem++) {
		CCommentListItem *pItem = GetCommentItem( iItem );

		if (pItem != NULL) {
			CCandidateItem *pCandItem = pItem->GetCandidateItem();
			SIZE size;

			FLGetTextExtentPoint32( hDC, pCandItem->GetString(), wcslen(pCandItem->GetString()), &size );

			cxTitle = max( cxTitle, size.cx );
		}
	}

	// restore DC

	SelectObject( hDC, hFontOld );
	ReleaseDC( NULL, hDC );

	return cxTitle + 1;
}


/*   C A L C  T I T L E  H E I G H T   */
/*------------------------------------------------------------------------------

	Calculate height of title 

------------------------------------------------------------------------------*/
void CUIFCommentList::CalcTitleHeight( void )
{
	HDC hDC = GetDC( NULL );

	m_cyTitle = GetFontHeightOfFont( hDC, m_hFontTitle ) + m_cyTitleMargin * 2;

	ReleaseDC( NULL, hDC );
}


/*   C A L C  I T E M  H E I G H T   */
/*------------------------------------------------------------------------------

	Calculate height of all items

------------------------------------------------------------------------------*/
void CUIFCommentList::CalcItemHeight( void )
{
	HDC hDC = GetDC( NULL );
	int nItem = GetCount();
	int iItem;
	HFONT hFontOld;

	// prepare DC

	hFontOld = (HFONT)SelectObject( hDC, m_hFontText );

	// calc height of all items

	for (iItem = 0; iItem < nItem; iItem++) {
		CCommentListItem *pItem = GetCommentItem( iItem );

		if (pItem != NULL) {
			CalcItemHeightProc( hDC, pItem );
		}
	}

	// restore DC

	SelectObject( hDC, hFontOld );
	ReleaseDC( NULL, hDC );
}


/*   C A L C  I T E M  H E I G H T  P R O C   */
/*------------------------------------------------------------------------------

	Calclate height of item main routine

------------------------------------------------------------------------------*/
void CUIFCommentList::CalcItemHeightProc( HDC hDC, CCommentListItem *pListItem )
{
	CCandidateItem *pCandItem = pListItem->GetCandidateItem();
	RECT  rc;
	int   cyComment;

	GetRect( &rc );
	rc.left += m_cxCommentMargin;
	cyComment = PaintCommentProc( hDC, &rc, pCandItem->GetPopupComment(), TRUE ) + m_cyCommentMargin * 2;

	pListItem->SetHeight( cyComment );
}


/*============================================================================*/
/*                                                                            */
/*   C  P O P U P  C O M M E N T  W I N D O W                                 */
/*                                                                            */
/*============================================================================*/

/*   C  P O P U P  C O M M E N T  W I N D O W   */
/*------------------------------------------------------------------------------

	Constructor of CPopupCommentWindow

------------------------------------------------------------------------------*/
CPopupCommentWindow::CPopupCommentWindow( CCandWindow *pCandWnd, CCandidateUI *pCandUI ) : CUIFWindow( g_hInst, UIWINDOW_TOPMOST | UIWINDOW_TOOLWINDOW | UIWINDOW_OFC10WORKPANE | UIWINDOW_HASSHADOW )
{
	m_pCandUI       = pCandUI;
	m_pCandWnd      = pCandWnd;
	m_pWndFrame     = NULL;
	m_pCloseBtn     = NULL;
	m_pCaption      = NULL;
	m_pCommentList  = NULL;
	m_hIconClose    = NULL;
	m_fUserMoved    = FALSE;
	
	// initialize event sinks

	CCandListEventSink::InitEventSink( m_pCandUI->GetCandListMgr() );
	CCandUIPropertyEventSink::InitEventSink( m_pCandUI->GetPropertyMgr() );

	// initialize resources

	m_hIconClose = (HICON)LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICONCLOSE), IMAGE_ICON, 0, 0, LR_LOADMAP3DCOLORS );
}


/*   ~  C  P O P U P  C O M M E N T  W I N D O W   */
/*------------------------------------------------------------------------------

	Destructor of CPopupCommentWindow

------------------------------------------------------------------------------*/
CPopupCommentWindow::~CPopupCommentWindow( void )
{
	// dispose resources

	DestroyIcon( m_hIconClose );

	//

	CCandUIPropertyEventSink::DoneEventSink();
	CCandListEventSink::DoneEventSink();
}


/*   G E T  C L A S S  N A M E   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
LPCTSTR CPopupCommentWindow::GetClassName( void )
{
	return _T( WNDCLASS_POPUPWND );
}


/*   G E T  W N D  T I T L E   */
/*------------------------------------------------------------------------------

	(CUIFWindow method)

------------------------------------------------------------------------------*/
LPCTSTR CPopupCommentWindow::GetWndTitle( void )
{
	return _T( WNDTITLE_POPUPWND );
}


/*   O N  S E T  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on SetCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnSetCandidateList( void )
{
	Assert( FInitialized() );

	SetCommentListProc();
	LayoutWindow();
}


/*   O N  C L E A R  C A N D I D A T E  L I S T   */
/*------------------------------------------------------------------------------

	Callback function on ClearCandidateList
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnClearCandidateList( void )
{
	Assert( FInitialized() );

	ClearCommentListProc();
	LayoutWindow();
}


/*   O N  C A N D  I T E M  U P D A T E   */
/*------------------------------------------------------------------------------

	Callback function of candiate item has been updated
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnCandItemUpdate( void )
{
	Assert( FInitialized() );

	SetCommentListProc();
	LayoutWindow();
}


/*   O N  S E L E C T I O N  C H A N G E D   */
/*------------------------------------------------------------------------------

	Callback function of candiate selection has been changed
	(CCandListEventSink method)

	NOTE: Do not update candidate item in the callback functios

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnSelectionChanged( void )
{
	Assert( FInitialized() );
}


/*   O N  P R O P E R T Y  U P D A T E D   */
/*------------------------------------------------------------------------------

	Callback function on update CandiateUI property
	(CCandUIPropertyEventSink method)

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event )
{
	switch (prop) {
		case CANDUIPROP_POPUPCOMMENTWINDOW: {
			if (event == CANDUIPROPEV_UPDATEPOSITION) {
				POINT pt;
				RECT rc;

				GetPropertyMgr()->GetPopupCommentWindowProp()->GetPosition( &pt );
				rc.left   = pt.x;
				rc.top    = pt.y;
				rc.right  = pt.x + _nWidth;
				rc.bottom = pt.y + _nHeight;

				AdjustWindowRect( NULL, &rc, &pt, FALSE );
				if (rc.left != _xWnd || rc.top != _yWnd) {
					Move( rc.left, rc.top, -1, -1 );
				}
			}
			else {
				LayoutWindow( TRUE /* resize/repos always */ );
			}
			break;
		}

		default: {
			LayoutWindow( TRUE /* resize/repos always */ );
			break;
		}
	}
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

	Initialize UI objects

------------------------------------------------------------------------------*/
CUIFObject *CPopupCommentWindow::Initialize( void )
{
	RECT rc = {0};

	//
	// create window frame
	//

	m_pWndFrame = new CUIFWndFrame( this, &rc, UIWNDFRAME_ROUNDTHICK | UIWNDFRAME_RESIZERIGHT );
	if (m_pWndFrame) {
		m_pWndFrame->Initialize();
		AddUIObj( m_pWndFrame ); 
	}

	//
	// create caption
	//

	m_pCaption = new CUIFWndCaption( this, 0, &rc, UIWNDCAPTION_MOVABLE );
	if (m_pCaption) {
		m_pCaption->Initialize();
		AddUIObj( m_pCaption );
	}

	//
	// create close button
	//

	m_pCloseBtn = new CUIFCaptionButton( this, IDUIF_CLOSEBUTTON, &rc, UIBUTTON_PUSH | UIBUTTON_CENTER | UIBUTTON_VCENTER );
	if (m_pCloseBtn) {
		m_pCloseBtn->Initialize();
		m_pCloseBtn->SetIcon( m_hIconClose );
		AddUIObj( m_pCloseBtn );
	}

	//
	// create list
	//

	m_pCommentList = new CUIFCommentList( this, IDUIF_COMMENTLIST, &rc, UILIST_HORZTB | UILIST_VARIABLEHEIGHT );
	if (m_pCommentList) {
		m_pCommentList->Initialize();
		AddUIObj( m_pCommentList );
	}

	return CUIFWindow::Initialize();
}


/*   M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CPopupCommentWindow::Move( int x, int y, int nWidth, int nHeight )
{
	BOOL fResize = (nWidth != -1 || nHeight != -1);
	RECT rc;

	if (fResize) {
		RECT rcTest;
		int  nHeightNew;

		// 

		if (nWidth  == -1) {
			nWidth = _nWidth;
		}
		if (nHeight == -1) {
			nHeight = _nHeight;
		}

		// get resizable width

		rc.left   = _xWnd;
		rc.top    = _yWnd;
		rc.right  = _xWnd + nWidth;
		rc.bottom = _yWnd + nHeight;

		AdjustWindowRect( GetWnd(), &rc, NULL, TRUE );

		nWidth = rc.right - rc.left;

		// get expected window height

		rcTest.left   = 0;
		rcTest.top    = 0;
		rcTest.right  = nWidth;
		rcTest.bottom = nHeight;

		nHeightNew = LayoutWindowProc( &rcTest );

		if (0 < nHeightNew) {
			nHeight = nHeightNew;
		}

		// adjust window pos again (because height might be changed)

		rc.left   = _xWnd;
		rc.top    = _yWnd;
		rc.right  = _xWnd + nWidth;
		rc.bottom = _yWnd + nHeight;

		AdjustWindowRect( GetWnd(), &rc, NULL, FALSE );
	}
	else {
		m_fUserMoved = TRUE;

		// ensure window is on workarea

		rc.left   = x;
		rc.top    = y;
		rc.right  = x + _nWidth;
		rc.bottom = y + _nHeight;

		AdjustWindowRect( GetWnd(), &rc, NULL, FALSE );
	}

	CUIFWindow::Move( rc.left, rc.top, nWidth, nHeight );

	if (fResize) {
		// re-layout child object again
		// (window size should not be changed by this...)

		LayoutWindow();
	}
}


/*   O N  W I N D O W  P O S  C H A N G E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CPopupCommentWindow::OnWindowPosChanged( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult = CUIFWindow::OnWindowPosChanged( hWnd, uMsg, wParam, lParam );

	m_pCandWnd->OnCommentWindowMoved();

	return lResult;
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CPopupCommentWindow::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
	DWORD dwID = pUIObj->GetID();

	// comment list

	if (dwID == IDUIF_COMMENTLIST) {
		switch (dwCommand) {
			case UILIST_SELECTED: {
				int iCandItem = CandItemFromListItem( (int)lParam );

				m_pCandWnd->OnCommentSelected( iCandItem );
				break;
			}
		}
	}

	// close button

	else if (dwID == IDUIF_CLOSEBUTTON) {
		switch (dwCommand) {
			case UIBUTTON_PRESSED: {
				m_pCandWnd->OnCommentClose();
				break;
			}
		}
	}

	return 0;
}


/*   O N  C R E A T E   */
/*------------------------------------------------------------------------------

	on create

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnCreate( HWND hWnd )
{
	SetProp( hWnd, (LPCTSTR)GlobalAddAtom(_T("MicrosoftTabletPenServiceProperty")), (HANDLE)1 );
}


/*   O N  N  C  D E S T R O Y   */
/*------------------------------------------------------------------------------

	on n c destroy

------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnNCDestroy( HWND hWnd )
{
	RemoveProp( hWnd, (LPCTSTR)GlobalAddAtom(_T("MicrosoftTabletPenServiceProperty")) );
}



/*   D E S T R O Y  W N D   */
/*------------------------------------------------------------------------------

	Destroy candidate window

------------------------------------------------------------------------------*/
void CPopupCommentWindow::DestroyWnd( void )
{
	DestroyWindow( GetWnd() );
}


/*   L A Y O U T  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CPopupCommentWindow::LayoutWindow( BOOL fResize )
{
	RECT rcWnd = GetRectRef();
	int  nHeight;

	// get expected window size 

	nHeight = LayoutWindowProc( &rcWnd );

	// change window size if required

	if (fResize || ((0 < nHeight) && (GetRectRef().bottom - GetRectRef().top != nHeight))) {
		int nWidth = GetRectRef().right - GetRectRef().left;
		RECT rc;

		if (m_fUserMoved || !GetPropertyMgr()->GetPopupCommentWindowProp()->IsAutoMoveEnabled()) {
			rc.left   = _xWnd;
			rc.top    = _yWnd;
			rc.right  = _xWnd + nWidth;
			rc.bottom = _yWnd + nHeight;

			AdjustWindowRect( GetWnd(), &rc, NULL, FALSE );
			CUIFWindow::Move( rc.left, rc.top, nWidth, nHeight );
		}
		else {
			POINT pt;

			CalcPos( &pt, nWidth, nHeight );
			CUIFWindow::Move( pt.x, pt.y, nWidth, nHeight );
		}

		// layout again

		rcWnd = GetRectRef();
		LayoutWindowProc( &rcWnd );
	}
}


/*   L A Y O U T  W I N D O W  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CPopupCommentWindow::LayoutWindowProc( RECT *prcWnd )
{
	RECT rcInt = *prcWnd;
	RECT rc;
	int  cyFrame = 0;
	int  cyList  = 0;
	int  cyCaption = 0;

	// set font

	if (m_pCommentList != NULL) {
		m_pCommentList->SetTitleFont( GetPropertyMgr()->GetPopupCommentTitleProp()->GetFont() );
		m_pCommentList->SetTextFont( GetPropertyMgr()->GetPopupCommentTextProp()->GetFont() );
	}

	// layout frame

	if (m_pWndFrame != NULL) {
		m_pWndFrame->SetRect( prcWnd );
		m_pWndFrame->Show( TRUE );

		m_pWndFrame->GetInternalRect( &rcInt );

		cyFrame = (prcWnd->bottom - prcWnd->top) - (rcInt.bottom - rcInt.top);
	}

	// layout caption

	if (m_pCaption != NULL) {
		rc.left   = rcInt.left;
		rc.top    = rcInt.top;
		rc.right  = rcInt.right;
		rc.bottom = rcInt.top + 16;

		m_pCaption->SetRect( &rc );
		m_pCaption->Show( TRUE );

		cyCaption = 16;
	}

	// layout close button

	if (m_pCloseBtn != NULL) {
		rc.left   = rcInt.right - cyCaption;
		rc.top    = rcInt.top;
		rc.right  = rcInt.right;
		rc.bottom = rcInt.top   + cyCaption;

		m_pCloseBtn->SetRect( &rc );
		m_pCloseBtn->Show( TRUE );
	}

	// layout list

	if (m_pCommentList != NULL) {
		rc.left   = rcInt.left + 6;
		rc.top    = rcInt.top + 16;
		rc.right  = rcInt.right - 6;
		rc.bottom = rcInt.bottom;

		m_pCommentList->SetRect( &rc );
		m_pCommentList->Show( TRUE );

		cyList = m_pCommentList->GetTotalHeight();
	}

	return ((cyList != 0) ? cyFrame + cyList + cyCaption : (-1));
}


/*   O N  C A N D  W I N D O W  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CPopupCommentWindow::OnCandWindowMove( BOOL fResetAnyway )
{
	POINT pt;

	if (!fResetAnyway && m_fUserMoved) {
		return;
	}

	m_fUserMoved = FALSE;

	if (!GetPropertyMgr()->GetPopupCommentWindowProp()->IsAutoMoveEnabled()) {
		return;
	}

	CalcPos( &pt, _nWidth, _nHeight );
	CUIFWindow::Move( pt.x, pt.y, -1, -1 );
}


/*   S E T  C O M M E N T  L I S T  P R O C   */
/*------------------------------------------------------------------------------

	Set comment list

------------------------------------------------------------------------------*/
void CPopupCommentWindow::SetCommentListProc( void )
{
	CCandidateList *pCandList;
	int i;
	int nCandItem;
	int cxMinimum;
	RECT rc;
	SIZE sizeFrame = {0};
	SIZE size;

	if (m_pCommentList == NULL) {
		return;
	}

	pCandList = GetCandListMgr()->GetCandList();
	Assert( pCandList != NULL );

	// reset list item

	m_pCommentList->DelAllItem();

	// Windows#482518/Satori81#907 - prevent from AV in case that we cannot get candidate list instance
	if (pCandList == NULL) {
		return;
	}

	// add list item

	nCandItem = pCandList->GetItemCount();
	for (i = 0; i < nCandItem; i++) {
		CCandidateItem *pCandItem;

		pCandItem = pCandList->GetCandidateItem( i );
		if (pCandItem->IsVisible() && pCandItem->IsPopupCommentVisible()) {
			CCommentListItem *pListItem = new CCommentListItem( i, pCandItem );
            if (pListItem)
			    m_pCommentList->AddCommentItem( pListItem );
		}
	}

	// get minimum width

	cxMinimum = m_pCommentList->GetMinimumWidth();
	if (m_pWndFrame != NULL) {
		m_pWndFrame->GetFrameSize( &sizeFrame );
	}

	size.cx = cxMinimum + sizeFrame.cx + sizeFrame.cx + 6 + 6;
	size.cy = -1;

	size.cx = max( size.cx, GetSystemMetrics( SM_CXMIN ) );

	// resize window when needed

	GetRect( &rc );
	if ((rc.right - rc.left) < size.cx) {
		Move( _xWnd, _yWnd, size.cx, size.cy );
	}

	// set minimum window size

	if (m_pWndFrame != NULL) {
		m_pWndFrame->SetMinimumSize( &size );
	}

	// calc list item height

	m_pCommentList->InitItemHeight();

	// update window

	if (m_hWnd != NULL) {
		InvalidateRect( m_hWnd, NULL, TRUE );
	}
}


/*   C L E A R  C O M M E N T  L I S T  P R O C   */
/*------------------------------------------------------------------------------

	Clear comment list

------------------------------------------------------------------------------*/
void CPopupCommentWindow::ClearCommentListProc( void )
{
	m_pCommentList->DelAllItem();
}


/*   C A N D  I T E M  F R O M  L I S T  I T E M   */
/*------------------------------------------------------------------------------

	Get index of candidate item in candidate list data 
		from index of item in UIList object

------------------------------------------------------------------------------*/
int CPopupCommentWindow::CandItemFromListItem( int iListItem )
{
	CCommentListItem *pListItem;

	if (m_pCommentList == NULL) {
		return ICANDITEM_NULL;
	}

	pListItem = m_pCommentList->GetCommentItem( iListItem );
	Assert( pListItem != NULL );

	return (pListItem != NULL) ? pListItem->GetICandItem() : ICANDITEM_NULL;
}


/*   C A L C  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CPopupCommentWindow::CalcPos( POINT *ppt, int nWidth, int nHeight )
{
	RECT rcCandWnd;
	RECT rc;
	int  cxOffset;
	int  cyOffset;
	CUIFBalloonWindow *pCandTipWnd;
	CCandMenu *pCandMenu;
	WNDALIGNH HAlign;
	WNDALIGNV VAlign;

	GetWindowRect( m_pCandWnd->GetWnd(), &rcCandWnd );

	// calc align

	switch (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection()) {
		default:
		case CANDUIDIR_TOPTOBOTTOM: {
			HAlign = LOCATE_RIGHT;
			VAlign = ALIGN_TOP;
			break;
		}

		case CANDUIDIR_BOTTOMTOTOP: {
			HAlign = LOCATE_RIGHT;
			VAlign = ALIGN_BOTTOM;
			break;
		}

		case CANDUIDIR_RIGHTTOLEFT: {
			HAlign = ALIGN_LEFT;
			VAlign = LOCATE_BELLOW;
			break;
		}

		case CANDUIDIR_LEFTTORIGHT: {
			HAlign = ALIGN_LEFT;
			VAlign = LOCATE_BELLOW;
			break;
		}
	}

	// calc offset to don't overlap with tip

	cxOffset = 0;
	cyOffset = 0;
	pCandTipWnd = m_pCandWnd->GetCandTipWindowObj();
	if (pCandTipWnd != NULL && IsWindow( pCandTipWnd->GetWnd() ) && pCandTipWnd->IsVisible()) {
		RECT rcCandTipWnd;

		GetWindowRect( pCandTipWnd->GetWnd(), &rcCandTipWnd );
		switch (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection()) {
			default:
			case CANDUIDIR_TOPTOBOTTOM: {
				cyOffset += rcCandTipWnd.bottom - rcCandWnd.top;
				break;
			}

			case CANDUIDIR_BOTTOMTOTOP: {
				cyOffset += rcCandTipWnd.top - rcCandWnd.bottom - 1;
				break;
			}

			case CANDUIDIR_RIGHTTOLEFT: {
				rcCandWnd.top = min( rcCandWnd.top, rcCandTipWnd.top );
				rcCandWnd.bottom = max( rcCandWnd.bottom, rcCandTipWnd.bottom );
				break;
			}

			case CANDUIDIR_LEFTTORIGHT: {
				rcCandWnd.top = min( rcCandWnd.top, rcCandTipWnd.top );
				rcCandWnd.bottom = max( rcCandWnd.bottom, rcCandTipWnd.bottom );
				break;
			}
		}
	}

	// calc pos

	CalcWindowRect( &rc, &rcCandWnd, nWidth, nHeight, cxOffset, cyOffset, HAlign, VAlign );

	// recalc pos to don't overlap with menu

	pCandMenu = m_pCandWnd->GetCandMenu();
	if (pCandMenu != NULL) {
		CUIFMenu *pCandMenuWnd;

		pCandMenuWnd = pCandMenu->GetMenuUI();
		if (pCandMenuWnd != NULL) {
			RECT rcCandMenu;
			RECT rcUnion;
			RECT rcIntersect;

			GetWindowRect( pCandMenuWnd->GetWnd(), &rcCandMenu );
			if (IntersectRect( &rcIntersect, &rc, &rcCandMenu )) {
				UnionRect( &rcUnion, &rcCandWnd, &rcCandMenu );

				switch (GetPropertyMgr()->GetCandWindowProp()->GetUIDirection()) {
					default:
					case CANDUIDIR_TOPTOBOTTOM: {
						cyOffset += rcCandWnd.top - min( rcCandWnd.top, rcUnion.top );
						break;
					}

					case CANDUIDIR_BOTTOMTOTOP: {
						cyOffset += rcCandWnd.bottom - max( rcCandWnd.bottom, rcUnion.bottom );
						break;
					}

					case CANDUIDIR_RIGHTTOLEFT: {
						// cxOffset = rcCandWnd.right - max( rcCandWnd.right, rcUnion.right );
						cxOffset += rcCandWnd.left - min( rcCandWnd.left, rcUnion.left );
						break;
					}

					case CANDUIDIR_LEFTTORIGHT: {
						cxOffset += rcCandWnd.left - min( rcCandWnd.left, rcUnion.left );
						break;
					}
				}

				CalcWindowRect( &rc, &rcUnion, nWidth, nHeight, cxOffset, cyOffset, HAlign, VAlign );
			}
		}
	}

	ppt->x = rc.left;
	ppt->y = rc.top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mscandui\wpopup.h ===
//
// wpopup.h
//

#ifndef WPOPUP_H
#define WPOPUP_H

#include "private.h"
#include "mscandui.h"
#include "cuilib.h"

#include "cuicand.h"
#include "cuicand2.h"
#include "candmgr.h"
#include "candprop.h"

class CCandidateUI;
class CCandWindow;


//
// CCommentListItem
//  = comment list item object =
//

class CCommentListItem : public CListItemBase
{
public:
	CCommentListItem( int iCandItem, CCandidateItem *pCandItem )
	{
		Assert( pCandItem != NULL );

		m_iCandItem = iCandItem;
		m_pCandItem = pCandItem;
		m_nHeight   = 0;
	}

	virtual ~CCommentListItem( void )
	{
	}

	int GetICandItem( void )
	{
		return m_iCandItem;
	}

	CCandidateItem *GetCandidateItem( void )
	{
		return m_pCandItem;
	}

	void SetHeight( int nHeight )
	{
		m_nHeight = nHeight;
	}

	int GetHeight( void )
	{
		return m_nHeight;
	}

protected:
	int            m_iCandItem;
	CCandidateItem *m_pCandItem;
	int            m_nHeight;
};


//
// CUIFCommentList
//  = popup comment list obeject =
//

class CUIFCommentList : public CUIFListBase
{
public:
	CUIFCommentList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
	virtual ~CUIFCommentList( void );

	void AddCommentItem( CCommentListItem *pListItem );
	CCommentListItem *GetCommentItem( int iListItem );

	virtual void SetRect( const RECT *prc );
	void InitItemHeight( void );
	int GetTotalHeight( void );
	int GetMinimumWidth( void );

	void SetTitleFont( HFONT hFont );
	void SetTextFont( HFONT hFont );

protected:
	int   m_cyTitle;
	int   m_cyTitleMargin;
	int   m_cxCommentMargin;
	int   m_cyCommentMargin;
	HFONT m_hFontTitle;
	HFONT m_hFontText;

	//
	// CUIFListBase methods
	//
	virtual int GetItemHeight( int iItem );
	virtual void PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected );

	int PaintCommentProc( HDC hDC, const RECT *prc, LPCWSTR pwch, BOOL fCalcOnly );
	int CalcMinimumWidth( void );
	void CalcTitleHeight( void );
	void CalcItemHeight( void );
	void CalcItemHeightProc( HDC hDC, CCommentListItem *pListItem );
};


//
// CPopupCommentWindow
//  = candidate window base class =
//

class CPopupCommentWindow : public CUIFWindow,
							public CCandListEventSink,
							public CCandUIPropertyEventSink
{
public:
	CPopupCommentWindow( CCandWindow *pCandWnd, CCandidateUI *pCandUI );
	virtual ~CPopupCommentWindow( void );

	//
	// CUIFWindow methods
	//
	virtual LPCTSTR GetClassName( void );
	virtual LPCTSTR GetWndTitle( void );
	virtual CUIFObject *Initialize( void );
	virtual void Move( int x, int y, int nWidth, int nHeight );
	virtual LRESULT OnWindowPosChanged( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
	virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );
	virtual void OnCreate( HWND hWnd );
	virtual void OnNCDestroy( HWND hWnd );

	//
	// CCandListEventSink methods
	//
	virtual void OnSetCandidateList( void );
	virtual void OnClearCandidateList( void );
	virtual void OnCandItemUpdate( void );
	virtual void OnSelectionChanged( void );

	//
	// CCandUIPropertyEventSink methods
	//
	virtual void OnPropertyUpdated( CANDUIPROPERTY prop, CANDUIPROPERTYEVENT event );

	void DestroyWnd( void );
	void LayoutWindow( BOOL fResize = FALSE );
	int LayoutWindowProc( RECT *prcWnd );
	void OnCandWindowMove( BOOL fResetAnyway );

protected:
	CCandidateUI		*m_pCandUI;
	CCandWindow			*m_pCandWnd;
	CUIFWndFrame		*m_pWndFrame;
	CUIFWndCaption		*m_pCaption;
	CUIFCaptionButton	*m_pCloseBtn;
	CUIFCommentList		*m_pCommentList;
	HICON				m_hIconClose;
	BOOL				m_fUserMoved;

	void SetCommentListProc( void );
	void ClearCommentListProc( void );
	int CandItemFromListItem( int iListItem );
	void CalcPos( POINT *ppt, int nWidth, int nHeight );
};

#endif // WPOPUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\boolean.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    boolean.h

Abstract:

    This file defines the CBoolean Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _BOOLEAN_H_
#define _BOOLEAN_H_

class CBoolean
{
public:
    CBoolean()       { m_flag = FALSE; }


    void SetFlag()     { m_flag = TRUE; }
    void ResetFlag()   { m_flag = FALSE; }
    BOOL IsSetFlag()   { return   m_flag; }
    BOOL IsResetFlag() { return ! m_flag; }

private:
    BOOL    m_flag : 1;
};

#endif // _BOOLEAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\caret.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    caret.h

Abstract:

    This file defines the CCaret Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CARET_H_
#define _CARET_H_

#include "boolean.h"
#include "toggle.h"

class CCaret
{
public:
    CCaret();
    virtual ~CCaret();

public:
    HRESULT CreateCaret(HWND hParentWnd, SIZE caret_size);
    HRESULT DestroyCaret();
    HRESULT OnTimer();

    HRESULT SetCaretPos(POINT pos);
    HRESULT ShowCaret() { m_show.SetFlag(); return S_OK; }
    HRESULT HideCaret();

private:
    HRESULT InvertCaret();
    HRESULT UpdateCaretPos(POINT pos);

private:
    static const UINT_PTR TIMER_EVENT_ID = 0x4f83af91;

    HWND      m_hParentWnd;
    UINT_PTR  m_hCaretTimer;
    POINT     m_caret_pos;
    SIZE      m_caret_size;
    CBoolean  m_show;
    CToggle   m_toggle;
};

#endif // _CARET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\candpos.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    candpos.h

Abstract:

    This file defines the CCandidatePosition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CANDPOS_H_
#define _CANDPOS_H_

#include "imc.h"
#include "tls.h"
#include "ctxtcomp.h"
#include "context.h"
#include "uicomp.h"

class CCandidatePosition
{
public:
    CCandidatePosition(TfClientId tid,
                       Interface_Attach<ITfContext> pic,
                       LIBTHREAD* pLibTLS)
        : m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS)
    {
    }
    virtual ~CCandidatePosition() { }

    HRESULT GetCandidatePosition(IN IMCLock& imc,
                                 IN CicInputContext& CicContext,
                                 IN IME_UIWND_STATE uists,
                                 IN LANGID langid,
                                 OUT RECT* out_rcArea);

    HRESULT GetRectFromApp(IN IMCLock& imc,
                           IN CicInputContext& CicContext,
                           IN LANGID langid,
                           OUT RECT* out_rcArea);
private:

    HRESULT GetRectFromHIMC(IN IMCLock& imc,
                            IN BOOL  fCandForm,
                            IN DWORD dwStyle,
                            IN POINT* ptCurrentPos,
                            IN RECT* rcArea,
                            OUT RECT* out_rcArea);

    HRESULT GetCandidateArea(IN IMCLock& imc,
                             IN DWORD dwStyle,
                             IN POINT* ptCurrentPos,
                             IN RECT* rcArea,
                             OUT RECT* out_rcArea);

    HRESULT GetRectFromCompFont(IN IMCLock& imc,
                                IN POINT* ptCurrentPos,
                                OUT RECT* out_rcArea);

    HRESULT FindAttributeInCompositionString(IN IMCLock& imc,
                                             IN BYTE target_attribute,
                                             OUT CWCompCursorPos& wCursorPosition);


    DWORD GetCharPos(IMCLock& imc, LANGID langid);

    //
    // Edit session helper
    //
    HRESULT EscbGetTextAndAttribute(IMCLock& imc, CWCompString* wCompString, CWCompAttribute* wCompAttribute)
    {
        return ::EscbGetTextAndAttribute(imc, m_tid, m_ic, m_pLibTLS, wCompString, wCompAttribute);
    }

    HRESULT EscbGetCursorPosition(IMCLock& imc, CWCompCursorPos* wCursorPosition)
    {
        return ::EscbGetCursorPosition(imc, m_tid, m_ic, m_pLibTLS, wCursorPosition);
    }

    HRESULT EscbGetStartEndSelection(IMCLock& imc, CWCompCursorPos& wStartSelection, CWCompCursorPos& wEndSelection)
    {
        return ::EscbGetStartEndSelection(imc, m_tid, m_ic, m_pLibTLS, wStartSelection, wEndSelection);
    }

    //
    // Edit session friend
    //
private:
    friend HRESULT EscbGetTextAndAttribute(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                           CWCompString* wCompString,
                                           CWCompAttribute* wCompAttribute);
    friend HRESULT EscbGetCursorPosition(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                         CWCompCursorPos* wCursorPosition);
    friend HRESULT EscbGetStartEndSelection(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                            CWCompCursorPos& wStartSelection,
                                            CWCompCursorPos& wEndSelection);

private:
    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
};

#endif // _CANDPOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\cic.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cic.cpp

Abstract:

    This file implements the CicBridge Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "globals.h"
#include "template.h"
#include "cic.h"
#include "context.h"
#include "profile.h"
#include "funcprv.h"
#include "korimx.h"
#include "delay.h"
#include "tls.h"

//+---------------------------------------------------------------------------
//
// CicBridge::IUnknown::QueryInterface
// CicBridge::IUnknown::AddRef
// CicBridge::IUnknown::Release
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::QueryInterface(
    REFIID riid,
    void** ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfSysHookSink))
    {
        *ppvObj = static_cast<ITfSysHookSink*>(this);
    }
    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CicBridge::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CicBridge::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::ITfSysHookSink::OnPreFocusDIM
// CicBridge::ITfSysHookSink::OnSysShellProc
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::OnPreFocusDIM(
    HWND hWnd)
{
    return S_OK;
}

HRESULT
CicBridge::OnSysShellProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicBridge::ITfSysHookSink::OnSysKeyboardProc
//
//----------------------------------------------------------------------------

const DWORD TRANSMSGCOUNT = 256;

HRESULT
CicBridge::OnSysKeyboardProc(
    WPARAM wParam,
    LPARAM lParam)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::OnSysKeyboardProc. ptls==NULL."));
        return S_FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::OnSysKeyboardProc. ptim_P==NULL"));
        return S_FALSE;
    }

    BOOL fKeystrokeFeed;
    if (FAILED(ptim_P->IsKeystrokeFeedEnabled(&fKeystrokeFeed)))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::OnSysKeyboardProc. IsKeystrokeFeedEnabled return error."));
        return S_FALSE;
    }

    if (!fKeystrokeFeed)
    {
        return S_FALSE;
    }

    HWND hWnd = GetFocus();
    if (hWnd != NULL)
    {
        Interface<ITfDocumentMgr> pdimAssoc; 

        ptim_P->GetFocus(pdimAssoc);
        if ((ITfDocumentMgr*)pdimAssoc) {
            //
            // Check if it is our dim or app dim.
            //
            if (IsOwnDim((ITfDocumentMgr*)pdimAssoc))
            {
                //
                // Call ImmGetAppCompatFlags with NULL to get the global app compat flag.
                //
                DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
                if (dwImeCompatFlags & (IMECOMPAT_AIMM12 | IMECOMPAT_AIMM_LEGACY_CLSID | IMECOMPAT_AIMM12_TRIDENT))
                {
                    //
                    // AIMM aware apps.
                    //
                    HIMC hIMC = ImmGetContext(hWnd);
                    if (hIMC == NULL)
                    {
                        return S_FALSE;
                    }

#if 0
                    IMCLock imc(hIMC);
                    if (FAILED(imc.GetResult()))
                    {
                        return S_FALSE;
                    }

                    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
                    if (FAILED(imc_ctfime.GetResult()))
                    {
                        return S_FALSE;
                    }

                    if (DefaultKeyHandling(ptls, imc, imc_ctfime->m_pCicContext, (UINT)wParam), lParam)
                    {
                        return S_OK;
                    }
#else
                    BYTE abKbdState[256];

                    if (!GetKeyboardState(abKbdState))
                        return S_FALSE;

                    DWORD fdwProperty = ImmGetProperty(GetKeyboardLayout(0), IGP_PROPERTY);

                    if ((HIWORD(lParam) & KF_MENUMODE) ||
                        ((HIWORD(lParam) & KF_UP) && (fdwProperty & IME_PROP_IGNORE_UPKEYS)) ||
                        ((HIWORD(lParam) & KF_ALTDOWN) && !(fdwProperty & IME_PROP_NEED_ALTKEY)))
                        return S_FALSE;

                    HRESULT hr;

                    hr = ProcessKey(ptls, ptim_P, hIMC, (UINT)wParam, lParam, abKbdState) ? S_OK : S_FALSE;
                    if (hr == S_OK)
                    {
                        UINT uVirKey = (UINT)wParam & 0xffff;
                        INT iNum;

                        if (fdwProperty & IME_PROP_KBD_CHAR_FIRST)
                        {
                            if (fdwProperty & IME_PROP_UNICODE)
                            {
                                WCHAR wc;

                                iNum = ToUnicode(uVirKey,           // virtual-key code
                                                 HIWORD(lParam),    // scan code
                                                 abKbdState,        // key-state array
                                                 &wc,               // translated key buffer
                                                 1,                 // size
                                                 0);                // function option
                                if (iNum == 1)
                                {
                                    //
                                    // hi word            : unicode character code
                                    // hi byte of lo word : zero
                                    // lo byte of lo word : virtual key
                                    //
                                    uVirKey = (uVirKey & 0x00ff) | ((UINT)wc << 16);
                                }
                            }
                            else
                                Assert(0); // should have IME_PROP_UNICODE
                        }

                        DWORD dwSize = FIELD_OFFSET(TRANSMSGLIST, TransMsg)
                                     + TRANSMSGCOUNT * sizeof(TRANSMSG);

                        LPTRANSMSGLIST lpTransMsgList = (LPTRANSMSGLIST) new BYTE[dwSize];
                        if (lpTransMsgList == NULL)
                            return S_FALSE;

                        lpTransMsgList->uMsgCount = TRANSMSGCOUNT;

                        hr = ToAsciiEx(ptls, ptim_P, uVirKey, HIWORD(lParam), abKbdState, lpTransMsgList, 0, hIMC, (UINT *) &iNum);
                        if (iNum > TRANSMSGCOUNT)
                        {
                            //
                            // The message buffer is not big enough. IME put messages
                            // into hMsgBuf in the input context.
                            //
                            IMCLock imc(hIMC);
                            if (FAILED(imc.GetResult()))
                            {
                                delete [] lpTransMsgList;
                                return S_FALSE;
                            }

                            IMCCLock<TRANSMSG> pdw(imc->hMsgBuf);
                            if (FAILED(pdw.GetResult()))
                            {
                                delete [] lpTransMsgList;
                                return S_FALSE;
                            }

                            PostTransMsg(GetFocus(), iNum, pdw);
                        }
                        else if (iNum > 0)
                        {
                            IMCLock imc(hIMC);
                            if (FAILED(imc.GetResult()))
                            {
                                delete [] lpTransMsgList;
                                return S_FALSE;
                            }

                            PostTransMsg(GetFocus(), iNum, &lpTransMsgList->TransMsg[0]);
                        }

                        delete [] lpTransMsgList;
                    }

                    return hr;
#endif
                }
            }
        }
    }
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::InitIMMX
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::InitIMMX(
    TLS* ptls)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::InitIMMX entered."));

    if (m_fCicInit.IsSetFlag())
        return S_OK;

    //
    // Create ITfThreadMgr instance.
    //
    HRESULT hr;

    if (ptls->GetTIM() == NULL)
    {
        ITfThreadMgr*   ptim;
        ITfThreadMgr_P* ptim_P;

        //
        // ITfThreadMgr is per thread instance.
        //
        hr = TF_CreateThreadMgr(&ptim);
        if (hr != S_OK)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. TF_CreateThreadMgr==NULL"));
            Assert(0); // couldn't create tim!
            goto ExitError;
        }

        hr = ptim->QueryInterface(IID_ITfThreadMgr_P, (void **)&ptim_P);
        ptim->Release();

        if (hr != S_OK)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. IID_ITfThreadMgr_P==NULL"));
            Assert(0); // couldn't find ITfThreadMgr_P
            goto ExitError;
        }
        Assert(ptls->GetTIM() == NULL);
        ptls->SetTIM(ptim_P);                    // Set ITfThreadMgr instance in the TLS data.

        //
        // Create Thread Manager Event Sink Callback for detect Cicero Aware Apps.
        //
        if (m_pDIMCallback == NULL) {
            m_pDIMCallback = new CThreadMgrEventSink_DIMCallBack();
            if (m_pDIMCallback == NULL) {
                DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. CThreadMgrEventSink_DIMCallBack==NULL"));
                Assert(0); // couldn't create CThreadMgrEventSink_DIMCallBack
                goto ExitError;
            }
            m_pDIMCallback->SetCallbackDataPointer(m_pDIMCallback);
            m_pDIMCallback->_Advise(ptim_P);
        }
    }

    //
    // Create CicProfile instance.
    //
    if (ptls->GetCicProfile() == NULL)
    {
        //
        // ITfInputProcessorProfiles is per thread instance.
        //
        CicProfile* pProfile = new CicProfile;
        if (pProfile == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. pProfile==NULL"));
            Assert(0); // couldn't create profile
            goto ExitError;
        }
        ptls->SetCicProfile(pProfile);

        hr = pProfile->InitProfileInstance(ptls);
        if (FAILED(hr))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. InitProfileInstance==NULL"));
            Assert(0); // couldn't create profile
            goto ExitError;
        }
    }

    //
    // get the keystroke manager ready
    //
    if (FAILED(::GetService(ptls->GetTIM(), IID_ITfKeystrokeMgr_P, (IUnknown **)&m_pkm_P))) {
        DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. IID_ITfKeystrokeMgr==NULL"));
        Assert(0); // couldn't get ksm!
        goto ExitError;
    }

    // cleanup/error code assumes this is the last thing we do, doesn't call
    // UninitDAL on error
    if (FAILED(InitDisplayAttrbuteLib(&_libTLS)))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::InitIMMX. InitDisplayAttributeLib==NULL"));
        Assert(0); // couldn't init lib!
        goto ExitError;
    }

    m_fCicInit.SetFlag();


    //
    // Start Edit Subclasss.
    //
    // StartEditSubClass();

    return S_OK;

ExitError:
    UnInitIMMX(ptls);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// CicBridge::UnInitIMMX
//
//----------------------------------------------------------------------------

BOOL
CicBridge::UnInitIMMX(
    TLS* ptls)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::UnInitIMMX"));

    // clear the display lib
    UninitDisplayAttrbuteLib(&_libTLS);

    TFUninitLib_Thread(&_libTLS);

    // clear the keystroke mgr
    SafeReleaseClear(m_pkm_P);

    // clear the profile
    CicProfile* pProfile;
    if ((pProfile=ptls->GetCicProfile()) != NULL)
    {
        pProfile->Release();
        ptls->SetCicProfile(NULL);
    }

    // clear Thread Manager Event Sink Callback for detect Cicero Aware Apps.
    if (m_pDIMCallback) {
        m_pDIMCallback->_Unadvise();
        m_pDIMCallback->Release();
        m_pDIMCallback = NULL;
    }

    // clear the thread mgr
    ITfThreadMgr_P* ptim_P;
    if ((ptim_P=ptls->GetTIM()) != NULL)
    {
        SafeReleaseClear(ptim_P);
        ptls->SetTIM(NULL);
    }

    m_fCicInit.ResetFlag();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::ActivateMMX
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::ActivateIMMX(
    TLS *ptls,
    ITfThreadMgr_P* ptim_P)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::ActivateIMMX"));

    //
    // Activate thread manager
    //
    Assert(m_tfClientId == TF_CLIENTID_NULL);

    HRESULT hr;
    hr = ptim_P->ActivateEx(&m_tfClientId, TF_TMAE_NOACTIVATETIP);

    if (hr != S_OK)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ActivateIMMX. ptim_P->Activate==NULL"));
        Assert(0); // couldn't activate thread!
        m_tfClientId = TF_CLIENTID_NULL;
        return E_FAIL;
    }

    m_lCicActive++;


    if (m_lCicActive == 1)
    {
        Interface<ITfSourceSingle> SourceSingle;
        hr = ptim_P->QueryInterface(IID_ITfSourceSingle, (void**)SourceSingle);
        if (hr != S_OK)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::ActivateIMMX. IID_ITfSourceSingle==NULL"));
            Assert(0);
            DeactivateIMMX(ptls, ptim_P);
            return E_FAIL;
        }

        CFunctionProvider* pFunc = new CFunctionProvider(m_tfClientId);
        if (pFunc == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::ActivateIMMX. pFunc==NULL"));
            Assert(0);
            DeactivateIMMX(ptls, ptim_P);
            return E_FAIL;
        }

        SourceSingle->AdviseSingleSink(m_tfClientId, IID_ITfFunctionProvider, (ITfFunctionProvider*)pFunc);
        pFunc->Release();

        if (m_dimEmpty == NULL)
        {
            hr = ptim_P->CreateDocumentMgr(&m_dimEmpty);
            if (FAILED(hr))
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::ActivateIMMX. m_dimEmpty==NULL"));
                Assert(0);
                DeactivateIMMX(ptls, ptim_P);
                return E_FAIL;
            }

            //
            // mark this is an owned dim.
            //
            SetCompartmentDWORD(m_tfClientId, m_dimEmpty, 
                                GUID_COMPARTMENT_CTFIME_DIMFLAGS,
                                COMPDIMFLAG_OWNEDDIM, FALSE);

        }

        //
        // set ITfSysHookSink
        //
        ptim_P->SetSysHookSink(this);

        if (ptls->IsDeactivatedOnce())
        {
            ENUMIMC edimc;
            edimc.ptls = ptls;
            edimc._this = this;
            ImmEnumInputContext(0, 
                                EnumCreateInputContextCallback, 
                                (LPARAM)&edimc);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::DeactivateMMX
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::DeactivateIMMX(
    TLS *ptls,
    ITfThreadMgr_P* ptim_P)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::DeactivateIMMX"));

    if (m_fInDeactivate.IsSetFlag())
    {
        //
        // Prevent recursive call of CicBridge::DeactivateIMMX().
        // ptim_P->Deactivate() might call DestroyWindow() via some TIP's deactivation,
        // then imm32 ! CtfImmLastEnabledWndDestroy will call and this functoin also call again.
        // In this case, this function return S_FALSE. Caller won't call UninitIMMX.
        //
        return S_FALSE;
    }

    m_fInDeactivate.SetFlag();

    // Deactivate thread manager.
    if (m_tfClientId != TF_CLIENTID_NULL)
    {
        ENUMIMC edimc;
        edimc.ptls = ptls;
        edimc._this = this;
        ImmEnumInputContext(0, 
                            EnumDestroyInputContextCallback, 
                            (LPARAM)&edimc);
        ptls->SetDeactivatedOnce();

        Interface<ITfSourceSingle> SourceSingle;
        if (ptim_P->QueryInterface(IID_ITfSourceSingle, (void**)SourceSingle) == S_OK)
        {
            SourceSingle->UnadviseSingleSink(m_tfClientId, IID_ITfFunctionProvider);
        }

        m_tfClientId = TF_CLIENTID_NULL;
        while (m_lCicActive)
        {
            m_lCicActive--;
            ptim_P->Deactivate();
        }
    }

    //
    // clear empty dim
    //
    // Release DIM should after tim->Deactivate. #480603
    //
    // If msctf ! DLL_THREAD_DETACH already runs before this DeactivateIMMX via msctfime ! DLL_THREAD_DETACH (depended DLL_THREAD_DETACH calling order).
    // then msctf ! SYSTHREAD is already released by msctf ! FreeSYSTHREAD.
    //
    // In this time, msctf lost TIM list in SYSTHREAD then CThreadInputMgr::*_GetThis() returns NULL.
    // And below Release DIM, dtor CDocumentInputManager doesn't remove DIM object from tim->_rgdim array.
    // If Release DIM is before tim->Deactivate, some TIM might access DIM by tim->_rgdim array. But it DIM already released.
    //
    SafeReleaseClear(m_dimEmpty);


    //
    // reset ITfSysHookSink
    //
    ptim_P->SetSysHookSink(NULL);

    Assert(!m_lCicActive);

    m_fInDeactivate.ResetFlag();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicBridge::CreateInputContext
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::CreateInputContext(
    TLS* ptls,
    HIMC hImc)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::CreateInputContext"));

    HRESULT hr;

    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::CreateInputContext. imc==NULL"));
        return hr;
    }

    if (imc->hCtfImeContext == NULL)
    {
        HIMCC h = ImmCreateIMCC(sizeof(CTFIMECONTEXT));
        if (h == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::CreateInputContext. hCtfImeContext==NULL"));
            return E_OUTOFMEMORY;
        }
        imc->hCtfImeContext = h;
    }

    {
        IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
        if (FAILED(hr=imc_ctfime.GetResult()))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::CreateInputContext. imc_ctfime==NULL"));
            return hr;
        }

        if (imc_ctfime->m_pCicContext)
        {
            hr = S_OK;
        }
        else
        {
            CicInputContext* _pCicContext = new CicInputContext(_GetClientId(), _GetLibTLS(), hImc);
            if (_pCicContext == NULL)
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::CreateInputContext. _pCicContext==NULL"));
                hr = E_OUTOFMEMORY;
                goto out_of_block;
            }

            ITfThreadMgr_P* ptim_P;
            if ((ptim_P=ptls->GetTIM()) == NULL)
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::CreateInputContext. ptim_P==NULL"));
                _pCicContext->Release();
                imc_ctfime->m_pCicContext = NULL;
                hr = E_NOINTERFACE;
                goto out_of_block;
            }

            imc_ctfime->m_pCicContext = _pCicContext;

            hr = _pCicContext->CreateInputContext(ptim_P, imc);
            if (FAILED(hr))
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::CreateInputContext. _pCicContext->CreateInputContext==NULL"));
                _pCicContext->Release();
                imc_ctfime->m_pCicContext = NULL;
                goto out_of_block;
            }

            //
            // If this himc is already activated, we need to associate now.
            // IMM32 won't call ImmSetActiveContext().
            //
            if (imc->hWnd && (imc->hWnd == ::GetFocus()))
            {
                Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc_ctfime));
                SetAssociate(ptls, imc->hWnd, ptim_P, dim.GetPtr());
            }
        }
    }  // dtor imc_ctfime

out_of_block:
    if (FAILED(hr))
    {
        DestroyInputContext(ptls, hImc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::DestroyInputContext
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::DestroyInputContext(
    TLS* ptls,
    HIMC hImc)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::DestroyInputContext"));

    HRESULT hr;

    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::DestroyInputContext. imc==NULL"));
        return hr;
    }

    {
        IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
        if (FAILED(hr=imc_ctfime.GetResult()))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::DestroyInputContext. imc_ctfime==NULL"));
            goto out_of_block;
        }

        // 
        // #548378
        // 
        // stop resursion call of _pCicContext->DestroyInputContext().
        if (imc_ctfime->m_fInDestroy)
        {
            hr = S_OK;
            goto exit;
        }
        imc_ctfime->m_fInDestroy = TRUE;

        // imc->m_pContext may be NULL if ITfThreadMgr::Activate has not been called
        if (imc_ctfime->m_pCicContext == NULL)
            goto out_of_block;

        CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
        imc_ctfime->m_pCicContext = NULL;

        hr = _pCicContext->DestroyInputContext();

        _pCicContext->Release();
        imc_ctfime->m_pCicContext = NULL;

    }  // dtor imc_ctfime

out_of_block:
    if (imc->hCtfImeContext != NULL)
    {
        ImmDestroyIMCC(imc->hCtfImeContext);
        imc->hCtfImeContext = NULL;
        hr = S_OK;
    }

exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::SelectEx
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::SelectEx(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,        // using private for RequestPostponedLock
    HIMC hImc,
    BOOL fSelect,
    HKL hKL)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::SelectEx(hImc=%x, fSelect=%x, hKL=%x)"), hImc, fSelect, hKL);

    HRESULT hr;
    IMCLock imc(hImc);
    if (FAILED(hr = imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SelectEx. imc==NULL"));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SelectEx. imc_ctfime==NULL"));
        return hr;
    }

#ifdef UNSELECTCHECK
    if (_pAImeContext)
        _pAImeContext->m_fSelected = (dwFlags & AIMMP_SE_SELECT) ? TRUE : FALSE;
#endif UNSELECTCHECK

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;

    if (_pCicContext)
        _pCicContext->m_fSelectingInSelectEx.SetFlag();

    if (fSelect)
    {

        if (_pCicContext)
            _pCicContext->m_fOpenCandidateWindow.ResetFlag();     // TRUE: opening candidate list window.

        //
        // #501445
        //
        // If imc is open, update GUID_COMPARTMENT_KEYBOARD_OPENCLOSE.
        //
        if (imc->fOpen)
            OnSetOpenStatus(ptim_P, imc, *_pCicContext);

    }
    else {  // being unselected

        Interface_Attach<ITfContext> ic(GetInputContext(imc_ctfime));
        if (ic.Valid())
        {
            ptim_P->RequestPostponedLock(ic.GetPtr());
        }

    }

    if (_pCicContext)
        _pCicContext->m_fSelectingInSelectEx.ResetFlag();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::SetActiveContextAlways
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::SetActiveContextAlways(
    TLS* ptls,
    HIMC hImc,
    BOOL fOn,
    HWND hWnd,
    HKL  hKL)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::SetActiveContextEx(hImc=%x, fOn=%x, hWnd=%x)"), hImc, fOn, hWnd);

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. ptim_P==NULL"));
        return E_OUTOFMEMORY;
    }

    if (fOn && hImc != NULL)
    {
        HRESULT hr;
        IMCLock imc(hImc);
        if (FAILED(hr = imc.GetResult()))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. imc==NULL"));
            return hr;
        }

        IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
        if (FAILED(hr=imc_ctfime.GetResult()))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. imc_ctfime==NULL"));
            return hr;
        }

        if (hImc == ImmGetContext(hWnd)) {
            /*
             * Selecting hIMC has been current active hIMC,
             * then associate this DIM with the TIM.
             */
            Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc_ctfime));
            SetAssociate(ptls, imc->hWnd, ptim_P, dim.GetPtr());
        }
    }
    else
    {
        //
        // When focus killed, composition string should completed.
        //
        // This is just for non-EA keyboard layouts. For example, we don't 
        // have a specific way to finilize the composition string like 
        // we use Enter key on EA kayboard layout. So we need to have
        // a service to finalize the composition string at focus change
        // automatically. (This is similar to Korean behaviour.)
        //
        if (!fOn && hImc && !IS_EA_KBDLAYOUT(hKL))
        {
            HRESULT hr;
            IMCLock imc(hImc);
            if (FAILED(hr = imc.GetResult()))
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. imc==NULL"));
                return hr;
            }

            IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
            if (FAILED(hr=imc_ctfime.GetResult()))
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. imc_ctfime==NULL"));
                return hr;
            }

            //
            // #482346
            //
            // If we are updating compstr, we don't have to complete it. 
            // App change the focus druing it handles WM_IME_xxx messages.
            //
            if (imc_ctfime->m_pCicContext->m_fInCompComplete.IsResetFlag() &&
                imc_ctfime->m_pCicContext->m_fInUpdateComposition.IsResetFlag())
                ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);

        }

        //
        // #501449
        //
        // When Win32k.sys generates IMS_DEACTIVATECONTEXT, it does not
        // guarantee to generate IMS_ACTIVATECONTEXT. It always checks
        // (pwndReceive == pti->pq->spwndFocus) in xxxSendFocusMessage().
        //
        if (!fOn && (::GetFocus() == hWnd) && 
            hImc && (hImc == ImmGetContext(hWnd)))
        {
            return S_OK;
        }

        //
        // this new focus change performance improvement breaks some
        // assumption of IsRealIME() in AssociateContext in dimm\immapp.cpp.
        // Associate NULL dim under IsPresent() window has not been the case
        // AIMM1.2 handles. In fact, this breaks IE that calls
        // AssociateContext on the focus window that is IsPresent().
        //
#ifdef FOCUSCHANGE_PERFORMANCE
        //
        // set empty dim so no text store to simulate NULL-HIMC.
        //
        BOOL fUseEmptyDIM = FALSE;
        ITfDocumentMgr  *pdimPrev; // just to receive prev for now
        if (SUCCEEDED(m_tim->GetFocus(&pdimPrev)) && pdimPrev)
        {
            fUseEmptyDIM = TRUE;
            pdimPrev->Release();

        }

        SetAssociate(hWnd, fUseEmptyDIM ? m_dimEmpty : NULL);
#else
        SetAssociate(ptls, hWnd, ptim_P, m_dimEmpty);
#endif
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicBridge::IsDefaultIMCDim
//
//----------------------------------------------------------------------------

BOOL CicBridge::IsDefaultIMCDim(ITfDocumentMgr *pdim)
{
    HWND hDefImeWnd = ImmGetDefaultIMEWnd(NULL);
    HRESULT hr;

    //
    // Get the default hIMC of this thread.
    //
    // Assume none associate any hIMC to the default IME window.
    //
    IMCLock imc(ImmGetContext(hDefImeWnd));
    if (FAILED(hr = imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. imc==NULL"));
        return FALSE;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetActiveContextEx. imc_ctfime==NULL"));
        return FALSE;
    }

    Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc_ctfime));
    
    if (dim.GetPtr() == pdim)
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::SetAssociate
//
//----------------------------------------------------------------------------

VOID
CicBridge::SetAssociate(
    TLS* ptls,
    HWND hWnd,
    ITfThreadMgr_P* ptim_P,
    ITfDocumentMgr* pdim)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::SetAssociate"));

    if (m_fOnSetAssociate.IsSetFlag()) {
        /*
         * Prevent reentrance call from m_tim->AssociateFocus.
         */
        return;
    }

    m_fOnSetAssociate.SetFlag();

    if (::IsWindow(hWnd) && m_fCicInit.IsSetFlag()) {
        ITfDocumentMgr  *pdimPrev = NULL; // just to receive prev for now
        ITfDocumentMgr  *pdimAssoc = NULL; 
        BOOL fIsAssociated = FALSE;

        ptim_P->GetAssociated(hWnd, &pdimAssoc);
        if (pdimAssoc) {
            //
            // Check if it is our dim or app dim.
            //
            if (!IsOwnDim(pdimAssoc))
                fIsAssociated = TRUE;

            SafeReleaseClear(pdimAssoc);
        }

        //
        // If an app dim is associated to hWnd, msctf.dll will do SetAssociate().
        //
        if (!fIsAssociated)
        {
            ptim_P->AssociateFocus(hWnd, pdim, &pdimPrev);

            //
            // #610113
            //
            // if pdimPrev is DIM for the default hIMC, we need to associate
            // a window to the dim. If the dim is not associated to any
            // window, Cicero thinks it is the dim for Cicero native app
            // so it skips to do _SetFocus().
            //
            if (pdimPrev)
            {
                if (IsDefaultIMCDim(pdimPrev))
                {
                    ITfDocumentMgr  *pdimDefPrev = NULL;
                    HWND hDefImeWnd = ImmGetDefaultIMEWnd(NULL);
                    ptim_P->AssociateFocus(hDefImeWnd, pdimPrev, &pdimDefPrev);
                    if (pdimDefPrev)
                        pdimDefPrev->Release();
                }
                pdimPrev->Release();
            }

            //
            // If pdim is the focus dim, we call CTFDetection() to check
            // the focus change between AIMM12, Cicero controls.
            //
            Interface<ITfDocumentMgr> pdimFocus; 
            ptim_P->GetFocus(pdimFocus);
            if ((ITfDocumentMgr *)pdimFocus == pdim)
                CTFDetection(ptls, pdim);
        }

    }

    m_fOnSetAssociate.ResetFlag();
}

//+---------------------------------------------------------------------------
//
// CicBridge::IsOwnDim
//
//----------------------------------------------------------------------------

BOOL CicBridge::IsOwnDim(ITfDocumentMgr *pdim)
{
    HRESULT hr;
    DWORD dwFlags;

    hr = GetCompartmentDWORD(pdim, GUID_COMPARTMENT_CTFIME_DIMFLAGS,
                             &dwFlags, FALSE);
                
    if (SUCCEEDED(hr))
        return (dwFlags & COMPDIMFLAG_OWNEDDIM) ? TRUE : FALSE;

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// CicBridge::ProcessKey
//
//----------------------------------------------------------------------------

BOOL
CicBridge::ProcessKey(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,        // using private for RequestPostponedLock
    HIMC hIMC,
    UINT uVirtKey,
    LPARAM lParam,
    CONST LPBYTE lpbKeyState)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::ProcessKey"));

    BOOL fEaten;
    BOOL fKeysEnabled;
    HRESULT hr;
    BOOL fRet;

#if 0
    // has anyone disabled system key feeding?
    if (ptim_P->IsKeystrokeFeedEnabled(&fKeysEnabled) == S_OK && !fKeysEnabled)
        return FALSE;
#endif

    if (uVirtKey == VK_PROCESSKEY)
    {
        LANGID langid;
        CicProfile* _pProfile = ptls->GetCicProfile();

        if (_pProfile == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::ProcessKey. _pProfile==NULL."));
        }
        else
        {
            _pProfile->GetLangId(&langid);

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
            {
                return TRUE;
            }
        }
    }

    hr = m_pkm_P->KeyDownUpEx(uVirtKey, lParam, (DWORD)TF_KEY_MSCTFIME | TF_KEY_TEST, &fEaten);

    if (hr == S_OK && fEaten) {
        return TRUE;
    }

    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
    {
        return FALSE;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        return FALSE;
    }

    //
    // m_fGeneratedEndComposition should be set only when m_fInProcessKey 
    // is set.
    //
    Assert(imc_ctfime->m_pCicContext->m_fGeneratedEndComposition.IsResetFlag());
    imc_ctfime->m_pCicContext->m_fInProcessKey.SetFlag();

    if (!fEaten)
    {
        if (imc_ctfime->m_pCicContext &&
            ptim_P != NULL)
        {
            ptim_P->RequestPostponedLock(imc_ctfime->m_pCicContext->GetInputContext());
        }
    }


    if ((HIWORD(lParam) & KF_UP) ||
        (HIWORD(lParam) & KF_ALTDOWN)) {
        fRet = FALSE;
    }
    else
        fRet = DefaultKeyHandling(ptls, imc, imc_ctfime->m_pCicContext, uVirtKey, lParam);

    imc_ctfime->m_pCicContext->m_fGeneratedEndComposition.ResetFlag();
    imc_ctfime->m_pCicContext->m_fInProcessKey.ResetFlag();

    return fRet;
}

//+---------------------------------------------------------------------------
//
// CicBridge::ToAsciiEx
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::ToAsciiEx(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,        // using private for RequestPostponedLock
    UINT uVirtKey,
    UINT uScanCode,
    CONST LPBYTE lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT fuState,
    HIMC hIMC,
    UINT *uNum)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::ToAsciiEx"));

    BOOL fEaten;
    HRESULT hr;

    *uNum = 0;

    Assert(ptim_P);

    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ToAsciiEx. imc==NULL"));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ToAsciiEx. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    ASSERT(_pCicContext != NULL);
    if (! _pCicContext)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ToAsciiEx. _pCicContext==NULL"));
        return S_FALSE;
    }

    //
    // Backup the m_fOpenCandidateWindow flag.
    // If open the candidate list and press "Cancel" key, Kana TIP would want to
    // close candidate UI window in the KeyDown() action.
    // Candidate UI calss maybe call m_pdim->Pop() and this function notify to
    // the ThreadMgrEventSinkCallback.
    // Win32 layer advised this callback and toggled m_fOpenCandidateWindow flag.
    // Win32 layer doesn't know candidate status after KeyDown() call.
    //
    BOOL fOpenCandidateWindow = _pCicContext->m_fOpenCandidateWindow.IsSetFlag();

    //
    // If candidate window were open, send IMN_CHANGECANDIDATE message.
    // In the case of PPT's centering composition string, it expect IMN_CHANGECANDIDATE.
    //
    if (fOpenCandidateWindow &&
        *uNum < lpTransBuf->uMsgCount) {
        TRANSMSG* pTransMsg = &lpTransBuf->TransMsg[*uNum];
        pTransMsg->message = WM_IME_NOTIFY;
        pTransMsg->wParam  = IMN_CHANGECANDIDATE;
        pTransMsg->lParam  = 1;  // bit 0 to first candidate list.
        (*uNum)++;
    }

    //
    // AIMM put char code in hiword. So we need to bail it out.
    //
    // if we don't need charcode, we may want to
    // remove IME_PROP_KBD_CHAR_FIRST.
    //
    uVirtKey = uVirtKey & 0xffff;

    if (uVirtKey == VK_PROCESSKEY)
    {
        /*
         * KOREAN:
         *  Finalize current composition string
         */
        LANGID langid;
        CicProfile* _pProfile = ptls->GetCicProfile();
        if (_pProfile == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::ToAsciiEx. _pProfile==NULL."));
        }
        else
        {
            _pProfile->GetLangId(&langid);

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
            {
                //
                // Composition complete.
                //
                _pCicContext->EscbCompComplete(imc);

                //
                // #506324
                //
                // we don't want to eat this VK_PROCESSKEY. So we don't
                // stop generating VK_LBUTTONDOWN.
                // Because we don't generate any message here, it is ok
                // to return S_FALSE;
                //
                return S_FALSE;
            }
        }
    }

    Interface<ITfContext_P> icp;
    hr = _pCicContext->GetInputContext()->QueryInterface(IID_ITfContext_P, 
                                                         (void **)icp);

    if (hr != S_OK)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ToAsciiEx. QueryInterface failed"));
        return hr;
    }

    imc_ctfime->m_pCicContext->m_fInToAsciiEx.SetFlag();

    //
    // stop posting LockRequest message and we call RequestPostponedLock 
    // forcefully so we don't have to have unnecessary PostThreadMessage().
    //
    // some application detect the unknown message in the queue and 
    // do much
    //
    icp->EnableLockRequestPosting(FALSE);

    //
    // consider: dimm12 set high bit oflower WORD at keyup.
    //
    hr = m_pkm_P->KeyDownUpEx(uVirtKey, (uScanCode << 16), TF_KEY_MSCTFIME, &fEaten);

    icp->EnableLockRequestPosting(TRUE);

    //
    // enpty the edit session queue of the ic.
    //
    ptim_P->RequestPostponedLock(icp);

    imc_ctfime->m_pCicContext->m_fInToAsciiEx.ResetFlag();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::ProcessCicHotkey
//
//----------------------------------------------------------------------------

BOOL
CicBridge::ProcessCicHotkey(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,        // using private for RequestPostponedLock
    HIMC hIMC,
    UINT uVirtKey,
    LPARAM lParam)
{
    if (!CtfImmIsCiceroStartedInThread()) {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ProcessCicHotkey. StopImm32HotkeyHandler returns Error."));
        return FALSE;
    }

    HRESULT hr;
    BOOL bHandled;

    hr = ptim_P->CallImm32HotkeyHanlder((WPARAM)uVirtKey, lParam, &bHandled);

    if (FAILED(hr)) {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ProcessCicHotkey. CallImm32HotkeyHandler returns Error."));
        return FALSE;
    }

    return bHandled;
}

//+---------------------------------------------------------------------------
//
// CicBridge::Notify
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::Notify(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,
    HIMC hIMC,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::Notify(hIMC=%x, dwAction=%x, dwIndex=%x, dwValue=%x)"), hIMC, dwAction, dwIndex, dwValue);

    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::Notify. imc==NULL"));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::Notify. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::Notify. _pCicContext==NULL."));
        return E_OUTOFMEMORY;
    }

    LANGID langid;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::Notify. _pProfile==NULL."));
        return E_OUTOFMEMORY;
    }

    _pProfile->GetLangId(&langid);

    switch (dwAction) {

        case NI_CONTEXTUPDATED:
            switch (dwValue) {
                case IMC_SETOPENSTATUS:
                    return OnSetOpenStatus(ptim_P, imc, *_pCicContext);

                case IMC_SETCONVERSIONMODE:
                case IMC_SETSENTENCEMODE:
                    return OnSetConversionSentenceMode(ptim_P, imc, *_pCicContext, dwValue, langid);

                case IMC_SETCOMPOSITIONWINDOW:
                case IMC_SETCOMPOSITIONFONT:
                    return E_NOTIMPL;

                case IMC_SETCANDIDATEPOS:
                    return _pCicContext->OnSetCandidatePos(ptls, imc);

                default:
                    return E_FAIL;
            }
            break;

        case NI_COMPOSITIONSTR:
            switch (dwIndex) {
                case CPS_COMPLETE:
                    _pCicContext->EscbCompComplete(imc);
                    return S_OK;

                case CPS_CONVERT:
                case CPS_REVERT:
                    return E_NOTIMPL;

                case CPS_CANCEL:
                    _pCicContext->EscbCompCancel(imc);
                    return S_OK;

                default:
                    return E_FAIL;
            }
            break;

        case NI_OPENCANDIDATE:
            if (PRIMARYLANGID(langid) == LANG_KOREAN)
            {
                if (DoOpenCandidateHanja(ptim_P, imc, *_pCicContext))
                    return S_OK;
                else
                    return E_FAIL;
            }
        case NI_CLOSECANDIDATE:
        case NI_SELECTCANDIDATESTR:
        case NI_CHANGECANDIDATELIST:
        case NI_SETCANDIDATE_PAGESIZE:
        case NI_SETCANDIDATE_PAGESTART:
        case NI_IMEMENUSELECTED:
            return E_NOTIMPL;

        default:
            break;
    }
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// CicBridge::OnSetOpenStatus
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::OnSetOpenStatus(
    ITfThreadMgr_P* ptim_P,
    IMCLock& imc,
    CicInputContext& CicContext)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::OnSetOpenStatus"));

    if (! imc->fOpen && imc.ValidCompositionString())
    {
        //
        // #503401 - Finalize the composition string.
        //
        CicContext.EscbCompComplete(imc);
    }

    CicContext.m_fOpenStatusChanging.SetFlag();
    HRESULT hr =  SetCompartmentDWORD(m_tfClientId,
                                      ptim_P,
                                      GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                      imc->fOpen,
                                      FALSE);
    CicContext.m_fOpenStatusChanging.ResetFlag();
    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::OnSetConversionSentenceMode
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::OnSetConversionSentenceMode(
    ITfThreadMgr_P* ptim_P,
    IMCLock& imc,
    CicInputContext& CicContext,
    DWORD dwValue,
    LANGID langid)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::OnSetConversionSentenceMode"));

    CicContext.m_fOnceModeChanged.SetFlag();
    CicContext.m_fConversionSentenceModeChanged.SetFlag();
    Interface_Attach<ITfContextOwnerServices> iccb(CicContext.GetInputContextOwnerSink());

    if (dwValue == IMC_SETCONVERSIONMODE)
    {
        CicContext.m_nInConversionModeChangingRef++;

        if (PRIMARYLANGID(langid) == LANG_JAPANESE)
        {
            if (imc->fdwSentence == IME_SMODE_PHRASEPREDICT) {
                CicContext.m_nInConversionModeResetRef++;
                iccb->OnAttributeChange(GUID_PROP_MODEBIAS);
                CicContext.m_nInConversionModeResetRef--;
            }
        }
    }

    //
    // If we're in EscHanjaMode, we already makes Reconversion. So
    // we don't have to make AttributeChange for IMC_CMODE_HANJACONVERT.
    //
    BOOL fSkipOnAttributeChange = FALSE;
    if ((PRIMARYLANGID(langid) == LANG_KOREAN) &&
        CicContext.m_fHanjaReConversion.IsSetFlag())
    {
        fSkipOnAttributeChange = TRUE;
    }

    // let cicero know the mode bias has changed
    // consider: perf: we could try to filter out false-positives here
    // (sometimes a bit that cicero ignores changes, we could check and avoid the call,
    // but it would complicate the code)
    if (!fSkipOnAttributeChange)
         iccb->OnAttributeChange(GUID_PROP_MODEBIAS);

    //
    // let Korean Tip sync up the current mode status changing...
    //
    if (PRIMARYLANGID(langid) == LANG_KOREAN)
    {
        OnSetKorImxConversionMode(ptim_P, imc, CicContext);
    }

    if (dwValue == IMC_SETCONVERSIONMODE)
        CicContext.m_nInConversionModeChangingRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicBridge::OnSetKorImxConversionMode
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::OnSetKorImxConversionMode(
    ITfThreadMgr_P* ptim_P,
    IMCLock& imc,
    CicInputContext& CicContext)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::OnSetKorImxConversionMode"));

    DWORD fdwConvMode = 0;

    CicContext.m_fKorImxModeChanging.SetFlag();

    if (imc->fdwConversion & IME_CMODE_HANGUL)
    {
        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
            fdwConvMode = KORIMX_HANGULJUNJA_MODE;
        else
            fdwConvMode = KORIMX_HANGUL_MODE;
    }
    else
    {
        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
            fdwConvMode = KORIMX_JUNJA_MODE;
        else
            fdwConvMode = KORIMX_ALPHANUMERIC_MODE;
    }

    HRESULT hr =  SetCompartmentDWORD(m_tfClientId,
                                      ptim_P,
                                      GUID_COMPARTMENT_KORIMX_CONVMODE,
                                      fdwConvMode,
                                      FALSE);
    CicContext.m_fKorImxModeChanging.ResetFlag();

    return hr;
}


//+---------------------------------------------------------------------------
//
// CicBridge::ConfigureGeneral
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::ConfigureGeneral(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,
    HKL hKL,
    HWND hAppWnd)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::ConfigureGeneral"));

    TF_LANGUAGEPROFILE LanguageProfile;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureGeneral. _pProfile==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    hr = _pProfile->GetActiveLanguageProfile(hKL,
                                             GUID_TFCAT_TIP_KEYBOARD,
                                             &LanguageProfile);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureGeneral. LanguageProfile==NULL."));
        return hr;
    }

    Interface<ITfFunctionProvider> pFuncProv;
    hr = ptim_P->GetFunctionProvider(LanguageProfile.clsid,    // CLSID of tip
                                     pFuncProv);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureGeneral. pFuncProv==NULL."));
        return hr;
    }

    Interface<ITfFnConfigure> pFnConfigure;
    hr = pFuncProv->GetFunction(GUID_NULL,
                                IID_ITfFnConfigure,
                                (IUnknown**)(ITfFnConfigure**)pFnConfigure);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureGeneral. pFnCofigure==NULL."));
        return hr;
    }

    hr = pFnConfigure->Show(hAppWnd,
                            LanguageProfile.langid,
                            LanguageProfile.guidProfile);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::ConfigureGeneral
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::ConfigureRegisterWord(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,
    HKL hKL,
    HWND hAppWnd,
    REGISTERWORDW* pRegisterWord)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::ConfigureRegisterWord"));

    TF_LANGUAGEPROFILE LanguageProfile;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureRegisterWord. _pProfile==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    hr = _pProfile->GetActiveLanguageProfile(hKL,
                                             GUID_TFCAT_TIP_KEYBOARD,
                                             &LanguageProfile);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureRegisterWord. LanguageProfile==NULL."));
        return hr;
    }

    Interface<ITfFunctionProvider> pFuncProv;
    hr = ptim_P->GetFunctionProvider(LanguageProfile.clsid,    // CLSID of tip
                                     pFuncProv);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureRegisterWord. pFuncProv==NULL."));
        return hr;
    }

    Interface<ITfFnConfigureRegisterWord> pFnRegisterWord;
    hr = pFuncProv->GetFunction(GUID_NULL,
                                IID_ITfFnConfigureRegisterWord,
                                (IUnknown**)(ITfFnConfigureRegisterWord**)pFnRegisterWord);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ConfigureRegisterWord. pFnRegisterWord==NULL."));
        return hr;
    }

    if (!pRegisterWord || !pRegisterWord->lpWord)
    {
        hr = pFnRegisterWord->Show(hAppWnd,
                                   LanguageProfile.langid,
                                   LanguageProfile.guidProfile,
                                   NULL);
    }
    else
    {
        BSTR bstrWord = SysAllocString(pRegisterWord->lpWord);
        if (!bstrWord)
            return E_OUTOFMEMORY;

        hr = pFnRegisterWord->Show(hAppWnd,
                                   LanguageProfile.langid,
                                   LanguageProfile.guidProfile,
                                   bstrWord);

        SysFreeString(bstrWord);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::EscapeKorean
//
//----------------------------------------------------------------------------

LRESULT
CicBridge::EscapeKorean(
    TLS* ptls,
    HIMC hImc,
    UINT uSubFunc,
    LPVOID lpData)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::EscapeKorean"));

    switch (uSubFunc)
    {
        case IME_ESC_QUERY_SUPPORT:
            switch (*(LPUINT)lpData)
            {
                case IME_ESC_HANJA_MODE:    return TRUE;
                default:                    return FALSE;
            }
            break;

        case IME_ESC_HANJA_MODE:
            return EscHanjaMode(ptls, hImc, (LPWSTR)lpData);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::EscHanjaMode
//
//----------------------------------------------------------------------------

LRESULT
CicBridge::EscHanjaMode(
    TLS* ptls,
    HIMC hImc,
    LPWSTR lpwStr)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::EscHanjaMode"));

    HRESULT hr;
    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::EscHanjaMode. imc==NULL"));
        return FALSE;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::EscHanjaMode. imc_ctfime==NULL"));
        return FALSE;
    }

    CicInputContext* pCicContext = imc_ctfime->m_pCicContext;
    if (pCicContext)
    {
        //
        // This is for only Excel since Excel calling Hanja escape function two
        // times. we going to just ignore the second request not to close Hanja
        // candidate window.
        //
        if (pCicContext->m_fOpenCandidateWindow.IsSetFlag())
        {
            //
            // Need to set the result value since some apps(Trident) also call
            // Escape() twice and expect the right result value.
            //
            return TRUE;
        }

        pCicContext->m_fHanjaReConversion.SetFlag();
    }

    CWReconvertString wReconvStr(imc);
    wReconvStr.WriteCompData(lpwStr, 1);

    BOOL fCompMem = FALSE;
    LPRECONVERTSTRING lpReconvertString = NULL;
    DWORD dwLen = wReconvStr.ReadCompData();
    if (dwLen) {
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];
        if (lpReconvertString) {
            fCompMem = TRUE;
            wReconvStr.ReadCompData(lpReconvertString, dwLen);
        }
    }

    LRESULT ret;
    ret = ImmSetCompositionStringW(hImc, SCS_QUERYRECONVERTSTRING, lpReconvertString, dwLen, NULL, 0);
    if (ret) {
        ret = ImmSetCompositionStringW(hImc, SCS_SETRECONVERTSTRING, lpReconvertString, dwLen, NULL, 0);
        if (ret) {
            ret = ImmSetConversionStatus(hImc, imc->fdwConversion | IME_CMODE_HANJACONVERT,
                                               imc->fdwSentence);
        }
    }

    if (pCicContext)
    {
        //
        // enpty the edit session queue of the ic.
        //
        ITfThreadMgr_P* ptim_P;

        if (ptls != NULL && ((ptim_P = ptls->GetTIM()) != NULL))
        {
            Interface<ITfContext_P> icp;
            hr = pCicContext->GetInputContext()->QueryInterface(IID_ITfContext_P, 
                                                                (void **)icp);
            if (hr == S_OK)
                ptim_P->RequestPostponedLock(icp);  
            else
                DebugMsg(TF_ERROR, TEXT("CicBridge::EscHanjaMode. QueryInterface is failed"));
        }
        else
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::EscHanjaMode. ptls or ptim_P==NULL"));
        }
        
        pCicContext->m_fHanjaReConversion.ResetFlag();
    }


    if (fCompMem)
        delete [] lpReconvertString;

    return ret;
}

//+---------------------------------------------------------------------------
//
// CicBridge::DoOpenCandidateHanja
//
//----------------------------------------------------------------------------

LRESULT
CicBridge::DoOpenCandidateHanja(
    ITfThreadMgr_P* ptim_P,
    IMCLock& imc,
    CicInputContext& CicContext)
{
    BOOL fRet = FALSE;

    DebugMsg(TF_FUNC, TEXT("CicBridge::DoOpenCandidateHanja"));


    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);

    if (SUCCEEDED(comp.GetResult()) && comp->dwCompStrLen)
    {
        //
        // This is for only Excel since Excel calling Hanja escape function two
        // times. we going to just ignore the second request not to close Hanja
        // candidate window.
        //
        if (CicContext.m_fOpenCandidateWindow.IsSetFlag())
        {
            //
            // Need to set the result value since some apps(Trident) also call
            // Escape() twice and expect the right result value.
            //
            return TRUE;
        }

        CicContext.m_fHanjaReConversion.SetFlag();

        HRESULT hr;
        Interface<ITfRange> Selection;
        Interface<ITfFunctionProvider> FuncProv;
        Interface<ITfFnReconversion> Reconversion;

        hr = CicContext.EscbGetSelection(imc, &Selection);
        if (FAILED(hr))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::DoOpenCandidateHanja. EscbGetSelection failed"));
            goto Exit;
        }

        hr = ptim_P->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
        if (FAILED(hr))
        {
            DebugMsg(TF_ERROR, TEXT("CicBridge::DoOpenCandidateHanja. FuncProv==NULL"));
            goto Exit;
        }

        hr = FuncProv->GetFunction(GUID_NULL,
                                   IID_ITfFnReconversion,
                                   (IUnknown**)(ITfFnReconversion**)Reconversion);
        if (SUCCEEDED(hr))
        {
            Interface<ITfRange> RangeNew;
            BOOL fConvertable;

            hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
            if (SUCCEEDED(hr) && fConvertable)
            {
                //
                // Tip has a chance to close Hanja candidate UI window during
                // the changes of conversion mode, so update conversion status
                // first.
                //
                ImmSetConversionStatus(imc, imc->fdwConversion | IME_CMODE_HANJACONVERT,
                                       imc->fdwSentence);

                hr = Reconversion->Reconvert(RangeNew);
                if (FAILED(hr))
                {
                    ImmSetConversionStatus(imc,
                                           imc->fdwConversion & ~IME_CMODE_HANJACONVERT,
                                           imc->fdwSentence);
                }
            }
            else
            {
                DebugMsg(TF_ERROR, TEXT("CicBridge::DoOpenCandidateHanja. QueryRange failed so the compoisiton string will be completed."));

                CicContext.EscbCompComplete(imc);
                goto Exit;
            }
        }

        fRet = TRUE;
Exit:
        CicContext.m_fHanjaReConversion.ResetFlag();
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// CicBridge::SetCompositionString
//
//----------------------------------------------------------------------------

BOOL
CicBridge::SetCompositionString(
    TLS* ptls,
    ITfThreadMgr_P* ptim_P,
    HIMC hImc,
    DWORD dwIndex,
    void* pComp,
    DWORD dwCompLen,
    void* pRead,
    DWORD dwReadLen)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::SetCompositionString"));

    HRESULT hr;
    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetCompositionString. imc==NULL"));
        return FALSE;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetCompositionString. imc_ctfime==NULL"));
        return FALSE;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetCompositionString. _pCicContext==NULL."));
        return FALSE;
    }

    UINT cp;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::SetCompositionString. _pProfile==NULL."));
        return FALSE;
    }

    _pProfile->GetCodePageA(&cp);

    if (dwIndex == SCS_SETSTR &&
        pComp != NULL && (*(LPWSTR)pComp) == L'\0' && dwCompLen != 0)
    {
        LANGID langid;
        hr = _pProfile->GetLangId(&langid);

        //
        // Bug#580455 - Some korean specific apps calls it for completing
        // the current composition immediately.
        //
        if (SUCCEEDED(hr) && PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            if (imc->fdwConversion & IME_CMODE_HANGUL)
            {
                ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                return TRUE;        
            }
            else
            {
                return FALSE;                            
            }
        }
    }

    return _pCicContext->SetCompositionString(imc, ptim_P, dwIndex, pComp, dwCompLen, pRead, dwReadLen, cp);
}

//+---------------------------------------------------------------------------
//
// CicBridge::GetGuidAtom
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::GetGuidAtom(
    TLS* ptls,
    HIMC hImc,
    BYTE bAttr,
    TfGuidAtom* atom)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::GetGuidAtom"));

    HRESULT hr;
    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::GetGuidAtom. imc==NULL"));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::GetGuidAtom. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::GetGuidAtom. _pCicContext==NULL."));
        return E_OUTOFMEMORY;
    }

    return _pCicContext->GetGuidAtom(imc, bAttr, atom);
}

//+---------------------------------------------------------------------------
//
// CicBridge::GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT
CicBridge::GetDisplayAttributeInfo(
    TfGuidAtom atom,
    TF_DISPLAYATTRIBUTE* da)
{
    HRESULT hr = E_FAIL;
    GUID guid;
    GetGUIDFromGUIDATOM(&_libTLS, atom, &guid);

    Interface<ITfDisplayAttributeInfo> dai;
    CLSID clsid;
    ITfDisplayAttributeMgr* dam = GetDAMLib(&_libTLS);
    if (dam != NULL)
    {
        if (SUCCEEDED(hr=dam->GetDisplayAttributeInfo(guid, dai, &clsid)))
        {
            dai->GetAttributeInfo(da);
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CicBridge::DefaultKeyHandling
//
//----------------------------------------------------------------------------

BOOL
CicBridge::DefaultKeyHandling(
    TLS* ptls,
    IMCLock& imc,
    CicInputContext* CicContext,
    UINT uVirtKey,
    LPARAM lParam)
{
    if (CicContext == NULL)
        return FALSE;

    LANGID langid;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicBridge::DefaultKeyHandling. _pProfile==NULL."));
        return FALSE;
    }

    HRESULT hr = _pProfile->GetLangId(&langid);

    if (SUCCEEDED(hr) && PRIMARYLANGID(langid) == LANG_KOREAN)
    {
        if (!MsimtfIsWindowFiltered(::GetFocus()) &&
            (CicContext->m_fGeneratedEndComposition.IsSetFlag() || uVirtKey == VK_HANJA))
        {
            //
            // Korean IME alwaus generate WM_IME_KEYDOWN message
            // if it finalizes the interim char in order to keep message
            // order.
            //
            PostMessage(imc->hWnd, WM_IME_KEYDOWN, uVirtKey, lParam);
            return TRUE;
        }

        //
        // Korean won't _WantThisKey / _HandleThisKey
        //
        return FALSE;
    }

    if (! (HIWORD(uVirtKey) & KF_UP)) {
        if (CicContext->WantThisKey(uVirtKey)) {
            CicContext->EscbHandleThisKey(imc, uVirtKey);
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::CTFDetection
//
//----------------------------------------------------------------------------

BOOL
CicBridge::CTFDetection(
    TLS* ptls, 
    ITfDocumentMgr* dim)
{
    HRESULT hr;

    //
    // Get TIM
    //
    ITfThreadMgr_P* ptim_P;
    if ((ptim_P=ptls->GetTIM()) == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CThreadMgrEventSink_DIMCallBack::DIMCallback. ptim_P==NULL"));
        return FALSE;
    }

    //
    // Get cskf
    //
    Interface<ITfConfigureSystemKeystrokeFeed> cskf;
    hr = ptim_P->QueryInterface(IID_ITfConfigureSystemKeystrokeFeed, (void**)cskf);
    if (hr != S_OK)
    {
        DebugMsg(TF_ERROR, TEXT("CThreadMgrEventSink_DIMCallBack::DIMCallback. IID_ITfConfigureSystemKeystrokeFeed==NULL"));
        return FALSE;
    }

    BOOL fEnableKeystrokeFeed = FALSE;

    //
    // Cicero aware application detection...
    //
    // if dim is NULL, it is not Ciceor aware apps document.
    //
    if (!dim || IsOwnDim(dim))
    {
        //
        // CTFIME owns document
        //
        fEnableKeystrokeFeed = FALSE;
        ptls->ResetCTFAware();
    }
    else
    {
        fEnableKeystrokeFeed = TRUE;
        ptls->SetCTFAware();
    }

    //
    // Call ImmGetAppCompatFlags with NULL to get the global app compat flag.
    //
    DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
    if (dwImeCompatFlags & (IMECOMPAT_AIMM12 | IMECOMPAT_AIMM_LEGACY_CLSID | IMECOMPAT_AIMM12_TRIDENT))
    {
        //
        // we want to get hwnd from hIMC that is associated to dim.
        // Now we don't have a back pointer to hIMC in dim. 
        //
        HWND hwndFocus = ::GetFocus();
        if (hwndFocus && MsimtfIsWindowFiltered(hwndFocus))
        {
            //
            // AIMM aware apps. Never processing ImeProcessKey
            //
            fEnableKeystrokeFeed = TRUE;
            ptls->SetAIMMAware();
        }
        else
        {
            ptls->ResetAIMMAware();
        }
    }

    //
    // Enable or disable keystroke feed if necessary.
    //
    if (ptls->IsEnabledKeystrokeFeed() && !fEnableKeystrokeFeed)
    {
        hr = cskf->DisableSystemKeystrokeFeed();
        if (hr != S_OK)
        {
            DebugMsg(TF_ERROR, TEXT("CThreadMgrEventSink_DIMCallBack::CTFDetection. DisableSystemKeystrokeFeed==NULL"));
        }
        ptls->ResetEnabledKeystrokeFeed();
    }
    else if (!ptls->IsEnabledKeystrokeFeed() && fEnableKeystrokeFeed)
    {
        hr = cskf->EnableSystemKeystrokeFeed();
        if (hr != S_OK)
        {
            DebugMsg(TF_ERROR, TEXT("CThreadMgrEventSink_DIMCallBack::CTFDetection. EnableSystemKeystrokeFeed==NULL"));
        }
        ptls->SetEnabledKeystrokeFeed();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::PostTransMsg
//
//----------------------------------------------------------------------------

VOID
CicBridge::PostTransMsg(
    HWND hwnd,
    INT iNum,
    LPTRANSMSG lpTransMsg)
{
    while (iNum--)
    {
        PostMessageW(hwnd,
                     lpTransMsg->message,
                     lpTransMsg->wParam,
                     lpTransMsg->lParam);
        lpTransMsg++;
    }
}

//+---------------------------------------------------------------------------
//
// CicBridge::EnumCreateInputContextCallback(HIMC hIMC, LPARAM lParam)
//
//----------------------------------------------------------------------------

BOOL 
CicBridge::EnumCreateInputContextCallback(HIMC hIMC, LPARAM lParam)
{
    ENUMIMC *pedimc = (ENUMIMC *)lParam;

    pedimc->_this->CreateInputContext(pedimc->ptls, hIMC);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CicBridge::EnumDestroyInputContextCallback(HIMC hIMC, LPARAM lParam)
//
//----------------------------------------------------------------------------

BOOL 
CicBridge::EnumDestroyInputContextCallback(HIMC hIMC, LPARAM lParam)
{
    ENUMIMC *pedimc = (ENUMIMC *)lParam;

    pedimc->_this->DestroyInputContext(pedimc->ptls, hIMC);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\caret.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    caret.cpp

Abstract:

    This file implements the CCaret Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "caret.h"
#include "globals.h"

//+---------------------------------------------------------------------------
//
// CCaret::ctor
// CCaret::dtor
//
//+---------------------------------------------------------------------------

CCaret::CCaret()
{
    m_hCaretTimer = NULL;
    m_caret_pos.x   = 0;
    m_caret_pos.y   = 0;
    m_caret_size.cx = 0;
    m_caret_size.cy = 0;
}

CCaret::~CCaret()
{
    HideCaret();
    KillTimer(m_hParentWnd, m_hCaretTimer);
    m_hCaretTimer = NULL;
}

//+---------------------------------------------------------------------------
//
// CCaret::CreateCaret
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::CreateCaret(
    HWND hParentWnd,
    SIZE caret_size)
{
    HRESULT hr;

    m_hParentWnd = hParentWnd;
    m_caret_size = caret_size;

    if (IsWindow(m_hParentWnd))
        m_hCaretTimer = SetTimer(m_hParentWnd, TIMER_EVENT_ID, GetCaretBlinkTime(), NULL);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CCaret::DestroyCaret
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::DestroyCaret()
{
    HideCaret();
    KillTimer(m_hParentWnd, m_hCaretTimer);
    m_hCaretTimer = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CCaret::OnTimer
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::OnTimer()
{
    if (m_show.IsSetFlag())
    {
        m_toggle.Toggle();
        InvertCaret();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CCaret::InvertCaret
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::InvertCaret()
{
    HDC hDC = GetDC(m_hParentWnd);
    PatBlt(hDC, m_caret_pos.x, m_caret_pos.y, m_caret_size.cx, m_caret_size.cy, DSTINVERT);
    ReleaseDC(m_hParentWnd, hDC);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CCaret::UpdateCaretPos
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::UpdateCaretPos(
    POINT pos)
{
    BOOL fInvert = FALSE;
    if (m_toggle.IsOn())
    {
        fInvert = TRUE;
        InvertCaret();
    }
    m_caret_pos = pos;
    if (fInvert)
    {
        InvertCaret();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CCaret::SetCaretPos
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::SetCaretPos(
    POINT pos)
{
    return UpdateCaretPos(pos);
}

//+---------------------------------------------------------------------------
//
// CCaret::HideCaret
//
//+---------------------------------------------------------------------------

HRESULT
CCaret::HideCaret()
{
    if (m_toggle.IsOn())
    {
        m_toggle.Toggle();
        InvertCaret();
    }
    m_show.ResetFlag();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\candpos.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    candpos.cpp

Abstract:

    This file implements the CCandidatePosition Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "candpos.h"
#include "ctxtcomp.h"
#include "uicomp.h"

HRESULT
CCandidatePosition::GetCandidatePosition(
    IN IMCLock& imc,
    IN CicInputContext& CicContext,
    IN IME_UIWND_STATE uists,
    IN LANGID langid,
    OUT RECT* out_rcArea
    )
{
    HRESULT hr;
    ::SetRect(out_rcArea, 0, 0, 0, 0);

#if 0
    //
    // Simplified Chinese TIP's Candidate window create ic and Push it.
    // AIMM can know candidate window status.
    // If it opened, we returns position of imc->cfCandForm.
    // Not use QueryCharPos() because it returns position of Reading window.
    //
    if (langid == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        if (_pAImeContext->m_fOpenCandidateWindow) {
            if (imc->cfCandForm[0].dwStyle != CFS_DEFAULT && imc->cfCandForm[0].dwStyle != CFS_EXCLUDE) {

#if 0
                //
                // Chinese TIP needs rectangle
                //
                IMECHARPOSITION ip = {0};
                ip.dwSize = sizeof(IMECHARPOSITION);

                if (QueryCharPos(ptls, imc, &ip)) {
                    //
                    // Sure. Support "query positioning".
                    //
                    RECT rect;
                    hr = GetRectFromApp(imc,
                                        &rect);    // rect = screen coordinate.
                    if (SUCCEEDED(hr)) {
                        MapWindowPoints(HWND_DESKTOP, imc->hWnd, (LPPOINT)&rect, sizeof(RECT)/sizeof(POINT));
                        hr = GetRectFromHIMC(imc,
                                             CFS_EXCLUDE,
                                             &imc->cfCandForm[0].ptCurrentPos,
                                             &rect,
                                             out_rcArea);
                        if (SUCCEEDED(hr))
                            return hr;
                    }
                }
#endif
                //
                // Chinese TIP needs rectangle
                //
                hr = GetRectFromCompFont(imc,
                                         &imc->cfCandForm[0].ptCurrentPos,
                                         out_rcArea);
                if (SUCCEEDED(hr))
                    return hr;

            }

            hr = GetRectFromHIMC(imc,
                                 imc->cfCandForm[0].dwStyle,
                                 &imc->cfCandForm[0].ptCurrentPos,
                                 &imc->cfCandForm[0].rcArea,
                                 out_rcArea);

            return hr;
        }
    }
#endif

    //
    // Is apps support "query positioning" ?
    //
    CicInputContext::IME_QUERY_POS qpos = CicInputContext::IME_QUERY_POS_UNKNOWN;

    if (SUCCEEDED(CicContext.InquireIMECharPosition(langid, imc, &qpos)) &&
        qpos == CicInputContext::IME_QUERY_POS_YES) {
        //
        // Sure. Support "query positioning".
        //
        hr = GetRectFromApp(imc,
                            CicContext,
                            langid,
                            out_rcArea);
        if (SUCCEEDED(hr))
            return hr;
        else
            CicContext.ResetIMECharPosition();
    }

#if 0
    //
    // Is apps composition window Level 1 or 2 ?
    //
    // For Level 1 and 2, there are handled in CInputContextOwnerCallBack::IcoTextExt()
    //
    IME_UIWND_STATE uists;
    uists = UIComposition::InquireImeUIWndState(imc);
    if (uists == IME_UIWND_LEVEL1 ||
        uists == IME_UIWND_LEVEL2)
    {
        //
        // Get candidate window rectangle from composition
        //
        DWORD dwCharPos = GetCharPos(imc, langid);
        hr = UIComposition::GetCandRectFromComposition(imc, langid, dwCharPos, out_rcArea);
        return hr;
    }
#endif

    //
    // This apps is Level 3 or unknown, and do not support "query position".
    //

    if ( (PRIMARYLANGID(langid) == LANG_CHINESE) &&
         (imc->cfCandForm[0].dwIndex == -1 ||
          (uists != IME_UIWND_LEVEL3 && CicContext.m_fOpenCandidateWindow.IsResetFlag())
         )
        )
    {
        //
        // Assume CHT/CHS's Reading Window Position.
        //
        hr = GetRectFromHIMC(imc, FALSE,
                             imc->cfCompForm.dwStyle,
                             &imc->cfCompForm.ptCurrentPos,
                             &imc->cfCompForm.rcArea,
                             out_rcArea);
        return hr;
    }


    //
    // This apps is Level 3 or unknown, and do not support "query position".
    //

    if (PRIMARYLANGID(langid) == LANG_KOREAN)
    {
        hr = GetRectFromHIMC(imc, TRUE,
                             imc->cfCandForm[0].dwStyle,
                             &imc->cfCandForm[0].ptCurrentPos,
                             &imc->cfCandForm[0].rcArea,
                             out_rcArea);
        return hr;
    }

    //
    // This is workaround for IME_UIWND_UNKNOWN case.
    // If WM_IME_STARTCOMPOSITION is not comes in, uists set IME_UIWND_UNKNOWN.
    //
    if ( (uists == IME_UIWND_UNKNOWN) &&
         // #513458
         // If apps specified any cfCandForm, then ctfime should use it.
         (imc->cfCandForm[0].dwIndex == -1))
    {
        hr = GetRectFromHIMC(imc, FALSE,
                             imc->cfCompForm.dwStyle,
                             &imc->cfCompForm.ptCurrentPos,
                             &imc->cfCompForm.rcArea,
                             out_rcArea);
    }
    else
    {
        hr = GetRectFromHIMC(imc, TRUE,
                             imc->cfCandForm[0].dwStyle,
                             &imc->cfCandForm[0].ptCurrentPos,
                             &imc->cfCandForm[0].rcArea,
                             out_rcArea);
    }

    return hr;
}

HRESULT
CCandidatePosition::GetRectFromApp(
    IN IMCLock& imc,
    IN CicInputContext& CicContext,
    IN LANGID langid,
    OUT RECT* out_rcArea
    )
{
    IMECHARPOSITION ip = {0};
    ip.dwSize = sizeof(IMECHARPOSITION);
    ip.dwCharPos = GetCharPos(imc, langid);

    HRESULT hr;

    if (SUCCEEDED(hr = CicContext.RetrieveIMECharPosition(imc, &ip))) {
        switch (imc.GetDirection()) {
            case DIR_TOP_BOTTOM:
                ::SetRect(out_rcArea,
                          ip.pt.x - ip.cLineHeight,               // left
                          ip.pt.y,                                // top
                          ip.pt.x,                                // right
                          max(ip.pt.y, ip.rcDocument.bottom));    // bottom
                break;
            case DIR_BOTTOM_TOP:
                ::SetRect(out_rcArea,
                          ip.pt.x - ip.cLineHeight,               // left
                          min(ip.pt.y, ip.rcDocument.top),        // top
                          ip.pt.x,                                // right
                          ip.pt.y);                               // bottom
                break;
            case DIR_RIGHT_LEFT:
                ::SetRect(out_rcArea,
                          min(ip.pt.x, ip.rcDocument.left),       // left
                          ip.pt.y,                                // top
                          ip.pt.x,                                // right
                          ip.pt.y + ip.cLineHeight);              // bottom
                break;
            case DIR_LEFT_RIGHT:
                ::SetRect(out_rcArea,
                          ip.pt.x,                                // left
                          ip.pt.y,                                // top
                          max(ip.pt.x, ip.rcDocument.right),      // right
                          ip.pt.y + ip.cLineHeight);              // bottom
                break;
        }
    }

    return hr;
}

HRESULT
CCandidatePosition::GetRectFromHIMC(
    IN IMCLock& imc,
    IN BOOL  fCandForm,
    IN DWORD  dwStyle,
    IN POINT* ptCurrentPos,
    IN RECT*  rcArea,
    OUT RECT*  out_rcArea
    )
{
    HWND hWnd = imc->hWnd;

    POINT pt;

    if (dwStyle == CFS_DEFAULT)
    {
        ::SystemParametersInfo(SPI_GETWORKAREA,
                               0,
                               out_rcArea,
                               0);
        out_rcArea->left   = out_rcArea->right;
        out_rcArea->top    = out_rcArea->bottom;
        return S_OK;
    }
    else if (dwStyle & (CFS_RECT | CFS_POINT | CFS_FORCE_POSITION))
    {
        if (! fCandForm)
        {
            return GetRectFromCompFont(imc,
                                       ptCurrentPos,
                                       out_rcArea);
        }
        else
        {
            out_rcArea->left   = ptCurrentPos->x;
            out_rcArea->right  = ptCurrentPos->x;
            out_rcArea->top    = ptCurrentPos->y;
            out_rcArea->bottom = ptCurrentPos->y;
        }
    }
    else if (dwStyle == CFS_CANDIDATEPOS)
    {
        //
        // We needs rectangle
        //
        return GetRectFromCompFont(imc,
                                   ptCurrentPos,
                                   out_rcArea);
    }
    else if (dwStyle == CFS_EXCLUDE)
    {
        GetCandidateArea(imc, dwStyle, ptCurrentPos, rcArea, out_rcArea);
    }

    pt.x = pt.y = 0;
    ClientToScreen(hWnd, &pt);
    out_rcArea->left   += pt.x;
    out_rcArea->right  += pt.x;
    out_rcArea->top    += pt.y;
    out_rcArea->bottom += pt.y;

    return S_OK;
}

HRESULT
CCandidatePosition::GetRectFromCompFont(
    IN IMCLock& imc,
    IN POINT* ptCurrentPos,
    OUT RECT* out_rcArea
    )
{
    HRESULT hr = E_FAIL;

    HDC dc = ::GetDC(imc->hWnd);
    if (dc != NULL) {

        LOGFONT logfont;
        if (ImmGetCompositionFont((HIMC)imc, &logfont)) {

            HFONT font = ::CreateFontIndirect( &logfont );
            if (font != NULL) {

                HFONT prev_font;
                prev_font = (HFONT)::SelectObject(dc, font);

                TEXTMETRIC metric;
                if (::GetTextMetrics(dc, &metric)) {

                    int font_cx = metric.tmMaxCharWidth;
                    int font_cy = metric.tmHeight;

                    switch (imc.GetDirection()) {
                        case DIR_TOP_BOTTOM:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x - font_cx,              // left
                                      ptCurrentPos->y,                        // top
                                      ptCurrentPos->x,                        // right
                                      ptCurrentPos->y + font_cy);             // bottom
                            break;
                        case DIR_BOTTOM_TOP:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x,                        // left
                                      ptCurrentPos->y - font_cy,              // top
                                      ptCurrentPos->x + font_cx,              // right
                                      ptCurrentPos->y);                       // bottom
                            break;
                        case DIR_RIGHT_LEFT:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x - font_cx,              // left
                                      ptCurrentPos->y - font_cy,              // top
                                      ptCurrentPos->x,                        // right
                                      ptCurrentPos->y);                       // bottom
                            break;
                        case DIR_LEFT_RIGHT:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x,                        // left
                                      ptCurrentPos->y,                        // top
                                      ptCurrentPos->x + font_cx,              // right
                                      ptCurrentPos->y + font_cy);             // bottom
                            break;
                    }

                    POINT pt;
                    pt.x = pt.y = 0;
                    ClientToScreen(imc->hWnd, &pt);
                    out_rcArea->left   += pt.x;
                    out_rcArea->right  += pt.x;
                    out_rcArea->top    += pt.y;
                    out_rcArea->bottom += pt.y;

                    hr = S_OK;
                }

                ::SelectObject(dc, prev_font);
                ::DeleteObject(font);
            }
        }

        ::ReleaseDC(imc->hWnd, dc);
    }

    return hr;
}


/*
 *
 *  dwStyle == CFS_EXCLUDE
 *
 */

HRESULT
CCandidatePosition::GetCandidateArea(
    IN IMCLock& imc,
    IN DWORD dwStyle,
    IN POINT* ptCurrentPos,
    IN RECT* rcArea,
    OUT RECT* out_rcArea
    )
{
    POINT pt = *ptCurrentPos;
    RECT rc = *rcArea;

    switch (imc.GetDirection()) {
        case DIR_TOP_BOTTOM:
            ::SetRect(out_rcArea,
                      min(pt.x, rcArea->left),     // left
                      max(pt.y, rcArea->top),      // top
                      max(pt.x, rcArea->right),    // right
                      rcArea->bottom);             // bottom
            break;
        case DIR_BOTTOM_TOP:
            ::SetRect(out_rcArea,
                      min(pt.x, rcArea->left),     // left
                      rcArea->top,                 // top
                      max(pt.x, rcArea->right),    // right
                      min(pt.y, rcArea->bottom));  // bottom
            break;
        case DIR_RIGHT_LEFT:
            ::SetRect(out_rcArea,
                      rcArea->left,                // left
                      min(pt.y, rcArea->top),      // top
                      min(pt.x, rcArea->right),    // right
                      max(pt.y, rcArea->bottom));  // bottom
            break;
        case DIR_LEFT_RIGHT:
            ::SetRect(out_rcArea,
                      max(pt.x, rcArea->left),     // left
                      min(pt.y, rcArea->top),      // top
                      rcArea->right,               // right
                      max(pt.y, rcArea->bottom));  // bottom
            break;
    }

    return S_OK;
}

HRESULT
CCandidatePosition::FindAttributeInCompositionString(
    IN IMCLock& imc,
    IN BYTE target_attribute,
    OUT CWCompCursorPos& wCursorPosition
    )
{
    HRESULT hr = E_FAIL;

    CWCompString    wCompString;
    CWCompAttribute wCompAttribute;

    if (SUCCEEDED(hr = EscbGetTextAndAttribute(imc, &wCompString, &wCompAttribute))) {

        LONG num_of_written = (LONG)wCompAttribute.ReadCompData();
        if (num_of_written == 0)
            return E_FAIL;

        BYTE* attribute = new BYTE[ num_of_written ];
        if (attribute != NULL) {
            //
            // Get attribute data.
            //
            wCompAttribute.ReadCompData(attribute, num_of_written);

            LONG start_position = 0;

            LONG ich = 0;
            LONG attr_size = num_of_written;
            while (ich < attr_size && attribute[ich] != target_attribute)
                ich++;

            if (ich < attr_size) {
                start_position = ich;
            }
            else {
                //
                // If not hit with target_attribute, then returns S_FALSE.
                // 
                hr = S_FALSE;
            }

            wCursorPosition.Set(start_position);

            delete [] attribute;
        }
    }

    return hr;
}

DWORD
CCandidatePosition::GetCharPos(
    IMCLock& imc,
    LANGID langid)
{
    CWCompCursorPos wCursorPosition;
    HRESULT hr;
    DWORD dwCharPos = 0;

    if (PRIMARYLANGID(langid) == LANG_JAPANESE &&
        (hr = FindAttributeInCompositionString(imc,
                                               ATTR_TARGET_CONVERTED,
                                               wCursorPosition)) == S_OK) {
        dwCharPos = wCursorPosition.GetAt(0);
    }
    else if (PRIMARYLANGID(langid) == LANG_JAPANESE &&
             (hr = FindAttributeInCompositionString(imc,
                                                    ATTR_INPUT,
                                                    wCursorPosition)) == S_OK) {
        dwCharPos = wCursorPosition.GetAt(0);
    }
    else {
        if (SUCCEEDED(hr = EscbGetCursorPosition(imc, &wCursorPosition))) {
            CWCompCursorPos wStartSelection;
            CWCompCursorPos wEndSelection;
            if (SUCCEEDED(hr = EscbGetStartEndSelection(imc, wStartSelection, wEndSelection))) {
                dwCharPos = min(wCursorPosition.GetAt(0),
                                wStartSelection.GetAt(0));
            }
            else {
                dwCharPos = wCursorPosition.GetAt(0);
            }
        }
        else {
            dwCharPos = 0;
        }
    }
    return dwCharPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\cic.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cic.h

Abstract:

    This file defines the CicBridge Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CIC_H_
#define _CIC_H_

#include "tls.h"
#include "template.h"
#include "imc.h"
#include "context.h"
#include "tmgrevcb.h"

class CicBridge : public ITfSysHookSink
{
public:
    CicBridge()
    {
        m_pkm_P      = NULL;
        m_dimEmpty   = NULL;
        m_pDIMCallback = NULL;
        m_tfClientId = TF_CLIENTID_NULL;

        m_ref = 1;
    }

    virtual ~CicBridge()
    {
        TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                          // DllMain -> TLS::InternalDestroy -> CicBridge::Release
        if (ptls != NULL)
        {
            ITfThreadMgr_P* ptim_P = ptls->GetTIM();
            if (ptim_P != NULL)
            {
                HRESULT hr = DeactivateIMMX(ptls, ptim_P);
                if (SUCCEEDED(hr))
                {
                    UnInitIMMX(ptls);
                }
            }
        }
    }

    //
    // IUnknown methods
    //
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSysHookSink methods
    //
    STDMETHODIMP OnPreFocusDIM(HWND hWnd);
    STDMETHODIMP OnSysKeyboardProc(WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnSysShellProc(int nCode, WPARAM wParam, LPARAM lParam);

public:
    HRESULT InitIMMX(TLS* ptls);
    BOOL    UnInitIMMX(TLS* ptls);

    HRESULT ActivateIMMX(TLS *ptls, ITfThreadMgr_P* ptim_P);
    HRESULT DeactivateIMMX(TLS *ptls, ITfThreadMgr_P* ptim_P);

    HRESULT CreateInputContext(TLS* ptls, HIMC hImc);
    HRESULT DestroyInputContext(TLS* ptls, HIMC hImc);

    HRESULT SelectEx(TLS* ptls, ITfThreadMgr_P* ptim_P, HIMC hImc, BOOL fSelect, HKL hKL);
    HRESULT SetActiveContextAlways(TLS* ptls, HIMC hImc, BOOL fOn, HWND hWnd, HKL hKL);

    BOOL    ProcessKey(TLS* ptls, ITfThreadMgr_P* ptim_P, HIMC hIMC, UINT uVirtKey, LPARAM lParam, CONST LPBYTE lpbKeyState);
    HRESULT ToAsciiEx(TLS* ptls, ITfThreadMgr_P* ptim_P, UINT uVirtKey, UINT uScanCode, CONST LPBYTE lpbKeyState, LPTRANSMSGLIST lpTransBuf, UINT fuState, HIMC hIMC, UINT *uNum);

    BOOL    ProcessCicHotkey(TLS* ptls, ITfThreadMgr_P* ptim_P, HIMC hIMC, UINT uVirtKey, LPARAM lParam);

    HRESULT Notify(TLS* ptls, ITfThreadMgr_P* ptls_P, HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    HRESULT ConfigureGeneral(TLS* ptls, ITfThreadMgr_P* ptim_P, HKL hKL, HWND hAppWnd);
    HRESULT ConfigureRegisterWord(TLS* ptls, ITfThreadMgr_P* ptim_P, HKL hKL, HWND hAppWnd, REGISTERWORDW* pRegisterWord);

    LRESULT EscapeKorean(TLS* ptls, HIMC hImc, UINT uSubFunc, LPVOID lpData);

    BOOL    SetCompositionString(TLS* ptls, ITfThreadMgr_P* ptim_P, HIMC hImc, DWORD dwIndex, void* pComp, DWORD dwCompLen, void* pRead, DWORD dwReadLen);

    HRESULT GetGuidAtom(TLS* ptls, HIMC hImc, BYTE bAttr, TfGuidAtom* atom);
    HRESULT GetDisplayAttributeInfo(TfGuidAtom atom, TF_DISPLAYATTRIBUTE* da);

private:
    TfClientId _GetClientId()
    {
        return m_tfClientId;
    }

    LIBTHREAD* _GetLibTLS()
    {
        return &_libTLS;
    }

    Interface_Attach<ITfContext> GetInputContext(IMCCLock<CTFIMECONTEXT>& imc_ctfime) const
    {
        CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
        if (!_pCicContext)
            return NULL;
        Interface_Attach<ITfContext> ic(_pCicContext->GetInputContext());
        return ic;
    }

    Interface_Attach<ITfDocumentMgr> GetDocumentManager(IMCCLock<CTFIMECONTEXT>& imc_ctfime) const
    {
        CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
        if (!_pCicContext)
            return NULL;
        Interface_Attach<ITfDocumentMgr> dim(_pCicContext->GetDocumentManager());
        return dim;
    }

public:
    Interface_Attach<ITfDocumentMgr> GetEmptyDIM() const
    {
        Interface_Attach<ITfDocumentMgr> dim(m_dimEmpty);
        return dim;
    }

    static BOOL IsOwnDim(ITfDocumentMgr *pdim);
    static BOOL CTFDetection(TLS* ptls, ITfDocumentMgr* dim);


private:
    struct ENUMIMC
    {
        TLS *ptls;
        CicBridge *_this;
    };
    static BOOL EnumCreateInputContextCallback(HIMC hIMC, LPARAM lParam);
    static BOOL EnumDestroyInputContextCallback(HIMC hIMC, LPARAM lParam);

    BOOL IsDefaultIMCDim(ITfDocumentMgr *pdim);
    VOID SetAssociate(TLS* ptls, HWND hWnd, ITfThreadMgr_P* ptim_P, ITfDocumentMgr* pdim);

    HRESULT OnSetOpenStatus(ITfThreadMgr_P* ptim_P, IMCLock& imc, CicInputContext& CicContext);
    HRESULT OnSetConversionSentenceMode(ITfThreadMgr_P* ptim_P, IMCLock& imc, CicInputContext& CicContext, DWORD dwValue, LANGID langid);
    HRESULT OnSetKorImxConversionMode(ITfThreadMgr_P* ptim_P, IMCLock& imc, CicInputContext& CicContext);

    LRESULT EscHanjaMode(TLS* ptls, HIMC hImc, LPWSTR lpwStr);
    LRESULT DoOpenCandidateHanja(ITfThreadMgr_P* ptim_P, IMCLock& imc, CicInputContext& CicContext);

    BOOL    DefaultKeyHandling(TLS* ptls, IMCLock& imc, CicInputContext* CicContext, UINT uVirtKey, LPARAM lParam);
    VOID    PostTransMsg(HWND hwnd, INT iNum, LPTRANSMSG lpTransMsg);

    //
    // ref count.
    //
private:
    long   m_ref;

private:
    CBoolean         m_fCicInit;
    CBoolean         m_fOnSetAssociate;
    CBoolean         m_fInDeactivate;
    LONG             m_lCicActive;

    ITfKeystrokeMgr_P       *m_pkm_P;

    ITfDocumentMgr          *m_dimEmpty;   // empty dim for NULL hIMC.

    CThreadMgrEventSink_DIMCallBack    *m_pDIMCallback;   // Thread manager event sink callback for DIM

    TfClientId       m_tfClientId;

    LIBTHREAD       _libTLS; // tls for the helper library. Since this object is apt threaded,
                             // all members are accessed in a single thread
                             // also, cicero will only create a single instance of this obj per thread
};

#endif // _CIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\cmpevcb.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cmpevcb.h

Abstract:

    This file defines the CKbdOpenCloseEventSink          Class.
                          CCandidateWndOpenCloseEventSink

Author:

Revision History:

Notes:

--*/

#ifndef _CMPEVCB_H_
#define _CMPEVCB_H_

#include "template.h"
#include "imc.h"
#include "context.h"

class CKbdOpenCloseEventSink : public CCompartmentEventSink
{
public:
    CKbdOpenCloseEventSink(TfClientId tid,
                           HIMC hIMC, 
                           Interface_Attach<ITfContext> pic,
                           LIBTHREAD* pLibTLS)
        : m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS), m_hIMC(hIMC),
          CCompartmentEventSink(KbdOpenCloseCallback, NULL)
    {
    }
    virtual ~CKbdOpenCloseEventSink() { }

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // Callbacks
    //
private:
    static HRESULT KbdOpenCloseCallback(void* pv, REFGUID rguid);

    //
    // Edit session helper
    //
protected:
    HRESULT EscbCompComplete(IMCLock& imc)
    {
        return ::EscbCompComplete(imc, m_tid, m_ic, m_pLibTLS, TRUE);
    }

    //
    // Edit session friend
    //
private:
    friend HRESULT EscbCompComplete(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    BOOL fSync);

private:
    HIMC                          m_hIMC;
    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
};

class CCandidateWndOpenCloseEventSink : public CCompartmentEventSink
{
public:
    CCandidateWndOpenCloseEventSink(TfClientId tid,
                                    HIMC hIMC, 
                                    Interface_Attach<ITfContext> pic,
                                    LIBTHREAD* pLibTLS)
        : m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS), m_hIMC(hIMC),
          CCompartmentEventSink(CandidateWndOpenCloseCallback, NULL)
    {
    }
    virtual ~CCandidateWndOpenCloseEventSink() { }

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // Callbacks
    //
private:
    static HRESULT CandidateWndOpenCloseCallback(void* pv, REFGUID rguid);
public:
    HRESULT CandidateWndOpenCloseCallback(REFGUID rguid);

private:
    HIMC                          m_hIMC;
    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
};

#endif // _CMPEVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\cmpevcb.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cmpevcb.cpp

Abstract:

    This file implements the CKbdOpenCloseEventSink          Class.
                             CCandidateWndOpenCloseEventSink

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "cmpevcb.h"
#include "imc.h"
#include "context.h"
#include "korimx.h"
#include "tls.h"
#include "profile.h"

// static
HRESULT
CKbdOpenCloseEventSink::KbdOpenCloseCallback(
    void* pv,
    REFGUID rguid
    )
{
    DebugMsg(TF_FUNC, TEXT("KbdOpenCloseCallback"));

    HRESULT hr = S_OK;
    BOOL fOpenChanged = FALSE;

    CKbdOpenCloseEventSink* _this = (CKbdOpenCloseEventSink*)pv;
    ASSERT(_this);


    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CKbdOpenCloseEventSink. ptls==NULL"));
        return E_FAIL;
    }

    IMCLock imc(_this->m_hIMC);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CKbdOpenCloseEventSink. imc==NULL"));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CKbdOpenCloseEventSink. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    ASSERT(_pCicContext != NULL);
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CKbdOpenCloseEventSink. _pCicContext==NULL"));
        return E_FAIL;
    }

    LANGID langid;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CKbdOpenCloseEventSink. _pProfile==NULL"));
        return E_FAIL;
    }

    _pProfile->GetLangId(&langid);

    fOpenChanged = _pCicContext->m_fOpenStatusChanging.IsSetFlag();

    if ((PRIMARYLANGID(langid) != LANG_KOREAN) && fOpenChanged)
        return S_OK;

    if (!fOpenChanged)
    {
        DWORD fOnOff;
        hr = GetCompartmentDWORD(ptls->GetTIM(),
                                 GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                 &fOnOff, FALSE);
        if (SUCCEEDED(hr)) {

            //
            // Direct input mode support for Satori.
            // When user switch to direct input mode with composition string,
            // we want finalize composition string.
            //
            if (!fOnOff) {
                if (_pCicContext->m_fStartComposition.IsSetFlag()) {
                    //
                    // finalize the composition before letting the world see this keystroke
                    //
                    _this->EscbCompComplete(imc);
                }
            }

            //
            // #565276
            //
            // we can not call ImmSetOpenStatus() during SelectEx().
            // IMM32 may call previous IME.
            //
            if (_pCicContext->m_fSelectingInSelectEx.IsResetFlag())
            {
                //
                // #510242
                //
                // we need to call ImmSetOpenStatus() if the current HKL is
                // a pure IME. IME's NotfyIME needs to be called.
                //
                ImmSetOpenStatus((HIMC)imc, fOnOff);
                if (fOnOff && (PRIMARYLANGID(langid) == LANG_CHINESE))
                {
                    imc->fdwConversion = IME_CMODE_NATIVE | IME_CMODE_FULLSHAPE;
                }
 
            }
        }
    }

    if ((PRIMARYLANGID(langid) == LANG_KOREAN))
    {
        DWORD fdwConvMode;

        hr = GetCompartmentDWORD(ptls->GetTIM(),
                                 GUID_COMPARTMENT_KORIMX_CONVMODE,
                                 &fdwConvMode,
                                 FALSE);
        if (SUCCEEDED(hr))
        {
            switch (fdwConvMode)
            {
                // Korean TIP ALPHANUMERIC Mode
                case KORIMX_ALPHANUMERIC_MODE:
                    imc->fdwConversion = IME_CMODE_ALPHANUMERIC;
                    break;

                // Korean TIP HANGUL Mode
                case KORIMX_HANGUL_MODE:
                    imc->fdwConversion = IME_CMODE_HANGUL;
                    break;

                // Korean TIP JUNJA Mode
                case KORIMX_JUNJA_MODE:
                    imc->fdwConversion = IME_CMODE_FULLSHAPE;
                    break;

                // Korean TIP HANGUL/JUNJA Mode
                case KORIMX_HANGULJUNJA_MODE:
                    imc->fdwConversion = IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE;
                    break;
            }

            //
            // Some Korean application wait for IMN_SETCONVERSIONMODE notification
            // to update application's input mode setting.
            //
            if (imc->hWnd)
                SendMessage(imc->hWnd, WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0);
        }
    }

    return hr;
}

// static
HRESULT
CCandidateWndOpenCloseEventSink::CandidateWndOpenCloseCallback(
    void* pv,
    REFGUID rguid
    )
{
    DebugMsg(TF_FUNC, TEXT("CandidateWndOpenCloseCallback"));

    CCandidateWndOpenCloseEventSink* _this = (CCandidateWndOpenCloseEventSink*)pv;
    ASSERT(_this);

    return _this->CandidateWndOpenCloseCallback(rguid);
}

HRESULT
CCandidateWndOpenCloseEventSink::CandidateWndOpenCloseCallback(
    REFGUID rguid
    )
{
    HRESULT hr = S_OK;

    DWORD fOnOff;
    hr = GetCompartmentDWORD(m_ic.GetPtr(),
                             GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW,
                             &fOnOff, FALSE);
    if (SUCCEEDED(hr))
    {
        /*
         * This pic is not created by msctfime.
         */
        IMCLock imc(m_hIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        SendMessage(imc->hWnd, WM_IME_NOTIFY,
                    (fOnOff) ? IMN_OPENCANDIDATE : IMN_CLOSECANDIDATE, 1L);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\compstr.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    compstr.cpp

Abstract:

    This file implements the CCompStrFactory Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "compstr.h"

HRESULT
CCompStrFactory::CreateCompositionString(
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompTfGuidAtom* CompGuid,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause
    )
{
    DWORD dwCompSize = (CompStr          ? Align(CompStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (CompAttr         ? Align(CompAttr->GetSize()   * sizeof(BYTE))  : 0) +
                       (CompClause       ? Align(CompClause->GetSize() * sizeof(DWORD)) : 0) +
                       (CompReadStr      ? Align(CompReadStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (CompReadAttr     ? Align(CompReadAttr->GetSize()   * sizeof(BYTE))  : 0) +
                       (CompReadClause   ? Align(CompReadClause->GetSize() * sizeof(DWORD)) : 0) +
                       (ResultStr        ? Align(ResultStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (ResultClause     ? Align(ResultClause->GetSize() * sizeof(DWORD)) : 0) +
                       (ResultReadStr    ? Align(ResultReadStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (ResultReadClause ? Align(ResultReadClause->GetSize() * sizeof(DWORD)) : 0) +
                       (CompGuid         ? Align(CompGuid->GetSize() * sizeof(TfGuidAtom)) : 0) +      // COMPSTRING_AIMM12->dwTfGuidAtom
                       (CompGuid && CompAttr
                                         ? Align(CompAttr->GetSize() * sizeof(BYTE)) : 0);             // COMPSTRING_AIMM12->dwGuidMapAttr

#ifdef CICERO_4678
    //
    // This is another workaround instead of dimm\imewnd.cpp.
    // Even subclass window hook off, AIMM won't resize hCompStr if dwCompSize is zero.
    //
    return (dwCompSize ? _CreateCompositionString(dwCompSize) : S_OK);
#else
    return _CreateCompositionString(dwCompSize);
#endif
}

HRESULT
CCompStrFactory::CreateCompositionString(
    CWInterimString* InterimStr
    )
{
    DWORD dwCompSize = (InterimStr ? Align(InterimStr->GetSize() * sizeof(WCHAR))      : 0) +
                       Align(sizeof(WCHAR)) +    // Interim char
                       Align(sizeof(BYTE));      // Interim attr
    return _CreateCompositionString(dwCompSize);
}

HRESULT
CCompStrFactory::ClearCompositionString()
{
    return _CreateCompositionString(0);
}

HRESULT
CCompStrFactory::_CreateCompositionString(
    DWORD dwCompSize
    )

/*+++

Return Value:

    Returns S_FALSE, dwCompSize is zero.
    Returns S_OK,    dwCompSize is valid size.

---*/

{
    HRESULT hr = (dwCompSize != 0 ? S_OK : S_FALSE);

    dwCompSize += sizeof(COMPOSITIONSTRING) + sizeof(GUIDMAPATTRIBUTE);

    if (m_himcc == NULL) {
        //
        // First creation. Let's initialize it now
        //
        m_himcc = ImmCreateIMCC(dwCompSize);
        if (m_himcc != NULL) {
            m_hr = _LockIMCC(m_himcc, (void**)&m_pcomp);
        }
    }
    else if (ImmGetIMCCSize(m_himcc) != dwCompSize) {
        //
        // If already have m_himcc, then recreate it.
        //
        if (m_pcomp) {
            _UnlockIMCC(m_himcc);
        }

        HIMCC hMem;

        if ((hMem = ImmReSizeIMCC(m_himcc, dwCompSize)) != NULL) {
            m_himcc = hMem;
        }
        else {
            ImmDestroyIMCC(m_himcc);
            m_himcc = ImmCreateIMCC(dwCompSize);
        }

        if (m_himcc != NULL) {
            m_hr = _LockIMCC(m_himcc, (void**)&m_pcomp);
        }
    }

    if (FAILED(m_hr))
        return m_hr;

    if (m_himcc == NULL)
        return E_OUTOFMEMORY;

    memset(m_pcomp, 0, dwCompSize);                 // clear buffer with zero.

    m_pcomp->dwSize = dwCompSize;                   // set buffer size.

    m_pEndOfData = (BYTE*)m_pcomp + sizeof(COMPOSITIONSTRING); // set end of the data pointer.

    return hr;
}

HRESULT
CCompStrFactory::MakeGuidMapAttribute(
    CWCompTfGuidAtom* CompGuid,
    CWCompAttribute* CompAttr)
{
    HRESULT hr;
    GUIDMAPATTRIBUTE* guid_map;

    hr = InitData<GUIDMAPATTRIBUTE>(&GetBuffer()->dwPrivateSize,
                                    &GetBuffer()->dwPrivateOffset);
    if (SUCCEEDED(hr) &&
        (guid_map = (GUIDMAPATTRIBUTE*)GetOffsetPointer(GetBuffer()->dwPrivateOffset)) != NULL)
    {
        hr = WriteData<CWCompTfGuidAtom, TfGuidAtom>(*CompGuid,
                                                     &guid_map->dwTfGuidAtomLen,
                                                     &guid_map->dwTfGuidAtomOffset,
                                                     GetBuffer()->dwPrivateOffset);
        if (SUCCEEDED(hr))
        {
            // temporary make a buffer of dwGuidMapAttr
            if (CompAttr && CompAttr->GetSize()) {
                hr = WriteData<CWCompAttribute, BYTE>(*CompAttr,
                                                      &guid_map->dwGuidMapAttrLen,
                                                      &guid_map->dwGuidMapAttrOffset,
                                                      GetBuffer()->dwPrivateOffset);
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\compstr.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    compstr.h

Abstract:

    This file defines the CCompStrFactory Class.

Author:

Revision History:

Notes:

--*/


#ifndef _COMPSTR_H_
#define _COMPSTR_H_

#include "ime.h"
#include "template.h"
#include "ctxtcomp.h"

class CCompStrFactory : public IMCCLock<COMPOSITIONSTRING>
{
public:
    CCompStrFactory(HIMCC hCompStr) : IMCCLock<COMPOSITIONSTRING>(hCompStr)
    {
        m_pEndOfData = NULL;
    }

    HIMCC GetHandle()
    {
        return m_himcc;
    }

    HRESULT CreateCompositionString(CWCompString* CompStr,
                                    CWCompAttribute* CompAttr,
                                    CWCompClause* CompClause,
                                    CWCompTfGuidAtom* CompGuid,
                                    CWCompString* CompReadStr,
                                    CWCompAttribute* CompReadAttr,
                                    CWCompClause* CompReadClause,
                                    CWCompString* ResultStr,
                                    CWCompClause* ResultClause,
                                    CWCompString* ResultReadStr,
                                    CWCompClause* ResultReadClause
                                   );

    HRESULT CreateCompositionString(CWInterimString* InterimStr);

    HRESULT ClearCompositionString();

    template<class CONTEXT_SRC, class ARG_TYPE>
    HRESULT WriteData(CONTEXT_SRC& context_src,
                      DWORD* context_dest_len,
                      DWORD* context_dest_off,
                      DWORD  context_baias = 0
                     )
    {
        DWORD dwLen = (DWORD)context_src.GetSize();
        DWORD dwRemainBufferSize = GetRemainBufferSize();

        if (dwLen > dwRemainBufferSize)
            return E_OUTOFMEMORY;

        *context_dest_len = dwLen;
        *context_dest_off = (DWORD)(m_pEndOfData - (BYTE*)m_pcomp - context_baias);

        context_src.ReadCompData((ARG_TYPE*)m_pEndOfData, dwRemainBufferSize);
        m_pEndOfData += Align(dwLen * sizeof(ARG_TYPE));

        return S_OK;
    }

    template<class ARG_TYPE>
    HRESULT InitData(DWORD* context_dest_len,
                     DWORD* context_dest_off
                     )
    {
        DWORD dwRemainBufferSize = GetRemainBufferSize();

        if (sizeof(ARG_TYPE) > dwRemainBufferSize)
            return E_OUTOFMEMORY;

        m_pcomp->dwPrivateSize = sizeof(ARG_TYPE);
        m_pcomp->dwPrivateOffset = (DWORD)(m_pEndOfData - (BYTE*)m_pcomp);

        memset((BYTE*)m_pEndOfData, 0, dwRemainBufferSize);
        m_pEndOfData += Align(sizeof(ARG_TYPE));

        return S_OK;
    }

    HRESULT MakeGuidMapAttribute(CWCompTfGuidAtom* CompGuid, CWCompAttribute* CompAttr);

private:
    HRESULT _CreateCompositionString(DWORD dwCompSize);

    DWORD GetRemainBufferSize()
    {
        if (m_pEndOfData == NULL)
            return 0;

        return m_pcomp->dwSize > (DWORD)(m_pEndOfData - (BYTE*)m_pcomp) ? (DWORD)(m_pcomp->dwSize - (m_pEndOfData - (BYTE*)m_pcomp)) : 0;
    }

    size_t Align(size_t a)
    {
#ifndef _WIN64
        return (size_t) ((a + 3) & ~3);
#else
        return (size_t) ((a + 7) & ~7);
#endif
    }

    BYTE*    m_pEndOfData;
};

#endif // _COMPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\context.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    context.h

Abstract:

    This file defines the CicInputContext Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#include "tls.h"
#include "template.h"
#include "boolean.h"
#include "imc.h"
#include "ctxtcomp.h"
#include "globals.h"
#include "modebias.h"

#define ArrayZeroInit(x) memset(&(x), 0, sizeof(x));

class CicInputContext;
class CInputContextOwnerCallBack;
class CTextEventSinkCallBack;
class CThreadMgrEventSink_ICCallBack;
class CKbdOpenCloseEventSink;
class CCandidateWndOpenCloseEventSink;
class CStartReconversionNotifySink;
class CModeBias;

typedef struct tagCTFIMECONTEXT {
    CicInputContext*    m_pCicContext;
    BOOL                m_fInDestroy : 1;
} CTFIMECONTEXT, *PCTFIMECONTEXT;

class CicInputContext : public ITfCleanupContextSink,
                        public ITfContextOwnerCompositionSink,
                        public ITfCompositionSink
{
public:
    CicInputContext(TfClientId tid,
                    LIBTHREAD* pLibTLS,
                    HIMC hIMC)
        : m_tid(tid), m_pLibTLS(pLibTLS), m_hIMC(hIMC)
    {
        m_ref = 1;

        m_fQueryPos = IME_QUERY_POS_UNKNOWN;
    }
    virtual ~CicInputContext() { }

    //
    // IUnknown methods
    //
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCleanupContextSink methods
    //
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    //
    // ITfContextOwnerCompositionSink
    //
    STDMETHODIMP OnStartComposition(ITfCompositionView *pComposition, BOOL *pfOk);
    STDMETHODIMP OnUpdateComposition(ITfCompositionView *pComposition, ITfRange *pRangeNew);
    STDMETHODIMP OnEndComposition(ITfCompositionView *pComposition);

    //
    // ITfCompositionSink
    //
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition* pComposition);

public:
    HRESULT CreateInputContext(ITfThreadMgr_P* ptim_P, IMCLock& imc);
    HRESULT DestroyInputContext();

    void GenerateMessage(IMCLock& imc);

    BOOL SetCompositionString(IMCLock& imc, ITfThreadMgr_P* ptim_P, DWORD dwIndex, void* pComp, DWORD dwCompLen, void* pRead, DWORD dwReadLen, UINT cp);



    //
    // Cicero's context
    //
public:
    ITfContext* GetInputContext()
    {
        return m_pic;
    }

    ITfDocumentMgr* GetDocumentManager()
    {
        return m_pdim;
    }

    ITfContextOwnerServices* GetInputContextOwnerSink()
    {
        return m_piccb;
    }

    //
    // ref count.
    //
private:
    long   m_ref;

    //
    // hIMC
    //
private:
    HIMC   m_hIMC;

    //
    // Cicero's context
    //
private:
    ITfDocumentMgr            *m_pdim;           // Document Manager
    ITfContext                *m_pic;            // Input Context
    ITfContextOwnerServices   *m_piccb;          // Context owner service from m_pic

    //
    // Cicero's event sink callback
    //
private:
    CInputContextOwnerCallBack      *m_pICOwnerSink;          // IC owner call back

    CTextEventSinkCallBack          *m_pTextEventSink;        // Text event sink callback

    CKbdOpenCloseEventSink          *m_pKbdOpenCloseEventSink; // Kbd TIP Open/Close Compartment event sink callback

    CCandidateWndOpenCloseEventSink *m_pCandidateWndOpenCloseEventSink; // Candidate UI Window Open/Close Compartment event sink callback

    CStartReconversionNotifySink    *m_pStartReconvSink;

    //
    // Reconvert
    //
public:
    HRESULT SetupReconvertString(IMCLock& imc, ITfThreadMgr_P* ptim_P, UINT cp, UINT uPrivMsg, BOOL fUndoComposition);
    HRESULT EndReconvertString(IMCLock& imc);
    HRESULT DelayedReconvertFuncCall(IMCLock &imc);
private:
    HRESULT _ReconvertStringNegotiation(IMCLock& imc, ITfThreadMgr_P* ptim_P, UINT cp, UINT uPrivMsg, BOOL fUndoComposition);
    HRESULT _ReconvertStringTextStore(IMCLock& imc, ITfThreadMgr_P* ptim_P, UINT uPrivMsg);
    HRESULT MakeReconversionFuncCall( IMCLock& imc, ITfThreadMgr_P* ptim_P, CWReconvertString &wReconvStr, BOOL fCallFunc);
    CWCompString m_PrevResultStr;

public:
    void UpdatePrevResultStr(IMCLock& imc)
    {
        IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);
        m_PrevResultStr.RemoveAll();
        m_PrevResultStr.AddCompData(
               (WCHAR *)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset),
               pCompStr->dwResultStrLen);
    }
private:

    static HRESULT Internal_QueryReconvertString_ICOwnerSink(UINT uCode, ICOARGS *pargs, VOID *pv);
    HRESULT Internal_QueryReconvertString(IMCLock& imc, ITfThreadMgr_P* ptim_P, RECONVERTSTRING* pReconv, UINT cp, BOOL fNeedAW);
    HRESULT Internal_ReconvertString(IMCLock& imc, ITfThreadMgr_P* ptim_P, CWReconvertString& wReconvStr, CWReconvertString& wReconvReadStr);
    HRESULT Internal_SetCompositionString(IMCLock& imc, CWCompString& wCompStr, CWCompString& wCompReadStr);

    //
    // Document Feeding
    //
public:
    HRESULT SetupDocFeedString(IMCLock& imc, UINT cp);
    HRESULT ClearDocFeedBuffer(IMCLock& imc, BOOL fSync = TRUE)
    {
        return EscbClearDocFeedBuffer(imc, fSync);
    }

    //
    // Undo composition string
    //
public:
    HRESULT SetupUndoCompositionString(IMCLock& imc, ITfThreadMgr_P* ptim_P, UINT cp)
    {
        return SetupReconvertString(imc, ptim_P, cp, 0, TRUE); /* 0 == Don't need ITfFnReconvert */
    }
    HRESULT EndUndoCompositionString(IMCLock& imc)
    {
        return EndReconvertString(imc);
    }


    //
    // QueryCharPos
    //
public:
    typedef enum {
        IME_QUERY_POS_UNKNOWN = 0,
        IME_QUERY_POS_NO      = 1,
        IME_QUERY_POS_YES     = 2
    } IME_QUERY_POS;

    HRESULT InquireIMECharPosition(LANGID langid, IMCLock& imc, IME_QUERY_POS* pfQueryPos);
    HRESULT RetrieveIMECharPosition(IMCLock& imc, IMECHARPOSITION* ip);
    HRESULT ResetIMECharPosition()
    {
        m_fQueryPos = IME_QUERY_POS_UNKNOWN;
        return S_OK;
    }

private:
    BOOL QueryCharPos(IMCLock& imc, IMECHARPOSITION* position);

    //
    // Apps support QueryCharPos().
    //
    IME_QUERY_POS   m_fQueryPos;




    //
    // Generate message
    //
public:
    UINT TranslateImeMessage(IMCLock& imc, LPTRANSMSGLIST lpTransMsgList = NULL);

    CFirstInFirstOut<TRANSMSG, TRANSMSG>    *m_pMessageBuffer;


    //
    // Mouse sink
    //
    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc);


    //
    // Mode bias
    //
public:
    CModeBias  m_ModeBias;

    //
    // Flags
    //
public:
    CBoolean   m_fStartComposition;           // TRUE: already sent WM_IME_STARTCOMPOSITION.
    CBoolean   m_fOpenCandidateWindow;        // TRUE: opening candidate list window.
    CBoolean   m_fInReconvertEditSession;     // TRUE: In reconvert edit session.
    CBoolean   m_fInClearDocFeedEditSession;  // TRUE: In ClearDocFeed edit session.
    CBoolean   m_fInCompComplete;             // TRUE: In CompComplete running.
    CBoolean   m_fInUpdateComposition;        // TRUE: In UpdateComposition running.

    CBoolean   m_fHanjaReConversion;
#if 0
    CBoolean   m_fHanjaRequested;
#endif
#ifdef UNSELECTCHECK
    CBoolean   m_fSelected;   // TRUE: if this context is selected.
#endif UNSELECTCHECK
    CBoolean   m_fOpenStatusChanging;
    CBoolean   m_fKorImxModeChanging;
    CBoolean   m_fGeneratedEndComposition;
    CBoolean   m_fInProcessKey;
    CBoolean   m_fInToAsciiEx;
    CBoolean   m_fSelectingInSelectEx;

    CBoolean   m_fInDocFeedReconvert;         // TRUE: In CFnDocFeed::StartReconvert function.

    //
    // ITfContextOwnerCompositionSink
    //
public:
    CBoolean   m_fModifyingDoc;
    int        m_cCompositions;

public:
    CBoolean   m_fConversionSentenceModeChanged;
    CBoolean   m_fOnceModeChanged;
    UINT       m_nInConversionModeChangingRef;
    UINT       m_nInConversionModeResetRef;

    //
    // IME share.
    //
public:
    HRESULT    GetGuidAtom(IMCLock& imc, BYTE bAttr, TfGuidAtom* atom);
    HRESULT    MapAttributes(IMCLock& imc);
    VOID       ClearGuidMap()
    {
        usGuidMapSize = 0;
        memset(&aGuidMap, 0, sizeof aGuidMap);
    }

    //
    // Default Key Handling
    //
public:
    BOOL WantThisKey(UINT uVirtKey);

private:
    BOOL IsTopNow()
    {
        BOOL bRet = FALSE;
        ITfContext *pic;
        if (SUCCEEDED(m_pdim->GetTop(&pic)))
        {
            bRet = (pic == m_pic) ? TRUE : FALSE;
            pic->Release();
        }
        return bRet;
    }

private:
    USHORT      usGuidMapSize;
    TfGuidAtom  aGuidMap[256];    // GUIDATOM map to IME Attribute

    static const USHORT ATTR_LAYER_GUID_START = ATTR_FIXEDCONVERTED + 1;

    //
    // previous candidate position
    //
private:
    HWND m_hwndPrevCandidatePos;
    RECT m_rcPrevAppPosForCandidatePos;
    CANDIDATEFORM m_cfPrevCandidatePos;
    RECT m_rcPrevAppCandidatePos;

public:
    HRESULT OnSetCandidatePos(TLS* ptls, IMCLock& imc);
    void ClearPrevCandidatePos()
    {
        m_hwndPrevCandidatePos = NULL;
        ArrayZeroInit(m_rcPrevAppPosForCandidatePos);
        ArrayZeroInit(m_cfPrevCandidatePos);
        ArrayZeroInit(m_rcPrevAppCandidatePos);
        ResetIMECharPosition();
    }

    //
    // Edit session helper
    //
public:
    HRESULT EscbHandleThisKey(IMCLock& imc, UINT uVirtKey)
    {
        return ::EscbHandleThisKey(imc, m_tid, m_pic, m_pLibTLS, uVirtKey);
    }

    HRESULT EscbCompComplete(IMCLock& imc)
    {
        return ::EscbCompComplete(imc, m_tid, m_pic, m_pLibTLS, TRUE);
    }

    HRESULT EscbCompCancel(IMCLock& imc)
    {
        return ::EscbCompCancel(imc, m_tid, m_pic, m_pLibTLS);
    }

    HRESULT EscbGetSelection(IMCLock& imc, Interface<ITfRange>* selection)
    {
        return ::EscbGetSelection(imc, m_tid, m_pic, m_pLibTLS, selection);
    }

    HRESULT EscbReadOnlyPropMargin(IMCLock& imc, Interface<ITfRangeACP>* range_acp, LONG* pcch)
    {
        return ::EscbReadOnlyPropMargin(imc, m_tid, m_pic, m_pLibTLS, range_acp, pcch);
    }

protected:
    HRESULT EscbUpdateCompositionString(IMCLock& imc)
    {
        return ::EscbUpdateCompositionString(imc, m_tid, m_pic, m_pLibTLS, 0, 0);
    }

    HRESULT EscbReplaceWholeText(IMCLock& imc, CWCompString* wCompString)
    {
        return ::EscbReplaceWholeText(imc, m_tid, m_pic, m_pLibTLS, wCompString);
    }

    HRESULT EscbClearDocFeedBuffer(IMCLock& imc, BOOL fSync = TRUE)
    {
        return ::EscbClearDocFeedBuffer(imc, *this, m_tid, m_pic, m_pLibTLS, fSync);
    }

    HRESULT EscbQueryReconvertString(IMCLock& imc, Interface_Attach<ITfContext> local_pic, CWReconvertString* wReconvertString, Interface<ITfRange>* selection)
    {
        return ::EscbQueryReconvertString(imc, m_tid, local_pic, m_pLibTLS, wReconvertString, selection);
    }

    HRESULT EscbReconvertString(IMCLock& imc, CWReconvertString* wReconvertString, Interface<ITfRange>* selection, BOOL fDocFeedOnly)
    {
        return ::EscbReconvertString(imc, m_tid, m_pic, m_pLibTLS, wReconvertString, selection, fDocFeedOnly);
    }

    HRESULT EscbCalcRangePos(IMCLock& imc, Interface_Attach<ITfContext> local_pic, CWReconvertString* wReconvertString, Interface<ITfRange>* range)
    {
        return ::EscbCalcRangePos(imc, m_tid, local_pic, m_pLibTLS, wReconvertString, range);
    }


    //
    // Edit session friend
    //
private:
    friend HRESULT EscbHandleThisKey(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                     UINT uVirtKey);
    friend HRESULT EscbCompComplete(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    BOOL fSync);
    friend HRESULT EscbCompCancel(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS);
    friend HRESULT EscbUpdateCompositionString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                               DWORD dwDeltaStart,
                                               DWORD dwFlags);
    friend HRESULT EscbReplaceWholeText(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                        CWCompString* wCompString);
    friend HRESULT EscbReconvertString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                       CWReconvertString* wReconvertString,
                                       Interface<ITfRange>* selection,
                                       BOOL fDocFeedOnly);
    friend HRESULT EscbClearDocFeedBuffer(IMCLock& imc, CicInputContext& CicContext, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                          BOOL fSync);
    friend HRESULT EscbGetSelection(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    Interface<ITfRange>* selection);
    friend HRESULT EscbQueryReconvertString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                            CWReconvertString* wReconvertString,
                                            Interface<ITfRange>* selection);
    friend HRESULT EscbCalcRangePos(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    CWReconvertString* wReconvertString,
                                    Interface<ITfRange>* range);
    friend HRESULT EscbReadOnlyPropMargin(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                          Interface<ITfRangeACP>* range_acp,
                                          LONG*     pcch);

private:
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
};


#endif // _CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSCTFIME"
#define SZ_MODULE       "MSCTFIME"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\defimehd.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    defimehd.cpp

Abstract:

    This file implements the default IME sub window handler Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "uiwndhd.h"

//+---------------------------------------------------------------------------
//
// CtfImeDispatchDefImeMessage
//
//+---------------------------------------------------------------------------

LRESULT
CtfImeDispatchDefImeMessage(
    HWND hDefImeWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    if (!IsMsImeMessage(message))
        return 0;

    HKL hkl = GetKeyboardLayout(0);
    if (IS_IME_KBDLAYOUT(hkl))
        return 0;

    HWND hUIWnd = (HWND)SendMessage(hDefImeWnd, 
                                    WM_IME_NOTIFY,
                                    IMN_PRIVATE_GETUIWND,
                                    0);

    if (IsWindow(hUIWnd))
        return SendMessage(hUIWnd, message, wParam, lParam);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\ctxtcomp.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    ctxtcomp.h

Abstract:

    This file defines the Context of Composition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CTXTCOMP_H_
#define _CTXTCOMP_H_

#include "template.h"
#include "imc.h"

/////////////////////////////////////////////////////////////////////////////
// GetCompInfo

template<class T>
HRESULT
GetCompInfo(
    IN T size,
    IN DWORD len,
    IN LONG*& lpCopied
    )
{
    *lpCopied = (LONG)(len * size);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CompData

template<class TYPE, class ARG_TYPE>
class CompData
{
public:
    CompData(HIMC hIMC = NULL, ARG_TYPE* lpsz = NULL, DWORD dwLen = 0)
    {
        IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return;

        if (lpsz)
            WriteCompData(lpsz, dwLen);
    }

    CompData(IMCCLock<COMPOSITIONSTRING>& lpCompStr)
    {
    }

    CompData(IMCCLock<COMPOSITIONSTRING>& lpCompStr, DWORD dwIndex);

    DWORD WriteCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        if (! m_array.SetSize(dwLen))
            return 0;

        ARG_TYPE* psz = m_array.GetData();
        if (!psz)
            return 0;

        DWORD index = dwLen;
        while (index--) {
            *psz++ = data;
        }

        return dwLen;
    }

    DWORD WriteCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        if (! m_array.SetSize(dwLen))
            return 0;

        ARG_TYPE* psz = m_array.GetData();
        if (!psz)
            return 0;

        memcpy(psz, lpSrc, dwLen * sizeof(TYPE));
        return dwLen;
    }

    DWORD AddCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        if (! m_array.SetSize(dwLen+dwl))
            return 0;

        psTemp = m_array.GetData();
        if (!psTemp)
            return 0;

        memcpy(psTemp+dwl, lpSrc, dwLen*sizeof(TYPE));

        return dwLen;
    }

    DWORD AddCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        if (! m_array.SetSize(dwLen+dwl))
            return 0;

        psTemp = m_array.GetData();
        if (!psTemp)
            return 0;

        psTemp += dwl;

        DWORD index = dwLen;
        while (index--) {
            *psTemp++ = data;
        }

        return dwLen;
    }

    const INT_PTR ReadCompData(IN ARG_TYPE* lpDest = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_array.GetSize();
        }
        else {
            ARG_TYPE* psz = m_array.GetData();
            if ((INT_PTR)dwLen > m_array.GetSize()) {
                dwBufLen = m_array.GetSize();
            }
            else {
                dwBufLen = (INT_PTR)dwLen;
            }
            memcpy(lpDest, psz, dwBufLen * sizeof(TYPE));
        }
        return dwBufLen;
    }

    DWORD GetCompStrIndex(IN DWORD dwIndex) {
        switch(dwIndex) {
            case GCS_COMPATTR:         return GCS_COMPSTR;
            case GCS_COMPREADATTR:     return GCS_COMPREADSTR;
            case GCS_COMPCLAUSE:       return GCS_COMPSTR;
            case GCS_COMPREADCLAUSE:   return GCS_COMPREADSTR;
            case GCS_RESULTCLAUSE:     return GCS_RESULTSTR;
            case GCS_RESULTREADCLAUSE: return GCS_RESULTREADSTR;
            case GCS_CURSORPOS:        return GCS_COMPSTR;
            case GCS_DELTASTART:       return GCS_COMPSTR;
            default:                   break;
        }
        ASSERT(FALSE);
        return 0;
    }

    TYPE GetAt(INT_PTR nIndex) const
    {
        return m_array.GetAt(nIndex);
    }

    void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
    {
        m_array.SetAtGrow(nIndex, newElement);
    }

    INT_PTR Add(ARG_TYPE newElement)
    {
        return m_array.Add(newElement);
    }

    INT_PTR GetSize() const
    {
        return m_array.GetSize();
    }

    void RemoveAll()
    {
        m_array.RemoveAll();
    }

    operator void* ()
    {
        return m_array.GetData();
    }

    TYPE operator[](INT_PTR nIndex)
    {
        return m_array.GetAt(nIndex);
    }

protected:
    CArray<TYPE, ARG_TYPE>    m_array;
};

template<class TYPE, class ARG_TYPE>
CompData<TYPE, ARG_TYPE>::CompData(
    IMCCLock<COMPOSITIONSTRING>& lpCompStr,
    DWORD dwIndex
    )
{
    switch (dwIndex) {
        case GCS_COMPSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwCompStrOffset),
                                                            lpCompStr->dwCompStrLen);        // # of chars
            break;
        case GCS_COMPREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwCompReadStrOffset),
                                                            lpCompStr->dwCompReadStrLen);    // # of chars
            break;
        case GCS_RESULTSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwResultStrOffset),
                                                            lpCompStr->dwResultStrLen);      // # of chars
            break;
        case GCS_RESULTREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwResultReadStrOffset),
                                                            lpCompStr->dwResultReadStrLen);  // # of chars
            break;

        case GCS_COMPATTR:        // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwCompAttrOffset),
                                                            lpCompStr->dwCompAttrLen);
            break;
        case GCS_COMPREADATTR:    // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwCompReadAttrOffset),
                                                            lpCompStr->dwCompReadAttrLen);
            break;

        case GCS_COMPREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwCompReadClauseOffset),
                                                            lpCompStr->dwCompReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwResultClauseOffset),
                                                            lpCompStr->dwResultClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwResultReadClauseOffset),
                                                            lpCompStr->dwResultReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_COMPCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->dwCompClauseOffset),
                                                            lpCompStr->dwCompClauseLen / sizeof(TYPE));    // # of bytes
            break;

        case GCS_CURSORPOS:
            SetAtGrow(0, (TYPE)lpCompStr->dwCursorPos);
            break;
        case GCS_DELTASTART:
            SetAtGrow(0, (TYPE)lpCompStr->dwDeltaStart);
            break;

        default:
            break;
    }
}




class CWCompString;


/////////////////////////////////////////////////////////////////////////////
// CBCompString

class CBCompString : public CompData<CHAR, CHAR>
{
public:
    CBCompString(
        HIMC hIMC=NULL,
        LPSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<CHAR, CHAR>(hIMC, lpsz, dwLen)
    {
    };

    CBCompString(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr) : CompData<CHAR, CHAR>(lpCompStr)
    {
    };

    CBCompString(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr,
        DWORD dwIndex) : CompData<CHAR, CHAR>(lpCompStr, dwIndex)
    {
    };

    const CBCompString& operator=(CWCompString& wcompstr);

    const DWORD ConvertUnicodeString(IN OUT LPWSTR lpsz = NULL, DWORD cch = 0)
    {
        return _mbstowcs(lpsz, cch);
    }

    CHAR GetAt(IN DWORD dwIndex)
    {
        return CompData<CHAR, CHAR>::GetAt(dwIndex);
    }

    BOOL IsDBCSLeadByteEx(IN DWORD dwIndex)
    {
         CHAR c = GetAt(dwIndex);
         return ::IsDBCSLeadByteEx(m_cp, c);
    }

    void SetCodePage(UINT cp)
    {
        m_cp = cp;
    }

private:
    UINT      m_cp;            // code page value.

    int _mbstowcs(wchar_t* wcstr, size_t cch);
};

inline
int
CBCompString::_mbstowcs(
    wchar_t* wcstr,
    size_t cch
    )
{
    if (cch == 0 && wcstr != NULL)
        return 0;

    const char* mbstr = m_array.GetData();
    if (!mbstr)
        return 0;

    INT_PTR nSize = m_array.GetSize();

    int result = ::MultiByteToWideChar(m_cp,     // code page
                                       0,        // character-type option
                                       mbstr,    // address of string to map
                                       (int)nSize,    // number of bytes in string
                                       wcstr,    // address of wide-char buffer
                                       (int)cch);   // size of buffer, in wide character.

    return result;
}




/////////////////////////////////////////////////////////////////////////////
// CWCompString

class CWCompString : public CompData<WCHAR, WCHAR>
{
public:
    CWCompString(
        HIMC hIMC=NULL,
        LPWSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<WCHAR, WCHAR>(hIMC, lpsz, dwLen)
    {
    };

    CWCompString(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr) : CompData<WCHAR, WCHAR>(lpCompStr)
    {
    };

    CWCompString(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr,
        DWORD dwIndex) : CompData<WCHAR, WCHAR>(lpCompStr, dwIndex)
    {
    };

    const CWCompString& operator=(CBCompString& bcompstr);

    const DWORD ConvertANSIString(IN OUT LPSTR lpsz = NULL, DWORD dwLen = 0)
    {
        return _wcstombs(lpsz, dwLen);
    }

    WCHAR GetAt(IN DWORD dwIndex)
    {
        return (WCHAR)CompData<WCHAR, WCHAR>::GetAt(dwIndex);
    }

    int UnicodeToMultiByteSize(IN DWORD dwIndex)
    {
        WCHAR wc = GetAt(dwIndex);
        return ::WideCharToMultiByte(m_cp,     // code page
                                     0,        // performance and mapping flags
                                     (const wchar_t*)&wc,     // address of wide-char string
                                     1,        // number of char string
                                     NULL,     // address of buffer for new string
                                     0,        // size of buffer
                                     NULL,     // default for unmappable char
                                     NULL);    // flag set when default char
    }

    void SetCodePage(UINT cp)
    {
        m_cp = cp;
    }

private:
    UINT      m_cp;            // code page value.

    int _wcstombs(char* mbstr, size_t count);
};


inline
int
CWCompString::_wcstombs(
    char* mbstr,
    size_t count
    )
{
    if (count == 0 && mbstr != NULL)
        return 0;

    const wchar_t* wcstr = m_array.GetData();
    if (!wcstr)
        return 0;

    INT_PTR nSize = m_array.GetSize();

    int result = ::WideCharToMultiByte(m_cp,     // code page
                                       0,        // performance and mapping flags
                                       wcstr,    // address of wide-char string
                                       (int)nSize,    // number of char string
                                       mbstr,    // address of buffer for new string
                                       (int)count,    // size of buffer
                                       NULL,     // default for unmappable char
                                       NULL);    // flag set when default char

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// CBCompStrin/CWCompString::operator=

inline
const CBCompString&
CBCompString::operator=(
    CWCompString& wcompstr
    )

/*+++
 *
 * Get ANSI string from Unicode composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = wcompstr.ConvertANSIString();
    if (! m_array.SetSize(len))
        return *this;

    LPSTR psz = m_array.GetData();
    if (psz)
        len = wcompstr.ConvertANSIString(psz, len * sizeof(CHAR));

    return *this;
}

inline
const CWCompString&
CWCompString::operator=(
    CBCompString& bcompstr
    )

/*+++
 *
 * Get Unicode string from ANSI composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = bcompstr.ConvertUnicodeString();
    if (! m_array.SetSize(len))
        return *this;

    LPWSTR psz = m_array.GetData();
    if (psz)
        len = bcompstr.ConvertUnicodeString(psz, len);

    return *this;
}



/////////////////////////////////////////////////////////////////////////////
// CheckAttribute template

template<class APPS_ATTR, class HIMC_ATTR, class HIMC_CLAUSE>
HRESULT
CheckAttribute(
    APPS_ATTR& apps_attr,                        // the attr from apps
    HIMC_ATTR& himc_attr,                        // the attr from IMC
    HIMC_CLAUSE& himc_clause                     // the clause from IMC
    )
{
    if (himc_clause.ReadCompData() == 0) {
        TraceMsg(TF_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
    }
    else {
        if (himc_attr.ReadCompData() != 0) {
            if (apps_attr.GetSize() != himc_attr.GetSize()) {
                TraceMsg(TF_ERROR, "CheckAttribute: wrong length.");
                return E_FAIL;
            }

            /*
             * The attr. of chars of one clause have to be same.
             */
            DWORD dwAttrIndex = 0;
            DWORD dwClauseIndex;
            for (dwClauseIndex = 0;
                 (INT_PTR)himc_clause.GetAt(dwClauseIndex) < apps_attr.ReadCompData();
                 dwClauseIndex++
                ) {
                DWORD dwBound = himc_clause.GetAt(dwClauseIndex+1) - himc_clause.GetAt(dwClauseIndex);
                DWORD battr = apps_attr.GetAt(dwAttrIndex++);
                DWORD dwCnt;
                for (dwCnt = 1; dwCnt < dwBound; dwCnt++) {
                    if (battr != apps_attr.GetAt(dwAttrIndex++)) {
                        TraceMsg(TF_ERROR, "CheckAttribute: mismatch clause attribute.");
                        return E_FAIL;
                    }
                }
            }
        }
    }

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CWCompAttribute

class CWCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CWCompAttribute(
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_wcompstr(hIMC)
    {
    };

    CWCompAttribute(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                  m_wcompstr(lpCompStr)
    {
    };

    CWCompAttribute(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_wcompstr(lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    // const CWCompAttribute& operator=(CBCompAttribute& bcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CWCompString    m_wcompstr;
};



/////////////////////////////////////////////////////////////////////////////
// CheckClause template


template<class APPS_CLAUSE, class HIMC_CLAUSE>
HRESULT
CheckClause(
    APPS_CLAUSE& apps_clause,                 // the clause from apps
    HIMC_CLAUSE& himc_clause                  // the clause from IMC
    )
{
    if (apps_clause.ReadCompData() == 0 ||
        himc_clause.ReadCompData() == 0  ) {
        TraceMsg(TF_ERROR, "CheckClause: no Clause.");
        return E_FAIL;
    }

    if (apps_clause.GetAt(0) ||
        himc_clause.GetAt(0)   ) {
        TraceMsg(TF_ERROR, "CheckClause: clause[0] have to be ZERO.");
        return E_FAIL;
    }

    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < himc_clause.ReadCompData();
         dwClauseIndex++
        ) {
        if (apps_clause.GetAt(dwClauseIndex) != himc_clause.GetAt(dwClauseIndex)) {
            return E_FAIL;
        }
    }

    return S_OK;
}


class CWCompClause;



/////////////////////////////////////////////////////////////////////////////
// CWCompClause

class CWCompClause : public CompData<DWORD, DWORD>
{
public:
    CWCompClause(
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_wcompstr(hIMC)
    {
    };

    CWCompClause(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                  m_wcompstr(lpCompStr)
    {
    };

    CWCompClause(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    // const CWCompClause& operator=(CBCompClause& bcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};







/////////////////////////////////////////////////////////////////////////////
// CWCompCursorPos

class CWCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CWCompCursorPos(
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(hIMC)
    {
    };

    CWCompCursorPos(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                  m_wcompstr(lpCompStr)
    {
    };

    CWCompCursorPos(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    // const CWCompCursorPos& operator=(CBCompCursorPos& bcompcursorpos);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};







/////////////////////////////////////////////////////////////////////////////
// CWCompDeltaStart

class CWCompDeltaStart : public CompData<DWORD, DWORD>
{
public:
    CWCompDeltaStart(
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(hIMC)
    {
    };

    CWCompDeltaStart(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                  m_wcompstr(lpCompStr)
    {
    };

    CWCompDeltaStart(
        IMCCLock<COMPOSITIONSTRING>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    // const CWCompDeltaStart& operator=(CBCompDeltaStart& bcompdeltastart);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};




class CWReconvertString;

/////////////////////////////////////////////////////////////////////////////
// CBReconvetString

class CBReconvertString
{
public:
    CBReconvertString(
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_bcompstr(hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;
        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_bcompstr.WriteCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset;
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset;
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_bcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_bcompstr.ReadCompData() * sizeof(CHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)(m_bcompstr.ReadCompData() * sizeof(CHAR));
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(CHAR));
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(CHAR));

            dwBufLen = m_bcompstr.ReadCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CBReconvertString& operator=(CWReconvertString& wReconvStr);

    void SetData(CWReconvertString& wReconvStr);

    void SetCodePage(UINT cp)
    {
        m_bcompstr.SetCodePage(cp);
    }

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

public:
    CBCompString    m_bcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CBCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CBCompString::<string array> that is related to thetarget clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};




/////////////////////////////////////////////////////////////////////////////
// CWReconvertString

class CWReconvertString
{
public:
    CWReconvertString(
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_wcompstr(hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;

        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_wcompstr.WriteCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset / sizeof(WCHAR);   // char count
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset / sizeof(WCHAR);  // char count
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_wcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_wcompstr.ReadCompData() * sizeof(WCHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)m_wcompstr.ReadCompData();
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(WCHAR));  // byte count
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(WCHAR));  // byte count

            dwBufLen = m_wcompstr.ReadCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CWReconvertString& operator=(CBReconvertString& bReconvStr);

    void SetData(CBReconvertString& bReconvStr);

    void SetCodePage(UINT cp)
    {
        m_wcompstr.SetCodePage(cp);
    }

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

public:
    CWCompString    m_wcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CWCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CWCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};


/////////////////////////////////////////////////////////////////////////////
// CBCompReconvertString/CWCompReconvertString::operator=

inline
const CBReconvertString&
CBReconvertString::operator=(
    CWReconvertString& wReconvStr
    )
{
    m_bcompstr = wReconvStr.m_wcompstr;
    SetData(wReconvStr);
    return *this;
}

inline
const CWReconvertString&
CWReconvertString::operator=(
    CBReconvertString& bReconvStr
    )
{
    m_wcompstr = bReconvStr.m_bcompstr;
    SetData(bReconvStr);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// CBReconvertString/CWReconvertString::SetData

inline
void
CBReconvertString::SetData(
    CWReconvertString& wReconvStr
    )
{
    m_dwVersion = wReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex), &wReconvStr.m_wcompstr);
    m_CompStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen), &wReconvStr.m_wcompstr) - m_CompStrIndex;
    m_TargetStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex), &wReconvStr.m_wcompstr);
    m_TargetStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex + wReconvStr.m_TargetStrLen), &wReconvStr.m_wcompstr) - m_TargetStrIndex;
}

inline
void
CWReconvertString::SetData(
    CBReconvertString& bReconvStr
    )
{
    m_dwVersion = bReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex), &bReconvStr.m_bcompstr);
    m_CompStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex + bReconvStr.m_CompStrLen), &bReconvStr.m_bcompstr) - m_CompStrIndex);
    m_TargetStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex), &bReconvStr.m_bcompstr);
    m_TargetStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex + bReconvStr.m_TargetStrLen), &bReconvStr.m_bcompstr) - m_TargetStrIndex);
}














/////////////////////////////////////////////////////////////////////////////
// CWInterimString

class CWInterimString : public CWCompString
{
public:
    CWInterimString(
        HIMC hIMC
        ) : CWCompString(hIMC)
    {
        m_InterimChar = L'\0';
        m_InterimAttr = 0;
    }

    VOID WriteInterimChar(WCHAR ch, BYTE attr)
    {
        m_InterimChar = ch;
        m_InterimAttr = attr;
    }

    void ReadInterimChar(WCHAR* ch, BYTE* attr)
    {
        *ch   = m_InterimChar;
        *attr = m_InterimAttr;
    }

    void ReadInterimChar(CWCompString* ch, CWCompAttribute* attr)
    {
        ch->WriteCompData(&m_InterimChar, 1);
        attr->WriteCompData(&m_InterimAttr, 1);
    }

public:
    WCHAR           m_InterimChar;
    BYTE            m_InterimAttr;
};




/////////////////////////////////////////////////////////////////////////////
// CWCompTfGuidAtom

class CWCompTfGuidAtom : public CompData<TfGuidAtom, TfGuidAtom>
{
public:
};




/////////////////////////////////////////////////////////////////////////////
// friend


inline
DWORD
CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    CBCompString* bcompstr
    )

/*+++

    Calculation Unicode character position to ANSI character position

---*/

{
    DWORD dwCharPosW = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosA != 0) {
        if (bcompstr->IsDBCSLeadByteEx(dwStrIndex)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            dwStrIndex += 2;
        }
        else {
            dwCharPosA--;
            dwStrIndex++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}


inline
DWORD
CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    CWCompString* wcompstr
    )

/*+++

    Calculate ANSI character position to Unicode character position.

---*/

{
    DWORD dwCharPosA = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosW != 0) {
        if (wcompstr->UnicodeToMultiByteSize(dwStrIndex) == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwStrIndex++;
        dwCharPosW--;
    }

    return dwCharPosA;
}

#endif // _CTXTCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\context.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    context.cpp

Abstract:

    This file implements the CicInputContext Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "context.h"
#include "globals.h"
#include "msime.h"
#include "icocb.h"
#include "txtevcb.h"
#include "tmgrevcb.h"
#include "cmpevcb.h"
#include "reconvcb.h"
#include "korimx.h"
#include "profile.h"
#include "delay.h"


//+---------------------------------------------------------------------------
//
// CicInputContext::IUnknown::QueryInterface
// CicInputContext::IUnknown::AddRef
// CicInputContext::IUnknown::Release
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::QueryInterface(
    REFIID riid,
    void** ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        *ppvObj = static_cast<ITfCleanupContextSink*>(this);
    }
    else if (IsEqualGUID(riid, IID_ITfContextOwnerCompositionSink))
    {
        *ppvObj = static_cast<ITfContextOwnerCompositionSink*>(this);
    }
    else if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }
    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CicInputContext::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CicInputContext::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::ITfCleanupContextSink::OnCleanupContext
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::OnCleanupContext(
    TfEditCookie ecWrite,
    ITfContext* pic)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::OnCleanupContext"));

    TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                      // DllMain -> ImeDestroy -> DeactivateIMMX -> Deactivate
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::OnCleanupContext. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    LANGID langid;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::OnCleanupContext. _pProfile==NULL."));
        return E_OUTOFMEMORY;
    }

    _pProfile->GetLangId(&langid);

    IMEINFO ImeInfo;
    WCHAR   szWndCls[MAX_PATH];
    if (Inquire(&ImeInfo, szWndCls, 0, (HKL)UlongToHandle(langid)) != S_OK)
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::OnCleanupContext. ImeInfo==NULL."));
        return E_FAIL;
    }

    if (ImeInfo.fdwProperty & IME_PROP_COMPLETE_ON_UNSELECT)
    {
#if 0
        ImmIfCompositionComplete *pImmIfCallBack = new ImmIfCompositionComplete;
        if (!pImmIfCallBack)
            return E_OUTOFMEMORY;

        pImmIfCallBack->CompComplete(ecWrite, m_hImc, FALSE, pic, m_pImmIfIME);

        delete pImmIfCallBack;
#else
        //
        // Remove GUID_PROP_COMPOSING
        //
        ITfRange *rangeFull = NULL;
        ITfProperty *prop;
        ITfRange *rangeTmp;
        if (SUCCEEDED(pic->GetProperty(GUID_PROP_COMPOSING, &prop)))
        {
            IEnumTfRanges *enumranges;
            if (SUCCEEDED(prop->EnumRanges(ecWrite, &enumranges, rangeFull)))
            {
                while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
                {
                    VARIANT var;
                    QuickVariantInit(&var);
                    prop->GetValue(ecWrite, rangeTmp, &var);
                    if ((var.vt == VT_I4) && (var.lVal != 0))
                    {
                        prop->Clear(ecWrite, rangeTmp);
                    }
                    rangeTmp->Release();
                }
                enumranges->Release();
            }
            prop->Release();
        }
#endif
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::ITfContextOwnerCompositionSink::OnStartComposition
// CicInputContext::ITfContextOwnerCompositionSink::OnUpdateComposition
// CicInputContext::ITfContextOwnerCompositionSink::OnEndComposition
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::OnStartComposition(
    ITfCompositionView* pComposition,
    BOOL* pfOk)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::OnStartComposition"));

    if (m_cCompositions > 0 && m_fModifyingDoc.IsResetFlag())
    {
        *pfOk = FALSE;
    }
    else
    {
        *pfOk = TRUE;
        m_cCompositions++;
    }

    return S_OK;
}

HRESULT
CicInputContext::OnUpdateComposition(
    ITfCompositionView* pComposition,
    ITfRange* pRangeNew)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::OnUpdateComposition"));

    return S_OK;
}

HRESULT
CicInputContext::OnEndComposition(
    ITfCompositionView* pComposition)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::OnEndComposition"));

    m_cCompositions--;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::ITfCompositionSink::OnCompositionTerminated
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::OnCompositionTerminated(
    TfEditCookie ecWrite,
    ITfComposition* pComposition)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::OnCompositionTerminated"));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::CreateInputContext
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::CreateInputContext(
    ITfThreadMgr_P* ptim_P,
    IMCLock& imc)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::CreateInputContext"));

    // do this once for the life time of this context
    m_fStartComposition.ResetFlag();

    HRESULT hr;

    //
    // Create document manager.
    //
    if (m_pdim == NULL) {

        if (FAILED(hr = ptim_P->CreateDocumentMgr(&m_pdim)))
        {
            return hr;
        }

        //
        // mark this is an owned dim.
        //
        SetCompartmentDWORD(m_tid, m_pdim, GUID_COMPARTMENT_CTFIME_DIMFLAGS,
                            COMPDIMFLAG_OWNEDDIM, FALSE);
                
    }

    //
    // Create input context
    //
    TfEditCookie ecTmp;
    hr = m_pdim->CreateContext(m_tid, 0, (ITfContextOwnerCompositionSink*)this, &m_pic, &ecTmp);
    if (FAILED(hr)) {
        DestroyInputContext();
        return hr;
    }

    //
    // associate CicInputContext in PIC.
    //
    Interface<IUnknown> punk;
    if (SUCCEEDED(QueryInterface(IID_IUnknown, punk))) {
        SetCompartmentUnknown(m_tid, m_pic, 
                              GUID_COMPARTMENT_CTFIME_CICINPUTCONTEXT,
                              punk);
    }

    //
    // set AppProp mapping
    //
    ITfContext_P *picp;
    if (SUCCEEDED(m_pic->QueryInterface(IID_ITfContext_P, (void **)&picp)))
    {
        picp->MapAppProperty(TSATTRID_Text_ReadOnly, GUID_PROP_MSIMTF_READONLY);
        picp->Release();
    }

    //
    // Create Input Context Owner Callback
    //
    if (m_pICOwnerSink == NULL) {
        m_pICOwnerSink = new CInputContextOwnerCallBack(m_tid, m_pic, m_pLibTLS);
        if (m_pICOwnerSink == NULL) {
            DebugMsg(TF_ERROR, TEXT("Couldn't create ICOwnerSink tim!"));
            Assert(0); // couldn't activate thread!
            DestroyInputContext();
            return E_FAIL;
        }

        if (!m_pICOwnerSink->Init()) {
            DebugMsg(TF_ERROR, TEXT("Couldn't initialize ICOwnerSink tim!"));
            Assert(0); // couldn't activate thread!
            DestroyInputContext();
            return E_FAIL;
        }
        m_pICOwnerSink->SetCallbackDataPointer(m_pICOwnerSink);
    }

    //
    // Advise IC.
    //
    m_pICOwnerSink->_Advise(m_pic);

    Interface<ITfSourceSingle> SourceSingle;

    if (m_pic->QueryInterface(IID_ITfSourceSingle, (void **)SourceSingle) == S_OK)
    {
        // setup a cleanup callback
        // nb: a real tip doesn't need to be this aggressive, for instance
        // kimx probably only needs this sink on the focus ic.
        SourceSingle->AdviseSingleSink(m_tid, IID_ITfCleanupContextSink, (ITfCleanupContextSink *)this);
    }

    //
    // Push IC.
    //
    hr = m_pdim->Push(m_pic);

    if (m_piccb == NULL) {
        m_pic->QueryInterface(IID_ITfContextOwnerServices,
                              (void **)&m_piccb);
    }

    //
    // Create Text Event Sink Callback
    //
    if (m_pTextEventSink == NULL) {
        m_pTextEventSink = new CTextEventSinkCallBack((HIMC)imc, m_tid, m_pic, m_pLibTLS);
        if (m_pTextEventSink == NULL) {
            DestroyInputContext();
            return E_FAIL;
        }
        m_pTextEventSink->SetCallbackDataPointer(m_pTextEventSink);

        Interface_Attach<ITfContext> ic(GetInputContext());
        m_pTextEventSink->_Advise(ic.GetPtr(), ICF_TEXTDELTA);
    }

    //
    // Create KBD TIP Open/Close Compartment Event Sink Callback
    //
    if (m_pKbdOpenCloseEventSink == NULL) {
        m_pKbdOpenCloseEventSink = new CKbdOpenCloseEventSink(m_tid, (HIMC)imc, m_pic, m_pLibTLS);
        if (m_pKbdOpenCloseEventSink == NULL) {
            DestroyInputContext();
            return E_FAIL;
        }
        m_pKbdOpenCloseEventSink->SetCallbackDataPointer(m_pKbdOpenCloseEventSink);
        m_pKbdOpenCloseEventSink->_Advise(ptim_P, GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, FALSE);
        m_pKbdOpenCloseEventSink->_Advise(ptim_P, GUID_COMPARTMENT_KORIMX_CONVMODE, FALSE);
    }

    //
    // Create Candidate UI Window Open/Close Compartment Event Sink Callback
    //
    if (m_pCandidateWndOpenCloseEventSink == NULL) {
        m_pCandidateWndOpenCloseEventSink = new CCandidateWndOpenCloseEventSink(m_tid, (HIMC)imc, m_pic, m_pLibTLS);
        if (m_pCandidateWndOpenCloseEventSink == NULL) {
            DestroyInputContext();
            return E_FAIL;
        }
        m_pCandidateWndOpenCloseEventSink->SetCallbackDataPointer(m_pCandidateWndOpenCloseEventSink);
        m_pCandidateWndOpenCloseEventSink->_Advise(m_pic, GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW, FALSE);
    }

    //
    // Create Start reconversion notify Sink
    //
    if (m_pStartReconvSink == NULL) {
        m_pStartReconvSink = new CStartReconversionNotifySink((HIMC)imc);
        if (m_pStartReconvSink == NULL) {
            DestroyInputContext();
            return E_FAIL;
        }
        m_pStartReconvSink->_Advise(m_pic);
    }

    //
    // Create Message Buffer
    //
    if (m_pMessageBuffer == NULL) {
        m_pMessageBuffer = new CFirstInFirstOut<TRANSMSG, TRANSMSG>;
        if (m_pMessageBuffer == NULL) {
            DestroyInputContext();
            return E_FAIL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::DestroyInputContext
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::DestroyInputContext()
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::DestroyInputContext"));

    Interface<ITfSourceSingle> SourceSingle;

    if (m_pic && m_pic->QueryInterface(IID_ITfSourceSingle, (void **)SourceSingle) == S_OK)
    {
        SourceSingle->UnadviseSingleSink(m_tid, IID_ITfCleanupContextSink);
    }

    if (m_pMessageBuffer) {
        delete m_pMessageBuffer;
        m_pMessageBuffer = NULL;
    }

    if (m_pTextEventSink) {
        m_pTextEventSink->_Unadvise();
        m_pTextEventSink->Release();
        m_pTextEventSink = NULL;
    }

    if (m_pCandidateWndOpenCloseEventSink) {
        m_pCandidateWndOpenCloseEventSink->_Unadvise();
        m_pCandidateWndOpenCloseEventSink->Release();
        m_pCandidateWndOpenCloseEventSink = NULL;
    }

    if (m_pKbdOpenCloseEventSink) {
        m_pKbdOpenCloseEventSink->_Unadvise();
        m_pKbdOpenCloseEventSink->Release();
        m_pKbdOpenCloseEventSink = NULL;
    }

    if (m_pStartReconvSink) {
        m_pStartReconvSink->_Unadvise();
        m_pStartReconvSink->Release();
        m_pStartReconvSink = NULL;
    }


    HRESULT hr;

    if (m_pdim)
    {
        hr = m_pdim->Pop(TF_POPF_ALL);
    }

    //
    // un-associate CicInputContext in PIC.
    //
    if (m_pic) {
        ClearCompartment(m_tid, m_pic, 
                         GUID_COMPARTMENT_CTFIME_CICINPUTCONTEXT,
                         FALSE);
    }

    if (m_pic) {
        m_pic->Release();
        m_pic = NULL;
    }

    if (m_piccb) {
        m_piccb->Release();
        m_piccb = NULL;
    }

    // ic owner is auto unadvised during the Pop by cicero
    // in any case, it must not be unadvised before the pop
    // since it will be used to handle mouse sinks, etc.
    if (m_pICOwnerSink) {
        m_pICOwnerSink->_Unadvise();
        m_pICOwnerSink->Release();
        m_pICOwnerSink = NULL;
    }

    if (m_pdim)
    {
        m_pdim->Release();
        m_pdim = NULL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::GenerateMessage
//
//----------------------------------------------------------------------------

void
CicInputContext::GenerateMessage(
    IMCLock& imc)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::GenerateMessage"));

    TranslateImeMessage(imc);

    if (FAILED(imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::GenerateMessage. imc==NULL"));
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);

    DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
    BOOL fSendMsg;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return;

    if (!(_pCicContext->m_fInToAsciiEx.IsSetFlag() ||
          _pCicContext->m_fInProcessKey.IsSetFlag()  ) ||
        _pCicContext->m_fInDocFeedReconvert.IsSetFlag() ||
        MsimtfIsWindowFiltered(::GetFocus()))
    {
        //
        // Generate SendMessage.
        //
        fSendMsg = TRUE;
        CtfImmGenerateMessage((HIMC)imc, fSendMsg);
    }
    else
    {
        //
        // Generate PostMessage.
        //
        fSendMsg = FALSE;
        CtfImmGenerateMessage((HIMC)imc, fSendMsg);
    }
}

//+---------------------------------------------------------------------------
//
// CicInputContext::TranslateImeMessage
//
//----------------------------------------------------------------------------

UINT
CicInputContext::TranslateImeMessage(
    IMCLock& imc,
    TRANSMSGLIST* lpTransMsgList)  // default = NULL
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::TranslateImeMessage"));

    if (m_pMessageBuffer == NULL)
        return 0;

    INT_PTR NumMsg = m_pMessageBuffer->GetSize();
    if (NumMsg == 0)
        return 0;

    UINT retNumMsg = 0;

    if (lpTransMsgList && NumMsg < (INT_PTR)lpTransMsgList->uMsgCount) {
        LPTRANSMSG lpTransMsg = &lpTransMsgList->TransMsg[0];
        while (NumMsg--) {
            if (! m_pMessageBuffer->GetData(*lpTransMsg++))
                break;
            retNumMsg++;
        }
    }
    else {
        if (imc->hMsgBuf == NULL) {
            imc->hMsgBuf = ImmCreateIMCC((DWORD)(NumMsg * sizeof(TRANSMSG)));
        }
        else if (ImmGetIMCCSize(imc->hMsgBuf) < NumMsg * sizeof(TRANSMSG)) {
            imc->hMsgBuf = ImmReSizeIMCC(imc->hMsgBuf, (DWORD)(NumMsg * sizeof(TRANSMSG)));
        }

        imc->dwNumMsgBuf = 0;

        IMCCLock<TRANSMSG> pdw(imc->hMsgBuf);
        if (pdw.Valid()) {
            LPTRANSMSG lpTransMsg = pdw;
            while (NumMsg--) {
                if (! m_pMessageBuffer->GetData(*lpTransMsg++))
                    break;
                retNumMsg++;
            }
            imc->dwNumMsgBuf = retNumMsg;
        }
    }

    return retNumMsg;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::InquireIMECharPosition
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::InquireIMECharPosition(
    LANGID langid,
    IMCLock& imc,
    IME_QUERY_POS* pfQueryPos)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::InquireIMECharPosition"));

    if (m_fQueryPos == IME_QUERY_POS_UNKNOWN) {
        //
        // Bug#500488 - Don't WM_MSIME_QUERYPOSITION for Korea
        //
        DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
        if ((PRIMARYLANGID(langid) != LANG_KOREAN) ||
            ((PRIMARYLANGID(langid) == LANG_KOREAN) &&
             (dwImeCompatFlags & (IMECOMPAT_AIMM12 | IMECOMPAT_AIMM_LEGACY_CLSID | IMECOMPAT_AIMM12_TRIDENT)))
           ) {
            //
            // Is apps support "query positioning" ?
            //
            IMECHARPOSITION ip = {0};
            ip.dwSize = sizeof(IMECHARPOSITION);

            m_fQueryPos = QueryCharPos(imc, &ip) ? IME_QUERY_POS_YES : IME_QUERY_POS_NO;
#ifdef DEBUG
            //
            // if QeuryCharPos() fails, the candidate window pos won't be correct.
            //
            if (m_fQueryPos == IME_QUERY_POS_NO)
            {
                Assert(0);
            }
#endif
        }
    }

    if (pfQueryPos) {
        *pfQueryPos = m_fQueryPos;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::RetrieveIMECharPosition
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::RetrieveIMECharPosition(
    IMCLock& imc,
    IMECHARPOSITION* ip)
{
    return QueryCharPos(imc, ip) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::QueryCharPos
//
//----------------------------------------------------------------------------

BOOL
CicInputContext::QueryCharPos(
    IMCLock& imc,
    IMECHARPOSITION* position)
{
    LRESULT lRet;

    //
    // First Step. Query by local method.
    //
    lRet = ::SendMessage(imc->hWnd,
                         WM_MSIME_QUERYPOSITION,
                         VERSION_QUERYPOSITION,
                         (LPARAM)position);
    if (lRet) {
        return TRUE;
    }

    //
    // Second Step. Query by IMM method.
    // (IsOnNT5() || IsOn98())
    //
    if (ImmRequestMessage((HIMC)imc,
                          IMR_QUERYCHARPOSITION,
                          (LPARAM)position)) {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::MsImeMouseHandler
//
//----------------------------------------------------------------------------

LRESULT
CicInputContext::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::MsImeMouseHandler"));

    LRESULT ret = m_pICOwnerSink->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc);

    if (dwBtnStatus & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) {
        EscbUpdateCompositionString(imc);
    }

    return ret;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::SetCompositionString
//
//----------------------------------------------------------------------------

BOOL
CicInputContext::SetCompositionString(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,
    DWORD dwIndex,
    void* pComp,
    DWORD dwCompLen,
    void* pRead,
    DWORD dwReadLen,
    UINT cp)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::SetCompositionString"));

    HRESULT hr;

    switch (dwIndex)
    {
        case SCS_SETSTR:
            {
                CWCompString wCompStr(imc, (LPWSTR)pComp, dwCompLen / sizeof(WCHAR));      // dwCompLen is byte count.
                CWCompString wCompReadStr(imc, (LPWSTR)pRead, dwReadLen / sizeof(WCHAR));  // dwReadLen is byte count.
                hr = Internal_SetCompositionString(imc, wCompStr, wCompReadStr);
                if (SUCCEEDED(hr))
                    return TRUE;
            }
            break;
        case SCS_CHANGEATTR:
        case SCS_CHANGECLAUSE:
            return FALSE;
        case SCS_SETRECONVERTSTRING:
            {
                CWReconvertString wReconvStr(imc, (LPRECONVERTSTRING)pComp, dwCompLen);
                CWReconvertString wReconvReadStr(imc, (LPRECONVERTSTRING)pRead, dwReadLen);
                hr = Internal_ReconvertString(imc, ptim_P, wReconvStr, wReconvReadStr);
                if (SUCCEEDED(hr))
                    return TRUE;
            }
            break;
        case SCS_QUERYRECONVERTSTRING:
            // AdjustZeroCompLenReconvertString((LPRECONVERTSTRING)pComp, cp, FALSE);
            // hr = S_OK;

            hr = Internal_QueryReconvertString(imc, ptim_P, (LPRECONVERTSTRING)pComp, cp, FALSE);
            if (SUCCEEDED(hr))
                return TRUE;
            break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::GetGuidAtom
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::GetGuidAtom(
    IMCLock& imc,
    BYTE bAttr,
    TfGuidAtom* atom)
{
    HRESULT hr;
    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::GetGuidAtom. comp==NULL"));
        return hr;
    }
    if (bAttr < usGuidMapSize)
    {
        *atom = aGuidMap[bAttr];
        return S_OK;
    }
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::MapAttributes
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::MapAttributes(
    IMCLock& imc)
{
    HRESULT hr;
    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::MapAttributes. comp==NULL"));
        return hr;
    }

    GuidMapAttribute guid_map(GuidMapAttribute::GetData(comp));
    if (guid_map.Invalid())
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::MapAttributes. guid_map==NULL"));
        return E_OUTOFMEMORY;
    }

    if (usGuidMapSize == 0)
    {
        //
        // Make transration table.
        //
        usGuidMapSize = ATTR_LAYER_GUID_START;

        for (USHORT i = 0; i < guid_map->dwTfGuidAtomLen; ++i)
        {
            //
            // Check if this GUID is already registered
            //
            for (USHORT j = ATTR_LAYER_GUID_START; j < usGuidMapSize; ++j)
            {
                if (aGuidMap[j] == ((TfGuidAtom*)guid_map.GetOffsetPointer(guid_map->dwTfGuidAtomOffset))[i])
                {
                    break;
                }
            }

            BYTE bAttr;
            if (j >= usGuidMapSize)
            {
                //
                // Couldn't find the GUID registered.
                //
                if (usGuidMapSize < ARRAYSIZE(aGuidMap) - 1)
                {
                    bAttr = static_cast<BYTE>(usGuidMapSize);
                    aGuidMap[usGuidMapSize++] = ((TfGuidAtom*)guid_map.GetOffsetPointer(guid_map->dwTfGuidAtomOffset))[i];
                }
                else
                {
                    // # of GUID exceeds the # of available attribute...
                    // Maybe it should fail, but for now give it a bogus attirbute.
                    bAttr = ATTR_TARGET_CONVERTED;
                }
            }
            else
            {
                bAttr = static_cast<BYTE>(j);
            }

            ((BYTE*)guid_map.GetOffsetPointer(guid_map->dwGuidMapAttrOffset))[i] = bAttr;
        }

        guid_map->dwGuidMapAttrLen = guid_map->dwTfGuidAtomLen;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::WantThisKey
//
//----------------------------------------------------------------------------

BOOL
CicInputContext::WantThisKey(
    UINT uVirtKey)
{
    if (! IsTopNow())
    {
        return FALSE;
    }

    switch (BYTE(uVirtKey))
    {
        case VK_RETURN:
        case VK_ESCAPE:
        case VK_BACK:
        case VK_DELETE:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
        case VK_HOME:
        case VK_END:
            /*
             * If we don't have a composition string, then we should return FALSE.
             */
            if (m_fStartComposition.IsResetFlag())
            {
                return FALSE;
            }
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// OnSetCandidatePos
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::OnSetCandidatePos(
    TLS* ptls,
    IMCLock& imc)
{
    DebugMsg(TF_FUNC, TEXT("CicBridge::OnSetCandidatePos"));

    RECT rcAppPosForCandidatePos = {0};
    RECT rcAppCandidatePos = {0};

    //
    // #510404
    //
    // check the previous candidate pos and we don't have to move them
    // if it is not changed.
    //
    GetWindowRect(imc->hWnd, &rcAppPosForCandidatePos);
    if ((imc->hWnd == m_hwndPrevCandidatePos) &&
         !memcmp(&rcAppPosForCandidatePos,  
                 &m_rcPrevAppPosForCandidatePos, sizeof(RECT)))
    {
        BOOL fCheckQueryCharPos = FALSE;
        if (!memcmp(&imc->cfCandForm[0],  
                    &m_cfPrevCandidatePos, sizeof(CANDIDATEFORM)))
        {
            LANGID langid;
            CicProfile* _pProfile = ptls->GetCicProfile();
            if (_pProfile == NULL)
            {
                DebugMsg(TF_ERROR, TEXT("CicInputContext::OnCleanupContext. _pProfile==NULL."));
                return E_OUTOFMEMORY;
            }

            _pProfile->GetLangId(&langid);

            CCandidatePosition cand_pos(m_tid, m_pic, m_pLibTLS);
            if (SUCCEEDED(cand_pos.GetRectFromApp(imc, *this, langid, &rcAppCandidatePos)))
            {
                if (!memcmp(&rcAppCandidatePos, 
                            &m_rcPrevAppCandidatePos, sizeof(RECT)))
                    return S_OK;
          
            }
            else
                return S_OK;
        }
    }

    HWND hDefImeWnd;
    //
    // When this is in the reconvert session, candidate window position is
    // not caret position of cfCandForm->ptCurrentPos.
    //
    if (m_fInReconvertEditSession.IsResetFlag() &&
        IsWindow(hDefImeWnd=ImmGetDefaultIMEWnd(NULL)) &&
        ptls->IsCTFUnaware()  // bug:5213 WinWord
                              // WinWord10 calls ImmSetCandidateWindow() while receive WM_LBUTTONUP.
       )
    {
        /*
         * A-Synchronize call ITfContextOwnerServices::OnLayoutChange
         * because this method had a protected.
         */
        PostMessage(hDefImeWnd, WM_IME_NOTIFY, IMN_PRIVATE_STARTLAYOUTCHANGE, 0);
    }

    m_hwndPrevCandidatePos = imc->hWnd;
    memcpy(&m_rcPrevAppPosForCandidatePos, &rcAppPosForCandidatePos, sizeof(RECT));
    memcpy(&m_cfPrevCandidatePos, &imc->cfCandForm[0], sizeof(CANDIDATEFORM));
    memcpy(&m_rcPrevAppCandidatePos, &rcAppCandidatePos, sizeof(RECT));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\delay.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    delay.cpp

Abstract:

    This file implements the delay load.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "delay.h"

FARPROC GetFn(HINSTANCE *phInst, WCHAR *pchLib, char *pchFunc, BOOL fLoad)
{
    if (*phInst == NULL)
    {
        if (fLoad)
            *phInst = LoadSystemLibraryW(pchLib);

        if (*phInst == NULL)
        {
#ifdef DEBUG
            if (fLoad)
            {
                Assert(0);
            }
#endif
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _fLoad)   \
_RetType _CallConv _FuncName _Args1                                             \
{                                                                               \
    static FARPROC pfn = NULL;                                                  \
                                                                                \
    if (pfn == NULL || _hInst == NULL)                                          \
    {                                                                           \
        pfn = GetFn(&_hInst, L#_DllName, #_FuncName, _fLoad);                            \
                                                                                \
        if (pfn == NULL)                                                        \
        {                                                                       \
            if (_fLoad)                                                         \
            {                                                                   \
                Assert(0);                                                      \
            }                                                                   \
            return (_RetType) _ErrVal;                                          \
        }                                                                       \
    }                                                                           \
                                                                                \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                       \
}


HINSTANCE g_hOle32 = NULL;

HRESULT Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoCreateInstance", TRUE);
        if (pfn == NULL) {
            Assert(0);
            return E_FAIL;
        }
    }
    return ((HRESULT (WINAPI *)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv))(pfn))(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

HINSTANCE g_hMsimtf = NULL;
DELAYLOAD(g_hMsimtf, Msimtf.dll, WINAPI, MsimtfIsWindowFiltered, (HWND hwnd), (hwnd), BOOL, FALSE, TRUE)
DELAYLOAD(g_hMsimtf, Msimtf.dll, WINAPI, MsimtfIsGuidMapEnable, (HIMC himc,BOOL *pbGuidMap), (himc, pbGuidMap), BOOL, FALSE, TRUE)


HINSTANCE g_hMsctf = NULL;
DELAYLOAD(g_hMsctf, Msctf.dll, WINAPI, TF_CreateThreadMgr, (ITfThreadMgr **pptim), (pptim), HRESULT, E_FAIL, TRUE)
DELAYLOAD(g_hMsctf, Msctf.dll, WINAPI, TF_GetThreadMgr, (ITfThreadMgr **pptim), (pptim), HRESULT, E_FAIL, TRUE)
DELAYLOAD(g_hMsctf, Msctf.dll, WINAPI, TF_CreateInputProcessorProfiles, (ITfInputProcessorProfiles **ppipp), (ppipp), HRESULT, E_FAIL, TRUE)
DELAYLOAD(g_hMsctf, Msctf.dll, WINAPI, TF_DllDetachInOther, (void), (), BOOL, FALSE, FALSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\delay.h ===
//
// delay.h
//

#ifndef _DELAY_H_
#define _DELAY_H_

extern "C" BOOL WINAPI MsimtfIsWindowFiltered(HWND hwnd);
extern "C" BOOL WINAPI MsimtfIsGuidMapEnable(HIMC himc, BOOL *pbGuidmap);

extern "C" BOOL WINAPI TF_DllDetachInOther();

#endif _DELAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\editcomp.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    editcomp.cpp

Abstract:

    This file implements the EditCompositionString Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "editcomp.h"
#include "context.h"
#include "compstr.h"
#include "profile.h"
#include "delay.h"

// static BOOL fHanjaRequested = FALSE; // consider: this is not thread safe

/////////////////////////////////////////////////////////////////////////////
// EditCompositionString

//
// Set (almost) all in composition string
//

HRESULT
EditCompositionString::SetString(
    IMCLock& imc,
    CicInputContext& CicContext,
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompCursorPos* CompCursorPos,
    CWCompDeltaStart* CompDeltaStart,
    CWCompTfGuidAtom* CompGuid,
    OUT BOOL* lpbBufferOverflow,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause,
    CWInterimString* InterimStr
    )
{
    HRESULT hr;

#ifdef UNSELECTCHECK
    if (!_pAImeContext->m_fSelected)
        return S_OK;
#endif UNSELECTCHECK

#if 0
    DWORD dwImeCompatFlags = ImmGetAppCompatFlags((HIMC)imc);
#endif

    if (CicContext.m_fHanjaReConversion.IsSetFlag() ||
        CicContext.m_fInClearDocFeedEditSession.IsSetFlag())
    {
#if 0
        if ((dwImeCompatFlags & IMECOMPAT_AIMM_TRIDENT55) && CicContext.m_fHanjaReConversion.IsSetFlag())
            CicContext.m_fHanjaRequested.SetFlag();
#endif

        return S_OK;
    }

    //
    // Clear the contents of candidate list
    //
    imc.ClearCand();

    TRANSMSG msg;
    if (InterimStr) {
        hr = _MakeInterimData(imc,
                              InterimStr,
                              &msg.lParam);
    }
    else {
        hr = _MakeCompositionData(imc,
                                  CompStr, CompAttr, CompClause,
                                  CompCursorPos, CompDeltaStart,
                                  CompGuid,
                                  CompReadStr, CompReadAttr, CompReadClause,
                                  ResultStr, ResultClause,
                                  ResultReadStr, ResultReadClause,
                                  &msg.lParam,
                                  lpbBufferOverflow);
    }
    if ( hr == S_OK ||     // In case of valid dwCompSize in the CCompStrFactory::CreateCompositionString
        (hr == S_FALSE && CicContext.m_fStartComposition.IsSetFlag())
                           // In case of empty dwCompSize but still m_fStartComposition
       ) {
        //
        // Is available compstr/attr/clause, compread, result or resultread ?
        //
        bool fNoCompResultData = false;
        if (! (msg.lParam & (GCS_COMP | GCS_COMPREAD | GCS_RESULT | GCS_RESULTREAD))) {
            DebugMsg(TF_GENERAL, TEXT("EditCompositionString::SetString: No data in compstr, compread, result or resultread."));
            fNoCompResultData = true;
            if (CicContext.m_fStartComposition.IsResetFlag()) {
                DebugMsg(TF_ERROR, TEXT("EditCompositionString::SetString: No send WM_IME_STARTCOMPOSITION yet."));
                return S_FALSE;
            }
        }

#if 0
        //
        // New Trident(5.5 & 6.0) had a bug to convert Hanja.
        // So _GenerateHanja() funtion try to generate message like as Korean
        // legacy IME behavior.
        //
        // Send WM_IME_ENDCOMPOSITION and then WM_IME_COMPOSITION GCS_RESULT msg.
        //
        if ((dwImeCompatFlags & IMECOMPAT_AIMM_TRIDENT55) && CicContext.m_fHanjaRequested.IsSetFlag() &&
            !fNoCompResultData && (msg.lParam & GCS_RESULT))
        {
            LANGID langid = LANG_NEUTRAL;

            //
            // TLS doesn't inherit in edit session.
            //
            TLS* ptls = TLS::GetTLS();
            if (ptls != NULL)
            {
                CicProfile* _pProfile = ptls->GetCicProfile();
                if (_pProfile != NULL)
                {
                    _pProfile->GetLangId(&langid);
                }
            }

            CicContext.m_fHanjaRequested.ResetFlag();

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
            {
                return _GenerateKoreanComposition(imc, CicContext, ResultStr);
            }
        }

        CicContext.m_fHanjaRequested.ResetFlag();
#else
        LANGID langid = LANG_NEUTRAL;

        //
        // TLS doesn't inherit in edit session.
        //
        TLS* ptls = TLS::GetTLS();
        if (ptls != NULL)
        {
            CicProfile* _pProfile = ptls->GetCicProfile();
            if (_pProfile != NULL)
            {
                _pProfile->GetLangId(&langid);
            }
        }

        if (PRIMARYLANGID(langid) == LANG_KOREAN &&
            !fNoCompResultData && (msg.lParam & GCS_RESULT))
        {
            if (_GenerateKoreanComposition(imc, CicContext, ResultStr) == S_OK)
            {
                return S_OK;
            }
        }
#endif

        //
        // set private input context
        //
        bool fSetStartComp = false;

        if (CicContext.m_fStartComposition.IsResetFlag()) {
            CicContext.m_fStartComposition.SetFlag();
            TRANSMSG start_msg;
            start_msg.message = WM_IME_STARTCOMPOSITION;
            start_msg.wParam  = (WPARAM) 0;
            start_msg.lParam  = (LPARAM) 0;
            if (CicContext.m_pMessageBuffer) {
                CicContext.m_pMessageBuffer->SetData(start_msg);
                fSetStartComp = true;
            }
        }

        if (! fNoCompResultData) {
            msg.message = WM_IME_COMPOSITION;

            IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

            if (msg.lParam & GCS_RESULT)
            {
                msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));

                if (PRIMARYLANGID(langid) == LANG_KOREAN &&
                    msg.lParam & GCS_RESULTSTR)
                {
                    TRANSMSG comp_result_msg;

                    comp_result_msg.message = msg.message;
                    comp_result_msg.wParam = msg.wParam;
                    comp_result_msg.lParam = GCS_RESULTSTR;

                    //
                    // Only set GCS_RESULTSTR for compatibility(#487046).
                    //
                    if (CicContext.m_pMessageBuffer)
                        CicContext.m_pMessageBuffer->SetData(comp_result_msg);

                    msg.lParam &= ~GCS_RESULTSTR;

                    //
                    // Send another composition string message.
                    //
                    if (msg.lParam & GCS_COMPSTR)
                        msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwCompStrOffset));
                }
            }
            else
            {
                msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwCompStrOffset));
            }

            if (CicContext.m_pMessageBuffer) {
                CicContext.m_pMessageBuffer->SetData(msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then calls QueryCharPos().
                //
                if (fSetStartComp) {
                    TRANSMSG notify_msg;
                    notify_msg.message = WM_IME_NOTIFY;
                    notify_msg.wParam = (WPARAM)WM_IME_STARTCOMPOSITION;
                    notify_msg.lParam = 0;
                    CicContext.m_pMessageBuffer->SetData(notify_msg);
                }
            }
        }
        else {
            msg.message = WM_IME_COMPOSITION;
            if ((PRIMARYLANGID(langid) != LANG_JAPANESE))
            {
                msg.wParam = (WPARAM)VK_ESCAPE;
                msg.lParam = (LPARAM)(GCS_COMPREAD | GCS_COMP | GCS_CURSORPOS | GCS_DELTASTART);
            }
            else
            {
                //
                // #509247
                //
                // Some apps don't accept lParam without compstr in hIMC.
                //
                msg.wParam = 0;
                msg.lParam = 0;
            }

            if (CicContext.m_pMessageBuffer)
                CicContext.m_pMessageBuffer->SetData(msg);
        }

        if ((ResultStr && ResultStr->GetSize() && !(msg.lParam & GCS_COMP)) 
           || fNoCompResultData) {
            //
            // We're ending the composition
            //
            CicContext.m_fStartComposition.ResetFlag();
            TRANSMSG end_msg;
            end_msg.message = WM_IME_ENDCOMPOSITION;
            end_msg.wParam  = (WPARAM) 0;
            end_msg.lParam  = (LPARAM) 0;
            if (CicContext.m_pMessageBuffer) {
                CicContext.m_pMessageBuffer->SetData(end_msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then clear QueryCharPos's flag.
                //
                TRANSMSG notify_msg;
                notify_msg.message = WM_IME_NOTIFY;
                notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
                notify_msg.lParam = 0;
                CicContext.m_pMessageBuffer->SetData(notify_msg);

                if (CicContext.m_fInProcessKey.IsSetFlag())
                    CicContext.m_fGeneratedEndComposition.SetFlag();
            }
        }

#ifdef DEBUG
        IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
#endif

#if 0
        // Move to editses.cpp
        if (fGenerateMessage) {
            CicContext.GenerateMessage(imc);
        }
#endif
        hr = S_OK;

        //
        // Update the previous result string cache.
        //
        CicContext.UpdatePrevResultStr(imc);
    }

    return hr;
}


//
// Make composition string data in the IMCCLock<_COMPOSITIONSTRING> comp.
//

HRESULT
EditCompositionString::_MakeCompositionData(
    IMCLock& imc,
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompCursorPos* CompCursorPos,
    CWCompDeltaStart* CompDeltaStart,
    CWCompTfGuidAtom* CompGuid,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause,
    OUT LPARAM* lpdwFlag,
    OUT BOOL* lpbBufferOverflow
    )
{
    DebugMsg(TF_FUNC, TEXT("EditCompositionString::MakeCompositionData"));

    *lpdwFlag = (LPARAM) 0;

    HRESULT hr;

    CCompStrFactory compstrfactory(imc->hCompStr);
    if (FAILED(hr=compstrfactory.GetResult()))
        return hr;

    hr = compstrfactory.CreateCompositionString(CompStr,
                                                CompAttr,
                                                CompClause,
                                                CompGuid,
                                                CompReadStr,
                                                CompReadAttr,
                                                CompReadClause,
                                                ResultStr,
                                                ResultClause,
                                                ResultReadStr,
                                                ResultReadClause
                                              );
    if (FAILED(hr))
        return hr;

    //
    // Composition string
    //
    if (lpbBufferOverflow != NULL)
        *lpbBufferOverflow = FALSE;

    if (CompStr && CompStr->GetSize()) {
#if 0
        /*
         * If composition string length over the buffer of COMPOSITIONSTRING.compstr[NMAXKEY],
         * then we want to finalize this composition string.
         */
        if ((*comp)->dwCompStrLen >= NMAXKEY) {
            if (lpbBufferOverflow != NULL)
                *lpbBufferOverflow = TRUE;
            //
            // Clear compsition string length.
            //
            (*comp)->dwCompStrLen = 0;
            //
            // Make result string.
            //
            (*comp)->dwResultStrLen = NMAXKEY;
            CompStr->ReadCompData((*comp)->W.resultstr, ARRAYSIZE((*comp)->W.resultstr));
            *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
        }
        else
#endif
        {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*CompStr,
                                                               &compstrfactory->dwCompStrLen,
                                                               &compstrfactory->dwCompStrOffset
                                                              );
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_COMPSTR;
            else
                goto Exit;
        }
    }

    if ((lpbBufferOverflow == NULL) ||
        (lpbBufferOverflow != NULL && (! *lpbBufferOverflow))) {

        //
        // Compoition attribute
        //
        if (CompAttr && CompAttr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompAttr,
                                                                 &compstrfactory->dwCompAttrLen,
                                                                 &compstrfactory->dwCompAttrOffset
                                                                );
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_COMPATTR;
            else
                goto Exit;
        }

        //
        // Compoition clause
        //
        if (CompClause && CompClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*CompClause,
                                                               &compstrfactory->dwCompClauseLen,
                                                               &compstrfactory->dwCompClauseOffset
                                                              );
            compstrfactory->dwCompClauseLen *= sizeof(DWORD);
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_COMPCLAUSE;
            else
                goto Exit;
        }

        //
        // Composition Reading string
        //
        if (CompReadStr && CompReadStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*CompReadStr,
                                                               &compstrfactory->dwCompReadStrLen,
                                                               &compstrfactory->dwCompReadStrOffset
                                                              );
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_COMPREADSTR;
            else
                goto Exit;
        }

        //
        // Compoition Reading attribute
        //
        if (CompReadAttr && CompReadAttr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompReadAttr,
                                                                 &compstrfactory->dwCompReadAttrLen,
                                                                 &compstrfactory->dwCompReadAttrOffset
                                                                );
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_COMPREADATTR;
            else
                goto Exit;
        }

        //
        // Composition Reading clause
        //
        if (CompReadClause && CompReadClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*CompReadClause,
                                                               &compstrfactory->dwCompReadClauseLen,
                                                               &compstrfactory->dwCompReadClauseOffset
                                                              );
            compstrfactory->dwCompReadClauseLen *= sizeof(DWORD);
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_COMPREADCLAUSE;
            else
                goto Exit;
        }

        //
        // Result String
        //
        if (ResultStr && ResultStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*ResultStr,
                                                               &compstrfactory->dwResultStrLen,
                                                               &compstrfactory->dwResultStrOffset
                                                              );
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
            else
                goto Exit;
        }

        //
        // Result clause
        //
        if (ResultClause && ResultClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*ResultClause,
                                                               &compstrfactory->dwResultClauseLen,
                                                               &compstrfactory->dwResultClauseOffset
                                                              );
            compstrfactory->dwResultClauseLen *= sizeof(DWORD);
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_RESULTCLAUSE;
            else
                goto Exit;
        }

        //
        // Result Reading string
        //
        if (ResultReadStr && ResultReadStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*ResultReadStr,
                                                               &compstrfactory->dwResultReadStrLen,
                                                               &compstrfactory->dwResultReadStrOffset
                                                              );
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_RESULTREADSTR;
            else
                goto Exit;
        }

        //
        // Result Reading clause
        //
        if (ResultReadClause && ResultReadClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*ResultReadClause,
                                                               &compstrfactory->dwResultReadClauseLen,
                                                               &compstrfactory->dwResultReadClauseOffset
                                                              );
            compstrfactory->dwResultReadClauseLen *= sizeof(DWORD);
            if (SUCCEEDED(hr))
                *lpdwFlag |= (LPARAM) GCS_RESULTREADCLAUSE;
            else
                goto Exit;
        }

        //
        // TfGuidAtom
        //
        if (CompGuid && CompGuid->GetSize()) {
            hr = compstrfactory.MakeGuidMapAttribute(CompGuid, CompAttr);
            if (SUCCEEDED(hr))
            {
                // set INIT_GUID_ATOM flag in the fdwInit.
                imc->fdwInit |= INIT_GUID_ATOM;
            }
            else
                goto Exit;
        }
    }

    //
    // Composition Cursor Position
    //
    if (CompCursorPos && CompCursorPos->GetSize()) {
        CompCursorPos->ReadCompData(&compstrfactory->dwCursorPos, 1);
        *lpdwFlag |= (LPARAM) GCS_CURSORPOS;
    }

    //
    // Delta Start
    //
    if (CompDeltaStart && CompDeltaStart->GetSize()) {
        CompDeltaStart->ReadCompData(&compstrfactory->dwDeltaStart, 1);
        *lpdwFlag |= (LPARAM) GCS_DELTASTART;
    }

Exit:
    //
    // Copy back hCompStr to the Input Context
    //
    imc->hCompStr = compstrfactory.GetHandle();

    return hr;
}

//
// Make interim string data in the IMCCLock<_COMPOSITIONSTRING> comp.
//

HRESULT
EditCompositionString::_MakeInterimData(
    IMCLock& imc,
    CWInterimString* InterimStr,
    LPARAM* lpdwFlag
    )
{
    DebugMsg(TF_FUNC, TEXT("EditCompositionString::MakeInterimData"));

    *lpdwFlag = (LPARAM) 0;

    //
    // Interim character and result string
    //

    HRESULT hr;

    CCompStrFactory compstrfactory(imc->hCompStr);
    if (FAILED(hr=compstrfactory.GetResult()))
        return hr;

    hr = compstrfactory.CreateCompositionString(InterimStr);
    if (FAILED(hr))
        return hr;

    //
    // Result string
    //
    if (InterimStr && InterimStr->GetSize()) {
        hr = compstrfactory.WriteData<CWInterimString, WCHAR>(*InterimStr,
                                                              &compstrfactory->dwResultStrLen,
                                                              &compstrfactory->dwResultStrOffset
                                                             );
        *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
    }

    //
    // Composition string (Interim character)
    // Compoition attribute
    //
    CWCompString ch;
    CWCompAttribute attr;
    InterimStr->ReadInterimChar(&ch, &attr);
    if (ch.GetSize() && ch.GetAt(0)) {
        hr = compstrfactory.WriteData<CWCompString, WCHAR>(ch,
                                                           &compstrfactory->dwCompStrLen,
                                                           &compstrfactory->dwCompStrOffset
                                                          );
        *lpdwFlag |= (LPARAM) GCS_COMPSTR;

        hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(attr,
                                                             &compstrfactory->dwCompAttrLen,
                                                             &compstrfactory->dwCompAttrOffset
                                                            );
        *lpdwFlag |= (LPARAM) GCS_COMPATTR;

        *lpdwFlag |= (LPARAM) CS_INSERTCHAR | CS_NOMOVECARET;
    }

    //
    // Copy back hCompStr to the Input Context
    //
    imc->hCompStr = compstrfactory.GetHandle();

    return hr;
}


//
// Generate WM_IME_ENDCOMPOSITION and WM_IME_COMPOSITION message for
// Trident 5.5 version. Since Trident 5.5 always expect WM_IME_ENDCOMPOSITION
// first in case of Hanja conversion.
//

HRESULT
EditCompositionString::_GenerateKoreanComposition(
    IMCLock& imc,
    CicInputContext& CicContext,
    CWCompString* ResultStr)
{
    HRESULT hr = S_FALSE;

    DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
    BOOL fEndCompFirst = FALSE;

    if (!MsimtfIsWindowFiltered(::GetFocus()) ||
        (dwImeCompatFlags & IMECOMPAT_AIMM12_TRIDENT))
    {
        fEndCompFirst = TRUE;
    }

    if (ResultStr && ResultStr->GetSize())
    {
        //
        // We're ending the composition
        //
        CicContext.m_fStartComposition.ResetFlag();

        if (fEndCompFirst)
        {
            TRANSMSG end_msg;
            end_msg.message = WM_IME_ENDCOMPOSITION;
            end_msg.wParam  = (WPARAM) 0;
            end_msg.lParam  = (LPARAM) 0;

            if (CicContext.m_pMessageBuffer)
            {
                CicContext.m_pMessageBuffer->SetData(end_msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then clear QueryCharPos's flag.
                //
                TRANSMSG notify_msg;

                notify_msg.message = WM_IME_NOTIFY;
                notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
                notify_msg.lParam = 0;
                CicContext.m_pMessageBuffer->SetData(notify_msg);

                if (CicContext.m_fInProcessKey.IsSetFlag())
                    CicContext.m_fGeneratedEndComposition.SetFlag();
            }

            TRANSMSG result_msg;
            result_msg.message = WM_IME_COMPOSITION;
            result_msg.lParam = GCS_RESULTSTR;

            IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

            result_msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));

            if (CicContext.m_pMessageBuffer)
            {
                CicContext.m_pMessageBuffer->SetData(result_msg);
            }
        }
        else
        {
            TRANSMSG result_msg;
            result_msg.message = WM_IME_COMPOSITION;
            result_msg.lParam = GCS_RESULTSTR;

            IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

            result_msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));

            if (CicContext.m_pMessageBuffer)
            {
                CicContext.m_pMessageBuffer->SetData(result_msg);
            }

            TRANSMSG end_msg;
            end_msg.message = WM_IME_ENDCOMPOSITION;
            end_msg.wParam  = (WPARAM) 0;
            end_msg.lParam  = (LPARAM) 0;

            if (CicContext.m_pMessageBuffer)
            {
                CicContext.m_pMessageBuffer->SetData(end_msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then clear QueryCharPos's flag.
                //
                TRANSMSG notify_msg;

                notify_msg.message = WM_IME_NOTIFY;
                notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
                notify_msg.lParam = 0;
                CicContext.m_pMessageBuffer->SetData(notify_msg);

                if (CicContext.m_fInProcessKey.IsSetFlag())
                    CicContext.m_fGeneratedEndComposition.SetFlag();
            }
        }

        hr = S_OK;
    }

#ifdef DEBUG
    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
#endif

#if 0
    // Move to editses.cpp
    if (fGenerateMessage)
    {
        imc.GenerateMessage();
    }
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\editses.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    editses.cpp

Abstract:

    This file implements the EditSession Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "editses.h"
#include "compstr.h"
#include "reconvps.h"
#include "delay.h"
#include "profile.h"

/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSessionCallBack

HRESULT
ImmIfEditSessionCallBack::GetAllTextRange(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>* range,
    LONG* lpTextLength,
    TF_HALTCOND* lpHaltCond
    )
{
    ITfRange *rangeFull = NULL;
    HRESULT hr;
    BOOL fFound = FALSE;
    BOOL fIsReadOnlyRange = FALSE;
    ITfProperty *prop;
    ITfRange *rangeTmp;
    LONG cch;

    //
    // init lpTextLength first.
    //
    *lpTextLength = 0;

    //
    // Create the range that covers all the text.
    //
    if (FAILED(hr=ic->GetStart(ec, &rangeFull)))
        return hr;

    if (FAILED(hr=rangeFull->ShiftEnd(ec, LONG_MAX, &cch, lpHaltCond)))
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, rangeFull)))
        {
            while(!fFound && (enumranges->Next(1, &rangeTmp, NULL) == S_OK))
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_EMPTY) || (var.lVal == 0))
                {
                    fFound = TRUE;
                    hr = rangeTmp->Clone(*range);
                    rangeTmp->Release();
                    break;
                }

                fIsReadOnlyRange = TRUE;
                rangeTmp->Release();

                VariantClear(&var);
            }
            enumranges->Release();
        }
        prop->Release();
    }

    if (FAILED(hr))
        return hr;

    if (!fFound)
    {
        if (fIsReadOnlyRange)
        {
            //
            // all text store is readonly. So we just return an empty range.
            //
            if (FAILED(hr = GetSelectionSimple(ec, ic.GetPtr(), *range)))
                return hr;

            if (FAILED(hr = (*range)->Collapse(ec, TF_ANCHOR_START)))
                return hr;
        }
        else 
        {
            if (FAILED(hr = rangeFull->Clone(*range)))
                return hr;

            *lpTextLength = cch;
        }
    }
    else
    {

        if (SUCCEEDED((*range)->Clone(&rangeTmp)))
        {
            BOOL fEmpty;
            WCHAR wstr[256 + 1];
            ULONG ul = 0;

            while (rangeTmp->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
            {
                ULONG ulcch;
                rangeTmp->GetText(ec, 
                                  TF_TF_MOVESTART, 
                                  wstr, 
                                  ARRAYSIZE(wstr) - 1, 
                                  &ulcch);
                ul += ulcch;
            }

            rangeTmp->Release();

            *lpTextLength = (LONG)ul;
        }
    }

    SafeRelease(rangeFull);

    return S_OK;
}


HRESULT
ImmIfEditSessionCallBack::SetTextInRange(
    TfEditCookie ec,
    ITfRange* range,
    LPWSTR psz,
    DWORD len,
    CicInputContext& CicContext
    )
{
    CicContext.m_fModifyingDoc.SetFlag();

    //
    // Set the text in Cicero TOM
    //
    HRESULT hr = range->SetText(ec, 0, psz, len);

    CicContext.m_fModifyingDoc.ResetFlag();

    return hr;
}


HRESULT
ImmIfEditSessionCallBack::ClearTextInRange(
    TfEditCookie ec,
    ITfRange* range,
    CicInputContext& CicContext
    )
{
    //
    // Clear the text in Cicero TOM
    //
    return SetTextInRange(ec, range, NULL, 0, CicContext);
}


HRESULT
ImmIfEditSessionCallBack::GetReadingString(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    CWCompString& reading_string,
    CWCompClause& reading_clause
    )
{
    HRESULT hr;

    Interface<ITfRange> range;
    LONG l;
    if (FAILED(hr=GetAllTextRange(ec, ic, &range, &l)))
        return hr;

    return GetReadingString(ec, ic, range, reading_string, reading_clause);
}

HRESULT
ImmIfEditSessionCallBack::GetReadingString(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    ITfRange* range,
    CWCompString& reading_string,
    CWCompClause& reading_clause
    )
{
    HRESULT hr;

    EnumReadingPropertyArgs args;
    if (FAILED(hr=ic->GetProperty(GUID_PROP_READING, args.Property)))
        return hr;

    Interface<IEnumTfRanges> EnumReadingProperty;
    hr = args.Property->EnumRanges(ec, EnumReadingProperty, range);
    if (FAILED(hr))
        return hr;

    args.ec = ec;
    args.reading_string = &reading_string;
    args.reading_clause = &reading_clause;
    args.ulClausePos = (reading_clause.GetSize() > 0 ? reading_clause[ reading_clause.GetSize() - 1]
                                                     : 0);

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumReadingPropertyArgs>  Enumrate(EnumReadingProperty,
                                                          EnumReadingPropertyCallback,
                                                          &args);      // Argument of callback func.
    Enumrate.DoEnumrate();

    return S_OK;
}

//
// Enumrate callbacks
//

/* static */
ENUM_RET
ImmIfEditSessionCallBack::EnumReadingPropertyCallback(
    ITfRange* pRange,
    EnumReadingPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        if (V_VT(&var) == VT_BSTR) {
            BSTR bstr = V_BSTR(&var);
            LONG cch = SysStringLen(bstr);
            pargs->reading_string->AddCompData(bstr, cch);

            if (pargs->reading_clause->GetSize() == 0)
                pargs->reading_clause->Add(0);

            pargs->reading_clause->Add( pargs->ulClausePos += cch );
        }
        VariantClear(&var);
    }

    return ret;
}


HRESULT
ImmIfEditSessionCallBack::CompClauseToResultClause(
    IMCLock& imc,
    CWCompClause& result_clause,
    UINT          cch
    )
{
    LONG num_of_written;

    // Check GCS_COMPCLAUSE office set
    IMCCLock<COMPOSITIONSTRING> lpCompStr(imc->hCompStr);
    if (lpCompStr.Invalid())
        return E_FAIL;

    if (lpCompStr->dwCompClauseOffset > lpCompStr->dwSize)
        return E_FAIL;

    if (lpCompStr->dwCompClauseOffset + lpCompStr->dwCompClauseLen > lpCompStr->dwSize)
        return E_FAIL;

    if (num_of_written=ImmGetCompositionStringW((HIMC)imc,
                                                GCS_COMPCLAUSE,
                                                NULL,
                                                0)) {
        DWORD* buffer = new DWORD[ num_of_written / sizeof(DWORD) ];
        if (buffer != NULL) {
            num_of_written = ImmGetCompositionStringW((HIMC)imc,
                                                      GCS_COMPCLAUSE,
                                                      buffer,
                                                      num_of_written);

            int idx = num_of_written / sizeof(DWORD);
            if (idx > 1)
            {
                idx -= 1;
                if (buffer[idx] == cch)
                {
                    result_clause.WriteCompData(buffer, num_of_written / sizeof(DWORD));
                }
                else
                {
                    // this is the case comp clause is corrupted
                    // it is the least we can do for the failure case
                    buffer[0] = 0;
                    buffer[1] = cch;
                    result_clause.WriteCompData(buffer, 2);
                }
            }

            delete [] buffer;
        }
    }
    return S_OK;
}

HRESULT
ImmIfEditSessionCallBack::CheckStrClauseAndReadClause(
    CWCompClause& str_clause,
    CWCompClause& reading_clause,
    LONG cch
    )
{
    if (str_clause.GetSize() == reading_clause.GetSize())
        return S_OK;

     //
     // string clause and reading clause is not much size of buffer array.
     // some office application expect that two clause should the same buffer length.
     //
     str_clause.RemoveAll();
     reading_clause.RemoveAll();

     str_clause.Add(0);
     str_clause.Add(cch);

     reading_clause.Add(0);
     reading_clause.Add(cch);

     return S_OK;
}


//
// Get cursor position
//
HRESULT
ImmIfEditSessionCallBack::_GetCursorPosition(
    TfEditCookie ec,
    IMCLock& imc,
    CicInputContext& CicContext,
    Interface_Attach<ITfContext>& ic,
    CWCompCursorPos& CompCursorPos,
    CWCompAttribute& CompAttr
    )
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        return E_OUTOFMEMORY;
    }
    LANGID langid;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImmIfEditSessionCallBack::_GetCursorPosition. _pProfile==NULL."));
        return E_FAIL;
    }

    _pProfile->GetLangId(&langid);

    CicInputContext::IME_QUERY_POS qpos = CicInputContext::IME_QUERY_POS_UNKNOWN;

    if (CicContext.m_fStartComposition.IsSetFlag()) {
        //
        // This method should not call before sending WM_IME_STARTCOMPOSITION
        // because some apps confusing to receive QUERYCHARPOSITION due to
        // no composing.
        //
        CicContext.InquireIMECharPosition(langid, imc, &qpos);
    }

    //
    // Is apps support "query positioning" ?
    //
    DWORD dwImeCompatFlags = ImmGetAppCompatFlags((HIMC)imc);
    if (((dwImeCompatFlags & IMECOMPAT_AIMM_LEGACY_CLSID) || (dwImeCompatFlags & IMECOMPAT_AIMM12_TRIDENT)) &&
        (qpos != CicInputContext::IME_QUERY_POS_YES) &&
        MsimtfIsWindowFiltered(imc->hWnd)) {
        //
        // IE5.0 candidate window positioning code.
        // They except of it position from COMPOSITIONSTRING.dwCursorPos.
        //
        INT_PTR ich = 0;
        if (_FindCompAttr(CompAttr, ATTR_TARGET_CONVERTED, &ich) == S_OK)
        {
            CompCursorPos.Set((DWORD)ich);
            return S_OK;
        }

    }

    //
    // Japanese IME cursor position behavior.
    //
    if (PRIMARYLANGID(langid) == LANG_JAPANESE)
    {
        IME_UIWND_STATE uists;
        uists = UIComposition::InquireImeUIWndState(imc);

        if (CicContext.m_fStartComposition.IsSetFlag() &&
            // even close CandidateWindow, cursor position should move to ATTR_TARGET_CONVERTED
            //
            // CicContext.m_fOpenCandidateWindow.IsSetFlag() &&
            uists == IME_UIWND_LEVEL3 &&
            qpos == CicInputContext::IME_QUERY_POS_NO)
        {
            INT_PTR ich = 0;
            if (_FindCompAttr(CompAttr, ATTR_TARGET_CONVERTED, &ich) == S_OK)
            {
                CompCursorPos.Set((DWORD)ich);
                return S_OK;
            }
        }
    }



    HRESULT hr;
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (SUCCEEDED(hr = ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched))) {
        Interface<ITfRange> start;
        LONG ich;
        TF_HALTCOND hc;

        hc.pHaltRange = sel->range;
        hc.aHaltPos = (sel->style.ase == TF_AE_START) ? TF_ANCHOR_START : TF_ANCHOR_END;
        hc.dwFlags = 0;

        if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &ich, &hc))) {
            CompCursorPos.Set(ich);
        }
    }

    return hr;
}


HRESULT
ImmIfEditSessionCallBack::_FindCompAttr(
    CWCompAttribute& CompAttr,
    BYTE bAttr,
    INT_PTR* pich)
{
    INT_PTR ich = 0;
    INT_PTR attr_size;

    if (attr_size = CompAttr.GetSize()) {
        while (ich < attr_size && CompAttr[ich] != bAttr)
            ich++;
        if (ich < attr_size) {
            *pich = ich;
            return S_OK;
        }
    }
    return S_FALSE;
}


//
// Get text and attribute in given range
//
//                                ITfRange::range
//   TF_ANCHOR_START
//    |======================================================================|
//                        +--------------------+          #+----------+
//                        |ITfRange::pPropRange|          #|pPropRange|
//                        +--------------------+          #+----------+
//                        |     GUID_ATOM      |          #
//                        +--------------------+          #
//    ^^^^^^^^^^^^^^^^^^^^                      ^^^^^^^^^^#
//    ITfRange::gap_range                       gap_range #
//                                                        #
//                                                        V
//                                                        ITfRange::no_display_attribute_range
//                                                   result_comp
//                                          +1   <-       0    ->     -1
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttribute(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    CicInputContext& CicContext,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& rangeIn,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& CompReadStr,
    CWCompClause& CompReadClause,
    CWCompString& ResultStr,
    CWCompClause& ResultClause,
    CWCompString& ResultReadStr,
    CWCompClause& ResultReadClause,
    BOOL bInWriteSession
    )
{
    //
    // Get no display attribute range if there exist.
    // Otherwise, result range is the same to input range.
    //
    LONG result_comp;
    Interface<ITfRange> no_display_attribute_range;
    if (FAILED(rangeIn->Clone(no_display_attribute_range)))
        return E_FAIL;

    const GUID* guids[] = {&GUID_PROP_COMPOSING,
                           &GUID_PROP_MSIMTF_PREPARE_RECONVERT};
    const int   guid_size = sizeof(guids) / sizeof(GUID*);

    if (FAILED(_GetNoDisplayAttributeRange(pLibTLS,
                                           ec,
                                           ic,
                                           rangeIn,
                                           guids, guid_size,
                                           no_display_attribute_range)))
        return E_FAIL;

    IME_UIWND_STATE uists;
    uists = UIComposition::InquireImeUIWndState(imc);


    Interface<ITfReadOnlyProperty> propComp;
    Interface<IEnumTfRanges> enumComp;
    HRESULT hr;

    if (FAILED(hr = ic->TrackProperties(guids, guid_size,       // system property
                                        NULL, 0,                // application property
                                        propComp)))
        return FALSE;


    if (FAILED(hr = propComp->EnumRanges(ec, enumComp, rangeIn)))
        return hr;

    CompClause.Add(0);         // setup composition clause at 0
    ResultClause.Add(0);       // setup result clause at 0

    Interface<ITfRange>  range;
    while(enumComp->Next(1, range, NULL) == S_OK)
    {
        VARIANT var;
        BOOL fCompExist = FALSE;

        hr = propComp->GetValue(ec, range, &var);
        if (S_OK == hr)
        {

            Interface<IEnumTfPropertyValue> EnumPropVal;
            hr = var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, EnumPropVal);
            if (SUCCEEDED(hr)) {
                TF_PROPERTYVAL tfPropertyVal;

                while (EnumPropVal->Next(1, &tfPropertyVal, NULL) == S_OK) {
                    for (int i=0; i < guid_size; i++) {
                        if (IsEqualGUID(tfPropertyVal.guidId, *guids[i])) {
                            if ((V_VT(&tfPropertyVal.varValue) == VT_I4 && V_I4(&tfPropertyVal.varValue) != 0)) {
                                fCompExist = TRUE;
                                break;
                            }
                        }
                    }

                    VariantClear(&tfPropertyVal.varValue);

                    if (fCompExist)
                        break;
                }
            }

        }

        VariantClear(&var);

        ULONG ulNumProp;

        //
        // Get display attribute track property range
        //
        Interface<IEnumTfRanges> enumProp;
        Interface<ITfReadOnlyProperty> prop;
        if (FAILED(GetDisplayAttributeTrackPropertyRange(ec, ic.GetPtr(), range, prop, enumProp, &ulNumProp))) {
            return E_FAIL;
        }
    
        // use text range for get text
        Interface<ITfRange> textRange;
        if (FAILED(range->Clone(textRange)))
            return E_FAIL;

        // use text range for gap text (no property range).
        Interface<ITfRange> gap_range;
        if (FAILED(range->Clone(gap_range)))
            return E_FAIL;


        ITfRange* pPropRange = NULL;
        while (enumProp->Next(1, &pPropRange, NULL) == S_OK) {

            // pick up the gap up to the next property
            gap_range->ShiftEndToRange(ec, pPropRange, TF_ANCHOR_START);

            //
            // GAP range
            //
            no_display_attribute_range->CompareStart(ec,
                                                     gap_range,
                                                     TF_ANCHOR_START,
                                                     &result_comp);
            _GetTextAndAttributeGapRange(pLibTLS,
                                         ec,
                                         uists,
                                         CicContext,
                                         gap_range,
                                         result_comp,
                                         CompStr, CompAttr, CompClause, CompGuid,
                                         ResultStr, ResultClause);

            //
            // Get display attribute data if some GUID_ATOM exist.
            //
            TF_DISPLAYATTRIBUTE da;
            TfGuidAtom guidatom = TF_INVALID_GUIDATOM;

            GetDisplayAttributeData(pLibTLS, ec, prop, pPropRange, &da, &guidatom, ulNumProp);

            
            //
            // Property range
            //
            no_display_attribute_range->CompareStart(ec,
                                                     pPropRange,
                                                     TF_ANCHOR_START,
                                                     &result_comp);

            // Adjust GAP range's start anchor to the end of proprty range.
            gap_range->ShiftStartToRange(ec, pPropRange, TF_ANCHOR_END);
    
            //
            // Get reading string from property.
            //
            if (fCompExist == TRUE && result_comp <= 0)
                GetReadingString(ec, ic, pPropRange, CompReadStr, CompReadClause);
            else
                GetReadingString(ec, ic, pPropRange, ResultReadStr, ResultReadClause);
    
            //
            // Get property text
            //
            _GetTextAndAttributePropertyRange(pLibTLS,
                                              ec,
                                              imc,
                                              uists,
                                              CicContext,
                                              pPropRange,
                                              fCompExist,
                                              result_comp,
                                              bInWriteSession,
                                              da,
                                              guidatom,
                                              CompStr, CompAttr, CompClause, CompGuid,
                                              ResultStr, ResultClause);

            SafeReleaseClear(pPropRange);

        } // while

        // the last non-attr
        textRange->ShiftStartToRange(ec, gap_range, TF_ANCHOR_START);
        textRange->ShiftEndToRange(ec, range, TF_ANCHOR_END);

        LONG ulClausePos = 0;
        BOOL fEmpty;
        while (textRange->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
        {
            WCHAR wstr0[256 + 1];
            ULONG ulcch0 = ARRAYSIZE(wstr0) - 1;
            textRange->GetText(ec, TF_TF_MOVESTART, wstr0, ulcch0, &ulcch0);

            TfGuidAtom guidatom;
            guidatom = TF_INVALID_GUIDATOM;

            TF_DISPLAYATTRIBUTE da;
            da.bAttr = TF_ATTR_INPUT;

            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(uists, da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
            ulClausePos += ulcch0;
        }

        if (ulClausePos) {
            DWORD last_clause;
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        textRange->Collapse(ec, TF_ANCHOR_END);

        range->Release();
        *(ITfRange **)(range) = NULL;

    } // out-most while for GUID_PROP_COMPOSING

    //
    // Fix up empty comp clause
    //
    if (CompClause.GetSize() <= 1)
    {
        CompClause.RemoveAll();
        CompReadClause.RemoveAll();
    }
    else
    {
        //
        // Check StrClause and ReadClause
        //
        // #578666
        // we should not break CompClause if there is no reading string.
        //
        if (CompReadStr.GetSize())
            CheckStrClauseAndReadClause(CompClause, CompReadClause, (LONG)CompStr.GetSize());
    }

    //
    // Fix up empty result clause
    //
    if (ResultClause.GetSize() <= 1)
    {
        ResultClause.RemoveAll();
        ResultReadClause.RemoveAll();
    }
    else
    {
        //
        // Check StrClause and ReadClause
        //
        CheckStrClauseAndReadClause(ResultClause, ResultReadClause, (LONG)ResultStr.GetSize());
    }

    //
    // set GUID_PROP_MSIMTF_TRACKCOMPOSITION
    //
    Interface<ITfProperty> PropertyTrackComposition;

    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_TRACKCOMPOSITION,
                                 PropertyTrackComposition)))
    {
        VARIANT var;
        var.vt = VT_I4;
        var.lVal = 1;
        PropertyTrackComposition->SetValue(ec, rangeIn, &var);
    }
    return S_OK;
}

//
// Retrieve text from gap range
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttributeGapRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IME_UIWND_STATE uists,
    CicInputContext& CicContext,
    Interface<ITfRange>& gap_range,
    LONG result_comp,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& ResultStr,
    CWCompClause& ResultClause
    )
{
    TfGuidAtom guidatom;
    guidatom = TF_INVALID_GUIDATOM;

    TF_DISPLAYATTRIBUTE da;
    da.bAttr = TF_ATTR_INPUT;

    ULONG ulClausePos = 0;
    BOOL fEmpty;
    WCHAR wstr0[256 + 1];
    ULONG ulcch0;


    while (gap_range->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        Interface<ITfRange> backup_range;
        if (FAILED(gap_range->Clone(backup_range)))
            return E_FAIL;

        //
        // Retrieve gap text if there exist.
        //
        ulcch0 = ARRAYSIZE(wstr0) - 1;
        if (FAILED(gap_range->GetText(ec,
                           TF_TF_MOVESTART,    // Move range to next after get text.
                           wstr0,
                           ulcch0, &ulcch0)))
            return E_FAIL;

        ulClausePos += ulcch0;

        if (result_comp <= 0) {
            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(uists, da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
        }
        else {
            ResultStr.AddCompData(wstr0, ulcch0);
            ClearTextInRange(ec, backup_range, CicContext);
        }
    }

    if (ulClausePos) {
        DWORD last_clause;
        if (result_comp <= 0) {
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        else {
            if (ResultClause.GetSize() > 0) {
                last_clause = ResultClause[ ResultClause.GetSize() - 1 ];
                ResultClause.Add( last_clause + ulClausePos );
            }
        }
    }

    return S_OK;
}

//
// Retrieve text from property range
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttributePropertyRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    IME_UIWND_STATE uists,
    CicInputContext& CicContext,
    ITfRange* pPropRange,
    BOOL fCompExist,
    LONG result_comp,
    BOOL bInWriteSession,
    TF_DISPLAYATTRIBUTE da,
    TfGuidAtom guidatom,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& ResultStr,
    CWCompClause& ResultClause
    )
{
    ULONG ulClausePos = 0;
    BOOL fEmpty;
    WCHAR wstr0[256 + 1];
    ULONG ulcch0;

    while (pPropRange->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        Interface<ITfRange> backup_range;
        if (FAILED(pPropRange->Clone(backup_range)))
            return E_FAIL;

        //
        // Retrieve property text if there exist.
        //
        ulcch0 = ARRAYSIZE(wstr0) - 1;
        if (FAILED(pPropRange->GetText(ec,
                            TF_TF_MOVESTART,    // Move range to next after get text.
                            wstr0,
                            ulcch0, &ulcch0)))
            return E_FAIL;

        ulClausePos += ulcch0;  // we only need to addup the char position for clause info

        // see if there is a valid disp attribute
        if (fCompExist == TRUE && result_comp <= 0)
        {
            if (guidatom == TF_INVALID_GUIDATOM) {
                da.bAttr = TF_ATTR_INPUT;
            }
            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(uists, da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
        }
        else if (bInWriteSession)
        {
            // if there's no disp attribute attached, it probably means 
            // the part of string is finalized.
            //
            ResultStr.AddCompData(wstr0, ulcch0);
            
            // it was a 'determined' string
            // so the doc has to shrink
            //
            ClearTextInRange(ec, backup_range, CicContext);
        }
        else
        {
            //
            // Prevent infinite loop
            //
            break;
        }
    }

    if (ulClausePos) {
        DWORD last_clause;
        if (fCompExist == TRUE && result_comp <= 0) {
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        else if (result_comp == 0) {
            //
            // Copy CompClause data to ResultClause
            //
            CompClauseToResultClause(imc, ResultClause, ulcch0);
        }
        else {
            if (ResultClause.GetSize() > 0) {
                last_clause = ResultClause[ ResultClause.GetSize() - 1 ];
                ResultClause.Add( last_clause + ulClausePos );
            }
        }
    }

    return S_OK;
}

HRESULT
ImmIfEditSessionCallBack::_GetNoDisplayAttributeRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& rangeIn,
    const GUID** guids,
    const int guid_size,
    Interface<ITfRange>& no_display_attribute_range
    )
{

    Interface<ITfReadOnlyProperty> propComp;
    Interface<IEnumTfRanges> enumComp;

    HRESULT hr = ic->TrackProperties(guids, guid_size,       // system property
                                     NULL, 0,                // application property
                                     propComp);
    if (FAILED(hr))
        return hr;

    hr = propComp->EnumRanges(ec, enumComp, rangeIn);
    if (FAILED(hr))
        return hr;

    ITfRange *pRange;

    while(enumComp->Next(1, &pRange, NULL) == S_OK)
    {
        VARIANT var;
        BOOL fCompExist = FALSE;

        hr = propComp->GetValue(ec, pRange, &var);
        if (S_OK == hr)
        {

            Interface<IEnumTfPropertyValue> EnumPropVal;
            hr = var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, EnumPropVal);
            if (SUCCEEDED(hr)) {
                TF_PROPERTYVAL tfPropertyVal;

                while (EnumPropVal->Next(1, &tfPropertyVal, NULL) == S_OK) {
                    for (int i=0; i < guid_size; i++) {
                        if (IsEqualGUID(tfPropertyVal.guidId, *guids[i])) {
                            if ((V_VT(&tfPropertyVal.varValue) == VT_I4 && V_I4(&tfPropertyVal.varValue) != 0)) {
                                fCompExist = TRUE;
                                break;
                            }
                        }
                    }

                    VariantClear(&tfPropertyVal.varValue);

                    if (fCompExist)
                        break;
                }
            }

        }

        if (!fCompExist) {

            // Adjust GAP range's start anchor to the end of proprty range.
            no_display_attribute_range->ShiftStartToRange(ec, pRange, TF_ANCHOR_START);
        }

        VariantClear(&var);

        pRange->Release();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSession::_Init

void 
ImmIfEditSession::_Init(
    ESCB escb
    )
{
    m_pfnCallback = EditSessionCallBack;
    m_cRef        = 1;

    m_ImmIfCallBack  = NULL;

    switch(escb) {
        case ESCB_HANDLETHISKEY:
            m_ImmIfCallBack = new ImmIfHandleThisKey(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_COMPCOMPLETE:
            m_ImmIfCallBack = new ImmIfCompositionComplete(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_COMPCANCEL:
            m_ImmIfCallBack = new ImmIfCompositionCancel(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_UPDATECOMPOSITIONSTRING:
            m_ImmIfCallBack = new ImmIfUpdateCompositionString(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_REPLACEWHOLETEXT:
            m_ImmIfCallBack = new ImmIfReplaceWholeText(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_RECONVERTSTRING:
            m_ImmIfCallBack = new ImmIfReconvertString(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_CLEARDOCFEEDBUFFER:
            m_ImmIfCallBack = new ImmIfClearDocFeedBuffer(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_GETTEXTANDATTRIBUTE:
            m_ImmIfCallBack = new ImmIfGetTextAndAttribute(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_QUERYRECONVERTSTRING:
            m_ImmIfCallBack = new ImmIfQueryReconvertString(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_CALCRANGEPOS:
            m_ImmIfCallBack = new ImmIfCalcRangePos(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_GETSELECTION:
            m_ImmIfCallBack = new ImmIfGetSelection(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_GET_READONLY_PROP_MARGIN:
            m_ImmIfCallBack = new ImmIfGetReadOnlyPropMargin(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_GET_CURSOR_POSITION:
            m_ImmIfCallBack = new ImmIfGetCursorPosition(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_GET_ALL_TEXT_RANGE:
            m_ImmIfCallBack = new ImmIfGetAllTextRange(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
        case ESCB_REMOVE_PROPERTY:
            m_ImmIfCallBack = new ImmIfRemoveProperty(m_state.hIMC, m_tid, m_ic, m_pLibTLS);
            break;
    }
}

ImmIfEditSession::~ImmIfEditSession(
    )
{
    if (m_ImmIfCallBack)
        delete m_ImmIfCallBack;
}

bool
ImmIfEditSession::Valid(
    )
{
    return (m_ic.Valid()) ? true : false;
}


// ImmIfEditSession::ITfEditCallback method

STDAPI
ImmIfEditSession::DoEditSession(
    TfEditCookie ec
    )
{
    return m_pfnCallback(ec, this);
}


// ImmIfEditSession::IUnknown

STDAPI
ImmIfEditSession::QueryInterface(
    REFIID riid,
    void** ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession)) {
        *ppvObj = SAFECAST(this, ImmIfEditSession*);
    }

    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG)
ImmIfEditSession::AddRef(
    )
{
    return ++m_cRef;
}

STDAPI_(ULONG)
ImmIfEditSession::Release(
    )
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0) {
        delete this;
    }

    return cr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfHandleThisKey

HRESULT
ImmIfHandleThisKey::HandleThisKey(
    TfEditCookie ec,
    UINT uVKey,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic
    )
{
    Interface_TFSELECTION sel;
    BOOL fEmpty;
    ULONG cFetched;

    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    ASSERT(_pCicContext != NULL);

    //
    // Finalize the composition string
    //
    if (uVKey == VK_RETURN) {
        return EscbCompComplete(imc, TRUE);
    }
    else if (uVKey == VK_ESCAPE) {
        return EscbCompCancel(imc);
    }

    //
    // Keys that change its behavior on selection
    //

    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return E_FAIL;

    sel->range->IsEmpty(ec, &fEmpty);

    if (!fEmpty) {
        //
        // Selection is not empty.
        //

        switch (uVKey) {
        case VK_BACK:
        case VK_DELETE:
            //
            // Delete the selection
            //
            ClearTextInRange(ec, sel->range, *_pCicContext);
            return EscbUpdateCompositionString(imc);
        }
    }

    // Determine if current range is vertical writing
    ITfReadOnlyProperty  *pProperty = NULL;
    BOOL     fVertical = FALSE;

    if (SUCCEEDED(ic->GetAppProperty(TSATTRID_Text_Orientation, &pProperty)) && pProperty )
    {
        VARIANT  var;
        if (pProperty->GetValue(ec, sel->range, &var) == S_OK )
        {
            fVertical = (var.lVal == 2700) ? TRUE : FALSE;
        }
        pProperty->Release();

        VariantClear(&var);
    }

    int nShift;

    switch (uVKey) {
    case VK_BACK:
        // Make selection
        if (SUCCEEDED(ShiftSelectionToLeft(ec, sel->range, 1, false))) {
            // Clear the current selection
            if (SUCCEEDED(ClearTextInRange(ec, sel->range, *_pCicContext))) {
                return EscbUpdateCompositionString(imc);
            }
        }
        break;

    case VK_DELETE:
        if (SUCCEEDED(ShiftSelectionToRight(ec, sel->range, 1, false))) {
            if (SUCCEEDED(ClearTextInRange(ec, sel->range, *_pCicContext))) {
                return EscbUpdateCompositionString(imc);
            }
        }
        break;

    case VK_HOME:
        nShift = 0x7fffffff;
        goto ShiftLeft;

    case VK_UP:
        nShift = 1;
        if (!fVertical)
            break;

        goto ShiftLeft;

    case VK_LEFT:
        nShift = 1;
        if (fVertical)
            break;

ShiftLeft:
        sel->style.ase = TF_AE_START;

        if (::GetKeyState(VK_CONTROL) >= 0) {
            if (SUCCEEDED(ShiftSelectionToLeft(ec, 
                                               sel->range, 
                                               nShift,
                                               ::GetKeyState(VK_SHIFT) >= 0 ? true : false)) &&
                SUCCEEDED(ic->SetSelection(ec, 1, sel))) {
                return EscbUpdateCompositionString(imc);
            }
        }
        break;

    case VK_END:
        nShift = 0x7fffffff;
        goto ShiftRight;

    case VK_DOWN:
        nShift = 1;
        if (!fVertical)
            break;

        goto ShiftRight;

    case VK_RIGHT:
        nShift = 1;
        if (fVertical)
            break;

ShiftRight:
        sel->style.ase = TF_AE_END;

        if (::GetKeyState(VK_CONTROL) >= 0) {
            if (SUCCEEDED(ShiftSelectionToRight(ec, 
                                                sel->range,
                                                nShift,
                                                ::GetKeyState(VK_SHIFT) >= 0 ? true : false)) &&
                SUCCEEDED(ic->SetSelection(ec, 1, sel))) {
                return EscbUpdateCompositionString(imc);
            }
        }
        break;
    }

    return E_FAIL;
}

HRESULT
ImmIfHandleThisKey::ShiftSelectionToLeft(
    TfEditCookie ec,
    ITfRange *range,
    int nShift,
    bool fShiftEnd
    )
{
    LONG cch;

    if (SUCCEEDED(range->ShiftStart(ec, 0-nShift, &cch, NULL))) {
        HRESULT hr = S_OK;
        if (fShiftEnd) {
            hr = range->Collapse(ec, TF_ANCHOR_START);
        }
        return hr;
    }

    return E_FAIL;
}

HRESULT
ImmIfHandleThisKey::ShiftSelectionToRight(
    TfEditCookie ec,
    ITfRange *range,
    int nShift,
    bool fShiftStart
    )
{
    LONG cch;

    if (SUCCEEDED(range->ShiftEnd(ec, nShift, &cch, NULL))) {
        HRESULT hr = S_OK;
        if (fShiftStart) {
            hr = range->Collapse(ec, TF_ANCHOR_END);
        }
        return hr;
    }

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionComplete

HRESULT
ImmIfCompositionComplete::CompComplete(
    TfEditCookie ec,
    HIMC hIMC,
    BOOL fTerminateComp,
    Interface_Attach<ITfContext> ic
    )
{
    HRESULT hr;

    if (fTerminateComp == TRUE)
    {
        Interface<ITfContextOwnerCompositionServices> icocs;

        hr = ic->QueryInterface(IID_ITfContextOwnerCompositionServices, (void **)icocs);

        if (S_OK == hr)
        {
            icocs->TerminateComposition(NULL);
        }
    }

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    //
    // we're doing CompComplete now. So stop recurse calls.
    //
    if (_pCicContext->m_fInCompComplete.IsSetFlag())
        return S_OK;

    //
    // Get the whole text, finalize it, and set empty string in TOM
    //
    Interface<ITfRange> start;
    LONG cch;

    if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &cch))) {

        //
        // If there is no string in TextStore and we havenot sent 
        // WM_IME_STARTCOMPOSITION, we don't have to do anything.
        //
        if (!cch) {
            if (_pCicContext->m_fStartComposition.IsResetFlag())
                return S_OK;
        }

        LPWSTR wstr = new WCHAR[ cch + 1 ];
        if (!wstr)
            return E_OUTOFMEMORY;

        Interface<ITfProperty> prop;
        //
        // Get the whole text, finalize it, and erase the whole text.
        //
        if (SUCCEEDED(start->GetText(ec, TF_TF_IGNOREEND, wstr, (ULONG)cch, (ULONG*)&cch))) {
            //
            // Make Result String.
            //
            CWCompString ResultStr(hIMC, wstr, cch);

            CWCompString ResultReadStr;
            CWCompClause ResultReadClause;
            CWCompClause ResultClause;

            if (cch) {

                //
                // Get reading string from property.
                //
                GetReadingString(ec, ic, ResultReadStr, ResultReadClause);


                //
                // Copy CompClause data to ResultClause
                //
                CompClauseToResultClause(imc, ResultClause, cch);

                //
                // Check StrClause and ReadClause
                //
                CheckStrClauseAndReadClause(ResultClause, ResultReadClause, cch);
            }

            //
            // Prevent reentrance call of CPS_COMPLETE.
            //
            _pCicContext->m_fInCompComplete.SetFlag();

            //
            // set composition string
            //
            hr = _SetCompositionString(imc,
                                       *_pCicContext,
                                       &ResultStr, &ResultClause,
                                       &ResultReadStr, &ResultReadClause);
            if (SUCCEEDED(hr))
            {
                _pCicContext->GenerateMessage(imc);
            }

            _pCicContext->m_fInCompComplete.ResetFlag();

            //
            // Clear the TOM
            //
            if (SUCCEEDED(hr))
            {
                hr = ClearTextInRange(ec, start, *_pCicContext);
            }

            //
            // Bug#493094
            // Clear the composition list here if it isn't removed yet.
            //
            if (fTerminateComp == FALSE)
            {
                Interface<ITfContextOwnerCompositionServices> icocs;

                hr = ic->QueryInterface(IID_ITfContextOwnerCompositionServices, (void **)icocs);

                if (S_OK == hr)
                {
                    icocs->TerminateComposition(NULL);
                }
            }
        }
        delete [] wstr;
    }
    else {
        EscbCompCancel(imc);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionCancel


HRESULT
ImmIfCompositionCancel::CompCancel(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    ASSERT(_pCicContext != NULL);

    LANGID langid = LANG_NEUTRAL;

    //
    // TLS doesn't inherit in edit session.
    //
    TLS* ptls = TLS::GetTLS();
    if (ptls != NULL)
    {
        CicProfile* _pProfile = ptls->GetCicProfile();
        if (_pProfile != NULL)
        {
            _pProfile->GetLangId(&langid);
        }
    }

    if (_pCicContext->m_fStartComposition.IsSetFlag()) {
        CCompStrFactory comp(imc->hCompStr);

        if (SUCCEEDED(hr = comp.GetResult())) {
            if (FAILED(hr = comp.ClearCompositionString()))
                return hr;

            TRANSMSG msg;
            msg.message = WM_IME_COMPOSITION;
            if ((PRIMARYLANGID(langid) != LANG_JAPANESE))
            {
                msg.wParam = (WPARAM)VK_ESCAPE;
                msg.lParam = (LPARAM)(GCS_COMPREAD | GCS_COMP | GCS_CURSORPOS | GCS_DELTASTART);
            }
            else
            {
                //
                // #509247
                //
                // Some apps don't accept lParam without compstr in hIMC.
                //
                msg.wParam = 0;
                msg.lParam = 0;
            }

            if (_pCicContext->m_pMessageBuffer)
                _pCicContext->m_pMessageBuffer->SetData(msg);

            _pCicContext->m_fStartComposition.ResetFlag();

            msg.message = WM_IME_ENDCOMPOSITION;
            msg.wParam = (WPARAM) 0;
            msg.lParam = (LPARAM) 0;
            if (_pCicContext->m_pMessageBuffer)
                _pCicContext->m_pMessageBuffer->SetData(msg);

            //
            // Clear the text in Cicero TOM
            //
            Interface<ITfRange> range;
            LONG l;
            if (SUCCEEDED(GetAllTextRange(ec, ic, &range, &l))) {
                hr = ClearTextInRange(ec, range, *_pCicContext);
            }
        }

        _pCicContext->GenerateMessage(imc);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfUpdateCompositionString

HRESULT
ImmIfUpdateCompositionString::UpdateCompositionString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    DWORD dwDeltaStart,
    TfClientId ClientId,
    LIBTHREAD* pLibTLS
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ClientId, &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    //
    // Prevent reentrance call of CPS_COMPLETE.
    //
    _pCicContext->m_fInUpdateComposition.SetFlag();

    Interface<ITfRange> InterimRange;
    BOOL fInterim = FALSE;
    if (FAILED(hr = _IsInterimSelection(ec, ic, &InterimRange, &fInterim)))
        return hr;

    if (fInterim) {

        hr = _MakeInterimString(pLibTLS,
                                ec, imc, *_pCicContext, ic, FullTextRange,
                                InterimRange, lTextLength,
                                bInWriteSession);
    }
    else {
        hr = _MakeCompositionString(pLibTLS,
                                    ec, imc, *_pCicContext, ic, FullTextRange,
                                    dwDeltaStart,
                                    bInWriteSession);
    }

    _pCicContext->m_fInUpdateComposition.ResetFlag();

    return hr;
}


HRESULT
ImmIfUpdateCompositionString::_IsInterimSelection(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>* pInterimRange,
    BOOL *pfInterim
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    *pfInterim = FALSE;
    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
    {
        // no selection. we can return S_OK.
        return S_OK;
    }

    if (sel->style.fInterimChar) {
        HRESULT hr;
        if (FAILED(hr = sel->range->Clone(*pInterimRange)))
            return hr;

        *pfInterim = TRUE;
    }

    return S_OK;
}


HRESULT
ImmIfUpdateCompositionString::_MakeCompositionString(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    CicInputContext& CicContext,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& FullTextRange,
    DWORD dwDeltaStart,
    BOOL bInWriteSession
    )
{
    HRESULT hr;
    CWCompString CompStr;
    CWCompAttribute CompAttr;
    CWCompClause CompClause;
    CWCompTfGuidAtom CompGuid;
    CWCompCursorPos CompCursorPos;
    CWCompDeltaStart CompDeltaStart;
    CWCompString CompReadStr;
    CWCompClause CompReadClause;
    CWCompString ResultStr;
    CWCompClause ResultClause;
    CWCompString ResultReadStr;
    CWCompClause ResultReadClause;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, CicContext, ic, FullTextRange,
                                         CompStr, CompAttr, CompClause,
                                         CompGuid,
                                         CompReadStr, CompReadClause,
                                         ResultStr, ResultClause,
                                         ResultReadStr, ResultReadClause,
                                         bInWriteSession
                                        ))) {
        return hr;
    }

    if (FAILED(hr = _GetCursorPosition(ec, imc, CicContext, ic, CompCursorPos, CompAttr))) {
        return hr;
    }

    if (FAILED(hr = _GetDeltaStart(CompDeltaStart, CompStr, dwDeltaStart))) {
        return hr;
    }

    //
    // Clear the GUID attribute map array
    //
    CicContext.ClearGuidMap();

    BOOL bBufferOverflow = FALSE;
    
    // handle result string
    hr = _SetCompositionString(imc,
                               CicContext,
                               &CompStr, &CompAttr, &CompClause,
                               &CompCursorPos, &CompDeltaStart,
                               &CompGuid,
                               &bBufferOverflow,
                               &CompReadStr,
                               &ResultStr, &ResultClause,
                               &ResultReadStr, &ResultReadClause);

    if (SUCCEEDED(hr))
    {
        //
        // Map the GUID attribute array
        //
        CicContext.MapAttributes(imc);
        //
        // Send message to aplication
        //
        CicContext.GenerateMessage(imc);
    }

    if (SUCCEEDED(hr) && bBufferOverflow) {
        //
        // Buffer overflow in COMPOSITIONSTRING.compstr[NMAXKEY],
        // Then, Clear the TOM
        //
        //
        // Get the whole text, finalize it, and set empty string in TOM
        //
        Interface<ITfRange> start;
        LONG cch;
        if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &cch))) {
            hr = ClearTextInRange(ec, start, CicContext);
        }
    }

    return hr;
}


HRESULT
ImmIfUpdateCompositionString::_MakeInterimString(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    CicInputContext& CicContext,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& FullTextRange,
    Interface<ITfRange>& InterimRange,
    LONG lTextLength,
    BOOL bInWriteSession
    )
{
    LONG lStartResult;
    LONG lEndResult;

    FullTextRange->CompareStart(ec, InterimRange, TF_ANCHOR_START, &lStartResult);
    if (lStartResult > 0) {
        return E_FAIL;
    }

    FullTextRange->CompareEnd(ec, InterimRange, TF_ANCHOR_END, &lEndResult);
    if (lEndResult < 0) {
        return E_FAIL;
    }
    if (lEndResult > 1) {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    CWInterimString InterimStr((HIMC)imc);

    if (lStartResult < 0) {
        //
        // Make result string.
        //
#if 0
        BOOL fEqual;
        do {
            LONG cch;
            FullTextRange->ShiftEnd(ec, -1, &cch, NULL);
            if (cch == 0) {
                return E_FAIL;
            }
            lTextLength -= abs(cch);
            FullTextRange->IsEqualEnd(ec, InterimRange, TF_ANCHOR_START, &fEqual);
        } while(! fEqual);
#endif
        if (FAILED(hr=FullTextRange->ShiftEndToRange(ec, InterimRange, TF_ANCHOR_START)))
            return hr;

        //
        // Interim char assume 1 char length.
        // Full text length - 1 means result string length.
        //
        lTextLength --;
        ASSERT(lTextLength > 0);

        if (lTextLength > 0) {

            LPWSTR wstr = new WCHAR[ lTextLength + 1 ];

            //
            // Get the result text, finalize it, and erase the result text.
            //
            if (SUCCEEDED(FullTextRange->GetText(ec, TF_TF_IGNOREEND, wstr, (ULONG)lTextLength, (ULONG*)&lTextLength))) {
                //
                // Clear the TOM
                //
                if (SUCCEEDED(hr = ClearTextInRange(ec, FullTextRange, CicContext))) {
                    InterimStr.WriteCompData(wstr, lTextLength);
                }
            }
            delete [] wstr;
        }
    }

    //
    // Make interim character
    //
    CWCompString CompStr;
    CWCompAttribute CompAttr;
    CWCompClause CompClause;
    CWCompTfGuidAtom CompGuid;
    CWCompString CompReadStr;
    CWCompClause CompReadClause;
    CWCompString ResultStr;
    CWCompClause ResultClause;
    CWCompString ResultReadStr;
    CWCompClause ResultReadClause;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, CicContext, ic, InterimRange,
                                         CompStr, CompAttr, CompClause,
                                         CompGuid,
                                         CompReadStr, CompReadClause,
                                         ResultStr, ResultClause,
                                         ResultReadStr, ResultReadClause,
                                         bInWriteSession
                                        ))) {
        return hr;
    }

    WCHAR ch = L'\0';
    BYTE  attr = 0;
    if (CompStr.GetSize() > 0) {
        CompStr.ReadCompData(&ch, 1);
    }
    if (CompAttr.GetSize() > 0) {
        CompAttr.ReadCompData(&attr, 1);
    }

    InterimStr.WriteInterimChar(ch, attr);
    hr = _SetCompositionString(imc, CicContext, &InterimStr);
    if (SUCCEEDED(hr))
    {
        CicContext.GenerateMessage(imc);
    }

    return hr;
}


//
// Get delta start
//
HRESULT
ImmIfUpdateCompositionString::_GetDeltaStart(
    CWCompDeltaStart& CompDeltaStart,
    CWCompString& CompStr,
    DWORD dwDeltaStart
    )
{
    if (dwDeltaStart < (DWORD)CompStr.GetSize())
        CompDeltaStart.Set(dwDeltaStart);    // Set COMPOSITIONSTRING.dwDeltaStart.
    else
        CompDeltaStart.Set(0);

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfReplaceWholeText

HRESULT
ImmIfReplaceWholeText::ReplaceWholeText(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompString* lpwCompStr
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    DWORD dwSize = (DWORD)lpwCompStr->GetSize();
    LPWSTR lpszComp = new WCHAR[dwSize + 1];

    if (!lpszComp)
        return hr;

    lpwCompStr->ReadCompData(lpszComp, dwSize + 1);
    lpszComp[dwSize] = L'\0';

    Interface<ITfRange> whole;
    LONG cch;
    if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &whole, &cch))) {
        Interface<ITfContextComposition> icc;

        hr = ic->QueryInterface(IID_ITfContextComposition, (void **)icc);
        if (hr == S_OK)
        {
            Interface<ITfComposition> composition;
            hr = icc->StartComposition(ec, whole, _pCicContext, composition);
            if (hr == S_OK)
            {
                hr = SetTextInRange(ec, whole, lpszComp, dwSize, *_pCicContext);
            }
        }
    }
    delete [] lpszComp;

    return hr;
}


void SetReadOnlyRange(TfEditCookie ec,
                      Interface_Attach<ITfContext> ic,
                      ITfRange *range,
                      BOOL fSet)
{
    ITfProperty *prop;
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        if (fSet)
        {
            VARIANT var;
            var.vt = VT_I4;
            var.lVal = 1;
            prop->SetValue(ec, range, &var);
        }
        else
        {
            prop->Clear(ec, range);
        }
        prop->Release();
    }
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfReconvertString

HRESULT
ImmIfReconvertString::ReconvertString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    BOOL fDocFeedOnly,
    CWReconvertString* lpwReconvStr
    )

/*+++

    LPRECONVERTSTRING structure:
      +00  DWORD dwSize               // Sizeof data (include this structure size) with byte count.
      +04  DWORD dwVersion
      +08  DWORD dwStrLen             // String length with character count.
      +0C  DWORD dwStrOffset          // Offset from start of this structure with byte count.
      +10  DWORD dwCompStrLen         // Comp Str length with character count.
      +14  DWORD dwCompStrOffset      // Offset from this->dwStrOffset with byte count.
      +18  DWORD dwTargetStrLen       // Target Str length with character count.
      +1C  DWORD dwTargetStrOffset    // Offset from this->dwStrOffset with byte count.
      +20

---*/

{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    DWORD dwLen;
    dwLen = lpwReconvStr->ReadCompData();
    if (dwLen) {
        LPRECONVERTSTRING lpReconvertString;
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];

        if (lpReconvertString == NULL)
            return hr;

        lpwReconvStr->ReadCompData(lpReconvertString, dwLen);


        if (lpReconvertString->dwStrLen) {
            hr = ic->GetStart(ec, *rangeSrc);
            if (SUCCEEDED(hr)) {
                LONG cch;
                hr = (*rangeSrc)->ShiftEnd(ec, LONG_MAX, &cch, NULL);
                SetReadOnlyRange(ec, ic, *rangeSrc, FALSE);
                BOOL fSkipSetText = FALSE;

                if (SUCCEEDED(hr)) {

                    Interface<ITfRange> rangeOrgSelection;

                    if (lpReconvertString->dwCompStrLen)
                    {
                        WCHAR *pwstr = NULL;
                        ULONG ul = 0;
                        Interface<ITfRange> rangeTmp;
    
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeTmp)))
                        {
                            UINT uSize = lpReconvertString->dwCompStrLen + 2;
                            pwstr = new WCHAR[uSize + 1];
                            if (pwstr)
                            {
                                ULONG ulcch;
                                rangeTmp->GetText(ec, 0, pwstr, uSize, &ulcch);

                                if ((lpReconvertString->dwCompStrLen == ulcch) &&
                                     !memcmp(((LPBYTE)lpReconvertString +
                                                lpReconvertString->dwStrOffset +
                                                lpReconvertString->dwCompStrOffset),
                                            pwstr,
                                            lpReconvertString->dwCompStrLen * sizeof(WCHAR)))
                                    fSkipSetText = TRUE;
                
                                delete [] pwstr;
                            }
                        }

                        if (!fSkipSetText && fDocFeedOnly)
                        {
                            TraceMsg(TF_WARNING, "ImmIfReconvertString::ReconvertString   the current text store does not match with the string from App.");
                            goto Exit;
                        }
    
                        if (!fSkipSetText)
                        {
                            hr = SetTextInRange(ec,
                                                *rangeSrc,
                                                (LPWSTR)((LPBYTE)lpReconvertString +
                                                                 lpReconvertString->dwStrOffset +
                                                                 lpReconvertString->dwCompStrOffset),
                                                lpReconvertString->dwCompStrLen,
                                                *_pCicContext);
                            if (S_OK == hr)
                            {
                                //
                                // set GUID_PROP_MSIMTF_PREPARE_RECONVERT
                                //
                                Interface<ITfProperty> PropertyPrepareReconvert;
                                if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_PREPARE_RECONVERT,
                                                              PropertyPrepareReconvert)))
                                {
                                    //
                                    // create CReconvertPropStore
                                    //
                                    Interface_Creator<CReconvertPropStore> reconvps(new CReconvertPropStore(GUID_PROP_MSIMTF_PREPARE_RECONVERT, VT_I4, 1));
                                    if (reconvps.Valid())
                                    {
                                        PropertyPrepareReconvert->SetValueStore(ec, *rangeSrc, reconvps);
                                    }
                                }
                            }
                        }
                        else
                        {
                            GetSelectionSimple(ec, ic.GetPtr(), rangeOrgSelection);
                            hr = S_OK;
                        }
                    } 
                    else
                    {
                        BOOL fEmpty;
 
                        if (SUCCEEDED((*rangeSrc)->IsEmpty(ec, &fEmpty)) && !fEmpty)
                        {
                            if (fDocFeedOnly)
                            {
                                DebugMsg(TF_WARNING, TEXT("ImmIfReconvertString::ReconvertString   the current text store does not match with the string from App."));
                                goto Exit;
                            }

                            hr = ClearTextInRange(ec, *rangeSrc, *_pCicContext);
                        }
                    } 


                    //
                    // set read only string
                    //
                    if (lpReconvertString->dwCompStrOffset)
                    {
                        //
                        // keep rangeSrc and rangeOrgSelection
                        //
                        (*rangeSrc)->SetGravity(ec, 
                                                  TF_GRAVITY_FORWARD,
                                                  TF_GRAVITY_FORWARD);

                        if (rangeOrgSelection.Valid())
                            rangeOrgSelection->SetGravity(ec, 
                                                        TF_GRAVITY_FORWARD,
                                                        TF_GRAVITY_FORWARD);
                        Interface<ITfRange> rangeStart;
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeStart)))
                        {
                            if (SUCCEEDED(rangeStart->Collapse(ec, TF_ANCHOR_START)))
                            {
                                rangeStart->SetGravity(ec, 
                                                       TF_GRAVITY_BACKWARD,
                                                       TF_GRAVITY_FORWARD);
                                hr = SetTextInRange(ec,
                                                    rangeStart,
                                                    (LPWSTR)((LPBYTE)lpReconvertString +
                                                                     lpReconvertString->dwStrOffset),
                                                    lpReconvertString->dwCompStrOffset / sizeof(WCHAR),
                                                    *_pCicContext);

                                if (SUCCEEDED(hr))
                                    SetReadOnlyRange(ec, ic, rangeStart, TRUE);
                            }
                        }
                    }


                    if ((lpReconvertString->dwCompStrOffset + lpReconvertString->dwCompStrLen * sizeof(WCHAR)) < lpReconvertString->dwStrLen * sizeof(WCHAR))
                    {
                        //
                        // keep rangeSrc and rangeOrgSelection
                        //
                        (*rangeSrc)->SetGravity(ec, 
                                                  TF_GRAVITY_BACKWARD,
                                                  TF_GRAVITY_BACKWARD);

                        if (rangeOrgSelection.Valid())
                            rangeOrgSelection->SetGravity(ec, 
                                                        TF_GRAVITY_BACKWARD,
                                                        TF_GRAVITY_BACKWARD);

                        Interface<ITfRange> rangeEnd;
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeEnd)))
                        {
                            if (SUCCEEDED(rangeEnd->Collapse(ec, TF_ANCHOR_END)))
                            {
                                rangeEnd->SetGravity(ec, 
                                                     TF_GRAVITY_BACKWARD,
                                                     TF_GRAVITY_FORWARD);

                                hr = SetTextInRange(ec,
                                                    rangeEnd,
                                                    (LPWSTR)((LPBYTE)lpReconvertString +
                                                                     lpReconvertString->dwStrOffset +
                                                                     lpReconvertString->dwCompStrOffset +
                                                                    (lpReconvertString->dwCompStrLen * sizeof(WCHAR))),
                                                    ((lpReconvertString->dwStrLen  * sizeof(WCHAR)) -
                                                     (lpReconvertString->dwCompStrOffset +
                                                     (lpReconvertString->dwCompStrLen * sizeof(WCHAR)))) / sizeof(WCHAR),
                                                    *_pCicContext);
                                if (SUCCEEDED(hr))
                                    SetReadOnlyRange(ec, ic, rangeEnd, TRUE);
                            }
                        }
                    }

                    (*rangeSrc)->SetGravity(ec, 
                                              TF_GRAVITY_FORWARD,
                                              TF_GRAVITY_BACKWARD);


                    //
                    // we just set a selection to the target string.
                    //
                    Interface<ITfRange> range;
                    if (fSkipSetText)
                    {
                        if (rangeOrgSelection.Valid())
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = rangeOrgSelection;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);
                        }
                    }
                    else if (SUCCEEDED((*rangeSrc)->Clone(range)))
                    {
                        LONG cchStart;
                        LONG cchEnd;

                        if (lpReconvertString->dwTargetStrOffset == 0 &&
                            lpReconvertString->dwTargetStrLen == 0      ) {
                            cchStart = lpReconvertString->dwCompStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwCompStrOffset / sizeof(WCHAR) + lpReconvertString->dwCompStrLen;
                        }
                        else {
                            cchStart = (lpReconvertString->dwTargetStrOffset - lpReconvertString->dwCompStrOffset) / sizeof(WCHAR);
                            cchEnd = (lpReconvertString->dwTargetStrOffset - lpReconvertString->dwCompStrOffset) / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                            // cchStart = (lpReconvertString->dwTargetStrOffset) / sizeof(WCHAR);
                            // cchEnd = (lpReconvertString->dwTargetStrOffset) / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                        }

                        range->Collapse(ec, TF_ANCHOR_START);

                        //
                        // shift end first then shift start.
                        //
                        if ((SUCCEEDED(range->ShiftEnd(ec, 
                                                      cchEnd,
                                                      &cch, 
                                                      NULL))) &&
                            (SUCCEEDED(range->ShiftStart(ec,
                                                         cchStart,
                                                         &cch, 
                                                         NULL))))
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = range;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);
                        }
                    }

                    //
                    // it's time to generate WM_IME_COMPOSITION.
                    //
                    // ReconvertString() should call UpdateCompositionString with SYNCHRONIZATION.
                    // ASync would happen time lag of send WM_IME_STARTCOMPOSITION and WM_IME_COMPOSITION.
                    // This time lag is broken candidate window positioning because
                    // IID_ITfFnReconversion::Reconvert might open candidate window immediately.
                    //
                    // This synchronization call just want generate WM_IME_STARTCOMPOSITION and WM_IME_COMPOSITION messages.
                    // ReconvertString() won't modify text store in the edit session.
                    //

                    EscbUpdateCompositionStringSync(imc);

                }
            }
        }
Exit:
        delete [] lpReconvertString;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfClearDocFeedBuffer

HRESULT
ImmIfClearDocFeedBuffer::ClearDocFeedBuffer(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic
    )
{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    ITfRange *rangeFull = NULL;
    ITfProperty *prop;
    ITfRange *rangeTmp;
    LONG cch;

    //
    // Create the range that covers all the text.
    //
    if (FAILED(hr=ic->GetStart(ec, &rangeFull)))
        return hr;

    if (FAILED(hr=rangeFull->ShiftEnd(ec, LONG_MAX, &cch, NULL)))
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, rangeFull)))
        {
            while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_I4) && (var.lVal != 0))
                {
                    prop->Clear(ec, rangeTmp);
                    ClearTextInRange(ec, rangeTmp, *_pCicContext);
                }
                rangeTmp->Release();

                VariantClear(&var);
            }
            enumranges->Release();
        }
        prop->Release();
    }


    rangeFull->Release();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfGetTextAndAttribute

HRESULT
ImmIfGetTextAndAttribute::GetTextAndAttribute(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompString* lpwCompString,
    CWCompAttribute* lpwCompAttribute,
    TfClientId ClientId,
    LIBTHREAD* pLibTLS
    )
{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ClientId, &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, *_pCicContext, ic,
                                         FullTextRange,
                                         *lpwCompString,
                                         *lpwCompAttribute,
                                         bInWriteSession))) {
        return hr;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfQueryReconvertString

HRESULT
ImmIfQueryReconvertString::QueryReconvertString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeQuery,
    CWReconvertString* lpwReconvStr
    )

/*+++

    LPRECONVERTSTRING structure:
      +00  DWORD dwSize               // Sizeof data (include this structure size) with byte count.
      +04  DWORD dwVersion
      +08  DWORD dwStrLen             // String length with character count.
      +0C  DWORD dwStrOffset          // Offset from start of this structure with byte count.
      +10  DWORD dwCompStrLen         // Comp Str length with character count.
      +14  DWORD dwCompStrOffset      // Offset from this->dwStrOffset with byte count.
      +18  DWORD dwTargetStrLen       // Target Str length with character count.
      +1C  DWORD dwTargetStrOffset    // Offset from this->dwStrOffset with byte count.
      +20

---*/

{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    DWORD dwLen;
    dwLen = lpwReconvStr->ReadCompData();
    if (dwLen) {
        LPRECONVERTSTRING lpReconvertString;
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];

        if (lpReconvertString == NULL)
            return hr;

        lpwReconvStr->ReadCompData(lpReconvertString, dwLen);

        if (lpReconvertString->dwStrLen) {
            Interface<ITfRange> rangeSrc;
            hr = ic->GetStart(ec, rangeSrc);
            if (SUCCEEDED(hr)) {
                LONG cch;
                hr = rangeSrc->ShiftEnd(ec, LONG_MAX, &cch, NULL);
                if (SUCCEEDED(hr)) {

                    hr = SetTextInRange(ec,
                                        rangeSrc,
                                        (LPWSTR)((LPBYTE)lpReconvertString +
                                                         lpReconvertString->dwStrOffset),
                                        lpReconvertString->dwStrLen,
                                        *_pCicContext);



                    //
                    // we just set a selection to the target string.
                    //
                    Interface<ITfRange> range;
                    if (SUCCEEDED(rangeSrc->Clone(range)))
                    {
                        LONG cchStart;
                        LONG cchEnd;

                        if (lpReconvertString->dwTargetStrOffset == 0 &&
                            lpReconvertString->dwTargetStrLen == 0      ) {
                            cchStart = lpReconvertString->dwCompStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwCompStrOffset / sizeof(WCHAR) + lpReconvertString->dwCompStrLen;
                        }
                        else {
                            cchStart = lpReconvertString->dwTargetStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwTargetStrOffset / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                        }

                        range->Collapse(ec, TF_ANCHOR_START);

                        //
                        // shift end first then shift start.
                        //
                        if ((SUCCEEDED(range->ShiftEnd(ec, 
                                                      cchEnd,
                                                      &cch, 
                                                      NULL))) &&
                            (SUCCEEDED(range->ShiftStart(ec,
                                                         cchStart,
                                                         &cch, 
                                                         NULL))))
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = range;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);

                            hr = range->Clone(*rangeQuery);
                        }
                    }
                }
            }
        }
        delete [] lpReconvertString;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfCalcRangePos

HRESULT
ImmIfCalcRangePos::CalcRangePos(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    CWReconvertString* lpwReconvStr
    )
{
    HRESULT hr;
    Interface<ITfRange> pFullRange;

    hr = ic->GetStart(ec, pFullRange);
    if (SUCCEEDED(hr)) {
        lpwReconvStr->m_CompStrIndex = 0;
        lpwReconvStr->m_TargetStrIndex = 0;

        BOOL equal = FALSE;
        while (SUCCEEDED(hr=(*rangeSrc)->IsEqualStart(ec, pFullRange, TF_ANCHOR_START, &equal)) &&
               ! equal) {
            LONG cch;
            hr = pFullRange->ShiftStart(ec, 1, &cch, NULL);
            if (FAILED(hr))
                break;

            lpwReconvStr->m_CompStrIndex++;
            lpwReconvStr->m_TargetStrIndex++;
        }

        if (S_OK == hr) {
            lpwReconvStr->m_CompStrLen = 0;
            lpwReconvStr->m_TargetStrLen = 0;

            Interface<ITfRange> rangeTmp;

            if (SUCCEEDED(hr=(*rangeSrc)->Clone(rangeTmp)))
            {
                BOOL fEmpty;
                WCHAR wstr[256 + 1];
                ULONG ul = 0;

                while (rangeTmp->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
                {
                    ULONG ulcch;
                    rangeTmp->GetText(ec, 
                                      TF_TF_MOVESTART, 
                                      wstr, 
                                      ARRAYSIZE(wstr) - 1, 
                                      &ulcch);
                    ul += ulcch;
                }

                //
                // Hack for Satori
                // Satori receives empty range with Reconversion->QueryRange().
                // Apps couldn't call reconversion.
                //
                if (ul == 0) {
                    ul++;
                }

                lpwReconvStr->m_CompStrLen = (LONG)ul;
                lpwReconvStr->m_TargetStrLen = (LONG)ul;
            }
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetSelection

HRESULT
ImmIfGetSelection::GetSelection(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return E_FAIL;

    return sel->range->Clone(*rangeSrc);
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetReadOnlyPropMargin

HRESULT
ImmIfGetReadOnlyPropMargin::GetReadOnlyPropMargin(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRangeACP>* rangeSrc,
    LONG* cch
    )
{
    HRESULT hr;
    Interface<ITfRange> range_readonly_prop;

    *cch = 0;

    //
    // Create the range that covers start of text to rangeSrc.
    //
    if (FAILED(hr=ic->GetStart(ec, range_readonly_prop)))
        return hr;

    //
    // if rangeSrc is NULL, we check whole ic.
    //
    if (rangeSrc)
    {
        if (FAILED(hr=range_readonly_prop->ShiftEndToRange(ec, 
                                                           *rangeSrc, 
                                                           TF_ANCHOR_START)))
            return hr;
    }
    else
    {
        Interface<ITfRange> range_end;
        if (FAILED(hr=ic->GetEnd(ec, range_end)))
            return hr;

        if (FAILED(hr=range_readonly_prop->ShiftEndToRange(ec, 
                                                           range_end, 
                                                           TF_ANCHOR_START)))
            return hr;
    }

    //
    // same ?
    //
    BOOL empty;
    if (FAILED(hr=range_readonly_prop->IsEmpty(ec, &empty)))
        return hr;

    if (empty)
        return S_OK;

    //
    // find the first non readonly range in the text store.
    //
    ITfProperty *prop;
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, range_readonly_prop)))
        {
            ITfRange *rangeTmp;
            BOOL fFoundNotReadOnly = FALSE;
            while (!fFoundNotReadOnly &&
                   (enumranges->Next(1, &rangeTmp, NULL) == S_OK))
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_I4) && (var.lVal != 0))
                {
                    while (rangeTmp->IsEmpty(ec, &empty) == S_OK && !empty)
                    {
                        WCHAR wstr[256 + 1];
                        ULONG ulcch;
                        rangeTmp->GetText(ec, 
                                          TF_TF_MOVESTART, 
                                          wstr, 
                                          ARRAYSIZE(wstr) - 1, 
                                          &ulcch);
                        *cch += ulcch;
                    }
                }
                else
                {
                    fFoundNotReadOnly = TRUE;
                }

                rangeTmp->Release();

                VariantClear(&var);
            }
            enumranges->Release();
        }
        prop->Release();
    }

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

HRESULT
ImmIfGetCursorPosition::GetCursorPosition(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompCursorPos* lpwCursorPosition,
    TfClientId ClientId,
    LIBTHREAD* pLibTLS
    )
{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ClientId, &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    CWCompString CompStr;
    CWCompAttribute CompAttr;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, *_pCicContext, ic,
                                         FullTextRange,
                                         CompStr,
                                         CompAttr,
                                         bInWriteSession))) {
        return hr;
    }

    if (FAILED(hr = _GetCursorPosition(ec, imc, *_pCicContext, ic, *lpwCursorPosition, CompAttr))) {
        return hr;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfRemoveProperty

HRESULT
ImmIfRemoveProperty::RemoveProperty(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    const GUID* guid
    )
{
    HRESULT hr;
    Interface<ITfProperty> prop;

    if (SUCCEEDED(hr = ic->GetProperty(*guid, prop)))
    {
        prop->Clear(ec, NULL);     // remove CReconvertPropStore object.
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbHandleThisKey

HRESULT
EscbHandleThisKey(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    UINT uVKey)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_HANDLETHISKEY,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                             uVKey);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbUpdateCompositionString

HRESULT
EscbUpdateCompositionString(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    DWORD dwDeltaStart,
    DWORD dwFlags)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_UPDATECOMPOSITIONSTRING,
                             imc, tid, pic, pLibTLS)

    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    //
    // This method should not set synchronize mode becuase the edit session call back routine
    // modify a text in the input context.
    //
    // Except ReconvertString()
    //
    return _pEditSession->RequestEditSession(TF_ES_READWRITE | dwFlags,
                                             (UINT)dwDeltaStart);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbCompCancel

HRESULT
EscbCompCancel(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_COMPCANCEL,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbCompComplete

HRESULT
EscbCompComplete(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    BOOL fSync)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_COMPCOMPLETE,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0),
                                             fSync == TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbReplaceWholeText

HRESULT
EscbReplaceWholeText(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWCompString* wCompString)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_REPLACEWHOLETEXT,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                             wCompString);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbClearDocFeedBuffer

HRESULT
EscbClearDocFeedBuffer(
    IMCLock& imc,
    CicInputContext& CicContext,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    BOOL fSync)
{
    HRESULT hr = E_FAIL;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_CLEARDOCFEEDBUFFER,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
    {
        goto Exit;
    }

    CicContext.m_fInClearDocFeedEditSession.SetFlag();
    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0));
    CicContext.m_fInClearDocFeedEditSession.ResetFlag();

Exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbGetTextAndAttribute

HRESULT
EscbGetTextAndAttribute(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWCompString* wCompString,
    CWCompAttribute* wCompAttribute)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETTEXTANDATTRIBUTE,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                             wCompString, wCompAttribute);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbGetCursorPosition

HRESULT
EscbGetCursorPosition(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWCompCursorPos* wCursorPosition)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GET_CURSOR_POSITION,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                             wCursorPosition);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbGetSelection

HRESULT
EscbGetSelection(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    Interface<ITfRange>* selection)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETSELECTION,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                             selection);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbGetStartEndSelection

HRESULT
EscbGetStartEndSelection(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWCompCursorPos& wStartSelection,
    CWCompCursorPos& wEndSelection)
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETSELECTION,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    Interface<ITfRange> Selection;
    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                           &Selection);
    if (S_OK == hr) {
        //
        // Calcurate start position of RangeNew on text store
        //
        Interface_Creator<ImmIfEditSession> _pEditSession2(
            new ImmIfEditSession(ESCB_CALCRANGEPOS,
                                 imc, tid, pic, pLibTLS)
        );
        if (_pEditSession2.Valid()) {
            CWReconvertString wReconvStr(imc);
            hr = _pEditSession2->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                                    &wReconvStr, &Selection, FALSE);
            if (S_OK == hr) {
                wStartSelection.Set((DWORD) wReconvStr.m_CompStrIndex);
                wEndSelection.Set((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen));
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbReconvertString

HRESULT
EscbReconvertString(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWReconvertString* wReconvertString,
    Interface<ITfRange>* selection,
    BOOL fDocFeedOnly)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_RECONVERTSTRING,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                             wReconvertString, selection, fDocFeedOnly);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbQueryReconvertString

HRESULT
EscbQueryReconvertString(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWReconvertString* wReconvertString,
    Interface<ITfRange>* selection)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_QUERYRECONVERTSTRING,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                             wReconvertString, selection, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbCalcRangePos

HRESULT
EscbCalcRangePos(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    CWReconvertString* wReconvertString,
    Interface<ITfRange>* range)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_CALCRANGEPOS,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                             wReconvertString, range, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbReadOnlyPropMargin

HRESULT
EscbReadOnlyPropMargin(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    Interface<ITfRangeACP>* range_acp,
    LONG* pcch)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GET_READONLY_PROP_MARGIN,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                             range_acp, pcch);
}

/////////////////////////////////////////////////////////////////////////////
// Edit session friend
// EscbRemoveProperty

HRESULT
EscbRemoveProperty(
    IMCLock& imc,
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD* pLibTLS,
    const GUID* guid)
{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_REMOVE_PROPERTY,
                             imc, tid, pic, pLibTLS)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    //
    // This method should not set synchronize mode becuase the edit session call back routine
    // modify a property in the input context.
    //
    return _pEditSession->RequestEditSession(TF_ES_READWRITE,
                                             guid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\dllmain.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dllmain.cpp

Abstract:

    This file implements the windows DLL entry.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "tls.h"
#include "cuilib.h"
#include "delay.h"
#include "cicutil.h"

BOOL gfTFInitLib = FALSE;

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    BOOL bRet;
#ifdef DEBUG
    g_dwTraceFlags = 0;
    g_dwBreakFlags = 0;
#endif
    CcshellGetDebugFlags();

    Dbg_MemInit(TEXT("MSCTFIME"), NULL);

    DebugMsg(TF_FUNC, TEXT("DllMain::DLL_PROCESS_ATTACH"));
    SetInstance(hInstance);

    if (!g_cs.Init())
        return FALSE;

    if (!TLS::Initialize())
        return FALSE;

    InitOSVer();
    InitUIFLib();

    //
    // Might be required by some library function, so let's initialize
    // it as the first thing.
    //
    if (!TFInitLib())
        return FALSE;

    //
    // Succeeded TFInitLib
    //
    gfTFInitLib = TRUE;

    if (!AttachIME())
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
    DebugMsg(TF_FUNC, TEXT("DllMain::DLL_PROCESS_DETACH"));

    //
    // let free XPSP1RES if it is loaded.
    //
    FreeCicResInstance();

    //
    // let msctf.dll know we're in process detach.
    //
    TF_DllDetachInOther();

    if (gfTFInitLib) {
        DetachIME();
        TFUninitLib();
    }

    g_cs.Delete();

    TLS::DestroyTLS();
    TLS::Uninitialize();
    DoneUIFLib();

    Dbg_MemUninit();
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    BOOL ret = TRUE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            ret = ProcessAttach(hInstance);
            if (!ret)
                ProcessDettach(hInstance);
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;

        case DLL_THREAD_DETACH:
            //
            // let msctf.dll know we're in thread detach.
            //
            TF_DllDetachInOther();

            CtfImeThreadDetach();

            TLS::DestroyTLS();

            break;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\editses.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    editses.h

Abstract:

    This file defines the EditSession Class.

Author:

Revision History:

Notes:

--*/

#ifndef _EDITSES_H_
#define _EDITSES_H_

#include "editcomp.h"
#include "context.h"
#include "globals.h"
#include "imc.h"
#include "uicomp.h"


typedef enum {
    ESCB_HANDLETHISKEY = 1,
    ESCB_COMPCOMPLETE,
    ESCB_COMPCANCEL,
    ESCB_UPDATECOMPOSITIONSTRING,
    ESCB_REPLACEWHOLETEXT,
    ESCB_RECONVERTSTRING,
    ESCB_CLEARDOCFEEDBUFFER,
    ESCB_GETTEXTANDATTRIBUTE,
    ESCB_QUERYRECONVERTSTRING,
    ESCB_CALCRANGEPOS,
    ESCB_GETSELECTION,
    ESCB_GET_READONLY_PROP_MARGIN,
    ESCB_GET_CURSOR_POSITION,
    ESCB_GET_ALL_TEXT_RANGE,
    ESCB_REMOVE_PROPERTY
} ESCB;


/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSessionCallBack

class ImmIfEditSession;

class ImmIfEditSessionCallBack
{
public:
    ImmIfEditSessionCallBack(HIMC hIMC,
                             TfClientId tid,
                             Interface_Attach<ITfContext> pic,
                             LIBTHREAD* pLibTLS)
        : m_hIMC(hIMC), m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS)
    {
    }
    virtual ~ImmIfEditSessionCallBack() { };

    virtual HRESULT CallBackRoutine(TfEditCookie ec,
                                    ImmIfEditSession* pes) = 0;
    static HRESULT GetAllTextRange(TfEditCookie ec,
                                   Interface_Attach<ITfContext>& ic,
                                   Interface<ITfRange>* range,
                                   LONG* lpTextLength,
                                   TF_HALTCOND* lpHaltCond=NULL);

protected:
    HRESULT SetTextInRange(TfEditCookie ec,
                           ITfRange* range,
                           LPWSTR psz,
                           DWORD len,
                           CicInputContext& CicContext);

    HRESULT ClearTextInRange(TfEditCookie ec,
                             ITfRange* range,
                             CicInputContext& CicContext);

    HRESULT GetReadingString(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             CWCompString& reading_string,
                             CWCompClause& reading_clause);

    HRESULT GetReadingString(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             ITfRange* range,
                             CWCompString& reading_string,
                             CWCompClause& reading_clause);

    HRESULT CompClauseToResultClause(IMCLock& imc,
                                     CWCompClause& result_clause, UINT cch);

    HRESULT CheckStrClauseAndReadClause(CWCompClause& str_clause, CWCompClause& reading_clause, LONG cch);

    HRESULT _GetTextAndAttribute(LIBTHREAD *pLibTLS,
                                 TfEditCookie ec,
                                 IMCLock& imc,
                                 CicInputContext& CicContext,
                                 Interface_Attach<ITfContext>& ic,
                                 Interface<ITfRange>& range,
                                 CWCompString& CompStr,
                                 CWCompAttribute& CompAttr,
                                 BOOL bInWriteSession)
    {
        CWCompClause CompClause;
        CWCompTfGuidAtom CompGuid;
        CWCompString CompReadStr;
        CWCompClause CompReadClause;
        CWCompString ResultStr;
        CWCompClause ResultClause;
        CWCompString ResultReadStr;
        CWCompClause ResultReadClause;
        return _GetTextAndAttribute(pLibTLS, ec, imc, CicContext, ic, range,
                                    CompStr, CompAttr, CompClause,
                                    CompGuid,
                                    CompReadStr, CompReadClause,
                                    ResultStr, ResultClause,
                                    ResultReadStr, ResultReadClause,
                                    bInWriteSession);
    }

    HRESULT _GetTextAndAttribute(LIBTHREAD *pLibTLS,
                                 TfEditCookie ec,
                                 IMCLock& imc,
                                 CicInputContext& CicContext,
                                 Interface_Attach<ITfContext>& ic,
                                 Interface<ITfRange>& range,
                                 CWCompString& CompStr,
                                 CWCompAttribute& CompAttr,
                                 CWCompClause& CompClause,
                                 CWCompTfGuidAtom& CompGuid,
                                 CWCompString& CompReadStr,
                                 CWCompClause& CompReadCls,
                                 CWCompString& ResultStr,
                                 CWCompClause& ResultClause,
                                 CWCompString& ResultReadStr,
                                 CWCompClause& ResultReadClause,
                                 BOOL bInWriteSession);

    HRESULT _GetTextAndAttributeGapRange(LIBTHREAD *pLibTLS,
                                         TfEditCookie ec,
                                         // IMCLock& imc,
                                         IME_UIWND_STATE uists,
                                         CicInputContext& CicContext,
                                         Interface<ITfRange>& gap_range,
                                         LONG result_comp,
                                         CWCompString& CompStr,
                                         CWCompAttribute& CompAttr,
                                         CWCompClause& CompClause,
                                         CWCompTfGuidAtom& CompGuid,
                                         CWCompString& ResultStr,
                                         CWCompClause& ResultClause);

    HRESULT _GetTextAndAttributePropertyRange(LIBTHREAD *pLibTLS,
                                              TfEditCookie ec,
                                              IMCLock& imc,
                                              IME_UIWND_STATE uists,
                                              CicInputContext& CicContext,
                                              ITfRange* pPropRange,
                                              BOOL fDispAttribute,
                                              LONG result_comp,
                                              BOOL bInWriteSession,
                                              TF_DISPLAYATTRIBUTE da,
                                              TfGuidAtom guidatom,
                                              CWCompString& CompStr,
                                              CWCompAttribute& CompAttr,
                                              CWCompClause& CompClause,
                                              CWCompTfGuidAtom& CompGuid,
                                              CWCompString& ResultStr,
                                              CWCompClause& ResultClause);

    HRESULT _GetNoDisplayAttributeRange(LIBTHREAD *pLibTLS,
                                        TfEditCookie ec,
                                        Interface_Attach<ITfContext>& ic,
                                        Interface<ITfRange>& range,
                                        const GUID** guids,
                                        const int guid_size,
                                        Interface<ITfRange>& no_display_attribute_range);

    HRESULT _GetCursorPosition(TfEditCookie ec,
                               IMCLock& imc,
                               CicInputContext& CicContext,
                               Interface_Attach<ITfContext>& ic,
                               CWCompCursorPos& CompCursorPos,
                               CWCompAttribute& CompAttr);

    //
    // Edit session helper
    //
protected:
    HRESULT EscbHandleThisKey(IMCLock& imc, UINT uVKey)
    {
        return ::EscbHandleThisKey(imc, m_tid, m_ic, m_pLibTLS, uVKey);
    }

    HRESULT EscbUpdateCompositionString(IMCLock& imc)
    {
        return ::EscbUpdateCompositionString(imc, m_tid, m_ic, m_pLibTLS, 0, 0);
    }

    HRESULT EscbUpdateCompositionStringSync(IMCLock& imc)
    {
        return ::EscbUpdateCompositionString(imc, m_tid, m_ic, m_pLibTLS, 0, TF_ES_SYNC);
    }

    HRESULT EscbCompCancel(IMCLock& imc)
    {
        return ::EscbCompCancel(imc, m_tid, m_ic, m_pLibTLS);
    }

    HRESULT EscbCompComplete(IMCLock& imc, BOOL fSync)
    {
        return ::EscbCompComplete(imc, m_tid, m_ic, m_pLibTLS, fSync);
    }

    HRESULT EscbClearDocFeedBuffer(IMCLock& imc, CicInputContext& CicContext, BOOL fSync)
    {
        return ::EscbClearDocFeedBuffer(imc, CicContext, m_tid, m_ic, m_pLibTLS, fSync);
    }

    HRESULT EscbRemoveProperty(IMCLock& imc, const GUID* guid)
    {
        return ::EscbRemoveProperty(imc, m_tid, m_ic, m_pLibTLS, guid);
    }

    //
    // Edit session friend
    //
private:
    friend HRESULT EscbHandleThisKey(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* tls,
                                     UINT uVKey);
    friend HRESULT EscbCompComplete(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    BOOL fSync);
    friend HRESULT EscbCompCancel(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS);
    friend HRESULT EscbUpdateCompositionString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                               DWORD dwDeltaStart,
                                               DWORD dwFlags);
    friend HRESULT EscbReplaceWholeText(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                        CWCompString* wCompString);
    friend HRESULT EscbReconvertString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                       CWReconvertString* wReconvertString,
                                       Interface<ITfRange>* selection,
                                       BOOL fDocFeedOnly);
    friend HRESULT EscbClearDocFeedBuffer(IMCLock& imc, CicInputContext& CicContext, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                          BOOL fSync);
    friend HRESULT EscbGetTextAndAttribute(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                           CWCompString* wCompString,
                                           CWCompAttribute* wCompAttribute);
    friend HRESULT EscbQueryReconvertString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                            CWReconvertString* wReconvertString,
                                            Interface<ITfRange>* selection);
    friend HRESULT EscbCalcRangePos(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    CWReconvertString* wReconvertString,
                                    Interface<ITfRange>* range);
    friend HRESULT EscbGetSelection(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    Interface<ITfRange>* selection);
    friend HRESULT EscbGetStartEndSelection(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                            CWCompCursorPos& wStartSelection,
                                            CWCompCursorPos& wEndSelection);
    friend HRESULT EscbReadOnlyPropMargin(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                          Interface<ITfRangeACP>* range_acp,
                                          LONG*     pcch);
    friend HRESULT EscbGetCursorPosition(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                         CWCompCursorPos* wCursorPosition);
    friend HRESULT EscbRemoveProperty(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                      const GUID* guid);

private:
    typedef struct _EnumReadingPropertyArgs
    {
        Interface<ITfProperty> Property;
        TfEditCookie ec;
        CWCompString*          reading_string;
        CWCompClause*          reading_clause;
        LONG ulClausePos;
    } EnumReadingPropertyArgs;

    //
    // Enumrate callbacks
    //
    static ENUM_RET EnumReadingPropertyCallback(ITfRange* pRange, EnumReadingPropertyArgs *pargs);

    BYTE _ConvertAttributeToImm32(IME_UIWND_STATE uists,
                                  TF_DA_ATTR_INFO attribute)
    {
        if (attribute == TF_ATTR_OTHER || attribute > TF_ATTR_FIXEDCONVERTED) {
            return ATTR_TARGET_CONVERTED;
        }
        else {

            if (attribute == ATTR_INPUT_ERROR)
            {
                if (uists != IME_UIWND_LEVEL1 && uists != IME_UIWND_LEVEL2)
                {
                    return ATTR_CONVERTED;
                }
            }
            return (BYTE)attribute;
        }
    }

    HRESULT _FindCompAttr(CWCompAttribute& CompAttr, BYTE bAttr, INT_PTR* pich);

    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
    HIMC                          m_hIMC;

};




/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSession

class ImmIfEditSession : public ITfEditSession
{
public:
    ImmIfEditSession(ESCB escb,
                     IMCLock& imc,
                     TfClientId tid,
                     Interface_Attach<ITfContext> pic,
                     LIBTHREAD* pLibTLS)
        : m_state((HIMC)imc), m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS)
    {
        _Init(escb);
    }


private:
    void _Init(ESCB escb);

public:
    virtual ~ImmIfEditSession();

    bool Valid();
    bool Invalid() { return ! Valid(); }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback method
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

    //
    // ImmIfEditSession methods
    //
    static HRESULT EditSessionCallBack(TfEditCookie ec, ImmIfEditSession* pes)
    {
        if (pes->m_ImmIfCallBack)
            return pes->m_ImmIfCallBack->CallBackRoutine(ec, pes);
        else
            return E_FAIL;
    }

    //
    // EditSession methods.
    //
    HRESULT RequestEditSession(DWORD dwFlags,
                               UINT uVKey=0)
    {
        HRESULT hr;
        m_state.uVKey = uVKey;
        m_ic->RequestEditSession(m_tid, this, dwFlags, &hr);
        return hr;
    }

    HRESULT RequestEditSession(DWORD dwFlags, CWCompString* pwCompStr,
                          CWCompString* pwReadCompStr=NULL, Interface<ITfRange>* pRange=NULL)
    {
        m_state.lpwCompStr     = pwCompStr;
        m_state.lpwReadCompStr = pwReadCompStr;
        m_pRange               = pRange;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags, Interface<ITfRange>* pSelection)
    {
        m_pRange             = pSelection;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWReconvertString* pwReconvStr, Interface<ITfRange>* pSelection, BOOL fDocFeedOnly)
    {
        m_state.lpwReconvStr = pwReconvStr;
        m_pRange             = pSelection;
        m_fDocFeedOnly       = fDocFeedOnly;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          Interface<ITfRangeACP>* pMouseRangeACP, LPMOUSE_RANGE_RECT pv)
    {
        m_pRangeACP          = pMouseRangeACP;
        m_state.pv           = (VOID*)pv;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWCompString* pwCompStr, CWCompAttribute* pwCompAttr)
    {
        m_state.lpwCompStr  = pwCompStr;
        m_state.lpwCompAttr = pwCompAttr;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags, BOOL fTerminateComp)
    {
        m_state.fTerminateComp             = fTerminateComp;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          Interface<ITfRangeACP>* pRange, LONG* cch)
    {
        m_pRangeACP = pRange;
        m_state.pv  = (VOID*)cch;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWCompCursorPos* pwCursorPosition)
    {
        m_state.lpwCursorPosition = pwCursorPosition;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                               const GUID* guid)
    {
        HRESULT hr;
        m_guid = guid;
        m_ic->RequestEditSession(m_tid, this, dwFlags, &hr);
        return hr;
    }

public:
    ImmIfEditSessionCallBack*     m_ImmIfCallBack;

    Interface_Attach<ITfContext>  m_ic;

    Interface<ITfRange>*          m_pRange;
    Interface<ITfRangeACP>*       m_pRangeACP;

    const GUID* m_guid;

    BOOL                          m_fDocFeedOnly;

    struct state {
        state(HIMC hd) : hIMC(hd) { };

        UINT                uVKey;
        HIMC                hIMC;
        CWCompString*       lpwCompStr;
        CWCompString*       lpwReadCompStr;
        CWCompAttribute*    lpwCompAttr;
        CWReconvertString*  lpwReconvStr;
        CWCompCursorPos*    lpwCursorPosition;
        VOID*               pv;
        BOOL                fTerminateComp;
    } m_state;

    TfClientId              m_tid;
    LIBTHREAD*              m_pLibTLS;

    HRESULT                 (*m_pfnCallback)(TfEditCookie ec, ImmIfEditSession*);
    int                     m_cRef;
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfHandleThisKey

class ImmIfHandleThisKey : public ImmIfEditSessionCallBack
{
public:
    ImmIfHandleThisKey(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return HandleThisKey(ec,
                             pes->m_state.uVKey,
                             pes->m_state.hIMC,
                             pes->m_ic);
    }

    HRESULT HandleThisKey(TfEditCookie ec,
                          UINT uVKey,
                          HIMC hIMC,
                          Interface_Attach<ITfContext> ic);

private:
    HRESULT ShiftSelectionToLeft(TfEditCookie rc, ITfRange *range, int nShift, bool fShiftEnd);
    HRESULT ShiftSelectionToRight(TfEditCookie rc, ITfRange *range, int nShift, bool fShiftStart);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionComplete

class ImmIfCompositionComplete : public ImmIfEditSessionCallBack,
                                 private EditCompositionString
{
public:
    ImmIfCompositionComplete(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return CompComplete(ec,
                            pes->m_state.hIMC,
                            pes->m_state.fTerminateComp,
                            pes->m_ic);
    }

    HRESULT CompComplete(TfEditCookie ec,
                         HIMC hIMC,
                         BOOL fTerminateComp,
                         Interface_Attach<ITfContext> ic);

private:
    HRESULT _SetCompositionString(IMCLock& imc,
                                  CicInputContext& CicContext,
                                  CWCompString* ResultStr,
                                  CWCompClause* ResultClause,
                                  CWCompString* ResultReadStr,
                                  CWCompClause* ResultReadClause)
    {
        return SetString(imc,
                         CicContext,
                         NULL, NULL, NULL,    // CompStr, CompAttr, CompCls
                         NULL, NULL,          // CompCursor, CompDeltaStart
                         NULL,                // CompGuid
                         NULL,                // lpbBufferOverflow
                         NULL, NULL, NULL,    // CompReadStr, CompReadAttr, CompReadCls
                         ResultStr, ResultClause,           // ResultStr, ResultCls
                         ResultReadStr, ResultReadClause);  // ResultReadStr, ResultReadCls
    }

};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionCancel

class ImmIfCompositionCancel : public ImmIfEditSessionCallBack,
                               private EditCompositionString
{
public:
    ImmIfCompositionCancel(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return CompCancel(ec,
                          pes->m_state.hIMC,
                          pes->m_ic);
    }

    HRESULT CompCancel(TfEditCookie ec,
                       HIMC hIMC,
                       Interface_Attach<ITfContext> ic);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfUpdateCompositionString

class ImmIfUpdateCompositionString : public ImmIfEditSessionCallBack,
                                     private EditCompositionString
{
public:
    ImmIfUpdateCompositionString(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return UpdateCompositionString(ec,
                                       pes->m_state.hIMC,
                                       pes->m_ic,
                                       pes->m_state.uVKey,
                                       pes->m_tid,
                                       pes->m_pLibTLS);
    }

    HRESULT UpdateCompositionString(TfEditCookie ec,
                                    HIMC hIMC,
                                    Interface_Attach<ITfContext> ic,
                                    DWORD dwDeltaStart,
                                    TfClientId ClientId,
                                    LIBTHREAD* pLibTLS);

private:
    HRESULT _IsInterimSelection(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             Interface<ITfRange>* pInterimRange,
                             BOOL *pfInterim);

    HRESULT _MakeCompositionString(LIBTHREAD *pLibTLS,
                                   TfEditCookie ec,
                                   IMCLock& imc,
                                   CicInputContext& CicContext,
                                   Interface_Attach<ITfContext>& ic,
                                   Interface<ITfRange>& FullTextRange,
                                   DWORD dwDeltaStart,
                                   BOOL bInWriteSession);

    HRESULT _MakeInterimString(LIBTHREAD *pLibTLS,
                               TfEditCookie ec,
                               IMCLock& imc,
                               CicInputContext& CicContext,
                               Interface_Attach<ITfContext>& ic,
                               Interface<ITfRange>& FullTextRange,
                               Interface<ITfRange>& InterimRange,
                               LONG lTextLength,
                               BOOL bInWriteSession);

    HRESULT _GetDeltaStart(CWCompDeltaStart& CompDeltaStart,
                           CWCompString& CompStr,
                           DWORD dwDeltaStart);

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CicInputContext& CicContext,
                                  CWCompString* CompStr,
                                  CWCompAttribute* CompAttr,
                                  CWCompClause* CompClause,
                                  CWCompCursorPos* CompCursorPos,
                                  CWCompDeltaStart* CompDeltaStart,
                                  CWCompTfGuidAtom* CompGuid,
                                  OUT BOOL* lpbBufferOverflow,
                                  CWCompString* CompReadStr)
    {
        return SetString(imc,
                         CicContext,
                         CompStr, CompAttr, CompClause,
                         CompCursorPos, CompDeltaStart,
                         CompGuid,
                         lpbBufferOverflow,
                         CompReadStr);
    }

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CicInputContext& CicContext,
                                  CWCompString* CompStr,
                                  CWCompAttribute* CompAttr,
                                  CWCompClause* CompClause,
                                  CWCompCursorPos* CompCursorPos,
                                  CWCompDeltaStart* CompDeltaStart,
                                  CWCompTfGuidAtom* CompGuid,
                                  OUT BOOL* lpbBufferOverflow,
                                  CWCompString* CompReadStr,
                                  CWCompString* ResultStr,
                                  CWCompClause* ResultClause,
                                  CWCompString* ResultReadStr,
                                  CWCompClause* ResultReadClause)
    {
        return SetString(imc,
                         CicContext,
                         CompStr, CompAttr, CompClause,
                         CompCursorPos, CompDeltaStart,
                         CompGuid,
                         lpbBufferOverflow,
                         CompReadStr, NULL, NULL,     // CompReadStr, CompReadAttr, CompReadCls
                         ResultStr, ResultClause,
                         ResultReadStr, ResultReadClause);
    }

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CicInputContext& CicContext,
                                  CWInterimString* InterimStr)
    {
        return SetString(imc,
                         CicContext,
                         NULL, NULL, NULL,    // CompStr, CompAttr, CompCls
                         NULL, NULL,          // CompCursor, CompDeltaStart
                         NULL,                // CompGuid
                         NULL,                // lpbBufferOverflow
                         NULL, NULL, NULL,    // CompReadStr, CompReadAttr, CompReadCls
                         NULL, NULL,          // ResultStr, ResultCls
                         NULL, NULL,          // ResultReadStr, ResultReadCls
                         InterimStr);
    }
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfReplaceWholeText

class ImmIfReplaceWholeText : public ImmIfEditSessionCallBack
{
public:
    ImmIfReplaceWholeText(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return ReplaceWholeText(ec,
                                pes->m_state.hIMC,
                                pes->m_ic,
                                pes->m_state.lpwCompStr);
    }

    HRESULT ReplaceWholeText(TfEditCookie ec,
                             HIMC hIMC,
                             Interface_Attach<ITfContext> ic,
                             CWCompString* lpwCompStr);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfReconvertString

class ImmIfReconvertString : public ImmIfEditSessionCallBack
{
public:
    ImmIfReconvertString(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return ReconvertString(ec,
                               pes->m_state.hIMC,
                               pes->m_ic,
                               pes->m_pRange,
                               pes->m_fDocFeedOnly,
                               pes->m_state.lpwReconvStr);
    }

    HRESULT ReconvertString(TfEditCookie ec,
                            HIMC hIMC,
                            Interface_Attach<ITfContext> ic,
                            Interface<ITfRange>* rangeSrc,
                            BOOL fDocFeedOnly,
                            CWReconvertString* lpwReconvStr);
};

/////////////////////////////////////////////////////////////////////////////
// ImmIfClearDocFeedBuffer

class ImmIfClearDocFeedBuffer : public ImmIfEditSessionCallBack
{
public:
    ImmIfClearDocFeedBuffer(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return ClearDocFeedBuffer(ec,
                                  pes->m_state.hIMC,
                                  pes->m_ic);
    }

    HRESULT ClearDocFeedBuffer(TfEditCookie ec,
                            HIMC hIMC,
                            Interface_Attach<ITfContext> ic);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetTextAndAttribute

class ImmIfGetTextAndAttribute : public ImmIfEditSessionCallBack
{
public:
    ImmIfGetTextAndAttribute(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return GetTextAndAttribute(ec,
                                   pes->m_state.hIMC,
                                   pes->m_ic,
                                   pes->m_state.lpwCompStr,
                                   pes->m_state.lpwCompAttr,
                                   pes->m_tid,
                                   pes->m_pLibTLS);
    }

    HRESULT GetTextAndAttribute(TfEditCookie ec,
                                HIMC hIMC,
                                Interface_Attach<ITfContext> ic,
                                CWCompString* lpwCompString,
                                CWCompAttribute* lpwCompAttribute,
                                TfClientId ClientId,
                                LIBTHREAD* pLibTLS);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfQueryReconvertString

class ImmIfQueryReconvertString : public ImmIfEditSessionCallBack
{
public:
    ImmIfQueryReconvertString(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return QueryReconvertString(ec,
                                    pes->m_state.hIMC,
                                    pes->m_ic,
                                    pes->m_pRange,
                                    pes->m_state.lpwReconvStr);
    }

    HRESULT QueryReconvertString(TfEditCookie ec,
                                 HIMC hIMC,
                                 Interface_Attach<ITfContext> ic,
                                 Interface<ITfRange>* rangeQuery,
                                 CWReconvertString* lpwReconvStr);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCalcRangePos

class ImmIfCalcRangePos : public ImmIfEditSessionCallBack
{
public:
    ImmIfCalcRangePos(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return CalcRangePos(ec,
                            pes->m_ic,
                            pes->m_pRange,
                            pes->m_state.lpwReconvStr);
    }

    HRESULT CalcRangePos(TfEditCookie ec,
                         Interface_Attach<ITfContext> ic,
                         Interface<ITfRange>* rangeSrc,
                         CWReconvertString* lpwReconvStr);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetSelection

class ImmIfGetSelection : public ImmIfEditSessionCallBack
{
public:
    ImmIfGetSelection(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return GetSelection(ec,
                            pes->m_ic,
                            pes->m_pRange);
    }

    HRESULT GetSelection(TfEditCookie ec,
                         Interface_Attach<ITfContext> ic,
                         Interface<ITfRange>* rangeSrc);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetReadOnlyPropMargin

class ImmIfGetReadOnlyPropMargin : public ImmIfEditSessionCallBack
{
public:
    ImmIfGetReadOnlyPropMargin(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return GetReadOnlyPropMargin(ec,
                                     pes->m_ic,
                                     pes->m_pRangeACP,
                                     (LONG*)pes->m_state.pv);
    }

    HRESULT GetReadOnlyPropMargin(TfEditCookie ec,
                                  Interface_Attach<ITfContext> ic,
                                  Interface<ITfRangeACP>* rangeSrc,
                                  LONG* cch);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

class ImmIfGetCursorPosition : public ImmIfEditSessionCallBack
{
public:
    ImmIfGetCursorPosition(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return GetCursorPosition(ec,
                                 pes->m_state.hIMC,
                                 pes->m_ic,
                                 pes->m_state.lpwCursorPosition,
                                 pes->m_tid,
                                 pes->m_pLibTLS);
    }

    HRESULT GetCursorPosition(TfEditCookie ec,
                              HIMC hIMC,
                              Interface_Attach<ITfContext> ic,
                              CWCompCursorPos* lpwCursorPosition,
                              TfClientId ClientId,
                              LIBTHREAD* pLibTLS);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

class ImmIfGetAllTextRange : public ImmIfEditSessionCallBack
{
public:
    ImmIfGetAllTextRange(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        LONG cch;

        return GetAllTextRange(ec,
                               pes->m_ic,
                               pes->m_pRange,
                               &cch);
    }
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfRemoveProperty

class ImmIfRemoveProperty : public ImmIfEditSessionCallBack
{
public:
    ImmIfRemoveProperty(HIMC hIMC, TfClientId tid, Interface_Attach<ITfContext> ic, LIBTHREAD* pLibTLS) : ImmIfEditSessionCallBack(hIMC, tid, ic, pLibTLS) { }

    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes)
    {
        return RemoveProperty(ec,
                              pes->m_ic,
                              pes->m_guid);
    }

    HRESULT RemoveProperty(TfEditCookie ec,
                           Interface_Attach<ITfContext> ic,
                           const GUID* guid);
};


#endif // _EDITSES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\editcomp.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    editcomp.h

Abstract:

    This file defines the EditCompositionString Class.

Author:

Revision History:

Notes:

--*/

#ifndef _EDITCOMP_H_
#define _EDITCOMP_H_

#include "imc.h"
#include "template.h"
#include "ctxtcomp.h"
#include "context.h"

/////////////////////////////////////////////////////////////////////////////
// EditCompositionString

class EditCompositionString
{
public:
    HRESULT SetString(IMCLock& imc,
                      CicInputContext& CicContext,
                      CWCompString* CompStr,
                      CWCompAttribute* CompAttr,
                      CWCompClause* CompClause,
                      CWCompCursorPos* CompCursorPos,
                      CWCompDeltaStart* CompDeltaStart,
                      CWCompTfGuidAtom* CompGuid,
                      OUT BOOL* lpbBufferOverflow,
                      CWCompString* CompReadStr = NULL,
                      CWCompAttribute* CompReadAttr = NULL,
                      CWCompClause* CompReadClause = NULL,
                      CWCompString* ResultStr = NULL,
                      CWCompClause* ResultClause = NULL,
                      CWCompString* ResultReadStr = NULL,
                      CWCompClause* ResultReadClause = NULL,
                      CWInterimString* InterimStr = NULL);

private:

    HRESULT _MakeCompositionData(IMCLock& imc,
                                 CWCompString* CompStr,
                                 CWCompAttribute* CompAttr,
                                 CWCompClause* CompClause,
                                 CWCompCursorPos* CompCursorPos,
                                 CWCompDeltaStart* CompDeltaStart,
                                 CWCompTfGuidAtom* CompGuid,
                                 CWCompString* CompReadStr,
                                 CWCompAttribute* CompReadAttr,
                                 CWCompClause* CompReadClause,
                                 CWCompString* ResultStr,
                                 CWCompClause* ResultClause,
                                 CWCompString* ResultReadStr,
                                 CWCompClause* ResultReadClause,
                                 OUT LPARAM* lpdwFlag,
                                 OUT BOOL* lpbBufferOverflow);

    HRESULT _MakeInterimData(IMCLock& imc,
                             CWInterimString* InterimStr,
                             LPARAM* lpdwFlag);

    HRESULT _GenerateKoreanComposition(IMCLock& imc,
                           CicInputContext& CicContext,
                           CWCompString*);
};

#endif // _EDITCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\funcprv.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    funcprv.h

Abstract:

    This file defines the CFunctionProvider Interface Class.

Author:

Revision History:

Notes:

--*/


#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"
#include "fnprbase.h"
#include "aimmex.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

class CFunctionProvider :  public CFunctionProviderBase
{
public:
    CFunctionProvider(TfClientId tid);

    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnDocFeed
//
//////////////////////////////////////////////////////////////////////////////

class CFnDocFeed : public IAImmFnDocFeed
{
public:
    CFnDocFeed()
    {
        _cRef = 1;
    }
    virtual ~CFnDocFeed() { }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnDocFeed
    //
    STDMETHODIMP DocFeed();
    STDMETHODIMP ClearDocFeedBuffer();
    STDMETHODIMP StartReconvert();

    STDMETHODIMP StartUndoCompositionString();

private:
    long _cRef;
};


#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\globals.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    This file implements the global data.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "tls.h"
#include "ime.h"


HINSTANCE g_hInst;

const WCHAR s_szUIClassName[16]  = L"MSCTFIME UI";
const WCHAR s_szCompClassName[]  = L"MSCTFIME Composition";


DWORD TLS::dwTLSIndex = TLS_OUT_OF_INDEXES;


/* a94c5fd2-c471-4031-9546-709c17300cb9 */
extern const GUID GUID_COMPARTMENT_CTFIME_DIMFLAGS = { 
    0xa94c5fd2,
    0xc471,
    0x4031,
    {0x95, 0x46, 0x70, 0x9c, 0x17, 0x30, 0x0c, 0xb9}
  };

// {85A688F7-6DC8-4f17-A83A-B11C09CDD7BF}
extern const GUID GUID_COMPARTMENT_CTFIME_CICINPUTCONTEXT = {
    0x85a688f7,
    0x6dc8,
    0x4f17,
    { 0xa8, 0x3a, 0xb1, 0x1c, 0x9, 0xcd, 0xd7, 0xbf }
  };

CCicCriticalSectionStatic g_cs;
DECLARE_OSVER()

/////////////////////////////////////////////////////////////////////////////
// WM_MSIME_xxxx

UINT  WM_MSIME_SERVICE;
UINT  WM_MSIME_UIREADY;
UINT  WM_MSIME_RECONVERTREQUEST;
UINT  WM_MSIME_RECONVERT;
UINT  WM_MSIME_DOCUMENTFEED;
UINT  WM_MSIME_QUERYPOSITION;
UINT  WM_MSIME_MODEBIAS;
UINT  WM_MSIME_SHOWIMEPAD;
UINT  WM_MSIME_MOUSE;
UINT  WM_MSIME_KEYMAP;

/* friend */
BOOL IsMsImeMessage(UINT uMsg)
{
    if (uMsg == WM_MSIME_SERVICE ||
        uMsg == WM_MSIME_UIREADY ||
        uMsg == WM_MSIME_RECONVERTREQUEST ||
        uMsg == WM_MSIME_RECONVERT ||
        uMsg == WM_MSIME_DOCUMENTFEED ||
        uMsg == WM_MSIME_QUERYPOSITION ||
        uMsg == WM_MSIME_MODEBIAS ||
        uMsg == WM_MSIME_SHOWIMEPAD ||
        uMsg == WM_MSIME_MOUSE ||
        uMsg == WM_MSIME_KEYMAP)
        return TRUE;
    else
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

DWORD g_dwThreadDllMain = 0;

/////////////////////////////////////////////////////////////////////////////

DWORD g_bWinLogon = FALSE;

/////////////////////////////////////////////////////////////////////////////

HIMC GetActiveContext()
{
    HWND hWnd = GetFocus();
    if (hWnd == NULL)
        hWnd = GetActiveWindow();
    return ImmGetContext(hWnd);
}


BOOL IsVKDBEKey(UINT uVKey)
{
    switch (uVKey)
    {
        case VK_DBE_ALPHANUMERIC:
        case VK_DBE_KATAKANA:
        case VK_DBE_HIRAGANA:
        case VK_DBE_SBCSCHAR:
        case VK_DBE_DBCSCHAR:
        case VK_DBE_ROMAN:
        case VK_DBE_NOROMAN:
        case VK_DBE_CODEINPUT:
        case VK_DBE_NOCODEINPUT:
        case VK_DBE_ENTERWORDREGISTERMODE:
        case VK_DBE_ENTERIMECONFIGMODE:
        case VK_DBE_ENTERDLGCONVERSIONMODE:
        case VK_DBE_DETERMINESTRING:
        case VK_DBE_FLUSHSTRING:
        case VK_CONVERT:
        case VK_KANJI:
             return TRUE;
    }
    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////

typedef BYTE (*PFNRTLDLLSHUTDOWNINPROGRESS)(void);

BOOL DllShutDownInProgress()
{
    BOOL fRet = FALSE;
    static PFNRTLDLLSHUTDOWNINPROGRESS pfn = NULL;

    if (!pfn)
    {
        HINSTANCE hInst;
        hInst = GetSystemModuleHandle("ntdll.dll");
        if (hInst)
        {
            pfn = (PFNRTLDLLSHUTDOWNINPROGRESS)GetProcAddress(hInst,
                                                  "RtlDllShutdownInProgress");
        }
    }

    if (pfn)
        fRet = pfn() ? TRUE : FALSE;

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\funcprv.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    funcprv.cpp

Abstract:

    This file implements the CFunctionProvider Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "funcprv.h"
#include "tls.h"
#include "context.h"
#include "profile.h"
#include "cresstr.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProvider::CFunctionProvider(TfClientId tid) : CFunctionProviderBase(tid)
{
    Init(CLSID_CAImmLayer, L"MSCTFIME::Function Provider");
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IAImmFnDocFeed))
    {
        *ppunk = new CFnDocFeed();
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnDocFeed
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IAImmFnDocFeed))
    {
        *ppvObj = SAFECAST(this, CFnDocFeed *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnDocFeed::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnDocFeed::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::GetDisplayName(BSTR *pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = SysAllocString(CRStr2(IDS_FUNCPRV_CONVERSION));
    if (!*pbstrName)
        return E_OUTOFMEMORY;

    return S_OK;
}
//+---------------------------------------------------------------------------
//
// CFnDocFeed::IsEnabled
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::IsEnabled(BOOL *pfEnable)
{
    if (!pfEnable)
        return E_INVALIDARG;

    *pfEnable = TRUE;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// CFnDocFeed::DocFeed
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::DocFeed()
{
    DebugMsg(TF_FUNC, TEXT("CFnDocFeed::DocFeed"));

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::DocFeed. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    IMCLock imc(GetActiveContext());
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::DocFeed. imc==NULL."));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::DocFeed. imc_ctfime==NULL."));
        return hr;
    }

    CicInputContext* pCicContext = imc_ctfime->m_pCicContext;
    if (!pCicContext)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::DocFeed. pCicContext==NULL."));
        return E_FAIL;
    }

    UINT cp = CP_ACP;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::DocFeed. _pProfile==NULL."));
        return E_FAIL;
    }

    _pProfile->GetCodePageA(&cp);

    pCicContext->SetupDocFeedString(imc, cp);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::ClearDocFeedBuffer
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::ClearDocFeedBuffer()
{
    DebugMsg(TF_FUNC, TEXT("CFnDocFeed::ClearDocFeedBuffer"));

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::ClearDocFeedBuffer. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    IMCLock imc(GetActiveContext());
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::ClearDocFeedBuffer. imc==NULL."));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::ClearDocFeed. imc_ctfime==NULL."));
        return hr;
    }

    CicInputContext* pCicContext = imc_ctfime->m_pCicContext;
    if (!pCicContext)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::ClearDocFeed. pCicContext==NULL."));
        return E_FAIL;
    }

    pCicContext->ClearDocFeedBuffer(imc);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::StartReconvert
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::StartReconvert()
{
    DebugMsg(TF_FUNC, TEXT("CFnDocFeed::StartReconvert"));

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartReconvert. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartReconvert. ptim_P==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    IMCLock imc(GetActiveContext());
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartReconvert. imc==NULL."));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartReconvert. imc_ctfime==NULL."));
        return hr;
    }

    CicInputContext* pCicContext = imc_ctfime->m_pCicContext;
    if (!pCicContext)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartReconvert. _pCicContext==NULL."));
        return E_FAIL;
    }

    UINT cp = CP_ACP;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartReconvert. _pProfile==NULL."));
        return E_FAIL;
    }

    _pProfile->GetCodePageA(&cp);

    pCicContext->m_fInDocFeedReconvert.SetFlag();

    pCicContext->SetupReconvertString(imc, ptim_P, cp, 0, FALSE);
    pCicContext->EndReconvertString(imc);

    pCicContext->m_fInDocFeedReconvert.ResetFlag();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::StartUndoCompositionString
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::StartUndoCompositionString()
{
    DebugMsg(TF_FUNC, TEXT("CFnDocFeed::StartUndoCompositionString"));

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartUndoCompositionString. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartUndoCompositionString. ptim_P==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    IMCLock imc(GetActiveContext());
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartUndoCompositionString. imc==NULL."));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartUndoCompositionString. imc_ctfime==NULL."));
        return hr;
    }

    CicInputContext* pCicContext = imc_ctfime->m_pCicContext;
    if (!pCicContext)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartUndoComposition. pCicContext==NULL."));
        return E_FAIL;
    }

    UINT cp = CP_ACP;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CFnDocFeed::StartUndoCompositionString. _pProfile==NULL."));
        return E_FAIL;
    }

    _pProfile->GetCodePageA(&cp);

    pCicContext->SetupUndoCompositionString(imc, ptim_P, cp);
    pCicContext->EndUndoCompositionString(imc);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\makefile.inc ===
imm.h : $(OAK_INC_PATH)\immdev.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\korimx.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    korimx.h

Abstract:

    This file defines the Koram KBD TIP specific value.

Author:

Revision History:

Notes:

--*/

#ifndef _KORIMX_H_
#define _KORIMX_H_


const GUID GUID_COMPARTMENT_KORIMX_CONVMODE =
	{ 
	0x91656349, 
	0x4ba9, 
	0x4143, 
	{ 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
	};

//
//  Korean TIP Conversion modes
//
#define KORIMX_ALPHANUMERIC_MODE           0
#define KORIMX_HANGUL_MODE                 1
#define KORIMX_JUNJA_MODE                  2
#define KORIMX_HANGULJUNJA_MODE            3

#endif // _KORIMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\icocb.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    icocb.h

Abstract:

    This file defines the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _ICOCB_H_
#define _ICOCB_H_

#include "template.h"
#include "imc.h"
#include "context.h"
#include "candpos.h"

class CMouseSink;

class CInputContextOwnerCallBack : public CInputContextOwner
{
public:
    CInputContextOwnerCallBack(
        TfClientId tid,
        Interface_Attach<ITfContext> pic,
        LIBTHREAD *pLibTLS);
    virtual ~CInputContextOwnerCallBack();

    BOOL Init();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    HRESULT IcoTextExt(IMCLock& imc, CicInputContext& CicContext, LANGID langid, ICOARGS *pargs);

    //
    // Mouse sink
    //
    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc);

    //
    // Callbacks
    //
private:
    static HRESULT ICOwnerSinkCallback(UINT uCode, ICOARGS *pargs, void *pv);

    HRESULT GetAttribute(IMCLock& imc, CicInputContext& CicContext, LANGID langid, const GUID *pguid, VARIANT *pvarValue);

    //
    // Mouse sink
    //
    CMouseSink                    *m_pMouseSink;

private:
    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
};

#endif // _ICOCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\globals.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This file defines the global data.

Author:

Revision History:

Notes:

--*/


#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include "template.h"
#include "imc.h"
#include "ciccs.h"

/////////////////////////////////////////////////////////////////////////////
// Prototype

extern "C" {
    BOOL PASCAL AttachIME();
    void PASCAL DetachIME();
    LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);

    HRESULT WINAPI Inquire(LPIMEINFO, LPWSTR, DWORD, HKL);

    BYTE GetCharsetFromLangId(LCID lcid);

    HIMC GetActiveContext();

    BOOL IsVKDBEKey(UINT uVKey);

    HRESULT WINAPI CtfImeThreadDetach();

    BOOL DllShutDownInProgress();
}

/////////////////////////////////////////////////////////////////////////////
// Data

extern const WCHAR s_szUIClassName[16];
extern const WCHAR s_szCompClassName[];

extern const GUID GUID_COMPARTMENT_CTFIME_DIMFLAGS;
extern const GUID GUID_COMPARTMENT_CTFIME_CICINPUTCONTEXT;

extern CCicCriticalSectionStatic g_cs;

/////////////////////////////////////////////////////////////////////////////
// Flags for GUID_COMPARTMENT_CTFIME_DIMFLAGS
#define COMPDIMFLAG_OWNEDDIM   0x0001


/////////////////////////////////////////////////////////////////////////////
// Module instance

__inline HINSTANCE GetInstance()
{
    extern HINSTANCE g_hInst;
    return g_hInst;
}

__inline void SetInstance(HINSTANCE hInst)
{
    extern HINSTANCE g_hInst;
    g_hInst = hInst;
}

/////////////////////////////////////////////////////////////////////////////
// Mouse sink

typedef struct tagPRIVATE_MOUSESINK {
    Interface<ITfRangeACP> range;
    HIMC         hImc;
} PRIVATE_MOUSESINK, *LPPRIVATE_MOUSESINK;


typedef struct tagMOUSE_RANGE_RECT {
    ULONG uStartRangeEdge;
    ULONG uStartRangeQuadrant;
    ULONG uEndRangeEdge;
    ULONG uEndRangeQuadrant;
} MOUSE_RANGE_RECT, *LPMOUSE_RANGE_RECT;

/////////////////////////////////////////////////////////////////////////////
// WM_MSIME_xxxx

extern    UINT  WM_MSIME_SERVICE;
extern    UINT  WM_MSIME_UIREADY;
extern    UINT  WM_MSIME_RECONVERTREQUEST;
extern    UINT  WM_MSIME_RECONVERT;
extern    UINT  WM_MSIME_DOCUMENTFEED;
extern    UINT  WM_MSIME_QUERYPOSITION;
extern    UINT  WM_MSIME_MODEBIAS;
extern    UINT  WM_MSIME_SHOWIMEPAD;
extern    UINT  WM_MSIME_MOUSE;
extern    UINT  WM_MSIME_KEYMAP;

/////////////////////////////////////////////////////////////////////////////
// WM_IME_NOTIFY

#define IMN_PRIVATE_ONLAYOUTCHANGE                (IMN_PRIVATE+1)
#define IMN_PRIVATE_ONCLEARDOCFEEDBUFFER          (IMN_PRIVATE+2) 
#define IMN_PRIVATE_GETCONTEXTFLAG                (IMN_PRIVATE+3)
#define IMN_PRIVATE_GETCANDRECTFROMCOMPOSITION    (IMN_PRIVATE+4)
#define IMN_PRIVATE_STARTLAYOUTCHANGE             (IMN_PRIVATE+5)
#define IMN_PRIVATE_GETTEXTEXT                    (IMN_PRIVATE+6)
//
// FrontPage XP call SendMessage(WM_IME_NOTIFY, NI_COMPOSITIONSTR)
// So we can not use IMN_PRIVATE+7.
//
// #define IMN_PRIVATE_FRONTPAGERESERVE              (IMN_PRIVATE+7)
#define IMN_PRIVATE_DELAYRECONVERTFUNCCALL        (IMN_PRIVATE+8)
#define IMN_PRIVATE_GETUIWND                      (IMN_PRIVATE+9)

/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
extern DWORD g_dwThreadDllMain;
#endif

/////////////////////////////////////////////////////////////////////////////

extern DWORD g_bWinLogon;

/////////////////////////////////////////////////////////////////////////////
// Delay load

HRESULT Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv);

/////////////////////////////////////////////////////////////////////////////
// RotateSize

inline void RotateSize(LPSIZE size)
{
    int nTemp; 
    nTemp = size->cx; 
    size->cx = size->cy; 
    size->cy = nTemp;
}

/////////////////////////////////////////////////////////////////////////////
// IS_IME_KBDLAYOUT

inline BOOL IS_IME_KBDLAYOUT(HKL hKL)
{
    return ((HIWORD((ULONG_PTR)(hKL)) & 0xf000) == 0xe000);
}

inline BOOL IS_EA_KBDLAYOUT(HKL hKL)
{
    switch (LOWORD((ULONG_PTR)(hKL)))
    {
        case 0x411:
        case 0x412:
        case 0x404:
        case 0x804:
            return TRUE;
    }
    return FALSE;
}

#endif  // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\icocb.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    icocb.cpp

Abstract:

    This file implements the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "icocb.h"
#include "imc.h"
#include "mouse.h"
#include "tls.h"
#include "profile.h"
#include "uicomp.h"


//
// MSIME private smode. Office 2k uses this bit to set KOUGO mode.
//
#define IME_SMODE_PRIVATE_KOUGO     0x10000


CInputContextOwnerCallBack::CInputContextOwnerCallBack(
    TfClientId tid,
    Interface_Attach<ITfContext> pic,
    LIBTHREAD *pLibTLS) : m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS),
                          CInputContextOwner(ICOwnerSinkCallback, NULL)
{
    m_pMouseSink = NULL;
}

CInputContextOwnerCallBack::~CInputContextOwnerCallBack(
    )
{
    if (m_pMouseSink) {
        m_pMouseSink->InternalRelease();
        m_pMouseSink = NULL;
    }
}


BOOL CInputContextOwnerCallBack::Init()
{
    //
    // Create Mouse Sink
    //
    Assert(!m_pMouseSink);

    m_pMouseSink = new CMouseSink(m_tid, m_ic, m_pLibTLS);
    if (m_pMouseSink == NULL)
        return FALSE;

    if (!m_pMouseSink->Init())
    {
        delete m_pMouseSink;
        m_pMouseSink = NULL;
        return FALSE;
    }

    return TRUE;
}


// static
HRESULT
CInputContextOwnerCallBack::ICOwnerSinkCallback(
    UINT uCode,
    ICOARGS *pargs,
    void *pv
    )
{
    DebugMsg(TF_FUNC, TEXT("ICOwnerSinkCallback"));

    POINT pt;

    CInputContextOwnerCallBack* _this = (CInputContextOwnerCallBack*)pv;

    TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                      // DllMain -> ImeDestroy -> DeactivateIMMX -> Deactivate
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback. ptls==NULL."));
        return E_FAIL;
    }


    switch (uCode)
    {
        case ICO_POINT_TO_ACP:
            Assert(0);
            return E_NOTIMPL;

        case ICO_KEYDOWN:
        case ICO_KEYUP:
            *pargs->key.pfEaten = FALSE;
            break;

        case ICO_SCREENEXT:
            {
                HRESULT hr;
                IMCLock imc(GetActiveContext());
                if (FAILED(hr=imc.GetResult()))
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback. imc==NULL."));
                    return hr;
                }

                GetClientRect(imc->hWnd, pargs->scr_ext.prc);
                pt.x = pt.y = 0;
                ClientToScreen(imc->hWnd, &pt);

                pargs->scr_ext.prc->left += pt.x;
                pargs->scr_ext.prc->right += pt.x;
                pargs->scr_ext.prc->top += pt.y;
                pargs->scr_ext.prc->bottom += pt.y;
            }

            break;

        case ICO_TEXTEXT:
            //
            // consider.
            //
            // hack TextExtent from CANDIDATEFORM of HIMC.
            //
            // more hacks
            //   - may want to send WM_OPENCANDIDATEPOS to let apps
            //     call ImmSetCandidateWindow().
            //   - may need to calculate the actual point from rcArea.
            //
            {
                HRESULT hr;
                IMCLock imc(GetActiveContext());
                if (FAILED(hr=imc.GetResult()))
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback. imc==NULL."));
                    return hr;
                }

                IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
                if (imc_ctfime.Invalid())
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback(ICO_TEXTEXT). imc_ctfime==NULL."));
                    break;
                }

                CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
                if (_pCicContext == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback(ICO_TEXTEXT). _pCicContext==NULL."));
                    break;
                }

                LANGID langid;
                CicProfile* _pProfile = ptls->GetCicProfile();
                if (_pProfile == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback(ICO_TEXTEXT). _pProfile==NULL."));
                    break;
                }

                _pProfile->GetLangId(&langid);

                _this->IcoTextExt(imc, *_pCicContext, langid, pargs);
            }
            break;

        case ICO_STATUS:
            pargs->status.pdcs->dwDynamicFlags = 0;
            pargs->status.pdcs->dwStaticFlags = TF_SS_TRANSITORY;
            break;

        case ICO_WND:
            {
                HRESULT hr;
                IMCLock imc(GetActiveContext());
                if (FAILED(hr=imc.GetResult()))
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback. imc==NULL."));
                    return hr;
                }

                *(pargs->hwnd.phwnd) = imc->hWnd;
            }
            break;

        case ICO_ATTR:
            {
                HRESULT hr;
                IMCLock imc(GetActiveContext());
                if (FAILED(hr=imc.GetResult()))
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback. imc==NULL."));
                    return hr;
                }

                IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
                if (imc_ctfime.Invalid())
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback(ICO_ATTR). imc_ctfime==NULL."));
                    break;
                }

                CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
                if (_pCicContext == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback(ICO_ATTR). _pCicContext==NULL."));
                    break;
                }

                LANGID langid;
                CicProfile* _pProfile = ptls->GetCicProfile();
                if (_pProfile == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback(ICO_ATTR). _pProfile==NULL."));
                    break;
                }

                _pProfile->GetLangId(&langid);

                return _this->GetAttribute(imc, *_pCicContext, langid, pargs->sys_attr.pguid, pargs->sys_attr.pvar);
            }

        case ICO_ADVISEMOUSE:
            {
                HRESULT hr;
                IMCLock imc(GetActiveContext());
                if (FAILED(hr=imc.GetResult()))
                {
                    DebugMsg(TF_ERROR, TEXT("CInputContextOwnerCallBack::ICOwnerSinkCallback. imc==NULL."));
                    return hr;
                }

                _this->m_pMouseSink->InternalAddRef();
                return _this->m_pMouseSink->AdviseMouseSink(imc,
                                                            pargs->advise_mouse.rangeACP,
                                                            pargs->advise_mouse.pSink,
                                                            pargs->advise_mouse.pdwCookie);
            }
            break;

        case ICO_UNADVISEMOUSE:
            {
                HRESULT hr = _this->m_pMouseSink->UnadviseMouseSink(pargs->unadvise_mouse.dwCookie);
                _this->m_pMouseSink->InternalRelease();
                return hr;
            }
            break;

        default:
            Assert(0); // shouldn't ever get here
            break;
    }

    return S_OK;
}

/*++

Method:

    CInputContextOwnerCallBack::GetAttribute

Routine Description:

    Implementation of ITfContextOwner::GetAttribute.  Returns the value of a cicero
    app property attribute.

Arguments:


    pguid - [in] GUID of the attrib in question.
    pvarValue - [out] VARIANT, receives the value.  VT_EMPTY if we don't support it.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

HRESULT
CInputContextOwnerCallBack::GetAttribute(
    IMCLock& imc,
    CicInputContext& CicContext,
    LANGID langid,
    const GUID *pguid,
    VARIANT *pvarValue
    )
{
    TfGuidAtom ga;
    const GUID *pguidValue;

    QuickVariantInit(pvarValue);

    if (IsEqualGUID(*pguid, GUID_PROP_MODEBIAS))
    {
        BOOL fModeChanged = CicContext.m_fConversionSentenceModeChanged.IsSetFlag();
        CicContext.m_fConversionSentenceModeChanged.ResetFlag();

        // xlate conversion mode, sentence mode to cicero mode bias
        GUID guidModeBias = CicContext.m_ModeBias.GetModeBias();

        if (CicContext.m_fOnceModeChanged.IsResetFlag())
        {
            return S_OK;
        }

        if (CicContext.m_nInConversionModeResetRef)
        {
            pguidValue = &GUID_NULL;
            fModeChanged = TRUE;
            goto SetGA;
        }

        if (! IsEqualGUID(guidModeBias, GUID_MODEBIAS_NONE))
        {
            if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_DEFAULT))
            {
                // reset mode bias to GUID_MODEBIAS_NONE
                CicContext.m_ModeBias.SetModeBias(GUID_MODEBIAS_NONE);

                // GUID_MODEBIAS_NONE == GUID_NULL;
                pguidValue = &GUID_NULL;
                fModeChanged = TRUE;

                // Reset flag
                CicContext.m_fOnceModeChanged.ResetFlag();
            }
            else
            {
                pguidValue = &guidModeBias;
            }
        }
        else
        {
            //
            // existing logic:
            //
            // if imcp->lModeBias == MODEBIASMODE_DEFAULT
            //      IME_SMODE_CONVERSATION -> GUID_MODEBIAS_CONVERSATION
            //      otherwise -> GUID_MODEBIAS_NONE
            // otherwise
            //      -> MODEBIASMODE_FILENAME -> GUID_MODEBIAS_FILENAME
            //

            if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_NONE))
            {
                pguidValue = &GUID_MODEBIAS_NONE;

                if (imc->fdwConversion & IME_CMODE_KATAKANA)
                {
                    if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                        pguidValue = &GUID_MODEBIAS_KATAKANA;
                    else
                        pguidValue = &GUID_MODEBIAS_HALFWIDTHKATAKANA;
                }
                else if (imc->fdwConversion & IME_CMODE_NATIVE)
                {
                    pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                    if (langid == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
                    {
                        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                            pguidValue = &GUID_MODEBIAS_HIRAGANA;
                        else
                            pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                    }
                    else if (langid == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT))
                    {
                        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                            pguidValue = &GUID_MODEBIAS_FULLWIDTHHANGUL;
                        else
                            pguidValue = &GUID_MODEBIAS_HANGUL;
                    }
                    else if (PRIMARYLANGID(langid) == LANG_CHINESE)
                    {
                        pguidValue = &GUID_MODEBIAS_CHINESE;
                    }
                }
                else
                {
                    if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                        pguidValue = &GUID_MODEBIAS_FULLWIDTHALPHANUMERIC;
                    else
                        pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                }
            }

            if (!CicContext.m_nInConversionModeChangingRef)
            {
                //
                // We overwrite modebias here....
                //
                if ((imc->fdwSentence & IME_SMODE_CONVERSATION) ||
                         ((imc->fdwSentence & (IME_SMODE_PHRASEPREDICT | IME_SMODE_PRIVATE_KOUGO)) ==  (IME_SMODE_PHRASEPREDICT | IME_SMODE_PRIVATE_KOUGO)))
                {
                    pguidValue = &GUID_MODEBIAS_CONVERSATION;
                }
                else if (imc->fdwSentence & IME_SMODE_PLAURALCLAUSE)
                {
                    pguidValue = &GUID_MODEBIAS_NAME;
                }
            }
        }

SetGA:
        if (!GetGUIDATOMFromGUID(m_pLibTLS, *pguidValue, &ga))
            return E_FAIL;

        //
        // Cicero 5073:
        //
        // returning valid variant value, Satori set back to its default 
        // input mode.
        //
        if (!IsEqualGUID(*pguidValue, GUID_NULL) || fModeChanged)
        {
            pvarValue->vt = VT_I4; // for TfGuidAtom
            pvarValue->lVal = ga;
        }
    }
    if (IsEqualGUID(*pguid, TSATTRID_Text_Orientation))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IME_UIWND_STATE uists = UIComposition::InquireImeUIWndState(imc);

        pvarValue->vt = VT_I4; 
        if (uists == IME_UIWND_LEVEL1)
            pvarValue->lVal = 0;
        else
            pvarValue->lVal = imc->lfFont.W.lfEscapement;
    }
    if (IsEqualGUID(*pguid, TSATTRID_Text_VerticalWriting))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        LOGFONT font;

        if (ImmGetCompositionFont((HIMC)imc, &font)) {
            pvarValue->vt = VT_BOOL; 
            pvarValue->lVal = (font.lfFaceName[0] == L'@' ? TRUE : FALSE);
        }
    }


    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CInputContextOwnerCallBack::MsImeMouseHandler
//
//+---------------------------------------------------------------------------

LRESULT
CInputContextOwnerCallBack::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc
    )
{
    return m_pMouseSink->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwnerCallBack::IcoTextExt
//
//+---------------------------------------------------------------------------

HRESULT 
CInputContextOwnerCallBack::IcoTextExt(
    IMCLock& imc, 
    CicInputContext& CicContext, 
    LANGID langid, 
    ICOARGS *pargs)
{
    IME_UIWND_STATE uists;
    uists = UIComposition::InquireImeUIWndState(imc);
    if (uists == IME_UIWND_LEVEL1 ||
        uists == IME_UIWND_LEVEL2 ||
        uists == IME_UIWND_LEVEL1_OR_LEVEL2)
    {

        UIComposition::TEXTEXT uicomp_text_ext;
        uicomp_text_ext.SetICOARGS(pargs);
        return UIComposition::GetImeUIWndTextExtent(&uicomp_text_ext) ? S_OK : E_FAIL;
    }

    CCandidatePosition cand_pos(m_tid, m_ic, m_pLibTLS);
    return cand_pos.GetCandidatePosition(imc, CicContext, uists, langid, pargs->text_ext.prc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\imc.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    imc.cpp

Abstract:

    This file implements the IMCLock / IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "imc.h"
#include "context.h"

/////////////////////////////////////////////////////////////////////////////
// IMCLock

IMCLock::IMCLock(
    HIMC hImc
    ) : _IMCLock(hImc)
{
    if (hImc) {
        m_hr = _LockIMC(hImc, &m_inputcontext);
    }
}

HRESULT
IMCLock::_LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT **ppIMC
    )
{
    if (hIMC == NULL) {
        return E_INVALIDARG;
    }

    *ppIMC = (INPUTCONTEXT*)ImmLockIMC(hIMC);
    return *ppIMC == NULL ? E_FAIL : S_OK;
}

HRESULT
IMCLock::_UnlockIMC(
    IN HIMC hIMC
    )
{
    return ImmUnlockIMC(hIMC) ? S_OK : E_FAIL;
}

BOOL
IMCLock::ValidCompositionString(
    )
{
    if (ImmGetIMCCSize(m_inputcontext->hCompStr) < sizeof(COMPOSITIONSTRING))
        return FALSE;

    IMCCLock<COMPOSITIONSTRING> lpCompStr(m_inputcontext->hCompStr);
    if (lpCompStr.Invalid())
        return FALSE;

    return (lpCompStr->dwCompStrLen > 0);
}

//
// Initialize the context
//
void
IMCLock::InitContext(
    )
{
    if (!(m_inputcontext->fdwInit & INIT_COMPFORM)) {
        m_inputcontext->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    for (UINT i = 0; i < 4; i++) {
        m_inputcontext->cfCandForm[i].dwStyle = CFS_DEFAULT;
    }

    return;
}

//
// clear candidate list
//
BOOL
IMCLock::ClearCand(
    )
{
    HIMCC           hMem;
    LPCANDIDATELIST lpCandList;
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;

    if (! m_inputcontext->hCandInfo) {
        // it maybe free by other IME, init it
        m_inputcontext->hCandInfo = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(m_inputcontext->hCandInfo, dwSize)) {
        m_inputcontext->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(m_inputcontext->hCandInfo);
        m_inputcontext->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (! m_inputcontext->hCandInfo) {
        return (FALSE);
    }


    IMCCLock<CANDIDATEINFO> lpCandInfo(m_inputcontext->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(m_inputcontext->hCandInfo);
        m_inputcontext->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)lpCandInfo.GetOffsetPointer( lpCandInfo->dwOffset[0] );
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    return (TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// InternalIMCCLock

InternalIMCCLock::InternalIMCCLock(
    HIMCC hImcc
    ) : _IMCCLock(hImcc)
{
    if (hImcc) {
        m_hr = _LockIMCC(m_himcc, (void**)&m_pimcc);
    }
}


HRESULT
InternalIMCCLock::_LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )
{
    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    *ppv = ImmLockIMCC(hIMCC);
#if defined(DEBUG)
    if (*ppv) {
        HeapValidate( GetProcessHeap(), 0, *ppv);
    }
#endif
    return *ppv == NULL ? E_FAIL : S_OK;
}

HRESULT
InternalIMCCLock::_UnlockIMCC(
    IN HIMCC hIMCC
    )
{
    return ImmUnlockIMCC(hIMCC) ? S_OK :
        GetLastError() == NO_ERROR ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\misc.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

Author:

Revision History:

Notes:

--*/

#include "private.h"
#pragma warning(disable: 4005)
#include <wingdip.h>

extern "C" BYTE GetCharsetFromLangId(LCID lcid)
{
    CHARSETINFO csInfo;

    if (!TranslateCharsetInfo((DWORD *)(ULONG_PTR)lcid, &csInfo, TCI_SRCLOCALE))
        return DEFAULT_CHARSET;
    return (BYTE) csInfo.ciCharset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\imc.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    imc.h

Abstract:

    This file defines the IMCLock / IMCCLock Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMC_H_
#define _IMC_H_

const int MAXCAND = 256;
const int CANDPERPAGE = 9;

typedef enum {
    DIR_LEFT_RIGHT = 0,        // normal
    DIR_BOTTOM_TOP = 900 / 900,        // vertical
    DIR_RIGHT_LEFT = 1800 / 900,        // right to left
    DIR_TOP_BOTTOM = 2700 / 900,        // vertical
    END_OF_DIR     = 3600 / 900
} DOC_DIR;


/////////////////////////////////////////////////////////////////////////////
// _IMCLock

class _IMCLock
{
public:
    _IMCLock(HIMC hImc=NULL);
    virtual ~_IMCLock() {};

    bool    Valid()     { return m_inputcontext != NULL ? m_hr == S_OK : FALSE; }
    bool    Invalid()   { return !Valid(); }
    HRESULT GetResult() { return m_inputcontext ? m_hr : E_FAIL; }

    operator INPUTCONTEXT*() { return m_inputcontext; }

    INPUTCONTEXT* operator->() {
        ASSERT(m_inputcontext);
        return m_inputcontext;
    }

    operator HIMC() { return m_himc; }

    BOOL IsUnicode() { return m_fUnicode; }

protected:
    INPUTCONTEXT*        m_inputcontext;
    HIMC                 m_himc;
    HRESULT              m_hr;
    BOOL                 m_fUnicode;

    virtual HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC) = 0;
    virtual HRESULT _UnlockIMC(HIMC hIMC) = 0;

private:
    // Do not allow to make a copy
    _IMCLock(_IMCLock&) { }
};


inline
_IMCLock::_IMCLock(
    HIMC hImc
    )
{
    m_inputcontext = NULL;
    m_himc         = hImc;
    m_hr           = S_OK;
    m_fUnicode     = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// _IMCCLock

class _IMCCLock
{
public:
    _IMCCLock(HIMCC himcc = NULL);
    virtual ~_IMCCLock() {};

    bool Valid() { return m_pimcc != NULL; }
    bool Invalid() { return !Valid(); }
    HRESULT GetResult() { return m_pimcc ? m_hr : E_FAIL; }

    void ReleaseBuffer() { }

    void* GetOffsetPointer(DWORD dwOffset) {
        return (void*)( (LPBYTE)m_pimcc + dwOffset );
    }

protected:
    union {
        void*                      m_pimcc;
        COMPOSITIONSTRING*         m_pcomp;
    };

    HIMCC         m_himcc;
    HRESULT       m_hr;

    virtual HRESULT _LockIMCC(HIMCC hIMCC, void **ppv) = 0;
    virtual HRESULT _UnlockIMCC(HIMCC hIMCC) = 0;

private:
    void init(HIMCC hImcc);

    // Do not allow to make a copy
    _IMCCLock(_IMCCLock&) { }
};


inline
_IMCCLock::_IMCCLock(
    HIMCC hImcc
    )
{
    init(hImcc);
}

inline
void
_IMCCLock::init(
    HIMCC hImcc
    )
{
    m_pimcc = NULL;
    m_himcc        = hImcc;
    m_hr           = S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// IMCLock

class IMCLock : public _IMCLock
{
public:
    IMCLock(HIMC hImc=NULL);
    virtual ~IMCLock() {
        if (m_inputcontext) {
            _UnlockIMC(m_himc);
        }
    }

    // virtual InternalIMCCLock
    HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT** ppIMC);
    HRESULT _UnlockIMC(HIMC hIMC);

    void InitContext();
    BOOL ClearCand();

    BOOL ValidCompositionString();

    DOC_DIR GetDirection()
    {
        Assert(m_inputcontext);

        return (DOC_DIR)(m_inputcontext->lfFont.A.lfEscapement / 900 % END_OF_DIR);
    }

    BOOL UseVerticalCompWindow()
    {
        Assert(m_inputcontext);

        if (m_inputcontext->cfCompForm.dwStyle == CFS_DEFAULT)
            return FALSE;

        return ((m_inputcontext->lfFont.A.lfEscapement / 900 % END_OF_DIR) == DIR_TOP_BOTTOM) ? TRUE : FALSE;
    }

private:
    // Do not allow to make a copy
    IMCLock(IMCLock&) { }
};


/////////////////////////////////////////////////////////////////////////////
// InternalIMCCLock

class InternalIMCCLock : public _IMCCLock
{
public:
    InternalIMCCLock(HIMCC hImcc = NULL);
    virtual ~InternalIMCCLock() {
        if (m_pimcc) {
            _UnlockIMCC(m_himcc);
        }
    }

    // virtual InternalIMCCLock
    HRESULT _LockIMCC(HIMCC hIMCC, void** ppv);
    HRESULT _UnlockIMCC(HIMCC hIMCC);

private:
    // Do not allow to make a copy
    InternalIMCCLock(InternalIMCCLock&) { }
};


/////////////////////////////////////////////////////////////////////////////
// IMCCLock

template <class T>
class IMCCLock : public InternalIMCCLock
{
public:
    IMCCLock(HIMCC hImcc) : InternalIMCCLock(hImcc) {};

    T* GetBuffer() { return (T*)m_pimcc; }

    operator T*() { return (T*)m_pimcc; }

    T* operator->() {
        ASSERT(m_pimcc);
        return (T*)m_pimcc;
    }

private:
    // Do not allow to make a copy
    IMCCLock(IMCCLock<T>&) { }
};

/////////////////////////////////////////////////////////////////////////////
// GUID attribute (IME share)
//     COMPOSITIONSTRING->dwPrivateSize = sizeof(GUIDMAPATTRIBUTE) + actual data array.
//     GUIDMAPATTRIBUTE* = GetOffset(COMPOSITIONSTRING->dwPrivateOffset)

class GuidMapAttribute
{
public:
    GuidMapAttribute(GUIDMAPATTRIBUTE* pv)
    {
        m_guid_map = pv;
    }
    virtual ~GuidMapAttribute() { }

    static GUIDMAPATTRIBUTE* GetData(IMCCLock<COMPOSITIONSTRING>& comp)
    {
        if (comp->dwPrivateSize >= sizeof(tagGUIDMAPATTRIBUTE))
        {
            return (GUIDMAPATTRIBUTE*)comp.GetOffsetPointer(comp->dwPrivateOffset);
        }
        else
        {
            return NULL;
        }
    }

    bool Valid() { return m_guid_map != NULL; }
    bool Invalid() { return !Valid(); }

    void* GetOffsetPointer(DWORD dwOffset) {
        return (void*)( (LPBYTE)m_guid_map + dwOffset );
    }

    GUIDMAPATTRIBUTE* operator->() {
        ASSERT(m_guid_map);
        return (GUIDMAPATTRIBUTE*)m_guid_map;
    }

protected:
    GUIDMAPATTRIBUTE*  m_guid_map;
};

#endif // _IMC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\init.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    init.cpp

Abstract:

    This file implements an initialization.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "msime.h"
#include "context.h"
#include "uicomp.h"
#include "caret.h"

//+---------------------------------------------------------------------------
//
// RegisterImeClass
//
//----------------------------------------------------------------------------

BOOL PASCAL RegisterImeClass()
{
    WNDCLASSEXW wcWndCls;

    // register class of IME UI window.
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(LONG_PTR) * 2;    // 0: IMMGWL_IMC
                                                      // 1: IMMGWL_PRIVATE = class UI
    wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wcWndCls.hInstance     = GetInstance();
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPWSTR)NULL;
    wcWndCls.hIconSm       = NULL;

    if (!GetClassInfoExW(GetInstance(), s_szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME | CS_GLOBALCLASS;
        wcWndCls.lpfnWndProc   = UIWndProc;
        wcWndCls.lpszClassName = s_szUIClassName;

        ATOM atom = RegisterClassExW(&wcWndCls);
        if (atom == 0)
            return FALSE;
    }

    // register class of composition window.
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(LONG_PTR);  // COMPUI_WINDOW_INDEX: index of first/middle/last
    wcWndCls.hIcon         = NULL;
    wcWndCls.hInstance     = GetInstance();
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_IBEAM);
    wcWndCls.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPWSTR)NULL;
    wcWndCls.hIconSm       = NULL;

    if (!GetClassInfoExW(GetInstance(), s_szCompClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME | CS_VREDRAW | CS_HREDRAW;
        wcWndCls.lpfnWndProc   = UIComposition::CompWndProc;
        wcWndCls.lpszClassName = s_szCompClassName;

        ATOM atom = RegisterClassExW(&wcWndCls);
        if (atom == 0)
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UnregisterImeClass
//
//----------------------------------------------------------------------------

void PASCAL UnregisterImeClass()
{
    WNDCLASSEXW wcWndCls;
    BOOL ret;

    // IME UI class
    GetClassInfoExW(GetInstance(), s_szUIClassName, &wcWndCls);
    ret = UnregisterClassW(s_szUIClassName, GetInstance());
    Assert(ret);

    DestroyIcon(wcWndCls.hIcon);
    DestroyIcon(wcWndCls.hIconSm);

    // IME composition class
    GetClassInfoExW(GetInstance(), s_szCompClassName, &wcWndCls);
    ret = UnregisterClassW(s_szCompClassName, GetInstance());
    Assert(ret);

    DestroyIcon(wcWndCls.hIcon);
    DestroyIcon(wcWndCls.hIconSm);
}

//+---------------------------------------------------------------------------
//
// RegisterMSIMEMessage
//
//----------------------------------------------------------------------------

BOOL RegisterMSIMEMessage()
{
    WM_MSIME_SERVICE          = RegisterWindowMessage( RWM_SERVICE );
    WM_MSIME_UIREADY          = RegisterWindowMessage( RWM_UIREADY );
    WM_MSIME_RECONVERTREQUEST = RegisterWindowMessage( RWM_RECONVERTREQUEST );
    WM_MSIME_RECONVERT        = RegisterWindowMessage( RWM_RECONVERT );
    WM_MSIME_DOCUMENTFEED     = RegisterWindowMessage( RWM_DOCUMENTFEED );
    WM_MSIME_QUERYPOSITION    = RegisterWindowMessage( RWM_QUERYPOSITION );
    WM_MSIME_MODEBIAS         = RegisterWindowMessage( RWM_MODEBIAS );
    WM_MSIME_SHOWIMEPAD       = RegisterWindowMessage( RWM_SHOWIMEPAD );
    WM_MSIME_MOUSE            = RegisterWindowMessage( RWM_MOUSE );
    WM_MSIME_KEYMAP           = RegisterWindowMessage( RWM_KEYMAP );

    if (!WM_MSIME_SERVICE          ||
        !WM_MSIME_UIREADY          ||
        !WM_MSIME_RECONVERTREQUEST ||
        !WM_MSIME_RECONVERT        ||
        !WM_MSIME_DOCUMENTFEED     ||
        !WM_MSIME_QUERYPOSITION    ||
        !WM_MSIME_MODEBIAS         ||
        !WM_MSIME_SHOWIMEPAD       ||
        !WM_MSIME_MOUSE            ||
        !WM_MSIME_KEYMAP)
        return FALSE;

   return TRUE;
}

//+---------------------------------------------------------------------------
//
// AttachIME
//
//----------------------------------------------------------------------------

BOOL PASCAL AttachIME()
{
    if (!RegisterImeClass())
        return FALSE;

    if (!RegisterMSIMEMessage())
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// DetachIME
//
//----------------------------------------------------------------------------

void PASCAL DetachIME()
{
    UnregisterImeClass();
}

//+---------------------------------------------------------------------------
//
// Inquire
//
//----------------------------------------------------------------------------

HRESULT WINAPI Inquire(
    LPIMEINFO   lpImeInfo,      // IME specific data report to IMM
    LPWSTR      lpszWndCls,     // the class name of UI
    DWORD       dwSystemInfoFlags,
    HKL         hKL)
{
    if (! lpImeInfo)
        return E_OUTOFMEMORY;

    DebugMsg(TF_FUNC, TEXT("Inquire(hKL=%x)"), hKL);

    // UI class name
    wcscpy(lpszWndCls, s_szUIClassName);

    // Private data size.
    lpImeInfo->dwPrivateDataSize = 0;

    // Properties
    if (LOWORD(HandleToUlong(hKL)) == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
    {
        lpImeInfo->fdwProperty =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY |              // This IME needs the ALT key to be passed to ImmProcessKey.
        IME_PROP_COMPLETE_ON_UNSELECT;      // Windows 98 and Windows 2000:
                                            // If set, the IME will complete the composition
                                            // string when the IME is deactivated.
                                            // If clear, the IME will cancel the composition
                                            // string when the IME is deactivated.
                                            // (for example, from a keyboard layout change).

        lpImeInfo->fdwConversionCaps =
        IME_CMODE_JAPANESE |         // This bit on indicates IME is in JAPANESE(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_KATAKANA |         //
        IME_CMODE_FULLSHAPE;

        lpImeInfo->fdwSentenceCaps =
        IME_SMODE_PLAURALCLAUSE |
        IME_SMODE_CONVERSATION;

        lpImeInfo->fdwSCSCaps =
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        lpImeInfo->fdwUICaps = UI_CAP_ROT90;

        // IME want to decide conversion mode on ImeSelect
        lpImeInfo->fdwSelectCaps = SELECT_CAP_CONVERSION | SELECT_CAP_SENTENCE;

    }
    else if (LOWORD(HandleToUlong(hKL)) == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT))
    {
        lpImeInfo->fdwProperty =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY |              // This IME needs the ALT key to be passed to ImmProcessKey.
        IME_PROP_COMPLETE_ON_UNSELECT;      // Windows 98 and Windows 2000:
                                            // If set, the IME will complete the composition
                                            // string when the IME is deactivated.
                                            // If clear, the IME will cancel the composition
                                            // string when the IME is deactivated.
                                            // (for example, from a keyboard layout change).

        lpImeInfo->fdwConversionCaps =
        IME_CMODE_HANGUL |           // This bit on indicates IME is in HANGUL(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_FULLSHAPE;

        lpImeInfo->fdwSentenceCaps = 0;

        lpImeInfo->fdwSCSCaps =
        SCS_CAP_COMPSTR |     // This IME can generate the composition string by SCS_SETSTR.
#if 0
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
#endif
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        lpImeInfo->fdwUICaps = UI_CAP_ROT90;

        // IME want to decide conversion mode on ImeSelect
        lpImeInfo->fdwSelectCaps = SELECT_CAP_CONVERSION;

    }
    else if (LOWORD(HandleToUlong(hKL)) == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED) ||
             LOWORD(HandleToUlong(hKL)) == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL))
    {
        lpImeInfo->fdwProperty =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY;        // This IME needs the ALT key to be passed to ImmProcessKey.

        lpImeInfo->fdwConversionCaps =
        IME_CMODE_CHINESE |          // This bit on indicates IME is in CHINESE(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_FULLSHAPE;

        lpImeInfo->fdwSentenceCaps =
        IME_SMODE_PLAURALCLAUSE;

        lpImeInfo->fdwSCSCaps =
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        lpImeInfo->fdwUICaps = UI_CAP_ROT90;

        // IME want to decide conversion mode on ImeSelect
        lpImeInfo->fdwSelectCaps = 0;

    }
    else
    {
        lpImeInfo->fdwProperty =
        IME_PROP_UNICODE |     // If set, the IME is viewed as a Unicode IME. The system and
                               // the IME will communicate through the Unicode IME interface.
                               // If clear, IME will use the ANSI interface to communicate
                               // with the system.
        IME_PROP_AT_CARET;     // If set, conversion window is at the caret position.
                               // If clear, the window is near caret position.
        lpImeInfo->fdwConversionCaps = 0;
        lpImeInfo->fdwSentenceCaps   = 0;
        lpImeInfo->fdwSCSCaps        = 0;
        lpImeInfo->fdwUICaps         = 0;

        // IME want to decide conversion mode on ImeSelect
        lpImeInfo->fdwSelectCaps = 0;

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\modebias.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    modebias.h

Abstract:

    This file defines the CModeBias Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _MODEBIAS_H_
#define _MODEBIAS_H_

typedef struct tagModeBiasMap {
    const GUID*  m_guid;
    LPARAM       m_mode;
} MODE_BIAS_MAP;

extern MODE_BIAS_MAP g_ModeBiasMap[];

class CModeBias
{
public:
    CModeBias()
    {
        m_guidModeBias = GUID_MODEBIAS_NONE;
    }

    GUID       GetModeBias()
    {
        return m_guidModeBias;
    }

    void SetModeBias(GUID guid)
    {
        m_guidModeBias = guid;
    }

    LPARAM     ConvertModeBias(GUID guid);
    GUID       ConvertModeBias(LPARAM mode);

private:
    GUID       m_guidModeBias;
};

#endif // _MODEBIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\mouse.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    mouse.h

Abstract:

    This file defines the CMouseSink Class.

Author:

Revision History:

Notes:

--*/

#ifndef _MOUSE_H_
#define _MOUSE_H_

#include "imc.h"
#include "template.h"

class CMouseSink
{
public:
    CMouseSink(TfClientId tid,
               Interface_Attach<ITfContext> pic,
               LIBTHREAD* pLibTLS)
        : m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS)
    {
        m_ref = 1;

        m_prgMouseSinks = NULL;
    }
    virtual ~CMouseSink()
    {
        if (m_prgMouseSinks)
        {
            delete m_prgMouseSinks;
            m_prgMouseSinks = NULL;
        }
    }

    BOOL Init()
    {
        Assert(!m_prgMouseSinks);
        m_prgMouseSinks = new CStructArray<GENERICSINK>;
        if (!m_prgMouseSinks)
            return FALSE;

        return TRUE;
    }
public:
    ULONG InternalAddRef(void);
    ULONG InternalRelease(void);

public:
    //
    // Mouse sink
    //
public:
    HRESULT AdviseMouseSink(HIMC hImc, ITfRangeACP* range, ITfMouseSink* pSink, DWORD* pdwCookie);
    HRESULT UnadviseMouseSink(DWORD dwCookie);

    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc);

public:
    CStructArray<GENERICSINK> *m_prgMouseSinks;

protected:
    long        m_ref;

    //
    // Edit session helper
    //
protected:
    HRESULT EscbReadOnlyPropMargin(IMCLock& imc, Interface<ITfRangeACP>* range_acp, LONG* pcch)
    {
        return ::EscbReadOnlyPropMargin(imc, m_tid, m_ic, m_pLibTLS, range_acp, pcch);
    }

    //
    // Edit session friend
    //
private:
    friend HRESULT EscbReadOnlyPropMargin(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                          Interface<ITfRangeACP>* range_acp,
                                          LONG*     pcch);

private:
    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
};

#endif // _MOUSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\modebias.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    modebias.cpp

Abstract:

    This file implements the CModeBias Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "modebias.h"
#include "msime.h"
#include "setmode.h"

MODE_BIAS_MAP g_ModeBiasMap[] = {
    { &GUID_MODEBIAS_FILENAME, MODEBIASMODE_FILENAME     },
    { &GUID_MODEBIAS_NUMERIC,  MODEBIASMODE_DIGIT        },
    { &GUID_MODEBIAS_URLHISTORY, MODEBIASMODE_URLHISTORY },
    { &GUID_MODEBIAS_DEFAULT,    MODEBIASMODE_DEFAULT    },
    { &GUID_MODEBIAS_NONE,       MODEBIASMODE_DEFAULT    }
};


LPARAM CModeBias::ConvertModeBias(GUID guid)
{
    for (int i = 0; i < sizeof(g_ModeBiasMap)/sizeof(MODE_BIAS_MAP); i++)
    {
        if (IsEqualGUID(guid, *g_ModeBiasMap[i].m_guid))
            return g_ModeBiasMap[i].m_mode;
    }
    return 0L;
}

GUID CModeBias::ConvertModeBias(LPARAM mode)
{
    for (int i = 0; i < sizeof(g_ModeBiasMap)/sizeof(MODE_BIAS_MAP); i++)
    {
        if (mode == g_ModeBiasMap[i].m_mode)
            return *g_ModeBiasMap[i].m_guid;
    }
    return GUID_NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\mouse.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    mouse.cpp

Abstract:

    This file implements the mouse sink in the ImmIfIME Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "mouse.h"
#include "template.h"
#include "editses.h"
#include "msime.h"

ULONG
CMouseSink::InternalAddRef(
    )
{
    return ++m_ref;
}

ULONG
CMouseSink::InternalRelease(
    )
{
    ULONG cr = --m_ref;

    if (cr == 0) {
        delete this;
    }

    return cr;
}


HRESULT
CMouseSink::AdviseMouseSink(
    HIMC hImc,
    ITfRangeACP* range,
    ITfMouseSink* pSink,
    DWORD* pdwCookie
    )
{
    if (m_prgMouseSinks == NULL)
        return E_FAIL;

    const IID *rgiid = &IID_ITfMouseSink;
    GENERICSINK *pgs;
    HRESULT hr;

    hr = GenericAdviseSink(IID_ITfMouseSink, pSink, &rgiid, m_prgMouseSinks, 1, pdwCookie, &pgs);
    if (hr == S_OK) {
        pgs->uPrivate = (UINT_PTR) new tagPRIVATE_MOUSESINK;
        if (pgs->uPrivate) {
            ((LPPRIVATE_MOUSESINK)pgs->uPrivate)->range.Attach(range);
            range->AddRef();
            ((LPPRIVATE_MOUSESINK)pgs->uPrivate)->hImc  = hImc;
        }
    }

    return hr;
}

HRESULT
CMouseSink::UnadviseMouseSink(
    DWORD dwCookie
    )
{
    if (m_prgMouseSinks == NULL)
        return E_FAIL;

    HRESULT hr;
    LPPRIVATE_MOUSESINK pPrivMouseSink = NULL;

    hr = GenericUnadviseSink(m_prgMouseSinks, 1, dwCookie, (UINT_PTR *)&pPrivMouseSink);
    if (hr == S_OK) {
        if (pPrivMouseSink) {
            delete pPrivMouseSink;
        }
    }

    return hr;
}

LRESULT
CMouseSink::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc
    )
{
    LONG acpStart;
    LONG cch;
    ULONG uRangeEdgeMin;
    ULONG uRangeEdgeMax;
    HRESULT hr;

    /*
     * Find out specified range in whole text's range
     */
    BOOL fEaten = FALSE;

    for (int i = 0; i < m_prgMouseSinks->Count(); i++) {
        GENERICSINK* pgs;
        LPPRIVATE_MOUSESINK pPrivMouseSink;

        pgs = m_prgMouseSinks->GetPtr(i);
        pPrivMouseSink = (LPPRIVATE_MOUSESINK)pgs->uPrivate;

        if ((HIMC)imc != pPrivMouseSink->hImc)
            continue;

        // test: does this sink cover the specified edge?

        pPrivMouseSink->range->GetExtent(&acpStart, &cch);

        uRangeEdgeMin = acpStart;
        uRangeEdgeMax = acpStart + cch;

        //
        // Get GUID_PROP_MSIMTF_READONLY margin.
        //
        hr = EscbReadOnlyPropMargin(imc, &pPrivMouseSink->range, &cch);
        if (SUCCEEDED(hr))
        {
            uEdge += cch;
        }

        if (uEdge < uRangeEdgeMin)
            continue;
        if (uEdge == uRangeEdgeMin && uQuadrant < 2)
            continue;

        if (uEdge > uRangeEdgeMax)
            continue;
        if (uEdge == uRangeEdgeMax && uQuadrant > 1)
            continue;

        //
        // Call OnMouseEvent
        //
        hr = ((ITfMouseSink*)pgs->pSink)->OnMouseEvent(uEdge - uRangeEdgeMin /* adjust uEdge for this range's frame of reference */,
                                                       uQuadrant, dwBtnStatus, &fEaten);

        if (hr == S_OK && fEaten)
            return 1L;

        break; // we already found a covered range, don't bother querying any others
    }

    return IMEMOUSERET_NOTHANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\polytext.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    polytext.h

Abstract:

    This file defines the CPolyText Class.

Author:

Revision History:

Notes:

--*/

#ifndef _POLYTEXT_H_
#define _POLYTEXT_H_

#include "template.h"
#include "imc.h"

class CCompClauseStore
{
public:
    CCompClauseStore()
    {
        m_lpCompClause = NULL;
        m_dwCompClauseLen = 0;
    }
    virtual ~CCompClauseStore()
    {
        ClearString();
    }

    void ClearString()
    {
        if (m_lpCompClause)
        {
            delete m_lpCompClause;
            m_lpCompClause = NULL;
        }
    }


    HRESULT Set(IMCCLock<COMPOSITIONSTRING> &comp)
    {
        LPDWORD lpCompClause = (LPDWORD)comp.GetOffsetPointer(comp->dwCompClauseOffset);
        m_dwCompClauseLen   = comp->dwCompClauseLen / sizeof(DWORD);

        if (m_dwCompClauseLen < 2)
            return E_FAIL;

        ClearString();
        m_lpCompClause = new DWORD[m_dwCompClauseLen + 1];
        if (!m_lpCompClause)
            return E_OUTOFMEMORY;

        Assert(!*lpCompClause);
        // memcpy(m_lpCompClause, (lpCompClause + 1), 
        //        (m_dwCompClauseLen - 1) * sizeof(DWORD));
        memcpy(m_lpCompClause, lpCompClause, 
               m_dwCompClauseLen * sizeof(DWORD));
        Shift(0);
        return S_OK;
    }

    HRESULT Shift(DWORD dwPos)
    {
        DWORD i;
        DWORD dwCur = 0;

        if (!m_lpCompClause)
            return E_FAIL;

        for (i = 0; i < m_dwCompClauseLen; i++) 
        { 
            if (m_lpCompClause[i] > dwPos)
                m_lpCompClause[dwCur++] = m_lpCompClause[i] - dwPos;
        }
        m_lpCompClause[dwCur] = (DWORD)(-1);
        m_dwCompClauseLen = dwCur;
        return S_OK;
    }

    BOOL IsAtFirstBoundary(DWORD dwPos)
    {
        if (!m_lpCompClause)
            return FALSE;

        if (!m_lpCompClause[0])
        {
            Assert(0);
            return FALSE;
        }

        if (m_lpCompClause[0] == dwPos)
            return TRUE;

        return FALSE;
    }

    HRESULT Copy(CCompClauseStore *compclause) 
    {
        m_dwCompClauseLen  = compclause->m_dwCompClauseLen;
        if (m_dwCompClauseLen < 2)
            return E_FAIL;

        ClearString();
        m_lpCompClause = new DWORD[m_dwCompClauseLen + 1];
        if (!m_lpCompClause)
            return E_OUTOFMEMORY;

        Assert(*compclause->m_lpCompClause);
        memcpy(m_lpCompClause, compclause->m_lpCompClause, 
               m_dwCompClauseLen * sizeof(DWORD));
        Shift(0);
        return S_OK;
    }

private:
    LPDWORD m_lpCompClause;
    DWORD m_dwCompClauseLen;
};

class CPolyText
{
public:
    CPolyText() { }
    virtual ~CPolyText() { }

public:
    HRESULT SplitPolyStringAndAttr(IMCLock& imc, HDC hDC, POLYTEXTW poly_text, PBYTE pbAttrPtr, CCompClauseStore *compclause);
    HRESULT SplitPolyStringAndAttr(IMCLock& imc, HDC hDC, POLYTEXTW poly_text);
    HRESULT RemoveLastLine(BOOL fVert);
    HRESULT ShiftPolyText(int dx, int dy);
    HRESULT GetPolyTextExtent(POINT pt, HDC hDC, BOOL  fVert, ULONG *puEdge, ULONG *puQuadrant);
    HRESULT GetPolyTextExtentRect(DWORD &ach, HDC hDC, BOOL fVert, BOOL fGetLastPoint, RECT *prc);

    void RemoveAll()
    {
        m_poly_text.RemoveAll();
        m_TfGuidAtom.RemoveAll();
    }

    INT_PTR GetPolySize() { return m_poly_text.GetSize(); }
    const POLYTEXTW* GetPolyData() const { return m_poly_text.GetData(); }
    POLYTEXTW GetPolyAt(int n) const { return m_poly_text.GetAt(n); }

    INT_PTR GetAttrSize() { return m_TfGuidAtom.GetSize(); }
    const TfGuidAtom* GetAttrData() const { return m_TfGuidAtom.GetData(); }
    TfGuidAtom GetAttrAt(int n) const { return m_TfGuidAtom.GetAt(n); }

private:
    CArray<POLYTEXTW, POLYTEXTW>      m_poly_text;
    CArray<TfGuidAtom, TfGuidAtom>  m_TfGuidAtom;
};

#endif // _POLYTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\polytext.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    polytext.cpp

Abstract:

    This file implements the CPolyText Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "globals.h"
#include "polytext.h"
#include "fontlink.h"

//+---------------------------------------------------------------------------
//
// CPolyText::SplitPolyStringAndAttr
//
//+---------------------------------------------------------------------------

HRESULT
CPolyText::SplitPolyStringAndAttr(
    IMCLock& imc,
    HDC hDC,
    POLYTEXTW poly_text,
    PBYTE pbAttrPtr,
    CCompClauseStore *compclause)
{
    BYTE attr = *pbAttrPtr;
    PBYTE p = pbAttrPtr;
    UINT n = poly_text.n;
    UINT str_len = 0;

    //
    // Find different attribute
    //
    while (n)
    {
        if (compclause->IsAtFirstBoundary(str_len))
        {
            Assert(str_len);
            break;
        }

        --n;
        ++p;
        ++str_len;
    }

    CCompClauseStore compclauseTmp;
    compclauseTmp.Copy(compclause);
    compclauseTmp.Shift(str_len);

    INT_PTR index = m_poly_text.GetSize();

    if (n == 0)
    {
        if (poly_text.n)
        {
            SIZE size;
            FLGetTextExtentPoint32(hDC, poly_text.lpstr, poly_text.n, &size);

            if (!imc.UseVerticalCompWindow())
            {
                poly_text.rcl.right = poly_text.rcl.left + size.cx;
            }
            else
            {
                RotateSize(&size);
                poly_text.rcl.bottom = poly_text.rcl.top + size.cy;
            }
        }

        m_poly_text.SetAtGrow(index, poly_text);
        TfGuidAtom atom = TF_INVALID_GUIDATOM;
        CtfImeGetGuidAtom((HIMC)imc, *pbAttrPtr, &atom);
        m_TfGuidAtom.SetAtGrow(index, atom);
    }
    else
    {
        POLYTEXTW merge_poly = poly_text;

        n = poly_text.n;
        poly_text.n = str_len;

        SIZE size;
        FLGetTextExtentPoint32(hDC, poly_text.lpstr, poly_text.n, &size);

        if (!imc.UseVerticalCompWindow())
        {
            poly_text.rcl.right = poly_text.rcl.left + size.cx;
        }
        else
        {
            RotateSize(&size);
            poly_text.rcl.bottom = poly_text.rcl.top + size.cy;
        }

        m_poly_text.SetAtGrow(index, poly_text);
        TfGuidAtom atom = TF_INVALID_GUIDATOM;
        CtfImeGetGuidAtom((HIMC)imc, *pbAttrPtr, &atom);
        m_TfGuidAtom.SetAtGrow(index, atom);

        if (!imc.UseVerticalCompWindow())
        {
            merge_poly.x         += size.cx;
            merge_poly.rcl.left  += size.cx;
        }
        else
        {
            merge_poly.y         += size.cy;
            merge_poly.rcl.top  += size.cy;
        }
        merge_poly.n     = n - str_len;
        merge_poly.lpstr = poly_text.lpstr + str_len;

        return SplitPolyStringAndAttr(imc, hDC, merge_poly, p, &compclauseTmp);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CPolyText::SplitPolyStringAndAttr
//
//+---------------------------------------------------------------------------

HRESULT
CPolyText::SplitPolyStringAndAttr(
    IMCLock& imc,
    HDC hDC,
    POLYTEXTW poly_text)
{
    INT_PTR index = m_poly_text.GetSize();

    m_poly_text.SetAtGrow(index, poly_text);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CPolyText::RemoveLastLine
//
//+---------------------------------------------------------------------------

HRESULT
CPolyText::RemoveLastLine(BOOL fVert)
{
    INT_PTR n = m_poly_text.GetSize();
    if (n == 0)
    {
        return S_FALSE;
    }

    POLYTEXTW last_poly = m_poly_text.GetAt(n-1);

    //
    // Find the same Y line.
    //
    for (int index = 0; index < n; index++)
    {
        POLYTEXTW poly = m_poly_text.GetAt(index);
        
        if (!fVert && (poly.y == last_poly.y))
            break;
        else if (fVert && (poly.x == last_poly.x))
            break;
    }

    if (index >= n)
    {
        return E_FAIL;
    }

    m_poly_text.RemoveAt(index, (int)(n - index));
    m_TfGuidAtom.RemoveAt(index, (int)(n - index));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CPolyText::ShiftPolyText
//
//+---------------------------------------------------------------------------

HRESULT
CPolyText::ShiftPolyText(int dx, int dy)
{
    INT_PTR n = m_poly_text.GetSize();
    POLYTEXTW *ppoly_text = m_poly_text.GetData();
    INT_PTR i;

    for (i = 0; i < n; i++)
    {
        ppoly_text[i].x += dx;
        ppoly_text[i].y += dy;
        ppoly_text[i].rcl.left   += dx;
        ppoly_text[i].rcl.right  += dx;
        ppoly_text[i].rcl.top    += dy;
        ppoly_text[i].rcl.bottom += dy;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CPolyText::GetPolyTextExtent
//
//+---------------------------------------------------------------------------

HRESULT
CPolyText::GetPolyTextExtent(POINT pt,
                             HDC   hDC,
                             BOOL  fVert,
                             ULONG *puEdge,
                             ULONG *puQuadrant)
{
    INT_PTR n = m_poly_text.GetSize();
    POLYTEXTW *ppoly_text = m_poly_text.GetData();
    INT_PTR i;
    ULONG j;
    DWORD dwCount = 0;

    for (i = 0; i < n; i++)
    {
        if (ppoly_text[i].n && PtInRect(&ppoly_text[i].rcl, pt))
        {
            INT cxPoint;
            SIZE sizePrev = {0};

            if (!fVert)
                cxPoint = pt.x - ppoly_text[i].rcl.left;
            else
                cxPoint = pt.y - ppoly_text[i].rcl.top;

            for (j = 1; j <= ppoly_text[i].n; j++)
            {
                SIZE size;
                FLGetTextExtentPoint32(hDC, 
                                     ppoly_text[i].lpstr, 
                                     j,
                                     &size);
                if (cxPoint < size.cx)
                {
                    DWORD dwOneCharWidth = size.cx - sizePrev.cx;
                    ULONG uOneCharDist = cxPoint - sizePrev.cx;

                    //
                    // Calc Edge. 
                    //
                    *puEdge += dwCount;
                    if (uOneCharDist * 2 > dwOneCharWidth)
                        (*puEdge)++;

                    //
                    // Calc Quadrant. 
                    //
                    if (uOneCharDist)
                        uOneCharDist--;
                    *puQuadrant = ((uOneCharDist * 4 / dwOneCharWidth) + 2) % 4;
                    return S_OK;
                }

                sizePrev = size;
                dwCount++;
            }
        }
        dwCount += ppoly_text[i].n;
    }

    *puEdge += dwCount;
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// CPolyText::GetPolyTextExtentRect
//
//+---------------------------------------------------------------------------

HRESULT
CPolyText::GetPolyTextExtentRect(DWORD &ach,
                                 HDC   hDC,
                                 BOOL  fVert,
                                 BOOL  fGetLastPoint,
                                 RECT  *prc)
{
    INT_PTR n = m_poly_text.GetSize();
    POLYTEXTW *ppoly_text = m_poly_text.GetData();
    INT_PTR i;
    ULONG j;
    DWORD dwCount = 0;

    for (i = 0; i < n; i++)
    {
        BOOL fTry = FALSE;
        if (!fGetLastPoint)
        {
            if ((ach >= dwCount) && (ach < dwCount + ppoly_text[i].n))
                fTry = TRUE;
        }
        else
        {
            if ((ach >= dwCount) && (ach <= dwCount + ppoly_text[i].n))
                fTry = TRUE;
        }
      
        if (fTry)
        {
            SIZE size;
            if (ach - dwCount)
            {
                FLGetTextExtentPoint32(hDC, 
                                      ppoly_text[i].lpstr, 
                                      ach - dwCount,
                                      &size);
            }
            else
            {
                size.cx = 0;
                size.cy = 0;
            }


            if (!fVert)
            {
                prc->left = ppoly_text[i].rcl.left + size.cx;
                prc->right = ppoly_text[i].rcl.left + size.cx;
                prc->top = ppoly_text[i].rcl.top;
                prc->bottom = ppoly_text[i].rcl.bottom;
            }
            else
            {
                prc->left = ppoly_text[i].rcl.left;
                prc->right = ppoly_text[i].rcl.right;
                prc->top = ppoly_text[i].rcl.top + size.cx;
                prc->bottom = ppoly_text[i].rcl.top + size.cx;
            }

            return S_OK;
        }
        dwCount += ppoly_text[i].n;
    }

    ach -= dwCount;
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\profile.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    profile.h

Abstract:

    This file defines the CicProfiles Class.

Author:

Revision History:

Notes:

--*/

#ifndef _PROFILE_H
#define _PROFILE_H

#include "ats.h"
#include "tls.h"
#include "template.h"

class CicProfile : public IUnknown
{
public:
    CicProfile();
    virtual ~CicProfile();

public:
    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    //
    //
    HRESULT InitProfileInstance(TLS* ptls);

    HRESULT Activate(void);

    HRESULT Deactivate(void);

    HRESULT ChangeCurrentKeyboardLayout(HKL hKL);

    HRESULT GetLangId(LANGID *plid);

    HRESULT GetCodePageA(UINT* puCodePage);

    HRESULT GetKeyboardLayout(HKL* phkl);

    HRESULT IsIME(HKL hKL);

    HRESULT GetActiveLanguageProfile(IN HKL hKL,
                                     IN GUID catid,
                                     OUT TF_LANGUAGEPROFILE* pLanguageProfile);

public:
    //
    // Callbacks
    //
    static HRESULT ActiveLanguageProfileNotifySinkCallback(REFGUID rguid, REFGUID rguidProfile, BOOL fActivated, void *pv);

    //
    // Enumrate callbacks
    //
    struct LANG_PROF_ENUM_ARG {
        IN GUID catid;
        OUT TF_LANGUAGEPROFILE LanguageProfile;
    };
    static ENUM_RET LanguageProfilesCallback(TF_LANGUAGEPROFILE  LanguageProfile,
                                             LANG_PROF_ENUM_ARG* pLangProfEnumArg);

private:
    LANGID LangIdFromKL(HKL hKL)
    {
        return LOWORD(hKL);
    }

    void ResetCache(void)
    {
        m_fInitCP     = FALSE;
        m_fInitLangID = FALSE;
        m_fInitHKL    = FALSE;
    }

protected:
    ITfInputProcessorProfiles*          m_profile;
    CActiveLanguageProfileNotifySink*   m_pActiveLanguageProfileNotifySink;

private:
    LANGID  m_SavedLangId;

    BOOL    m_fActivateThread : 1;    // TRUE: Activate this thread.
    BOOL    m_fInitCP         : 1;    // TRUE: initialized CodePage value.
    BOOL    m_fInitLangID     : 1;    // TRUE: initialized LangID value.
    BOOL    m_fInitHKL        : 1;    // TRUE: initialized hKL value.

    UINT    m_cp;
    LANGID  m_LangID;
    HKL     m_hKL;

    long    m_ref;
};

#endif // _PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\private.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    private.h

Abstract:

    This file defines the precompile header.

Author:

Revision History:

Notes:

--*/

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <winuserp.h>
#include <immp.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>

#include <commctrl.h>


#include <debug.h>
#include <limits.h>
#include <initguid.h>

#include <tsattrs.h>

#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h>

#if 0
// New NT5 header
#include "immdev.h"
#endif
#define _IMM_
#define _DDKIMM_H_

#include "msctf.h"
#include "msctfp.h"
#include "aimmp.h"
#include "ico.h"
#include "tes.h"
#include "computil.h"
#include "timsink.h"
#include "sink.h"
#include "immxutil.h"
#include "dispattr.h"
#include "helpers.h"
#include "osver.h"

#include "mem.h"

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof(x)/sizeof(x)[0])
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    ARRAY_SIZE(x)
#endif

//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\profile.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    profile.cpp

Abstract:

    This file implements the CicProfiles Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "profile.h"

//+---------------------------------------------------------------------------
//
// CicProfile::Callbacks
//
//----------------------------------------------------------------------------

HRESULT
CicProfile::ActiveLanguageProfileNotifySinkCallback(
    REFGUID rguid,
    REFGUID rguidProfile,
    BOOL fActivated,
    void *pv)
{
    DebugMsg(TF_FUNC, TEXT("ActiveLanguageProfileNotifySinkCallback"));

    CicProfile* _this = (CicProfile*)pv;

    _this->ResetCache();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicProfile::ctor
// CicProfile::dtor
//
//----------------------------------------------------------------------------

CicProfile::CicProfile()
{
    m_ref = 1;

    m_profile = NULL;
    m_pActiveLanguageProfileNotifySink = NULL;

    m_SavedLangId       = LANG_NEUTRAL;

    m_fActivateThread   = FALSE;
    ResetCache();

    m_cp     = CP_ACP;
    m_LangID = LANG_NEUTRAL;
    m_hKL    = 0;
}

CicProfile::~CicProfile()
{
    if (m_profile) {
        if (m_SavedLangId != LANG_NEUTRAL) {
            HRESULT hr = m_profile->ChangeCurrentLanguage(m_SavedLangId);
            if (FAILED(hr)) {
                DebugMsg(TF_ERROR, TEXT("CicProfile::~CicProfile: failed for ChangeCurrentLanguage"));
            }
        }
        m_profile->Release();
        m_profile = NULL;
    }

    if (m_pActiveLanguageProfileNotifySink) {
        m_pActiveLanguageProfileNotifySink->_Unadvise();
        m_pActiveLanguageProfileNotifySink->Release();
        m_pActiveLanguageProfileNotifySink = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CicProfile::QueryInterface
// CicProfile::AddRef
// CicProfile::Release
//
//----------------------------------------------------------------------------

HRESULT
CicProfile::QueryInterface(
    REFIID riid,
    void** ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG
CicProfile::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CicProfile::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// CicProfile::InitProfileInstance
//
//----------------------------------------------------------------------------

HRESULT
CicProfile::InitProfileInstance(
    TLS* ptls)
{
    HRESULT hr;

    hr = TF_CreateInputProcessorProfiles(&m_profile);

    if (FAILED(hr)) {
        DebugMsg(TF_ERROR, TEXT("CicProfile::InitProfileInstance: failed for CoCreate"));
    }
    else if (m_pActiveLanguageProfileNotifySink == NULL) {
        m_pActiveLanguageProfileNotifySink = new CActiveLanguageProfileNotifySink(CicProfile::ActiveLanguageProfileNotifySinkCallback, this);
        if (m_pActiveLanguageProfileNotifySink == NULL) {
            DebugMsg(TF_ERROR, TEXT("Couldn't create ActiveLanguageProfileNotifySink!"));

            m_profile->Release();
            m_profile = NULL;
            return E_FAIL;
        }

        ITfThreadMgr_P* ptim_P = ptls->GetTIM();
        if (ptim_P != NULL)
        {
            m_pActiveLanguageProfileNotifySink->_Advise(ptim_P);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicProfile::Activate
// CicProfile::Deactivate
//
//----------------------------------------------------------------------------

HRESULT
CicProfile::Activate(void)
{
    m_fActivateThread   = TRUE;
    ResetCache();
    return S_OK;
}

HRESULT
CicProfile::Deactivate(void)
{
    m_fActivateThread   = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicProfile::ChangeCurrentKeyboardLayout
//
//----------------------------------------------------------------------------

HRESULT
CicProfile::ChangeCurrentKeyboardLayout(
    HKL hKL)
{
    HRESULT hr;

    LANGID CurrentLangId;
    hr = m_profile->GetCurrentLanguage(&CurrentLangId);
    if (FAILED(hr)) {
        DebugMsg(TF_ERROR, TEXT("CicProfile::ChangeCurrentKeyboardLayout: failed for GetCurrentLanguage"));
    }
    else if (hKL != NULL) {
        LANGID LangId = LangIdFromKL(hKL);
        if (LangId != CurrentLangId) {
            hr = m_profile->ChangeCurrentLanguage(LangId);
            if (FAILED(hr)) {
                m_SavedLangId = LANG_NEUTRAL;
                DebugMsg(TF_ERROR, TEXT("CicProfile::ChangeCurrentKeyboardLayout: failed for ChangeCurrentLanguage"));
            }
            m_SavedLangId = LangId;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CicProfile::GetLangId
//
//----------------------------------------------------------------------------

HRESULT 
CicProfile::GetLangId(
    LANGID *plid)
{
    if (!m_profile)
        return E_FAIL;

    if (!plid)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if (m_fInitLangID) {
        *plid = m_LangID;
    }
    else {
        *plid = LANG_NEUTRAL;

        hr = m_profile->GetCurrentLanguage(plid);
        if (FAILED(hr)) {
            DebugMsg(TF_ERROR, TEXT("CicProfile::GetLangId: failed for GetCurrentLanguage"));
        }
        else {
            m_LangID = *plid;
            m_fInitLangID = TRUE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicProfile::GetCodePageA
//
//----------------------------------------------------------------------------

HRESULT 
CicProfile::GetCodePageA(
    UINT *puCodePage
    )
{
    if (!puCodePage)
        return E_INVALIDARG;

    if (m_fInitCP) {
        *puCodePage = m_cp;
    }
    else {
        *puCodePage = CP_ACP;

        LANGID langid;
        if (FAILED(GetLangId(&langid)))
            return E_FAIL;

        WCHAR szCodePage[12];
        int ret = GetLocaleInfoW(MAKELCID(langid, SORT_DEFAULT),
                                LOCALE_IDEFAULTANSICODEPAGE,
                                szCodePage,
                                sizeof(szCodePage)/sizeof(WCHAR));
        if (ret) {
            szCodePage[ret] = L'\0';
            *puCodePage = wcstoul(szCodePage, NULL, 10);
            m_cp = *puCodePage;
            m_fInitCP = TRUE;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicProfile::GetKeyboardLayout
//
//----------------------------------------------------------------------------

HRESULT 
CicProfile::GetKeyboardLayout(
    HKL* phkl)
{
    if (! phkl)
        return E_INVALIDARG;

    *phkl = NULL;

    if (m_fInitHKL) {
        *phkl = m_hKL;
    }
    else if (! m_fActivateThread) {
        return E_FAIL;
    }
    else {
        LANGID langid;
        GUID guidProfile;
        HRESULT hr = m_profile->GetActiveLanguageProfile(GUID_TFCAT_TIP_KEYBOARD,
                                                         &langid,
                                                         &guidProfile);
        if (FAILED(hr))
            return hr;

        //
        // Instead of (!IsEqualGUID(guidProfil, GUID_NULL)), we check
        // 2nd, 3r and 4th DWORD of guidProfile. Because
        // GetActivelanguageProfile(category guid) may return hKL in 
        // guidProfile
        //
        if ((((unsigned long *) &guidProfile)[1] != 0) ||
            (((unsigned long *) &guidProfile)[2] != 0) ||
            (((unsigned long *) &guidProfile)[3] != 0)) {
            /*
             * Current keyboard layout is Cicero.
             */
            m_hKL = (HKL)LongToHandle(langid);          // Don't use ::GetKeyboardLayout(0);
                                                        // Cicero awre doesn't case hKL.

        }
        else if (!IsEqualGUID(guidProfile, GUID_NULL)) {
            /*
             * Current keyboard layout is regacy IME.
             */
            m_hKL = (HKL)LongToHandle(*(DWORD *)&guidProfile);
        }
        else {
            m_hKL = 0;
        }

        *phkl = m_hKL;
        m_fInitHKL = TRUE;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicProfile::IsIME
//
//----------------------------------------------------------------------------

HRESULT 
CicProfile::IsIME(
    HKL hKL)
{
    LANGID LangId = LangIdFromKL(hKL);

    Interface<IEnumTfLanguageProfiles> LanguageProfiles;
    HRESULT hr = m_profile->EnumLanguageProfiles(LangId, 
                                                 LanguageProfiles);
    if (FAILED(hr))
        return S_FALSE;

    //
    // AIMM12 compat.
    // we don't set GUID_TFCAT_TIP_KEYBOARD catid to enumerate profiles.
    // so if we have some other TIP than Keyboard TIP, we may return S_OK.
    //

    CEnumrateValue<IEnumTfLanguageProfiles,
                   TF_LANGUAGEPROFILE,
                   LANG_PROF_ENUM_ARG> Enumrate(LanguageProfiles,
                                                LanguageProfilesCallback);

    ENUM_RET ret = Enumrate.DoEnumrate();
    if (ret != ENUM_FIND)
        return S_FALSE;
    else
        return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicProfile::GetActiveLanguageProfile
// CicProfile::LanguageProfilesCallback
//
//----------------------------------------------------------------------------

HRESULT
CicProfile::GetActiveLanguageProfile(
    IN HKL hKL,
    IN GUID catid,
    OUT TF_LANGUAGEPROFILE* pLanguageProfile)
{
    LANGID LangId = LangIdFromKL(hKL);

    Interface<IEnumTfLanguageProfiles> LanguageProfiles;
    HRESULT hr = m_profile->EnumLanguageProfiles(LangId, 
                                                 LanguageProfiles);
    if (FAILED(hr))
        return S_FALSE;

    LANG_PROF_ENUM_ARG LangProfEnumArg;
    LangProfEnumArg.catid = catid;

    CEnumrateValue<IEnumTfLanguageProfiles,
                   TF_LANGUAGEPROFILE,
                   LANG_PROF_ENUM_ARG> Enumrate(LanguageProfiles,
                                                LanguageProfilesCallback,
                                                &LangProfEnumArg);

    ENUM_RET ret = Enumrate.DoEnumrate();
    if (ret != ENUM_FIND || pLanguageProfile == NULL)
        return S_FALSE;
    else {
        *pLanguageProfile = LangProfEnumArg.LanguageProfile;
        return S_OK;
    }
}

ENUM_RET
CicProfile::LanguageProfilesCallback(
    TF_LANGUAGEPROFILE   LanguageProfile,
    LANG_PROF_ENUM_ARG* pLangProfEnumArg)
{
    if (LanguageProfile.fActive &&
        ! IsEqualGUID(LanguageProfile.clsid, GUID_NULL)) {
        if (pLangProfEnumArg) {
            if (! IsEqualGUID(LanguageProfile.catid, pLangProfEnumArg->catid)) {
                return ENUM_CONTINUE;
            }
            pLangProfEnumArg->LanguageProfile = LanguageProfile;
        }
        return ENUM_FIND;
    }

    return ENUM_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\reconvps.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    reconvps.cpp

Abstract:

    This file implements the CReconvertPropStore Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "reconvps.h"

//+---------------------------------------------------------------------------
//
// CReconvertPropStore::IUnknown::QueryInterface
// CReconvertPropStore::IUnknown::AddRef
// CReconvertPropStore::IUnknown::Release
//
//----------------------------------------------------------------------------

HRESULT
CReconvertPropStore::QueryInterface(
    REFIID riid,
    void** ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = static_cast<ITfPropertyStore*>(this);
    }
    else if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }
    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CReconvertPropStore::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CReconvertPropStore::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// CReconvertPropStore::ITfPropertyStore::GetType
//
//----------------------------------------------------------------------------

HRESULT
CReconvertPropStore::GetType(GUID *pguid)
{
    *pguid = m_guid;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CReconvertPropStore::ITfPropertyStore::GetDataType
//
//----------------------------------------------------------------------------

HRESULT
CReconvertPropStore::GetDataType(DWORD *pdwReserved)
{
    if (pdwReserved == NULL)
        return E_INVALIDARG;

    *pdwReserved = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CReconvertPropStore::ITfPropertyStore::GetData
//
//----------------------------------------------------------------------------

HRESULT
CReconvertPropStore::GetData(VARIANT *pvarValue)
{
    if (pvarValue == NULL)
        return E_INVALIDARG;

    *pvarValue = m_var;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\reconvcb.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    reconvcb.h

Abstract:

    This file defines the CStartReconversionNotifySink Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef RECONVCB_H
#define RECONVCB_H

class CicInputContext;

class CStartReconversionNotifySink : public ITfStartReconversionNotifySink
{
public:
    CStartReconversionNotifySink(HIMC hIMC)
    {
        m_cRef = 1;
        m_hIMC = hIMC;
    }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfStartReconversionNotifySink
    //
    STDMETHODIMP StartReconversion();
    STDMETHODIMP EndReconversion();

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:
    long  m_cRef;
    HIMC  m_hIMC;

    ITfContext *_pic;
    DWORD _dwCookie;
};

#endif // RECONVCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\reconvcb.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    reconvcb.cpp

Abstract:

    This file implements the CStartReconversionNotifySink Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "reconvcb.h"
#include "imc.h"
#include "context.h"
#include "tls.h"
#include "profile.h"

//////////////////////////////////////////////////////////////////////////////
//
// CStartReconversionNotifySink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfStartReconversionNotifySink))
    {
        *ppvObj = SAFECAST(this, CStartReconversionNotifySink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CStartReconversionNotifySink::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CStartReconversionNotifySink::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// CStartReconversionNotifySink::Advise
//
//----------------------------------------------------------------------------

HRESULT CStartReconversionNotifySink::_Advise(ITfContext *pic)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfStartReconversionNotifySink, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CStartReconversionNotifySink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CStartReconversionNotifySink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// StartReconversionNotifySink::StartReconversion
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::StartReconversion()
{
    DebugMsg(TF_FUNC, TEXT("CStartReconversionNotifySink::StartReconversion"));

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CStartReconversionNotifySink::StartReconversion. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CStartReconversionNotifySink::StartReconversion. ptim_P==NULL."));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    IMCLock imc(m_hIMC);
    if (FAILED(hr = imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CStartReconversionNotifySink::StartReconversion. imc==NULL."));
        return hr;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CStartReconversionNotifySink::StartReconversion. imc_ctfime==NULL."));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CStartReconversionNotifySink::StartReconversion. _pCicCotext==NULL."));
        return E_FAIL;
    }

    UINT cp = CP_ACP;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CStartReconversionNotifySink::StartReconversion. _pProfile==NULL."));
        return E_FAIL;
    }

    _pProfile->GetCodePageA(&cp);

    return _pCicContext->SetupReconvertString(imc, ptim_P, cp, 0, FALSE);
}

//+---------------------------------------------------------------------------
//
// StartReconversionNotifySink::EndReconversion
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::EndReconversion()
{
    HRESULT hr;
    IMCLock imc(m_hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr = imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    return _pCicContext->EndReconvertString(imc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\reconv.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    reconv.cpp

Abstract:

    This file implements part of Reconversion in the CicInputContext Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "context.h"
#include "ctxtcomp.h"
#include "delay.h"


//+---------------------------------------------------------------------------
//
// CicInputContext::SetupReconvertString
//
//
// Setup reconversion string
//
// This function called from
//   1. CFnDocFeed::StartReconvert
//   2. CStartReconversionNotifySink::StartReconversion
//   3. CIMEUIWindowHandler::ImeUIMsImeHandler(WM_MSIME_RECONVERTREQUEST)
//
// If Cicero's text store were not cleared, then compositioning and unessential query
// RECONVERTSTRING to apprication. Also edit session (ImmIfReconvertString::ReconvertString)
// doesn't set RECONVERTSTRING text string to hIMC's text store.
//
//----------------------------------------------------------------------------

HRESULT
CicInputContext::SetupReconvertString(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,
    UINT  cp,
    UINT  uPrivMsg,       // is WM_MSIME_RECONVERTREQUEST or 0
    BOOL  fUndoComposition)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::SetupReconvertString"));

    m_fInReconvertEditSession.SetFlag();

    if (m_fStartComposition.IsSetFlag())
        return _ReconvertStringTextStore(imc, ptim_P, uPrivMsg);
    else
        return _ReconvertStringNegotiation(imc, ptim_P, cp, uPrivMsg, fUndoComposition);
}

//+---------------------------------------------------------------------------
//
// CicInputContext::EndReconvertString
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::EndReconvertString(
    IMCLock& imc)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::EndReconvertString"));

    m_fInReconvertEditSession.ResetFlag();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::_ReconvertStringNegotiation
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::_ReconvertStringNegotiation(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,
    UINT  cp,
    UINT  uPrivMsg,
    BOOL fUndoComposition)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::_ReconvertStringNegotiation"));

    RECONVERTSTRING *pReconv = NULL;
    HRESULT hr = E_FAIL;
    int nSize;

    UINT uReconvMsg = uPrivMsg != 0 ? uPrivMsg : WM_IME_REQUEST;

    Assert(IsWindow(imc->hWnd));

    //
    // We don't have to do "VK_BACK" hack for UndoComposition under AIMM12 
    // applications.
    //
    if (!fUndoComposition || MsimtfIsWindowFiltered(imc->hWnd)) 
    {
        nSize = (int)SendMessageW(imc->hWnd,  uReconvMsg, IMR_RECONVERTSTRING, NULL);
        if (!nSize)
        {
            return S_OK;
        }
    
        pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
        if (!pReconv)
        {
            return E_OUTOFMEMORY;
        }
    
        pReconv->dwSize = nSize;
    
        //
        // #480459
        //
        // Hanako11 may change the focus by showing MessageBox during 
        // this SendMessageW(). We need to save the current focus 
        // dim now. So Internal_QueryReconvertString() won't break the
        // current focus dim. Internal_QueryReconvertString() save the current
        // focus dim in there to work with temp DIM.
        //
        Interface<ITfDocumentMgr> priv_dim;
        if (FAILED(hr = ptim_P->GetFocus(priv_dim)))
        {
            return hr;
        }
    
        hr = S_OK;
    
        if (SendMessageW(imc->hWnd, uReconvMsg, IMR_RECONVERTSTRING, (LPARAM)pReconv) ||
            (uPrivMsg != 0 && pReconv->dwCompStrLen > 0))
        {
            //
            // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
            // Any string data doesn't convert between ASCII <--> Unicode.
            // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
            // If ASCII wnd proc, then returns ASCII string.
            // Otherwise if Unicode wnd proc, returns Unicode string.
            //
            BOOL fNeedAW = ( !(IsWindowUnicode(imc->hWnd)) && uPrivMsg == 0);
    
            //
            // backup RECOVNERTSTRING in case IMR_CONFIRMCONVERTSTRING fails.
            //
            RECONVERTSTRING rsBackUp;
            memcpy(&rsBackUp, pReconv, sizeof(RECONVERTSTRING));
    
            // AdjustZeroCompLenReconvertString(pReconv, cp, fNeedAW);
            hr = Internal_QueryReconvertString(imc, ptim_P, pReconv, cp, fNeedAW);
            if (FAILED(hr))
                goto Exit;
    
            if (!SendMessageW(imc->hWnd, uReconvMsg, IMR_CONFIRMRECONVERTSTRING, (LPARAM)pReconv))
            {
                memcpy(pReconv, &rsBackUp, sizeof(RECONVERTSTRING));
            }
    
    
    
            CWReconvertString wReconvStr(imc,
                                         !fNeedAW ? pReconv : NULL,
                                         !fNeedAW ? nSize : 0);
            if (fNeedAW)
            {
                //
                // convert Ansi to Unicode.
                //
                CBReconvertString bReconvStr(imc, pReconv, nSize);
                bReconvStr.SetCodePage(cp);
                wReconvStr = bReconvStr;
            }
            hr = MakeReconversionFuncCall(imc, ptim_P, wReconvStr, (uPrivMsg != 0));
        }

        ptim_P->SetFocus(priv_dim);
    }
    else
    {

        //
        // release control and shift keys. So the application can handle
        // VK_BACK corectly.
        //
        if (GetKeyState(VK_CONTROL) & 0x8000)
            keybd_event((BYTE)VK_CONTROL, (BYTE)0, KEYEVENTF_KEYUP, 0);

        if (GetKeyState(VK_SHIFT) & 0x8000)
            keybd_event((BYTE)VK_SHIFT, (BYTE)0, KEYEVENTF_KEYUP, 0);

        //
        // Generate VK_BACK key events.
        //
        int i;
        for (i = 0; i < m_PrevResultStr.GetSize(); i++)
        {
            keybd_event((BYTE)VK_BACK, (BYTE)0, 0, 0);
            keybd_event((BYTE)VK_BACK, (BYTE)0, KEYEVENTF_KEYUP, 0);
        }

        //
        // SendMessage() to start a timer for DelayedReconvertFuncCall.
        //
        HWND hDefImeWnd;
        if (IsWindow(hDefImeWnd=ImmGetDefaultIMEWnd(NULL)))
            SendMessage(hDefImeWnd, 
                        WM_IME_NOTIFY, 
                        IMN_PRIVATE_DELAYRECONVERTFUNCCALL, 
                        0);

    }

Exit:

    if (pReconv)
        cicMemFree(pReconv);

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::DelayedReconversionFuncCall
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::DelayedReconvertFuncCall(IMCLock &imc)
{
    RECONVERTSTRING *pReconv;
    HRESULT hr;
    int nSize;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::UndoReconvertFuncCall. ptls==NULL."));
        return S_FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::UndoReconvertFuncCall. ptim_P==NULL"));
        return S_FALSE;
    }

    ptim_P->RequestPostponedLock(GetInputContext());

    nSize = sizeof(RECONVERTSTRING);
    nSize += (m_PrevResultStr.GetSize() + 1) * sizeof(WCHAR);
    pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
    if (!pReconv)
    {
        return E_OUTOFMEMORY;
    }

    pReconv->dwSize = (DWORD)nSize;
    pReconv->dwVersion = 1;
    pReconv->dwStrLen = 
    pReconv->dwCompStrLen = 
    pReconv->dwTargetStrLen = (DWORD)m_PrevResultStr.GetSize();
    pReconv->dwStrOffset =  sizeof(RECONVERTSTRING);
    pReconv->dwCompStrOffset = 
    pReconv->dwTargetStrOffset = 0;
    memcpy(((BYTE *)pReconv) + sizeof(RECONVERTSTRING),
           (void *)m_PrevResultStr,
           m_PrevResultStr.GetSize() * sizeof(WCHAR));

    CWReconvertString wReconvStr(imc, pReconv, nSize);

    BOOL fInReconvertEditSession;
    fInReconvertEditSession = m_fInReconvertEditSession.IsSetFlag();

    if (!fInReconvertEditSession)
        m_fInReconvertEditSession.SetFlag();

    hr = MakeReconversionFuncCall(imc, ptim_P, wReconvStr, TRUE);

    if (!fInReconvertEditSession)
        m_fInReconvertEditSession.ResetFlag();

    if (pReconv)
        cicMemFree(pReconv);

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::MakeReconversionFuncCall
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::MakeReconversionFuncCall(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,
    CWReconvertString &wReconvStr,
    BOOL fCallFunc)
{

    HRESULT hr;

    Interface<ITfRange> Selection;
    hr = EscbReconvertString(imc, &wReconvStr, &Selection, FALSE);
    if (S_OK == hr && fCallFunc)
    {
        Interface<ITfFunctionProvider> FuncProv;
        Interface<ITfFnReconversion> Reconversion;
        hr = ptim_P->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
        if (S_OK == hr)
        {

            hr = FuncProv->GetFunction(GUID_NULL,
                           IID_ITfFnReconversion,
                           (IUnknown**)(ITfFnReconversion**)Reconversion);
        }
        if (S_OK == hr) {
            Interface<ITfRange> RangeNew;
            BOOL fConvertable;
            hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
            if (SUCCEEDED(hr) && fConvertable) {
                hr = Reconversion->Reconvert(RangeNew);
            }
            else {
                EscbCompComplete(imc);
            }
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::_ReconvertStringTextStore
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::_ReconvertStringTextStore(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,
    UINT  uPrivMsg)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::_ReconvertStringTextStore"));

    //
    // Clear DocFeed buffer
    //
    EscbClearDocFeedBuffer(imc);

    if (uPrivMsg != 0) {
        HRESULT hr;
        Interface<ITfRange> Selection;
        hr = EscbGetSelection(imc, &Selection);
        if (S_OK == hr)
        {
            Interface<ITfFunctionProvider> FuncProv;
            Interface<ITfFnReconversion> Reconversion;
            hr = ptim_P->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
            if (S_OK == hr)
            {
                hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
            }
            if (S_OK == hr) {
                Interface<ITfRange> RangeNew;
                BOOL fConvertable;
                hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                if (SUCCEEDED(hr) && fConvertable) {
                    hr = Reconversion->Reconvert(RangeNew);
                }
                else {
                    EscbCompComplete(imc);
                    return E_FAIL;
                }
            }
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::Internal_QueryReconvertString_ICOwnerSink
//
//+---------------------------------------------------------------------------

// static
HRESULT
CicInputContext::Internal_QueryReconvertString_ICOwnerSink(
    UINT uCode,
    ICOARGS *pargs,
    VOID *pv)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::Internal_QueryReconvertString_ICOwnerSink"));

    switch (uCode)
    {
        case ICO_STATUS:
            pargs->status.pdcs->dwDynamicFlags = 0;
            pargs->status.pdcs->dwStaticFlags = TF_SS_TRANSITORY;
            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::Internal_QueryReconvertString
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::Internal_QueryReconvertString(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,        // using private for RequestPostponedLock
    RECONVERTSTRING *pReconv,
    UINT cp,
    BOOL fNeedAW)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::Internal_QueryReconvertString"));

    HRESULT hr;

    CWReconvertString wReconvStr(imc,
                                 !fNeedAW ? pReconv : NULL,
                                 !fNeedAW ? pReconv->dwSize : 0);
    if (fNeedAW)
    {
        //
        // convert Ansi to Unicode.
        //
        CBReconvertString bReconvStr(imc, pReconv, pReconv->dwSize);
        bReconvStr.SetCodePage(cp);
        wReconvStr = bReconvStr;
    }

    //
    // Create document manager.
    //
    Interface<ITfDocumentMgr> pdim;           // Document Manager
    if (FAILED(hr = ptim_P->CreateDocumentMgr(pdim)))
        return hr;

    //
    // Create input context
    //
    Interface<ITfContext> pic;                // Input Context
    TfEditCookie ecTmp;
    hr = pdim->CreateContext(m_tid, 0, NULL, pic, &ecTmp);
    if (FAILED(hr))
        return hr;

    //
    // associate CicInputContext in PIC.
    //
    Interface<IUnknown> punk;
    if (SUCCEEDED(QueryInterface(IID_IUnknown, punk))) {
        SetCompartmentUnknown(m_tid, pic, 
                              GUID_COMPARTMENT_CTFIME_CICINPUTCONTEXT,
                              punk);
    }

    //
    // Create Input Context Owner Callback
    //
    CInputContextOwner *_pICOwnerSink;          // IC owner call back

    _pICOwnerSink = new CInputContextOwner(Internal_QueryReconvertString_ICOwnerSink, NULL);
    if (_pICOwnerSink == NULL) {
        DebugMsg(TF_ERROR, TEXT("Couldn't create ICOwnerSink tim!"));
        Assert(0); // couldn't activate thread!
        return E_FAIL;
    }

    //
    // Advise IC.
    //
    _pICOwnerSink->_Advise(pic);

    //
    // Push IC.
    //
    hr = pdim->Push(pic);
    if (SUCCEEDED(hr)) {

        Interface<ITfDocumentMgr> priv_dim;
        if (SUCCEEDED(hr=ptim_P->GetFocus(priv_dim)) &&
            SUCCEEDED(hr=ptim_P->SetFocus(pdim)))
        {
            Interface_Attach<ITfContext> _pic(pic);
            Interface<ITfRange> Selection;
            hr = EscbQueryReconvertString(imc, _pic, &wReconvStr, &Selection);
            if (S_OK == hr)
            {
                Interface<ITfFunctionProvider> FuncProv;
                Interface<ITfFnReconversion> Reconversion;
                hr = ptim_P->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
                if (S_OK == hr)
                {
                    hr = FuncProv->GetFunction(GUID_NULL,
                                   IID_ITfFnReconversion,
                                   (IUnknown**)(ITfFnReconversion**)Reconversion);
                }
                if (S_OK == hr) {
                    Interface<ITfRange> RangeNew;
                    BOOL fConvertable;
                    hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                    if (SUCCEEDED(hr) && fConvertable) {
                        //
                        // Calcurate start position of RangeNew on text store
                        //
                        hr = EscbCalcRangePos(imc, _pic, &wReconvStr, &RangeNew);
                    }
                    else {
                        hr = E_FAIL;
                    }
                }
            }
        }

        if (S_OK == hr)
        {
            if (fNeedAW) {
                //
                // Back to convert Unicode to Ansi.
                //
                CBReconvertString bReconvStr(imc, NULL, 0);
                wReconvStr.SetCodePage(cp);
                bReconvStr = wReconvStr;

                bReconvStr.ReadCompData(pReconv, pReconv->dwSize);
            }
            else {
                wReconvStr.ReadCompData(pReconv, pReconv->dwSize);
            }
        }

        ptim_P->SetFocus(priv_dim);

        ptim_P->RequestPostponedLock(pic);
        ptim_P->RequestPostponedLock(GetInputContext());

        pdim->Pop(TF_POPF_ALL);

        //
        // un-associate CicInputContext in PIC.
        //
        Interface<IUnknown> punk;
        if (SUCCEEDED(QueryInterface(IID_IUnknown, punk))) {
            ClearCompartment(m_tid, pic, 
                             GUID_COMPARTMENT_CTFIME_CICINPUTCONTEXT,
                             FALSE);
        }
    }
    // ic owner is auto unadvised during the Pop by cicero
    // in any case, it must not be unadvised before the pop
    // since it will be used to handle mouse sinks, etc.
    if (_pICOwnerSink) {
        _pICOwnerSink->_Unadvise();
        _pICOwnerSink->Release();
        _pICOwnerSink = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::Internal_ReconvertString
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::Internal_ReconvertString(
    IMCLock& imc,
    ITfThreadMgr_P* ptim_P,
    CWReconvertString& wReconvStr,
    CWReconvertString& wReconvReadStr)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::Internal_ResonvertString"));

    m_fInReconvertEditSession.SetFlag();

    Interface<ITfRange> Selection;
    Interface<ITfFunctionProvider> FuncProv;
    Interface<ITfFnReconversion> Reconversion;


    HRESULT hr;
    hr = EscbReconvertString(imc, &wReconvStr, &Selection, FALSE);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::Internal_ResonvertString. EscbReconvertString fail."));
        goto Exit;
    }

    hr = ptim_P->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
    if (FAILED(hr))
    {
        DebugMsg(TF_ERROR, TEXT("CicInputContext::Internal_ResonvertString. FuncProv==NULL"));
        goto Exit;
    }

    hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
    if (SUCCEEDED(hr)) {
        Interface<ITfRange> RangeNew;
        BOOL fConvertable;
        hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
        if (SUCCEEDED(hr) && fConvertable) {
            hr = Reconversion->Reconvert(RangeNew);
        }
        else {
            DebugMsg(TF_ERROR, TEXT("CicInputContext::Internal_ReconvertString: QueryRange failed so the compoisiton stri ng will be completed."));
            EscbCompComplete(imc);
            hr = E_FAIL;
        }
    }

Exit:
    m_fInReconvertEditSession.ResetFlag();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CicInputContext::Internal_SetCompositionString
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::Internal_SetCompositionString(
    IMCLock& imc,
    CWCompString& wCompStr,
    CWCompString& wCompReadStr)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::Internal_SetCompositionString"));

    HRESULT hr;
    hr = EscbReplaceWholeText(imc, &wCompStr);
    if (FAILED(hr))
        return hr;

    return EscbUpdateCompositionString(imc);
}

//+---------------------------------------------------------------------------
//
// CicInputContext::SetupDocFeedString
//
//+---------------------------------------------------------------------------

HRESULT
CicInputContext::SetupDocFeedString(
    IMCLock& imc,
    UINT cp)
{
    DebugMsg(TF_FUNC, TEXT("CicInputContext::SetupDocFeedString"));

    RECONVERTSTRING *pReconv = NULL;
    HRESULT hr = E_FAIL;
    int nSize;

    Assert(IsWindow(imc->hWnd));

    nSize = (int)SendMessageW(imc->hWnd, WM_IME_REQUEST, IMR_DOCUMENTFEED, NULL);
    if (!nSize)
    {
        return S_OK;
    }

    pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
    if (!pReconv)
    {
        return E_OUTOFMEMORY;
    }

    if (SendMessageW(imc->hWnd, WM_IME_REQUEST, IMR_DOCUMENTFEED, (LPARAM)pReconv))
    {
        Interface<ITfRange> Selection;

        //
        // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
        // Any string data doesn't convert between ASCII <--> Unicode.
        // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
        // If ASCII wnd proc, then returns ASCII string.
        // Otherwise if Unicode wnd proc, returns Unicode string.
        //
        BOOL fNeedAW = !(IsWindowUnicode(imc->hWnd));

        CWReconvertString wReconvStr(imc,
                                     !fNeedAW ? pReconv : NULL,
                                     !fNeedAW ? nSize : 0);
        if (fNeedAW)
        {
            //
            // convert Ansi to Unicode.
            //
            CBReconvertString bReconvStr(imc, pReconv, nSize);
            bReconvStr.SetCodePage(cp);
            wReconvStr = bReconvStr;
        }

        hr = EscbReconvertString(imc, &wReconvStr, &Selection, TRUE);
    }

    if (pReconv)
        cicMemFree(pReconv);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\reconvps.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    reconvps.h

Abstract:

    This file defines the CReconvertPropStore Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef RECONVPS_H
#define RECONVPS_H

class CReconvertPropStore : public ITfPropertyStore
{
public:
    CReconvertPropStore(const GUID guid, VARTYPE vt, long lVal) : m_guid(guid)
    {
        QuickVariantInit(&m_var);

        m_var.vt   = vt;
        m_var.lVal = lVal;

        m_ref = 1;
    }
    virtual ~CReconvertPropStore() { }

    bool Valid()   { return true; }
    bool Invalid() { return ! Valid(); }

    //
    // IUnknown methods
    //
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfPropertyStore methods
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
    {
        *pfAccept = FALSE;
        return S_OK;;
    }
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree)
    {
        *pfFree = TRUE;
        return S_OK;
    }
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
    {
        *ppPropStore = NULL;
        return S_OK;
    }
    //
    // ITfPropertyStore methods (not implementation)
    //
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb)
    {
        return E_NOTIMPL;
    }

    //
    // ref count.
    //
private:
    long   m_ref;

    //
    // property GUID.
    //
    const GUID m_guid;

    //
    // property value.
    //
    VARIANT m_var;
};

#endif // RECONVPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\resource.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file defines the windows resources.

Author:

Revision History:

Notes:

--*/



#define IDIC_IME_ICON                   0x0100
#define IDIC_ENTER_ICON                 0x0101

#define IDS_ENTER_BTN_TEXT              0x0200
#define IDS_ENTER_BTN_TOOLTIP           0x0201
#define IDS_FUNCPRV_CONVERSION          0x0202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\tls.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    tls.cpp

Abstract:

    This file implements the TLS.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "tls.h"
#include "cic.h"
#include "profile.h"

// static
BOOL TLS::InternalDestroyTLS()
{
    if (dwTLSIndex == TLS_OUT_OF_INDEXES)
        return FALSE;

    TLS* ptls = (TLS*)TlsGetValue(dwTLSIndex);
    if (ptls != NULL)
    {
        if (ptls->pCicBridge)
            ptls->pCicBridge->Release();
        if (ptls->pCicProfile)
            ptls->pCicProfile->Release();
        if (ptls->ptim)
            ptls->ptim->Release();
        cicMemFree(ptls);
        TlsSetValue(dwTLSIndex, NULL);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\setmode.h ===
#ifndef __SETMODE_H__

#define __SETMODE_H__
#include "imm.h"

#include "msime.h"
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#define SZ_IMM32                TEXT("imm32.dll")

// Additional modebias bits definition
#ifndef MODEBIASMODE_DIGIT
#define MODEBIASMODE_DIGIT					0x00000004	// ANSI-Digit Recommended Mode
#endif
#ifndef MODEBIASMODE_URLHISTORY
#define MODEBIASMODE_URLHISTORY             0x00010000  // URL history
#endif


inline void SetModeBias(DWORD dwMode)
{
    typedef HWND (WINAPI *FNIMMGETDEFAULTIMEWND)(HWND);
    HMODULE hmod = GetModuleHandle(SZ_IMM32);
    if (hmod)
    {
        FNIMMGETDEFAULTIMEWND lpfn = (FNIMMGETDEFAULTIMEWND)GetProcAddress(hmod, "ImmGetDefaultIMEWnd");
        UINT uiMsg= RegisterWindowMessage( RWM_MODEBIAS );
        if (uiMsg > 0 && lpfn)
        {
            HWND hwnd = (lpfn)(NULL);
            SendMessage(hwnd, uiMsg, MODEBIAS_SETVALUE, dwMode);
        }
    }
}

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\toggle.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    toggle.h

Abstract:

    This file defines the CToggle Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TOGGLE_H_
#define _TOGGLE_H_

class CToggle
{
public:
    CToggle()       { m_flag = FALSE; }

    BOOL Toggle()   { return m_flag = ! m_flag; }
    BOOL IsOn()     { return m_flag; }

private:
    BOOL    m_flag : 1;
};

#endif // _TOGGLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\tls.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    tls.h

Abstract:

    This file defines the TLS.

Author:

Revision History:

Notes:

--*/

#ifndef _TLS_H_
#define _TLS_H_

#include "boolean.h"
#include "cregkey.h"
#include "globals.h"
const TCHAR c_szKeyCUAS[] = TEXT("SOFTWARE\\Microsoft\\CTF\\CUAS");
const TCHAR c_szNonEAComposition[] = TEXT("NonEAComposition");
const DWORD c_dwDisabled = 1;
const DWORD c_dwEnabled  = 2;

class CicBridge;
class CicProfile;

class TLS
{
public:
    static inline BOOL Initialize()
    {
        dwTLSIndex = TlsAlloc();
        if (dwTLSIndex == TLS_OUT_OF_INDEXES)
            return FALSE;

        return TRUE;
    }

    static inline void Uninitialize()
    {
        if (dwTLSIndex != TLS_OUT_OF_INDEXES)
        {
            TlsFree(dwTLSIndex);
            dwTLSIndex = TLS_OUT_OF_INDEXES;
        }
    }

    static inline TLS* GetTLS()
    {
        //
        // Should allocate TLS data if doesn't exist.
        //
        return InternalAllocateTLS();
    }

    static inline TLS* ReferenceTLS()
    {
        //
        // Shouldn't allocate TLS data even TLS data doesn't exist.
        //
        return (TLS*)TlsGetValue(dwTLSIndex);
    }

    static inline BOOL DestroyTLS()
    {
        return InternalDestroyTLS();
    }

    inline DWORD GetSystemInfoFlags()
    {
        return dwSystemInfoFlags;
    }

    inline VOID SetSystemInfoFlags(DWORD dw)
    {
        dwSystemInfoFlags = dw;
    }

    inline CicBridge* GetCicBridge()
    {
        return pCicBridge;
    }

    inline VOID SetCicBridge(CicBridge* pv)
    {
        pCicBridge = pv;
    }

    inline CicProfile* GetCicProfile()
    {
        return pCicProfile;
    }

    inline VOID SetCicProfile(CicProfile* pv)
    {
        pCicProfile = pv;
    }

    inline ITfThreadMgr_P* GetTIM()
    {
        return ptim;
    }

    inline VOID SetTIM(ITfThreadMgr_P* pv)
    {
        ptim = pv;
    }

    inline BOOL IsCTFAware()
    {
        return CTFAware.IsSetFlag();
    }

    inline BOOL IsCTFUnaware()
    {
        return CTFAware.IsResetFlag();
    }

    inline VOID SetCTFAware()
    {
        CTFAware.SetFlag();
    }

    inline VOID ResetCTFAware()
    {
        CTFAware.ResetFlag();
    }

    inline BOOL IsAIMMAware()
    {
        return AIMMAware.IsSetFlag();
    }

    inline VOID SetAIMMAware()
    {
        AIMMAware.SetFlag();
    }

    inline VOID ResetAIMMAware()
    {
        AIMMAware.ResetFlag();
    }

    inline BOOL IsEnabledKeystrokeFeed()
    {
        return EnabledKeystrokeFeed.IsSetFlag();
    }

    inline VOID SetEnabledKeystrokeFeed()
    {
        EnabledKeystrokeFeed.SetFlag();
    }

    inline VOID ResetEnabledKeystrokeFeed()
    {
        EnabledKeystrokeFeed.ResetFlag();
    }

    inline VOID SetDeactivatedOnce()
    {
        DeactivatedOnce.SetFlag();
    }

    inline BOOL IsDeactivatedOnce()
    {
        return DeactivatedOnce.IsSetFlag();
    }

    inline BOOL NonEACompositionEnabled()
    {
        if (!dwNonEAComposition)
        {
            CMyRegKey regkey;
            DWORD dw;
            
            if (S_OK != regkey.Open(HKEY_CURRENT_USER, c_szKeyCUAS, KEY_READ) ||
                S_OK != regkey.QueryValue(dw, c_szNonEAComposition))
            {
                   dw  = c_dwDisabled;
            }
            dwNonEAComposition = dw;  // dw == 1 disabled, 2 enabled
        }
        return dwNonEAComposition == c_dwEnabled;
    }


private:
    DWORD           dwSystemInfoFlags;
    CicBridge*      pCicBridge;
    CicProfile*     pCicProfile;
    ITfThreadMgr_P* ptim;
    CBoolean        CTFAware;
    CBoolean        AIMMAware;
    CBoolean        EnabledKeystrokeFeed;
    CBoolean        DeactivatedOnce;
    DWORD           dwNonEAComposition;

private:
    static inline TLS* InternalAllocateTLS()
    {
        TLS* ptls = (TLS*)TlsGetValue(dwTLSIndex);
        if (ptls == NULL)
        {
            if (DllShutDownInProgress())
                return NULL;

            if ((ptls = (TLS*)cicMemAllocClear(sizeof(TLS))) == NULL)
                return NULL;

            if (! TlsSetValue(dwTLSIndex, ptls))
            {
                cicMemFree(ptls);
                return NULL;
            }

            //
            // Set Inital value
            //
            ptls->SetCTFAware();    // Set CTFAware
            ptls->SetEnabledKeystrokeFeed();
        }
        return ptls;
    }

    static BOOL InternalDestroyTLS();

private:
    static DWORD dwTLSIndex;
};

#endif // _TLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\tmgrevcb.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    tmgrevcb.cpp

Abstract:

    This file implements the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "tmgrevcb.h"
#include "imc.h"
#include "tls.h"
#include "cic.h"
#include "delay.h"

// static
HRESULT
CThreadMgrEventSink_DIMCallBack::DIMCallback(
    UINT uCode,
    ITfDocumentMgr* dim,
    ITfDocumentMgr* dim_prev,
    void* pv)
{
    DebugMsg(TF_FUNC, TEXT("CThreadMgrEventSink_DIMCallBack"));

    HRESULT hr = S_OK;

    switch (uCode) {
        case TIM_CODE_INITDIM:
        case TIM_CODE_UNINITDIM:
           break;

        case TIM_CODE_SETFOCUS:
            {
                TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                                  // DllMain -> ImeDestroy -> DeactivateIMMX -> Deactivate
                if (ptls == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CThreadMgrEventSink_DIMCallBack::DIMCallback. TLS==NULL"));
                    return E_FAIL;
                }

                CicBridge::CTFDetection(ptls, dim);
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\tmgrevcb.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    tmgrevcb.h

Abstract:

    This file defines the CThreadMgrEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TMGREVCB_H_
#define _TMGREVCB_H_

#include "template.h"
#include "tls.h"
#include "context.h"

class CicBridge;

class CThreadMgrEventSink_DIMCallBack : public CThreadMgrEventSink
{
public:
    CThreadMgrEventSink_DIMCallBack() : CThreadMgrEventSink(DIMCallback, NULL, NULL) {};

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // DIM Callback
    //
private:
    static HRESULT DIMCallback(UINT uCode, ITfDocumentMgr* dim, ITfDocumentMgr* dim_prev, void* pv);

    struct DETECT_PARAM
    {
        DETECT_PARAM(TLS* ptls, ITfDocumentMgr* dim, ITfConfigureSystemKeystrokeFeed* cskf, CicBridge* cic) : m_ptls(ptls), m_dim(dim), m_cskf(cskf), m_cic(cic) {}
        virtual ~DETECT_PARAM() {}

        TLS*                             m_ptls;
        ITfDocumentMgr*                  m_dim;
        ITfConfigureSystemKeystrokeFeed* m_cskf;
        CicBridge*                       m_cic;
    };
};

#endif // _TMGREVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\txtevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    txtevcb.cpp

Abstract:

    This file implements the CTextEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "txtevcb.h"
#include "ime.h"
#include "editses.h"
#include "context.h"
#include "profile.h"


// from ctf\sapilayr\globals.cpp
const GUID GUID_ATTR_SAPI_GREENBAR = {
    0xc3a9e2e8,
    0x738c,
    0x48e0,
    {0xac, 0xc8, 0x43, 0xee, 0xfa, 0xbf, 0x83, 0xc8}
};

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::_IsSapiFeedbackUIPresent
//
//----------------------------------------------------------------------------

BOOL CTextEventSinkCallBack::_IsSapiFeedbackUIPresent(
    Interface_Attach<ITfContext>& ic,
    TESENDEDIT *ee
    )
{
    EnumPropertyArgs args;

    args.comp_guid = GUID_ATTR_SAPI_GREENBAR;
    if (FAILED(ic->GetProperty(GUID_PROP_ATTRIBUTE, args.Property)))
        return FALSE;

    Interface<IEnumTfRanges> EnumReadOnlyProperty;
    if (FAILED(args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL)))
        return FALSE;

    args.ec = ee->ecReadOnly;
    args.pLibTLS = m_pLibTLS;

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                   EnumPropertyCallback,
                                                   &args);        // Argument of callback func.
    ENUM_RET ret_prop_attribute = Enumrate.DoEnumrate();
    if (ret_prop_attribute == ENUM_FIND)
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::_IsComposingPresent
//
//----------------------------------------------------------------------------

BOOL CTextEventSinkCallBack::_IsComposingPresent(
    Interface_Attach<ITfContext>& ic,
    TESENDEDIT *ee
    )
{
    /*
     * This is automatic detection code of the Hangul + alphanumeric input
     * If detected a Hangul + alphanumeric, then we finalized all text.
     */

    EnumTrackPropertyArgs args;

    const GUID *guids[] = {&GUID_PROP_COMPOSING,
                           &GUID_PROP_MSIMTF_PREPARE_RECONVERT};
    const int guid_size = sizeof(guids) / sizeof(GUID*);

    args.guids     = (GUID**)guids;
    args.num_guids = guid_size;

    if (FAILED(ic->TrackProperties(guids, args.num_guids,  // system property
                                   NULL, 0,                // application property
                                   args.Property)))
        return FALSE;

    //
    // get the text range that does not include read only area for 
    // reconversion.
    //
    Interface<ITfRange> rangeAllText;
    LONG cch;
    if (FAILED(ImmIfEditSessionCallBack::GetAllTextRange(ee->ecReadOnly, 
                                                         ic, 
                                                         &rangeAllText, 
                                                         &cch)))
        return FALSE;


    Interface<IEnumTfRanges> EnumReadOnlyProperty;
    if (FAILED(args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, rangeAllText)))
        return FALSE;


    args.ec = ee->ecReadOnly;
    args.pLibTLS = m_pLibTLS;

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumTrackPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                        EnumTrackPropertyCallback,
                                                        &args);        // Argument of callback func.
    ENUM_RET ret_prop_composing = Enumrate.DoEnumrate();
    if (ret_prop_composing == ENUM_FIND)
        return TRUE;

    return FALSE;

}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::_IsInterim
//
//----------------------------------------------------------------------------

BOOL CTextEventSinkCallBack::_IsInterim(
    Interface_Attach<ITfContext>& ic,
    TESENDEDIT *ee
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (ic->GetSelection(ee->ecReadOnly, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return FALSE;

    if (sel->style.fInterimChar) {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::_IsCompositionChanged
//
//----------------------------------------------------------------------------

BOOL CTextEventSinkCallBack::_IsCompositionChanged(
    Interface_Attach<ITfContext>& ic,
    TESENDEDIT *ee
    )
{
    ENUM_RET enumret;

    BOOL fChanged;
    if (SUCCEEDED(ee->pEditRecord->GetSelectionStatus(&fChanged)))
    {
        if (fChanged)
            return TRUE;
    }

    //
    // Find GUID_PROP_MSIMTF_TRACKCOMPOSITION property.
    //
    EnumFindFirstTrackCompRangeArgs argsFindFirstTrackCompRange;
    Interface<ITfProperty> PropertyTrackComposition;
    if (FAILED(ic->GetProperty(GUID_PROP_MSIMTF_TRACKCOMPOSITION, 
                               argsFindFirstTrackCompRange.Property)))
        return FALSE;



    Interface<IEnumTfRanges> EnumFindFirstTrackCompRange;
    if (FAILED(argsFindFirstTrackCompRange.Property->EnumRanges(ee->ecReadOnly,
                                                    EnumFindFirstTrackCompRange,
                                                    NULL)))
        return FALSE;

    argsFindFirstTrackCompRange.ec = ee->ecReadOnly;

    CEnumrateInterface<IEnumTfRanges,
        ITfRange,
        EnumFindFirstTrackCompRangeArgs> EnumrateFindFirstTrackCompRange(
            EnumFindFirstTrackCompRange,
            EnumFindFirstTrackCompRangeCallback,
            &argsFindFirstTrackCompRange);   

    enumret = EnumrateFindFirstTrackCompRange.DoEnumrate();

    //
    // if there is no track composition property, 
    // the composition has been changed since we put it.
    //
    if (enumret != ENUM_FIND)
        return TRUE;

    Interface<ITfRange> rangeTrackComposition;
    if (FAILED(argsFindFirstTrackCompRange.Range->Clone(rangeTrackComposition)))
        return FALSE;

    //
    // get the text range that does not include read only area for 
    // reconversion.
    //
    Interface<ITfRange> rangeAllText;
    LONG cch;
    if (FAILED(ImmIfEditSessionCallBack::GetAllTextRange(ee->ecReadOnly, 
                                                         ic, 
                                                         &rangeAllText, 
                                                         &cch)))
        return FALSE;

    LONG lResult;
    if (FAILED(rangeTrackComposition->CompareStart(ee->ecReadOnly,
                                                   rangeAllText,
                                                   TF_ANCHOR_START,
                                                   &lResult)))
        return FALSE;

    //
    // if the start position of the track composition range is not
    // the beggining of IC, 
    // the composition has been changed since we put it.
    //
    if (lResult != 0)
        return TRUE;

    if (FAILED(rangeTrackComposition->CompareEnd(ee->ecReadOnly,
                                                    rangeAllText,
                                                    TF_ANCHOR_END,
                                                    &lResult)))
        return FALSE;

    //
    // if the start position of the track composition range is not
    // the beggining of IC, 
    // the composition has been changed since we put it.
    //
    if (lResult != 0)
        return TRUE;


    //
    // If we find the changes in these property, we need to update hIMC.
    //
    const GUID *guids[] = {&GUID_PROP_COMPOSING, 
                           &GUID_PROP_ATTRIBUTE,
                           &GUID_PROP_READING,
                           &GUID_PROP_MSIMTF_PREPARE_RECONVERT};
    const int guid_size = sizeof(guids) / sizeof(GUID*);

    Interface<IEnumTfRanges> EnumPropertyChanged;

    if (FAILED(ee->pEditRecord->GetTextAndPropertyUpdates(TF_GTP_INCL_TEXT,
                                                          guids, guid_size,
                                                          EnumPropertyChanged)))
        return FALSE;

    EnumPropertyChangedCallbackArgs args;
    args.ec = ee->ecReadOnly;
    CEnumrateInterface<IEnumTfRanges,
        ITfRange,
        EnumPropertyChangedCallbackArgs> Enumrate(EnumPropertyChanged,
                                                  EnumPropertyChangedCallback,
                                                  &args);   
    enumret = Enumrate.DoEnumrate();

    if (enumret == ENUM_FIND)
        return TRUE;

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::TextEventSinkCallback
//
//----------------------------------------------------------------------------
// static
HRESULT
CTextEventSinkCallBack::TextEventSinkCallback(
    UINT uCode,
    void *pv,
    void *pvData
    )
{
    DebugMsg(TF_FUNC, TEXT("TextEventSinkCallback"));

    ASSERT(uCode == ICF_TEXTDELTA); // the pvData cast only works in this case
    if (uCode != ICF_TEXTDELTA)
        return S_OK;

    CTextEventSinkCallBack* _this = (CTextEventSinkCallBack*)pv;
    ASSERT(_this);

    TESENDEDIT* ee = (TESENDEDIT*)pvData;
    ASSERT(ee);

    HRESULT hr;

    IMCLock imc(_this->m_hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
        return hr;

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
        return E_FAIL;

    ASSERT(_pCicContext != NULL);

#ifdef UNSELECTCHECK
    if (!_pAImeContext->m_fSelected)
        return S_OK;
#endif UNSELECTCHECK

    Interface_Attach<ITfContext> ic(_pCicContext->GetInputContext());



    /*
     * We have composition text.
     */

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        return E_OUTOFMEMORY;
    }


    BOOL     fInReconvertEditSession;

    fInReconvertEditSession = _pCicContext->m_fInReconvertEditSession.IsSetFlag();


    if (!_this->_IsCompositionChanged(ic, ee))
        return S_OK;

    BOOL     fComp;
    BOOL     fSapiFeedback;

    // need to check speech feedback UI.
    fSapiFeedback = _this->_IsSapiFeedbackUIPresent(ic, ee);

    fComp = _this->_IsComposingPresent(ic, ee);

    LANGID langid;
    CicProfile* _pProfile = ptls->GetCicProfile();

    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CTextEventSinkCallBack::TextEventSinkCallback. _pProfile==NULL."));
        return E_OUTOFMEMORY;
    }

    _pProfile->GetLangId(&langid);

    switch (PRIMARYLANGID(langid))
    {
        case LANG_KOREAN:
            //
            // We will finalize Korean composition string immediately if it 
            // doesn't set the interim definition. For example, Korean 
            // Handwriting TIP case. 
            //
            // Bug#482983 - Notepad doesn't support the level 2 composition 
            // window for Korean.
            //
            // And we should not do this during HanjaReConversion.
            //
            if (fComp && _pCicContext->m_fHanjaReConversion.IsResetFlag())
            {
                if (!(_this->_IsInterim(ic, ee)))
                {
                    //
                    // Reset fComp to false to complete the current composition
                    // string.
                    //
                    fComp = FALSE;
                }
            }
            break;

        case LANG_JAPANESE:
        case LANG_CHINESE:
            break;

        default:
            //
            // #500698
            //
            // Reset fComp to false to complete the current composition
            // string.
            //
            if (!ptls->NonEACompositionEnabled())
            {
                fComp = FALSE;
            }
            break;

    }

    //
    // Update composition and generate WM_IME_COMPOSITION
    //
    //    if there is SAPI green bar.
    //        - there is only hIMC composition if there is Speech Green bar.
    //
    //    if Reconversion just started.
    //        - because some tip may not change the text yet.
    //          then there is no composition range yet.
    //
    //    if now clearing DocFeed buffer.
    //        - because the change happens in read-only text
    //          nothing in hIMC changes.
    //
    if (fComp || fSapiFeedback || fInReconvertEditSession ||
        _pCicContext->m_fInClearDocFeedEditSession.IsSetFlag())
    {
        //
        // Retreive text delta from GUID_PROP_COMPOSING
        //
        const GUID *guids[] = {&GUID_PROP_COMPOSING};
        const int guid_size = sizeof(guids) / sizeof(GUID*);

        Interface<IEnumTfRanges> EnumPropertyUpdate;
        hr = ee->pEditRecord->GetTextAndPropertyUpdates(0,                   // dwFlags
                                                        guids, guid_size,
                                                        EnumPropertyUpdate);
        if (SUCCEEDED(hr)) {
            EnumPropertyUpdateArgs args(ic.GetPtr(), _this->m_tid, imc, _this->m_pLibTLS);

            if (FAILED(hr=ic->GetProperty(GUID_PROP_COMPOSING, args.Property)))
                return hr;

            args.ec = ee->ecReadOnly;
            args.dwDeltaStart = 0;

            CEnumrateInterface<IEnumTfRanges,
                               ITfRange,
                               EnumPropertyUpdateArgs> Enumrate(EnumPropertyUpdate,
                                                                EnumPropertyUpdateCallback,
                                                                &args);        // Argument of callback func.
            ENUM_RET ret_prop_update = Enumrate.DoEnumrate();
            if (ret_prop_update == ENUM_FIND) {
                //
                // Remove GUID_PROP_MSIMTF_PREPARE_RECONVERT property.
                //
                _this->EscbRemoveProperty(imc, &GUID_PROP_MSIMTF_PREPARE_RECONVERT);

                //
                // Update composition string with delta start position
                //
                return _this->EscbUpdateCompositionString(imc, args.dwDeltaStart);
            }
        }

        //
        // Update composition string
        //
        return _this->EscbUpdateCompositionString(imc);
    }
    else {
        //
        // Clear DocFeed range's text store.
        // Find GUID_PROP_MSIMTF_READONLY property and SetText(NULL).
        //
        // ImmIfIME::ClearDocFeedBuffer() essential function for all ESCB_RECONVERTSTRING's edit
        // session except only ImmIfIME::SetupDocFeedString() since this is provided for keyboard
        // TIP's DocFeeding.
        //
        _this->EscbClearDocFeedBuffer(imc, *_pCicContext, FALSE);  // No TF_ES_SYNC
        //
        // Composition complete.
        //
        return _this->EscbCompComplete(imc, FALSE);    //  No TF_ES_SYNC
    }
}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::EnumPropertyCallback
//
//----------------------------------------------------------------------------
// static
ENUM_RET
CTextEventSinkCallBack::EnumPropertyCallback(
    ITfRange* pRange,
    EnumPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        if (IsEqualIID(pargs->comp_guid, GUID_NULL)) {
            if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0))
                ret = ENUM_FIND;
        }
        else if (V_VT(&var) == VT_I4) {
            TfGuidAtom guid = V_I4(&var);
            if (IsEqualTFGUIDATOM(pargs->pLibTLS, guid, pargs->comp_guid))
                ret = ENUM_FIND;
        }
    }

    VariantClear(&var);
    return ret;
}


//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::EnumTrackPropertyCallback
//
//----------------------------------------------------------------------------
// static
ENUM_RET
CTextEventSinkCallBack::EnumTrackPropertyCallback(
    ITfRange* pRange,
    EnumTrackPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        Interface<IEnumTfPropertyValue> EnumPropVal;
        hr = var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, EnumPropVal);
        if (SUCCEEDED(hr)) {
            TF_PROPERTYVAL tfPropertyVal;

            while (EnumPropVal->Next(1, &tfPropertyVal, NULL) == S_OK) {
                for (int i=0; i < pargs->num_guids; i++) {
                    if (IsEqualGUID(tfPropertyVal.guidId, *pargs->guids[i])) {
                        if ((V_VT(&tfPropertyVal.varValue) == VT_I4 && V_I4(&tfPropertyVal.varValue) != 0)) {
                            ret = ENUM_FIND;
                            break;
                        }
                    }
                }

                VariantClear(&tfPropertyVal.varValue);

                if (ret == ENUM_FIND)
                    break;
            }
        }
    }

    VariantClear(&var);
    return ret;
}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::EnumPropertyUpdateCallback
//
//----------------------------------------------------------------------------
// static
ENUM_RET
CTextEventSinkCallBack::EnumPropertyUpdateCallback(
    ITfRange* update_range,
    EnumPropertyUpdateArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, update_range, &var);
    if (SUCCEEDED(hr)) {
        if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0)) {

            Interface_Creator<ImmIfEditSession> _pEditSession(
                new ImmIfEditSession(ESCB_GET_ALL_TEXT_RANGE,
                                     pargs->imc,
                                     pargs->tid,
                                     pargs->ic.GetPtr(),
                                     pargs->pLibTLS)
            );
            if (_pEditSession.Valid()) {

                Interface<ITfRange> full_range;

                if (SUCCEEDED(_pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                                           &full_range))) {

                    if (SUCCEEDED(full_range->ShiftEndToRange(pargs->ec, update_range, TF_ANCHOR_START))) {
                        Interface<ITfRangeACP> unupdate_range;
                        if (SUCCEEDED(full_range->QueryInterface(IID_ITfRangeACP, unupdate_range))) {
                            LONG acpStart;
                            LONG cch;
                            if (SUCCEEDED(unupdate_range->GetExtent(&acpStart, &cch))) {
                                pargs->dwDeltaStart = cch;
                                ret = ENUM_FIND;
                            }
                        }
                    }
                }
            }
        }
    }

    VariantClear(&var);
    return ret;
}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::EnumPropertyChangedCallback
//
//----------------------------------------------------------------------------
// static 
ENUM_RET 
CTextEventSinkCallBack::EnumPropertyChangedCallback(
    ITfRange* update_range, 
    EnumPropertyChangedCallbackArgs *pargs
    )
{
    BOOL empty;
    if (update_range->IsEmpty(pargs->ec, &empty) == S_OK && empty)
        return ENUM_CONTINUE;

    return ENUM_FIND;
}

//+---------------------------------------------------------------------------
//
// CTextEventSinkCallBack::EnumPropertyChangedCallback
//
//----------------------------------------------------------------------------
// static 
ENUM_RET 
CTextEventSinkCallBack::EnumFindFirstTrackCompRangeCallback(
    ITfRange* update_range, 
    EnumFindFirstTrackCompRangeArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, update_range, &var);
    if (SUCCEEDED(hr)) 
    {
        if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0)) 
        {
            update_range->Clone(pargs->Range);
            ret = ENUM_FIND;
        }
    }
    VariantClear(&var);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\ui.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    ui.cpp

Abstract:

    This file implements the UI Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "ui.h"

//+---------------------------------------------------------------------------
//
// OnCreate
//
//+---------------------------------------------------------------------------

/* static */
VOID
UI::OnCreate(
    HWND hUIWnd)
{
    UI* pv = (UI*)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (pv != NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UI::OnCreate. pv!=NULL"));
        return;
    }


    pv = new UI(hUIWnd);
    if (pv == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UI::OnCreate. pv==NULL"));
        return;
    }

    pv->_Create();
}

//+---------------------------------------------------------------------------
//
// OnDestroy
//
//+---------------------------------------------------------------------------

/* static */
VOID
UI::OnDestroy(
    HWND hUIWnd)
{
    UI* pv = (UI*)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (pv == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UI::OnDestroy. pv==NULL"));
        return;
    }

    pv->_Destroy();

    delete pv;
}

//+---------------------------------------------------------------------------
//
// _Create
//
//+---------------------------------------------------------------------------

HRESULT
UI::_Create()
{
    m_UIComposition = (UIComposition*)new UIComposition(m_hUIWnd);
    if (m_UIComposition == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UI::Create. m_UIComposition==NULL"));
        return E_OUTOFMEMORY;
    }

    SetWindowLongPtr(m_hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)this);

    if (FAILED(m_UIComposition->OnCreate()))
    {
        DebugMsg(TF_ERROR, TEXT("UI::Create. m_UIComposition->Create==NULL"));
        delete m_UIComposition;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Destroy
//
//+---------------------------------------------------------------------------

HRESULT
UI::_Destroy()
{
    m_UIComposition->OnDestroy();
    SetWindowLongPtr(m_hUIWnd, IMMGWLP_PRIVATE, NULL);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\txtevcb.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    txtevcb.h

Abstract:

    This file defines the CTextEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TXTEVCB_H_
#define _TXTEVCB_H_

#include "template.h"
#include "imc.h"
#include "context.h"

class CTextEventSinkCallBack : public CTextEventSink
{
public:
    CTextEventSinkCallBack(HIMC hIMC,
                           TfClientId tid,
                           Interface_Attach<ITfContext> pic,
                           LIBTHREAD* pLibTLS)
        : m_hIMC(hIMC), m_tid(tid), m_ic(pic), m_pLibTLS(pLibTLS),
          CTextEventSink(TextEventSinkCallback, NULL)
    {
    }
    virtual ~CTextEventSinkCallBack() { }

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    BOOL _IsSapiFeedbackUIPresent(Interface_Attach<ITfContext>& ic, TESENDEDIT *ee);
    BOOL _IsComposingPresent(Interface_Attach<ITfContext>& ic, TESENDEDIT *ee);
    BOOL _IsInterim(Interface_Attach<ITfContext>& ic, TESENDEDIT *ee);
    BOOL _IsCompositionChanged(Interface_Attach<ITfContext>& ic, TESENDEDIT *ee);

    //
    // Callbacks
    //
private:
    static HRESULT TextEventSinkCallback(UINT uCode, void *pv, void *pvData);

    //
    // Enumrate property
    //
    typedef struct _EnumPropertyArgs
    {
        Interface<ITfProperty> Property;
        TfEditCookie ec;
        GUID         comp_guid;
        LIBTHREAD    *pLibTLS;
    } EnumPropertyArgs;

    static ENUM_RET EnumPropertyCallback(ITfRange* pRange, EnumPropertyArgs *pargs);

    //
    // Enumrate track property
    //
    typedef struct _EnumTrackPropertyArgs
    {
        Interface<ITfReadOnlyProperty> Property;
        TfEditCookie ec;

        GUID       **guids;
        int          num_guids;

        LIBTHREAD    *pLibTLS;
    } EnumTrackPropertyArgs;

    static ENUM_RET EnumTrackPropertyCallback(ITfRange* pRange, EnumTrackPropertyArgs *pargs);

    //
    // Enumrate property update
    //
    typedef struct _EnumPropertyUpdateArgs
    {
        _EnumPropertyUpdateArgs(ITfContext* pv, TfClientId p1, IMCLock& p2, LIBTHREAD* p3) : ic(pv), tid(p1), imc(p2), pLibTLS(p3) { }

        Interface<ITfProperty> Property;
        TfEditCookie           ec;
        Interface_Attach<ITfContext> ic;
        IMCLock&               imc;
        DWORD                  dwDeltaStart;
        TfClientId             tid;
        LIBTHREAD*             pLibTLS;
    } EnumPropertyUpdateArgs;

    static ENUM_RET EnumPropertyUpdateCallback(ITfRange* update_range, EnumPropertyUpdateArgs *pargs);

    //
    // Enumrate property change
    //
    typedef struct _EnumPropertyChangedCallbackArgs
    {
        TfEditCookie           ec;
    } EnumPropertyChangedCallbackArgs;

    static ENUM_RET EnumPropertyChangedCallback(ITfRange* update_range, EnumPropertyChangedCallbackArgs *pargs);

    //
    // Enumrate find first track comp range
    //
    typedef struct _EnumFindFirstTrackCompRangeArgs 
    {
        TfEditCookie           ec;
        Interface<ITfProperty> Property;
        Interface<ITfRange>    Range;
    } EnumFindFirstTrackCompRangeArgs;

    static ENUM_RET EnumFindFirstTrackCompRangeCallback(ITfRange* update_range, EnumFindFirstTrackCompRangeArgs *pargs);

    //
    // Edit session helper
    //
protected:
    HRESULT EscbUpdateCompositionString(IMCLock& imc)
    {
        return ::EscbUpdateCompositionString(imc, m_tid, m_ic, m_pLibTLS, 0, 0);
    }

    HRESULT EscbUpdateCompositionString(IMCLock& imc, DWORD dwDeltaStart)
    {
        return ::EscbUpdateCompositionString(imc, m_tid, m_ic, m_pLibTLS, dwDeltaStart, 0);
    }

    HRESULT EscbCompComplete(IMCLock& imc, BOOL fSync)
    {
        return ::EscbCompComplete(imc, m_tid, m_ic, m_pLibTLS, fSync);
    }

    HRESULT EscbClearDocFeedBuffer(IMCLock& imc, CicInputContext& CicContext, BOOL fSync)
    {
        return ::EscbClearDocFeedBuffer(imc, CicContext, m_tid, m_ic, m_pLibTLS, fSync);
    }

    HRESULT EscbRemoveProperty(IMCLock& imc, const GUID* guid)
    {
        return ::EscbRemoveProperty(imc, m_tid, m_ic, m_pLibTLS, guid);
    }

    //
    // Edit session friend
    //
private:
    friend HRESULT EscbUpdateCompositionString(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                               DWORD dwDeltaStart,
                                               DWORD dwFlags);
    friend HRESULT EscbCompComplete(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                    BOOL fSync);
    friend HRESULT EscbClearDocFeedBuffer(IMCLock& imc, CicInputContext& CicContext, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                          BOOL fSync);

    friend HRESULT EscbRemoveProperty(IMCLock& imc, TfClientId tid, Interface_Attach<ITfContext> pic, LIBTHREAD* pLibTLS,
                                      const GUID* guid);

private:
    Interface_Attach<ITfContext>  m_ic;
    TfClientId                    m_tid;
    LIBTHREAD*                    m_pLibTLS;
    HIMC                          m_hIMC;
};

#endif // _TXTEVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\uicomp.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    uicomp.cpp

Abstract:

    This file implements the UIComposition Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "resource.h"
#include "cicspres.h"
#include "uicomp.h"
#include "globals.h"
#include "ctxtcomp.h"
#include "cic.h"
#include "profile.h"
#include "cregkey.h"
#include "cresstr.h"
#include "delay.h"
#include "fontlink.h"

const TCHAR c_szCUASDefCompKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\CUAS\\DefaultCompositionWindow");
const TCHAR c_szLeft[] = TEXT("Left");
const TCHAR c_szTop[] = TEXT("Top");


//+---------------------------------------------------------------------------
//
// IsEALang
//
//+---------------------------------------------------------------------------

BOOL IsEALang()
{
    TLS* ptls = TLS::GetTLS();
    if (ptls)
    {
        CicProfile* pProfile;
        if (pProfile = ptls->GetCicProfile())
        {
            LANGID langid;
            pProfile->GetLangId(&langid);
            switch(PRIMARYLANGID(langid))
            {
                case LANG_JAPANESE:
                case LANG_KOREAN:
                case LANG_CHINESE:
                    return TRUE;
            }
        } 
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// Internal_PolyTextOutW
//
//+---------------------------------------------------------------------------

BOOL
Internal_PolyTextOutW(
    HDC hDC,
    CONST POLYTEXTW* pptxt,
    int cStrings)
{
    for (int i=0; i < cStrings; i++)
    {
        if (! FLExtTextOutW(hDC,
                          pptxt[i].x, pptxt[i].y,
                          pptxt[i].uiFlags,
                          &pptxt[i].rcl,
                          pptxt[i].lpstr, pptxt[i].n, pptxt[i].pdx))
            return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDefCompFrameGripper
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CDefCompFrameGripper::ctor
//
//+---------------------------------------------------------------------------

CDefCompFrameGripper::CDefCompFrameGripper(CDefCompFrameWindow *pDefCompFrameWindow, RECT *prc, DWORD dwStyle) : CUIFGripper( pDefCompFrameWindow, prc, dwStyle) 
{
    m_pDefCompFrameWnd = pDefCompFrameWindow;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompFinalizeButton
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CCompFinalizeButton::ctor
//
//+---------------------------------------------------------------------------

CCompFinalizeButton::CCompFinalizeButton(CCompFrameWindow *pCompFrameWindow, DWORD dwID, RECT *prc, DWORD dwStyle, DWORD dwSBtnStyle, DWORD dwSBtnShowType) : CUIFToolbarButton(pCompFrameWindow, dwID, prc, dwStyle, dwSBtnStyle, dwSBtnShowType)
{
    m_pCompFrameWnd = pCompFrameWindow;
}

//+---------------------------------------------------------------------------
//
// CCompFinalizeButton::dtor
//
//+---------------------------------------------------------------------------

CCompFinalizeButton::~CCompFinalizeButton()
{
    HICON hIcon = GetIcon();
    if (hIcon)
    {
        DestroyIcon(hIcon);
        SetIcon(NULL);
    }
}

//+---------------------------------------------------------------------------
//
// CCompFinalizeButton::OnLeftClick
//
//+---------------------------------------------------------------------------

void CCompFinalizeButton::OnLeftClick()
{
    Assert(m_pCompFrameWnd);

    //
    // complete string at lbutton click.
    //
    if (m_pCompFrameWnd->GetIMC())
        ImmNotifyIME(m_pCompFrameWnd->GetIMC(), 
                     NI_COMPOSITIONSTR, 
                     CPS_COMPLETE, 
                     0);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDefCompFrameWindow
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CDefCompFrameWindow::CDefCompFrameWindow
//
//+---------------------------------------------------------------------------

CDefCompFrameWindow::CDefCompFrameWindow(HIMC hIMC, DWORD dwStyle) : CCompFrameWindow(hIMC, dwStyle)
{

    //
    // get the current position from registry
    //
    LoadPosition();

    //
    // Set theme
    //
    SetActiveTheme(L"TASKBAR", TBP_BACKGROUNDBOTTOM, TS_NORMAL );
}

//+---------------------------------------------------------------------------
//
// CDefCompFrameWindow::~CDefCompFrameWindow
//
//+---------------------------------------------------------------------------

CDefCompFrameWindow::~CDefCompFrameWindow()
{

    //
    // save the current position to registry
    //
    SavePosition();
}

//+---------------------------------------------------------------------------
//
// CDefCompFrameWindow::OnSetCursor
//
//+---------------------------------------------------------------------------

BOOL CDefCompFrameWindow::OnSetCursor( UINT uMsg, POINT pt )
{
    //
    // SendMessage(WM_UICOMP_SETCURSOR) will set the cursor if pt is in 
    // the comp str window.
    //

    if (IsWindow(m_hwndCompStr))
    {
        RECT rc;
        GetWindowRect(m_hwndCompStr, &rc);
        MyScreenToClient(NULL, &rc);
        if (PtInRect(&rc, pt))
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CDefCompFrameWindow::HandleMouseMsg
//
//+---------------------------------------------------------------------------

void CDefCompFrameWindow::HandleMouseMsg( UINT uMsg, POINT pt )
{
    if (IsWindow(m_hwndCompStr))
    {
        RECT rc;
        GetWindowRect(m_hwndCompStr, &rc);
        MyScreenToClient(NULL, &rc);
        if (PtInRect(&rc, pt))
            SendMessage(m_hwndCompStr, WM_UICOMP_SETCURSOR, 0, 0);
    }

    CUIFWindow::HandleMouseMsg(uMsg, pt );
}

//+---------------------------------------------------------------------------
//
// CDefCompFrameWindow::Init
//
//+---------------------------------------------------------------------------

void CDefCompFrameWindow::Init()
{
    if (!m_pGripper)
    {
        RECT rc;
        ::SetRect(&rc, 0, 0, 0, 0);
        m_pGripper = new CDefCompFrameGripper(this, &rc, 0);

        m_pGripper->Initialize();

        AddUIObj(m_pGripper);
    }

    if (!m_pEnterButton)
    {
        RECT rc;
        ::SetRect(&rc, 0, 0, 0, 0);
        m_pEnterButton = new CCompFinalizeButton(this, 
                                                 0, 
                                                 &rc, 
                                                 0, 
                                                 UITBBUTTON_BUTTON, 
                                                 0);

        m_pEnterButton->Initialize();
        m_pEnterButton->Init();
        m_pEnterButton->SetIcon(LoadSmIcon(::GetInstance(),
                                MAKEINTRESOURCE(IDIC_ENTER_ICON)));
        m_pEnterButton->SetToolTip(CRStr2(IDS_ENTER_BTN_TOOLTIP));

        AddUIObj(m_pEnterButton);
    }
}

//+---------------------------------------------------------------------------
//
// OnCreate
//
//----------------------------------------------------------------------------

void CDefCompFrameWindow::OnCreate(HWND hWnd)
{
    //
    // Set Window Theme.
    //
    SetWindowTheme(hWnd, L"TASKBAR", NULL);

    //
    // Get margins of button theme.
    //
    CUIFTheme themeBtn;
    memset(&_marginsButton, 0, sizeof(_marginsButton));

    themeBtn.SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);
    if (SUCCEEDED(themeBtn.OpenThemeData(hWnd)))
    {
        themeBtn.GetThemeMargins(NULL, TS_NORMAL,
                                 TMT_CONTENTMARGINS,
                                 NULL, &_marginsButton);
    }

}

//+---------------------------------------------------------------------------
//
// OnWindowPosChanged
//
//----------------------------------------------------------------------------

LRESULT CDefCompFrameWindow::OnWindowPosChanged(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IMCLock imc(GetIMC());
    if (SUCCEEDED(imc.GetResult()))
    {
         SendMessage(imc->hWnd, 
                     WM_IME_NOTIFY,
                     IMN_PRIVATE_ONLAYOUTCHANGE, 
                     (LPARAM)GetIMC());
    }
    return CUIFWindow::OnWindowPosChanged(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// CDefCompFrameWindow::SetCompStrRect
//
//+---------------------------------------------------------------------------

void CDefCompFrameWindow::SetCompStrRect(int dx, int dy, BOOL fShow)
{
    int x, y;
    int nGripperWidth = GetGripperWidth();
    RECT rcWnd;

    GetWindowRect(GetWnd(), &rcWnd);
    Move(rcWnd.left, rcWnd.top, dx + (DEFFRAME_LEFT_MARGIN * 3) + nGripperWidth + DEFFRAME_ENTER_BTN_CX, dy + DEFFRAME_TOP_MARGIN + DEFFRAME_BOTTOM_MARGIN);

    if (m_pGripper)
    {
        RECT rc;
        x = DEFFRAME_LEFT_MARGIN;
        y = DEFFRAME_TOP_MARGIN;
        ::SetRect(&rc, 
                  x, 
                  y, 
                  x + nGripperWidth, 
                  DEFFRAME_TOP_STR_MARGIN + dy);
        m_pGripper->SetRect(&rc);
    }

    if (m_pEnterButton)
    {
        RECT rc;
        x = DEFFRAME_LEFT_MARGIN + nGripperWidth + dx + DEFFRAME_LEFT_MARGIN;
        y = DEFFRAME_TOP_MARGIN;
        ::SetRect(&rc, 
                  x, 
                  y,
                  x + DEFFRAME_ENTER_BTN_CX + _marginsButton.cxLeftWidth + _marginsButton.cxRightWidth,
                  y + DEFFRAME_ENTER_BTN_CY + _marginsButton.cyTopHeight + _marginsButton.cyBottomHeight);
        m_pEnterButton->SetRect(&rc);
    }

    Show(fShow);

    
    x = DEFFRAME_LEFT_MARGIN + nGripperWidth;
    y = DEFFRAME_TOP_STR_MARGIN;
    ::MoveWindow(m_hwndCompStr, x, y, dx, dy, TRUE);
    ::ShowWindow(m_hwndCompStr, fShow ? SW_SHOWNOACTIVATE : SW_HIDE);
}

//+---------------------------------------------------------------------------
//
// GetGripperWidth
//
//----------------------------------------------------------------------------

int CDefCompFrameWindow::GetGripperWidth()
{
    if (m_pGripper)
    {
        if (SUCCEEDED(m_pGripper->EnsureThemeData(GetWnd())))
        {
            int nRet = -1;

            SIZE size;
            HDC hdc = GetDC(GetWnd());
            if (SUCCEEDED(m_pGripper->GetThemePartSize(hdc,
                                                      TS_NORMAL,
                                                      NULL,
                                                      TS_TRUE,
                                                      &size)))
            {
                nRet = size.cx + CUI_GRIPPER_THEME_MARGIN * 2;
            }

            ReleaseDC(GetWnd(), hdc);

            if (nRet >= 0)
                return nRet;
        }
    }

    return 5;
}


//+---------------------------------------------------------------------------
//
// SavePosition
//
//----------------------------------------------------------------------------

void CDefCompFrameWindow::SavePosition()
{
    CMyRegKey key;

    if (key.Create(HKEY_CURRENT_USER, c_szCUASDefCompKey) == S_OK)
    {
        key.SetValue((DWORD)_xWnd, c_szLeft);
        key.SetValue((DWORD)_yWnd, c_szTop);
    }
}

//+---------------------------------------------------------------------------
//
// LoadPosition
//
//----------------------------------------------------------------------------

void CDefCompFrameWindow::LoadPosition()
{
    CMyRegKey key;
    int x, y;

    x = 0;
    y = 0;
    if (key.Open(HKEY_CURRENT_USER, c_szCUASDefCompKey, KEY_READ) == S_OK)
    {
        DWORD dw;
        if (key.QueryValue(dw, c_szLeft) == S_OK)
            x = (int)dw;

        if (key.QueryValue(dw, c_szTop) == S_OK)
            y = (int)dw;
    }

    Move(x, y, 0, 0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompButtonFrameWindow
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CCompButtonFrameWindow::CCompButtonFrameWindow
//
//+---------------------------------------------------------------------------

CCompButtonFrameWindow::CCompButtonFrameWindow(HIMC hIMC, DWORD dwStyle) : CCompFrameWindow(hIMC, dwStyle)
{
#ifdef COMPBUTTON_TOOLBARTHEME
    //
    // Set theme
    //
    SetActiveTheme(L"TOOLBAR", TBP_BACKGROUNDBOTTOM, TS_NORMAL );
#endif
}

//+---------------------------------------------------------------------------
//
// CCompButtonFrameWindow::~CCompButtonFrameWindow
//
//+---------------------------------------------------------------------------

CCompButtonFrameWindow::~CCompButtonFrameWindow()
{

}

//+---------------------------------------------------------------------------
//
// OnCreate
//
//----------------------------------------------------------------------------

void CCompButtonFrameWindow::OnCreate(HWND hWnd)
{
    //
    // Set Window Theme.
    //
#ifdef COMPBUTTON_TOOLBARTHEME
    SetWindowTheme(hWnd, L"TASKBAR", NULL);
#else
    SetWindowTheme(hWnd, L"TOOLBAR", NULL);
#endif

    //
    // Get margins of button theme.
    //
    CUIFTheme themeBtn;
    memset(&_marginsButton, 0, sizeof(_marginsButton));

    themeBtn.SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);
    if (SUCCEEDED(themeBtn.OpenThemeData(hWnd)))
    {
        themeBtn.GetThemeMargins(NULL, TS_NORMAL,
                                 TMT_CONTENTMARGINS,
                                 NULL, &_marginsButton);
    }

}

//+---------------------------------------------------------------------------
//
// CCompButtonFrameWindow::Init
//
//+---------------------------------------------------------------------------

void CCompButtonFrameWindow::Init()
{

    if (!m_pEnterButton)
    {
        RECT rc;
        ::SetRect(&rc, 0, 0, 0, 0);
        m_pEnterButton = new CCompFinalizeButton(this, 
                                                 0, 
                                                 &rc, 
                                                 0, 
                                                 UITBBUTTON_BUTTON, 
                                                 0);

        m_pEnterButton->Initialize();
        m_pEnterButton->Init();
        m_pEnterButton->SetIcon(LoadSmIcon(::GetInstance(),
                                MAKEINTRESOURCE(IDIC_ENTER_ICON)));
        m_pEnterButton->SetToolTip(CRStr2(IDS_ENTER_BTN_TOOLTIP));

        AddUIObj(m_pEnterButton);
    }
}

//+---------------------------------------------------------------------------
//
// CCompButtonFrameWindow::MoveShow
//
//+---------------------------------------------------------------------------

void CCompButtonFrameWindow::MoveShow(int x, int y, BOOL fShow)
{
    RECT rcWnd;
    int cx = DEFFRAME_ENTER_BTN_CX + _marginsButton.cxLeftWidth + _marginsButton.cxRightWidth;
    int cy = DEFFRAME_ENTER_BTN_CY + _marginsButton.cyTopHeight + _marginsButton.cyBottomHeight;

    GetWindowRect(GetWnd(), &rcWnd);
    Move(x, y, 
         ((COMPBTN_LEFT_MARGIN + 1) * 2) + cx, 
         ((COMPBTN_TOP_MARGIN  + 1) * 2) + cy);

    if (m_pEnterButton)
    {
        RECT rc;
        x = COMPBTN_LEFT_MARGIN;
        y = COMPBTN_TOP_MARGIN;
        ::SetRect(&rc, x, y, x + cx, x + cy);
        m_pEnterButton->SetRect(&rc);
    }

    Show(fShow);
}


//////////////////////////////////////////////////////////////////////////////
//
// UIComposition
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// UIComposition::CompWndProc
//
//+---------------------------------------------------------------------------

/* static */
LRESULT
UIComposition::CompWndProc(
    HWND hCompWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{

    switch (uMsg)
    {
        case WM_SETCURSOR:
        case WM_UICOMP_SETCURSOR:
            {
            UIComposition* pv = (UIComposition*)GetWindowLongPtr(hCompWnd, GWLP_USERDATA);
            HRESULT hr = E_FAIL;
            
            if (pv)
            {
                HWND hUIWnd = pv->GetUIWnd();
                if (IsWindow(hUIWnd))
                {
                    HIMC hImc = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                    IMCLock imc(hImc);
                    if (SUCCEEDED(imc.GetResult()))
                    {
                        hr = pv->OnSetCursor(imc, wParam, lParam);
                    }
                }
            }

            if (hr != S_OK)
                return DefWindowProc(hCompWnd, uMsg, wParam, lParam);

            break;
            }

        case WM_PAINT:
        case WM_TIMER:
            {
                TLS* ptls = TLS::GetTLS();
                if (ptls == NULL)
                    return 0;

                UIComposition* pv = (UIComposition*)GetWindowLongPtr(hCompWnd, GWLP_USERDATA);
                if (pv != NULL)
                {
                    switch (uMsg)
                    {
                        case WM_PAINT:
                            {
                                PAINTSTRUCT ps;
                                HDC hDC = BeginPaint(hCompWnd, &ps);

                                HWND hUIWnd = pv->GetUIWnd();
                                if (IsWindow(hUIWnd))
                                {
                                    HIMC hImc = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                                    IMCLock imc(hImc);
                                    if (SUCCEEDED(imc.GetResult()))
                                    {
                                        pv->OnPaint(ptls, hCompWnd, hDC, ps, imc);
                                    }
                                }
                                EndPaint(hCompWnd, &ps);
                            }
                            break;

                        case WM_TIMER:
                            pv->OnTimer(hCompWnd);
                            break;
                    }
                }
            }
            break;

        default:
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
// UIComposition::ctor
// UIComposition::dtor
//
//+---------------------------------------------------------------------------

UIComposition::UIComposition(HWND hUIWnd)
{
    for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
    {
        m_CompWnd[i].hCompWnd = NULL;
        m_CompWnd[i].fDefaultCompWnd = FALSE;
    }
    m_DefCompWnd.hCompWnd = NULL;
    m_DefCompWnd.fDefaultCompWnd = TRUE;

    m_hFontLevel1 = NULL;
    m_hFontLevel2 = NULL;

    m_isc = 0;
    m_hUIWnd = hUIWnd;
    m_lpszCompStr = NULL;
    m_nCompStr = 0;
    m_bTimerCOMPOSITION = FALSE;
}

UIComposition::~UIComposition()
{
    DestroyCompositionWindow();

    if (m_hFontLevel1)
        DeleteObject(m_hFontLevel1);

    if (m_hFontLevel2)
        DeleteObject(m_hFontLevel2);

    m_hFontLevel1 = NULL;
    m_hFontLevel2 = NULL;

    if (m_lpszCompStr)
    {
        cicMemFree(m_lpszCompStr);
        m_lpszCompStr = NULL;
    }
    m_nCompStr = 0;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnCreate
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnCreate()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnDestroy
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnDestroy()
{
    return DestroyCompositionWindow();
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeSetContext
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeSetContext(
    IMCLock& imc,
    HWND hUIWnd,
    BOOL fActivate,
    DWORD isc)
{
    HRESULT hr = S_OK;
    if (fActivate)
    {
        if (SUCCEEDED(imc.GetResult()))
        {
            //
            // #598648
            //
            // Powerpnt XP does not clear ISC_SHOWUICOMPOSITIONWINDOW.
            // even though it is AIMM filtered window. It must be Level3.
            //
            BOOL fFilter = MsimtfIsWindowFiltered(imc->hWnd);
            if ((isc & ISC_SHOWUICOMPOSITIONWINDOW) && fFilter)
            {
                isc &= ~ISC_SHOWUICOMPOSITIONWINDOW;

                //
                // 616323
                //
                // Trident can not handle the existing composition string.
                //
                // if hIMC already has a composition string before the focus 
                // goes to the trident. We need to clear the comp string.
                // Trident can not start the composition string in the middle 
                // of composing.
                //
                IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
                if (FAILED(hr=comp.GetResult()))
                {
                    DebugMsg(TF_ERROR, TEXT("UIComposition::OnImeSetContext. comp==NULL"));
                    return hr;
                }

                if (comp->dwCompStrLen)
                {
                    DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
                    if (dwImeCompatFlags & IMECOMPAT_AIMM12_TRIDENT)
                    {
                        IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
                        if (FAILED(imc_ctfime.GetResult()))
                        {
                            return E_FAIL;
                        }

                        CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
                        if (_pCicContext == NULL)
                        {
                            DebugMsg(TF_ERROR, TEXT("UIComposition::OnImeSetContext. _pCicContext==NULL"));
                            return E_FAIL;
                        }

                        _pCicContext->EscbCompComplete(imc);

                    }
                }
            }
        }

        m_isc = isc;

        UpdateShowCompWndFlag(imc, NULL);

    }
    m_fActive = fActivate;
    return hr;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeSetContextAfter
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeSetContextAfter(
    IMCLock& imc)
{
    if ((m_pDefCompFrameWnd && IsWindow(m_pDefCompFrameWnd->GetWnd())) ||
        IsWindow(m_CompWnd[FIRST_WINDOW].hCompWnd)
       )
    {
        HRESULT hr;

        //
        // Validation check of imc.
        // Because CIMEUIWindowHandler::ImeUIWndProcWorker doesn't check.
        //
        hr = imc.GetResult();

        //
        // we show the def / level2 comp window,
        //
        //  - if imc is valid.
        //  - if composition window is on Level1 or 2.
        //  - if it is not level 3,
        //          (m_isc does not have ISC_SHOWUICOMPOSITIONWINDOW)
        //  - if it is active.
        //  - if there is a composition string.
        //
        IME_UIWND_STATE uiwndState;
        if (SUCCEEDED(hr) &&
            ((uiwndState = GetLevelFromIMC(imc)) == IME_UIWND_LEVEL1 || uiwndState == IME_UIWND_LEVEL2) &&
            (m_isc & ISC_SHOWUICOMPOSITIONWINDOW) &&
            m_fActive)
        {
            DWORD dwCompLen = 0;
            UpdateShowCompWndFlag(imc, &dwCompLen);

            if (uiwndState == IME_UIWND_LEVEL1)
            {
                ShowWindow(m_pDefCompFrameWnd->GetWnd(), 
                           m_fShowCompWnd.IsSetFlag() ? SW_SHOWNOACTIVATE : SW_HIDE);
            }
            else if ((uiwndState == IME_UIWND_LEVEL2) && (m_fShowCompWnd.IsResetFlag()))
            {
                for (int i = 0; i < sizeof(m_CompWnd)/sizeof(COMPWND) && dwCompLen > 0; i++)
                {
                    m_CompWnd[i].caret.HideCaret();
                    ShowWindow(m_CompWnd[i].hCompWnd, SW_HIDE);
                }
            }
        }
        else
        {
            //
            // Both Level 1 / Level 2 window hide.
            //
            ShowWindow(m_pDefCompFrameWnd->GetWnd(), SW_HIDE);
            for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
            {
                m_CompWnd[i].caret.HideCaret();
                ShowWindow(m_CompWnd[i].hCompWnd, SW_HIDE);
            }
        }
    }
    else
    {
        m_isc &= ~ISC_SHOWUICOMPOSITIONWINDOW;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeSelect
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeSelect(
    BOOL fSelect)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeStartComposition
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeStartComposition(
    IMCLock& imc,
    HWND hUIWnd)
{
    HRESULT hr;

    if (SUCCEEDED(hr = UpdateFont(imc)))
    {
        TEXTMETRIC tm;
        HDC hDC;
        HFONT hFontOrg;

        hDC = GetDC(m_DefCompWnd.hCompWnd);

        // get FontHeight for level1.
        hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel1);
        GetTextMetrics(hDC, &tm);
        m_tmFontHeightLevel1 = tm.tmHeight;

        // get FontHeight for level2.
        SelectObject(hDC, m_hFontLevel2);
        GetTextMetrics(hDC, &tm);
        m_tmFontHeightLevel2 = tm.tmHeight;

        SelectObject(hDC, hFontOrg);
        ReleaseDC(m_DefCompWnd.hCompWnd, hDC);

        if (!imc.UseVerticalCompWindow())
        {
            m_caret_size.cx = CARET_WIDTH;
            m_caret_size.cy = tm.tmHeight + LINE_BOLD_WIDTH;
        }
        else
        {
            m_caret_size.cx = tm.tmHeight + LINE_BOLD_WIDTH;
            m_caret_size.cy = CARET_WIDTH;
        }

        if (SUCCEEDED(hr = CreateCompositionWindow(imc, hUIWnd)))
        {
            UpdateCompositionRect(imc);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeCompositionUpdate
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeCompositionUpdate(IMCLock& imc)
{
    m_isc |= ISC_SHOWUICOMPOSITIONWINDOW;    // arrive WM_IME_COMPOSITION in IME UI window,
                                             // IME should draw comp wnd.
    return UpdateShowCompWndFlag(imc, NULL);
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeCompositionUpdateByTimer
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeCompositionUpdateByTimer(IMCLock& imc)
{
    return UpdateCompositionRect(imc);
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeEndComposition
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeEndComposition()
{
    m_isc = 0;
    return DestroyCompositionWindow();
}

//+---------------------------------------------------------------------------
//
// UIComposition::CreateCompositionWindow
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::CreateCompositionWindow(
    IMCLock& imc,
    HWND hUIWnd)
{
    HRESULT hr;

    if (SUCCEEDED(hr=imc.GetResult()) &&
        IsWindow(hUIWnd) &&
        m_fInitUIComp.IsResetFlag())
    {

        //
        // Create three composition windows
        //
        // m_CompWnd[0].hCompWnd is first composition window rectangle.
        // m_CompWnd[1].hCompWnd is middle composition window rectangle.
        // m_CompWnd[2].hCompWnd is last composition window rectangle.
        //
        for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
        {
            Assert(!m_CompWnd[i].hCompWnd);
            m_CompWnd[i].hCompWnd = CreateWindowExW(0,
                                                   s_szCompClassName,
                                                   NULL,
                                                   WS_POPUP | WS_DISABLED,
                                                   0, 0, 0, 0,
                                                   hUIWnd,        // Parent Window Handle.
                                                   NULL,
                                                   GetInstance(),
                                                   NULL);
            if (m_CompWnd[i].hCompWnd == NULL)
            {
                DestroyCompositionWindow();
                DebugMsg(TF_ERROR, TEXT("UIComposition::Create. m_CompWnd[].hCompWnd==NULL"));
                return E_OUTOFMEMORY;
            }

            SetWindowLongPtr(m_CompWnd[i].hCompWnd, GWLP_USERDATA, (LONG_PTR)this);

            switch (i)
            {
                case FIRST_WINDOW:
                    SetWindowLongPtr(m_CompWnd[FIRST_WINDOW].hCompWnd, COMPUI_WINDOW_INDEX, FIRST_WINDOW);
                    break;
                case MIDDLE_WINDOW:
                    SetWindowLongPtr(m_CompWnd[MIDDLE_WINDOW].hCompWnd, COMPUI_WINDOW_INDEX, MIDDLE_WINDOW);
                    break;
                case LAST_WINDOW:
                    SetWindowLongPtr(m_CompWnd[LAST_WINDOW].hCompWnd, COMPUI_WINDOW_INDEX, LAST_WINDOW);
                    break;
            }

            m_CompWnd[i].caret.CreateCaret(m_CompWnd[i].hCompWnd, m_caret_size);
        }

        if (FAILED(CreateCompButtonWnd(hUIWnd, (HIMC)imc)))
        {
            DestroyCompositionWindow();
            DebugMsg(TF_ERROR, TEXT("UIComposition::Create. m_pCompButtonFrameWindow==NULL"));
            return E_OUTOFMEMORY;
        }

        if (FAILED(CreateDefFrameWnd(hUIWnd, (HIMC)imc)))
        {
            DestroyCompositionWindow();
            DebugMsg(TF_ERROR, TEXT("UIComposition::Create. m_pDefFrameWindow==NULL"));
            return E_OUTOFMEMORY;
        }

        //
        // Create default composition window
        //
        Assert(!m_DefCompWnd.hCompWnd);
        m_DefCompWnd.hCompWnd = CreateWindowExW(WS_EX_CLIENTEDGE,
                                               s_szCompClassName,
                                               NULL,
                                               WS_CHILD | WS_DISABLED,
                                               0, 0, 0, 0,
                                               m_pDefCompFrameWnd->GetWnd(),
                                               NULL,
                                               GetInstance(),
                                               NULL);
        if (m_DefCompWnd.hCompWnd == NULL)
        {
            DestroyCompositionWindow();
            DebugMsg(TF_ERROR, TEXT("UIComposition::Create. m_DefCompWnd.hCompWnd==NULL"));
            return E_OUTOFMEMORY;
        }

        m_pDefCompFrameWnd->SetCompStrWnd(m_DefCompWnd.hCompWnd);

        SetWindowLongPtr(m_DefCompWnd.hCompWnd, GWLP_USERDATA, (LONG_PTR)this);
        SetWindowLongPtr(m_DefCompWnd.hCompWnd, COMPUI_WINDOW_INDEX, DEFAULT_WINDOW);

        m_DefCompWnd.caret.CreateCaret(m_DefCompWnd.hCompWnd, m_caret_size);

        //
        // Final: set flag
        //
        m_fInitUIComp.SetFlag();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// UIComposition::DestroyCompositionWindow
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::DestroyCompositionWindow()
{
    for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
    {
        m_CompWnd[i].caret.DestroyCaret();

        if (IsWindow(m_CompWnd[i].hCompWnd))
        {
            DestroyWindow(m_CompWnd[i].hCompWnd);
            m_CompWnd[i].poly_text.RemoveAll();
        }
        m_CompWnd[i].hCompWnd = NULL;
    }

    if (m_pCompButtonFrameWnd)
    {
        DestroyWindow(m_pCompButtonFrameWnd->GetWnd());
        delete m_pCompButtonFrameWnd;
        m_pCompButtonFrameWnd = NULL;
    }

    m_DefCompWnd.caret.DestroyCaret();

    if (IsWindow(m_DefCompWnd.hCompWnd))
    {
        DestroyWindow(m_DefCompWnd.hCompWnd);
        m_DefCompWnd.poly_text.RemoveAll();

    }
    if (m_pDefCompFrameWnd)
    {
        DestroyWindow(m_pDefCompFrameWnd->GetWnd());
        delete m_pDefCompFrameWnd;
        m_pDefCompFrameWnd = NULL;
    }
    m_DefCompWnd.hCompWnd = NULL;

    m_fInitUIComp.ResetFlag();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::HideCompositionWindow
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::HideCompositionWindow()
{
    for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
    {
        if (IsWindow(m_CompWnd[i].hCompWnd))
        {
            ShowWindow(m_CompWnd[i].hCompWnd, SW_HIDE);
        }
    }

    if (IsWindow(m_DefCompWnd.hCompWnd))
    {
        ShowWindow(m_DefCompWnd.hCompWnd, SW_HIDE);
    }

    if (m_pDefCompFrameWnd)
        m_pDefCompFrameWnd->Show(FALSE);

    if (m_pCompButtonFrameWnd)
        m_pCompButtonFrameWnd->Show(FALSE);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::GetSelection
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::GetSelection(
    IMCLock& imc,
    LONG *pacpSelStart,
    LONG *pcchSel)
{
    HRESULT hr;
    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnSetCursor. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnSetCursor. _pCicContext==NULL"));
        return hr;
    }

    *pacpSelStart = 0;
    *pcchSel = 0;
    Interface<ITfRange> Selection;
    Interface<ITfRangeACP> SelectionACP;

    hr = _pCicContext->EscbGetSelection(imc, &Selection);
    if (hr == S_OK)
    {
        hr = Selection->QueryInterface(IID_ITfRangeACP, (void **)SelectionACP);
        if (hr == S_OK)
        {
            hr = SelectionACP->GetExtent(pacpSelStart, pcchSel);
        }
    }

    //
    // if there is no selection, we don't have to check ReadOnly area.
    //
    if (*pcchSel == 0)
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    // pacpSelSrart is the offset of the composition string,
    // so we need to subtract the range of the readonly area.
    //
    LONG cchRO = 0;
    hr = _pCicContext->EscbReadOnlyPropMargin(imc, &SelectionACP, &cchRO);
    if (hr == S_OK)
    {
        if (cchRO <= *pacpSelStart)
        {
            *pacpSelStart -= cchRO;
        }
        else
        {
            //
            // our selection is overwrapped to Read Only area. Why?
            //
            Assert(0);
            *pacpSelStart = 0;
            *pcchSel = 0;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::UpdateShowCompWndFlag
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::UpdateShowCompWndFlag(
    IMCLock& imc,
    DWORD* pdwCompStrLen)
{
    HRESULT hr;

    //
    // Validation check of imc.
    // Because CIMEUIWindowHandler::ImeUIWndProcWorker doesn't check.
    //
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateShowCompWndFlag. imc==NULL"));
        return hr;
    }

    if (! IsWindow(imc->hWnd))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateShowCompWndFlag. imc->hWNd==NULL"));
        return E_FAIL;
    }

    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateShowCompWndFlag. comp==NULL"));
        return hr;
    }

    if ((m_isc & ISC_SHOWUICOMPOSITIONWINDOW) && comp->dwCompStrLen)
    {
        m_fShowCompWnd.SetFlag();
    }
    else
    {
        m_fShowCompWnd.ResetFlag();
    }

    if (pdwCompStrLen)
        *pdwCompStrLen = comp->dwCompStrLen;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::UpdateCompositionRect
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::UpdateCompositionRect(
    IMCLock& imc)
{
    HRESULT hr;

    //
    // Validation check of imc.
    // Because CIMEUIWindowHandler::ImeUIWndProcWorker doesn't check.
    //
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateCompositionRect. imc==NULL"));
        return hr;
    }

    if (! IsWindow(imc->hWnd))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateCompositionRect. imc->hWNd==NULL"));
        return E_FAIL;
    }

    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateCompositionRect. comp==NULL"));
        return hr;
    }

    //
    // Get Selection.
    //
    LONG acpSelStart = 0;
    LONG cchSel = 0;
    GetSelection(imc, &acpSelStart, &cchSel);


    //
    // Update show composition flag
    //
    DWORD   dwCompLen = 0;
    UpdateShowCompWndFlag(imc, &dwCompLen);

    //
    // Allocate temp composition string buffer
    //
    LPWSTR lpCompStr;
    lpCompStr = GetCompStrBuffer(comp->dwCompStrLen);
    if (!lpCompStr)
        return E_OUTOFMEMORY;

    //
    // Store composition string in local buffer
    //
    memcpy(lpCompStr, 
           comp.GetOffsetPointer(comp->dwCompStrOffset),
           dwCompLen * sizeof(WCHAR));


    UINT fSwpShow = m_fShowCompWnd.IsSetFlag() ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;

    IME_UIWND_STATE uiwndState = GetLevelFromIMC(imc);
    if (uiwndState == IME_UIWND_LEVEL1)
    {
        //
        // When the style is DEFAULT, show the default composition window.
        //
        if (IsWindow(m_DefCompWnd.hCompWnd))
        {
            POLYTEXTW poly;
            memset(&poly, 0, sizeof(poly));
            poly.n     = dwCompLen;
            poly.lpstr = (LPCWSTR)lpCompStr;
            poly.uiFlags = ETO_OPAQUE;

            SIZE size;
            HDC hDC = GetDC(m_DefCompWnd.hCompWnd);
            HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel1);
            FLGetTextExtentPoint32(hDC, poly.lpstr, poly.n, &size);

            poly.rcl.right  = size.cx + 2 * GetSystemMetrics(SM_CXEDGE);
            poly.rcl.bottom = size.cy + 2 * GetSystemMetrics(SM_CYEDGE);

            BOOL fShowCaret = (comp->dwCursorPos <= poly.n ? TRUE : FALSE);
            BOOL fEndCaret  = (comp->dwCursorPos == poly.n ? TRUE : FALSE);

            if (m_pDefCompFrameWnd)
            {
                m_pDefCompFrameWnd->SetCompStrRect(poly.rcl.right - poly.rcl.left + (fEndCaret ? m_caret_size.cx * 2: 0),
                                                      poly.rcl.bottom - poly.rcl.top + LINE_BOLD_WIDTH,
                                                      m_fShowCompWnd.IsSetFlag());
            }

            GuidMapAttribute guid_map(GuidMapAttribute::GetData(comp));
            if (guid_map.Valid())
            {
                Assert(poly.n == guid_map->dwGuidMapAttrLen);
                m_DefCompWnd.poly_text.RemoveAll();

                PBYTE lpCompAttr = (PBYTE)guid_map.GetOffsetPointer(guid_map->dwGuidMapAttrOffset);
                CCompClauseStore compclause;
                compclause.Set(comp);

                m_DefCompWnd.poly_text.SplitPolyStringAndAttr(imc, hDC, poly, lpCompAttr, &compclause);
            }
            else
            {
                m_DefCompWnd.poly_text.RemoveAll();

                m_DefCompWnd.poly_text.SplitPolyStringAndAttr(imc, hDC, poly);
            }

            if (fShowCaret)
            {
                SetCaretPos(hDC, m_DefCompWnd.caret,
                            0, 0,
                            poly.lpstr, poly.n, comp->dwCursorPos, 
                            FALSE, fEndCaret);
            }

            //
            // Save Selection acp and cch
            //
            m_DefCompWnd.sel.acpStart = acpSelStart;
            m_DefCompWnd.sel.cch      = cchSel;

            SelectObject(hDC, hFontOrg);
            ReleaseDC(m_DefCompWnd.hCompWnd, hDC);

            InvalidateRect(m_DefCompWnd.hCompWnd, NULL, FALSE);
        }

        for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
        {
            if (IsWindow(m_CompWnd[i].hCompWnd))
            {
                ShowWindow(m_CompWnd[i].hCompWnd, SW_HIDE);
            }
        }

        if (m_pCompButtonFrameWnd)
        {
            m_pCompButtonFrameWnd->MoveShow(0, 0, FALSE);
        }
    }
    else if (uiwndState == IME_UIWND_LEVEL2)
    {
        //
        // When the style is not DEFAULT, show the composition window.
        //
        POINT pt = imc->cfCompForm.ptCurrentPos;
        //
        // Set the rectangle for the composition string.
        //
        RECT rect;
        if (imc->cfCompForm.dwStyle & CFS_RECT)
            rect = imc->cfCompForm.rcArea;
        else
            GetClientRect(imc->hWnd, &rect);

        ClientToScreen(imc->hWnd, &pt);
        MapWindowPoints(imc->hWnd, NULL, (LPPOINT)&rect, 2);
        //
        // Check the start position.
        //
        if (! PtInRect(&rect, pt))
            return E_FAIL;

        DWORD   dwCursorPos = comp->dwCursorPos;

        CCompClauseStore compclause;
        compclause.Set(comp);

        GuidMapAttribute guid_map(GuidMapAttribute::GetData(comp));

        PBYTE lpCompAttr;
        BOOL fCompAttr = TRUE;

        if (guid_map.Valid())
        {
            lpCompAttr = (PBYTE)guid_map.GetOffsetPointer(guid_map->dwGuidMapAttrOffset);
            Assert(dwCompLen == guid_map->dwGuidMapAttrLen);
        }
        else
        {
            TLS* ptls = TLS::GetTLS();
            if (ptls)
            {
                CicProfile* pProfile;
                if (pProfile = ptls->GetCicProfile())
                {
                    LANGID langid;
                    pProfile->GetLangId(&langid);
                    if (PRIMARYLANGID(langid) == LANG_KOREAN)
                    {
                        fCompAttr = FALSE;
                    }
                }
             }

             if (fCompAttr)
                 return E_FAIL;
        }

        {
            //
            // composition window
            //
            POINT compbtn_pos = {0,0};
            BOOL fInitcompbtn_pos = FALSE;
            POINT window_pos;
            window_pos = pt;

            int window_width;
            if (!imc.UseVerticalCompWindow())
            {
                window_width = rect.right - pt.x;
            }
            else
            {
                window_width = rect.bottom - pt.y;
            }

            UINT string_length;

            int i;
            for (i = 0; i < sizeof(m_CompWnd)/sizeof(COMPWND) && dwCompLen > 0; i++)
            {
                m_CompWnd[i].caret.HideCaret();

                m_CompWnd[i].poly_text.RemoveAll();

                //
                // Init Selection acp and cch
                //
                m_CompWnd[i].sel.acpStart = 0;
                m_CompWnd[i].sel.cch      = 0;

                SIZE size;
                size.cy = 0;
                if (IsWindow(m_CompWnd[i].hCompWnd))
                {
                    HDC hDC = GetDC(m_CompWnd[i].hCompWnd);
                    HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel2);
                    if (i != MIDDLE_WINDOW)
                    {
                        string_length = CalcSingleTextExtentPoint(imc, hDC, lpCompStr, dwCompLen,
                                                                  lpCompAttr,
                                                                  fCompAttr,
                                                                  &compclause,
                                                                  window_width, &size,
                                                                  m_CompWnd[i].poly_text, 0);
                    }
                    else
                    {
                        string_length = CalcMultiTextExtentPoint(imc, hDC, lpCompStr, dwCompLen,
                                                                 lpCompAttr,
                                                                 fCompAttr,
                                                                 &compclause,
                                                                 window_width, &size,
                                                                 m_CompWnd[i].poly_text);
                    }

                    if (string_length)
                    {
                        BOOL fShowCaret = (dwCursorPos <= string_length ? TRUE : FALSE);
                        BOOL fEndCaret  = (dwCursorPos == string_length ? TRUE : FALSE);

                        int pos_x = window_pos.x;
                        int pos_y = window_pos.y;
                        int cx;
                        int cy;
 
                        if (!imc.UseVerticalCompWindow())
                        {
                            cx = size.cx + (fEndCaret ? m_caret_size.cx: 0);
                            cy = size.cy;
                        }
                        else
                        {
                            pos_x -= size.cx;
                            cx = size.cx;
                            cy = size.cy + (fEndCaret ? m_caret_size.cy: 0);
                        }

                        SetWindowPos(m_CompWnd[i].hCompWnd, HWND_TOP,
                                     pos_x, pos_y, cx, cy,
                                     SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOACTIVATE |
                                     fSwpShow);

                        if (fShowCaret)
                        {
                            UpdateCaretRect(hDC, i, dwCursorPos, imc.UseVerticalCompWindow(), fEndCaret);
                            dwCursorPos = ULONG_MAX;
                        }
                        else
                        {
                            dwCursorPos -= string_length;
                        }

                        //
                        // Save Selection acp and cch for this COMPWND
                        //
                        if (cchSel && (acpSelStart < (LONG)string_length))
                        {
                            m_CompWnd[i].sel.acpStart = acpSelStart;
                            LONG cchSelTemp = cchSel;
                            if (acpSelStart + cchSel > (LONG)string_length)
                                cchSelTemp = string_length - acpSelStart;

                            m_CompWnd[i].sel.cch      = cchSelTemp;

                            //
                            // update cchSel for next COMPWND
                            //
                            cchSel -= cchSelTemp;
                            if (cchSel < 0)
                                cchSel = 0;
                        }


                        //
                        // set level2 comp finalizing button position.
                        //
                        compbtn_pos.x = pos_x + cx;
                        compbtn_pos.y = pos_y;
                        fInitcompbtn_pos = TRUE;

                        //
                        // update CompStr, CompAttr, CompClause for next COMPWND
                        //
                        lpCompStr += string_length;
                        dwCompLen -= string_length;
                        if (fCompAttr)
                        {
                            lpCompAttr += string_length;
                            compclause.Shift(string_length);
                        }

                        //
                        // update acpSelStart for next COMPWND
                        //
                        acpSelStart -= string_length;
                        if (acpSelStart < 0)
                            acpSelStart = 0;
                    }
                    else
                    {
                        ShowWindow(m_CompWnd[i].hCompWnd, SW_HIDE);
                        m_CompWnd[i].poly_text.RemoveAll();
                    }

                    SelectObject(hDC, hFontOrg);
                    ReleaseDC(m_CompWnd[i].hCompWnd, hDC);

                    InvalidateRect(m_CompWnd[i].hCompWnd, NULL, FALSE);
                }

                if (!imc.UseVerticalCompWindow())
                {
                    window_pos.x = rect.left;
                    window_pos.y += size.cy;

                    window_width = rect.right - rect.left;

                    rect.top += size.cy;
                }
                else
                {
                    window_pos.x -= size.cx;
                    window_pos.y = rect.top;

                    window_width = rect.bottom - rect.top;

                    rect.left -= size.cx;
                }

            }

            //
            // hide the remaining window.
            //
            for (; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
            {
                if (IsWindow(m_CompWnd[i].hCompWnd))
                    ShowWindow(m_CompWnd[i].hCompWnd, SW_HIDE);
                m_CompWnd[i].poly_text.RemoveAll();
            }
            if (IsWindow(m_DefCompWnd.hCompWnd))
            {
                ShowWindow(m_DefCompWnd.hCompWnd, SW_HIDE);
            }

            if (m_pDefCompFrameWnd)
                m_pDefCompFrameWnd->Show(FALSE);

            if (m_pCompButtonFrameWnd)
            {
                m_pCompButtonFrameWnd->MoveShow(compbtn_pos.x, 
                                                compbtn_pos.y, 
                                                m_fShowCompWnd.IsSetFlag() && fInitcompbtn_pos);
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::UpdateFont
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::UpdateFont(
    IMCLock& imc)
{
    HRESULT hr;

    //
    // Validation check of imc.
    // Because CIMEUIWindowHandler::ImeUIWndProcWorker doesn't check.
    //
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::UpdateFont. imc==NULL"));
        return hr;
    }

    if (m_hFontLevel1)
        DeleteObject(m_hFontLevel1);

    if (m_hFontLevel2)
        DeleteObject(m_hFontLevel2);

    LOGFONTW logfont = imc->lfFont.W;

    m_hFontLevel2 = CreateFontIndirectW(&logfont);

    logfont.lfEscapement = 0;
    logfont.lfOrientation = 0;
    if (logfont.lfFaceName[0] == L'@')
    {
        StringCchCopyW(logfont.lfFaceName, ARRAYSIZE(logfont.lfFaceName), &logfont.lfFaceName[1]);
    }
    m_hFontLevel1 = CreateFontIndirectW(&logfont);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnPaint
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnPaint(
    TLS* ptls,
    HWND hCompWnd,
    HDC hDC,
    PAINTSTRUCT& ps,
    IMCLock& imc)
{

    HRESULT hr = S_OK;
    COMPWNDINDEX index = (COMPWNDINDEX)GetWindowLong(hCompWnd, COMPUI_WINDOW_INDEX);

    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnPaint. comp==NULL"));
    }
    else
    {
        IME_UIWND_STATE uiwndState = GetLevelFromIMC(imc);

        if ((uiwndState == IME_UIWND_LEVEL1) &&
            (index == DEFAULT_WINDOW))
        {
            HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel1);

            PolyTextAndAttrOut(ptls, 
                               hDC, 
                               FALSE, 
                               &m_DefCompWnd);
            SelectObject(hDC, hFontOrg);
        }
        else if ((uiwndState == IME_UIWND_LEVEL2) &&
                 (index != DEFAULT_WINDOW))
        {
            if (m_CompWnd[index].poly_text.GetPolySize())
            {
                HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel2);
                PolyTextAndAttrOut(ptls, 
                                   hDC, 
                                   imc.UseVerticalCompWindow(),
                                   &m_CompWnd[index]);
                SelectObject(hDC, hFontOrg);
            }
        }
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnTimer
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnTimer(
    HWND hCompWnd)
{
    HRESULT hr = S_OK;
    COMPWNDINDEX index = (COMPWNDINDEX)GetWindowLong(hCompWnd, COMPUI_WINDOW_INDEX);

    if (index == DEFAULT_WINDOW)
    {
        return m_DefCompWnd.caret.OnTimer();
    }
    else
    {
        return m_CompWnd[index].caret.OnTimer();
    }
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeNotifySetCompositionWindow
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeNotifySetCompositionWindow(
    IMCLock& imc)
{
    return UpdateCompositionRect(imc);
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnImeNotifySetCompositionFont
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnImeNotifySetCompositionFont(
    IMCLock& imc)
{
    HRESULT hr;

    if (FAILED(hr = UpdateFont(imc)))
         return hr;

    return UpdateCompositionRect(imc);
}

//+---------------------------------------------------------------------------
//
// UIComposition::CalcSingleTextExtentPoint
//
//+---------------------------------------------------------------------------

UINT
UIComposition::CalcSingleTextExtentPoint(
    IMCLock& imc,
    HDC hDC,
    LPCWSTR lpsz,
    int string_len,
    PBYTE lpAttr,
    BOOL fCompAttr,
    CCompClauseStore* compclause,
    int window_width,
    LPSIZE real_size,        // OUTPUT: Total window rectangle
    CPolyText& poly_text,
    int row_index)
{
    if (string_len == 0 || lpsz == NULL)
    {
        return 0;
    }


    SIZE delta_size;
    delta_size.cx = 0;

    UINT ret_len = 0;
    UINT delta_len = 0;
    SIZE size;

    while ((delta_size.cx < window_width) && string_len)
    {
        ++delta_len;
        --string_len;
        FLGetTextExtentPoint32(hDC, lpsz, delta_len, &size);
        delta_size = size;
    }

    if (delta_size.cx < window_width)
    {
        ret_len = delta_len;
    }
    else
    {
        ret_len = (delta_len > 1 ? delta_len - 1 : 0);
    }

    if (ret_len)
    {
        FLGetTextExtentPoint32(hDC, lpsz, ret_len, real_size);
    }
    else
    {
        //
        // if string length is 0, we should return just the height.
        //
        real_size->cx = 0;
        real_size->cy = delta_size.cy;
    }

    if (!imc.UseVerticalCompWindow())
    {
        if (ret_len > 0)
        {
            real_size->cy += LINE_BOLD_WIDTH;

            POLYTEXTW poly;
            memset(&poly, 0, sizeof(poly));
            poly.y     = row_index * real_size->cy;
            poly.n     = ret_len;
            poly.lpstr = lpsz;
            poly.uiFlags = ETO_OPAQUE;
            poly.rcl.top    = row_index * real_size->cy;
            poly.rcl.right  = real_size->cx;
            poly.rcl.bottom = poly.rcl.top + real_size->cy;
            if (fCompAttr)
                poly_text.SplitPolyStringAndAttr(imc, hDC, poly, lpAttr, compclause);
            else
                poly_text.SplitPolyStringAndAttr(imc, hDC, poly);
        }
    }
    else
    {
        RotateSize(real_size);

        if (ret_len > 0)
        {
            real_size->cx += LINE_BOLD_WIDTH;

            //
            // shift prev lines to the right.
            //
            poly_text.ShiftPolyText(real_size->cx, 0);

            POLYTEXTW poly;
            memset(&poly, 0, sizeof(poly));
            poly.x     = real_size->cx;
            poly.n     = ret_len;
            poly.lpstr = lpsz;
            poly.uiFlags = ETO_OPAQUE;
            poly.rcl.left   = 0;
            poly.rcl.right  = poly.rcl.left + real_size->cx;
            poly.rcl.bottom = real_size->cy;
            if (fCompAttr)
                poly_text.SplitPolyStringAndAttr(imc, hDC, poly, lpAttr, compclause);
            else
                poly_text.SplitPolyStringAndAttr(imc, hDC, poly);
        }
    }

    //
    // #608684
    //
    // the total size of poly text could be bigger than the result of
    // FLGetTextExtentPoint() with whole string. So we need to
    // adjust the returning size.
    //
    if (ret_len)
    {
        int real_width = 0;
        INT_PTR i;
        INT_PTR nCnt = poly_text.GetPolySize();
        const POLYTEXTW* ppoly = poly_text.GetPolyData();
        if (!imc.UseVerticalCompWindow())
        {
            for (i = 0; i < nCnt; i++)
            {
                if (ppoly->rcl.top == (row_index * real_size->cy))
                    real_width += (ppoly->rcl.right - ppoly->rcl.left);

                ppoly++;
            }

            Assert(window_width >= real_width);
            real_size->cx = real_width;
        }
        else
        {
            for (i = 0; i < nCnt; i++)
            {
                if (ppoly->rcl.left == 0)
                    real_width += (ppoly->rcl.bottom - ppoly->rcl.top);

                ppoly++;
            }

            Assert(window_width >= real_width);
            real_size->cy = real_width;
        }
    }

    return ret_len;
}

//+---------------------------------------------------------------------------
//
// UIComposition::CalcMultiTextExtentPoint
//
//+---------------------------------------------------------------------------

UINT
UIComposition::CalcMultiTextExtentPoint(
    IMCLock& imc,
    HDC hDC,
    LPCWSTR lpsz,
    int string_len,
    PBYTE lpAttr,
    BOOL fCompAttr,
    CCompClauseStore *compclause,
    int window_width,
    LPSIZE real_size,        // OUTPUT: Total window rectangle
    CPolyText& poly_text)
{
    SIZE single_size;        // output single window rectangle from CalcSingleTextExtentPoint
    single_size.cy = 0;
    single_size.cx = 0;
    UINT single_len;

    UINT total_string_len = 0;
    SIZE prev_size = {0, 0};
    UINT prev_string_len = 0;

    real_size->cx = 0;
    real_size->cy = 0;

    int row_index = 0;
    CCompClauseStore compclauseTmp;
    compclauseTmp.Copy(compclause);

    if (!imc.UseVerticalCompWindow())
    {
        while ((single_len = CalcSingleTextExtentPoint(imc, hDC, lpsz, string_len, lpAttr, fCompAttr, &compclauseTmp, window_width, &single_size, poly_text, row_index)) > 0)
        {
            string_len -= single_len;
            lpsz       += single_len;

            if (fCompAttr)
            {
                lpAttr     += single_len;
                compclauseTmp.Shift(single_len);
            }

            real_size->cx = max(real_size->cx, single_size.cx);
            real_size->cy += single_size.cy;

            prev_size = single_size;
            prev_string_len = single_len;

            total_string_len += single_len;

            ++row_index;
        }

        real_size->cy -= prev_size.cy;
        total_string_len -= prev_string_len;
        poly_text.RemoveLastLine(FALSE);
    }
    else
    {
        while ((single_len = CalcSingleTextExtentPoint(imc, hDC, lpsz, string_len, lpAttr, fCompAttr, &compclauseTmp, window_width, &single_size, poly_text, row_index)) > 0)
        {
            string_len -= single_len;
            lpsz       += single_len;

            if (fCompAttr)
            {
                lpAttr     += single_len;
                compclauseTmp.Shift(single_len);
            }

            real_size->cy = max(real_size->cy, single_size.cy);
            real_size->cx += single_size.cx;

            prev_size = single_size;
            prev_string_len = single_len;

            total_string_len += single_len;

            ++row_index;
        }

        real_size->cx -= prev_size.cx;
        total_string_len -= prev_string_len;

        if (poly_text.RemoveLastLine(TRUE) == S_OK)
            poly_text.ShiftPolyText(-single_size.cx, 0);
    }


    return total_string_len;
}

//+---------------------------------------------------------------------------
//
// UIComposition::SetCaretPos
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::SetCaretPos(
    HDC hDC,
    CCaret& caret,
    int x,
    int y,
    LPCWSTR lpCompStr,
    DWORD string_length,
    DWORD cursor_pos,
    BOOL fVert,
    BOOL fEndCaret)
{
    if (cursor_pos > string_length)
        return S_FALSE;

    SIZE size;
    FLGetTextExtentPoint32(hDC, lpCompStr, cursor_pos, &size);

    POINT pos;
    if (!fVert)
    {
        pos.x = ((x + size.cx > 1) ? (x + size.cx - (fEndCaret ? 0 : 1)) : 0);
        pos.y = y;
    }
    else
    {
        RotateSize(&size);
        pos.x = x - size.cx - LINE_BOLD_WIDTH;
        pos.y = ((y + size.cy > 1) ? (y + size.cy - (fEndCaret ? 0 : 1)) : 0);
    }
    caret.SetCaretPos(pos);
    caret.ShowCaret();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::UpdateCaretRect
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::UpdateCaretRect(
    HDC hDC,
    int index,
    DWORD dwCursorPos,    // dwCursorPos:: based on m_CompWnd[index].poly_text.lpstr
    BOOL fVert,
    BOOL fEndCaret)
{
    POLYTEXTW poly;
    DWORD dwCur = dwCursorPos;
    BOOL fFound = FALSE;

    for (int i=0; i < m_CompWnd[index].poly_text.GetPolySize(); i++)
    {
        poly = m_CompWnd[index].poly_text.GetPolyAt(i);
        if (dwCur <= poly.n)
        {
            fFound = TRUE;
            break;
        }
        dwCur -= poly.n;
    }
    if (! fFound)
    {
        return S_FALSE;
    }

    SetCaretPos(hDC, m_CompWnd[index].caret,
                poly.x, poly.y,
                poly.lpstr, poly.n,
                dwCur, fVert, fEndCaret);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::PolyTextAndAttrOut
//
//+---------------------------------------------------------------------------

const DWORD s_dwDotStyles[]  = {1,2};
const DWORD s_dwDashStyles[] = {3,2};

HRESULT
UIComposition::PolyTextAndAttrOut(
    TLS* ptls,
    HDC hDC,
    BOOL fVert, 
    COMPWND* pcompwnd)
{
    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        Internal_PolyTextOutW(hDC, pcompwnd->poly_text.GetPolyData(), (int)pcompwnd->poly_text.GetPolySize());

        DebugMsg(TF_ERROR, TEXT("UIComposition::PolyTextAndAttrOut. cic==NULL"));
        return S_OK;
    }

    if (pcompwnd->poly_text.GetAttrSize() == 0)
    {
        //
        // Korean default composition window.
        //
        SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        Internal_PolyTextOutW(hDC, pcompwnd->poly_text.GetPolyData(), (int)pcompwnd->poly_text.GetPolySize());

        return S_OK;
    }

    RECT rect;
    GetClientRect(pcompwnd->hCompWnd, &rect);
    LONG acpStart = 0;

    for (int i = 0; i < pcompwnd->poly_text.GetAttrSize(); i++)
    {
        POLYTEXTW poly = pcompwnd->poly_text.GetPolyAt(i);

        //
        // Check if this is the last in this line.
        //
        BOOL fLastTextInLine = FALSE;
        if (i + 1 < pcompwnd->poly_text.GetAttrSize())
        {
            POLYTEXTW poly_next = pcompwnd->poly_text.GetPolyAt(i+1);
            if (!fVert && (poly_next.x < poly.rcl.right))
                fLastTextInLine = TRUE;
            else if (fVert && (poly_next.y < poly.rcl.bottom))
                fLastTextInLine = TRUE;
        }
        else
        {
            fLastTextInLine = TRUE;
        }

        TF_DISPLAYATTRIBUTE da;
        BOOL fDapNotFound = FALSE;

        if (FAILED(cic->GetDisplayAttributeInfo(pcompwnd->poly_text.GetAttrAt(i), &da)))
        { 
            memset(&da, 0, sizeof(da));
            da.lsStyle = TF_LS_DOT;
            da.crLine.type = TF_CT_SYSCOLOR;
            da.crLine.nIndex = COLOR_WINDOWTEXT;
            fDapNotFound= TRUE;
        }

        //
        // Text and Back color.
        //
        switch (da.crText.type)
        {
            case TF_CT_SYSCOLOR: SetTextColor(hDC, GetSysColor(da.crText.nIndex)); break;
            case TF_CT_COLORREF: SetTextColor(hDC, da.crText.cr); break;
            default: SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); break;
        }
        switch (da.crBk.type)
        {
            case TF_CT_SYSCOLOR: SetBkColor(hDC, GetSysColor(da.crBk.nIndex)); break;
            case TF_CT_COLORREF: SetBkColor(hDC, da.crBk.cr); break;
            default: SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); break;
        }

        //
        // Line
        //

        DWORD dwPenStyle = PS_GEOMETRIC | PS_SOLID;
        DWORD dwStyles = 0;
        const DWORD *lpdwStyles = NULL;
        switch (da.lsStyle)
        {
            case TF_LS_NONE:    
                dwPenStyle = PS_NULL; 
                break;

            case TF_LS_SOLID:   
                dwPenStyle = PS_GEOMETRIC | PS_SOLID;
                break;

            case TF_LS_DOT:     
                dwPenStyle = PS_GEOMETRIC | PS_USERSTYLE;
                dwStyles = 2; 
                lpdwStyles = s_dwDotStyles; 
                break;

            case TF_LS_DASH:    
                dwPenStyle = PS_GEOMETRIC | PS_USERSTYLE;
                dwStyles = 2; 
                lpdwStyles = s_dwDashStyles; 
                break;

            case TF_LS_SQUIGGLE: 
                dwPenStyle = PS_GEOMETRIC | PS_SOLID;
                break;
        }


        DWORD dwWidth = 1;
        if (da.fBoldLine)
        {
            dwWidth = LINE_BOLD_WIDTH;
        }

        LOGBRUSH lbr;
        lbr.lbStyle = BS_SOLID;
        lbr.lbColor = 0;
        lbr.lbHatch = 0;
        switch (da.crLine.type)
        {
            case TF_CT_SYSCOLOR: lbr.lbColor = GetSysColor(da.crLine.nIndex); break;
            case TF_CT_COLORREF: lbr.lbColor = da.crLine.cr; break;
            case TF_CT_NONE:     lbr.lbColor = GetTextColor(hDC); break;
        }

        HPEN hPen = ExtCreatePen(dwPenStyle, dwWidth, &lbr, dwStyles, lpdwStyles);
        if (hPen != NULL)
        {
            HPEN hPenOrg = (HPEN)SelectObject(hDC, hPen);

            Internal_PolyTextOutW(hDC, &poly, 1);

            SIZE size;
            FLGetTextExtentPoint32(hDC, poly.lpstr, poly.n, &size);

            POINT start_pt;
            POINT end_pt;
            if (!fVert)
            {
                start_pt.x = poly.x;
                start_pt.y = poly.y + size.cy;
                //
                // (size.cy / 4) is the gap between clauses.
                //
                end_pt.x = poly.rcl.right;
                if (!fLastTextInLine)
                    end_pt.x -= (size.cy / 4);

                end_pt.y = start_pt.y;
            }
            else
            {
                RotateSize(&size);

                start_pt.x = poly.rcl.left + 1;
                start_pt.y = poly.y;
                end_pt.x = poly.rcl.left + 1;

                //
                // (size.cx / 4) is the gap between clauses.
                //
                end_pt.y = poly.rcl.bottom;
                if (!fLastTextInLine)
                    end_pt.y -= (size.cx / 4);
            }


            MoveToEx(hDC, start_pt.x, start_pt.y, NULL);

            if (da.lsStyle != TF_LS_SQUIGGLE)
            {
                LineTo(hDC, end_pt.x, end_pt.y);
            }
            else
            {
                CArray<POINT, POINT> squiggle_line;
                MakeSquiggleLine(start_pt, end_pt, LINE_SQUIGGLE_FREQUENCY, LINE_SQUIGGLE_AMPLITUDE, fVert, squiggle_line);
                Polyline(hDC, squiggle_line.GetData(), (int)squiggle_line.GetSize());
            }

            SelectObject(hDC, hPenOrg);
            DeleteObject(hPen);
        }
        else
        {
            Assert(0);
            Internal_PolyTextOutW(hDC, &poly, 1);
        }

        //
        // Draw Selection.
        //
        if (fDapNotFound && pcompwnd->sel.cch &&
            ((acpStart + (LONG)poly.n) >  pcompwnd->sel.acpStart) &&
            (acpStart <=  pcompwnd->sel.acpStart + pcompwnd->sel.cch))
        {
            LONG acpSelStartTemp;
            LONG cchSelTemp;

            acpSelStartTemp = pcompwnd->sel.acpStart - acpStart;
            if (acpSelStartTemp < 0)
                acpSelStartTemp = 0;

            cchSelTemp = pcompwnd->sel.acpStart + pcompwnd->sel.cch - acpStart - acpSelStartTemp;
            if (cchSelTemp > (LONG)poly.n)
                cchSelTemp = poly.n;


            SIZE sizeStart;
            SIZE sizeEnd;
            if (acpSelStartTemp)
            {
                FLGetTextExtentPoint32(hDC, 
                                      poly.lpstr, 
                                      acpSelStartTemp, 
                                      &sizeStart);
            }
            else
            {
                sizeStart.cx = 0;
                sizeStart.cy = pcompwnd->fDefaultCompWnd ? 
                               m_tmFontHeightLevel1 : m_tmFontHeightLevel2;
            }

            FLGetTextExtentPoint32(hDC, 
                                  poly.lpstr, 
                                  acpSelStartTemp + cchSelTemp, 
                                  &sizeEnd);

            RECT rcInvert;
            rcInvert = poly.rcl;
            if (!fVert)
            {
                rcInvert.left = poly.rcl.left + sizeStart.cx;
                rcInvert.right = poly.rcl.left + sizeEnd.cx;
            }
            else
            {
                rcInvert.top = poly.rcl.top + sizeStart.cx;
                rcInvert.bottom = poly.rcl.top + sizeEnd.cx;
            }

            BitBlt(hDC,
                   rcInvert.left,
                   rcInvert.top,
                   rcInvert.right - rcInvert.left,
                   rcInvert.bottom - rcInvert.top,
                   hDC,
                   rcInvert.left,
                   rcInvert.top,
                   DSTINVERT);
        }

        if (fLastTextInLine)
        {
            //
            // if this is the last in this line, we just draw with bk color.
            //
            POLYTEXTW poly_clear;
            memset(&poly_clear, 0, sizeof(poly_clear));
            if (!fVert)
            {
                SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
                poly_clear.uiFlags = ETO_OPAQUE;
                poly_clear.rcl.top = poly.y;
                poly_clear.rcl.bottom = poly.rcl.bottom;
                poly_clear.rcl.left = poly.rcl.right;
                poly_clear.rcl.right = rect.right;
                Internal_PolyTextOutW(hDC, &poly_clear, 1);
            }
            else
            {
                SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
                poly_clear.uiFlags = ETO_OPAQUE;
                poly_clear.rcl.top = poly.rcl.bottom;
                poly_clear.rcl.bottom = rect.bottom;
                poly_clear.rcl.left = poly.rcl.left;
                poly_clear.rcl.right = poly.x;
                Internal_PolyTextOutW(hDC, &poly_clear, 1);
            }
        }

        acpStart += poly.n;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::MakeSquiggleLine
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::MakeSquiggleLine(
    POINT start_pt,
    POINT end_pt,
    int frequency,
    int amplitude,
    BOOL fVert,
    CArray<POINT, POINT>& squiggle_line)
{
 
    int nSquiggle = 0;
    int n;
    if (!fVert)
    {
        if (end_pt.x > start_pt.x)
            n = (end_pt.x - start_pt.x) / frequency;
        else
            n = (start_pt.x - end_pt.x) / frequency;
    }
    else
    {
        if (end_pt.y > start_pt.y)
            n = (end_pt.y - start_pt.y) / frequency;
        else
            n = (start_pt.y - end_pt.y) / frequency;
    }

    nSquiggle = n * 2;  // control point.
    nSquiggle++;        // end point.

    POINT begin_pt = start_pt;
    POINT pt       = begin_pt;

    for (int i=1; i < nSquiggle; i++)
    {
        if (!fVert)
        {
            if ((n = i % 2) != 0)
            {
                // control point
                pt.x += frequency / 2;
                pt.y = begin_pt.y - amplitude;
            }
            else
            {
                pt.x = begin_pt.x + frequency;
                pt.y = begin_pt.y;

                begin_pt = pt;
            }
        }
        else
        {
            if ((n = i % 2) != 0)
            {
                // control point
                pt.x = begin_pt.x + amplitude;
                pt.y += frequency / 2;
            }
            else
            {
                pt.x = begin_pt.x;
                pt.y = begin_pt.y + frequency;

                begin_pt = pt;
            }
        }
        squiggle_line.SetAtGrow(i-1, pt);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnPrivateGetContextFlag
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnPrivateGetContextFlag(
    IMCLock& imc,
    BOOL fStartComposition,
    IME_UIWND_STATE* uists)
{
    //
    // Check WM_IME_STARTCOMPOSITION already send ?
    //
    if (fStartComposition)
    {
        WINDOWPLACEMENT wndpl;

        if (IsWindow(m_DefCompWnd.hCompWnd) && IsWindowVisible(m_DefCompWnd.hCompWnd))
        {
            *uists = IME_UIWND_LEVEL1;
            return S_OK;
        }
        else
        {
            for (int i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
            {
                if (IsWindow(m_CompWnd[i].hCompWnd) && IsWindowVisible(m_CompWnd[i].hCompWnd))
                {
                    *uists = IME_UIWND_LEVEL2;
                    return S_OK;
                }
            }
        }

        //
        // If m_fShowCompWnd flag set, already arrived WM_IME_COMPOSITION in this UI Wnd.
        // In this case, IME UI Wnd Level is either Level 1 or Level 2.
        //
        if (m_fShowCompWnd.IsSetFlag())
        {
            *uists = IME_UIWND_LEVEL1_OR_LEVEL2;
            return S_OK;
        }

        if (! (m_isc & ISC_SHOWUICOMPOSITIONWINDOW))
        {
            *uists = IME_UIWND_LEVEL3;
            return S_OK;
        }
    }

    *uists = IME_UIWND_UNKNOWN;
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// UIComposition::OnPrivateGetCandRectFromComposition
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnPrivateGetCandRectFromComposition(
    IMCLock& imc,
    CandRectFromComposition* pv)
{
    HRESULT hr;

    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnPrivateGetCandRectFromComposition. comp==NULL"));
        return hr;
    }

    IME_UIWND_STATE uiwndState = GetLevelFromIMC(imc);
    if (uiwndState == IME_UIWND_LEVEL1)
    {
        LPCWSTR lpstr = (LPCWSTR)comp.GetOffsetPointer(comp->dwCompStrOffset);

        SIZE size;
        if (lpstr && pv->dwCharPos)
        {
            HDC hDC = GetDC(m_DefCompWnd.hCompWnd);
            HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel1);
            FLGetTextExtentPoint32(hDC, lpstr, pv->dwCharPos, &size);
            SelectObject(hDC, hFontOrg);
            ReleaseDC(m_DefCompWnd.hCompWnd, hDC);
        }
        else
        {
            size.cx = 0;
            size.cy = m_tmFontHeightLevel1;
        }

        //
        // When the style is DEFAULT, this is the default composition window.
        //
        GetWindowRect(m_DefCompWnd.hCompWnd, pv->out_rcArea);

        POINT pt;

        pt.x = pt.y = 0;
        pv->out_rcArea->left   += pt.x + size.cx;
        pv->out_rcArea->right  += pt.x + size.cx;
        pv->out_rcArea->top    += pt.y;
        pv->out_rcArea->bottom += pt.y;
    }
    else if (uiwndState == IME_UIWND_LEVEL2)
    {
        BOOL fFound = FALSE;
        POLYTEXTW poly;
        DWORD dwCur = pv->dwCharPos;
        int i;

        if (PRIMARYLANGID(pv->langid) == LANG_JAPANESE)
        {
            //
            // In Japanese case, poly_text stored each clause string.
            //
            for (i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND) && ! fFound;)
            {
                for (int j=0; j < m_CompWnd[i].poly_text.GetPolySize(); j++)
                {
                    poly = m_CompWnd[i].poly_text.GetPolyAt(j);
                    if (dwCur < poly.n)
                    {
                        fFound = TRUE;
                        break;
                    }
                    dwCur -= poly.n;
                }
                if (! fFound)
                {
                    i++;
                }
            }
        }
        else
        {
            //
            // In other language case, poly_text stored plane text. Not clause.
            //
            for (i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND) && ! fFound;)
            {
                for (int j=0; j < m_CompWnd[i].poly_text.GetPolySize(); j++)
                {
                    poly = m_CompWnd[i].poly_text.GetPolyAt(j);
                    if (dwCur <= poly.n)
                    {
                        fFound = TRUE;
                        poly.n = dwCur;
                        break;
                    }
                    dwCur -= poly.n;
                }
                if (! fFound)
                {
                    i++;
                }
            }
        }

        if (! fFound)
        {
            return S_FALSE;
        }

        SIZE size;
        if (poly.lpstr && poly.n)
        {
            HDC hDC = GetDC(m_CompWnd[i].hCompWnd);
            HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel2);
            FLGetTextExtentPoint32(hDC, poly.lpstr, poly.n, &size);
            SelectObject(hDC, hFontOrg);
            ReleaseDC(m_DefCompWnd.hCompWnd, hDC);
        }
        else
        {
            size.cx = 0;
            size.cy = m_tmFontHeightLevel2;
        }

        if (!imc.UseVerticalCompWindow())
        {
            //
            // When the style is not DEFAULT, this is the composition window.
            //
            if (PRIMARYLANGID(pv->langid) == LANG_JAPANESE)
            {
                pv->out_rcArea->left    = poly.x;
            }
            else
            {
                pv->out_rcArea->left    = poly.x + size.cx;
            }
            pv->out_rcArea->right   = poly.x + size.cx;
            pv->out_rcArea->top     = poly.y;
            pv->out_rcArea->bottom  = poly.y + size.cy + LINE_BOLD_WIDTH;
        }
        else
        {
            RotateSize(&size);

            pv->out_rcArea->left    = poly.x - size.cx - LINE_BOLD_WIDTH;
            pv->out_rcArea->right   = poly.x;
            pv->out_rcArea->top     = poly.y;
            pv->out_rcArea->bottom  = poly.y + size.cy;
        }

        //
        // Convert to Screen coordinate.
        //
        POINT pt;
        pt.x = pt.y = 0;
        ClientToScreen(m_CompWnd[i].hCompWnd, &pt);
        pv->out_rcArea->left   += pt.x;
        pv->out_rcArea->right  += pt.x;
        pv->out_rcArea->top    += pt.y;
        pv->out_rcArea->bottom += pt.y;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::GetCompStrExtent
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::OnSetCursor(IMCLock &imc, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;

    POINT pt;
    ULONG uEdge;
    ULONG uQuadrant;

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnSetCursor. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnSetCursor. _pCicContext==NULL"));
        return hr;
    }


    GetCursorPos(&pt);
    GetCompStrExtent(pt, &uEdge, &uQuadrant, imc);

    DWORD dwBtnStatus = 0;

    if (GetKeyState(VK_LBUTTON) < 0)
    {
        dwBtnStatus |= MK_LBUTTON;
    }
    if (GetKeyState(VK_MBUTTON) < 0)
    {
        dwBtnStatus |= MK_MBUTTON;
    }
    if (GetKeyState(VK_RBUTTON) < 0)
    {
        dwBtnStatus |= MK_RBUTTON;
    }

    if (_pCicContext->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc) == 1L)
        hr = S_OK;

    return hr;
}

//+---------------------------------------------------------------------------
//
// UIComposition::GetCompStrExtent
//
//+---------------------------------------------------------------------------

HRESULT
UIComposition::GetCompStrExtent(
    POINT pt,
    ULONG *puEdge,
    ULONG *puQuadrant,
    IMCLock& imc)
{

    Assert(puEdge);
    Assert(puQuadrant);
    *puEdge = 0;
    *puQuadrant = 0;
    ULONG uCount;

    HRESULT hr;

    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::GetCompStrExtent. comp==NULL"));
        return hr;
    }

    if (!comp.GetOffsetPointer(comp->dwCompStrLen))
    {
        //
        // There is no composition string.
        //
        return S_OK;
    }

    IME_UIWND_STATE uiwndState = GetLevelFromIMC(imc);
    if (uiwndState == IME_UIWND_LEVEL1)
    {
        HDC hDC = GetDC(m_DefCompWnd.hCompWnd);
        HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel1);

        POINT ptCli = pt;
        ScreenToClient(m_DefCompWnd.hCompWnd, &ptCli);
        hr = m_DefCompWnd.poly_text.GetPolyTextExtent(ptCli, 
                                                      hDC, 
                                                      FALSE,
                                                      puEdge, 
                                                      puQuadrant);
        SelectObject(hDC, hFontOrg);
        ReleaseDC(m_DefCompWnd.hCompWnd, hDC);
    }
    else if (uiwndState == IME_UIWND_LEVEL2)
    {
        BOOL fVert = imc.UseVerticalCompWindow();
        int i;
        for (i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
        {
            HDC hDC = GetDC(m_CompWnd[i].hCompWnd);
            HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel2);

            POINT ptCli = pt;
            ScreenToClient(m_CompWnd[i].hCompWnd, &ptCli);
            hr = m_CompWnd[i].poly_text.GetPolyTextExtent(ptCli, 
                                                          hDC, 
                                                          fVert,
                                                          puEdge, 
                                                          puQuadrant);
            SelectObject(hDC, hFontOrg);
            ReleaseDC(m_CompWnd[i].hCompWnd, hDC);
            if (hr == S_OK)
                break;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UIComposition::CreateDefFrameWnd
//
//+---------------------------------------------------------------------------

HRESULT UIComposition::CreateDefFrameWnd(HWND hwndParent, HIMC hIMC)
{

    DWORD dwWndStyle = // UIWINDOW_TOPMOST |
                       UIWINDOW_HASTOOLTIP |
                       UIWINDOW_HABITATINWORKAREA |
                       UIWINDOW_WHISTLERLOOK |
                       UIWINDOW_TOOLWINDOW;


    
    if (!m_pDefCompFrameWnd)
    {
        m_pDefCompFrameWnd = new CDefCompFrameWindow(hIMC, dwWndStyle);
        if (!m_pDefCompFrameWnd)
            return E_OUTOFMEMORY;

        if (!m_pDefCompFrameWnd->Initialize())
        {
            delete m_pDefCompFrameWnd;
            m_pDefCompFrameWnd = NULL;
            return E_FAIL;
        }

        m_pDefCompFrameWnd->Init();
    }

    m_pDefCompFrameWnd->CreateWnd(hwndParent);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UIComposition::CreateCompButtonWnd
//
//+---------------------------------------------------------------------------

HRESULT UIComposition::CreateCompButtonWnd(HWND hwndParent, HIMC hIMC)
{
    //
    // #500698
    //
    // no more level2 comp window in English Speech so we don't need
    // finalizing button on level2.
    //
    TLS * ptls = TLS::GetTLS();
    if (!ptls || !ptls->NonEACompositionEnabled())
        return S_OK;

    //
    // we don't use Level2 Comp Finalizing Button for EA language.
    //
    if (IsEALang())
    {
        if (m_pCompButtonFrameWnd)
        {
            delete m_pCompButtonFrameWnd;
            m_pCompButtonFrameWnd = NULL;
        }
        return S_OK;
    }

    DWORD dwWndStyle = // UIWINDOW_TOPMOST |
                       UIWINDOW_HASTOOLTIP |
                       UIWINDOW_HABITATINWORKAREA |
                       UIWINDOW_WHISTLERLOOK |
                       UIWINDOW_TOOLWINDOW |
                       UIWINDOW_WSBORDER;


    
    if (!m_pCompButtonFrameWnd)
    {
        m_pCompButtonFrameWnd = new CCompButtonFrameWindow(hIMC, dwWndStyle);
        if (!m_pCompButtonFrameWnd)
            return E_OUTOFMEMORY;

        if (!m_pCompButtonFrameWnd->Initialize())
        {
            delete m_pCompButtonFrameWnd;
            m_pCompButtonFrameWnd = NULL;
            return E_FAIL;
        }

        m_pCompButtonFrameWnd->Init();
    }

    m_pCompButtonFrameWnd->CreateWnd(hwndParent);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// UIComposition::OnPrivateGetTextExtent
//
//+---------------------------------------------------------------------------

HRESULT UIComposition::OnPrivateGetTextExtent(IMCLock& imc, TEXTEXT *ptext_ext)
{
    ULONG uCount;

    HRESULT hr;

    if (m_bTimerCOMPOSITION == TRUE)
    {
        // UIWnd has already got WM_IME_COMPOSITION with new composition text, and 
        // set a timer for it, but the time-out value has not yet elapsed, so the new 
        // composition window text is not updated yet.
        // But caller of GetTextExtent may assume the new text has already been in the 
        // composition window and try to get extent for the updated range.
        //
        // In this case, we need to call UpdateCompositionRect( ) to update the composition
        // Rect.
        UpdateCompositionRect(imc);
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnPrivateGetTextExtent. imc_ctfime==NULL"));
        return hr;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnPrivateGetTextExtent. _pCicContext==NULL"));
        return hr;
    }

    LONG cch = 0;
    if (FAILED(_pCicContext->EscbReadOnlyPropMargin(imc, NULL, &cch)))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnPrivateGetTextExtent. comp==NULL"));
        return hr;
    }

    ptext_ext->acpStart -= cch;
    ptext_ext->acpEnd -= cch;

    if (ptext_ext->prc)
        memset(ptext_ext->prc, 0, sizeof(*ptext_ext->prc));
    if (ptext_ext->pfClipped)
        *ptext_ext->pfClipped = FALSE;

    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
    if (FAILED(hr=comp.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("UIComposition::OnPrivateGetTextExtent. comp==NULL"));
        return hr;
    }

    if (!comp.GetOffsetPointer(comp->dwCompStrLen))
    {
        //
        // There is no composition string.
        //
        return S_OK;
    }

    // If the requested range is beyond the composition window,
    // just return the position based on the real window.

    // this is hack for CHS/CHT TIP's special design.
    if (ptext_ext->acpStart > (LONG)(comp->dwCompStrLen))
        ptext_ext->acpStart = (LONG)(comp->dwCompStrLen);

    if (ptext_ext->acpEnd > (LONG)(comp->dwCompStrLen))
        ptext_ext->acpEnd = (LONG)(comp->dwCompStrLen);

    RECT rcStart =  {0};
    RECT rcEnd =  {0};
    HRESULT hrStart = S_FALSE;
    HRESULT hrEnd = S_FALSE;

    IME_UIWND_STATE uiwndState = GetLevelFromIMC(imc);
    if (uiwndState == IME_UIWND_LEVEL1)
    {
        HDC hDC = GetDC(m_DefCompWnd.hCompWnd);
        HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel1);

        DWORD acpStart = ptext_ext->acpStart;
        DWORD acpEnd = ptext_ext->acpEnd;
        hrStart = m_DefCompWnd.poly_text.GetPolyTextExtentRect(acpStart, hDC, FALSE, TRUE, &rcStart);

        if (hrStart == S_OK)
            m_DefCompWnd._ClientToScreen(&rcStart);

		hrEnd = m_DefCompWnd.poly_text.GetPolyTextExtentRect(acpEnd, hDC, FALSE, TRUE, &rcEnd);

        if (hrEnd == S_OK)
            m_DefCompWnd._ClientToScreen(&rcEnd);

        SelectObject(hDC, hFontOrg);
        ReleaseDC(m_DefCompWnd.hCompWnd, hDC);

    }
    else if (uiwndState == IME_UIWND_LEVEL2)
    {
        DWORD acpStart;
        DWORD acpEnd;
        BOOL fVert;
        BOOL fGetLast = FALSE;
        int i;

TryWithLast:
        acpStart = ptext_ext->acpStart;
        acpEnd = ptext_ext->acpEnd;

        fVert = imc.UseVerticalCompWindow();

        for (i=0; i < sizeof(m_CompWnd)/sizeof(COMPWND); i++)
        {
            HDC hDC = GetDC(m_CompWnd[i].hCompWnd);
            HFONT hFontOrg = (HFONT)SelectObject(hDC, m_hFontLevel2);

            if (hrStart != S_OK)
            {
                hrStart = m_CompWnd[i].poly_text.GetPolyTextExtentRect(acpStart, hDC, fVert, fGetLast, &rcStart);
                if (hrStart == S_OK)
                    m_CompWnd[i]._ClientToScreen(&rcStart);
            }
 
            if (hrEnd != S_OK)
            {
                hrEnd = m_CompWnd[i].poly_text.GetPolyTextExtentRect(acpEnd, hDC, fVert, fGetLast, &rcEnd);
                if (hrEnd == S_OK)
                    m_CompWnd[i]._ClientToScreen(&rcEnd);
            }

            SelectObject(hDC, hFontOrg);
            ReleaseDC(m_CompWnd[i].hCompWnd, hDC);
            if ((hrStart == S_OK) && (hrEnd == S_OK))
                break;
        }

        if (!fGetLast && (hrStart != S_OK))
        {
            fGetLast = TRUE;
            goto TryWithLast;
        }

    }

    if (hrStart == S_OK)
    {
        if (hrEnd == S_OK)
        {
            ptext_ext->prc->left   = min(rcStart.left , rcEnd.left);
            ptext_ext->prc->top    = min(rcStart.top , rcEnd.top);
            ptext_ext->prc->bottom = max(rcStart.bottom , rcEnd.bottom);
            ptext_ext->prc->right  = max(rcStart.right , rcEnd.right);
        }
        else
        {
            ptext_ext->prc->left   = rcStart.left;
            ptext_ext->prc->top    = rcStart.top;
            ptext_ext->prc->bottom = rcStart.bottom;
            ptext_ext->prc->right  = rcStart.right;
        }
    }

    return hrStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\ui.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    ui.h

Abstract:

    This file defines the UI Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UI_H_
#define _UI_H_

#include "uicomp.h"

class UI
{
public:
    static VOID OnCreate(HWND hUIWnd);
    static VOID OnDestroy(HWND hUIWnd);

public:
    UI(HWND hUIWnd)
    {
        m_hUIWnd = hUIWnd;
    }

    virtual ~UI()
    {
        delete m_UIComposition;
    }

    HRESULT _Create();
    HRESULT _Destroy();

    HRESULT OnImeSetContext(IMCLock& imc, BOOL fActivate, DWORD isc)
    {
        return m_UIComposition->OnImeSetContext(imc, m_hUIWnd, fActivate, isc);
    }
    HRESULT OnImeSetContextAfter(IMCLock& imc)
    {
        return m_UIComposition->OnImeSetContextAfter(imc);
    }
    HRESULT OnImeSelect(BOOL fSelect)
    {
        return m_UIComposition->OnImeSelect(fSelect);
    }
    HRESULT OnImeStartComposition(IMCLock& imc)
    {
        return m_UIComposition->OnImeStartComposition(imc, m_hUIWnd);
    }
    HRESULT OnImeCompositionUpdate(IMCLock& imc)
    {
        return m_UIComposition->OnImeCompositionUpdate(imc);
    }
    HRESULT OnImeCompositionUpdateByTimer(IMCLock& imc)
    {
        return m_UIComposition->OnImeCompositionUpdateByTimer(imc);
    }
    HRESULT OnImeEndComposition()
    {
        return m_UIComposition->OnImeEndComposition();
    }
    HRESULT OnImeNotifySetCompositionWindow(IMCLock& imc)
    {
        return m_UIComposition->OnImeNotifySetCompositionWindow(imc);
    }
    HRESULT OnImeNotifySetCompositionFont(IMCLock& imc)
    {
        return m_UIComposition->OnImeNotifySetCompositionFont(imc);
    }
    HRESULT OnPrivateGetContextFlag(IMCLock& imc, BOOL fStartComposition, IME_UIWND_STATE* uists)
    {
        return m_UIComposition->OnPrivateGetContextFlag(imc, fStartComposition, uists);
    }
    HRESULT OnPrivateGetTextExtent(IMCLock& imc, UIComposition::TEXTEXT *ptext_ext)
    {
        return m_UIComposition->OnPrivateGetTextExtent(imc, ptext_ext);
    }
    HRESULT OnPrivateGetCandRectFromComposition(IMCLock& imc, UIComposition::CandRectFromComposition* pv)
    {
        return m_UIComposition->OnPrivateGetCandRectFromComposition(imc, pv);
    }

    void OnSetCompositionTimerStatus(BOOL bSetTimer) 
    {
        m_UIComposition->OnSetCompositionTimerStatus(bSetTimer);
    }

private:
    HWND              m_hUIWnd;
    UIComposition*    m_UIComposition;
};

#endif // _UI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\uicomp.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    uicomp.h

Abstract:

    This file defines the UIComposition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UICOMP_H_
#define _UICOMP_H_

#include "imc.h"
#include "polytext.h"
#include "caret.h"
#include "tls.h"
#include "globals.h"
#include "cuiwnd.h"
#include "cuitb.h"

#define WM_UICOMP_SETCURSOR (WM_USER + 1000)

typedef enum {
        IME_UIWND_UNKNOWN = 0,
        IME_UIWND_LEVEL1  = 1,
        IME_UIWND_LEVEL2  = 2,
        IME_UIWND_LEVEL3  = 3,
        IME_UIWND_LEVEL1_OR_LEVEL2 = 4
} IME_UIWND_STATE;

static const LONG DEFFRAME_LEFT_MARGIN = 2;
static const LONG DEFFRAME_TOP_MARGIN = 3;
static const LONG DEFFRAME_BOTTOM_MARGIN = 7;
static const LONG DEFFRAME_TOP_STR_MARGIN = 7;
static const LONG DEFFRAME_ENTER_BTN_CX = 18;
static const LONG DEFFRAME_ENTER_BTN_CY = 18;
static const LONG COMPBTN_LEFT_MARGIN = 1;
static const LONG COMPBTN_TOP_MARGIN = 1;


class CCompFrameWindow;
class CDefCompFrameWindow;

//////////////////////////////////////////////////////////////////////////////
//
// CCompFinalizeButton
//
//////////////////////////////////////////////////////////////////////////////

class CCompFinalizeButton : public CUIFToolbarButton
{
public:
    CCompFinalizeButton(CCompFrameWindow *pCompFrameWindow, DWORD dwID, RECT *prc, DWORD dwStyle, DWORD dwSBtnStyle, DWORD dwSBtnShowType);

    ~CCompFinalizeButton();
    virtual void OnLeftClick();
    CCompFrameWindow *m_pCompFrameWnd;
};

//////////////////////////////////////////////////////////////////////////////
//
// CCompFrameWinodow
//
//////////////////////////////////////////////////////////////////////////////

class CCompFrameWindow : public CUIFWindow
{
public:
    CCompFrameWindow(HIMC hIMC, DWORD dwStyle) : CUIFWindow(::GetInstance(), dwStyle)
    {
        m_hIMC = hIMC;
    }

    HIMC GetIMC() {return m_hIMC;}

private:
    HIMC m_hIMC;
};

//////////////////////////////////////////////////////////////////////////////
//
// CDefCompFrameFripper
//
//////////////////////////////////////////////////////////////////////////////

class CDefCompFrameGripper : public CUIFGripper
{
public:
    CDefCompFrameGripper::CDefCompFrameGripper(CDefCompFrameWindow *pDefCompFrameWnd, RECT *prc, DWORD dwStyle);

    CDefCompFrameWindow *m_pDefCompFrameWnd;
};

//////////////////////////////////////////////////////////////////////////////
//
// CDefCompFrameWinodow
//
//////////////////////////////////////////////////////////////////////////////

class CDefCompFrameWindow : public CCompFrameWindow
{
public:
    CDefCompFrameWindow(HIMC hIMC, DWORD dwStyle);
    virtual ~CDefCompFrameWindow();

    virtual void HandleMouseMsg( UINT uMsg, POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

    void Init();
    void SetCompStrRect(int dx, int dy, BOOL fShow);
    virtual void OnCreate(HWND hWnd);
    virtual LRESULT OnWindowPosChanged(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


    void SetCompStrWnd(HWND hwnd) {m_hwndCompStr = hwnd;}

private:
    void SavePosition();
    void LoadPosition();

    int GetGripperWidth();

    void MyScreenToClient(POINT *ppt, RECT *prc)
    {
        if (ppt)
            ScreenToClient(GetWnd(), ppt);
        if (prc)
        {
            ScreenToClient(GetWnd(), (POINT *)&prc->left);
            ScreenToClient(GetWnd(), (POINT *)&prc->right);
        }
    }


    HWND m_hwndCompStr;
    CDefCompFrameGripper *m_pGripper;
    CCompFinalizeButton  *m_pEnterButton;
    MARGINS _marginsButton;
};

//////////////////////////////////////////////////////////////////////////////
//
// CCompButtonFrameWinodow
//
//////////////////////////////////////////////////////////////////////////////

class CCompButtonFrameWindow : public CCompFrameWindow
{
public:
    CCompButtonFrameWindow(HIMC hIMC, DWORD dwStyle);
    virtual ~CCompButtonFrameWindow();
    void Init();
    void OnCreate(HWND hWnd);
    void MoveShow(int x, int y, BOOL fShow);

private:
    CCompFinalizeButton  *m_pEnterButton;
    MARGINS _marginsButton;
};

//////////////////////////////////////////////////////////////////////////////
//
// UIComposition
//
//////////////////////////////////////////////////////////////////////////////

class UIComposition
{
public:
    static LRESULT CompWndProc(HWND hCompWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    UIComposition(HWND hUIWnd);
    virtual ~UIComposition();

public:
    HRESULT OnCreate();
    HRESULT OnDestroy();
    HRESULT OnImeSetContext(IMCLock& imc, HWND hUIWnd, BOOL fActivate, DWORD isc);
    HRESULT OnImeSetContextAfter(IMCLock& imc);
    HRESULT OnImeSelect(BOOL fSelect);
    HRESULT OnImeStartComposition(IMCLock& imc, HWND hUIWnd);
    HRESULT OnImeCompositionUpdate(IMCLock& imc);
    HRESULT OnImeCompositionUpdateByTimer(IMCLock& imc);
    HRESULT OnImeEndComposition();
    HRESULT OnImeNotifySetCompositionWindow(IMCLock& imc);
    HRESULT OnImeNotifySetCompositionFont(IMCLock& imc);

    HRESULT OnPaint(TLS* ptls, HWND hCompWnd, HDC hDC, PAINTSTRUCT& ps, IMCLock& imc);
    HRESULT OnTimer(HWND hCompWnd);
    HRESULT OnSetCursor(IMCLock& imc, WPARAM wParam, LPARAM lParam);

private:
    HRESULT CreateCompositionWindow(IMCLock& imc, HWND hUIWnd);
    HRESULT DestroyCompositionWindow();
    HRESULT HideCompositionWindow();
    HRESULT UpdateShowCompWndFlag(IMCLock& imc, DWORD* pdwCompStrLen);
    HRESULT UpdateCompositionRect(IMCLock& imc);
    HRESULT UpdateFont(IMCLock& imc);

    UINT    CalcSingleTextExtentPoint(IMCLock& imc, HDC hDC, LPCWSTR lpsz, int string_len, PBYTE lpAttr, BOOL fCompAttr, CCompClauseStore *compclause, int window_width, LPSIZE real_size, CPolyText& poly_text, int row_index);
    UINT    CalcMultiTextExtentPoint(IMCLock& imc, HDC hDC, LPCWSTR lpsz, int string_len, PBYTE lpAttr, BOOL fCompAttr, CCompClauseStore *compclause, int window_width, LPSIZE real_size, CPolyText& poly_text);

    HRESULT SetCaretPos(HDC hDC, CCaret& caret, int x, int y, LPCWSTR lpCompStr, DWORD string_length, DWORD cursor_pos, BOOL fVert, BOOL fEndCaret);
    HRESULT UpdateCaretRect(HDC hDC, int index, DWORD dwCursorPos, BOOL fVert, BOOL fEndCaret);

    typedef struct tagCOMPWND {
        HWND       hCompWnd;
        CPolyText  poly_text;
        CCaret     caret;
        struct {
            LONG       acpStart;
            LONG       cch;
        } sel;

        void _ClientToScreen(RECT *prc)
        {
            ::ClientToScreen(hCompWnd, (POINT *)&prc->left);
            ::ClientToScreen(hCompWnd, (POINT *)&prc->right);
        }

        BOOL fDefaultCompWnd : 1;
    } COMPWND;

    HRESULT PolyTextAndAttrOut(TLS* ptls, HDC hDC, BOOL fVert, COMPWND* pcompwnd);
    HRESULT MakeSquiggleLine(POINT start_pt, POINT end_pt, int frequency, int amplitude, BOOL fVert, CArray<POINT, POINT>& squiggle_line);

    //
    // Query IME UI Window state
    //
public:

    static IME_UIWND_STATE InquireImeUIWndState(IMCLock& imc)
    {
        HWND hDefImeWnd;

        if (IsWindow(hDefImeWnd=ImmGetDefaultIMEWnd(NULL)))
        {
            //
            // Internal notification to UI window
            // When receive this msg in UI wnd, then return IME context flag.
            //
            return (IME_UIWND_STATE)SendMessage(hDefImeWnd, WM_IME_NOTIFY, IMN_PRIVATE_GETCONTEXTFLAG, 0);
        }
        return IME_UIWND_UNKNOWN;
    }

    typedef struct
    {
        LONG acpStart;
        LONG acpEnd;
        RECT *prc;
        BOOL *pfClipped;

        void SetICOARGS(ICOARGS *pArgs)
        {
            acpStart  = pArgs->text_ext.acpStart;
            acpEnd    = pArgs->text_ext.acpEnd;
            prc       = pArgs->text_ext.prc;
            pfClipped = pArgs->text_ext.pfClipped;
        }

    } TEXTEXT;

    HRESULT OnPrivateGetTextExtent(IMCLock& imc, TEXTEXT *ptext_ext);

    static BOOL GetImeUIWndTextExtent(TEXTEXT *ptext_ext)
    {
        HWND hDefImeWnd;

        if (IsWindow(hDefImeWnd=ImmGetDefaultIMEWnd(NULL)))
        {
            //
            // Internal notification to UI window
            // When receive this msg in UI wnd, then return IME context flag.
            //
            return SendMessage(hDefImeWnd, 
                               WM_IME_NOTIFY, 
                               IMN_PRIVATE_GETTEXTEXT, 
                               (LPARAM)ptext_ext) ? TRUE : FALSE;
        }
        return FALSE;
    }

public:
    HRESULT OnPrivateGetContextFlag(IMCLock& imc, BOOL fStartComposition, IME_UIWND_STATE* uists);
    HRESULT GetCompStrExtent(POINT pt, ULONG *puEdge, ULONG *puQuadrant, IMCLock& imc);

    //
    // Get candidate window rectangle from composition window
    //
public:
    typedef struct tagCandRectFromComposition {
        LANGID langid;
        DWORD dwCharPos;
        RECT* out_rcArea;
    } CandRectFromComposition;

    static HRESULT GetCandRectFromComposition(IMCLock& imc, LANGID langid, DWORD dwCharPos, RECT* out_rcArea)
    {
        HWND hDefImeWnd;

        if (IsWindow(hDefImeWnd=ImmGetDefaultIMEWnd(NULL)))
        {
            //
            // Internal notification to UI window
            // When receive this msg in UI wnd, then return candidate window rectangle
            //
            CandRectFromComposition lParam;
            lParam.langid     = langid;
            lParam.dwCharPos  = dwCharPos;
            lParam.out_rcArea = out_rcArea;
            SendMessage(hDefImeWnd, WM_IME_NOTIFY, IMN_PRIVATE_GETCANDRECTFROMCOMPOSITION, (LPARAM)&lParam);
            return S_OK;
        }
        return S_FALSE;
    }

public:
    HRESULT GetSelection(IMCLock& imc, LONG *pacpSelStart, LONG *pcchSel);
    HRESULT OnPrivateGetCandRectFromComposition(IMCLock& imc, CandRectFromComposition* pv);

    HRESULT CreateDefFrameWnd(HWND hwndParent, HIMC hIMC);
    HRESULT CreateCompButtonWnd(HWND hwndParent, HIMC hIMC);

    HWND GetUIWnd() {return m_hUIWnd;}
    void OnSetCompositionTimerStatus(BOOL  bSetTimer) {m_bTimerCOMPOSITION = bSetTimer;}

private:
    LPWSTR GetCompStrBuffer(int nSize)
    {
        if (!m_lpszCompStr)
        {
            m_lpszCompStr = (LPWSTR)cicMemAllocClear((nSize + 1) * sizeof(WCHAR));
            m_nCompStr = nSize;
        }

        if (m_nCompStr < nSize)
        {
            m_lpszCompStr = (LPWSTR)cicMemReAlloc(m_lpszCompStr, (nSize + 1) * sizeof(WCHAR));
            m_nCompStr = nSize;
        }

        return m_lpszCompStr;
    }


    IME_UIWND_STATE GetLevelFromIMC(IMCLock& imc)
    {
        if (imc->cfCompForm.dwStyle == CFS_DEFAULT)
            return IME_UIWND_LEVEL1;

        if (imc->cfCompForm.dwStyle & (CFS_RECT | CFS_POINT | CFS_FORCE_POSITION))
        {
            RECT rc;
            //
            // if there is no room to draw, try Level1.
            //
            GetClientRect(imc->hWnd, &rc);
            if (!PtInRect(&rc, imc->cfCompForm.ptCurrentPos))
                return IME_UIWND_LEVEL1;

            //
            // if there is no room to draw, try Level1.
            //
            if (imc->cfCompForm.dwStyle & CFS_RECT)
            {
                if ((imc->cfCompForm.rcArea.top == 
                          imc->cfCompForm.rcArea.bottom) && 
                    (imc->cfCompForm.rcArea.left == 
                          imc->cfCompForm.rcArea.right))
                    return IME_UIWND_LEVEL1;
            }

            return IME_UIWND_LEVEL2;
        }
        return IME_UIWND_UNKNOWN;
    }

private:
    HWND       m_hUIWnd;
    static const LONG COMPUI_WINDOW_INDEX = 0;

    typedef enum tagCOMPWNDINDEX {
        FIRST_WINDOW,
        MIDDLE_WINDOW,
        LAST_WINDOW,
        END_OF_INDEX,
        //
        DEFAULT_WINDOW = -1
    } COMPWNDINDEX;

    CBoolean   m_fInitUIComp;
    COMPWND    m_CompWnd[END_OF_INDEX];
    COMPWND    m_DefCompWnd;

    HFONT      m_hFontLevel1;
    int        m_tmFontHeightLevel1;
    HFONT      m_hFontLevel2;
    int        m_tmFontHeightLevel2;

    static const LONG CARET_WIDTH = 2;
    SIZE       m_caret_size;

    static const LONG LINE_BOLD_WIDTH = 2;
    static const LONG LINE_SQUIGGLE_FREQUENCY = 4;
    static const LONG LINE_SQUIGGLE_AMPLITUDE = 2;

    DWORD      m_isc;
    BOOL       m_fActive;

    LPWSTR     m_lpszCompStr;
    int        m_nCompStr;
    BOOL       m_bTimerCOMPOSITION;   // when WM_IME_COMPOSITION is passed to the UI window, UIWnd procedure
                                      // start a timer for it.
                                      // this data member indicates if a timer is set and not handled (killed)yet.

    CBoolean   m_fShowCompWnd;        // When arrive WM_IME_COMPOSITION in UI window handler, UI Wnd might be Level 1 or Level 2 if
                                      // comp str is valid length and set ISC_SHOWUICOMPOSITIONWINDOW

    CDefCompFrameWindow *m_pDefCompFrameWnd;
    CCompButtonFrameWindow *m_pCompButtonFrameWnd;
};

#endif // _UICOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\uiwndhd.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    uiwndhd.cpp

Abstract:

    This file implements the IME UI window handler Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "uiwndhd.h"
#include "tls.h"
#include "profile.h"
#include "msime.h"
#include "setmode.h"
#include "ui.h"

#define UIWND_TIMERID_IME_COMPOSITION       0
#define UIWND_TIMERID_IME_SETCONTEXTAFTER   1
#define UIWND_TIMERID_IME_DELAYUNDORECONV   2

/* static */
LRESULT
CIMEUIWindowHandler::ImeUIWndProcWorker(
    HWND hUIWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LONG lRet = 0L;

    TLS* ptls = TLS::GetTLS();
    if (ptls && (ptls->GetSystemInfoFlags() & IME_SYSINFO_WINLOGON))
    {
        if (uMsg == WM_CREATE)
            return -1L;
        else
            return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }

    switch (uMsg) {
        case WM_CREATE:
            UI::OnCreate(hUIWnd);
            break;

        case WM_IME_NOTIFY:
            return ImeUINotifyHandler(hUIWnd, uMsg, wParam, lParam);

        case WM_ENDSESSION:
            if (wParam && lParam)
            {
                UI::OnDestroy(hUIWnd);
                break;
            }

        case WM_DESTROY:
            UI::OnDestroy(hUIWnd);
            break;

        case WM_IME_SETCONTEXT:
        case WM_IME_SELECT:
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_COMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_TIMER:
            {
                UI* pv = (UI*)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
                if (pv == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CIMEUIWindowHandler::ImeUIWndProcWorker. pv==NULL"));
                    break;
                }

                HIMC hImc = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                IMCLock imc(hImc);
                //
                // Should not return when IMCLock failed.
                // If application associate NULL hIMC, below method never work.
                // Inside of each method must validate check of imc object.
                //
                // if (FAILED(imc.GetResult()))
                // {
                //     DebugMsg(TF_ERROR, TEXT("ImeUIWndProcWorker. imc==NULL"));
                //     break;
                // }

                switch (uMsg)
                {
                    case WM_IME_SETCONTEXT:
                        pv->OnImeSetContext(imc, (BOOL)wParam, (DWORD)lParam);
                        KillTimer(hUIWnd, UIWND_TIMERID_IME_SETCONTEXTAFTER);
                        SetTimer(hUIWnd, 
                                 UIWND_TIMERID_IME_SETCONTEXTAFTER, 
                                 300, 
                                 NULL);
                        break;

                    case WM_IME_SELECT:
                        pv->OnImeSelect((BOOL)wParam);
                        break;

                    case WM_IME_STARTCOMPOSITION:
                        pv->OnImeStartComposition(imc);
                        break;

                    case WM_IME_COMPOSITION:
                        //
                        // use time to delay to calc the size of the window.
                        //
                        if (lParam & GCS_COMPSTR)
                        {
                            pv->OnImeCompositionUpdate(imc);
                            SetTimer(hUIWnd, UIWND_TIMERID_IME_COMPOSITION, 10, NULL);
                            pv->OnSetCompositionTimerStatus(TRUE);
                        }
                        break;

                    case WM_TIMER:
                        switch (wParam)
                        {
                            case UIWND_TIMERID_IME_COMPOSITION:
                                KillTimer(hUIWnd, UIWND_TIMERID_IME_COMPOSITION);
                                pv->OnSetCompositionTimerStatus(FALSE);
                                pv->OnImeCompositionUpdateByTimer(imc);
                                break;

                            case UIWND_TIMERID_IME_SETCONTEXTAFTER:
                                KillTimer(hUIWnd, UIWND_TIMERID_IME_SETCONTEXTAFTER);
                                pv->OnImeSetContextAfter(imc);
                                break;

                            case UIWND_TIMERID_IME_DELAYUNDORECONV:
                                KillTimer(hUIWnd, UIWND_TIMERID_IME_DELAYUNDORECONV);
                                ImeUIDelayedReconvertFuncCall(hUIWnd);
                                break;
                        }
                        break;

                    case WM_IME_ENDCOMPOSITION:
                        KillTimer(hUIWnd, UIWND_TIMERID_IME_COMPOSITION);
                        pv->OnSetCompositionTimerStatus(FALSE);
                        pv->OnImeEndComposition();
                        break;

                }
            }
            break;

        default:
            if (IsMsImeMessage(uMsg))
                return ImeUIMsImeHandler(hUIWnd, uMsg, wParam, lParam);
            else
                return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }

    return lRet;
}


/* static */
LRESULT
CIMEUIWindowHandler::ImeUINotifyHandler(
    HWND hUIWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DebugMsg(TF_FUNC, TEXT("ImeUINotifyHandler"));

    HRESULT hr;
    IMCLock imc((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC));
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUINotifyHandler. imc==NULL"));
        return 0L;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUINotifyHandler. imc_ctfime==NULL"));
        return 0L;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUINotifyHandler. _pCicContext==NULL"));
        return 0L;
    }

    switch (wParam) {
        case IMN_SETOPENSTATUS:
            //
            // we can track this in SetOpenStatus().
            // Don't have to sync when IMM32 is called.
            //
            // _pImmIfIME->OnSetOpenStatus(imc);
            break;
        case IMN_SETSTATUSWINDOWPOS:
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
            break;
        case IMN_SETCONVERSIONMODE:
        case IMN_SETSENTENCEMODE:
            //
            // we can track this in SetConversionMode().
            // Don't have to sync when IMM32 is called.
            //
            // _pImmIfIME->OnSetConversionSentenceMode(imc);
            break;
        case IMN_OPENCANDIDATE:
            _pCicContext->m_fOpenCandidateWindow.SetFlag();
            _pCicContext->ClearPrevCandidatePos();
            // fall through to call OnSetCandidatePos().
        case IMN_SETCANDIDATEPOS:
        case IMN_CHANGECANDIDATE:
            {
                TLS* ptls = TLS::GetTLS();
                if (ptls == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CIMEUIWindowHandler::ImeUINotifyHandler. ptls==NULL."));
                    return FALSE;
                }

                _pCicContext->OnSetCandidatePos(ptls, imc);
            }
            break;
        case IMN_CLOSECANDIDATE:
            _pCicContext->m_fOpenCandidateWindow.ResetFlag();
            {
                HWND hDefImeWnd;
                /*
                 * A-Synchronize call ImmIfIME::ClearDocFeedBuffer
                 * because this method had a protected.
                 */
                if (IsWindow(hDefImeWnd=ImmGetDefaultIMEWnd(NULL)))
                {
                    PostMessage(hDefImeWnd, WM_IME_NOTIFY, IMN_PRIVATE_ONCLEARDOCFEEDBUFFER, (LPARAM)(HIMC)imc);
                }
            }
            break;
        case IMN_SETCOMPOSITIONWINDOW:
            _pCicContext->ResetIMECharPosition();
            {
                UI* pv = (UI*)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
                if (pv == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CIMEUIWindowHandler::ImeUINotifyHandler. pv==NULL"));
                    break;
                }
                pv->OnImeNotifySetCompositionWindow(imc);
                ImeUIOnLayoutChange((HIMC)imc);
            }
            break;
        case IMN_SETCOMPOSITIONFONT:
            {
                UI* pv = (UI*)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
                if (pv == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CIMEUIWindowHandler::ImeUINotifyHandler. pv==NULL"));
                    break;
                }
                pv->OnImeNotifySetCompositionFont(imc);

                //
                // Get IME level and call ImeUIOnLayoutChange for only Level1 and Level2 cases.
                //
                IME_UIWND_STATE uists;
                hr = pv->OnPrivateGetContextFlag(imc, _pCicContext->m_fStartComposition.IsSetFlag(), &uists);
                if (hr == S_OK && ((uists == IME_UIWND_LEVEL1) || (uists == IME_UIWND_LEVEL2)))
                    ImeUIOnLayoutChange((HIMC)imc);
            }
            break;
        case IMN_GUIDELINE:
            break;
        case WM_IME_STARTCOMPOSITION:
            {
                TLS* ptls = TLS::GetTLS();
                if (ptls != NULL)
                {
                    LANGID langid;
                    CicProfile* _pProfile = ptls->GetCicProfile();
                    if (_pProfile != NULL)
                    {
                        _pProfile->GetLangId(&langid);
                        _pCicContext->InquireIMECharPosition(langid, imc, NULL);
                    }
                }
            }
            break;
        case WM_IME_ENDCOMPOSITION:
            _pCicContext->ResetIMECharPosition();
            break;
        case IMN_PRIVATE_ONLAYOUTCHANGE:
            ImeUIOnLayoutChange((HIMC)lParam);
            break;
        case IMN_PRIVATE_ONCLEARDOCFEEDBUFFER:
            ImeUIPrivateHandler(uMsg, wParam, lParam);
            break;
        case IMN_PRIVATE_GETCONTEXTFLAG:
        case IMN_PRIVATE_GETCANDRECTFROMCOMPOSITION:
        case IMN_PRIVATE_GETTEXTEXT:
            {
                UI* pv = (UI*)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
                if (pv == NULL)
                {
                    DebugMsg(TF_ERROR, TEXT("CIMEUIWindowHandler::ImeUINotifyHandler. pv==NULL"));
                    break;
                }

                switch (wParam)
                {
                    case IMN_PRIVATE_GETCONTEXTFLAG:
                        {
                            IME_UIWND_STATE uists;
                            pv->OnPrivateGetContextFlag(imc, _pCicContext->m_fStartComposition.IsSetFlag(), &uists);
                            return (LRESULT)uists;
                        }
                        break;
                    case IMN_PRIVATE_GETCANDRECTFROMCOMPOSITION:
                        return pv->OnPrivateGetCandRectFromComposition(imc, (UIComposition::CandRectFromComposition*)lParam);
                    case IMN_PRIVATE_GETTEXTEXT:
                        {
                            pv->OnPrivateGetTextExtent(imc, (UIComposition::TEXTEXT*)lParam);
                            return 1L;
                        }
                }
            }
            break;
        case IMN_PRIVATE_STARTLAYOUTCHANGE:
            ImeUIOnLayoutChange((HIMC)imc);
            break;

        case IMN_PRIVATE_DELAYRECONVERTFUNCCALL:
            SetTimer(hUIWnd, 
                     UIWND_TIMERID_IME_DELAYUNDORECONV,
                     100, 
                     NULL);
            break;
        case IMN_PRIVATE_GETUIWND:
            return (LRESULT)hUIWnd;
    }

    return 0L;
}


/* static */
LRESULT
CIMEUIWindowHandler::ImeUIDelayedReconvertFuncCall(
    HWND hUIWnd)
{
    DebugMsg(TF_FUNC, TEXT("ImeUINotifyHandler"));

    HRESULT hr;
    IMCLock imc((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC));
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIDelayedReconvertFuncCall. imc==NULL"));
        return 0L;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIDelayedReconvertFuncCall. imc_ctfime==NULL"));
        return 0L;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIDelayedReconvertFuncCall. _pCicContext==NULL"));
        return 0L;
    }

    _pCicContext->DelayedReconvertFuncCall(imc);
    return 0L;
}

/* static */
LRESULT
CIMEUIWindowHandler::ImeUIMsImeHandler(
    HWND hUIWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    if (uMsg == WM_MSIME_MOUSE) {
        return ImeUIMsImeMouseHandler(hUIWnd, uMsg, wParam, lParam);
    }
    else if (uMsg == WM_MSIME_MODEBIAS)
    {
        return ImeUIMsImeModeBiasHandler(hUIWnd, wParam, lParam);
    }
    else if (uMsg == WM_MSIME_RECONVERTREQUEST)
    {
        return ImeUIMsImeReconvertRequest(hUIWnd, uMsg, wParam, lParam);
    }
    else if (uMsg ==  WM_MSIME_SERVICE)
    {
        TLS* ptls = TLS::GetTLS();
        if (ptls != NULL)
        {
            LANGID langid;
            CicProfile* _pProfile = ptls->GetCicProfile();
            if (_pProfile != NULL)
            {
                _pProfile->GetLangId(&langid);

                if (PRIMARYLANGID(langid) == LANG_KOREAN)
                    return 0L;
            }
        }

        return 1L;    // Win32 Layer support WM_MSIME_xxxx message.
    }

    return 0L;
}

/* static */
LRESULT
CIMEUIWindowHandler::ImeUIMsImeMouseHandler(
    HWND hUIWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)

/*++

Method:

    WM_MSIME_MOUSE

Routine Description:

    Mouse Operation on Composition String

Arguments:

    wParam - Mouse operation code.
                 LOBYTE(LOWORD(wParam))
                     IMEMOUSE_VERSION
                     IMEMOUSE_NONE
                     IMEMOUSE_LDOWN
                     IMEMOUSE_RDOWN
                     IMEMOUSE_MDOWN
                     IMEMOUSE_WUP
                     IMEMOUSE_WDOWN
                 HIBYTE(LOWORD(wParam))
                     Mouse Position
                 HIWORD(wParam)
                     Clicked position
    lParam - Input Context handle (HIMC).

Return Value:

    Returns 1 if IME handled this message.
    IMEMOUSERET_NOTHANDLED if IME did not handled this message.

--*/

{
    DebugMsg(TF_FUNC, TEXT("ImeUIMsImeMouseHandler"));

    ULONG dwBtnStatus;

    // special case: version check
    if (LOBYTE(LOWORD(wParam)) == IMEMOUSE_VERSION)
        return 1; // we support version 1.0

    HRESULT hr;
    IMCLock imc((HIMC)lParam);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeMouseHandler. imc==NULL"));
        return IMEMOUSERET_NOTHANDLED;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeMouseHandler. imc_ctfime==NULL"));
        return IMEMOUSERET_NOTHANDLED;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeMouseHandler. _pCicContext==NULL"));
        return IMEMOUSERET_NOTHANDLED;
    }

    ULONG uEdge       = HIWORD(wParam);
    ULONG uQuadrant   = HIBYTE(LOWORD(wParam));
    ULONG dwBtnStatusIme = LOBYTE(LOWORD(wParam));

    //
    // need to xlate dwBtnStatus from WM_MSIME_MOUSE flags to WM_MOUSE flags
    //
    dwBtnStatus = 0;

    if (dwBtnStatusIme & IMEMOUSE_LDOWN)
    {
        dwBtnStatus |= MK_LBUTTON;
    }
    if (dwBtnStatusIme & IMEMOUSE_MDOWN)
    {
        dwBtnStatus |= MK_MBUTTON;
    }
    if (dwBtnStatusIme & IMEMOUSE_RDOWN)
    {
        dwBtnStatus |= MK_RBUTTON;
    }

    // mouse wheel needs to be xlated from IMEMOUSE_WUP/IMEMOUSE_WDOWN to WHEEL_DELTA units 
    if (dwBtnStatusIme & IMEMOUSE_WUP)
    {
        dwBtnStatus |= (WHEEL_DELTA << 16);
    }
    else if (dwBtnStatusIme & IMEMOUSE_WDOWN)
    {
        dwBtnStatus |= (((unsigned long)(-WHEEL_DELTA)) << 16);
    }

    return _pCicContext->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc);
}

/*++

Method:

    CIMEUIWindowHandler::ImeUIMsImeModeBiasHandler

Routine Description:

    Handles WM_MSIME_MODEBIAS messages sent to the ui window.

Arguments:

    wParam - [in] operation: get version, get mode, set mode
    lParam - [in] for set mode, the new bias
                  otherwise ignored

Return Value:

    If wParam is MODEBIAS_GETVERSION, returns version number of interface.
    If wParam is MODEBIAS_SETVALUE, returns non-zero value if succeeded. Returns 0 if fail.
    If wParam is MODEBIAS_GETVALUE, returns current bias mode.
    
--*/

/* static */
LRESULT
CIMEUIWindowHandler::ImeUIMsImeModeBiasHandler(
    HWND hUIWnd,
    WPARAM wParam,
    LPARAM lParam)
{
    DebugMsg(TF_FUNC, TEXT("ImeUIMsImeModeBiasHandler"));

    if (wParam == MODEBIAS_GETVERSION)
        return 1; // version 1
       
    HRESULT hr;
    IMCLock imc((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC));
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeModeBiasHandler. imc==NULL"));
        return 0;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeModeBiasHandler. imc_ctfime==NULL"));
        return 0;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeModeBiasHandler. _pCicContext==NULL"));
        return 0;
    }

    GUID guidModeBias;

    switch (wParam)
    {
        case MODEBIAS_GETVALUE:
            guidModeBias = _pCicContext->m_ModeBias.GetModeBias();
            return _pCicContext->m_ModeBias.ConvertModeBias(guidModeBias);

        case MODEBIAS_SETVALUE:
            // check lParam
            if (lParam != MODEBIASMODE_DEFAULT &&
                lParam != MODEBIASMODE_FILENAME &&
                lParam != MODEBIASMODE_DIGIT    &&
                lParam != MODEBIASMODE_URLHISTORY  )
            {
                Assert(0); // bogus mode bias!
                return 0;  // failure
            }

            // set the new value
            guidModeBias = _pCicContext->m_ModeBias.ConvertModeBias(lParam);
            _pCicContext->m_ModeBias.SetModeBias(guidModeBias);
            _pCicContext->m_fOnceModeChanged.SetFlag();

            // let cicero know the mode bias has changed
            Interface_Attach<ITfContextOwnerServices> iccb = _pCicContext->GetInputContextOwnerSink();
            iccb->OnAttributeChange(GUID_PROP_MODEBIAS);

            return 1; // success
    }

    Assert(0); // should never get here; bogus wParam
    return 0;
}

/* static */
LRESULT
CIMEUIWindowHandler::ImeUIPrivateHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)

/*++

Method:

    CIMEUIWindowHandler::ImeUIPrivateHandler

Routine Description:

    Handles WM_PRIVATE_xxx messages sent to the ui window.

Arguments:

    lParam - [in] HIMC : input context handle

Return Value:

--*/

{
    DebugMsg(TF_FUNC, TEXT("ImeUIPrivateHandler"));

    HRESULT hr;
    IMCLock imc((HIMC)lParam);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIPrivateHandler. imc==NULL"));
        return 0;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIPrivateHandler. imc_ctfime==NULL"));
        return 0;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIPrivateHandler. _pCicContext==NULL"));
        return 0;
    }

    if (wParam == IMN_PRIVATE_ONCLEARDOCFEEDBUFFER) {
        //
        // Clear DocFeed buffer
        // Find GUID_PROP_MSIMTF_READONLY property and SetText(NULL).
        //
        _pCicContext->ClearDocFeedBuffer(imc);  // TF_ES_SYNC
    }

    return S_OK;
}

/* static */
LRESULT
CIMEUIWindowHandler::ImeUIOnLayoutChange(HIMC hIMC)
{
    DebugMsg(TF_FUNC, TEXT("OnLayoutChange"));

    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("OnLayoutChange. imc==NULL"));
        return 0;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("OnLayoutChange. imc_ctfime==NULL"));
        return 0;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("OnLayoutChange. _pCicContext==NULL"));
        return 0;
    }

    Interface_Attach<ITfContextOwnerServices> iccb = _pCicContext->GetInputContextOwnerSink();

    iccb->AddRef();

    /*
     * Repositioning candidate window
     */
    iccb->OnLayoutChange();
    iccb->Release();

    return S_OK;
}


/* static */
LRESULT
CIMEUIWindowHandler::ImeUIMsImeReconvertRequest(
    HWND hUIWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DebugMsg(TF_FUNC, TEXT("ImeUIMsImeReconvertRequest"));

    if (wParam == FID_RECONVERT_VERSION)
    {
        // they're asking for version # so return something
        return 1L;
    }

    HRESULT hr;
    IMCLock imc((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC));
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeReconvertRequest. imc==NULL"));
        return 0L;
    }

    IMCCLock<CTFIMECONTEXT> imc_ctfime(imc->hCtfImeContext);
    if (FAILED(hr=imc_ctfime.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeReconvertRequest. imc_ctfime==NULL"));
        return 0L;
    }

    CicInputContext* _pCicContext = imc_ctfime->m_pCicContext;
    if (_pCicContext == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeReconvertRequest. _pCicContext==NULL"));
        return 0L;
    }

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeReconvertRequest. ptls==NULL."));
        return 0L;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeReconvertRequest. ptim_P==NULL."));
        return 0L;
    }

    UINT cp = CP_ACP;
    CicProfile* _pProfile = ptls->GetCicProfile();
    if (_pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeUIMsImeReconvertRequest. _pProfile==NULL."));
        return 0L;
    }

    _pProfile->GetCodePageA(&cp);

    _pCicContext->SetupReconvertString(imc, ptim_P, cp, WM_MSIME_RECONVERT, FALSE);
    _pCicContext->EndReconvertString(imc);

    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\wrapper.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    wrapper.cpp

Abstract:

    This file implements the IME entry.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "tls.h"
#include "cic.h"
#include "uiwndhd.h"
#include "delay.h"
#include "profile.h"

extern "C" {

DWORD WINAPI ImeConversionList(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    DebugMsg(TF_ERROR, TEXT("ImeConversionList. Not support."));
    Assert(0);
    return 0;
}

BOOL WINAPI ImeConfigure(
    HKL         hKL,            // hKL of this IME
    HWND        hAppWnd,        // the owner window
    DWORD       dwMode,         // mode of dialog
    LPVOID      lpData)         // the data depend on each mode
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeConfigure. ptls==NULL."));
        return FALSE;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeConfigure. cic==NULL."));
        return FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeConfigure. ptim_P==NULL."));
        return FALSE;
    }

    if (dwMode & IME_CONFIG_GENERAL)
    {
        return cic->ConfigureGeneral(ptls, ptim_P, hKL, hAppWnd) == S_OK ? TRUE : FALSE;
    }
    else if (dwMode & IME_CONFIG_REGISTERWORD)
    {
        return cic->ConfigureRegisterWord(ptls, ptim_P, hKL, hAppWnd, (REGISTERWORDW*)lpData) == S_OK ? TRUE : FALSE;
    }
    else
    {
        DebugMsg(TF_ERROR, TEXT("ImeConfigure(%x). Not support."), dwMode);
        Assert(0);
    }
    return FALSE;
}

BOOL WINAPI ImeDestroy(
    UINT        uReserved)
{
    TLS* ptls = TLS::ReferenceTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeDestroy. ptls==NULL."));
        return FALSE;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeDestroy. cic==NULL."));
        return FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeDestroy. ptim_P==NULL."));
        return FALSE;
    }

    if (ptls->GetSystemInfoFlags() & IME_SYSINFO_WINLOGON)
    {
        DebugMsg(TF_FUNC, TEXT("ImeDestroy. dwSystemInfoFlags=IME_SYSINFO_WINLOGON."));
        return TRUE;
    }
    else
    {
        HRESULT hr = cic->DeactivateIMMX(ptls, ptim_P);
        if (hr == S_OK)
        {
            return cic->UnInitIMMX(ptls);
        }
    }
    return FALSE;
}

LRESULT WINAPI ImeEscape(
    HIMC        hIMC,
    UINT        uSubFunc,
    LPVOID      lpData)
{
    DebugMsg(TF_ERROR, TEXT("ImeEscape. Never called when Cicero unaware support."));
    Assert(0);
    return FALSE;
}

BOOL WINAPI ImeInquire(
    LPIMEINFO   lpImeInfo,      // IME specific data report to IMM
    LPTSTR      lpszWndCls,     // the class name of UI
    DWORD       dwSystemInfoFlags)
{
    DebugMsg(TF_ERROR, TEXT("ImeInquire. Never called when Cicero unaware support."));
    Assert(0);
    return FALSE;
}

BOOL WINAPI ImeProcessKey(
    HIMC         hIMC,
    UINT         uVirtKey,
    LPARAM       lParam,
    CONST LPBYTE lpbKeyState)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeProcessKey. ptls==NULL."));
        return FALSE;
    }


    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeProcessKey. cic==NULL."));
        return FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeProcessKey. ptim_P==NULL."));
        return FALSE;
    }

    if (ptls->IsCTFAware())
    {
        Interface<ITfDocumentMgr> pdimFocus; 

        ptim_P->GetFocus(pdimFocus);
        if ((ITfDocumentMgr*)pdimFocus) 
        {
            //
            // Check if it is our dim or app dim.
            // if it is app dim, it is Cicero aware app.
            //
            //
            if (!cic->IsOwnDim((ITfDocumentMgr*)pdimFocus))
                return FALSE;
         
        }
        
        DebugMsg(TF_ERROR, TEXT("ImeProcessKey. why IsCTFAware?"));
    }

    if (ptls->IsAIMMAware())
    {
        // This is AIMM aware application.
        //
        // check imc->hWnd is filtered or not.
        //
        if (MsimtfIsGuidMapEnable(hIMC, NULL))
             return FALSE;

        DebugMsg(TF_ERROR, TEXT("ImeProcessKey. why IsAIMMAware?"));
    }

    //
    // #476089
    //
    // MSCTF.DLL handles Alt+VKDBE and pass it to KeyStrokeManager if focus DIM
    // is available. So msctfime does not have to handle this.
    // 
    //    MSCTF!HandleDBEKeys() in hotkey.cpp checks
    //       - if it is Japanese layout.
    //       - if ptim->_GetFocusDocInputMgr() is not NULL.
    //       - if ALT is down.
    //
    // Alt+VK_DBE_xxx key comes here even if IME does not have 
    // IME_PROP_NEED_ALTKEY.
    //
    if ((HIWORD(lParam) & KF_ALTDOWN) &&
        (LOWORD(GetKeyboardLayout(0)) == 0x411))
    {
        if (IsVKDBEKey(uVirtKey))
             return FALSE;
    }

    return cic->ProcessKey(ptls, ptim_P, hIMC, uVirtKey, lParam, lpbKeyState);
}


BOOL WINAPI CtfImeProcessCicHotkey(
    HIMC         hIMC,
    UINT         uVirtKey,
    LPARAM       lParam)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeProcessCicHotkey. ptls==NULL."));
        return FALSE;
    }

    Interface<ITfThreadMgr>   ptim;
    Interface<ITfThreadMgr_P> ptim_P;
    HRESULT hr;

    //
    // ITfThreadMgr is per thread instance.
    //
    hr = TF_GetThreadMgr(ptim);
    if (hr != S_OK)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeProcessCicHotkey. TF_GetThreadMgr failed"));
        Assert(0); // couldn't create tim!
        return FALSE;
    }

    hr = ptim->QueryInterface(IID_ITfThreadMgr_P, (void **)ptim_P);

    if (hr != S_OK)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeProcessCicHotkey. IID_ITfThreadMgr_P==NULL"));
        Assert(0); // couldn't find ITfThreadMgr_P
        return FALSE;
    }

    if (!CtfImmIsCiceroStartedInThread()) {
        DebugMsg(TF_ERROR, TEXT("CicBridge::ProcessCicHotkey. StopImm32HotkeyHandler returns Error."));
        return FALSE;
    }

    BOOL bHandled;

    hr = ptim_P->CallImm32HotkeyHanlder((WPARAM)uVirtKey, lParam, &bHandled);

    if (FAILED(hr)) {
        DebugMsg(TF_ERROR, TEXT("CtfImeProcessCicHotkey. CallImm32HotkeyHandler returns Error."));
        return FALSE;
    }

    return bHandled;
}

BOOL WINAPI ImeSelect(
    HIMC   hIMC,
    BOOL   fSelect)
{
    DebugMsg(TF_ERROR, TEXT("ImeSelect. Never called when Cicero unaware support."));
    Assert(0);
    return FALSE;
}

BOOL WINAPI ImeSetActiveContext(
    HIMC        hIMC,
    BOOL        fOn)
{
    DebugMsg(TF_ERROR, TEXT("ImeSetActiveContext. Never called when Cicero unaware support."));
    Assert(0);
    return FALSE;
}

BOOL WINAPI ImeSetCompositionString(
    HIMC        hIMC,
    DWORD       dwIndex,
    LPVOID      lpComp,
    DWORD       dwCompLen,
    LPVOID      lpRead,
    DWORD       dwReadLen)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeSetCompositionString. ptls==NULL."));
        return FALSE;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeSetCompositionString. cic==NULL."));
        return FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeSetCompositionString. ptim_P==NULL."));
        return FALSE;
    }

    return cic->SetCompositionString(ptls, ptim_P, hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
}

UINT WINAPI ImeToAsciiEx(
    UINT         uVirtKey,
    UINT         uScanCode,
    CONST LPBYTE lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT         fuState,
    HIMC         hIMC)
{
    UINT uNum = 0;
    HRESULT hr;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeToAsciiEx. ptls==NULL."));
        return 0;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeToAsciiEx. cic==NULL."));
        return 0;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("ImeToAsciiEx. ptim_P==NULL."));
        return 0;
    }

    hr = cic->ToAsciiEx(ptls, ptim_P, uVirtKey, uScanCode, lpbKeyState, lpTransBuf, fuState, hIMC, &uNum);

    if (hr != S_OK)
    {
        uNum = 0;
    }

    return uNum;
}

BOOL WINAPI NotifyIME(
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("NotifyIME. ptls==NULL."));
        return FALSE;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("NotifyIME. cic==NULL."));
        return FALSE;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("NotifyIME. ptim_P==NULL."));
        return FALSE;
    }

    return cic->Notify(ptls, ptim_P, hIMC, dwAction, dwIndex, dwValue) == S_OK ? TRUE : FALSE;
}

BOOL WINAPI ImeRegisterWord(
    LPCTSTR     lpszReading,
    DWORD       dwStyle,
    LPCTSTR     lpszString)
{
    DebugMsg(TF_ERROR, TEXT("ImeRegisterWord. Not support."));
    Assert(0);
    return FALSE;
}

BOOL WINAPI ImeUnregisterWord(
    LPCTSTR     lpszReading,
    DWORD       dwStyle,
    LPCTSTR     lpszString)
{
    DebugMsg(TF_ERROR, TEXT("ImeUnregisterWord. Not support."));
    Assert(0);
    return FALSE;
}

UINT WINAPI ImeGetRegisterWordStyle(
    UINT        nItem,
    LPSTYLEBUF  lpStyleBuf)
{
    DebugMsg(TF_ERROR, TEXT("ImeGetRegisterWordStyle. Not support."));
    Assert(0);
    return FALSE;
}

UINT WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
    DebugMsg(TF_ERROR, TEXT("ImeEnumRegisterWord. Not support."));
    Assert(0);
    return FALSE;
}

LRESULT CALLBACK UIWndProc(
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return CIMEUIWindowHandler::ImeUIWndProcWorker(hUIWnd, uMsg, wParam, lParam);
}

//
// Cicero IME extended entry
//
HRESULT WINAPI CtfImeInquireExW(
    LPIMEINFO   lpImeInfo,      // IME specific data report to IMM
    LPWSTR      lpszWndCls,     // the class name of UI
    DWORD       dwSystemInfoFlags,
    HKL         hKL)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeInquireExW. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    DebugMsg(TF_FUNC, TEXT("CtfImeInquireExW. hKL=%lx, dwSystemInfoFlags=%lx."), hKL, dwSystemInfoFlags);

    //
    // Bug#524962 - Won't support CUAS in case of unauthorized user.
    //
    if (!IsInteractiveUserLogon())
    {
        g_bWinLogon = TRUE;
        dwSystemInfoFlags |= IME_SYSINFO_WINLOGON;
    }

    ptls->SetSystemInfoFlags(dwSystemInfoFlags);
#if 0
    //
    // Even this is WinLogon process, never return error code to imm32.
    // Once imm32 receives error code with some hKL,
    // This hKL is marked IMEF_LOADERROR then all desktop doesn't load this IME.
    //
    if (ptls->GetSystemInfoFlags() & IME_SYSINFO_WINLOGON)
    {
        return E_NOTIMPL;
    }
#endif
    return Inquire(lpImeInfo, lpszWndCls, dwSystemInfoFlags, hKL);
}

HRESULT WINAPI CtfImeCreateThreadMgr()
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeCreateThreadMgr. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        cic = new CicBridge;
        if (cic == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CtfImeCreateThreadMgr. cic==NULL."));
            return E_OUTOFMEMORY;
        }
        ptls->SetCicBridge(cic);
    }
    HRESULT hr;

    if (g_bWinLogon || (ptls->GetSystemInfoFlags() & IME_SYSINFO_WINLOGON))
    {
        DebugMsg(TF_FUNC, TEXT("CtfImeCreateThreadMgr. dwSystemInfoFlags=IME_SYSINFO_WINLOGON."));
        hr = S_OK;
    }
    else
    {
        hr = cic->InitIMMX(ptls);
        if (SUCCEEDED(hr))
        {
            ITfThreadMgr_P* ptim_P = ptls->GetTIM();
            if (ptim_P == NULL)
            {
                DebugMsg(TF_ERROR, TEXT("CtfImeCreateThreadMgr. ptim_P==NULL."));
                return E_OUTOFMEMORY;
            }

            hr = cic->ActivateIMMX(ptls, ptim_P);
            if (FAILED(hr))
            {
                DebugMsg(TF_ERROR, TEXT("CtfImeCreateThreadMgr. cic->ActivateIMMX==NULL."));
                cic->UnInitIMMX(ptls);
            }
        }
    }
    return hr;
}

HRESULT WINAPI CtfImeDestroyThreadMgr()
{
    TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                      // DllMain -> ImeDestroy -> DeactivateIMMX -> Deactivate
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeDestroyThreadMgr. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        cic = new CicBridge;
        if (cic == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CtfImeDestroyThreadMgr. cic==NULL."));
            return E_OUTOFMEMORY;
        }
        ptls->SetCicBridge(cic);
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeDestroyThreadMgr. ptim_P==NULL."));
        return E_OUTOFMEMORY;
    }

    if (ptls->GetSystemInfoFlags() & IME_SYSINFO_WINLOGON)
    {
        DebugMsg(TF_FUNC, TEXT("CtfImeDestroyThreadMgr. dwSystemInfoFlags=IME_SYSINFO_WINLOGON."));
        return S_OK;
    }
    else
    {
        HRESULT hr = cic->DeactivateIMMX(ptls, ptim_P);
        if (hr == S_OK)
        {
            cic->UnInitIMMX(ptls);
        }
        return hr;
    }
}

HRESULT WINAPI CtfImeCreateInputContext(
    HIMC hImc)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeCreateInputContext. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeCreateInputContext. cic==NULL."));
        return E_OUTOFMEMORY;
    }
    return cic->CreateInputContext(ptls, hImc);
}

HRESULT WINAPI CtfImeDestroyInputContext(
    HIMC hImc)
{
    TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                      // IMM32::ImmDllInitialize -> IMM32::DestroyInputContext
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeDestroyInputContext. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeDestroyInputContext. cic==NULL."));
        return E_OUTOFMEMORY;
    }
    return cic->DestroyInputContext(ptls, hImc);
}

HRESULT InternalSelectEx(
    HIMC   hImc,
    BOOL   fSelect,
    HKL    hKL)
{
    DebugMsg(TF_FUNC, TEXT("InternalSelectEx(hImc=%x, fSelect=%x, hKL=%x)"), hImc, fSelect, hKL);

    HRESULT hr;
    IMCLock imc(hImc);
    if (FAILED(hr = imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("InternalSelectEx. imc==NULL"));
        return hr;
    }

    LANGID langid = LANGIDFROMLCID(PtrToUlong(hKL));

    //
    // Chinese Legacy IME hack code for near caret IME.
    //
    if (PRIMARYLANGID(langid) == LANG_CHINESE)
    {
        imc->cfCandForm[0].dwStyle = CFS_DEFAULT;
        imc->cfCandForm[0].dwIndex = (DWORD)-1;
    }

    if (fSelect)
    {
        if (! imc.ClearCand()) {
            return E_FAIL;
        }

        if ((imc->fdwInit & INIT_CONVERSION) == 0) {

            DWORD fdwConvForLang = (imc->fdwConversion & IME_CMODE_SOFTKBD); // = IME_CMODE_ALPHANUMERIC
            if (langid)
            {
                switch(PRIMARYLANGID(langid))
                {
                    case LANG_JAPANESE:
                        //
                        // Roman-FullShape-Native is a major convmode to
                        // initialize.
                        //
                        fdwConvForLang |= IME_CMODE_ROMAN |
                                          IME_CMODE_FULLSHAPE |
                                          IME_CMODE_NATIVE;
                        break;

                    case LANG_KOREAN:
                        // IME_CMODE_ALPHANUMERIC
                        break;

#ifdef CICERO_4428
                    case LANG_CHINESE:
                        switch(SUBLANGID(langid))
                        {
                            case SUBLANG_CHINESE_TRADITIONAL:
                                // IME_CMODE_ALPHANUMERIC
                                break;
                            default:
                                fdwConvForLang |= IME_CMODE_NATIVE;
                                break;
                        }
                        break;
#endif

                    default:
                        fdwConvForLang |= IME_CMODE_NATIVE;
                        break;
                }
            }
            imc->fdwConversion |= fdwConvForLang;

            imc->fdwInit |= INIT_CONVERSION;
        }

        //
        // Also, initialize extended fdwSentence flag.
        //
        imc->fdwSentence |= IME_SMODE_PHRASEPREDICT;

        if ((imc->fdwInit & INIT_LOGFONT) == 0) {
            HDC hDC;
            HGDIOBJ hSysFont;

            hDC = ::GetDC(imc->hWnd);
            hSysFont = ::GetCurrentObject(hDC, OBJ_FONT);
            LOGFONTW font;
            ::GetObjectW(hSysFont, sizeof(LOGFONTW), &font);
            ::ReleaseDC(NULL, hDC);

            memcpy(&imc->lfFont.W, &font, sizeof(LOGFONTW));

            imc->fdwInit |= INIT_LOGFONT;
        }

        // if this IME is run under Chicago Simplified Chinese version
        imc->lfFont.W.lfCharSet = GetCharsetFromLangId(langid);

        imc.InitContext();

    }
    else {  // being unselected

        //
        // Reset INIT_GUID_ATOM flag here.
        //
        imc->fdwInit &= ~INIT_GUID_ATOM;
    }

    return hr;
}

HRESULT WINAPI CtfImeSelectEx(
    HIMC   hIMC,
    BOOL   fSelect,
    HKL    hKL)
{
    TLS* ptls = TLS::ReferenceTLS();  // Should not allocate TLS. ie. TLS::GetTLS
                                      // IMM32::ImmDllInitialize -> IMM32::DestroyInputContext
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeSelectEx. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    //
    // This is only related hIMC content.
    // Even no cic object, hIMC should be updated.
    //
    InternalSelectEx(hIMC, fSelect, hKL);

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeSelectEx. cic==NULL."));
        return E_OUTOFMEMORY;
    }

    ITfThreadMgr_P* ptim_P = ptls->GetTIM();
    if (ptim_P == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeSelectEx. ptim_P==NULL."));
        return E_OUTOFMEMORY;
    }

    return cic->SelectEx(ptls, ptim_P, hIMC, fSelect, hKL);
}

HRESULT WINAPI CtfImeSetActiveContextAlways(
    HIMC        hIMC,
    BOOL        fOn,
    HWND        hWnd,
    HKL         hKL)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeSetActiveContextAlways. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeSetActiveContextAlways. cic==NULL."));
        return E_OUTOFMEMORY;
    }
    return cic->SetActiveContextAlways(ptls, hIMC, fOn, hWnd, hKL);
}

LRESULT WINAPI CtfImeEscapeEx(
    HIMC        hIMC,
    UINT        uSubFunc,
    LPVOID      lpData,
    HKL         hKL)
{
    if (LOWORD(HandleToUlong(hKL)) == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT))
    {
        TLS* ptls = TLS::GetTLS();
        if (ptls == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CtfImeEscapeEx. ptls==NULL."));
            return FALSE;
        }

        CicBridge* cic = ptls->GetCicBridge();
        if (cic == NULL)
        {
            DebugMsg(TF_ERROR, TEXT("CtfImeEscapeEx. cic==NULL."));
            return FALSE;
        }
        return cic->EscapeKorean(ptls, hIMC, uSubFunc, lpData);
    }
    return FALSE;
}

HRESULT WINAPI CtfImeGetGuidAtom(
    HIMC        hIMC,
    BYTE        bAttr,
    TfGuidAtom* pAtom)
{
    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeGetGuidAtom. ptls==NULL."));
        return E_OUTOFMEMORY;
    }

    CicBridge* cic = ptls->GetCicBridge();
    if (cic == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeGetGuidAtom. cic==NULL."));
        return E_OUTOFMEMORY;
    }
    return cic->GetGuidAtom(ptls, hIMC, bAttr, pAtom);
}

BOOL WINAPI CtfImeIsGuidMapEnable(
    HIMC        hIMC)
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeIsGuidMapEnable. imc==NULL"));
        return FALSE;
    }

    return (imc->fdwInit & INIT_GUID_ATOM) ? TRUE : FALSE;
}

HRESULT WINAPI CtfImeThreadDetach()
{
    ImeDestroy(0);
    return S_OK;
}

BOOL WINAPI CtfImeIsIME(
    HKL hkl)
{
    if (IS_IME_KBDLAYOUT(hkl))
        return TRUE;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeIsIME. ptls==NULL."));
        return FALSE;
    }

    CicProfile* pProfile = ptls->GetCicProfile();
    if (pProfile == NULL)
    {
        DebugMsg(TF_ERROR, TEXT("CtfImeIsIME. pProfile==NULL."));
        return FALSE;
    }

    return (pProfile->IsIME(hkl) == S_OK) ? TRUE : FALSE;
}



} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msctfime\uiwndhd.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    uiwndhd.h

Abstract:

    This file defines the IME UI window handler Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UIWNDHD_H_
#define _UIWNDHD_H_

#include "imc.h"
#include "template.h"
#include "context.h"
#include "globals.h"

class CIMEUIWindowHandler
{
public:
    static LRESULT ImeUIWndProcWorker(HWND hUIWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    static LRESULT ImeUINotifyHandler(HWND hUIWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static LRESULT ImeUIMsImeHandler(HWND hUIWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT ImeUIMsImeMouseHandler(HWND hUIWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT ImeUIMsImeModeBiasHandler(HWND hUIWnd, WPARAM wParam, LPARAM lParam);
    static LRESULT ImeUIMsImeReconvertRequest(HWND hUIWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    friend BOOL IsMsImeMessage(UINT uMsg);

    static LRESULT ImeUIPrivateHandler(UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT ImeUIOnLayoutChange(HIMC hIMC);
    static LRESULT ImeUIDelayedReconvertFuncCall(HWND hUIWnd);

    friend HRESULT OnSetCandidatePos(TLS* ptls, IMCLock& imc, CicInputContext& CicContext);

};


#endif // _UIWNDHD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\case.h ===
//
// case.h
//
// CCaseTextService declaration.
//

#ifndef CASE_H
#define CASE_H

class CLangBarItemButton;
class CSnoopWnd;

class CCaseTextService : public ITfTextInputProcessor,
                         public ITfThreadMgrEventSink,
                         public ITfTextEditSink,
                         public ITfThreadFocusSink,
                         public ITfKeyEventSink
{
public:
    CCaseTextService();
    ~CCaseTextService();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfTextInputProcessor
    STDMETHODIMP Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId);
    STDMETHODIMP Deactivate();

    // ITfThreadMgrEventSink
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pContext);
    STDMETHODIMP OnPopContext(ITfContext *pContext);

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfKeyEventSink
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten);

    // CClassFactory factory callback
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    // server registration
    static BOOL RegisterProfiles();
    static void UnregisterProfiles();
    static BOOL RegisterCategories(BOOL fRegister);
    static BOOL RegisterServer();
    static void UnregisterServer();

    // language bar menu handlers
    static void _Menu_HelloWord(CCaseTextService *_this);
    static void _Menu_FlipSel(CCaseTextService *_this);
    static void _Menu_FlipDoc(CCaseTextService *_this);
    static void _Menu_ShowSnoopWnd(CCaseTextService *_this);
    static void _Menu_FlipKeys(CCaseTextService *_this);

    ITfThreadMgr *_GetThreadMgr() { return _pThreadMgr; }
    TfClientId _GetClientId() { return _tfClientId; }
    BOOL _IsSnoopWndVisible() { return _fShowSnoop; }
    BOOL _IsKeyFlipping() { return _fFlipKeys; }

private:
    // init methods
    BOOL _InitLanguageBar();
    BOOL _InitThreadMgrSink();
    BOOL _InitSnoopWnd();
    BOOL _InitTextEditSink(ITfDocumentMgr *pDocMgr);
    BOOL _InitKeystrokeSink();
    BOOL _InitPreservedKey();

    // uninit methods
    void _UninitLanguageBar();
    void _UninitThreadMgrSink();
    void _UninitSnoopWnd();
    void _UninitKeystrokeSink();
    void _UninitPreservedKey();

    //
    // state
    //

    ITfThreadMgr *_pThreadMgr;
    TfClientId _tfClientId;

    BOOL _fShowSnoop; // hide/show the snoop window popup
    CSnoopWnd *_pSnoopWnd;

    BOOL _fFlipKeys;

    CLangBarItemButton *_pLangBarItem;

    DWORD _dwThreadMgrEventSinkCookie;
    DWORD _dwThreadFocusSinkCookie;
    DWORD _dwTextEditSinkCookie;
    ITfContext *_pTextEditSinkContext;

    LONG _cRef;     // COM ref count
};


#endif // CASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\cutil.h ===
// cutil.h
//
//
#ifndef CUTIL_H
#define CUTIL_H

#include "private.h"

//
// base class for SR engine detection
//
class __declspec(novtable)  CDetectSRUtil 
{
public:
    virtual ~CDetectSRUtil()
    {
        if (m_langidRecognizers.Count() > 0)
            m_langidRecognizers.Clear();
    }

    BOOL    _IsSREnabledForLangInReg(LANGID langidReq);

    LANGID _GetLangIdFromRecognizerToken(HKEY hkeyToken);

    //
    // this is an array of installed recognizers in their langid
    //
    CStructArray<LANGID>             m_langidRecognizers;
};

#endif // CUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\dllmain.cpp ===
//
// dllmain.cpp
//

#include "private.h"
#include "globals.h"
#include "ctflbui.h"
#include "osver.h"

DECLARE_OSVER();

DWORD g_dwThreadDllMain = 0;

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    g_fProcessDetached = FALSE;
    CcshellGetDebugFlags();

    Dbg_MemInit(TEXT("MSLBUI"), NULL);

    if (!g_cs.Init())
        return FALSE;

    g_hInst = hInstance;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
    TF_ClearLangBarAddIns(CLSID_MSLBUI);

    Dbg_MemUninit();

    g_cs.Delete();
    g_fProcessDetached = TRUE;
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    BOOL bRet = TRUE;
    g_dwThreadDllMain = GetCurrentThreadId();

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                bRet = FALSE;
            }
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;
    }

    g_dwThreadDllMain = 0;
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSLBUI"
#define SZ_MODULE       "MSLBUI"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\gcomp.h ===
//
// gcomp.h
//


#ifndef GCOMP_H
#define GCOMP_H

#include "private.h"
#include "strary.h"
#include "immxutil.h"
#include "computil.h"

HRESULT SetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD dw);
HRESULT GetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD *pdw);

#if 0
typedef struct {
    ITfCompartment *pComp;
    DWORD dwCookie;
} CESMAP;
#endif

#define CES_INVALID_COOKIE  ((DWORD)(-1))

typedef HRESULT (*CESCALLBACK)(void *pv, REFGUID rguid);

class CGlobalCompartmentEventSink : public ITfCompartmentEventSink
{
public:
    CGlobalCompartmentEventSink(CESCALLBACK pfnCallback, void *pv);
    virtual ~CGlobalCompartmentEventSink() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCompartmentEventSink
    //
    STDMETHODIMP OnChange(REFGUID rguid);

    HRESULT _Advise(REFGUID rguidComp);
    HRESULT _Unadvise();

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:
    CStructArray<CESMAP> _rgcesmap;

    long _cRef;
    CESCALLBACK _pfnCallback;
    void *_pv;
};

#endif //GCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\cutil.cpp ===
// cutil.cpp
//
// file to put misc utility classes implementation
//
#include "private.h"
#include "xstring.h"
#include "cregkey.h"
#include "strary.h"
#include "cutil.h"


static const char c_szSpeechRecognizersKey[] = "Software\\Microsoft\\Speech\\Recognizers";
static const char c_szSpeechRecognizersTokensKey[] = "Software\\Microsoft\\Speech\\Recognizers\\Tokens";
static const char c_szDefault[] =    "DefaultTokenId";

static const char c_szAttribute[]  = "Attributes";
static const char c_szLanguage[]   = "Language";



_inline BOOL _IsCompatibleLangid(LANGID langidReq, LANGID langidCmp)
{
    if (PRIMARYLANGID(langidReq) == LANG_CHINESE)
    {
        return langidReq == langidCmp;
    }
    else
    {
        return PRIMARYLANGID(langidReq) == PRIMARYLANGID(langidCmp);
    }
}



BOOL CDetectSRUtil::_IsSREnabledForLangInReg(LANGID langidReq)
{
    //
    // We want to see if any installed recognizer can satisfy 
    // the langid requested.
    //
    if (m_langidRecognizers.Count() == 0)
    {
        CMyRegKey regkey;
        char      szRecognizerName[MAX_PATH];
        LONG lret =  regkey.Open(HKEY_LOCAL_MACHINE, 
                                      c_szSpeechRecognizersTokensKey, 
                                      KEY_READ);

        if(ERROR_SUCCESS == lret)
        {
            CMyRegKey regkeyReco;
            DWORD dwIndex = 0;

            while (ERROR_SUCCESS == 
                   regkey.EnumKey(dwIndex, szRecognizerName, ARRAYSIZE(szRecognizerName)))
            {
                lret = regkeyReco.Open(regkey.m_hKey, szRecognizerName, KEY_READ);
                if (ERROR_SUCCESS == lret)
                { 
                    LANGID langid=_GetLangIdFromRecognizerToken(regkeyReco.m_hKey);
                    if (langid)
                    {
                        LANGID *pl = m_langidRecognizers.Append(1);
                        if (pl)
                            *pl = langid;
                    }
                    regkeyReco.Close();
                }
                dwIndex++;
            }
        }
    }

    BOOL fEnabled = FALSE;

    for (int i = 0 ; i < m_langidRecognizers.Count(); i++)
    {
        LANGID *p= m_langidRecognizers.GetPtr(i);

        if (p)
        {
            if (_IsCompatibleLangid(langidReq, *p))
            {
                fEnabled = TRUE;
                break;
            }
        }
    }

    return fEnabled;
}

LANGID CDetectSRUtil::_GetLangIdFromRecognizerToken(HKEY hkeyToken)
{
    LANGID      langid = 0;
    char  szLang[MAX_PATH];
    CMyRegKey regkeyAttr;

    LONG lret = regkeyAttr.Open(hkeyToken, c_szAttribute, KEY_READ);
    if (ERROR_SUCCESS == lret)
    {
        lret = regkeyAttr.QueryValueCch(szLang, c_szLanguage, ARRAYSIZE(szLang));
    }
    if (ERROR_SUCCESS == lret)
    {   
        char *psz = szLang;
        while(*psz && *psz != ';')
        {
            langid = langid << 4;

            if (*psz >= 'a' && *psz <= 'f')
            {
                *psz -= ('a' - 'A');
            }

            if (*psz >= 'A' && *psz <= 'F')
            {
                langid += *psz - 'A' + 10;
            }
            else if (*psz >= '0' && *psz <= '9') 
            {
                langid += *psz - '0';
            }
            psz++;
        }
    }
    return langid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\gcomp.cpp ===
//
// computil.cpp
//

#include "private.h"
#include "gcomp.h"
#include "helpers.h"


extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

//+---------------------------------------------------------------------------
//
//  GetCompartment
//
//----------------------------------------------------------------------------

HRESULT GetGlobalCompartment(REFGUID rguidComp, ITfCompartment **ppComp)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;

    *ppComp = NULL;

    if (FAILED(hr = TF_GetGlobalCompartment(&pCompMgr)))
    {
         Assert(0);
         goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  SetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT SetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD dw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetGlobalCompartment(rguidComp, &pComp)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(0, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetGlobalCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT GetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD *pdw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *pdw = 0;
    if (SUCCEEDED(hr = GetGlobalCompartment(rguidComp, &pComp)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pdw = var.lVal;
        }
        pComp->Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartmentEventSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CGlobalCompartmentEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCompartmentEventSink))
    {
        *ppvObj = SAFECAST(this, ITfCompartmentEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    Assert(0);
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CGlobalCompartmentEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CGlobalCompartmentEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CGlobalCompartmentEventSink::CGlobalCompartmentEventSink(CESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CGlobalCompartmentEventSink"));

    _cRef = 1;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// OnChange
//
//----------------------------------------------------------------------------

STDAPI CGlobalCompartmentEventSink::OnChange(REFGUID rguid)
{
    return _pfnCallback(_pv, rguid);
}

//+---------------------------------------------------------------------------
//
// CGlobalCompartmentEventSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartmentEventSink::_Advise(REFGUID rguidComp)
{
    HRESULT hr;
    ITfSource *pSource = NULL;
    int nCnt;
    CESMAP *pcesmap;

    nCnt = _rgcesmap.Count();
    if (!_rgcesmap.Insert(nCnt, 1))
        return E_OUTOFMEMORY;

    pcesmap = _rgcesmap.GetPtr(nCnt);
    memset(pcesmap, 0, sizeof(CESMAP));

    hr = E_FAIL;

    if (FAILED(hr = GetGlobalCompartment(rguidComp, &pcesmap->pComp)))
    {
        Assert(0);
        goto Exit;
    }

    if (FAILED(hr = pcesmap->pComp->QueryInterface(IID_ITfSource, (void **)&pSource)))
    {
        Assert(0);
        goto Exit;
    }
     

    if (FAILED(hr = pSource->AdviseSink(IID_ITfCompartmentEventSink, (ITfCompartmentEventSink *)this, &pcesmap->dwCookie)))
    {
        Assert(0);
        goto Exit;
    }

    hr = S_OK;

Exit:
    if (FAILED(hr))
    {
        Assert(0);
        SafeReleaseClear(pcesmap->pComp);
        _rgcesmap.Remove(nCnt, 1);
    }

    SafeRelease(pSource);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CGlobalCompartmentEventSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartmentEventSink::_Unadvise()
{
    HRESULT hr;
    int nCnt;
    CESMAP *pcesmap;
    hr = E_FAIL;

    nCnt = _rgcesmap.Count();
    pcesmap = _rgcesmap.GetPtr(0);

    while (nCnt)
    {
        ITfSource *pSource = NULL;
        if (FAILED(pcesmap->pComp->QueryInterface(IID_ITfSource, (void **)&pSource)))
            goto Next;

        if (FAILED(pSource->UnadviseSink(pcesmap->dwCookie)))
            goto Next;

Next:
        SafeReleaseClear(pcesmap->pComp);
        SafeRelease(pSource);
        nCnt--;
        pcesmap++;
    }
    _rgcesmap.Clear();

    hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\globals.h ===
//
// globals.h
//
// Global variable declarations.
//

#ifndef GLOBALS_H
#define GLOBALS_H

#include "ciccs.h"

void DllAddRef();
void DllRelease();


#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

extern HINSTANCE g_hInst;
extern LONG g_cRefDll;
extern CCicCriticalSectionStatic g_cs;
extern BOOL g_fProcessDetached;
extern const CLSID CLSID_MSLBUI;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\globals.cpp ===
//
// globals.cpp
//
// Global variables.
//

#include "private.h"
#include "globals.h"

HINSTANCE g_hInst;

LONG g_cRefDll = -1; // -1 /w no refs, for win95 InterlockedIncrement/Decrement compat

CCicCriticalSectionStatic g_cs;

BOOL g_fProcessDetached = FALSE;


/* a5239e24-2bcf-4915-9c5c-fd50c0f69db2 */
const CLSID CLSID_MSLBUI = { 
    0xa5239e24,
    0x2bcf,
    0x4915,
    {0x9c, 0x5c, 0xfd, 0x50, 0xc0, 0xf6, 0x9d, 0xb2}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\mslbui.h ===
//
// mslbui.h
//


#ifndef MSLBUI_H
#define MSLBUI_H

#include "ctflbui.h"
#include "nui.h"
#include "computil.h"
#include "gcomp.h"
#include "cresstr.h"
#include "cutil.h"
#include "ids.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

extern const GUID GUID_COMPARTMENT_CICPAD;
extern const GUID GUID_COMPARTMENT_SPEECHUISHOWN;

//////////////////////////////////////////////////////////////////////////////
//
// CUnCicAppLangBarAddIn
//
//////////////////////////////////////////////////////////////////////////////

class CUnCicAppLangBarAddIn : public ITfLangBarAddIn, CDetectSRUtil
{
public:
    CUnCicAppLangBarAddIn();
    ~CUnCicAppLangBarAddIn();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangBarAddIn methods
    //
    STDMETHODIMP OnStart(CLSID *pclsid);
    STDMETHODIMP OnUpdate(DWORD dwFlags);
    STDMETHODIMP OnTerminate();


    DWORD GetUIStatus()
    {
        if (!_ptim)
        {
            if (!SUCCEEDED(TF_GetThreadMgr(&_ptim)) || !_ptim)
            {
                return 0;
            }
        }
        
        DWORD dw;
        GetCompartmentDWORD(_ptim, GUID_COMPARTMENT_SPEECHUISHOWN, &dw, FALSE);
        return dw;
    }
private:
    
    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);
    
    void _DeleteSpeechUIItems();

    // utility
    void AddItemBalloon();
    void RemoveItemBalloon();

    void ToggleMicrophoneBtn( BOOL  fOn);
    void SetBalloonText(WCHAR  *pwszText);

    ITfLangBarItemMgr *_plbim;
    ITfCompartmentMgr *_pCompMgr;
    ITfThreadMgr      *_ptim;

    CLBarCicPadItem *_pCicPadItem;
    CLBarItemMicrophone *_pMicrophoneItem;
    CLBarItemBalloon    *_pBalloonItem;
    CLBarItemCfgMenuButton *_pCfgMenuItem;

    CGlobalCompartmentEventSink *_pces;

#ifdef DEBUG
    CLBarTestItem *_pTestItem;
#endif

    long _cRef;
};


BOOL GetBalloonStatus();
void SetBalloonStatus(BOOL fShow, BOOL fForce);

#define LANGIDFROMHKL(x) LANGID(LOWORD(HandleToLong(x)))

#endif MSLBUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\ids.h ===
//
// ids.h
//


#ifndef IDS_H
#define IDS_H


//
// Icon
//
#define ID_ICON_CICPAD 100
#define ID_ICON_TEST   101
#define ID_ICON_CFGMENU        5
#define ID_ICON_MICROPHONE     6

#define IDS_NUI_CFGMENU_TOOLTIP    405
#define IDS_NUI_CFGMENU_TEXT       406
#define IDS_NUI_BALLOON_TOOLTIP    407
#define IDS_NUI_BALLOON_TEXT       408
#define IDS_NUI_MICROPHONE_TOOLTIP 409
#define IDS_NUI_MICROPHONE_TEXT    410
#define IDS_NUI_COMMANDING_TOOLTIP 411
#define IDS_NUI_COMMANDING_TEXT    412
#define IDS_NUI_DICTATION_TOOLTIP  413
#define IDS_NUI_DICTATION_TEXT     414
#define IDS_NUI_STARTINGSPEECH     415
#define IDS_NUI_BEGINDICTATION     416
#define IDS_NUI_BEGINVOICECMD      417

#define IDS_MIC_SHOWBALLOON        420

// menu strings
#define IDS_MIC_OPTIONS            400
#define IDS_MIC_TRAINING           401
#define IDS_MIC_ADDDELETE          402
#define IDS_MIC_CURRENTUSER        403
#define IDS_MIC_SAVEDATA           404

// Balloon Text for Non-Aware Application

#define IDS_MIC_ON                 440

// CUAS status checking
#define IDS_MIC_CUASSTATUS         450
#define IDS_CUAS_RESTART_TITLE     451
#define IDS_CUAS_RESTART_CUASON    452
#define IDS_CUAS_RESTART_CUASOFF   453

// menu ids
#define IDM_MIC_OPTIONS              2
#define IDM_MIC_CUASSTATUS           3



#endif // IDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for simx project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <windows.h>
#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <initguid.h>
#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 
#include "msctf.h"
#include "ctffunc.h"


#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\nui.h ===
//
// nui.h
//

#ifndef NUI_H
#define NUI_H

#include "private.h"
#include "nuibase.h"

extern const GUID GUID_LBI_CICPADITEM;
extern const GUID GUID_LBI_TESTITEM;

#define SORT_MICROPHONE      100
#define SORT_DICTATION       300
#define SORT_COMMANDING      400
#define SORT_BALLOON         500
#define SORT_TTSPLAYSTOP     510
#define SORT_TTSPAUSERESUME  520
#define SORT_CFGMENUBUTTON   600

#define IDSLB_INITMENU        1
#define IDSLB_ONMENUSELECT    2

//////////////////////////////////////////////////////////////////////////////
//
//  LBarCicPadItem
//
//////////////////////////////////////////////////////////////////////////////

class CLBarCicPadItem : public CLBarItemButtonBase
{
public:
    CLBarCicPadItem();
    ~CLBarCicPadItem()
{
Assert(1);
}

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    BOOL _fIsCicPadShown;
};


//////////////////////////////////////////////////////////////////////////////
//
//    LBarItemMicrophone
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemMicrophone : public CLBarItemButtonBase
{
public:
    CLBarItemMicrophone();
    ~CLBarItemMicrophone();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemBalloon : public CLBarItemBalloonBase
{
public:
    CLBarItemBalloon();
    ~CLBarItemBalloon();

    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo);
    void Set(TfLBBalloonStyle style, const WCHAR *psz);

    BOOL NeedUpdate(TfLBBalloonStyle style, const WCHAR *psz)
    {
        return  (!_pszText || _style != style || wcscmp(_pszText, psz) != 0);
    }

private:
    WCHAR *_pszText;
    TfLBBalloonStyle _style;
};


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCfgMenuButton
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCfgMenuButton : public CLBarItemButtonBase
{
public:
    CLBarItemCfgMenuButton();
    ~CLBarItemCfgMenuButton();

    //
    // ITfNotifyUI
    //
    STDMETHODIMP GetIcon(HICON *phIcon);

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT uID);

private:
    HRESULT HandleMenuCmd(UINT uCode, ITfMenu *pMenu, UINT wID);
    void GetSapiCplPath(TCHAR *szCplPath, int cch);
};

//////////////////////////////////////////////////////////////////////////////
//
//  LBarTestItem
//
//////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
class CLBarTestItem : public CLBarItemButtonBase
{
public:
    CLBarTestItem();

    STDMETHODIMP GetIcon(HICON *phIcon);
};
#endif

#endif // NUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\mslbui.cpp ===
//
// mslbui.cpp
//

#include "private.h"
#include "globals.h"
#include "mslbui.h"
#include "helpers.h"


/* 2dc1cc1f-3e09-49c5-9cf0-bf67154dc827 */
const GUID GUID_COMPARTMENT_CICPAD = { 
    0x2dc1cc1f,
    0x3e09,
    0x49c5,
    {0x9c, 0xf0, 0xbf, 0x67, 0x15, 0x4d, 0xc8, 0x27}
  };


// Issue: we should add this to private header 
/* c1a1554f-b715-48e1-921f-716fd7332ce9 */
const GUID GUID_COMPARTMENT_SHARED_BLN_TEXT = {
    0xc1a1554f,
    0xb715,
    0x48e1,
    {0x92, 0x1f, 0x71, 0x6f, 0xd7, 0x33, 0x2c, 0xe9}
};

/* 574e41bb-1bf4-4630-95dd-b143372ac8d0 */
const GUID  GUID_COMPARTMENT_SPEECHUISHOWN = {
    0x574e41bb,
    0x1bf4,
    0x4630,
    {0x95, 0xdd, 0xb1, 0x43, 0x37, 0x2a, 0xc8, 0xd0}
  };

//////////////////////////////////////////////////////////////////////////////
//
//  CTFGetLangBarAddIn
//
//////////////////////////////////////////////////////////////////////////////

HRESULT CTFGetLangBarAddIn(ITfLangBarAddIn **ppAddIn)
{
    CUnCicAppLangBarAddIn *pAddIn;

    *ppAddIn = NULL;
    pAddIn = new CUnCicAppLangBarAddIn;
    if (!pAddIn)
        return E_OUTOFMEMORY;

    *ppAddIn = pAddIn;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CUnCicAppLangBarAddIn
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CUnCicAppLangBarAddIn::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarAddIn))
    {
        *ppvObj = SAFECAST(this, ITfLangBarAddIn *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CUnCicAppLangBarAddIn::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CUnCicAppLangBarAddIn::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CUnCicAppLangBarAddIn::CUnCicAppLangBarAddIn()
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CUnCicAppLangBarAddIn::~CUnCicAppLangBarAddIn()
{
}

//+---------------------------------------------------------------------------
//
// OnStart
//
//----------------------------------------------------------------------------

STDAPI CUnCicAppLangBarAddIn::OnStart(CLSID *pclsid)
{
    ITfLangBarItemMgr *plbim = NULL;

    HRESULT hr;

    Assert(!_plbim);
    Assert(!_pCicPadItem);


    hr = TF_CreateLangBarItemMgr(&plbim);
    if (FAILED(hr))
        return hr;

    if (!plbim)
        return E_FAIL;

    _plbim = plbim;
#ifdef _DEBUG_
    CLBarTestItem *pTestItem;
    pTestItem = new CLBarTestItem;
    if (pTestItem)
    {
        if (SUCCEEDED(plbim->AddItem(pTestItem)))
            _pTestItem = pTestItem;
        else
            Assert(0);
    }
#endif

    *pclsid = CLSID_MSLBUI;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUpdate()
//
//----------------------------------------------------------------------------

STDAPI CUnCicAppLangBarAddIn::OnUpdate(DWORD dwFlags)
{
    HRESULT hr = S_OK;

#if 1
    if (!_pces && 
       (_pces = new CGlobalCompartmentEventSink(_CompEventSinkCallback,this)))
    {    
        hr =_pces->_Advise(GUID_COMPARTMENT_CICPAD);

        if (S_OK == hr)
           hr = _pces->_Advise(GUID_COMPARTMENT_SPEECH_OPENCLOSE);

        if (S_OK == hr)
           hr = _pces->_Advise(GUID_COMPARTMENT_SHARED_BLN_TEXT);

        if (S_OK != hr)
        {
            _pces->_Unadvise();
            delete _pces;
            _pces = NULL;
        }
    }
#endif
    // let's assume language bar item manager is initialized already
    if (!_plbim)
        return E_FAIL;

    DWORD dwMicOn = 0;

    hr = GetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dwMicOn);

    if ( FAILED(hr))
        return hr;
   
    if (_pCicPadItem)
    {
        _pCicPadItem->SetOrClearStatus(TF_LBI_STATUS_HIDDEN,
                                                  dwFlags ? TRUE : FALSE);
        if (_pCicPadItem->GetSink())
           _pCicPadItem->GetSink()->OnUpdate(TF_LBI_STATUS);
    }
#if 0
    else if (!dwFlags) // non-Cicero case
    {
        CLBarCicPadItem *pCicPadItem = NULL;
        // create cicpad item
        pCicPadItem = new CLBarCicPadItem;
        if (!pCicPadItem)
            return E_OUTOFMEMORY;

        hr = _plbim->AddItem(pCicPadItem);

        if (FAILED(hr))
        {
            pCicPadItem->Release();
            return hr;
        }
        
        _pCicPadItem = pCicPadItem;
    }
#endif
    // We don't need to create Mic, Balloon or Cfg menu
    // when the thread has speech UI server running already
    // *OR* the speech isn't installed on the system
    //

    if (!_IsSREnabledForLangInReg(LANGIDFROMHKL(GetSystemDefaultHKL()))
       ||( GetUIStatus() & TF_SPEECHUI_SHOWN ))
    {
        dwFlags |= 1;
        _DeleteSpeechUIItems();
    }

    if (_pMicrophoneItem)
    {
        _pMicrophoneItem->SetOrClearStatus(TF_LBI_STATUS_HIDDEN,
                                                  dwFlags ? TRUE : FALSE);
        if (_pMicrophoneItem->GetSink())
           _pMicrophoneItem->GetSink()->OnUpdate(TF_LBI_STATUS);

    }
    else if (!dwFlags) // non-Cicero case
    {

        CLBarItemMicrophone *pMicrophoneItem = NULL;
        // create microphone item
        pMicrophoneItem = new CLBarItemMicrophone;
        if (!pMicrophoneItem)
            return E_OUTOFMEMORY;

        hr = _plbim->AddItem(pMicrophoneItem);

        if (FAILED(hr))
        {
            pMicrophoneItem->Release();
            return hr;
        }
        _pMicrophoneItem = pMicrophoneItem;
    }

    if ( _pMicrophoneItem && !dwFlags )
    {
        // For Non-Cicero application, we want to show the Mic button
        // as pressed if the MIC status is ON.
        ToggleMicrophoneBtn(dwMicOn ? TRUE : FALSE);
    }

    if (_pBalloonItem)
    {
        _pBalloonItem->SetOrClearStatus(TF_LBI_STATUS_HIDDEN,
                                                  dwFlags ? TRUE : FALSE);
        if (_pBalloonItem->GetSink())
           _pBalloonItem->GetSink()->OnUpdate(TF_LBI_STATUS);

    }
    else // when balloon isn't initialized
    {

        if (dwFlags)
        {
            // this is the case you are on Cicero app
            RemoveItemBalloon();
        }
        else if (dwMicOn)
        {
            // this is the case you are on non-Cicero app
            AddItemBalloon();
        }
    }

    if ( _pBalloonItem && !dwFlags && dwMicOn && GetBalloonStatus())
    {
        // Display "Mic is On" on the balloon for Non-Cicero Aware Application.

        if (!(TF_LBI_STATUS_HIDDEN &
            _pMicrophoneItem->GetStatusInternal()))
        {
           SetBalloonText(CRStr(IDS_MIC_ON));
        }
    }

    if (_pCfgMenuItem)
    {
        _pCfgMenuItem->SetOrClearStatus(TF_LBI_STATUS_HIDDEN,
                                                  dwFlags ? TRUE : FALSE);
        if (_pCfgMenuItem->GetSink())
           _pCfgMenuItem->GetSink()->OnUpdate(TF_LBI_STATUS);

    }
    else if (!dwFlags) // non-Cicero case
    {
        CLBarItemCfgMenuButton *pCfgMenuItem = NULL;

        // create tool menu item
        pCfgMenuItem = new CLBarItemCfgMenuButton;
        if (!pCfgMenuItem)
            return E_OUTOFMEMORY;

        hr = _plbim->AddItem(pCfgMenuItem);

        if (FAILED(hr))
        {
            pCfgMenuItem->Release();
            return hr;
        }
        _pCfgMenuItem = pCfgMenuItem;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CUnCicAppLangBarAddIn::OnTerminate()
{
 
    if (g_fProcessDetached)
        return S_OK;

    if (_pces)
    {    
        _pces->_Unadvise();
        _pces->Release();
        _pces = NULL;
    }

    if (_pCicPadItem)
    {
        _plbim->RemoveItem(_pCicPadItem);
        _pCicPadItem->Release();
        _pCicPadItem = NULL;
    }

    _DeleteSpeechUIItems();

    if (_ptim)
    {
        _ptim->Release();
        _ptim = NULL;
    }

#ifdef _DEBUG_
    if (_pTestItem)
    {
        _plbim->RemoveItem(_pTestItem);
        _pTestItem->Release();
        _pTestItem = NULL;
    }

#endif

    SafeReleaseClear(_plbim);
    SafeReleaseClear(_pCompMgr);

    return S_OK;
}

void CUnCicAppLangBarAddIn::_DeleteSpeechUIItems()
{

    if (_pMicrophoneItem)
    {
        _plbim->RemoveItem(_pMicrophoneItem);
        _pMicrophoneItem->Release();
        _pMicrophoneItem = NULL;
    }

    if (_pBalloonItem)
    {
        _plbim->RemoveItem(_pBalloonItem);
        _pBalloonItem->Release();
        _pBalloonItem = NULL;
    }

    if (_pCfgMenuItem)
    {
        _plbim->RemoveItem(_pCfgMenuItem);
        _pCfgMenuItem->Release();
        _pCfgMenuItem = NULL;
    }
}
//+---------------------------------------------------------------------------
//
// _CompEventSinkCallback
//
//----------------------------------------------------------------------------

HRESULT CUnCicAppLangBarAddIn::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CUnCicAppLangBarAddIn *_this = (CUnCicAppLangBarAddIn *)pv;

    if (!_this)
        return E_FAIL;

    if (IsEqualGUID(rguid, GUID_COMPARTMENT_CICPAD))
    {
        if (!_this->_pCicPadItem)
            return E_FAIL;

        DWORD dw;
        if (SUCCEEDED(GetGlobalCompartmentDWORD(rguid, &dw)))
        {
            _this->_pCicPadItem->SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED,
                                                  dw ? TRUE : FALSE);
            if (_this->_pCicPadItem->GetSink())
               _this->_pCicPadItem->GetSink()->OnUpdate(TF_LBI_STATUS);
        }
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
    {
        if (!_this->_pMicrophoneItem)
            return E_FAIL;

        DWORD dwMicOn;
        if (SUCCEEDED(GetGlobalCompartmentDWORD(rguid, &dwMicOn)))
        {
            _this->ToggleMicrophoneBtn(dwMicOn ? TRUE : FALSE);
        }

        if (!(TF_LBI_STATUS_HIDDEN &
            _this->_pMicrophoneItem->GetStatusInternal()))
        {
            if (GetBalloonStatus() && dwMicOn)
            {
                _this->AddItemBalloon();

                if (_this->_pBalloonItem)
                {
                    _this->SetBalloonText(CRStr(IDS_MIC_ON));
                }

            }
            else
            {
                _this->RemoveItemBalloon();
            }
        }
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SHARED_BLN_TEXT)) 
    {
        if (_this->_pBalloonItem &&
           !(TF_LBI_STATUS_HIDDEN & _this->_pBalloonItem->GetStatusInternal()))
        {
            DWORD   dw;

            if (SUCCEEDED(GetGlobalCompartmentDWORD(rguid, &dw)))
            {
                ATOM hAtom = (WORD)dw;
                WCHAR szAtom[MAX_PATH] = {0};

                GlobalGetAtomNameW(hAtom, szAtom, ARRAYSIZE(szAtom));
        
                _this->SetBalloonText(szAtom);
            }
        }
    }
    
    return S_OK;
}

// 
// Toggle the Microphone Button
//
void CUnCicAppLangBarAddIn::ToggleMicrophoneBtn( BOOL  fOn)
{
    _pMicrophoneItem->SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, fOn);

    if (_pMicrophoneItem->GetSink())
        _pMicrophoneItem->GetSink()->OnUpdate(TF_LBI_STATUS);
}

// 
// Show the Balloon Text for non-cicero Aware Application.
//
void CUnCicAppLangBarAddIn::SetBalloonText(WCHAR  *pwszText )
{
    if (_pBalloonItem && pwszText)
    {
       _pBalloonItem->Set(TF_LB_BALLOON_RECO, pwszText);

       if (_pBalloonItem->GetSink())
       {
           _pBalloonItem->GetSink()->OnUpdate(TF_LBI_BALLOON);
       }
    }
}


//
// Add/Remove ballon item
//
void CUnCicAppLangBarAddIn::AddItemBalloon()
{
    if (!_pBalloonItem)
    {
        _pBalloonItem = new CLBarItemBalloon();
    }

    if (_plbim && _pBalloonItem)
    {
        _plbim->AddItem(_pBalloonItem);
    }
}
void CUnCicAppLangBarAddIn::RemoveItemBalloon()
{
    if (_plbim && _pBalloonItem)
        _plbim->RemoveItem(_pBalloonItem);
}

//
// global functions
//
BOOL GetBalloonStatus()
{
    DWORD dw;
    GetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw);

    return (dw & TF_DISABLE_BALLOON) ? FALSE : TRUE;

}
void SetBalloonStatus(BOOL fShow, BOOL fForce = FALSE)
{
    if (!fForce && fShow == GetBalloonStatus())
        return;

    DWORD dw;
    GetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw);
    dw &= ~TF_DISABLE_BALLOON;
    dw |= fShow ? 0: TF_DISABLE_BALLOON;
    SetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_UI_STATUS, dw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msuimp\prxstub.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prxstub.c
//
//  Contents:   local marshalling code
//
//  Classes:    
//
//  Notes:   	HICON marshals are not explosed through ole32.def
//		so this file defines them locally and just turns
//		around and call the HWND routines which are exposed
//		and marshalled the same way HICON is internal in OLE.
//
//		If Ole32 adds this to the .def on all platforms interested
//		in remoting then this code is no longer necessary
//		   
//
//--------------------------------------------------------------------------


#include "rpcproxy.h"

// local file to define unexported marshal interfaces

unsigned long  __RPC_USER  HICON_UserSize(
		unsigned long * pFlags,
		unsigned long   Offset,
		HICON * pH )
{

	return HWND_UserSize(pFlags,Offset ,(HWND *) pH);
}

unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal( 
		unsigned long * pFlags,
		unsigned char * pBuffer,
		HICON	* pH)
{

	return HWND_UserMarshal( pFlags,pBuffer,(HWND *) pH);

}
 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(
		unsigned long * pFlags,
		unsigned char * pBuffer,
		HICON	* pH)
{

	return HWND_UserUnmarshal(pFlags
				,pBuffer
				, (HWND *) pH);
}

void    __RPC_USER  HICON_UserFree(
		unsigned long * pFlags,
		HICON	* pH)
{

	HWND_UserFree( pFlags,(HWND *) pH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msuimp\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#define _OLEAUT32_

#include <windows.h>
#include <ole2.h>

#define AssertMsg(x, y)

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? _hinst : (_hinst = LoadLibrary(#_dll)))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UCHAR(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, unsigned char *, _fn, _args, _nargs, 0)
#define DELAY_LOAD_ULONG(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, ULONG, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- OLEAUT32.DLL ---------------


HINSTANCE g_hinstOLEAUT32 = NULL;

DELAY_LOAD_ULONG(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR_UserSize,
    (ULONG *pul, ULONG ul, BSTR *pbstr), (pul, ul, pbstr));

DELAY_LOAD_UCHAR(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR_UserMarshal,
    (ULONG *pul, unsigned char *psz, BSTR *pbstr), (pul, psz, pbstr));

DELAY_LOAD_UCHAR(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR_UserUnmarshal,
    (ULONG *pul, unsigned char *psz, BSTR *pbstr), (pul, psz, pbstr));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR_UserFree,
    (ULONG *pul, BSTR *pbstr), (pul, pbstr));

DELAY_LOAD_ULONG(g_hinstOLEAUT32, OLEAUT32.DLL, LPSAFEARRAY_UserSize,
    (ULONG *pul, ULONG ul, LPSAFEARRAY *psa), (pul, ul, psa));

DELAY_LOAD_UCHAR(g_hinstOLEAUT32, OLEAUT32.DLL, LPSAFEARRAY_UserMarshal,
    (ULONG *pul, unsigned char *psz, LPSAFEARRAY *psa), (pul, psz, psa));

DELAY_LOAD_UCHAR(g_hinstOLEAUT32, OLEAUT32.DLL, LPSAFEARRAY_UserUnmarshal,
    (ULONG *pul, unsigned char *psz, LPSAFEARRAY *psa), (pul, psz, psa));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, LPSAFEARRAY_UserFree,
    (ULONG *pul, LPSAFEARRAY *psa), (pul, psa));

DELAY_LOAD_ULONG(g_hinstOLEAUT32, OLEAUT32.DLL, VARIANT_UserSize,
    (ULONG *pul, ULONG ul, VARIANT *pvar), (pul, ul, pvar));

DELAY_LOAD_UCHAR(g_hinstOLEAUT32, OLEAUT32.DLL, VARIANT_UserMarshal,
    (ULONG *pul, unsigned char *psz, VARIANT *pvar), (pul, psz, pvar));

DELAY_LOAD_UCHAR(g_hinstOLEAUT32, OLEAUT32.DLL, VARIANT_UserUnmarshal,
    (ULONG *pul, unsigned char *psz, VARIANT *pvar), (pul, psz, pvar));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, VARIANT_UserFree,
    (ULONG *pul, VARIANT *pvar), (pul, pvar));



#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\mslbui\nui.cpp ===
//
// nui.cpp
//

#include "private.h"
#include "ids.h"
#include "immxutil.h"
#include "nui.h"
#include "slbarid.h"
#include "mslbui.h"
#include "cregkey.h"
#include "tchar.h"


extern HINSTANCE g_hInst;

/* 7e4bf406-00e4-469e-bc40-0ce2cb626849 */
const GUID GUID_LBI_CICPADITEM = { 
    0x7e4bf406,
    0x00e4,
    0x469e,
    {0xbc, 0x40, 0x0c, 0xe2, 0xcb, 0x62, 0x68, 0x49}
  };

/* 2aad8804-c5c8-4d7c-90b3-b5214ac54a9f */
const GUID GUID_LBI_TESTITEM = { 
    0x2aad8804,
    0xc5c8,
    0x4d7c,
    {0x90, 0xb3, 0xb5, 0x21, 0x4a, 0xc5, 0x4a, 0x9f}
  };

const GUID GUID_LBI_UNAWARE_MICROPHONE = { 
    0x24d583e2,
    0xa785,
    0x4b16,
    {0x86, 0x6b, 0xf9, 0xdc, 0x08, 0x1f, 0x4c, 0x2c}
  };

/* 237bdc50-2aaa-44cd-be05-1b452b1acff1 */
const GUID GUID_LBI_UNAWARE_BALLOON = { 
    0x237bdc50,
    0x2aaa,
    0x44cd,
    {0xbe, 0x05, 0x1b, 0x45, 0x2b, 0x1a, 0xcf, 0xf1}
  };

/* a6b9e52b-3ab2-46b8-99d1-e44c1c8b3cf8 */
const GUID GUID_LBI_UNAWARE_CFGMENUBUTTON = {
    0xa6b9e52b,
    0x3ab2,
    0x46b8,
    {0x99, 0xd1, 0xe4, 0x4c, 0x1c, 0x8b, 0x3c, 0xf8}
  };

// == don't know if we use the following 4 items

#ifdef PERHAPS

/* 17f9fa7f-a9ed-47b5-8bcd-eebb94b2e6ca */
const GUID GUID_LBI_UNAWARE_COMMANDING = {
    0x17f9fa7f,
    0xa9ed,
    0x47b5,
    {0x8b, 0xcd, 0xee, 0xbb, 0x94, 0xb2, 0xe6, 0xca}
  };

/* 49261a4a-87df-47fc-8a68-6ea07ba82a87 */
const GUID GUID_LBI_UNAWARE_DICTATION = {
    0x49261a4a,
    0x87df,
    0x47fc,
    {0x8a, 0x68, 0x6e, 0xa0, 0x7b, 0xa8, 0x2a, 0x87}
  };

/* 791b4403-0cda-4fe1-b748-517d049fde08 */
const GUID GUID_LBI_UNAWARE_TTS_PLAY_STOP = {
    0x791b4403,
    0x0cda,
    0x4fe1,
    {0xb7, 0x48, 0x51, 0x7d, 0x04, 0x9f, 0xde, 0x08}
  };

/* e6fbfc9d-a2e0-4203-a27b-af2353e6a44e */
const GUID GUID_LBI_UNAWARE_TTS_PAUSE_RESUME = {
    0xe6fbfc9d,
    0xa2e0,
    0x4203,
    {0xa2, 0x7b, 0xaf, 0x23, 0x53, 0xe6, 0xa4, 0x4e}
  };

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  LBarCicPadItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarCicPadItem::CLBarCicPadItem()
{
    Dbg_MemSetThisName(TEXT("CLBarCicPadItem"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM2,  
                GUID_LBI_CICPADITEM,
                TF_LBI_STYLE_BTN_BUTTON
                | TF_LBI_STYLE_HIDDENSTATUSCONTROL
                | TF_LBI_STYLE_BTN_TOGGLE,
                CICPADBTN_ORDER, 
                L"Cicero Pad");


    SetToolTip(L"CicPad");
    SetText(L"CicPad");
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarCicPadItem::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_CICPAD));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUpHandler
//
//----------------------------------------------------------------------------

const TCHAR c_szCicPadWndClass[]  = TEXT("cicpad_mainwnd");

HRESULT CLBarCicPadItem::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HWND hwnd = FindWindow(c_szCicPadWndClass, NULL);
    if (!hwnd)
    {
        WinExec("cicpad.exe", 0);
        hwnd = FindWindow(c_szCicPadWndClass, NULL);
        if (!hwnd)
            return E_FAIL;

        SetGlobalCompartmentDWORD(GUID_COMPARTMENT_CICPAD, TRUE);
        return S_OK;
    }

  
    DWORD dw;
    if (SUCCEEDED(GetGlobalCompartmentDWORD(GUID_COMPARTMENT_CICPAD, &dw)))
    {
         SetGlobalCompartmentDWORD(GUID_COMPARTMENT_CICPAD, dw ? FALSE : TRUE);
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemMicrophone
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemMicrophone::CLBarItemMicrophone()
{
    Dbg_MemSetThisName(TEXT("CLBarItemMicrophone"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH,
                GUID_LBI_UNAWARE_MICROPHONE,
                 TF_LBI_STYLE_HIDDENSTATUSCONTROL
               | TF_LBI_STYLE_BTN_TOGGLE
               | TF_LBI_STYLE_SHOWNINTRAY,
                SORT_MICROPHONE,
                CRStr(IDS_NUI_MICROPHONE_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_MICROPHONE_TOOLTIP));
    SetText(CRStr(IDS_NUI_MICROPHONE_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemMicrophone::~CLBarItemMicrophone()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemMicrophone::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_MICROPHONE));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemMicrophone::OnLButtonUp(const POINT pt, const RECT *prcArea)
{

    DWORD dw;
    if (SUCCEEDED(GetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw)))
    {
         SetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, dw ? FALSE : TRUE);
    }

    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBalloon::CLBarItemBalloon()
{
    Dbg_MemSetThisName(TEXT("CLBarItemBalloon"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH,
                GUID_LBI_UNAWARE_BALLOON,
                0,
                SORT_BALLOON,
                CRStr(IDS_NUI_BALLOON_TEXT));

    SIZE size;
    size.cx = 100;
    size.cy = 16;
    SetPreferedSize(&size);
    SetToolTip(CRStr(IDS_NUI_BALLOON_TOOLTIP));

    // by default Balloon is hidden.
    // SetStatusInternal(TF_LBI_STATUS_HIDDEN);

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBalloon::~CLBarItemBalloon()
{
    if (_pszText)
        delete _pszText;
}

//+---------------------------------------------------------------------------
//
// GetBalloonInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloon::GetBalloonInfo(TF_LBBALLOONINFO *pInfo)
{
    pInfo->style = _style;
    pInfo->bstrText = SysAllocString(_pszText);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Set
//
//----------------------------------------------------------------------------

void CLBarItemBalloon::Set(TfLBBalloonStyle style, const WCHAR *psz)
{
    if (_pszText)
    {
        delete _pszText;
        _pszText = NULL;
    }

    _pszText = new WCHAR[wcslen(psz) + 1];
    if (_pszText)
    {
        wcscpy(_pszText, psz);
        SetToolTip(_pszText);
    }

    _style = style;

}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCfgmenuButton
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCfgMenuButton::CLBarItemCfgMenuButton()
{
    Dbg_MemSetThisName(TEXT("CLBarItemCfgMenuButton"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH,
                GUID_LBI_UNAWARE_CFGMENUBUTTON,
                TF_LBI_STYLE_BTN_MENU,
                SORT_CFGMENUBUTTON,
                CRStr(IDS_NUI_CFGMENU_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_CFGMENU_TOOLTIP));
    SetText(CRStr(IDS_NUI_CFGMENU_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCfgMenuButton::~CLBarItemCfgMenuButton()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_CFGMENU));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::InitMenu(ITfMenu *pMenu)
{
#if 0 // do I need this?
    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;
    _InsertCustomMenus(pMenu, &nTipCurMenuID);
#endif

    HandleMenuCmd(IDSLB_INITMENU, pMenu, 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::OnMenuSelect(UINT uID)
{
    HRESULT hr;
#if 0 // do I need this?
    if (uID >= IDM_CUSTOM_MENU_START)
        hr =  CLBarItemSystemButtonBase::OnMenuSelect(uID);
    else
#endif
        hr = HandleMenuCmd(IDSLB_ONMENUSELECT, NULL, uID);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  HandleMenuCmd
//  
//  Builds a list of fake menuitems. Nothing's real except "options..."
//  this is because we can't use COM here.
//
//----------------------------------------------------------------------------
HRESULT 
CLBarItemCfgMenuButton::HandleMenuCmd(UINT uCode, ITfMenu *pMenu, UINT wID)
{
    HRESULT hr = S_OK;

    if (uCode == IDSLB_INITMENU)
    {
        WCHAR sz[128];

        sz[0] = '\0';
        LoadStringWrapW(g_hInst, IDS_MIC_OPTIONS, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_OPTIONS, sz);

        sz[0] = '\0';
        LoadStringWrapW(g_hInst, IDS_MIC_SHOWBALLOON, sz, ARRAYSIZE(sz));
        LangBarInsertGrayedMenu(pMenu, sz);

        sz[0] = '\0';
        LoadStringWrapW(g_hInst, IDS_MIC_TRAINING, sz, ARRAYSIZE(sz));
        LangBarInsertGrayedMenu(pMenu, sz);

        sz[0] = '\0';
        LoadStringWrapW(g_hInst, IDS_MIC_ADDDELETE, sz, ARRAYSIZE(sz));
        LangBarInsertGrayedMenu(pMenu, sz);

        // [Save Data] menu...
        sz[0] = '\0';
        LoadStringWrapW(g_hInst, IDS_MIC_SAVEDATA, sz, ARRAYSIZE(sz));
        LangBarInsertGrayedMenu(pMenu, sz);
        

        LoadStringWrapW(g_hInst, IDS_MIC_CURRENTUSER, sz, ARRAYSIZE(sz));
        LangBarInsertGrayedMenu(pMenu, sz);
    }
    else if (uCode == IDSLB_ONMENUSELECT)
    {
        if (wID == IDM_MIC_OPTIONS)
        {
            TCHAR szCplPath[MAX_PATH];
            TCHAR szCmdLine[MAX_PATH * 2];

            GetSapiCplPath(szCplPath, ARRAYSIZE(szCplPath));
            StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""), szCplPath);

            // start speech control panel applet
            RunCPLSetting(szCmdLine);
        }
    }
    return hr;
}

const TCHAR c_szcplsKey[]    = TEXT("software\\microsoft\\windows\\currentversion\\control panel\\cpls");
void CLBarItemCfgMenuButton::GetSapiCplPath(TCHAR *szCplPath, int cch)
{
    CMyRegKey regkey;

    if (cch <= 0)
        return;

    szCplPath[0] = '\0';

    if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szcplsKey, KEY_READ))
    {
        LONG lret = regkey.QueryValueCch(szCplPath, TEXT("SapiCpl"), cch);

        if (lret != ERROR_SUCCESS)
           lret = regkey.QueryValueCch(szCplPath, TEXT("Speech"), cch);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  LBarTestItem
//
//////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarTestItem::CLBarTestItem()
{
    Dbg_MemSetThisName(TEXT("CLBarTestItem"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM2,  
                GUID_LBI_TESTITEM,
                TF_LBI_STYLE_BTN_BUTTON, 
                CICPADBTN_ORDER + 1, 
                L"Cicero Pad");


    SetToolTip(L"Test");
    SetText(L"Test");
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarTestItem::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TEST));
    return S_OK;
}

#endif DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\asynccal.cpp ===
//
// asynccal.cpp
//

#include "private.h"
#include "asynccal.h"



//////////////////////////////////////////////////////////////////////////////
//
// CAsyncCall
//
// Some TIP shows the modal dialog box or message box in OnClieck() or
// OnMenuSelected() method. Then tipbar thread got in a dead lock
// status until it returns. To avoid this problem, we crate another thread
// to call OnClick() or OnMenuSelected() method so langBar UI does not
// have to wait for the return.
//
//////////////////////////////////////////////////////////////////////////////

ULONG CAsyncCall::_AddRef( )
{
    return InterlockedIncrement(&_ref);
}

ULONG CAsyncCall::_Release( )
{
    ULONG cr = InterlockedDecrement(&_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// StartThread
//
//----------------------------------------------------------------------------

HRESULT CAsyncCall::StartThread()
{
    HANDLE hThread;
    DWORD dwRet;
    HRESULT hr = S_OK;

    _hr = S_OK;

    _AddRef();

    _fThreadStarted = FALSE;
    hThread = CreateThread(NULL, 0, s_ThreadProc, this, 0, &_dwThreadId);

    if (hThread)
    {
        //
        // we need to wait at least ThreadProc() is started.
        // Is it takes more than 30s, it terminate the thread.
        //
        DWORD dwCnt = 60;
        while (!_fThreadStarted && dwCnt--)
        {
            dwRet = WaitForSingleObject(hThread, 500);
        }

        if (!_fThreadStarted)
        {
            TerminateThread(hThread, 0);
        }
       
        CloseHandle(hThread);
    }

    hr = _hr;

    _Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// ThreadProc
//
//----------------------------------------------------------------------------

DWORD CAsyncCall::s_ThreadProc(void *pv)
{
    CAsyncCall *_this = (CAsyncCall *)pv;
    return _this->ThreadProc();
}

DWORD CAsyncCall::ThreadProc()
{
    HRESULT hr = E_FAIL;
    _AddRef();
    _fThreadStarted = TRUE;

    switch(_action)
    {
        case DOA_ONCLICK:
            if (_plbiButton)
            {
                hr = _plbiButton->OnClick(_click, _pt, &_rc);
            }
            else if (_plbiBitmapButton)
            {
                hr = _plbiBitmapButton->OnClick(_click, _pt, &_rc);
            }
            else if (_plbiBitmap)
            {
                hr = _plbiBitmap->OnClick(_click, _pt, &_rc);
            }
            else if (_plbiBalloon)
            {
                hr = _plbiBalloon->OnClick(_click, _pt, &_rc);
            }
            break;

        case DOA_ONMENUSELECT:
            if (_plbiButton)
            {
                hr = _plbiButton->OnMenuSelect(_uId);
            }
            else if (_plbiBitmapButton)
            {
                hr = _plbiBitmapButton->OnMenuSelect(_uId);
            }
            break;
    }

    _hr = hr;

    _Release();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\asynccal.h ===
//
// asynccal.h
//

#ifndef AYNCCAL_H
#define AYNCCAL_H

#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncCall
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncCall
{
public:
    CAsyncCall(ITfLangBarItemButton *plb)
    {
        plb->AddRef();
        _plbiButton       = plb;
        _plbiBitmapButton = NULL;
        _plbiBitmap       = NULL;
        _plbiBalloon      = NULL;
        _ref = 1;
    }

    CAsyncCall(ITfLangBarItemBitmapButton *plb)
    {
        plb->AddRef();
        _plbiButton       = NULL;
        _plbiBitmapButton = plb;
        _plbiBitmap       = NULL;
        _plbiBalloon      = NULL;
        _ref = 1;
    }

    CAsyncCall(ITfLangBarItemBitmap *plb)
    {
        plb->AddRef();
        _plbiButton       = NULL;
        _plbiBitmapButton = NULL;
        _plbiBitmap       = plb;
        _plbiBalloon      = NULL;
        _ref = 1;
    }

    CAsyncCall(ITfLangBarItemBalloon *plb)
    {
        plb->AddRef();
        _plbiButton       = NULL;
        _plbiBitmapButton = NULL;
        _plbiBitmap       = NULL;
        _plbiBalloon      = plb;
        _ref = 1;
    }

    ~CAsyncCall()
    {
        SafeRelease(_plbiButton);
        SafeRelease(_plbiBitmapButton);
        SafeRelease(_plbiBitmap);
        SafeRelease(_plbiBalloon);
        _ref = 1;
    }

    HRESULT OnClick(TfLBIClick click, POINT pt, const RECT *prc)
    {
        _action = DOA_ONCLICK;
        _click = click;
        _pt = pt;
        _rc = *prc;
        return StartThread();
    }

    HRESULT OnMenuSelect(ULONG uId)
    {
        _action = DOA_ONMENUSELECT;
        _uId = uId;
        return StartThread();
    }

    ULONG _AddRef( );
    ULONG _Release( );

private:
    DWORD _dwThreadId;
    HRESULT StartThread();
    static DWORD s_ThreadProc(void *pv);
    DWORD ThreadProc();

    ITfLangBarItemButton       *_plbiButton;
    ITfLangBarItemBitmapButton *_plbiBitmapButton;
    ITfLangBarItemBitmap       *_plbiBitmap;
    ITfLangBarItemBalloon      *_plbiBalloon;

    typedef enum {
        DOA_ONCLICK        = 0,
        DOA_ONMENUSELECT   = 1,
    } DOA_ACTION;

    DOA_ACTION _action;
    ULONG      _uId;
    TfLBIClick _click;
    POINT      _pt;
    RECT       _rc;


    HRESULT _hr;
    BOOL _fThreadStarted;
    LONG _ref;
};


#endif AYNCCAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\catenum.cpp ===
//
//  catenum.cpp
//
#include "private.h"
#include "helpers.h"
#include "catenum.h"
#include "catutil.h"
#include "globals.h"

// we're single threaded, so use static tls
LIBTHREAD g_libTLS = { 0 };

// share our tls with ctfmon.exe
extern "C" LIBTHREAD *WINAPI GetLibTls(void)
{
    return &g_libTLS;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCatCache
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumCatCache::~CEnumCatCache()
{
    int nCnt = _rgMap.Count();
    int i;
    for (i = 0; i < nCnt; i++)
    {
        GUIDENUMMAP *pmap = _rgMap.GetPtr(i);
        SafeRelease(pmap->pEnumItems);
    }
    _rgMap.Clear();
}


//----------------------------------------------------------------------------
//
// GetEnumItemsInCategory
//
//----------------------------------------------------------------------------

IEnumGUID *CEnumCatCache::GetEnumItemsInCategory(REFGUID rguid)
{
    IEnumGUID *pEnum = NULL;
    int nCnt = _rgMap.Count();
    int i;
    TfGuidAtom guidatom;

    if (!GetGUIDATOMFromGUID(&g_libTLS, rguid, &guidatom))
    {
        return NULL;
    }

    for (i = 0; i < nCnt; i++)
    {
        GUIDENUMMAP *pmap = _rgMap.GetPtr(i);
        if (pmap->guidatom == guidatom)
        {
            pmap->pEnumItems->Reset();
            return pmap->pEnumItems;
        }
    }

    if (SUCCEEDED(LibEnumItemsInCategory(&g_libTLS, rguid, &pEnum)))
    {
        GUIDENUMMAP *pmap = _rgMap.Append(1);
        if (!pmap)
            return NULL;

        pmap->guidatom = guidatom;
        pmap->pEnumItems = pEnum;
        return pEnum;
    }

    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CGuidDwordCache
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CGuidDwordCache::~CGuidDwordCache()
{
    _rgMap.Clear();
}


//----------------------------------------------------------------------------
//
// GetGuidDWORD
//
//----------------------------------------------------------------------------

DWORD CGuidDwordCache::GetGuidDWORD(REFGUID rguid)
{
    int nCnt = _rgMap.Count();
    int i;
    TfGuidAtom guidatom;
    DWORD dw;

    if (!GetGUIDATOMFromGUID(&g_libTLS, rguid, &guidatom))
    {
        return 0;
    }

    for (i = 0; i < nCnt; i++)
    {
        GUIDDWMAP *pmap = _rgMap.GetPtr(i);
        if (pmap->guidatom == guidatom)
        {
            return pmap->dw;
        }
    }

    if (SUCCEEDED(GetGUIDDWORD(&g_libTLS, rguid, &dw)))
    {
        GUIDDWMAP *pmap = _rgMap.Append(1);
        if (!pmap)
            return 0;

        pmap->guidatom = guidatom;
        pmap->dw = dw;
        return dw;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\bandobjs.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
   THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          BandObjs.cpp
   
   Description:   Contains DLLMain and standard OLE COM object creation stuff.

**************************************************************************/

/**************************************************************************
   include statements
**************************************************************************/


#include "private.h"
#include <ole2.h>
#include <comcat.h>
#include <olectl.h>
#include "ClsFact.h"
#include "regsvr.h"
#include "lbmenu.h"
#include "inatlib.h"
#include "immxutil.h"
#include "cuilib.h"
#include "utbtray.h"
#include "mui.h"
#include "cregkey.h"
#include "ciccs.h"


/**************************************************************************
   GUID stuff
**************************************************************************/

//this part is only done once
//if you need to use the GUID in another file, just include Guid.h
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "Guid.h"
#pragma data_seg()

/**************************************************************************
   private function prototypes
**************************************************************************/

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
BOOL RegisterComCat(CLSID, CATID, BOOL);
BOOL IsDeskBandFromReg();

/**************************************************************************
   global variables
**************************************************************************/
extern HINSTANCE g_hOle32;
HINSTANCE   g_hInst;
UINT        g_DllRefCount;
CCicCriticalSectionStatic g_cs;
#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif
UINT  g_wmTaskbarCreated;

DECLARE_OSVER()

/**************************************************************************

   ProcessAttach

**************************************************************************/

BOOL ProcessAttach(HINSTANCE hInstance)
{
    if (!g_cs.Init())
       return FALSE;

    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("MSUIMUI"), NULL);
    g_hInst = hInstance;
    InitOSVer();
    TFInitLib_PrivateForCiceroOnly(Internal_CoCreateInstance);
    InitUIFLib();
    TF_InitMlngInfo();

    CTrayIconWnd::RegisterClass();

    MuiLoadResource(hInstance, TEXT("msutb.dll"));

    g_wmTaskbarCreated = RegisterWindowMessage(TEXT("TaskbarCreated"));

    return TRUE;
}

/**************************************************************************

   ProcessDettach

**************************************************************************/

void ProcessDettach(HINSTANCE hInstance)
{
    DoneUIFLib();
    TFUninitLib();
    Dbg_MemUninit();
    g_cs.Delete();
    // Issue: MuiFreeResource is unsafe because it can call FreeLibrary
    // we may not need to bother because we are only loaded in the ctfmon.exe process
    // and are never unloaded until the process is shutdown
    //MuiFreeResource(hInstance);
    MuiClearResource();
}

/**************************************************************************

   DllMain

**************************************************************************/

extern "C" BOOL WINAPI DllMain(  HINSTANCE hInstance, 
                                 DWORD dwReason, 
                                 LPVOID lpReserved)
{
    BOOL bRet = TRUE;
#ifdef DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
               ProcessDettach(hInstance);
               bRet = FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;
    }
   
#ifdef DEBUG
    g_dwThreadDllMain = 0;
#endif
    return bRet;
}                                 

/**************************************************************************

   DllCanUnloadNow

**************************************************************************/

STDAPI DllCanUnloadNow(void)
{
    return (g_DllRefCount ? S_FALSE : S_OK);
}

/**************************************************************************

   DllGetClassObject

**************************************************************************/

STDAPI DllGetClassObject(  REFCLSID rclsid, 
                           REFIID riid, 
                           LPVOID *ppReturn)
{
    *ppReturn = NULL;

    //if we don't support this classid, return the proper error code
    if(   !IsEqualCLSID(rclsid, CLSID_MSUTBDeskBand))
       return CLASS_E_CLASSNOTAVAILABLE;
   
    //create a CClassFactory object and check it for validity
    CClassFactory *pClassFactory = new CClassFactory(rclsid);
    if(NULL == pClassFactory)
       return E_OUTOFMEMORY;
   
    //get the QueryInterface return for our return value
    HRESULT hResult = pClassFactory->QueryInterface(riid, ppReturn);

    //call Release to decement the ref count - creating the object set it to one
    //and QueryInterface incremented it - since its being used externally 
    //(not by us), we only want the ref count to be 1
    pClassFactory->Release();

    //return the result from QueryInterface
    return hResult;
}

/**************************************************************************

   DllRegisterServer 

**************************************************************************/

STDAPI DllRegisterServer(void)
{
    TCHAR achPath[MAX_PATH+1];
    HRESULT hr = E_FAIL;

    if (IsOnNT51())
    {
        if (GetModuleFileName(g_hInst, achPath, ARRAYSIZE(achPath)) == 0)
            goto Exit;

        if (!RegisterServerW(CLSID_MSUTBDeskBand, 
                             CRStr(IDS_LANGBAND), 
                             AtoW(achPath), 
                             L"Apartment", 
                             NULL,
                             CRStr(IDS_LANGBANDMENUTEXTPUI)))
            goto Exit;
    }

    hr = S_OK;
Exit:
    return hr;
}

/**************************************************************************

   DllUnregisterServer 

**************************************************************************/

STDAPI DllUnregisterServer(void)
{
    if (IsOnNT51())
    {
        //Register the desk band object.
        if (!RegisterServer(CLSID_MSUTBDeskBand, NULL, NULL, NULL, NULL))
            return SELFREG_E_CLASS;
    }

    return S_OK;
}

/**************************************************************************

   RegisterComCat

**************************************************************************/

const TCHAR c_szCatEnum[] = "Component Categories\\{00021492-0000-0000-C000-000000000046}\\Enum";
const TCHAR c_szIESubKey[] = "Software\\Microsoft\\Internet Explorer";

BOOL IsIE5()
{
    CMyRegKey key;
    BOOL bRet = FALSE;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szIESubKey, KEY_READ) == S_OK)
    {
        char szValue[16];
        if (key.QueryValueCch(szValue, "Version", ARRAYSIZE(szValue)) == S_OK)
        {
            if (!strncmp("5.00", szValue, 4))
                bRet = TRUE;
        }
    }
    return bRet;
}

BOOL RegisterComCat(CLSID clsid, CATID CatID, BOOL fSet)
{
    ICatRegister   *pcr;
    HRESULT        hr = S_OK ;
    
    hr = CoInitialize(NULL);
    if (FAILED(hr))
        return FALSE;


    hr = CoCreateInstance(  CLSID_StdComponentCategoriesMgr, 
                            NULL, 
                            CLSCTX_INPROC_SERVER, 
                            IID_ICatRegister, 
                            (LPVOID*)&pcr);

    if(SUCCEEDED(hr))
    {
        if (fSet)
            hr = pcr->RegisterClassImplCategories(clsid, 1, &CatID);
        else
            hr = pcr->UnRegisterClassImplCategories(clsid, 1, &CatID);

        pcr->Release();
    }
        
    CoUninitialize();

    //
    // IE5.0 shipped with a bug in the component category cache code, 
    // such that the cache is never refreshed (so we don't pick up newly 
    // registered toolbars).  The bug is fixed in versions 5.01 and greater.
    //
    // We need to delete the following reg key as part of your setup:
    //
    // HKCR\Component Categories\{00021492-0000-0000-C000-000000000046}\Enum
    //
    if (IsIE5())
    {
        RegDeleteKey(HKEY_CLASSES_ROOT, c_szCatEnum);
    }

    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
// IsDeskbandFromReg
//
//+---------------------------------------------------------------------------

BOOL IsDeskBandFromReg()
{
    CMyRegKey keyUTB;
    DWORD dwValue;
    BOOL bRet = FALSE;

    if (keyUTB.Open(HKEY_CURRENT_USER, c_szUTBKey, KEY_READ) == S_OK)
    {
        if (IsOnNT51() && keyUTB.QueryValue(dwValue, c_szShowDeskBand) == S_OK)
            bRet = dwValue ? TRUE : FALSE;

    }

    return bRet;
}


//+---------------------------------------------------------------------------
//
// SetDeskbandFromReg
//
//+---------------------------------------------------------------------------

void SetDeskBandToReg(BOOL fShow)
{
    CMyRegKey keyUTB;

    if (keyUTB.Open(HKEY_CURRENT_USER, c_szUTBKey, KEY_ALL_ACCESS) == S_OK)
    {
        keyUTB.SetValue((DWORD)fShow ? 1 : 0, c_szShowDeskBand);
    }
}


//+---------------------------------------------------------------------------
//
// SetRegisterLangBand
//
//+---------------------------------------------------------------------------

STDAPI SetRegisterLangBand(BOOL bSetReg)
{
    BOOL fShowDeskBand = IsDeskBandFromReg();


    if (!IsOnNT51())
        return E_FAIL;

    if (fShowDeskBand == bSetReg)
        return S_OK;

    SetDeskBandToReg(bSetReg);

    if (bSetReg)
    {
        //
        // we don't care if this deskband is registered or not.
        // Win95 without IE4 shell does not support deskband.
        //
        if (!RegisterComCat(CLSID_MSUTBDeskBand, CATID_DeskBand, TRUE))
            return SELFREG_E_CLASS;
    }
    else
    {
        //Register the component categories for the desk band object.
        if (!RegisterComCat(CLSID_MSUTBDeskBand, CATID_DeskBand, FALSE))
            return SELFREG_E_CLASS;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\catenum.h ===
//
// catenum.h
//


#ifndef CATENUM_H
#define CATENUM_H


#include "strary.h"


//////////////////////////////////////////////////////////////////////////////
//
// CEnumCatCache
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCatCache
{
public:
    CEnumCatCache() {}
    ~CEnumCatCache();

    IEnumGUID *GetEnumItemsInCategory(REFGUID rguid);

    typedef struct {
        TfGuidAtom guidatom;
        IEnumGUID *pEnumItems;
    } GUIDENUMMAP;
    

private:
    CStructArray<GUIDENUMMAP> _rgMap;

};

//////////////////////////////////////////////////////////////////////////////
//
// CGuidDwordCache
//
//////////////////////////////////////////////////////////////////////////////

class CGuidDwordCache
{
public:
    CGuidDwordCache() {}
    ~CGuidDwordCache();

    DWORD GetGuidDWORD(REFGUID rguid);

    typedef struct {
        TfGuidAtom guidatom;
        DWORD      dw;
    } GUIDDWMAP;
    

private:
    CStructArray<GUIDDWMAP> _rgMap;

};
#endif CATENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\balloon.cpp ===
//
// balloon.cpp
//

#include "private.h"
#include "globals.h"
#include "tipbar.h"
#include "helpers.h"
#include "xstring.h"
#include "immxutil.h"
#include "balloon.h"
#include "fontlink.h"
#include "asynccal.h"

extern CTipbarWnd *g_pTipbarWnd;

#define SHOWTOOLTIP_ONUPDATE
__inline void PrectSet(RECT *prc, int left, int top, int right, int bottom)
{
    prc->left = left;
    prc->top = top;
    prc->right = right;
    prc->bottom = bottom;
}
//////////////////////////////////////////////////////////////////////////////
//
// CTipbarBalloonItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTipbarBalloonItem::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItemSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemSink *);
    }
    else if (IsEqualIID(riid, IID_PRIV_BALLOONITEM))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTipbarBalloonItem::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTipbarBalloonItem::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarBalloonItem::CTipbarBalloonItem(CTipbarThread *ptt, 
                                      ITfLangBarItem *plbi,
                                      ITfLangBarItemBalloon *plbiBalloon, 
                                      DWORD dwId, 
                                      RECT *prc, 
                                      DWORD dwStyle, 
                                      TF_LANGBARITEMINFO *plbiInfo,
                                      DWORD dwStatus)
                    : CUIFObject(ptt->_ptw, 
                                 dwId, 
                                 prc, 
                                 dwStyle) , 
                     CTipbarItem(ptt, plbi, plbiInfo, dwStatus)
{
    Dbg_MemSetThisName(TEXT("CTipbarBalloonItem"));

    _plbiBalloon = plbiBalloon;
    _plbiBalloon->AddRef();

    if (_dwStatus & TF_LBI_STATUS_DISABLED)
        Enable(FALSE);

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarBalloonItem::~CTipbarBalloonItem()
{
    if (_bstrText)
        SysFreeString(_bstrText);
    SafeRelease(_plbiBalloon);
}

//+---------------------------------------------------------------------------
//
// Update
//
//----------------------------------------------------------------------------

HRESULT CTipbarBalloonItem::OnUpdateHandler(DWORD dwFlags, DWORD dwStatus)
{
    if (!IsConnected())
        return S_OK;

    HRESULT hr = S_OK;
    BOOL fCallPaint = FALSE;

    //
    // add ref count to be safe for releasing during marshaling.
    //
    AddRef();

    if (dwFlags & TF_LBI_BALLOON)
    {
        TF_LBBALLOONINFO info;

        if (_bstrText)
        {
            SysFreeString(_bstrText);
            _bstrText = NULL;
        }

        if (SUCCEEDED(_plbiBalloon->GetBalloonInfo(&info)))
        {
            _bstrText = info.bstrText;
            _style = info.style;
        }

        if (!IsHiddenStatusControl() && IsVisibleInToolbar())
            StartDemotingTimer(FALSE);

        EndTimer();
        DestroyBalloonTip();
#ifdef SHOWTOOLTIP_ONUPDATE
        if (IsTextEllipsis(_bstrText, &GetRectRef()))
        {
            StartTimer(2000);
        }
#endif

        fCallPaint = TRUE;
    }

    CTipbarItem::OnUpdateHandler(dwFlags, dwStatus);

    if ((_dwStatus & TF_LBI_STATUS_DISABLED) ||
        (_dwStatus & TF_LBI_STATUS_HIDDEN))
    {
        DestroyBalloonTip();
    }

    if (fCallPaint)
        CallOnPaint();

    Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnTimer
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::OnTimer()
{
    if (!_pblnTip)
    {
        EndTimer();
        StartTimer(20000);
        ShowBalloonTip();
    }
    else
    {
        EndTimer();
        DestroyBalloonTip();
    }
}

//----------------------------------------------------------------------------
//
// OnPosChanged
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::OnPosChanged()
{
    EndTimer();
    DestroyBalloonTip();
}

//+---------------------------------------------------------------------------
//
// ShowBalloonTip
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::ShowBalloonTip()
{
    RECT rc;
    POINT pt;

    DestroyBalloonTip();

    if (!_ptt)
        return;

    if (!_ptt->_ptw)
        return;

    if (!IsVisibleInToolbar() || !_ptt->IsFocusThread())
        return;

    _pblnTip = new CUIFBalloonWindow(g_hInst, 0);
    if (!_pblnTip)
        return;

    _pblnTip->Initialize();

    GetRect(&rc);
    pt.x = (rc.left + rc.right) / 2;
    pt.y = rc.top;
    MyClientToScreen(&pt, &rc);

    _pblnTip->SetTargetPos(pt);
    _pblnTip->SetExcludeRect(&rc);

    _pblnTip->SetText(_bstrText);
    _pblnTip->CreateWnd(_ptt->_ptw->GetWnd());

}

//+---------------------------------------------------------------------------
//
// DestroyBalloonTip
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::DestroyBalloonTip()
{
    if (_pblnTip)
    {
        if (IsWindow(_pblnTip->GetWnd()))
            DestroyWindow(_pblnTip->GetWnd());
        delete _pblnTip;
        _pblnTip = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// OnPaint
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::OnPaint( HDC hdc )
{
    switch (_style)
    {
        case TF_LB_BALLOON_RECO:
            DrawRecoBalloon(hdc, _bstrText, &GetRectRef());
            break;
        case TF_LB_BALLOON_SHOW:
            DrawShowBalloon(hdc, _bstrText, &GetRectRef());
            break;
        case TF_LB_BALLOON_MISS:
            DrawUnrecognizedBalloon(hdc, _bstrText, &GetRectRef());
            break;    
        default:
            Assert(0);
    }
}

//+---------------------------------------------------------------------------
//
// OnRightClick
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::OnRightClick()
{
    if (_plbiBalloon)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiBalloon);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_RIGHT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }
    }
}

//+---------------------------------------------------------------------------
//
// OnLeftClick
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::OnLeftClick()
{
    if (_plbiBalloon)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiBalloon);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_LEFT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }

        if (!IsHiddenStatusControl() && IsVisibleInToolbar())
            StartDemotingTimer(TRUE);
    }
}

//+---------------------------------------------------------------------------
//
// SetRect
//
//----------------------------------------------------------------------------

void CTipbarBalloonItem::SetRect( const RECT *prc ) 
{
    CUIFObject::SetRect(prc);
}


/*---------------------------------------------------------------------------
    DrawTransparentText

    Draws the text string wtz in the font ft with text color crText.
------------------------------------------------------------------- TCOON -*/
void CTipbarBalloonItem::DrawTransparentText(HDC hdc, COLORREF crText, WCHAR *psz, const RECT *prc)
{
    HFONT hFontOld;
    SIZE size;
    int cch;
    RECT rc;
	WORD rgfJustify = DT_END_ELLIPSIS | DT_WORDBREAK | DT_EDITCONTROL | DT_CENTER | DT_VCENTER;	

    if (!psz || !_ptt || !_ptt->_ptw)
        return;

    cch = wcslen(psz);

    // prepare objects
    hFontOld= (HFONT)SelectObject(hdc, GetFont() );

    // calc alignment
    FLGetTextExtentPoint32( hdc, psz, cch, &size );

    COLORREF crSave = SetTextColor(hdc, crText);
    SetBkMode(hdc, TRANSPARENT);

    if (!_ptt->IsVertical())
    {
        int yAlign = (prc->bottom - prc->top - size.cy) / 2;
        rc = *prc;
        rc.left += 1;
        rc.right -= 1;
        rc.top += yAlign;
	    FLDrawTextW(hdc, psz, cch, &rc, rgfJustify);
    }
    else
    {
        int xAlign = (prc->right - prc->left - size.cy) / 2;
        rc = *prc;
        rc.top += 1;
        rc.bottom -= 1;
        rc.right -= xAlign;
	    FLDrawTextWVert(hdc, psz, cch, &rc, rgfJustify);
    }

    SetTextColor(hdc, crSave);    
    SelectObject(hdc, hFontOld);
}

/*---------------------------------------------------------------------------
    DrawRect

    Draws the text string wtz in the font ft with text color crText.
------------------------------------------------------------------- TCOON -*/
void CTipbarBalloonItem::DrawRect(HDC hdc, const RECT *prc, COLORREF crBorder, COLORREF crFill)
{
    HPEN hpen = NULL;
    HPEN hpenOld;
    HBRUSH hbr = NULL;
    HBRUSH hbrOld;

    hpen = CreatePen(PS_SOLID, 0, crBorder);
    if (!hpen)
        goto Exit;
    hbr = CreateSolidBrush(crFill);
    if (!hbr)
        goto Exit;
     
    hpenOld = (HPEN)SelectObject(hdc, hpen);
    hbrOld = (HBRUSH)SelectObject(hdc, hbr);

    Rectangle(hdc, prc->left, prc->top, prc->right, prc->bottom);

    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);

Exit:
    if (hpen)
        DeleteObject(hpen);
    if (hbr)
        DeleteObject(hbr);
}

/*---------------------------------------------------------------------------
    DrawUnrecognizedBalloon

    Draws the Unrecognized balloon to show the user that the command was
    misunderstood.
------------------------------------------------------------------- TCOON -*/
void CTipbarBalloonItem::DrawUnrecognizedBalloon(HDC hdc, WCHAR *wtz, const RECT *prc)
{
    RECT rc = *prc;
    COLORREF crBtnText;
    HPEN hpen = NULL;
    HPEN hpenOld;
    HBRUSH hbrOld;

    crBtnText = GetSysColor(COLOR_BTNTEXT);

    hpen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWFRAME));
    if (!hpen)
        goto Exit;

    hbrOld = (HBRUSH)SelectObject(hdc, GetSysColorBrush(COLOR_HIGHLIGHT));

    InflateRect(&rc, -2, -2);

    hpenOld = (HPEN)SelectObject(hdc, hpen);
    RoundRect(hdc, rc.left,rc.top, rc.right, rc.bottom, 12, 12);

    DrawTransparentText(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT), wtz, &rc);

    // Restore DC contents
    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);
Exit:
    if (hpen)
        DeleteObject(hpen);
}


/*---------------------------------------------------------------------------
    DrawShowBalloon

    Draws the Show balloon to suggest the user say a given command.
------------------------------------------------------------------- TCOON -*/
void CTipbarBalloonItem::DrawShowBalloon(HDC hdc, WCHAR *wtz, const RECT *prc)
{
    COLORREF crBtnFace;
    COLORREF crBtnShad;
    COLORREF crBalloonText;
    COLORREF crBalloon;
    RECT rc = *prc;

    crBtnFace = GetSysColor(COLOR_BTNFACE); 
    crBtnShad = GetSysColor(COLOR_BTNSHADOW); 
    // crBalloonText = GetSysColor(COLOR_INFOTEXT); 
    // crBalloon = GetSysColor(COLOR_INFOBK) & 0x0000ff00; 
    // crBalloon =  col(30, RGB(0, 0xFF, 0), 70, GetSysColor(COLOR_INFOBK));
    crBalloon = GetSysColor(COLOR_BTNFACE); 
    crBalloonText = GetSysColor(COLOR_BTNTEXT); 

    // Draw Black outline
    InflateRect(&rc, -2, -2);
    // rc.bottom -= 5;
    DrawRect(hdc, &rc, GetSysColor(COLOR_WINDOWFRAME), crBalloon);    
    InflateRect(&rc, -1, -1);

    // Knock off the corner
    RECT rcDraw;

    int bkSav = SetBkColor(hdc, crBalloon);
    
    for (int iPixel = 0; iPixel < 7; iPixel++)
    {
        PrectSet(&rcDraw, rc.right-(7-iPixel), rc.bottom-iPixel-1,
                        rc.right-(7-iPixel)+1, rc.bottom-iPixel);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    }

    PrectSet(&rcDraw, rc.right-3, rc.bottom-2, rc.right-2, rc.bottom);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    PrectSet(&rcDraw, rc.right-2, rc.bottom-3, rc.right, rc.bottom-2);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // Shadows
    SetBkColor(hdc, crBtnShad);
    // Lower Shadow
    PrectSet(&rcDraw, rc.left+2, rc.bottom+1, rc.right+1, rc.bottom+2);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    
    for (iPixel = 0; iPixel < 8; iPixel++)
    {
        PrectSet(&rcDraw, rc.right-(7-iPixel), rc.bottom-iPixel,
                        rc.right-(7-iPixel)+1, rc.bottom-iPixel+2);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    }

    // Button Face portions
    SetBkColor(hdc, crBtnFace);
    for (iPixel = 0; iPixel < 3; iPixel++)
    {
        PrectSet(&rcDraw, rc.right-6+iPixel, rc.bottom+1-iPixel,
                        rc.right-3, rc.bottom-iPixel+2);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    }

    for (iPixel = 0; iPixel < 2; iPixel++)
    {
        PrectSet(&rcDraw, rc.right+iPixel-1, rc.bottom-4-iPixel,
                    rc.right+iPixel, rc.bottom+iPixel-3);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    }

    PrectSet(&rcDraw, rc.right-3, rc.bottom, rc.right-2, rc.bottom+2);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // Clean up and draw text
    SetBkColor(hdc, bkSav);    

    DrawTransparentText(hdc, crBalloonText, wtz, &rc);
}        
    

/*---------------------------------------------------------------------------
    DrawRecoBalloon

    Draws the Recognition Balloon.
------------------------------------------------------------------- TCOON -*/
void CTipbarBalloonItem::DrawRecoBalloon(HDC hdc, WCHAR *wtz, const RECT *prc)
{
    COLORREF crBtnFace;
    COLORREF crBtnShad;
    COLORREF crBalloonText;
    COLORREF crBalloon;
    RECT rc = *prc;

    crBtnFace = GetSysColor(COLOR_BTNFACE); 
    crBtnShad = GetSysColor(COLOR_BTNSHADOW); 
    crBalloonText = GetSysColor(COLOR_INFOTEXT); 
    crBalloon     = GetSysColor(COLOR_INFOBK); 

    // Draw Black outline
    InflateRect(&rc, -2, -2);
    // rc.bottom -= 5;
    rc.bottom -= 1;
    DrawRect(hdc, &rc, GetSysColor(COLOR_WINDOWFRAME), crBalloon);    
    InflateRect(&rc, -1, -1);

    // Knock off the corners
    int bkSav = SetBkColor(hdc, crBtnFace);

    InflateRect(&rc, +1, +1);
    RECT rcDraw;
    
    // UpperLeft
    PrectSet(&rcDraw, rc.left, rc.top, rc.left+1, rc.top+1);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // UpperRight
    PrectSet(&rcDraw, rc.right-1, rc.top, rc.right, rc.top+1);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // LowerLeft
    PrectSet(&rcDraw, rc.left, rc.bottom-1, rc.left+1, rc.bottom);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    SetBkColor(hdc, crBtnShad);
    // LowerRight (done in shadow color)
    PrectSet(&rcDraw, rc.right-1, rc.bottom-1, rc.right, rc.bottom);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // Lower Shadow
    PrectSet(&rcDraw, rc.left+2, rc.bottom, rc.right-1, rc.bottom+1);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // RightSide Shadow
    PrectSet(&rcDraw, rc.right, rc.top+2, rc.right+1, rc.bottom-1);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // Arrow Shadow
    PrectSet(&rcDraw, rc.right-4, rc.bottom+1, rc.right-3, rc.bottom+5);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    // Arrow 
    SetBkColor(hdc, crBalloonText);
    PrectSet(&rcDraw, rc.right-5, rc.bottom, rc.right-4, rc.bottom+4);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);

    int iPixel;
    
    for (iPixel = 0; iPixel < 3; iPixel++)
    {
        PrectSet(&rcDraw, rc.right-(6+iPixel), rc.bottom+(2-iPixel),
                                rc.right-(5+iPixel), rc.bottom+(3-iPixel));
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    }

    // Fill in Arrow
    SetBkColor(hdc, crBalloon);
    for (iPixel = 0; iPixel < 3; iPixel++)
    {
        PrectSet(&rcDraw, rc.right-(8-iPixel), rc.bottom-(1-iPixel),
                                rc.right-5, rc.bottom+iPixel);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcDraw, NULL, 0, 0);
    }
    SetBkColor(hdc, bkSav);    

    DrawTransparentText(hdc, crBalloonText, wtz, &rc);
}

/*---------------------------------------------------------------------------
    IsTextEllipsis

    Draws the text string wtz in the font ft with text color crText.
------------------------------------------------------------------- TCOON -*/
BOOL CTipbarBalloonItem::IsTextEllipsis(WCHAR *psz, const RECT *prc)
{
    HDC hdc;
    HFONT hFontOld;
    SIZE size;
    int cch;
    RECT rc;
    BOOL bRet = FALSE;

    // detect if the item is hidden and return immediately here
    if (IsInHiddenStatus())
        return bRet;

    if (g_pTipbarWnd && g_pTipbarWnd->IsSFHidden( ))
        return bRet;

    if (!psz)
        return bRet;

    hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
    if (!hdc)
        return bRet;

    cch = wcslen(psz);

    // prepare objects
    hFontOld= (HFONT)SelectObject(hdc, GetFont() );

    // calc alignment
    FLGetTextExtentPoint32( hdc, psz, cch, &size );

    rc = *prc;
    rc.left += 3;
    rc.right -= 3;

    SelectObject(hdc, hFontOld);
    DeleteDC(hdc);

    return (size.cx > (rc.right - rc.left)) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\balloon.h ===
//////////////////////////////////////////////////////////////////////////////
//
// CTipbarBalloonItem
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarBalloonItem: public CTipbarItem,
                          public CUIFObject,
                          public ITfLangBarItemSink
{
public:
    CTipbarBalloonItem(CTipbarThread *ptt, 
                       ITfLangBarItem *plbi, 
                       ITfLangBarItemBalloon *plbiBalloon, 
                       DWORD dwId, 
                       RECT *prc, 
                       DWORD dwStyle, 
                       TF_LANGBARITEMINFO *plbiInfo, 
                       DWORD dwStatus);

    ~CTipbarBalloonItem();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangbarItemSink methods
    //
    STDMETHODIMP OnUpdate(DWORD dwFlags)
    {
        return CTipbarItem::OnUpdate(dwFlags);
    }

    BOOL Init()
    {
        CUIFObject::Initialize();
        return TRUE;
    }
    void DetachWnd() {DetachWndObj();}
    void ClearWnd() {ClearWndObj();}
    void Enable(BOOL fEnable)
    {
        CUIFObject::Enable(fEnable);
    }

    void SetToolTip(LPCWSTR pwszToolTip)
    {
        CUIFObject::SetToolTip(pwszToolTip);
    }

    LPCWSTR GetToolTipFromUIOBJ()
    {
        return CUIFObject::GetToolTip();
    }

    LPCWSTR GetToolTip()
    {
#ifdef SHOWTOOLTIP_ONUPDATE
        return CTipbarItem::GetToolTip();
#else
        if (_bstrText && wcslen(_bstrText))
            return _bstrText;
        else
            return NULL;
#endif
    }

    void GetScreenRect(RECT *prc)
    {
        GetRect(prc);
        MyClientToScreen(prc);
    }

    void SetFont(HFONT hfont)
    {
        CUIFObject::SetFont(hfont);
    }

    void SetRect( const RECT *prc );
    BOOL OnSetCursor(UINT uMsg, POINT pt) {return CTipbarItem::OnSetCursor(uMsg, pt);}
    void OnPosChanged();
    void OnPaint( HDC hdc );
    void OnRightClick();
    void OnLeftClick();
    HRESULT OnUpdateHandler(DWORD dwFlags, DWORD dwStatus);

    void AddMeToUI(CUIFObject *pobj) 
    {
        if (!pobj)
            return;

        pobj->AddUIObj(this);
        _AddedToUI();
    }
    void RemoveMeToUI(CUIFObject *pobj)  
    {
        DestroyBalloonTip();

        if (!pobj)
            return;

        pobj->RemoveUIObj(this);
        _RemovedToUI();
    }

    void DrawTransparentText(HDC hdc, COLORREF crText, WCHAR *wtz, const RECT *prc);
    void DrawRect(HDC hdc, const RECT *prc, COLORREF crBorder, COLORREF crFill);
    void DrawUnrecognizedBalloon(HDC hdc, WCHAR *wtz, const RECT *prc);
    void DrawShowBalloon(HDC hdc, WCHAR *wtz, const RECT *prc);
    void DrawRecoBalloon(HDC hdc, WCHAR *wtz, const RECT *prc);

    void DestroyBalloonTip();

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID, int iStateID )
    {
        CUIFObject::SetActiveTheme(pszClassList, iPartID, iStateID);
    }

private:

    BOOL IsTextEllipsis(WCHAR *psz, const RECT *prc);
    void OnTimer();
    void ShowBalloonTip();

    BOOL OnShowToolTip()
    {
#ifdef SHOWTOOLTIP_ONUPDATE
        if (_bstrText && wcslen(_bstrText))
        {
            ShowBalloonTip();
            return TRUE;
        }
#endif
        return FALSE;
    }

    void OnHideToolTip()
    {
        DestroyBalloonTip();
    }

    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 )
    {
        int sum = r1 + r2;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + sum/2) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + sum/2) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + sum/2) / sum;
        return RGB( r, g, b );
    }

    ITfLangBarItemBalloon *_plbiBalloon;
    BSTR _bstrText;
    TfLBBalloonStyle _style;

    CUIFBalloonWindow *_pblnTip;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\clsfact.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ClsFact.h
   
   Description:   CClassFactory definitions.

**************************************************************************/

#ifndef _CLASSFACTORY_H_
#define _CLASSFACTORY_H_

#include <windows.h>
#include "Globals.h"
#include "DeskBand.h"

/**************************************************************************

   CClassFactory class definition

**************************************************************************/

class CClassFactory : public IClassFactory
{
protected:
   DWORD m_ObjRefCount;

public:
   CClassFactory(CLSID);
   ~CClassFactory();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IClassFactory methods
   STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
   STDMETHODIMP LockServer(BOOL);

private:
   CLSID m_clsidObject;
};

#endif   // _CLASSFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\clsfact.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
   THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ClsFact.cpp
   
   Description:   Implements CClassFactory.

**************************************************************************/

/**************************************************************************
   include statements
**************************************************************************/

#include "private.h"
#include "ClsFact.h"
#include "Guid.h"
#include <shlapip.h>

/**************************************************************************
   private function prototypes
**************************************************************************/

/**************************************************************************
   global variables
**************************************************************************/

///////////////////////////////////////////////////////////////////////////
//
// IClassFactory implementation
//

/**************************************************************************

   CClassFactory::CClassFactory

**************************************************************************/

CClassFactory::CClassFactory(CLSID clsid)
{
    Dbg_MemSetThisName(TEXT("CClassFactory"));

    m_clsidObject = clsid;
    m_ObjRefCount = 1;
    g_DllRefCount++;
}

/**************************************************************************

   CClassFactory::~CClassFactory

**************************************************************************/

CClassFactory::~CClassFactory()
{
    g_DllRefCount--;
}

/**************************************************************************

   CClassFactory::QueryInterface

**************************************************************************/

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
    *ppReturn = NULL;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppReturn = this;
    }
    else if(IsEqualIID(riid, IID_IClassFactory))
    {
        *ppReturn = (IClassFactory*)this;
    }   

    if(*ppReturn)
    {
        (*(LPUNKNOWN*)ppReturn)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}                                             

/**************************************************************************

   CClassFactory::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::AddRef()
{
    return ++m_ObjRefCount;
}


/**************************************************************************

   CClassFactory::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::Release()
{
    if (--m_ObjRefCount == 0)
    {
        delete this;
        return 0;
    }
   
    return m_ObjRefCount;
}

/**************************************************************************

   CClassFactory::CreateInstance

**************************************************************************/

const TCHAR c_szCicLoaderWndClass[] = TEXT("CicLoaderWndClass");

STDMETHODIMP CClassFactory::CreateInstance(  LPUNKNOWN pUnknown, 
                                             REFIID riid, 
                                             LPVOID *ppObject)
{
    //
    // Look up disabling Text Services status from the registry.
    // If it is disabled, return fail not to support language deskband.
    //
    if (IsDisabledTextServices())
    {
        return E_FAIL;
    }

    HRESULT  hResult = E_FAIL;
    LPVOID   pTemp = NULL;

    *ppObject = NULL;

    if(pUnknown != NULL)
       return CLASS_E_NOAGGREGATION;

    //create the proper object
    if (IsEqualCLSID(m_clsidObject, CLSID_MSUTBDeskBand))
    {
        CDeskBand *pDeskBand = new CDeskBand();
        if(NULL == pDeskBand)
           return E_OUTOFMEMORY;
    
        pTemp = pDeskBand;
    }
  
  
    if(pTemp)
    {
        //get the QueryInterface return for our return value
        hResult = ((LPUNKNOWN)pTemp)->QueryInterface(riid, ppObject);
 
        //call Release to decement the ref count
        ((LPUNKNOWN)pTemp)->Release();
    }

    return hResult;
}

/**************************************************************************

   CClassFactory::LockServer

**************************************************************************/

STDMETHODIMP CClassFactory::LockServer(BOOL)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\delay.h ===
//
// delay.h
//

#ifndef DELAY_H
#define DELAY_H

// shell32

BOOL WINAPI Internal_Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATA pnid);
#define Shell_NotifyIconA Internal_Shell_NotifyIconA

BOOL WINAPI Internal_Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW pnid);
#define Shell_NotifyIconW Internal_Shell_NotifyIconW

BOOL WINAPI Internal_Shell_SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pabd);
#define SHAppBarMessage Internal_Shell_SHAppBarMessage

// ole32

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
#define CoCreateInstance Internal_CoCreateInstance

HRESULT STDAPICALLTYPE Internal_CoInitialize(LPVOID pvReserved);
#define CoInitialize Internal_CoInitialize

HRESULT STDAPICALLTYPE Internal_CoUninitialize();
#define CoUninitialize Internal_CoUninitialize

void STDAPICALLTYPE Internal_CoTaskMemFree(void *pv);
#define CoTaskMemFree Internal_CoTaskMemFree

#endif // DELAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSUTB"
#define SZ_MODULE       "MSUTB"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\delay.cpp ===
//
// delay.cpp
//
// Delay load imported functions for perf.
//

#include "private.h"
#include "globals.h"
#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;

FARPROC GetFn(HINSTANCE *phInst, TCHAR *pchLib, TCHAR *pchFunc)
{
    if (*phInst == 0)
    {
        EnterCriticalSection(g_cs);

        // need to check again after entering crit sec
        if (*phInst == 0)
        {
            *phInst = LoadSystemLibrary(pchLib);
        }

        LeaveCriticalSection(g_cs);

        if (*phInst == 0)
        {
            Assert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal)   \
_RetType _CallConv _FuncName _Args1                                             \
{                                                                               \
    static FARPROC pfn = NULL;                                                  \
                                                                                \
    if (pfn == NULL || _hInst == NULL)                                          \
    {                                                                           \
        pfn = GetFn(&_hInst, #_DllName, #_FuncName);                            \
                                                                                \
        if (pfn == NULL)                                                        \
        {                                                                       \
            Assert(0);                                                          \
            return (_RetType) _ErrVal;                                          \
        }                                                                       \
    }                                                                           \
                                                                                \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                       \
}

//
// imm32.dll
//

HINSTANCE g_hImm32 = 0;

DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetDescriptionA, (HKL hKL, LPSTR psz, UINT uBufLen), (hKL, psz, uBufLen), UINT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetDescriptionW, (HKL hKL, LPWSTR psz, UINT uBufLen), (hKL, psz, uBufLen), UINT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetDefaultIMEWnd, (HWND hWnd), (hWnd), HWND, 0)

#ifdef UNUSED_IMM32_APIS

DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmReleaseContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmNotifyIME, (HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue), (hIMC, dwAction, dwIndex, dwValue), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetConversionStatus, (HIMC hIMC, DWORD dw1, DWORD dw2), (hIMC, dw1, dw2), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetConversionStatus, (HIMC hIMC, LPDWORD pdw1, LPDWORD pdw2), (hIMC, pdw1, pdw2), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetProperty, (HKL hKL, DWORD dw), (hKL, dw), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetOpenStatus, (HIMC hIMC), (hIMC), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetContext, (HWND hWnd), (hWnd), HIMC, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetOpenStatus, (HIMC hIMC, BOOL f), (hIMC, f), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmInstallIMEA, (LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmCreateIMCC, (DWORD dw), (dw), HIMCC, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmIsUIMessageA, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmIsUIMessageW, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetVirtualKey, (HWND hWnd), (hWnd), UINT, VK_PROCESSKEY)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM pCF), (hIMC, pCF), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmConfigureIMEA, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmConfigureIMEW, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmDestroyContext, (HIMC hIMC), (hIMC), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmAssociateContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), HIMC, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmEscapeA, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmEscapeW, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmIsIME, (HKL hKL), (hKL), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmCreateContext, (void), (), HIMC, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCompositionFontA, (HIMC hIMC, LPLOGFONTA plf), (hIMC, plf), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCompositionFontW, (HIMC hIMC, LPLOGFONTW plf), (hIMC, plf), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCandidateWindow, (HIMC hIMC, DWORD dw, LPCANDIDATEFORM pCF), (hIMC, dw, pCF), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCandidateListA, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCandidateListW, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCandidateListCountA, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCandidateListCountW, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCompositionStringA, (HIMC hIMC, DWORD dw1, LPVOID pv, DWORD dw2), (hIMC, dw1, pv, dw2), LONG, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCompositionStringW, (HIMC hIMC, DWORD dw1, LPVOID pv, DWORD dw2), (hIMC, dw1, pv, dw2), LONG, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM pCF), (hIMC, pCF), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetConversionListA, (HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetConversionListW, (HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetIMCCSize, (HIMCC hIMCC), (hIMCC), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmReSizeIMCC, (HIMCC hIMCC, DWORD dw), (hIMCC, dw), HIMCC, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmUnlockIMCC, (HIMCC hIMCC), (hIMCC), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmLockIMCC, (HIMCC hIMCC), (hIMCC), LPVOID, NULL)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmDestroyIMCC, (HIMCC hIMCC), (hIMCC), HIMCC, hIMCC)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmUnlockIMC, (HIMC hIMC), (hIMC), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmLockIMC, (HIMC hIMC), (hIMC), LPINPUTCONTEXT, NULL)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dw1, LPCVOID lpRead, DWORD dw2), (hIMC, dwIndex, lpComp, dw1, lpRead, dw2), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dw1, LPCVOID lpRead, DWORD dw2), (hIMC, dwIndex, lpComp, dw1, lpRead, dw2), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetCompositionFontA, (HIMC hIMC, LPLOGFONTA plf), (hIMC, plf), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetCompositionFontW, (HIMC hIMC, LPLOGFONTW plf), (hIMC, plf), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSetCandidateWindow, (HIMC hIMC, LPCANDIDATEFORM pCF), (hIMC, pCF), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmRegisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmRegisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmUnregisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmUnregisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetRegisterWordStyleA, (HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetRegisterWordStyleW, (HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmSimulateHotKey, (HWND hWnd, DWORD dwHotKeyID), (hWnd, dwHotKeyID), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetGuideLineA, (HIMC hIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetGuideLineW, (HIMC hIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmAssociateContextEx, (HWND hWnd, HIMC hIMC, DWORD dwFlags), (hWnd, hIMC, dwFlags), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmDisableIME, (DWORD dwId), (dwId), BOOL, FALSE)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetImeMenuItemsA, (HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmGetImeMenuItemsW, (HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize), DWORD, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmRequestMessageA, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0)
DELAYLOAD(g_hImm32, imm32.dll, WINAPI, ImmRequestMessageW, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0)

#endif // UNUSED_IMM32_APIS

//
// shell32
//

HINSTANCE g_hShell32 = 0;

BOOL WINAPI Internal_Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATA pnid)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShell32 == NULL)
    {
        pfn = GetFn(&g_hShell32, "shell32.dll", "Shell_NotifyIconA");

        if (pfn == NULL)
        {
            Assert(0);
            return FALSE;
        }
    }

    return ((BOOL (WINAPI *)(DWORD dwMessage, PNOTIFYICONDATA pnid))(pfn))(dwMessage, pnid);
}

BOOL WINAPI Internal_Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW pnid)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShell32 == NULL)
    {
        pfn = GetFn(&g_hShell32, "shell32.dll", "Shell_NotifyIconW");

        if (pfn == NULL)
        {
            Assert(0);
            return FALSE;
        }
    }

    return ((BOOL (WINAPI *)(DWORD dwMessage, PNOTIFYICONDATAW pnid))(pfn))(dwMessage, pnid);
}

BOOL WINAPI Internal_Shell_SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pabd)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShell32 == NULL)
    {
        pfn = GetFn(&g_hShell32, "shell32.dll", "SHAppBarMessage");

        if (pfn == NULL)
        {
            Assert(0);
            return FALSE;
        }
    }

    return ((BOOL (WINAPI *)(DWORD dwMessage,PAPPBARDATA pabd ))(pfn))(dwMessage, pabd);
}

//
// ole32
//
HINSTANCE g_hOle32 = 0;
extern "C" HRESULT WINAPI TF_CreateCategoryMgr(ITfCategoryMgr **ppCategoryMgr);

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
    static FARPROC pfn = NULL;

    // Issue: once library is clean, it can call these directly
    if (IsEqualCLSID(rclsid, CLSID_TF_CategoryMgr))
    {
        return TF_CreateCategoryMgr((ITfCategoryMgr **)ppv);
    }
    else if (IsEqualCLSID(rclsid, CLSID_TF_DisplayAttributeMgr))
    {
        return TF_CreateDisplayAttributeMgr((ITfDisplayAttributeMgr **)ppv);
    }

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoCreateInstance");

        if (pfn == NULL)
        {
            Assert(0);
            if (ppv != NULL)
            {
                *ppv = NULL;
            }
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv))(pfn))(rclsid, punkOuter, dwClsContext, riid, ppv);
}

HRESULT STDAPICALLTYPE Internal_CoInitialize(LPVOID pvReserved)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoInitialize");

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(LPVOID pvReserved))(pfn))(pvReserved);
}

HRESULT STDAPICALLTYPE Internal_CoUninitialize()
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoUninitialize");

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)())(pfn))();
}

void STDAPICALLTYPE Internal_CoTaskMemFree(void *pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemFree");

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    return ((void (STDAPICALLTYPE *)(void *pv))(pfn))(pv);
}

//
// oleacc
//
HINSTANCE g_hOleAcc = 0;
DELAYLOAD(g_hOleAcc, oleacc.dll, WINAPI, CreateStdAccessibleObject, (HWND hwnd, LONG l, REFIID riid, void **ppv), (hwnd, l, riid, ppv), HRESULT, 0)
DELAYLOAD(g_hOleAcc, oleacc.dll, WINAPI, LresultFromObject, (REFIID riid, WPARAM wParam, IUnknown *punk), (riid, wParam, punk), LRESULT, 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\deskband.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
   THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DeskBand.h
   
   Description:   CDeskBand definitions.

**************************************************************************/

#include <windows.h>
#include <shlobj.h>
#include <shpriv.h>

#include "Globals.h"
#include "tipbar.h"

#ifndef _DESKBAND_H_
#define _DESKBAND_H_

#define DB_CLASS_NAME (TEXT("DeskBandSampleClass"))

#define MIN_SIZE_X   32
#define MIN_SIZE_Y   30

#define IDM_COMMAND  0


/**************************************************************************

   CDeskBand class definition

**************************************************************************/

class CDeskBand : public IDeskBand,
                  public IDeskBandEx,
                  public IInputObject, 
                  public IObjectWithSite,
                  public IPersistStream,
                  public IContextMenu
{
protected:
    DWORD m_ObjRefCount;

public:
    CDeskBand();
    ~CDeskBand();

    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(DWORD) AddRef();
    STDMETHODIMP_(DWORD) Release();

    //IOleWindow methods
    STDMETHOD (GetWindow) (HWND*);
    STDMETHOD (ContextSensitiveHelp) (BOOL);

    //IDockingWindow methods
    STDMETHOD (ShowDW) (BOOL fShow);
    STDMETHOD (CloseDW) (DWORD dwReserved);
    STDMETHOD (ResizeBorderDW) (LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

    //IDeskBand methods
    STDMETHOD (GetBandInfo) (DWORD, DWORD, DESKBANDINFO*);

    //IDeskBandEx methods
    STDMETHOD (MoveBand) (void);

    //IInputObject methods
    STDMETHOD (UIActivateIO) (BOOL, LPMSG);
    STDMETHOD (HasFocusIO) (void);
    STDMETHOD (TranslateAcceleratorIO) (LPMSG);

    //IObjectWithSite methods
    STDMETHOD (SetSite) (IUnknown*);
    STDMETHOD (GetSite) (REFIID, LPVOID*);

    //IPersistStream methods
    STDMETHOD (GetClassID) (LPCLSID);
    STDMETHOD (IsDirty) (void);
    STDMETHOD (Load) (LPSTREAM);
    STDMETHOD (Save) (LPSTREAM, BOOL);
    STDMETHOD (GetSizeMax) (ULARGE_INTEGER*);

    //IContextMenu methods
    STDMETHOD (QueryContextMenu)(HMENU, UINT, UINT, UINT, UINT);
    STDMETHOD (InvokeCommand)(LPCMINVOKECOMMANDINFO);
    STDMETHOD (GetCommandString)(UINT_PTR, UINT, LPUINT, LPSTR, UINT);

    BOOL ResizeRebar(HWND hwnd, int nSize, BOOL fFit);
    void DeleteBand();

    BOOL IsInTipbarCreating() {return m_fTipbarCreating;}
private:
    BOOL m_bFocus;
    HWND m_hwndParent;
    DWORD m_dwViewMode;
    DWORD m_dwBandID;
    IInputObjectSite *m_pSite;
    BOOL  m_fTipbarCreating;
    BOOL  m_fInCloseDW;

private:
    void FocusChange(BOOL);
    void OnKillFocus(HWND hWnd);
    void OnSetFocus(HWND hWnd);
    BOOL RegisterAndCreateWindow(void);
};

#endif   // _DESKBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\guid.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Guid.h
   
   Description:   Private GUID definition.

**************************************************************************/

/* 540d8a8b-1c3f-4e32-8132-530f6a502090 */
DEFINE_GUID(CLSID_MSUTBDeskBand,
0x540d8a8b, 0x1c3f, 0x4e32, 0x81, 0x32, 0x53, 0x0f, 0x6a, 0x50, 0x20, 0x90);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\globals.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
   THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Globals.h
   
**************************************************************************/

/**************************************************************************
   global variables
**************************************************************************/

#ifndef GLOBALS_H
#define GLOBALS_H

#include "immxutil.h"

extern HINSTANCE  g_hInst;
extern UINT       g_DllRefCount;

extern BOOL g_fRunningOnNT;
extern BOOL g_fRunningOnNT5;
extern BOOL g_fRunningOn98;
extern BOOL g_fRunningOn95;
extern BOOL g_fRunningOnFE;
extern UINT g_uACP;

extern LIBTHREAD g_libTLS;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


STDAPI SetRegisterLangBand(BOOL bSetReg);

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarCoInitialize
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarCoInitialize
{
public:
    CTipbarCoInitialize() 
    {
        _fInitialized = FALSE;
    }
    ~CTipbarCoInitialize() 
    {
        Assert(!_fInitialized);
    }

    HRESULT EnsureCoInit()
    {
        HRESULT hr;

        if (_fInitialized)
            return S_OK;

        hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
            _fInitialized = TRUE;
        return hr;
    }

    void CoUninit()
    {
        if (_fInitialized)
        {
            CoUninitialize();
            _fInitialized = FALSE;
        }
    }

private:
    BOOL _fInitialized;
};

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\intlmenu.cpp ===
//
// intlmenu.cpp
//

#include "private.h"
#include "regstr.h"
#include "resource.h"
#include "globals.h"
#include "tipbar.h"
#include "cuimenu.h"
#include "intlmenu.h"
#include "balloon.h"
#include "xstring.h"
#include "helpers.h"
#include "cmydc.h"
#include "cresstr.h"
#include "cregkey.h"
#include "iconlib.h"
#include "delay.h"
#include "utbdlgs.h"


extern HINSTANCE g_hInst;


const TCHAR  c_szCTFMon[]  = TEXT("CTFMON.EXE");

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// GetBitmapFromItem
//
//----------------------------------------------------------------------------

BOOL GetBitmapFromItem(CTipbarItem *pItem, HBITMAP *phbmp, HBITMAP *phbmpMask)
{
    CTipbarButtonItem *plbiButton = NULL;
    CTipbarBitmapButtonItem *plbiBitmapButton = NULL;
    CTipbarBitmapItem *plbiBitmap = NULL;
    CTipbarBalloonItem *plbiBalloon = NULL;
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    BOOL bRet = FALSE;

    *phbmp = NULL;
    *phbmpMask = NULL;

    if (FAILED(pItem->QueryInterface(IID_PRIV_BUTTONITEM, 
                                     (void **)&plbiButton)) &&
        FAILED(pItem->QueryInterface(IID_PRIV_BITMAPBUTTONITEM, 
                                     (void **)&plbiBitmapButton)) &&
        FAILED(pItem->QueryInterface(IID_PRIV_BITMAPITEM, 
                                     (void **)&plbiBitmap)) &&
        FAILED(pItem->QueryInterface(IID_PRIV_BALLOONITEM, 
                                     (void **)&plbiBalloon)))
    {
        goto Exit;
    }

    if (plbiButton)
    {
        HICON hIcon;
        int cxSmIcon;
        int cySmIcon;
#ifdef SCALE_ICON
        cxSmIcon = cySmIcon = GetMenuIconHeight(NULL);
#else
        cxSmIcon = 16;
        cySmIcon = 16;
#endif

        SIZE size = {cxSmIcon, cySmIcon};
        if (SUCCEEDED(plbiButton->GetLangBarItem()->GetIcon(&hIcon)))
        {
            if (hIcon)
            {
                HICON hSmIcon = (HICON)CopyImage(hIcon, 
                                             IMAGE_ICON, 
                                             cxSmIcon, cySmIcon,
                                             LR_COPYFROMRESOURCE);

                GetIconBitmaps(hSmIcon ? hSmIcon : hIcon, &hbmp, &hbmpMask, &size);
                if (hSmIcon)
                    DestroyIcon(hSmIcon);
                DestroyIcon(hIcon);
            }
        }
    }
    else if (plbiBitmapButton)
    {
        SIZE sizeDef = {32,16};
        SIZE size;
        plbiBitmapButton->GetLangBarItem()->GetPreferredSize(&sizeDef, &size);
        plbiBitmapButton->GetLangBarItem()->DrawBitmap(size.cx, size.cy, 0, &hbmp, &hbmpMask);
    }
    else if (plbiBitmap)
    {
        SIZE sizeDef = {32,16};
        SIZE size;
        plbiBitmap->GetLangBarItem()->GetPreferredSize(&sizeDef, &size);
        plbiBitmap->GetLangBarItem()->DrawBitmap(size.cx, size.cy, 0, &hbmp, &hbmpMask);
    }
    else if (plbiBalloon)
    {
        goto Exit;
    }

    if (hbmp)
    {
       bRet = TRUE;
       *phbmp = hbmp;
       *phbmpMask = hbmpMask;
    }
    else
    {
        if (hbmpMask)
            DeleteObject(hbmpMask);
    }

Exit:
    SafeRelease(plbiButton);
    SafeRelease(plbiBitmapButton);
    SafeRelease(plbiBitmap);
    SafeRelease(plbiBalloon);
    return bRet;

}

//+---------------------------------------------------------------------------
//
// IsFELangId
//
//----------------------------------------------------------------------------

BOOL IsFELangId(LANGID langid)
{
    if ((langid == 0x411) ||
        (langid == 0x404) ||
        (langid == 0x412) ||
        (langid == 0x804))
    {
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CheckCloseMenuAvailable
//
//----------------------------------------------------------------------------

BOOL CheckCloseMenuAvailable()
{
    ITfInputProcessorProfiles *ppip = NULL;
    BOOL bRet = FALSE;
    LANGID *plangid = NULL;
    ULONG ulCnt;
    ULONG ul;

    //
    // If g_bShowCloseMenu is on, show "Close" menu item anyway....
    //
    if (g_bShowCloseMenu)
    {
        bRet = TRUE;
        goto Exit;
    }

    if (FAILED(TF_CreateInputProcessorProfiles(&ppip)))
        goto Exit;

    if (FAILED(ppip->GetLanguageList(&plangid, &ulCnt)))
        goto Exit;

    //
    // If two or more languages are registered, don't show "Close" menu item.
    //
    for (ul = 0; ul < ulCnt; ul++)
    {
        //
        // If the languages is FE, don't show "Close" menu item.
        //
        if (IsFELangId(plangid[ul]))
            goto Exit;
    }

    bRet = TRUE;
Exit:

    if (plangid)
        CoTaskMemFree(plangid);
    SafeRelease(ppip);
    return bRet;
}


//////////////////////////////////////////////////////////////////////////////
//
// CUTBIntelliMenu
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CUTBIntelliMenu::CUTBIntelliMenu(CTipbarWnd *ptw)
{
    _ptw = ptw;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CUTBIntelliMenu::~CUTBIntelliMenu()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CUTBIntelliMenu::Init()
{
    int nCnt;
    int i;
    BOOL bRet = FALSE;
    DWORD dwThreadId;

    _rgItem.Clear();

    _ptt = _ptw->GetFocusThread();
    if (!_ptt)
        goto Exit;

    dwThreadId = _ptt->_dwThreadId;

    // _ptt->UpdateItems();

    nCnt = _ptt->_rgItem.Count();
    for (i = 0; i < nCnt; i++)
    {
        CTipbarItem *pItem = _ptt->_rgItem.Get(i);
        if (!pItem->IsHiddenStatusControl())
        {
            CTipbarItem **ppItem = _rgItem.Append(1);
            if (ppItem)
                *ppItem = pItem;
        }
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// ShowUI
//
//----------------------------------------------------------------------------

UINT CUTBIntelliMenu::ShowPopup(CUIFWindow *pcuiWndParent, const POINT pt, const RECT *prcArea)
{
    if (_pCuiMenu)
         return 0;

    _pCuiMenu = CreateMenuUI();
    if (!_pCuiMenu)
        return 0;

    UINT uRet = _pCuiMenu->ShowModalPopup(pcuiWndParent, prcArea, TRUE);

    delete _pCuiMenu;
    _pCuiMenu = NULL;
    return uRet;
}

//+---------------------------------------------------------------------------
//
// CreateMenuUI
//
//----------------------------------------------------------------------------


CUTBMenuWnd *CUTBIntelliMenu::CreateMenuUI()
{
    CUTBMenuWnd *pCuiMenu;
    CUTBMenuItem *pCuiItem;
    int i;
    BOOL fInsertedItem = FALSE;
    DWORD dwCat = -1;

    if (!_ptw)
    {
        Assert(0);
        return NULL;
    }

    pCuiMenu = new CUTBMenuWnd(g_hInst, g_dwMenuStyle, 0);
    if (!pCuiMenu)
        return NULL;

    pCuiMenu->Initialize();

    if (!_ptw->IsInDeskBand() || !_ptw->IsSFNoExtraIcon())
    {
        for (i = 0; i < _rgItem.Count(); i++)
        {
            CTipbarItem *pItem = _rgItem.Get(i);
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            CItemSortScore *pscore = pItem->GetItemSortScore();

            if (!GetBitmapFromItem(pItem, &hbmp, &hbmpMask))
                continue;

            pCuiItem = new CUTBMenuItem(pCuiMenu);

            if (!pCuiItem)
                break;

            if (dwCat != pscore->GetCat())
            {
                if (dwCat != -1)
                {
                    pCuiMenu->InsertSeparator();
                }
            }

            dwCat = pscore->GetCat();

            pCuiItem->Initialize();
            pCuiItem->Init(i, pItem->GetDescriptionRef());
            if (pItem->IsVisibleInToolbar())
                 pCuiItem->Check(TRUE);

            if (hbmp)
                pCuiItem->SetBitmap(hbmp);

            if (hbmpMask)
                pCuiItem->SetBitmapMask(hbmpMask);

            pCuiMenu->InsertItem(pCuiItem);
            fInsertedItem = TRUE;
        }

        if (fInsertedItem)
            pCuiMenu->InsertSeparator();
    }

    if (_ptw->IsInDeskBand())
    {
        if (!_ptw->IsSFNoExtraIcon())
        {
            pCuiItem = InsertItem(pCuiMenu, 
                                  IDM_NONOTIFICATIONICONS, 
                                  IDS_NOTIFICATIONICONS);

            if (pCuiItem)
                pCuiItem->Check(TRUE);
        }
        else
        {
            pCuiItem = InsertItem(pCuiMenu, IDM_NOTIFICATIONICONS, IDS_NOTIFICATIONICONS);
        }

        //
        // Always show the extra additional icons in case of single keyboard
        // layout.
        //
        if (_ptw->IsSingleKeyboardLayout())
        {
            if (pCuiItem)
            {
                pCuiItem->Check(TRUE);
                pCuiItem->Gray(TRUE);
            }
        }
        else
        {
            if (pCuiItem)
                pCuiItem->Gray(FALSE);
        }
        InsertItem(pCuiMenu, IDM_ADJUSTLANGBAND, IDS_ADJUSTLANGBAND);
    }

    if (pCuiItem = new CUTBMenuItem(pCuiMenu))
    {
        pCuiItem->Initialize();
        pCuiItem->Init(IDM_SHOWINPUTCPL, CRStr(IDS_SHOWINPUTCPL));
        pCuiMenu->InsertItem(pCuiItem);
    }

    if (pCuiItem = new CUTBMenuItem(pCuiMenu))
    {
        pCuiItem->Initialize();
        pCuiItem->Init(IDM_RESTOREDEFAULTS, CRStr(IDS_RESTOREDEFAULTS));
        pCuiMenu->InsertItem(pCuiItem);
    }


    return pCuiMenu;
}

//+---------------------------------------------------------------------------
//
// SelectMenuItem
//
//----------------------------------------------------------------------------

BOOL CUTBIntelliMenu::SelectMenuItem(UINT uId)
{
    UINT uCnt = _rgItem.Count();
    CTipbarItem *pItem = NULL;

    if (uId == IDM_SHOWINPUTCPL)
    {
        TF_RunInputCPL();
    }
    else if (uId == IDM_RESTOREDEFAULTS)
    {
        if (_ptw)
            _ptw->ClearLBItemList();
    }
    else if (uId == IDM_NOTIFICATIONICONS)
    {
        if (_ptw)
        {
            _ptw->ClearDeskbandSizeAdjusted();
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_EXTRAICONSONMINIMIZED);
        }
    }
    else if (uId == IDM_NONOTIFICATIONICONS)
    {
        if (_ptw)
        {
            _ptw->ClearDeskbandSizeAdjusted();
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_NOEXTRAICONSONMINIMIZED);
        }
    }
    else if (uId == IDM_ADJUSTLANGBAND)
    {
        if (_ptw)
            _ptw->AdjustDeskBandSize(TRUE);
    }
    else if (IDM_ADDREMOVESTART <= uId)
    {
        pItem = _ptt->_rgItem.Get(uId - IDM_ADDREMOVESTART);
    }
    else if (uCnt > uId)
    {
        pItem = _rgItem.Get(uId);
    }

    if (pItem)
    {
        LBDemoteLevel lbdl = pItem->IsVisibleInToolbar() ? DL_HIDDENLEVEL2 : DL_SHOWN;
        if (lbdl != DL_SHOWN)
        {
            BOOL fFound = FALSE;
            int i;
            CMyRegKey key;

            for (i = 0; i < _ptt->_rgItem.Count(); i++)
            {
                CTipbarItem *pItemTmp = _ptt->_rgItem.Get(i);
                if (pItemTmp)
                {
                    if (pItemTmp == pItem)
                        continue;

                    if (pItemTmp->IsHideOnNoOtherItems())
                        continue;

                    if (!pItemTmp->IsVisibleInToolbar())
                        continue;
 
                    fFound = TRUE;
                    break;
                }
            }

            if (!fFound)
            {
                int nRet = MessageBox(_ptt->_ptw->GetWnd(), 
                                      CRStr2(IDS_NOMOREITEM),
                                      CRStr(IDS_LANGBAR),
                                      MB_YESNO);
                if (nRet != IDYES)
                    return TRUE;

                //
                // we close language bar instead of hiding the item.
                //
                _ptt->_ptw->GetLangBarMgr()->ShowFloating(TF_SFT_HIDDEN);
                if (key.Open(HKEY_CURRENT_USER, REGSTR_PATH_RUN, KEY_ALL_ACCESS) == S_OK)
                    key.DeleteValue(c_szCTFMon);

                 return TRUE;
            }
        }

        _ptw->_itemList.SetDemoteLevel(*pItem->GetGUID(), lbdl);

        if (lbdl == DL_SHOWN)
            _ptw->_itemList.StartDemotingTimer(*pItem->GetGUID(), TRUE);

        //
        // we adjust the deskband if Item is added or removed by
        // the end user. But we don't want to adjust if there is a room
        // to draw all items.
        //
        _ptw->ClearDeskbandSizeAdjusted();
        _ptw->SetAdjustDeskbandIfNoRoom();

        pItem->AddRemoveMeToUI(lbdl == DL_SHOWN);

    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CUTBContextMenu
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CUTBContextMenu::CUTBContextMenu(CTipbarWnd *ptw)
{
    _ptw = ptw;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CUTBContextMenu::~CUTBContextMenu()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CUTBContextMenu::Init()
{
    BOOL bRet = FALSE;
    DWORD dwThreadId;

    _ptt = _ptw->GetFocusThread();
    if (!_ptt)
        return FALSE;

    dwThreadId = _ptt->_dwThreadId;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ShowUI
//
//----------------------------------------------------------------------------

UINT CUTBContextMenu::ShowPopup(CUIFWindow *pcuiWndParent, const POINT pt, const RECT *prcArea, BOOL fExtendMenuItems)
{
    if (g_bWinLogon)
         return 0;

    if (_pCuiMenu)
         return CUI_MENU_UNSELECTED;

    if (!(_pCuiMenu = CreateMenuUI(fExtendMenuItems)))
         return 0;

    UINT uRet = _pCuiMenu->ShowModalPopup(pcuiWndParent, prcArea, TRUE);

    delete _pCuiMenu;
    _pCuiMenu = NULL;
    return uRet;
}

//+---------------------------------------------------------------------------
//
// IsTransparecyAvailable
//
//----------------------------------------------------------------------------

BOOL IsTransparecyAvailable()
{
    HDC hdc;
    BOOL bRet;

    if (!IsOnNT5())
        return FALSE;

    hdc = GetDC(NULL);
    if (!hdc)
        return FALSE;

    bRet = (GetDeviceCaps(hdc, BITSPIXEL ) > 8) ? TRUE : FALSE;

    ReleaseDC(NULL, hdc);
    return bRet;
}

//+---------------------------------------------------------------------------
//
// CreateMenuUI
//
//----------------------------------------------------------------------------

CUTBMenuWnd *CUTBContextMenu::CreateMenuUI(BOOL fExtendMenuItems)
{
    CUTBMenuWnd *pCuiMenu;
    BOOL fInsertedItem = FALSE;
    DWORD dwCat = -1;
    DWORD dwStatus;
    CUTBMenuItem *pMenuItem;

    if (FAILED(_ptw->GetLangBarMgr()->GetShowFloatingStatus(&dwStatus)))
        return NULL;

    pCuiMenu = new CUTBMenuWnd(g_hInst, g_dwMenuStyle, 0);
    if (!pCuiMenu)
        return NULL;

    pCuiMenu->Initialize();

    if (dwStatus & (TF_SFT_MINIMIZED | TF_SFT_DESKBAND))
    {
       pMenuItem = InsertItem(pCuiMenu, IDM_RESTORE, IDS_RESTORE);
       if (pMenuItem && !_ptw->_fIsItemShownInFloatingToolbar)
           pMenuItem->Gray(TRUE);
    }
    else
    {
       InsertItem(pCuiMenu, IDM_MINIMIZE, IDS_MINIMIZE);

       if (fExtendMenuItems)
       {
           if (IsTransparecyAvailable())
           {
               if (dwStatus & TF_SFT_NOTRANSPARENCY)
               {
                   InsertItem(pCuiMenu, IDM_TRANSPARENCYON, IDS_TRANSPARENCY);
               }
               else
               {
                   pMenuItem = InsertItem(pCuiMenu, IDM_TRANSPARENCYOFF, IDS_TRANSPARENCY);
                   if (pMenuItem)
                       pMenuItem->Check(TRUE);
               }
           }

           if (dwStatus & TF_SFT_LABELS)
           {
               pMenuItem = InsertItem(pCuiMenu, IDM_HIDELABEL, IDS_TEXTLABEL);
               if (pMenuItem)
                   pMenuItem->Check(TRUE);
           }
           else
           {
               InsertItem(pCuiMenu, IDM_SHOWLABEL, IDS_TEXTLABEL);
           }

           pMenuItem = InsertItem(pCuiMenu, IDM_VERTICAL, IDS_VERTICAL);
           if (pMenuItem)
               pMenuItem->Check(_ptw->IsVertical());
       }
    }

    if (fExtendMenuItems)
    {
        if (dwStatus & TF_SFT_EXTRAICONSONMINIMIZED)
        {
            pMenuItem = InsertItem(pCuiMenu, 
                                   IDM_NONOTIFICATIONICONS, 
                                   IDS_NOTIFICATIONICONS);

            if (pMenuItem)
                pMenuItem->Check(TRUE);
        }
        else
        {
            pMenuItem = InsertItem(pCuiMenu, IDM_NOTIFICATIONICONS, IDS_NOTIFICATIONICONS);
        }

        //
        // Always show the extra additional icons in case of single keyboard
        // layout.
        //
        if (_ptw->IsSingleKeyboardLayout())
        {
            if (pMenuItem)
            {
                pMenuItem->Check(TRUE);
                pMenuItem->Gray(TRUE);
            }
        }
        else
        {
            if (pMenuItem)
                pMenuItem->Gray(FALSE);
        }

        if (dwStatus & TF_SFT_DESKBAND)
            InsertItem(pCuiMenu, IDM_ADJUSTLANGBAND, IDS_ADJUSTLANGBAND);

        InsertItem(pCuiMenu, IDM_SHOWINPUTCPL, IDS_SHOWINPUTCPL);

        if (CheckCloseMenuAvailable())
            InsertItem(pCuiMenu, IDM_CLOSE, IDS_CLOSE);
    }

    return pCuiMenu;
}

//+---------------------------------------------------------------------------
//
// SelectMenuItem
//
//----------------------------------------------------------------------------

BOOL CUTBContextMenu::SelectMenuItem(UINT uId)
{
    CUTBCloseLangBarDlg *pDlg;
    CUTBMinimizeLangBarDlg *pMinimizeDlg;
    CMyRegKey key;

    switch (uId)
    {
        case IDM_MINIMIZE:
            //
            // Use Deskband object instead of system tray icon on NT51
            //
            if (IsOnNT51())
            {
                DWORD dwStatus;

                _ptw->GetLangBarMgr()->GetShowFloatingStatus(&dwStatus);

                if (!(dwStatus & TF_SFT_DESKBAND))
                {
                    _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_DESKBAND);

                    if (pMinimizeDlg = new CUTBMinimizeLangBarDlg)
                    {
                        pMinimizeDlg->DoModal(_ptw->GetWnd());
                        pMinimizeDlg->_Release();
                    }
                }
                break;
            }
            else
            {
                _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_MINIMIZED);

                if (pMinimizeDlg = new CUTBMinimizeLangBarDlg)
                {
                    pMinimizeDlg->DoModal(_ptw->GetWnd());
                    pMinimizeDlg->_Release();
                }
                break;
            }

        case IDM_RESTORE:
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);
            break;

        case IDM_VERTICAL:
            _ptw->SetVertical(!_ptw->IsVertical());
            break;

        case IDM_CLOSE:
            if (pDlg = new CUTBCloseLangBarDlg)
            {
                int nRet = pDlg->DoModal(_ptw->GetWnd());
                pDlg->_Release();

                if (!nRet)
                {
                    // 
                    // if we don't show the dialog box, 
                    // we close the language bar now.
                    // 
                    DoCloseLangbar();
                }
            }
            break;

        case IDM_TRANSPARENCYON:
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_LOWTRANSPARENCY);
            break;

        case IDM_TRANSPARENCYOFF:
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_NOTRANSPARENCY);
            break;

        case IDM_SHOWLABEL:
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_LABELS);
            break;

        case IDM_HIDELABEL:
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_NOLABELS);
            break;

        case IDM_SHOWINPUTCPL:
            TF_RunInputCPL();
            break;

        case IDM_NOTIFICATIONICONS:
            _ptw->ClearDeskbandSizeAdjusted();
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_EXTRAICONSONMINIMIZED);
            break;

        case IDM_NONOTIFICATIONICONS:
            _ptw->ClearDeskbandSizeAdjusted();
            _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_NOEXTRAICONSONMINIMIZED);
            break;

        case IDM_ADJUSTLANGBAND:
            _ptw->AdjustDeskBandSize(TRUE);
            break;
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\deskband.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
   THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DeskBand.cpp
   
   Description:   Implements CDeskBand

**************************************************************************/

/**************************************************************************
   include statements
**************************************************************************/

#include "private.h"
#include "DeskBand.h"
#include "tipbar.h"
#include "Guid.h"
#include <shlapip.h>

extern CTipbarWnd *g_pTipbarWnd;

const IID IID_IDeskBandEx = {
    0x5dd6b79a,
    0x3ab7,
    0x49c0,
    {0xab,0x82,0x6b,0x2d,0xa7,0xd7,0x8d,0x75}
  };


/**************************************************************************

   CDeskBand::CDeskBand()

**************************************************************************/

CDeskBand::CDeskBand()
{
    m_pSite = NULL;

    m_hwndParent = NULL;

    m_bFocus = FALSE;

    m_dwViewMode = 0;
    m_dwBandID = -1;

    m_ObjRefCount = 1;
    g_DllRefCount++;
}

/**************************************************************************

   CDeskBand::~CDeskBand()

**************************************************************************/

CDeskBand::~CDeskBand()
{
    // this should have been freed in a call to SetSite(NULL), 
    // but just to be safe
    if(m_pSite)
    {
        m_pSite->Release();
        m_pSite = NULL;
    }

    g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CDeskBand::QueryInterface

**************************************************************************/

STDMETHODIMP CDeskBand::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
    *ppReturn = NULL;

    //IUnknown
    if(IsEqualIID(riid, IID_IUnknown))
    {
       *ppReturn = this;
    }

    //IOleWindow
    else if(IsEqualIID(riid, IID_IOleWindow))
    {
       *ppReturn = (IOleWindow*)this;
    }

    //IDockingWindow
    else if(IsEqualIID(riid, IID_IDockingWindow))
    {
       *ppReturn = (IDockingWindow*)this;
    }    

    //IInputObject
    else if(IsEqualIID(riid, IID_IInputObject))
    {
       *ppReturn = (IInputObject*)this;
    }   

    //IObjectWithSite
    else if(IsEqualIID(riid, IID_IObjectWithSite))
    {
       *ppReturn = (IObjectWithSite*)this;
    }   

    //IDeskBand
    else if(IsEqualIID(riid, IID_IDeskBand))
    {
        *ppReturn = (IDeskBand*)this;
    }   

    //IDeskBandEx
    else if(IsEqualIID(riid, IID_IDeskBandEx))
    {
        *ppReturn = (IDeskBandEx*)this;
    }   

    //IPersist
    else if(IsEqualIID(riid, IID_IPersist))
    {
        *ppReturn = (IPersist*)this;
    }   

    //IPersistStream
    else if(IsEqualIID(riid, IID_IPersistStream))
    {
        *ppReturn = (IPersistStream*)this;
    }   

    //IContextMenu
    else if(IsEqualIID(riid, IID_IContextMenu))
    {
        *ppReturn = (IContextMenu*)this;
    }   

    if(*ppReturn)
    {
        (*(LPUNKNOWN*)ppReturn)->AddRef();
        return S_OK;
    }

    return E_FAIL;
}                                             

/**************************************************************************

   CDeskBand::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CDeskBand::AddRef()
{
    return ++m_ObjRefCount;
}


/**************************************************************************

   CDeskBand::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CDeskBand::Release()
{
    if(--m_ObjRefCount == 0)
    {
        delete this;
        return 0;
    }
   
    return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Implementation
//

/**************************************************************************

   CDeskBand::GetWindow()
   
**************************************************************************/

STDMETHODIMP CDeskBand::GetWindow(HWND *phWnd)
{
    if (!g_pTipbarWnd)
        *phWnd = NULL;
    else
        *phWnd = g_pTipbarWnd->GetWnd();

    return S_OK;
}

/**************************************************************************

   CDeskBand::ContextSensitiveHelp()
   
**************************************************************************/

STDMETHODIMP CDeskBand::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDockingWindow Implementation
//

/**************************************************************************

   CDeskBand::ShowDW()
   
**************************************************************************/

STDMETHODIMP CDeskBand::ShowDW(BOOL fShow)
{
    if (!g_pTipbarWnd)
        return S_OK;

    if (g_pTipbarWnd->GetWnd())
    {
        g_pTipbarWnd->Show(fShow);
    }

    return S_OK;
}

/**************************************************************************

   CDeskBand::CloseDW()
   
**************************************************************************/

STDMETHODIMP CDeskBand::CloseDW(DWORD dwReserved)
{
    if (m_fInCloseDW)
        return S_OK;

    AddRef();

    m_fInCloseDW = TRUE;

    ShowDW(FALSE);

    if(g_pTipbarWnd && IsWindow(g_pTipbarWnd->GetWnd()))
    {
        ClosePopupTipbar();
    }
    m_fInCloseDW = FALSE;

    Release();

    return S_OK;
}

/**************************************************************************

   CDeskBand::ResizeBorderDW()
   
**************************************************************************/

STDMETHODIMP CDeskBand::ResizeBorderDW(   LPCRECT prcBorder, 
                                          IUnknown* punkSite, 
                                          BOOL fReserved)
{
    // This method is never called for Band Objects.
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IInputObject Implementation
//

/**************************************************************************

   CDeskBand::UIActivateIO()
   
**************************************************************************/

STDMETHODIMP CDeskBand::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
#if 1
    //
    // we don't have keyboard access to the language bar, yet.
    // however the accessibility requires it. when it is done, this can be
    // implemented.
    //
    return E_NOTIMPL;
#else
    if(g_pTipbarWnd && fActivate)
        SetFocus(g_pTipbarWnd->GetWnd());

    return S_OK;
#endif
}

/**************************************************************************

   CDeskBand::HasFocusIO()
   
   If this window or one of its decendants has the focus, return S_OK. Return 
   S_FALSE if we don't have the focus.

**************************************************************************/

STDMETHODIMP CDeskBand::HasFocusIO(void)
{
    if(m_bFocus)
        return S_OK;

    return S_FALSE;
}

/**************************************************************************

   CDeskBand::TranslateAcceleratorIO()
   
   If the accelerator is translated, return S_OK or S_FALSE otherwise.

**************************************************************************/

STDMETHODIMP CDeskBand::TranslateAcceleratorIO(LPMSG pMsg)
{
    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// IObjectWithSite implementations
//

/**************************************************************************

   CDeskBand::SetSite()
   
**************************************************************************/

STDMETHODIMP CDeskBand::SetSite(IUnknown* punkSite)
{
    //If a site is being held, release it.
    if(m_pSite)
    {
        m_pSite->Release();
        m_pSite = NULL;
    }

    // If punkSite is not NULL, a new site is being set.
    if(punkSite)
    {
        // Get the parent window.
        IOleWindow  *pOleWindow;

        m_hwndParent = NULL;
   
        if(SUCCEEDED(punkSite->QueryInterface(IID_IOleWindow, 
                                              (LPVOID*)&pOleWindow)))
        {
            pOleWindow->GetWindow(&m_hwndParent);
            pOleWindow->Release();
        }

        if(!m_hwndParent)
            return E_FAIL;

        if(!RegisterAndCreateWindow())
            return E_FAIL;

        // Get and keep the IInputObjectSite pointer.
        if(SUCCEEDED(punkSite->QueryInterface(IID_IInputObjectSite, 
                                              (LPVOID*)&m_pSite)))
        {
           return S_OK;
        }
   
        return E_FAIL;
    }

    return S_OK;
}

/**************************************************************************

   CDeskBand::GetSite()
   
**************************************************************************/

STDMETHODIMP CDeskBand::GetSite(REFIID riid, LPVOID *ppvReturn)
{
    *ppvReturn = NULL;

    if(m_pSite)
        return m_pSite->QueryInterface(riid, ppvReturn);

    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBand implementation
//

/**************************************************************************

   CDeskBand::GetBandInfo()
   
**************************************************************************/

STDMETHODIMP CDeskBand::GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi)
{
    if(pdbi)
    {
        BOOL bVertical = FALSE;
        m_dwBandID = dwBandID;
        m_dwViewMode = dwViewMode;

        if (DBIF_VIEWMODE_VERTICAL & dwViewMode)
        {
            bVertical = TRUE;
        }

        UINT cxSmIcon;
        UINT cySmIcon;
        UINT cxSize;
        UINT cySize;

        cxSmIcon = GetSystemMetrics(SM_CXSMICON);
        cySmIcon = GetSystemMetrics(SM_CYSMICON);

        cxSize = cxSmIcon;

        if (g_pTipbarWnd)
        {
            g_pTipbarWnd->InitMetrics();
            cySize = g_pTipbarWnd->GetTipbarHeight();
        }
        else
            cySize = cySmIcon + cySmIcon / 3;


        if(pdbi->dwMask & DBIM_MINSIZE)
        {
            if(DBIF_VIEWMODE_FLOATING & dwViewMode)
            {
                pdbi->ptMinSize.x = 200;
                pdbi->ptMinSize.y = 400;
            }
            else
            {
                pdbi->ptMinSize.x = cxSize;
                pdbi->ptMinSize.y = cySize + 2;
            }
        }

        if(pdbi->dwMask & DBIM_MAXSIZE)
        {
            pdbi->ptMaxSize.x = -1;
            pdbi->ptMaxSize.y = -1;
        }

        if(pdbi->dwMask & DBIM_INTEGRAL)
        {
            pdbi->ptIntegral.x = cxSize;
            pdbi->ptIntegral.y = cySize;
        }

        if(pdbi->dwMask & DBIM_ACTUAL)
        {
            pdbi->ptActual.x = cxSize;
            pdbi->ptActual.y = cySize + 2;
        }

        if(pdbi->dwMask & DBIM_TITLE)
        {
            pdbi->dwMask &= ~DBIM_TITLE;
            StringCchCopyW(pdbi->wszTitle, 
                           ARRAYSIZE(pdbi->wszTitle),
                           CRStr(IDS_LANGBAR));
        }

        if(pdbi->dwMask & DBIM_MODEFLAGS)
        {
            pdbi->dwModeFlags = DBIMF_NORMAL;
            pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;
        }
   
        if(pdbi->dwMask & DBIM_BKCOLOR)
        {
            //Use the default background color by removing this flag.
            pdbi->dwMask &= ~DBIM_BKCOLOR;
        }

        //
        // Don't pulls language band into desktop window.
        //
        //pdbi->dwModeFlags |= DBIMF_UNDELETEABLE;

        if (g_pTipbarWnd)
        {
            if (!bVertical)
            {
                g_pTipbarWnd->SetVertical(FALSE);
            }
            else
            {
                g_pTipbarWnd->SetVertical(TRUE);
            }
        }


        return S_OK;
    }

    return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBandEx implementation
//

/**************************************************************************

   CDeskBand::MoveBand()
   
**************************************************************************/

STDMETHODIMP CDeskBand::MoveBand(void)
{
    if (g_pTipbarWnd)
    {
        g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);

        //
        // Don't need ask remove language deskband since we do it by calling
        // ShowFloating().
        //
        return S_FALSE;
    }
    else
    {
        //
        // Let's Explorer remove language deskband.
        //
        return S_OK;
    }
}

///////////////////////////////////////////////////////////////////////////
//
// IPersistStream implementations
// 
// This is only supported to allow the desk band to be dropped on the 
// desktop and to prevent multiple instances of the desk band from showing 
// up in the context menu. This desk band doesn't actually persist any data.
//

/**************************************************************************

   CDeskBand::GetClassID()
   
**************************************************************************/

STDMETHODIMP CDeskBand::GetClassID(LPCLSID pClassID)
{
    *pClassID = CLSID_MSUTBDeskBand;
    return S_OK;
}

/**************************************************************************

   CDeskBand::IsDirty()
   
**************************************************************************/

STDMETHODIMP CDeskBand::IsDirty(void)
{
    return S_FALSE;
}

/**************************************************************************

   CDeskBand::Load()
   
**************************************************************************/

STDMETHODIMP CDeskBand::Load(LPSTREAM pStream)
{
    return S_OK;
}

/**************************************************************************

   CDeskBand::Save()
   
**************************************************************************/

STDMETHODIMP CDeskBand::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    return S_OK;
}

/**************************************************************************

   CDeskBand::GetSizeMax()
   
**************************************************************************/

STDMETHODIMP CDeskBand::GetSizeMax(ULARGE_INTEGER *pul)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IContextMenu Implementation
//

/**************************************************************************

   CDeskBand::QueryContextMenu()

**************************************************************************/

STDMETHODIMP CDeskBand::QueryContextMenu( HMENU hMenu,
                                          UINT indexMenu,
                                          UINT idCmdFirst,
                                          UINT idCmdLast,
                                          UINT uFlags)
{
    if(!(CMF_DEFAULTONLY & uFlags))
    {
       InsertMenu( hMenu, 
                   indexMenu, 
                   MF_STRING | MF_BYPOSITION, 
                   idCmdFirst + IDM_COMMAND, 
                   CRStr(IDS_RESTORE));

       return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_COMMAND + 1));
    }

    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
}

/**************************************************************************

   CDeskBand::InvokeCommand()

**************************************************************************/

STDMETHODIMP CDeskBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    switch (LOWORD(lpcmi->lpVerb))
    {
        case IDM_COMMAND:
           //
           // Load floating language bar and close language band.
           //
           if (g_pTipbarWnd)
           {
               g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);
           }

           //
           // Need to remove language band here
           //

           break;

        default:
           return E_INVALIDARG;
    }

    return NOERROR;
}

/**************************************************************************

   CDeskBand::GetCommandString()

**************************************************************************/

STDMETHODIMP CDeskBand::GetCommandString( UINT_PTR idCommand,
                                          UINT uFlags,
                                          LPUINT lpReserved,
                                          LPSTR lpszName,
                                          UINT uMaxNameLen)
{
    HRESULT  hr = E_INVALIDARG;

    switch(uFlags)
    {
        case GCS_HELPTEXT:
            switch(idCommand)
            {
                case IDM_COMMAND:
                    StringCchCopy(lpszName, uMaxNameLen, "Desk Band command help text");
                    hr = NOERROR;
                    break;
            }
            break;
   
        case GCS_VERB:
            switch(idCommand)
            {
                case IDM_COMMAND:
                     StringCchCopy(lpszName, uMaxNameLen, "command");
                     hr = NOERROR;
                     break;
            }
            break;
   
        case GCS_VALIDATE:
            hr = NOERROR;
            break;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// private method implementations
//


/**************************************************************************

   CDeskBand::FocusChange()
   
**************************************************************************/

void CDeskBand::FocusChange(BOOL bFocus)
{
    m_bFocus = bFocus;

    //inform the input object site that the focus has changed
    if(m_pSite)
    {
        m_pSite->OnFocusChangeIS((IDockingWindow*)this, bFocus);
    }
}

/**************************************************************************

   CDeskBand::OnSetFocus(HWND hWnd)
   
**************************************************************************/

void CDeskBand::OnSetFocus(HWND hWndvoid)
{
    FocusChange(TRUE);

    return;
}

/**************************************************************************

   CDeskBand::OnKillFocus(HWND hWnd)
   
**************************************************************************/

void CDeskBand::OnKillFocus(HWND hWndvoid)
{
    FocusChange(FALSE);

    return;
}

/**************************************************************************

   CDeskBand::RegisterAndCreateWindow()
   
**************************************************************************/

BOOL CDeskBand::RegisterAndCreateWindow(void)
{
    // If the window doesn't exist yet, create it now.
    if (!g_pTipbarWnd)
    {
        m_fTipbarCreating = TRUE;
        GetTipbarInternal(m_hwndParent, 0, this);
        m_fTipbarCreating = FALSE;
    }

    if (!g_pTipbarWnd)
       return FALSE;

    return (NULL != g_pTipbarWnd->GetWnd());
}

/**************************************************************************

   CDeskBand::ResizeRebar()
   
**************************************************************************/

BOOL CDeskBand::ResizeRebar(HWND hwnd, int nSize, BOOL fFit)
{
     RECT rc0;
     RECT rc1;

     //
     // id is not initialized yet.
     //
     if (m_dwBandID == -1)
     {
         return FALSE;
     }

     GetWindowRect(hwnd, &rc0);
     GetWindowRect(m_hwndParent, &rc1);

     //
     // if the current size is nSize, we don't need to do anything.
     //
     int nCurSize;
     if (DBIF_VIEWMODE_VERTICAL & m_dwViewMode)
         nCurSize = rc0.bottom - rc0.top;
     else
         nCurSize = rc0.right - rc0.left;

     if (nCurSize == nSize)
         return TRUE;

     //
     // if the current size is bigger than nSize, we don't need to do anything.
     //
     if (!fFit && (nCurSize > nSize))
         return TRUE;

     //
     // start pos and end pos is offset of Rebar window.
     //
     LPARAM lStart;
     LPARAM lEnd;
     
     if (DBIF_VIEWMODE_VERTICAL & m_dwViewMode)
     {
         int nStart = rc0.top - rc1.top;
         int nEnd = nStart + nCurSize - nSize;
         lStart = MAKELPARAM(1, nStart);
         lEnd = MAKELPARAM(1, nEnd);
     }
     else
     {
         int nStart;
         int nEnd;

         if (g_dwWndStyle & UIWINDOW_LAYOUTRTL)
         {
             nStart = rc1.right - rc0.right;
             nEnd = nStart + nCurSize - nSize;
         }
         else
         {
             nStart = rc0.left - rc1.left;
             nEnd = nStart + nCurSize - nSize;
         }

         lStart = MAKELPARAM(nStart, 1);
         lEnd = MAKELPARAM(nEnd, 1);
     }

     //
     // #560192
     //
     // SendMessage() can yield another message in this thread and
     // this could be a request to remove langband. So this pointer
     // can be gone while the calls.
     // We want to finish the series of SendMessage() so keep the window
     // handle in the stack.
     //
     HWND hwndParent = m_hwndParent;

     int nIndex = (int)SendMessage(hwndParent, RB_IDTOINDEX, m_dwBandID, 0);
     if (nIndex == -1)
         return FALSE;

     //
     // move the deskband.
     //
     SendMessage(hwndParent, RB_BEGINDRAG, nIndex, lStart);
     SendMessage(hwndParent, RB_DRAGMOVE, 0, lEnd);
     SendMessage(hwndParent, RB_ENDDRAG, 0, 0);

     return TRUE;
}

/**************************************************************************

   CDeskBand::DeleteBand()
   
**************************************************************************/

void CDeskBand::DeleteBand()
{
     HWND hwndParent = m_hwndParent;

     int nIndex = (int)SendMessage(hwndParent, RB_IDTOINDEX, m_dwBandID, 0);
     if (nIndex == -1)
         return;

     SendMessage(hwndParent, RB_DELETEBAND, nIndex, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\intlmenu.h ===
//
// intlmenu.h
//
// Generic ITfTextEventSink object
//

#ifndef INTLMENU_H
#define INTLMENU_H

#include "ctfutb.h"
#include "utbmenu.h"
#include "ptrary.h"

class CTipbarWnd;
class CUTBMenuWnd;
class CUIFWindow;


//////////////////////////////////////////////////////////////////////////////
//
// CUTBIntelliMenu
//
//////////////////////////////////////////////////////////////////////////////

class CUTBIntelliMenu : public CModalMenu
{
public:
    CUTBIntelliMenu(CTipbarWnd *ptw);
    ~CUTBIntelliMenu();

    BOOL Init();
    UINT ShowPopup(CUIFWindow *pcuiWndParent, const POINT pt, const RECT *prcArea);

    BOOL SelectMenuItem(UINT uId);
    CUTBMenuWnd *GetCuiMenu() {return _pCuiMenu;}

private:
    CUTBMenuWnd *CreateMenuUI();

    CTipbarWnd *_ptw;
    CTipbarThread *_ptt;
    CPtrArray<CTipbarItem> _rgItem;
};

//////////////////////////////////////////////////////////////////////////////
//
// CUTBContextMenu
//
//////////////////////////////////////////////////////////////////////////////

class CUTBContextMenu : public CModalMenu
{
public:
    CUTBContextMenu(CTipbarWnd *ptw);
    ~CUTBContextMenu();

    BOOL Init();
    UINT ShowPopup(CUIFWindow *pcuiWndParent, const POINT pt, const RECT *prcArea, BOOL fExtendMenuItems);

    BOOL SelectMenuItem(UINT uId);
    CUTBMenuWnd *GetCuiMenu() {return _pCuiMenu;}

private:
    CUTBMenuWnd *CreateMenuUI(BOOL fExtendMenuItems);

    CTipbarWnd *_ptw;
    CTipbarThread *_ptt;
};

#endif // INTLMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\itemlist.cpp ===
//
// itemlist.cpp
//


#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "itemlist.h"
#include "tipbar.h"
#include "cregkey.h"
#include "catutil.h"

const TCHAR c_szLangBarKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\LangBar");
const TCHAR c_szItemState[] = TEXT("ItemState");
const TCHAR c_szItemStateKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\LangBar\\ItemState");
const TCHAR c_szDemoteLevel[] = TEXT("DemoteLevel");
const TCHAR c_szDisableDemoting[] = TEXT("DisableDemoting");

extern CTipbarWnd *g_pTipbarWnd;
extern BOOL g_bIntelliSense;

#define DL_TIMEOUT_NONINTENTIONAL     ( 1 * 60 * 1000) //  1 minute
#define DL_TIMEOUT_INTENTIONAL        (10 * 60 * 1000) // 10 minutes
#define DL_TIMEOUT_MAX                (DL_TIMEOUT_INTENTIONAL * 6)

UINT g_uTimeOutNonIntentional = DL_TIMEOUT_NONINTENTIONAL;
UINT g_uTimeOutIntentional    = DL_TIMEOUT_INTENTIONAL;
UINT g_uTimeOutMax            = DL_TIMEOUT_MAX;


//////////////////////////////////////////////////////////////////////////////
//
// CLangBarItemList
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  SetDemoteLevel
//
//----------------------------------------------------------------------------

BOOL CLangBarItemList::SetDemoteLevel(REFGUID guid, LBDemoteLevel lbdl)
{
    LANGBARITEMSTATE *pItem = AddItem(guid);

    if (!pItem)
        return TRUE;

    pItem->lbdl = lbdl;

    if (!pItem->IsShown())
    {
        if (pItem->uTimerId)
        {
            if (g_pTipbarWnd)
                g_pTipbarWnd->KillTimer(pItem->uTimerId);
            pItem->uTimerId = 0;
            pItem->uTimerElapse = 0;
        }

        //
        // This Item is hidden, so we enable demoting when this is shown again.
        //
        pItem->fDisableDemoting = FALSE;
    }
   
    //
    // update registry for this item.
    //
    SaveItem(NULL, pItem);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  GetDemoteLevel
//
//----------------------------------------------------------------------------

LBDemoteLevel CLangBarItemList::GetDemoteLevel(REFGUID guid)
{
    LANGBARITEMSTATE *pItem = FindItem(guid);
    if (!pItem)
        return DL_NONE;

    return pItem->lbdl;
}

//+---------------------------------------------------------------------------
//
//  AddItem
//
//----------------------------------------------------------------------------

LANGBARITEMSTATE *CLangBarItemList::AddItem(REFGUID guid)
{
    LANGBARITEMSTATE *pItem = FindItem(guid);

    if (pItem)
        return pItem;

    pItem = _rgLBItems.Append(1);
    if (!pItem)
        return NULL;

    memset(pItem, 0, sizeof(LANGBARITEMSTATE));
    pItem->guid     = guid;
    pItem->lbdl     = DL_NONE;

    return pItem;
}

//+---------------------------------------------------------------------------
//
//  Load
//
//----------------------------------------------------------------------------

void CLangBarItemList::Load()
{
    CMyRegKey key;

    if (key.Open(HKEY_CURRENT_USER, c_szItemStateKey, KEY_READ) != S_OK)
        return;

    TCHAR szName[255];

    DWORD dwIndex = 0;
    while (key.EnumKey(dwIndex, szName, ARRAYSIZE(szName)) == S_OK)
    {
        GUID guid;
        if (StringAToCLSID(szName, &guid))
        {
            CMyRegKey keySub;
            if (keySub.Open(key, szName, KEY_READ) == S_OK)
            {
                LANGBARITEMSTATE *pItem = AddItem(guid);

                if (pItem)
                {
                    DWORD dw = 0;
                    if (keySub.QueryValue(dw, c_szDemoteLevel) == S_OK)
                        pItem->lbdl = (LBDemoteLevel)dw;

                    if (keySub.QueryValue(dw, c_szDisableDemoting) == S_OK)
                        pItem->fDisableDemoting = dw ? TRUE : FALSE;
                }
            }
        }
        dwIndex++;
    }

}

//+---------------------------------------------------------------------------
//
//  Save
//
//----------------------------------------------------------------------------

void CLangBarItemList::Save()
{
    CMyRegKey key;
    int nCnt;
    int i;

    nCnt = _rgLBItems.Count();
    if (!nCnt)
        return;

    if (key.Create(HKEY_CURRENT_USER, c_szItemStateKey) != S_OK)
        return;

    for (i = 0; i < nCnt; i++)
    {
        LANGBARITEMSTATE *pItem = _rgLBItems.GetPtr(i);
        if (pItem)
            SaveItem(&key, pItem);
    }

}

//+---------------------------------------------------------------------------
//
//  SaveItem
//
//----------------------------------------------------------------------------

void CLangBarItemList::SaveItem(CMyRegKey *pkey, LANGBARITEMSTATE *pItem)
{
    CMyRegKey keyTmp;
    CMyRegKey keySub;
    char szValueName[CLSID_STRLEN];

    if (!pkey)
    {
        if (keyTmp.Create(HKEY_CURRENT_USER, c_szItemStateKey) != S_OK)
            return;

        pkey = &keyTmp;
    }

    CLSIDToStringA(pItem->guid, szValueName);

    if ((pItem->lbdl != DL_NONE) || pItem->fDisableDemoting)
    {
        if (keySub.Create(*pkey, szValueName) == S_OK)
        {
            //
            // if it is shown, delete the key. The default is "shown".
            //
            if (pItem->lbdl == DL_NONE)
                keySub.DeleteValue(c_szDemoteLevel);
            else
                keySub.SetValue((DWORD)pItem->lbdl, c_szDemoteLevel);

            keySub.SetValue(pItem->fDisableDemoting ? 0x01 : 0x00, 
                            c_szDisableDemoting);
        }
    }
    else
    {
        pkey->RecurseDeleteKey(szValueName);
    }
}

//+---------------------------------------------------------------------------
//
//  Clear
//
//----------------------------------------------------------------------------

void CLangBarItemList::Clear()
{
    _rgLBItems.Clear();

    CMyRegKey key;

    if (key.Open(HKEY_CURRENT_USER, c_szLangBarKey, KEY_ALL_ACCESS) != S_OK)
        return;

    key.RecurseDeleteKey(c_szItemState);
}

//+---------------------------------------------------------------------------
//
//  StartDemotingTimer
//
//----------------------------------------------------------------------------

void CLangBarItemList::StartDemotingTimer(REFGUID guid, BOOL fIntentional)
{
    LANGBARITEMSTATE *pItem;

    if (!g_bIntelliSense)
        return;

    pItem = AddItem(guid);
    if (!pItem)
        return;

    if (pItem->fDisableDemoting)
        return;

    if (pItem->uTimerId)
    {
        if (fIntentional)
        {
            if (g_pTipbarWnd)
                g_pTipbarWnd->KillTimer(pItem->uTimerId);
            pItem->uTimerId = 0;
        }
        else
        {
            return;
        }
    }

    pItem->fStartedIntentionally |= fIntentional ? TRUE : FALSE;

    //
    // update Timer Elapse.
    // if this goes over TIMEOUT_MAX, this means the item is used very often.
    // Then we disable demoting so the item won't be hidden foever.
    //
    pItem->uTimerElapse += (fIntentional ? g_uTimeOutIntentional : g_uTimeOutNonIntentional);
    if (pItem->uTimerElapse >= g_uTimeOutMax)
    {
        pItem->fDisableDemoting = TRUE;
        return;
    }

    pItem->uTimerId = FindDemotingTimerId();
    if (!pItem->uTimerId)
        return;

    if (g_pTipbarWnd)
        g_pTipbarWnd->SetTimer(pItem->uTimerId, pItem->uTimerElapse);
}

//+---------------------------------------------------------------------------
//
//  FindDemotingTimerId
//
//----------------------------------------------------------------------------

UINT CLangBarItemList::FindDemotingTimerId()
{
    UINT uTimerId = TIPWND_TIMER_DEMOTEITEMFIRST;
    int nCnt = _rgLBItems.Count();
    int i;

    while (uTimerId < TIPWND_TIMER_DEMOTEITEMLAST)
    {
        BOOL fFound = FALSE;
        for (i = 0; i < nCnt; i++)
        {
            LANGBARITEMSTATE *pItem = _rgLBItems.GetPtr(i);
            if (pItem->uTimerId == uTimerId)
            {
                fFound = TRUE;
                break;
            }
        }
        if (!fFound)
        {
            break;
        }
        uTimerId++;
    }
   
    if (uTimerId >= TIPWND_TIMER_DEMOTEITEMLAST)
        uTimerId = 0;

    return uTimerId;
}

//+---------------------------------------------------------------------------
//
//  GetItemStateFromTimerId
//
//----------------------------------------------------------------------------

LANGBARITEMSTATE *CLangBarItemList::GetItemStateFromTimerId(UINT uTimerId)
{
    int nCnt = _rgLBItems.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        LANGBARITEMSTATE *pItem = _rgLBItems.GetPtr(i);
        if (pItem->uTimerId == uTimerId)
        {
            return pItem;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\maskbmp.h ===
//
// maskbmp.h
//


#ifndef MASKBMP_H
#define MASKBMP_H


#include "cmydc.h"

HICON StretchIcon(HICON hIcon, int cxNew, int cyNew);

extern HINSTANCE g_hInst;

class CMaskBitmap
{
public:
    CMaskBitmap()
    {
        _hbmp = NULL;
        _hbmpMask = NULL;
    }

    ~CMaskBitmap()
    {
       Clear();
    }

    void Clear()
    {
        if (_hbmp)
        {
            DeleteObject(_hbmp);
            _hbmp = NULL;
        }

        if (_hbmpMask)
        {
            DeleteObject(_hbmpMask);
            _hbmpMask = NULL;
        }
    }

    BOOL Init(int nId, int cx, int cy, COLORREF rgb);
    BOOL Init(HICON hIcon, int cx, int cy, COLORREF rgb);

    HBITMAP GetBmp() {return _hbmp;}
    HBITMAP GetBmpMask() {return _hbmpMask;}
    
private:
    HBITMAP _hbmp;
    HBITMAP _hbmpMask;
};

#endif // MASKBMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\itemlist.h ===
//
// itemlist.h
//

#ifndef ITEMLIST_H
#define ITEMLIST_H

#include "strary.h"
#include "cregkey.h"

typedef enum {DL_NONE, DL_SHOWN, DL_HIDDENLEVEL1, DL_HIDDENLEVEL2 } LBDemoteLevel;

typedef struct tag_LANGBARITEMSTATE {
    GUID           guid;
    LBDemoteLevel  lbdl;
    UINT           uTimerId;
    UINT           uTimerElapse;
    BOOL           fStartedIntentionally;
    BOOL           fDisableDemoting;

    BOOL IsShown()
    {
        return ((lbdl == DL_NONE) || (lbdl == DL_SHOWN)) ? TRUE : FALSE;
    }
} LANGBARITEMSTATE;

class CLangBarItemList
{
public:
    CLangBarItemList() {}
    ~CLangBarItemList() {}

    BOOL SetDemoteLevel(REFGUID guid, LBDemoteLevel lbdl);
    LBDemoteLevel GetDemoteLevel(REFGUID guid);

    void StartDemotingTimer(REFGUID guid, BOOL fIntentional);
    LANGBARITEMSTATE *GetItemStateFromTimerId(UINT uId);

    void Load();
    void Save();
    void SaveItem(CMyRegKey *pkey, LANGBARITEMSTATE *pItem);
    void Clear();

    LANGBARITEMSTATE *FindItem(REFGUID guid)
    {
        int nCnt = _rgLBItems.Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            LANGBARITEMSTATE *pItem = _rgLBItems.GetPtr(i);
            if (IsEqualGUID(pItem->guid, guid))
                return pItem;

        }
        return NULL;
    }

    BOOL IsStartedIntentionally(REFGUID guid)
    {
        LANGBARITEMSTATE *pItem = FindItem(guid);
        if (!pItem)
            return FALSE;
        return pItem->fStartedIntentionally ? TRUE : FALSE;
    }

private:
    UINT FindDemotingTimerId();

    LANGBARITEMSTATE *AddItem(REFGUID guid);
    CStructArray<LANGBARITEMSTATE> _rgLBItems;
};

#endif ITEMLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for immx project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define OEMRESOURCE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define NOIME
#include <windows.h>
#include <immp.h>

#include <ccstock.h>
#include <debug.h>
#include <olectl.h>
#include <oleacc.h>
#include <richedit.h>
#include "msctf.h"
#include "msctfp.h"
#include "helpers.h"

#include "delay.h"

#include "osver.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#include "mem.h"  // put this last because it macros "new" in DEBUG

#define SCALE_ICON 1

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\nuiinat.h ===
//
// nuiinat.h
//

#ifndef NUIINAT_H
#define NUIINAT_H

#include "private.h"
#include "nuibase.h"

extern const GUID GUID_LBI_INATITEM;

ULONG GetIconIndexFromhKL(HKL hKL);
BOOL GethKLDesc(HKL hKL, WCHAR *psz, UINT cch);

class CLBarInatItem : public CLBarItemButtonBase
{
public:
    CLBarInatItem(DWORD dwThreadId);
    ~CLBarInatItem();


    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstr);

    void SetHKL(HKL hKL) {_hKL = hKL;}

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prc);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

    HKL _hKL;
    DWORD _dwThreadId;
};


#endif // NUIINAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\maskbmp.cpp ===
//
// maskbmp.cpp
//

#include "private.h"
#include "globals.h"
#include "maskbmp.h"


extern HINSTANCE g_hInst;


//
// from CUILIB.LIB
//
extern CBitmapDC *g_phdcSrc;
extern CBitmapDC *g_phdcMask;
extern CBitmapDC *g_phdcDst;

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// StretchIcon
//
//----------------------------------------------------------------------------

HICON StretchIcon(HICON hIcon, int cxNew, int cyNew)
{
    BITMAP bmp;
    ICONINFO ii;
    HICON hIconRet = NULL;

    GetIconInfo(hIcon, &ii);
    GetObject(ii.hbmMask, sizeof(BITMAP), &bmp);

    if ((bmp.bmWidth == cxNew) && (bmp.bmHeight == cyNew))
    {
        hIconRet = (HICON)CopyImage(hIcon,  
                                IMAGE_ICON,  
                                cxNew, cyNew,
                                LR_COPYFROMRESOURCE);
        goto Exit;
    }

    g_phdcDst->SetDIB(cxNew, cyNew);
    g_phdcSrc->SetDIB(bmp.bmWidth, bmp.bmHeight);

    DrawIconEx(*g_phdcSrc, 0, 0, hIcon, bmp.bmWidth, bmp.bmHeight, 0, NULL, DI_IMAGE);
    SetStretchBltMode(*g_phdcDst, HALFTONE);
    StretchBlt(*g_phdcDst, 0, 0, cxNew, cyNew, 
               *g_phdcSrc, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);

    g_phdcSrc->Uninit();
    g_phdcSrc->SetBitmap(bmp.bmWidth, bmp.bmHeight, 1, 1);
    g_phdcMask->SetBitmap(cxNew, cyNew, 1, 1);
    DrawIconEx(*g_phdcSrc, 0, 0, hIcon, bmp.bmWidth, bmp.bmHeight, 0, NULL, DI_MASK);
    StretchBlt(*g_phdcMask, 0, 0, cxNew, cyNew, 
               *g_phdcSrc, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);


    ii.fIcon = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;

    DeleteObject(ii.hbmMask);
    DeleteObject(ii.hbmColor);

    ii.hbmMask = g_phdcMask->GetBitmapAndKeep();
    ii.hbmColor = g_phdcDst->GetBitmapAndKeep();

    g_phdcMask->Uninit();
    g_phdcDst->Uninit();
    g_phdcSrc->Uninit();

    hIconRet= CreateIconIndirect(&ii);

Exit:
    DeleteObject(ii.hbmMask);
    DeleteObject(ii.hbmColor);

    return hIconRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CMaskBitmap
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CMaskBitmap::Init(int nId, int cx, int cy, COLORREF rgb)
{
    Clear();

    CSolidBrush hbrFore(rgb);
    HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
    HBRUSH hbrWhite = (HBRUSH)GetStockObject(WHITE_BRUSH);
    RECT rc;

    g_phdcMask->SetBitmap(cx, cy, 1, 1);
    g_phdcDst->SetDIB(cx, cy);
    g_phdcSrc->SetBitmapFromRes(g_hInst, MAKEINTRESOURCE(nId));

    ::SetRect(&rc, 0, 0, cx, cy);
    FillRect(*g_phdcDst, &rc, hbrBlack);
    FillRect(*g_phdcMask, &rc, hbrWhite);

    //
    // draw caps bitmap
    //
    // src
    ::SetRect(&rc, 0, 0, cx, cy);
    FillRect(*g_phdcDst, &rc, hbrFore);
    BitBlt(*g_phdcDst, 0, 0, cx, cy,
           *g_phdcSrc, 0, 0, SRCAND);

    // mask
    BitBlt(*g_phdcMask, 0, 0, cx, cy,
           *g_phdcSrc, 0, 0, SRCINVERT);

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit(TRUE);
    g_phdcDst->Uninit(TRUE);

    _hbmp = g_phdcDst->GetBitmapAndKeep();
    _hbmpMask = g_phdcMask->GetBitmapAndKeep();

    DeleteObject(hbrBlack);
    DeleteObject(hbrWhite);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CMaskBitmap::Init(HICON hIcon, int cx, int cy, COLORREF rgb)
{
    Clear();

    CSolidBrush hbrFore(rgb);
    HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
    HBRUSH hbrWhite = (HBRUSH)GetStockObject(WHITE_BRUSH);
    RECT rc;

    g_phdcMask->SetBitmap(cx, cy, 1, 1);
    g_phdcDst->SetDIB(cx, cy);
    g_phdcSrc->SetDIB(cx, cy);

    //
    // flip mask of Icon.
    //
    DrawIconEx(*g_phdcDst, 0, 0, hIcon, cx, cy, 0, NULL, DI_MASK);
    ::SetRect(&rc, 0, 0, cx, cy);
    FillRect(*g_phdcSrc, &rc, hbrWhite);
    BitBlt(*g_phdcSrc, 0, 0, cx, cy, *g_phdcDst, 0, 0, SRCINVERT);

    //
    // draw caps bitmap
    //

    //
    // src
    //
    ::SetRect(&rc, 0, 0, cx, cy);
    FillRect(*g_phdcDst, &rc, hbrFore);
    BitBlt(*g_phdcDst, 0, 0, cx, cy, *g_phdcSrc, 0, 0, SRCAND);


    //
    // mask
    //
    ::SetRect(&rc, 0, 0, cx, cy);
    FillRect(*g_phdcMask, &rc, hbrWhite);

    BitBlt(*g_phdcMask, 0, 0, cx, cy, *g_phdcSrc, 0, 0, SRCINVERT);

    //
    // Draw white area for image.
    //
    FillRect(*g_phdcSrc, &rc, hbrBlack);
    DrawIconEx(*g_phdcSrc, 0, 0, hIcon, cx, cy, 0, NULL, DI_IMAGE);
    BitBlt(*g_phdcDst, 0, 0, cx, cy, *g_phdcSrc, 0, 0, SRCPAINT);

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit(TRUE);
    g_phdcDst->Uninit(TRUE);
    _hbmp = g_phdcDst->GetBitmapAndKeep();
    _hbmpMask = g_phdcMask->GetBitmapAndKeep();

    DeleteObject(hbrBlack);
    DeleteObject(hbrWhite);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\resource.h ===
//
// resource.h
//

#ifndef RESOURCE_H_
#define RESOURCE_H_

#define ID_ICON_CONTROLBTN    100
#define ID_ICON_INFO          101
#define ID_BITMAP_CAPS        150
#define ID_BITMAP_KANA        151
#define ID_BITMAP_CAPSV       152
#define ID_BITMAP_KANAV       153
#define ID_BITMAP_TRAYICONPOS 154
#define ID_BITMAP_DESKBANDPOS 155


//
// dialog ids
//
#define IDC_STATIC -1
#define IDD_CLOSELANGBAR                1000
#define IDD_CLOSELANGBAR51              1001
#define IDC_DONTSHOWAGAIN               1002
#define IDD_MINIMIZELANGBAR             1003
#define IDD_MINIMIZELANGBAR51           1004

//
// menu ids
//
#define IDM_CLOSECICLOAD                 201
#define IDM_OPAQUE                       202
#define IDM_LOWTRANSPARENCY              203
#define IDM_HIGHTRANSPARENCY             204
#define IDM_SHOWTEXT                     205
#define IDM_BREAK                        206
#define IDM_RESTOREDEFAULTS              207
#define IDM_TRANSPARENCYON               208
#define IDM_TRANSPARENCYOFF              209
#define IDM_SHOWLABEL                    210
#define IDM_HIDELABEL                    211
#define IDM_MINIMIZE                     212
#define IDM_CLOSE                        213
#define IDM_NOTIFICATIONICONS            214
#define IDM_NONOTIFICATIONICONS          215
#define IDM_RESTORE                      216
#define IDM_VERTICAL                     217
#define IDM_LANGBAND                     218
#define IDM_ADJUSTLANGBAND               219

#define IDM_ADDREMOVESTART    1000
#define IDM_SHOWINPUTCPL      2000   // this must be big enough than IDM_ADDREMOVESTART

#define IDM_SHOWLANGBARONCMD             2000

//
// string ids
//
#define IDS_SHOWINPUTCPL            300
#define IDS_OPAQUE                  301
#define IDS_LOWTRANSPARENCY         302
#define IDS_HIGHTRANSPARENCY        303
#define IDS_SHOWTEXT                304
#define IDS_HIDETEXT                305
#define IDS_BREAK                   306
#define IDS_CANCEL                  307
#define IDS_CONTROLBTN              308
#define IDS_NUI_LANGUAGE_TEXT       309
#define IDS_NUI_LANGUAGE_TOOLTIP    310
#define IDS_RESTOREDEFAULTS         311
#define IDS_TRANSPARENCY            312
#define IDS_TEXTLABEL               313
#define IDS_MINIMIZE                314
#define IDS_CLOSE                   315
#define IDS_MINIMIZEDBALLOONTEXT    316
#define IDS_OVERSCREENSIZE          317
#define IDS_NOTIFICATIONICONS       318
#define IDS_NOMOREITEM              319
#define IDS_LANGBAR                 320
#define IDS_RESTORE                 321
#define IDS_MENUWINDOW              322
#define IDS_LEFTCLICK               323
#define IDS_VERTICAL                324
#define IDS_LANGBAND                325
#define IDS_ADJUSTLANGBAND          326
#define IDS_LANGBANDMENUTEXTPUI     327

#define IDS_CONTROLBUTTONTOOLTIP    1000
#define IDS_CBTN_MINIMIZE           1100 
#define IDS_CBTN_EXTMENU            1101
#define IDS_CBTN_KANAKEY            1102
#define IDS_CBTN_CAPSKEY            1103
#define IDS_CBTN_RESTORE            1104

#endif // RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\shellwnd.h ===
//
// shellwnd.h
//

#ifndef _SHELLWND_H_
#define _SHELLWND_H_

#include <shlapip.h>

class CShellWndThread
{
public:
    CShellWndThread()
    {
        Clear();
    }

    void Clear()
    {
        _hwndTray = NULL;
        _hwndProgman = NULL;
#ifdef LAYTER
        _dwThreadIdTray = 0;
        _dwThreadIdProgman = 0;
#endif
    }

    HWND GetWndTray()
    {
        if (!_hwndTray || !IsWindow(_hwndTray))
            _hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

        return _hwndTray;
    }

    HWND GetWndProgman()
    {
        if (!_hwndProgman || !IsWindow(_hwndProgman))
            _hwndProgman = FindWindow("Progman", NULL);

        return _hwndProgman;
    }

#ifdef LAYTER
    DWORD GetWndTrayThread()
    {
        if (!GetWndTray())
            _dwThreadIdTray = 0;
        else if (!_dwThreadIdTray)
            _dwThreadIdTray = GetWindowThreadProcessId(_hwndTray, NULL);

        return _dwThreadIdTray;
    }


    DWORD GetWndProgmanThread()
    {
        if (!GetWndProgman())
            _dwThreadIdProgman = 0;
        else if (!_dwThreadIdProgman)
            _dwThreadIdProgman = GetWindowThreadProcessId(_hwndProgman, NULL);

        return _dwThreadIdProgman;
    }
#endif

private:
    HWND  _hwndTray;
    HWND  _hwndProgman;
#ifdef LAYTER
    DWORD _dwThreadIdTray;
    DWORD _dwThreadIdProgman;
#endif
};

#endif _SHELLWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\nuiinat.cpp ===
//
// nuiinat.cpp
//

#include "private.h"
#include "globals.h"
#include "nuiinat.h"
#include "tipbar.h"
#include "resource.h"
#include "inatlib.h"
#include "cresstr.h"

extern HINSTANCE g_hInst;
extern CTipbarWnd *g_pTipbarWnd;


const GUID GUID_LBI_INATITEM = { /* cdbc683a-55ce-4717-bac0-50bf44a3270c */
    0xcdbc683a,
    0x55ce,
    0x4717,
    {0xba, 0xc0, 0x50, 0xbf, 0x44, 0xa3, 0x27, 0x0c}
  };


//+---------------------------------------------------------------------------
//
// GetIconIndexFromhKL
//
//----------------------------------------------------------------------------

ULONG GetIconIndexFromhKL(HKL hKL)
{
    BOOL       bFound;
    int nCnt = TF_MlngInfoCount();
    HKL hKLTmp;
    int i;

    bFound = FALSE;
    for (i = 0; i < nCnt; i++)
    {
        if (!TF_GetMlngHKL(i, &hKLTmp, NULL, 0))
           continue;

        if (hKL == hKLTmp)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        i = 0;
        if (!TF_GetMlngHKL(0, &hKL, NULL, 0))
            return -1;
    }

    return TF_GetMlngIconIndex(i);
}

//+---------------------------------------------------------------------------
//
// GethKLDesc
//
//----------------------------------------------------------------------------

BOOL GethKLDesc(HKL hKL, WCHAR *psz, UINT cch)
{
    BOOL       bFound;
    int nCnt = TF_MlngInfoCount();
    HKL hKLTmp;
    int i;

    bFound = FALSE;
    for (i = 0; i < nCnt; i++)
    {
        if (!TF_GetMlngHKL(i, &hKLTmp, psz, cch))
           continue;

        if (hKL == hKLTmp)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        i = 0;
        if (TF_GetMlngHKL(0, &hKL, psz, cch))
            return TRUE;
    }

    return bFound ? TRUE : FALSE;
}

//---------------------------------------------------------------------------
//
// GetFontSig()
//
//---------------------------------------------------------------------------

BOOL GetFontSig(HWND hwnd, HKL hKL)
{
    LOCALESIGNATURE ls;
    BOOL bFontSig = 0;

    //
    // 4th param is TCHAR count but we call GetLocaleInfoA()
    //                                                   ~
    // so we pass "sizeof(LOCALESIGNATURE) / sizeof(char)".
    //
    if( GetLocaleInfoA( (DWORD)(LOWORD(hKL)), 
                        LOCALE_FONTSIGNATURE, 
                        (LPSTR)&ls, 
                        sizeof(LOCALESIGNATURE) / sizeof(char)))
    {
        CHARSETINFO cs;
        HDC hdc = GetDC(hwnd);
        TranslateCharsetInfo((LPDWORD)UIntToPtr(GetTextCharsetInfo(hdc,NULL,0)), 
                             &cs, TCI_SRCCHARSET);
        DWORD fsShell = cs.fs.fsCsb[0];
        ReleaseDC(hwnd, hdc);
        if (fsShell & ls.lsCsbSupported[0])
            bFontSig = 1;
    }
    return bFontSig;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarInatItem::CLBarInatItem(DWORD dwThreadId)
{
    Dbg_MemSetThisName(TEXT("CLBarInatItem"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM,  
                GUID_LBI_INATITEM, 
                TF_LBI_STYLE_BTN_MENU | TF_LBI_STYLE_HIDDENSTATUSCONTROL, 
                0,
                CRStr(IDS_NUI_LANGUAGE_TEXT));

    SetToolTip(CRStr(IDS_NUI_LANGUAGE_TOOLTIP));

    _dwThreadId = dwThreadId;
    _hKL = GetKeyboardLayout(dwThreadId);

    TF_InitMlngInfo();
    int nLang = TF_MlngInfoCount();
    ShowInternal((nLang > 1), FALSE);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarInatItem::~CLBarInatItem()
{
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarInatItem::GetIcon(HICON *phIcon)
{
    ULONG uIconIndex;
    HICON hIcon = NULL;

    uIconIndex = GetIconIndexFromhKL(_hKL);
    if (uIconIndex != -1)
        hIcon = TF_InatExtractIcon(uIconIndex);

    *phIcon = hIcon;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLBarInatItem::GetText(BSTR *pbstr)
{
    WCHAR szText[NUIBASE_TEXT_MAX];
    if (!pbstr)
        return E_INVALIDARG;

    if (GethKLDesc(_hKL, szText, ARRAYSIZE(szText)))
    {
        *pbstr = SysAllocString(szText);
        return S_OK;
    }

    return CLBarItemButtonBase::GetText(pbstr);
}
//+---------------------------------------------------------------------------
//
// OnLButtonUpHandler
//
//----------------------------------------------------------------------------

HRESULT CLBarInatItem::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarInatItem::InitMenu(ITfMenu *pMenu)
{
    int nLang;
    int i;
    HKL hkl;
    WCHAR szDesc[128];

    TF_InitMlngInfo();
    nLang = TF_MlngInfoCount();

    for (i = 0; i < nLang; i++)
    {
        if (TF_GetMlngHKL(i, &hkl, szDesc, ARRAYSIZE(szDesc)))
        {
            ULONG uIconIndex;
            HICON hIcon = NULL;

            uIconIndex = GetIconIndexFromhKL(hkl);
            if (uIconIndex != -1)
                hIcon = TF_InatExtractIcon(uIconIndex);

            LangBarInsertMenu(pMenu, 
                              i, 
                              szDesc,
                              hkl == _hKL ? TRUE : FALSE,
                              hIcon);
        }
    }

    if (g_pTipbarWnd && g_pTipbarWnd->GetLangBarMgr())
    {
        DWORD dwFlags;
        if (SUCCEEDED(g_pTipbarWnd->GetLangBarMgr()->GetShowFloatingStatus(&dwFlags)))
        {
            if (dwFlags & (TF_SFT_MINIMIZED | TF_SFT_DESKBAND))
            {
                LangBarInsertSeparator(pMenu);
                LangBarInsertMenu(pMenu, IDM_SHOWLANGBARONCMD, CRStr(IDS_RESTORE));
            }
        }
    }
    return S_OK;
}
 
//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarInatItem::OnMenuSelect(UINT uID)
{
    HKL hkl;
    if (uID == IDM_SHOWLANGBARONCMD)
    {
        if (g_pTipbarWnd && g_pTipbarWnd->GetLangBarMgr())
            g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);
    }
    else if (TF_GetMlngHKL(uID, &hkl, NULL, 0))
    {
        Assert(g_pTipbarWnd);
        if (!g_pTipbarWnd->IsInDeskBand())
            g_pTipbarWnd->RestoreLastFocus(NULL, FALSE);
        else
            g_pTipbarWnd->RestoreLastFocus(NULL, TRUE);

        HWND hwndFore = GetForegroundWindow();
        if (_dwThreadId == GetWindowThreadProcessId(hwndFore, NULL))
        {
            BOOL bFontSig = GetFontSig(hwndFore, hkl);
            PostMessage(hwndFore, 
                        WM_INPUTLANGCHANGEREQUEST, 
                        (WPARAM)bFontSig, 
                        (LPARAM)hkl);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbacc.h ===
//
// utbdacc.h
//  = accessibility support in language bar
//

#ifndef UTBACC_H
#define UTBACC_H

#include "ptrary.h"

class CTipbarAccessible;

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////
extern void InitTipbarAcc( void );
extern void DoneTipbarAcc( void );

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarAccItem
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarAccItem 
{
public:
    CTipbarAccItem( void ) {}
    virtual ~CTipbarAccItem( void ) {}

    virtual BSTR GetAccName( void )  {return SysAllocString( L"" );}
    virtual BSTR GetAccValue( void ) {return NULL;}
    virtual LONG GetAccRole( void )  {return ROLE_SYSTEM_CLIENT;}
    virtual LONG GetAccState( void ) {return STATE_SYSTEM_DEFAULT;}
    virtual void GetAccLocation( RECT *prc ) {SetRect( prc, 0, 0, 0, 0 );}
    virtual BSTR GetAccDefaultAction( void ) {return NULL;}
    virtual BOOL DoAccDefaultAction( void ) {return FALSE;}
    virtual BOOL DoAccDefaultActionReal( void ) {return FALSE;}
};


//////////////////////////////////////////////////////////////////////////////
//
// CTipbarAccessible 
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarAccessible : public IAccessible
{
public:
    CTipbarAccessible( CTipbarAccItem *pAccItemSelf );
    virtual ~CTipbarAccessible( void );

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface( REFIID riid, void** ppv );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );

    //
    // IDispatch methods
    //
    STDMETHODIMP GetTypeInfoCount( UINT* pctinfo );
    STDMETHODIMP GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** pptinfo );
    STDMETHODIMP GetIDsOfNames( REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid );
    STDMETHODIMP Invoke( DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr );

    //
    // IAccessible methods
    //
    STDMETHODIMP get_accParent( IDispatch ** ppdispParent );
    STDMETHODIMP get_accChildCount( long* pChildCount );
    STDMETHODIMP get_accChild( VARIANT varChild, IDispatch ** ppdispChild );
    STDMETHODIMP get_accName( VARIANT varChild, BSTR* pszName );
    STDMETHODIMP get_accValue( VARIANT varChild, BSTR* pszValue );
    STDMETHODIMP get_accDescription( VARIANT varChild, BSTR* pszDescription );
    STDMETHODIMP get_accRole( VARIANT varChild, VARIANT *pvarRole );
    STDMETHODIMP get_accState( VARIANT varChild, VARIANT *pvarState );
    STDMETHODIMP get_accHelp( VARIANT varChild, BSTR* pszHelp );
    STDMETHODIMP get_accHelpTopic( BSTR* pszHelpFile, VARIANT varChild, long* pidTopic );
    STDMETHODIMP get_accKeyboardShortcut( VARIANT varChild, BSTR* pszKeyboardShortcut );
    STDMETHODIMP get_accFocus( VARIANT * pvarFocusChild );
    STDMETHODIMP get_accSelection( VARIANT * pvarSelectedChildren );
    STDMETHODIMP get_accDefaultAction( VARIANT varChild, BSTR* pszDefaultAction );
    STDMETHODIMP accSelect( long flagsSel, VARIANT varChild );
    STDMETHODIMP accLocation( long* pxLt, long* pyTp, long* pcxWd, long* pcyHt, VARIANT varChild );
    STDMETHODIMP accNavigate( long navDir, VARIANT varStart, VARIANT * pVarEndUpAt );
    STDMETHODIMP accHitTest( long xLeft, long yTop, VARIANT * pvarChildAtPoint );
    STDMETHODIMP accDoDefaultAction( VARIANT varChild );
    STDMETHODIMP put_accName( VARIANT varChild, BSTR szName );
    STDMETHODIMP put_accValue( VARIANT varChild, BSTR pszValue );

    //
    //
    //
    void SetWindow( HWND hWnd );
    HRESULT Initialize( void );
    int GetIDOfItem( CTipbarAccItem *pAccItem );
    void NotifyWinEvent( DWORD dwEvent, CTipbarAccItem *pAccItem );
    
    LRESULT CreateRefToAccObj( WPARAM wParam );

    //
    //
    //

    void ClearAccItems( void );
    BOOL AddAccItem( CTipbarAccItem *pAccItem );
    BOOL RemoveAccItem( CTipbarAccItem *pAccItem );
    BOOL DoDefaultActionReal(int nItemId);

    //
    //
    //
    __inline BOOL IsInitialized( void )
    {
        return _fInitialized;
    }

protected:
    LONG            _cRef;
    HWND            _hWnd;
    IAccessible     *_pDefAccClient;
    ITypeInfo        *_pTypeInfo;

    BOOL            _fInitialized;
    CPtrArray<CTipbarAccItem> _rgAccItems;

    LONG            _lSelection;

    CTipbarAccItem    *AccItemFromID( int iID );
};



#endif /* UTBACC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbacc.cpp ===
//
//
//

#include "private.h"
#include "globals.h"
#include "utbacc.h"

//
//
//

typedef void  (*LPFNNOTIFYWINEVENT)( DWORD, HWND, LONG, LONG );
static LPFNNOTIFYWINEVENT g_lpfnNotifyWinEvent = NULL;


//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// InitTipbarAcc
//
//----------------------------------------------------------------------------

void InitTipbarAcc( void )
{
    HMODULE hLibUser32   = NULL;

    if (g_lpfnNotifyWinEvent)
        return;

    //
    // load libs
    //
    hLibUser32 = GetSystemModuleHandle( "user32.dll" );

    if (!hLibUser32) 
        return;

    //
    // get proc address
    //
    g_lpfnNotifyWinEvent = (LPFNNOTIFYWINEVENT)GetProcAddress( hLibUser32, "NotifyWinEvent" );

}

//----------------------------------------------------------------------------
//
// OurNotifyWinEvent
//
//----------------------------------------------------------------------------

static __inline void OurNotifyWinEvent( DWORD event, HWND hWnd, LONG idObject, LONG idChild )
{
    if (g_lpfnNotifyWinEvent)
    {
        g_lpfnNotifyWinEvent( event, hWnd, idObject, idChild );
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarAccessible
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarAccessible::CTipbarAccessible( CTipbarAccItem *pAccItemSelf )
{
    CTipbarAccItem **ppItem;
    _cRef = 1;
    _hWnd = NULL;
    _pTypeInfo = NULL;
    _pDefAccClient = NULL;

    _fInitialized = FALSE;
    _lSelection = 1;

    // register itself

    ppItem = _rgAccItems.Append(1);
    if (ppItem)
       *ppItem = pAccItemSelf;

    //
    // thread safe? yes.
    // this object is created on only thread with CTipbarWnd..
    //
    g_DllRefCount++;
}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarAccessible::~CTipbarAccessible( void )
{
    SafeReleaseClear( _pTypeInfo );
    SafeReleaseClear( _pDefAccClient );

    //
    // thread safe? yes.
    // this object is created on only thread with CTipbarWnd..
    //
    g_DllRefCount--;
}

//----------------------------------------------------------------------------
//
// SetWindow
//
//----------------------------------------------------------------------------

void CTipbarAccessible::SetWindow( HWND hWnd )
{
    _hWnd = hWnd;
}



//-----------------------------------------------------------------------
//
//    Initialize()
//
//    DESCRIPTION:
//
//        Initializes the state of the CTipbarAccessible object, performing
//        tasks that might normally be done in a class constructor but
//        are done here to trap any errors.
//
//    PARAMETERS:
//
//        hWnd            Handle to the HWND object with which this
//                          Accessible object is associated.  This
//                          is the handle to our main window.
//
//        hInst            Instance handle for this instance of the
//                          application.
//
//    RETURNS:
//
//        HRESULT            NOERROR if the CTipbarAccessible object is
//                          initialized successfully, a COM error
//                          code otherwise.
//
//    NOTES:
//
//        It is assumed that this method will be called for the object
//        immediately after and only after the object is constructed.
//
// ----------------------------------------------------------------------

HRESULT CTipbarAccessible::Initialize( void )
{
    HRESULT  hr;
    ITypeLib *piTypeLib;

    _fInitialized = TRUE;

    //
    //    For our client window, create a system provided
    //      Accessible object which implements the default
    //      client window Accessibility behavior.
    //
    //    Our implementation of CTipbarAccessible will use the
    //      default object's implementation as needed.  In
    //      essence, CTipbarAccessible "inherits" its functionality
    //      from the standard object, "customizing" or
    //      "overriding" various methods for which the
    //      standard implementation is insufficent for the
    //      specifics of the window for which CTipbarAccessible
    //      provides Accessibility.
    //

    hr = CreateStdAccessibleObject( _hWnd,
                                    OBJID_CLIENT,
                                    IID_IAccessible,
                                    (void **) &_pDefAccClient );
    if (FAILED(hr)) 
    {
        return hr;
    }

    //
    //    Obtain an ITypeInfo pointer to our type library.
    //      The ITypeInfo pointer is used to implement the
    //      IDispatch interface.
    //

    //
    //    First, attempt to load the Accessibility type
    //      library version 1.0 using the registry.
    //

    hr = LoadRegTypeLib( LIBID_Accessibility, 1, 0, 0, &piTypeLib );

    //
    //    If we fail to load the type library from the
    //      registry information, explicitly try to load
    //      it from the MSAA system DLL.
    //

    if (FAILED(hr)) 
    {
        static OLECHAR s_szOleAcc[] = L"OLEACC.DLL";
        hr = LoadTypeLib( s_szOleAcc, &piTypeLib );
    }

    //
    //    If we successfully load the type library, attempt
    //      to get the IAccessible type description
    //      (ITypeInfo pointer) from the type library.
    //

    if (SUCCEEDED(hr)) 
    {
        hr = piTypeLib->GetTypeInfoOfGuid( IID_IAccessible, &_pTypeInfo );
        piTypeLib->Release();
    }

    return hr;
}


//-----------------------------------------------------------------------
//
//    QueryInterface()
//
//    DESCRIPTION:
//
//        Implements the IUnknown interface method QueryInterface().
//
//    PARAMETERS:
//
//        riid            [in]  The requested interface's IID.
//        ppv                [out] If the requested interface is supported,
//                              ppv points to the location of a pointer
//                              to the requested interface.  If the
//                              requested interface is not supported,
//                              ppv is set to NULL.
//
//    RETURNS:
//
//        HRESULT            S_OK if the interface is supported,
//                          E_NOINTERFACE if the interface is not
//                          supported, or some other COM error
//                          if the IEnumVARIANT interface is requested
//                          but cannot be delivered.
//
//    NOTES:
//
//        CTipbarAccessible correctly supports the IUnknown, IDispatch and
//        IAccessible interfaces.  CTipbarAccessible also incorrectly supports
//        the IEnumVARIANT interface (to return a VARIANT enumerator
//        containing all its children).  When the IEnumVARIANT
//        interface is requested, an enumerator is created and a
//        pointer to its IEnumVARIANT interface is returned.
//
//        The support for IEnumVARIANT is incorrect because the
//        interface pointer returned is not symmetric with respect
//        to the interface from which it was obtained.  For example,
//        assume that pIA is a pointer to an IAccessible interface.
//        Then, even though pIA->QueryInterface(IID_IEnumVARIANT)
//        succeeds and returns pIEV,
//        pIEV->QueryInterface(IID_Accessibility) will fail because
//        the enumerator has no knowledge of any interface except
//        itself (and IUnknown).
//
//        The original design of MSAA called for IAccessible
//        objects to also be enumerators of their children.  But
//        this design doesn't allow for different clients of the
//        Accessible object to have different enumerations of its
//        children and that is a potentially hazardous situation.
//        (Assume there is an Accessible object that is also a
//        VARIANT enumerator, A, and two clients, C1 and C2.
//        Since C1 and C2 each may be pre-empted will using A,
//        the following is a one of many examples that would pose
//        a problem for at least one client:
//
//            C1:  A->Reset()
//            C1:  A->Skip( 5 )
//            C2:  A->Reset()
//            C1:  A->Next()  ! C1 does not get the child it expects
//
//        So, although it breaks the rules of COM, QueryInterface()
//        as implemented below obtains a distinct VARIANT enumerator
//        for each request.  A better solution to this issue would
//        be if the IAccessible interface provided a method to get
//        the child enumeration or if MSAA provided an exported API
//        to perform this task.
//
// ----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;

    //
    //    If the IUnknown, IDispatch, or IAccessible
    //      interface is desired, simply cast the this
    //      pointer appropriately.
    //

    if ( riid == IID_IUnknown ) 
    {
        *ppv = (LPUNKNOWN) this;
    } 
    else if ( riid == IID_IDispatch ) 
    {
        *ppv = (IDispatch *) this;
    }
    else if ( riid == IID_IAccessible ) 
    {
        *ppv = (IAccessible *)this;
    }

#ifdef NEVER
    //
    //    If the IEnumVARIANT interface is desired, create
    //      a new VARIANT enumerator which contains all
    //      the Accessible object's children.
    //

    else if (riid == IID_IEnumVARIANT)
    {
        CEnumVariant*    pcenum;
        HRESULT            hr;

        hr = CreateVarEnumOfAllChildren( &pcenum );

        if ( FAILED( hr ) )
            return hr;

        *ppv = (IEnumVARIANT *) pcenum;
    }
#endif /* NEVER */

    //
    //    If the desired interface isn't one we know about,
    //      return E_NOINTERFACE.
    //

    else 
    {
        return E_NOINTERFACE;
    }

    //
    //    Increase the reference count of any interface
    //      returned.
    //

    ((LPUNKNOWN) *ppv)->AddRef();
    return S_OK;
}



//-----------------------------------------------------------------------
//
//    AddRef()
//
//    DESCRIPTION:
//
//        Implements the IUnknown interface method AddRef().
//
//    PARAMETERS:
//
//        None.
//
//    RETURNS:
//
//        ULONG            Current reference count.
//
//    NOTES:
//
//        The lifetime of the Accessible object is governed by the
//        lifetime of the HWND object for which it provides
//        Accessibility.  The object is created in response to the
//        first WM_GETOBJECT message that the server application
//        is ready to process and is destroyed when the server's
//        main window is destroyed.  Since the object's lifetime
//        is not dependent on a reference count, the object has no
//        internal mechanism for tracking reference counting and
//        AddRef() and Release() always return one.
//
//-----------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTipbarAccessible::AddRef( void )
{
    return InterlockedIncrement( &_cRef );
}


//-----------------------------------------------------------------------
//
//    Release()
//
//    DESCRIPTION:
//
//        Implements the IUnknown interface method Release().
//
//    PARAMETERS:
//
//        None.
//
//    RETURNS:
//
//        ULONG            Current reference count.
//
//    NOTES:
//
//        The lifetime of the Accessible object is governed by the
//        lifetime of the HWND object for which it provides
//        Accessibility.  The object is created in response to the
//        first WM_GETOBJECT message that the server application
//        is ready to process and is destroyed when the server's
//        main window is destroyed.  Since the object's lifetime
//        is not dependent on a reference count, the object has no
//        internal mechanism for tracking reference counting and
//        AddRef() and Release() always return one.
//
//-----------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTipbarAccessible::Release( void )
{
    ULONG l = InterlockedDecrement( &_cRef );
    if (0 < l) 
        return l;

    delete this;
    return 0;    
}


//-----------------------------------------------------------------------
//
//    GetTypeInfoCount()
//
//    DESCRIPTION:
//
//        Implements the IDispatch interface method GetTypeInfoCount().
//
//        Retrieves the number of type information interfaces that an
//        object provides (either 0 or 1).
//
//    PARAMETERS:
//
//        pctInfo        [out] Points to location that receives the
//                            number of type information interfaces
//                            that the object provides. If the object
//                            provides type information, this number
//                            is set to 1; otherwise it's set to 0.
//
//    RETURNS:
//
//        HRESULT              S_OK if the function succeeds or 
//                            E_INVALIDARG if pctInfo is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::GetTypeInfoCount( UINT *pctInfo )
{
    if (!pctInfo)
        return E_INVALIDARG;

    *pctInfo = (_pTypeInfo == NULL ? 1 : 0);
    return S_OK;
}



//-----------------------------------------------------------------------
//
//    GetTypeInfo()
//
//    DESCRIPTION:
//
//        Implements the IDispatch interface method GetTypeInfo().
//
//        Retrieves a type information object, which can be used to
//        get the type information for an interface.
//
//    PARAMETERS:
//
//        itinfo        [in]  The type information to return. If this value
//                            is 0, the type information for the IDispatch
//                            implementation is to be retrieved.
//
//        lcid        [in]  The locale ID for the type information.
//
//        ppITypeInfo    [out] Receives a pointer to the type information
//                            object requested.
//
//    RETURNS:
//
//        HRESULT              S_OK if the function succeeded (the TypeInfo
//                            element exists), TYPE_E_ELEMENTNOTFOUND if
//                            itinfo is not equal to zero, or 
//                            E_INVALIDARG if ppITypeInfo is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo )
{
    if (!ppITypeInfo) 
        return E_INVALIDARG;

    *ppITypeInfo = NULL;

    if (itinfo != 0) 
        return TYPE_E_ELEMENTNOTFOUND;
    else if (_pTypeInfo == NULL) 
        return E_NOTIMPL;

    *ppITypeInfo = _pTypeInfo;
    _pTypeInfo->AddRef();

    return S_OK;
}


//-----------------------------------------------------------------------
//
//    GetIDsOfNames()
//
//    DESCRIPTION:
//
//        Implements the IDispatch interface method GetIDsOfNames().
//
//        Maps a single member and an optional set of argument names
//        to a corresponding set of integer DISPIDs, which may be used
//        on subsequent calls to IDispatch::Invoke.
//
//    PARAMETERS:
//
//        riid        [in]  Reserved for future use. Must be NULL.
//
//        rgszNames    [in]  Passed-in array of names to be mapped.
//
//        cNames        [in]  Count of the names to be mapped.
//
//        lcid        [in]  The locale context in which to interpret
//                            the names.
//
//        rgdispid    [out] Caller-allocated array, each element of
//                            which contains an ID corresponding to
//                            one of the names passed in the rgszNames
//                            array.  The first element represents the
//                            member name; the subsequent elements
//                            represent each of the member's parameters.
//
//    RETURNS:
//
//        HRESULT              S_OK if the function succeeded,
//                            E_OUTOFMEMORY if there is not enough
//                            memory to complete the call,
//                            DISP_E_UNKNOWNNAME if one or more of
//                            the names were not known, or
//                            DISP_E_UNKNOWNLCID if the LCID was
//                            not recognized.
//
//    NOTES:
//
//        This method simply delegates the call to
//        ITypeInfo::GetIDsOfNames().
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::GetIDsOfNames( REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid )
{
    if (_pTypeInfo == NULL) 
        return E_NOTIMPL;

    return _pTypeInfo->GetIDsOfNames( rgszNames, cNames, rgdispid );
}


//-----------------------------------------------------------------------
//
//    Invoke()
//
//    DESCRIPTION:
//
//        Implements the IDispatch interface method Invoke().
//
//        Provides access to properties and methods exposed by the
//        Accessible object.
//
//    PARAMETERS:
//
//        dispidMember    [in]  Identifies the dispatch member.
//
//        riid            [in]  Reserved for future use. Must be NULL.
//
//        lcid            [in]  The locale context in which to interpret
//                                the names.
//
//        wFlags            [in]  Flags describing the context of the
//                                    Invoke call.
//
//        pdispparams        [in,] Pointer to a structure containing an
//                        [out]    array of arguments, array of argument
//                                dispatch IDs for named arguments, and
//                                counts for number of elements in the
//                                arrays.
//
//        pvarResult        [in,] Pointer to where the result is to be
//                        [out]    stored, or NULL if the caller expects
//                                no result.  This argument is ignored
//                                if DISPATCH_PROPERTYPUT or
//                                DISPATCH_PROPERTYPUTREF is specified.
//
//        pexcepinfo        [out] Pointer to a structure containing
//                                exception information.  This structure
//                                should be filled in if DISP_E_EXCEPTION
//                                is returned.
//
//        puArgErr        [out] The index within rgvarg of the first
//                                argument that has an error.  Arguments
//                                are stored in pdispparams->rgvarg in
//                                reverse order, so the first argument
//                                is the one with the highest index in
//                                the array.
//
//    RETURNS:
//
//        HRESULT              S_OK on success, dispatch error (DISP_E_*)
//                            or E_NOTIMPL otherwise.
//
//    NOTES:
//
//        This method simply delegates the call to ITypeInfo::Invoke().
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::Invoke( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
{
    if (_pTypeInfo == NULL) 
        return E_NOTIMPL;

    return _pTypeInfo->Invoke( (IAccessible *)this,
                                dispid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                puArgErr );
}


//-----------------------------------------------------------------------
//
//    get_accParent()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accParent().
//
//        Retrieves the IDispatch interface of the current object's
//        parent.
//
//    PARAMETERS:
//
//        ppdispParent    [out] Pointer to the variable that will
//                                contain a pointer to the IDispatch
//                                interface of CTipbarAccessible's parent.
//
//    RETURNS:
//
//        HRESULT            The value returned by the standard object's
//                          implementation of get_accParent().
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accParent( IDispatch ** ppdispParent )
{
    //
    // Use the default client window implementation to obtain the parent
    // of our Accessible object.
    //
    return _pDefAccClient->get_accParent( ppdispParent );
}


//-----------------------------------------------------------------------
//
//    get_accChildCount()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accChildCount().
//
//        Retrieves the number of children belonging to CTipbarAccessible.
//
//    PARAMETERS:
//
//        pChildCount        [out] Pointer to the variable that will
//                                be filled with the number of children
//                                belonging to the CTipbarAccessible object.
//
//    RETURNS:
//
//        HRESULT            S_OK on success, E_INVALIDARG if pChildCount
//                          is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accChildCount( long* pChildCount )
{
    if (!pChildCount) 
        return E_INVALIDARG;

    if (!_rgAccItems.Count())
    {
        Assert(0);
        return E_FAIL;
    }

    *pChildCount = (_rgAccItems.Count() - 1);
    return S_OK;
}


//-----------------------------------------------------------------------
//    get_accChild()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accChild().
//
//        Retrieve an IDispatch interface pointer to the child object
//        that has the given child ID or name.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        ppdispChild        [out] Pointer to the variable that will
//                                contain a pointer to the IDispatch
//                                interface of specified child object
//                                of CTipbarAccessible.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if ppdispChild is invalid, S_FALSE
//                          otherwise because none of CTipbarAccessible's
//                          children are objects.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    if (!ppdispChild) 
        return E_INVALIDARG;

    //
    //    None of the children of CTipbarAccessible are objects,
    //      so none have IDispatch pointers.  Thus, in all
    //      cases, set the IDispatch pointer to NULL and
    //      return S_FALSE.
    //

    *ppdispChild = NULL;
    return S_FALSE;
}


//-----------------------------------------------------------------------
//    get_accName()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accName().
//
//        Retrieve the name property for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pszName            [out] Pointer to the BSTR that will contain
//                                the child's name property string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid
//                          or the return value from the private method
//                          HrLoadString().
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accName( VARIANT varChild, BSTR *pbstrName )
{
    CTipbarAccItem *pAccItem;

    if (pbstrName == NULL) {
        return E_INVALIDARG;
    }

    // get acc item

    pAccItem = AccItemFromID( (int)varChild.lVal );
    if (pAccItem == NULL) {
        return E_INVALIDARG;
    }

    // get name of acc item

    *pbstrName = pAccItem->GetAccName();
    return (*pbstrName != NULL) ? S_OK : DISP_E_MEMBERNOTFOUND;
}


//-----------------------------------------------------------------------
//    get_accValue()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accValue().
//
//        Retrieves the value property for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pszValue        [out] Pointer to the BSTR that will contain
//                                the child's value property string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid,
//                          DISP_E_MEMBERNOTFOUND if VarChild refers
//                          to any child other than the status bar,
//                          or S_OK.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accValue( VARIANT varChild, BSTR *pbstrValue )
{
    CTipbarAccItem *pAccItem;

    if (pbstrValue == NULL) 
        return E_INVALIDARG;

    // get acc item

    pAccItem = AccItemFromID( (int)varChild.lVal );
    if (pAccItem == NULL)
        return E_INVALIDARG;

    // get value of acc item

    *pbstrValue = pAccItem->GetAccValue();
    return (*pbstrValue != NULL) ? S_OK : DISP_E_MEMBERNOTFOUND;
}


//-----------------------------------------------------------------------
//    get_accDescription()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accDescription().
//
//        Retrieves the description property for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pszDesc            [out] Pointer to the BSTR that will contain
//                                the child's description property string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid
//                          or the return value from either the
//                          standard client window implementation of
//                          get_accDescription() or the private method
//                          HrLoadString().
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accDescription( VARIANT varChild, BSTR *pbstrDesc )
{
    if (pbstrDesc == NULL) 
        return E_INVALIDARG;

    return _pDefAccClient->get_accDescription( varChild, pbstrDesc );
}


//-----------------------------------------------------------------------
//    get_accRole()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accRole().
//
//        Retrieves the role property for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pVarRole        [out] Pointer to the VARIANT structure that
//                                will contain the specified child's
//                                role property.  This property may
//                                either be in the form of a standard
//                                role constant or a custom description
//                                string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid,
//                          S_OK if the specified child is the button
//                          or status bar, or the return value from
//                          either the standard client window implementation
//                          of get_accRole() or the private method
//                          HrLoadString().
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accRole( VARIANT varChild, VARIANT *pVarRole )
{
    CTipbarAccItem *pAccItem;

    if (pVarRole == NULL) 
        return E_INVALIDARG;

    // get acc item

    pAccItem = AccItemFromID( (int)varChild.lVal );
    if (pAccItem == NULL)
        return E_INVALIDARG;

    // get role of acc item

    pVarRole->vt = VT_I4;
    pVarRole->lVal = pAccItem->GetAccRole();

    return S_OK;
}


//-----------------------------------------------------------------------
//    get_accState()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accState().
//
//        Retrieves the current state for the specified object or child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pVarState        [out] Pointer to the VARIANT structure that
//                                will contain information describing
//                                the specified child's current state.
//                                This information may either be in the
//                                form of one or more object state
//                                constants or a custom description
//                                string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid or
//                          S_OK.
//
//    NOTES:
//
//        Since the icons are HWND based objects, they can never truly
//        have the input focus.  However, if the user clicks one, the main
//        window treats the icon as if it had the focus.  So, the state
//        of the client area should not indicate "focused" when an icon
//        is said to have the focus.
//
//        The push button can have the focus, but it cannot be selected.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accState( VARIANT varChild, VARIANT * pVarState )
{
    CTipbarAccItem *pAccItem;

    if (pVarState == NULL) 
        return E_INVALIDARG;

    // get acc item

    pAccItem = AccItemFromID( (int)varChild.lVal );
    if (pAccItem == NULL)
        return E_INVALIDARG;

    // get state of acc item

    pVarState->vt = VT_I4;
    pVarState->lVal = pAccItem->GetAccState();

    return S_OK;
}


//-----------------------------------------------------------------------
//    get_accHelp()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accHelp().
//
//        Retrieves the help property string for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pszHelp            [out] Pointer to the BSTR that will contain
//                                the child's help property string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid,
//                          DISP_E_MEMBERNOTFOUND if VarChild refers
//                          to any icon child, or the return value from
//                          either the standard client window implementation
//                          of get_accHelp() or the private method
//                          HrLoadString().
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accHelp( VARIANT varChild, BSTR *pbstrHelp )
{
    return DISP_E_MEMBERNOTFOUND;    /* no support in candidate UI */
}


//-----------------------------------------------------------------------
//    get_accHelpTopic()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accHelpTopic().
//
//        Retrieves the fully qualified path name of the help file
//        associated with the specified object, as well as a pointer
//        to the appropriate topic with in that file.
//
//    PARAMETERS:
//
//        pszHelpFile        [out] Pointer to the BSTR that will contain
//                                the fully qualified path name of the
//                                help file associated with the child.
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pidTopic        [out] Pointer to the value identifying the
//                                help file topic associated with the
//                                object.
//
//    RETURNS:
//
//        HRESULT            DISP_E_MEMBERNOTFOUND because the help topic
//                          property is not supported for the Accessible
//                          object or any of its children.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accHelpTopic( BSTR* pszHelpFile, VARIANT varChild, long* pidTopic )
{
    return DISP_E_MEMBERNOTFOUND;    /* no support in candidate UI */
}


//-----------------------------------------------------------------------
//    get_accKeyboardShortcut()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method
//        get_accKeyboardShortcut().
//
//        Retrieves the specified object's keyboard shortcut property.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be retrieved.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pszShortcut        [out] Pointer to the BSTR that will contain
//                                the keyboard shortcut string, or NULL
//                                if no keyboard shortcut is associated
//                                with this item.
//
//
//    RETURNS:
//
//        HRESULT            DISP_E_MEMBERNOTFOUND because the keyboard
//                          shortcut property is not supported for the
//                          Accessible object or any of its children.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accKeyboardShortcut( VARIANT varChild, BSTR *pbstrShortcut )
{
    return DISP_E_MEMBERNOTFOUND;    /* no support in candidate UI */
}


//-----------------------------------------------------------------------
//    get_accFocus()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accFocus().
//
//        Retrieves the child object that currently has the input focus.
//        Only one object or item within a container can have the current
//        focus at any one time.
//
//    PARAMETERS:
//
//        pVarFocus        [out] Pointer to the VARIANT structure that
//                                will contain information describing
//                                the specified child's current state.
//                                This information may either be in the
//                                form of one or more object state
//                                constants or a custom description
//                                string.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if the pVarFocus parameter is
//                          invalid or S_OK.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accFocus( VARIANT *pVarFocus )
{
    if (pVarFocus == NULL)
        return E_INVALIDARG;

    pVarFocus->vt = VT_EMPTY;

    return S_FALSE;
}


//-----------------------------------------------------------------------
//    get_accSelection()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accSelection().
//
//        Retrieves the selected children of this object.
//
//    PARAMETERS:
//
//        pVarSel          [out] Pointer to the VARIANT structure that
//                                will be filled with information about
//                                the selected child object or objects.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if the pVarSel parameter is
//                          invalid or S_OK.
//
//    NOTES:
//
//        Refer to the MSAA SDK documentation for a full description
//        of this method and the possible settings of pVarSel.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accSelection( VARIANT * pVarSel )
{
    if (pVarSel == NULL)
        return E_INVALIDARG;

    pVarSel->vt = VT_EMPTY;

    //
    // check if Selected Child Id is invalid.
    //
    if (_rgAccItems.Count() < _lSelection)
        _lSelection = 1;
   
    if (_rgAccItems.Count() > _lSelection)
    {
        pVarSel->vt = VT_I4;
        pVarSel->lVal = _lSelection;
    }

    return S_OK;
}


//-----------------------------------------------------------------------
//    get_accDefaultAction()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method get_accDefaultAction().
//
//        Retrieves a string containing a localized, human-readable sentence
//        that describes the object's default action.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child whose default action string is
//                                to be retrieved.  Since CTipbarAccessible
//                                only supports child IDs, the vt member
//                                of this structure must equal VT_I4.
//
//        pszDefAct        [out] Pointer to the BSTR that will contain
//                                the child's default action string,
//                                or NULL if there is no default action
//                                for this object.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either parameter is invalid,
//                          DISP_E_MEMBERNOTFOUND if VarChild refers
//                          to any icon child or the status bar child,
//                          or the return value from either the standard
//                          client window implementation of
//                          get_accDefaultAction() or the private method
//                          HrLoadString().
//
//    NOTES:
//
//        The only CTipbarAccessible child that has a default action is
//        the push button.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::get_accDefaultAction( VARIANT varChild, BSTR *pbstrDefAct )
{
    if (pbstrDefAct == NULL) 
        return E_INVALIDARG;

    *pbstrDefAct = NULL;
    //
    // check the variant.
    //
    if (varChild.vt != VT_I4) 
        return E_INVALIDARG;

    CTipbarAccItem *pItem = AccItemFromID(varChild.lVal);
  
    //
    // is it a valid child id?
    //
    if (!pItem)
        return DISP_E_MEMBERNOTFOUND;    /* no support in candidate UI */

    *pbstrDefAct = pItem->GetAccDefaultAction();

    return *pbstrDefAct ? S_OK : S_FALSE;
}


//-----------------------------------------------------------------------
//    accDoDefaultAction()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method accDoDefaultAction().
//
//        Performs the object's default action.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child whose default action will be
//                                invoked.  Since CTipbarAccessible only
//                                supports child IDs, the vt member of
//                                this structure must equal VT_I4.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if the in-parameter is invalid,
//                          DISP_E_MEMBERNOTFOUND if VarChild refers
//                          to any icon child or the status bar child,
//                          S_OK if VarChild refers to the push button,
//                          or the return value from the standard
//                          client window implementation of
//                          accDoDefaultAction().
//
//    NOTES:
//
//        The only CTipbarAccessible child that has a default action is
//        the push button.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::accDoDefaultAction( VARIANT varChild )
{
    //
    // check the variant.
    //
    if (varChild.vt != VT_I4) 
        return E_INVALIDARG;

    CTipbarAccItem *pItem = AccItemFromID(varChild.lVal);
  
    //
    // is it a valid child id?
    //
    if (!pItem)
        return DISP_E_MEMBERNOTFOUND;    /* no support in candidate UI */

    return pItem->DoAccDefaultAction() ? S_OK : S_FALSE;
}


//-----------------------------------------------------------------------
//    accSelect()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method accSelect().
//
//        Modifies the selection or moves the keyboard focus according
//        to the specified flags.
//
//    PARAMETERS:
//
//        flagsSel        [in]  Value specifying how to change the
//                                the current selection.  This parameter
//                                can be a combination of the values
//                                from the SELFLAG enumerated type.
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child to be selected.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if either of the parameters
//                          is invalid, S_FALSE if the selection
//                          and/or focus cannot be placed at the
//                          requested location, or S_OK if the
//                          selection and/or focus can be placed
//                          at the requested location.
//
//    NOTES:
//
//        For more information on selected objects, please see the
//        MSAA SDK Documentation.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::accSelect( long flagsSel, VARIANT varChild )
{
    //
    //    Validate the requested selection.
    //      SELFLAG_ADDSELECTION may not be combined
    //      with SELFLAG_REMOVESELECTION.
    //

    if ((flagsSel & SELFLAG_ADDSELECTION) && (flagsSel & SELFLAG_REMOVESELECTION))
        return E_INVALIDARG;

    //
    // We don't support SetFocus.
    // We don't support multi selection.
    //
    if ((flagsSel & SELFLAG_TAKEFOCUS) ||
        (flagsSel & SELFLAG_ADDSELECTION) ||
        (flagsSel & SELFLAG_EXTENDSELECTION))
        return S_FALSE;

    //
    // do nothing on removing seleciton.
    //
    if (flagsSel & SELFLAG_REMOVESELECTION)
        return S_OK;

    //
    // check the variant.
    //
    if (varChild.vt != VT_I4)
        return E_INVALIDARG;

    //
    // Update selection.
    //
    if (flagsSel & SELFLAG_TAKESELECTION)
    {
        _lSelection = varChild.lVal;
        return S_OK;
    }

    return S_FALSE;
}


//-----------------------------------------------------------------------
//    accLocation()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method accLocation().
//
//        Retrieves the specified child's current screen location in
//        screen coordinates.
//
//    PARAMETERS:
//
//        pxLeft            [out] Address of the child's left most
//                                boundary.
//
//        pyTop            [out] Address of the child's upper most
//                                boundary.
//
//        pcxWid            [out] Address of the child's width.
//
//        pcyHt            [out] Address of the child's height.
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child whose screen location is to be
//                                retrieved.  Since CTipbarAccessible only
//                                supports child IDs, the vt member
//                                of this structure must equal VT_I4.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if any of the parameters
//                          are invalid, E_UNEXPECTED if we are for
//                          some reason unable to determine the
//                          window rect of the button or status bar,
//                          S_OK if the screen coordinates of the
//                          child are successfully determined, or
//                          the return value from the standard client
//                          window implementation of accLocation().
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::accLocation( long* pxLeft, long* pyTop, long* pcxWid, long* pcyHt, VARIANT varChild )
{
    CTipbarAccItem *pAccItem;
    RECT rc;

    if (pxLeft == NULL || pyTop == NULL || pcxWid == NULL || pcyHt == NULL)
        return E_INVALIDARG;

    //
    //    If the child ID is CHILDID_SELF, we are being
    //      asked to retrieve the current screen location
    //      of the Accessible object itself.   Delegate
    //      this request to the standard implementation.
    //

    if (varChild.lVal == CHILDID_SELF)
        return _pDefAccClient->accLocation( pxLeft, pyTop, pcxWid, pcyHt, varChild );


    // get acc item

    pAccItem = AccItemFromID( (int)varChild.lVal );
    if (pAccItem == NULL)
        return E_INVALIDARG;

    // get location of acc item

    pAccItem->GetAccLocation( &rc );
    *pxLeft = rc.left;
    *pyTop  = rc.top;
    *pcxWid = rc.right - rc.left;
    *pcyHt  = rc.bottom - rc.top;

    return S_OK;
}


//-----------------------------------------------------------------------
//    accNavigate()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method accNavigate().
//
//        Retrieves the next or previous sibling or child object in a
//        specified direction.  This direction can be spatial order
//        (such as Left and Right) or in navigational order (such as
//        Next and Previous).
//
//    PARAMETERS:
//
//        navDir            [in]  A navigational constant specifying
//                                the direction in which to move.
//
//        varStart        [in]  VARIANT structure that identifies the
//                                child from which the navigational
//                                change will originate.  Since
//                                CTipbarAccessible only supports child IDs,
//                                the vt member of this structure must
//                                equal VT_I4.
//
//        pVarEndUpAt        [out] Pointer to the VARIANT structure that
//                                will contain information describing
//                                the destination child or object.
//                                If the vt member is VT_I4, then the
//                                lVal member is a child ID.  If the
//                                vt member is VT_EMPTY, then the
//                                navigation failed.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if the varStart parameter is
//                          invalid, or the return value from the
//                          default implementation of the window client
//                          area default Accessible object,
//                          DISP_E_MEMBERNOTFOUND if the combination
//                          of the navigation flag and the varStart
//                          setting is invalid, S_FALSE if the
//                          navigation fails, or S_OK.
//
//    NOTES:
//
//        Since the CTipbarAccessible object has no child objects (only child
//        elements), pVarEndUpAt will never be a pointer to a IDispatch
//        interface of a child object.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::accNavigate( long navDir, VARIANT varStart, VARIANT* pVarEndUpAt )
{
    HRESULT hr = S_FALSE;

    if (_rgAccItems.Count() <= 1)
    {
        pVarEndUpAt->vt = VT_EMPTY;
        return hr;
    }

    switch (navDir)
    {
        case NAVDIR_DOWN:
        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            pVarEndUpAt->vt = VT_I4;
            pVarEndUpAt->lVal = varStart.lVal + 1;
            if (_rgAccItems.Count() <= pVarEndUpAt->lVal)
                 pVarEndUpAt->lVal = 1;
            hr = S_OK;
            break;

        case NAVDIR_UP:
        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            pVarEndUpAt->vt = VT_I4;
            pVarEndUpAt->lVal = varStart.lVal - 1;
            if (pVarEndUpAt->lVal <= 0)
                 pVarEndUpAt->lVal = (_rgAccItems.Count() - 1);
            hr = S_OK;
            break;

        case NAVDIR_FIRSTCHILD:
            pVarEndUpAt->vt = VT_I4;
            pVarEndUpAt->lVal = 1;
            hr = S_OK;
            break;

        case NAVDIR_LASTCHILD:
            pVarEndUpAt->vt = VT_I4;
            pVarEndUpAt->lVal = (_rgAccItems.Count() - 1);
            hr = S_OK;
            break;

        default:
            pVarEndUpAt->vt = VT_EMPTY;
            break;
    }
    return hr;        /* no support in candidate UI */
}


//-----------------------------------------------------------------------
//    accHitTest()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method accHitTest().
//
//        Retrieves the ID of the a child at a given point on the screen.
//
//    PARAMETERS:
//
//        xLeft and yTop    [in]  The screen coordinates of the point
//                                to be hit tested.
//
//        pVarHit            [out] Pointer to the VARIANT structure that
//                                will contain information describing
//                                the hit child.  If the vt member is
//                                VT_I4, then the lVal member is a child
//                                ID.  If the vt member is VT_EMPTY,
//                                then the navigation failed.
//
//    RETURNS:
//
//        HRESULT            E_INVALIDARG if the pVarHit parameter is
//                          invalid, or S_OK.
//
//    NOTES:
//
//        Since the CTipbarAccessible object has no child objects (only child
//        elements), pVarHit will never be a pointer to a IDispatch
//        interface of a child object.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::accHitTest( long xLeft, long yTop, VARIANT *pVarHit )
{
    int   i;
    POINT pt;
    RECT  rc;

    if (!pVarHit)
        return E_INVALIDARG;

    // check point is inside of window

    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient( _hWnd, &pt );

    GetClientRect( _hWnd, &rc );
    if (!PtInRect( &rc, pt )) 
    {
        pVarHit->vt = VT_EMPTY;
    }
    else 
    {
        pVarHit->vt = VT_I4;
        pVarHit->lVal = CHILDID_SELF;

        for (i = 1; i < _rgAccItems.Count(); i++) 
        {
            CTipbarAccItem *pItem;

            pItem = _rgAccItems.Get(i);
            if (!pItem)
                continue;

            pItem->GetAccLocation( &rc );

            if (PtInRect( &rc, pt )) 
            {
                pVarHit->lVal = i;
                break;
            }
        }
    }

    return S_OK;
}


//-----------------------------------------------------------------------
//    put_accName()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method put_accName().
//
//        Sets the name property for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child whose name property is to be
//                                set.  Since CTipbarAccessible only supports
//                                child IDs, the vt member of this
//                                structure must equal VT_I4.
//
//        szName            [in]  String that specifies the new name for
//                                this child.
//
//    RETURNS:
//
//        HRESULT            S_FALSE because the name property for any
//                          child may not be changed.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::put_accName( VARIANT varChild, BSTR szName )
{
    //
    //    We don't allow clients to change the name
    //      property of any child so we simply return
    //      S_FALSE.
    //

    return S_FALSE;
}


//-----------------------------------------------------------------------
//    put_accValue()
//
//    DESCRIPTION:
//
//        Implements the IAccessible interface method put_accValue().
//
//        Sets the value property for the specified child.
//
//    PARAMETERS:
//
//        varChild        [in]  VARIANT structure that identifies the
//                                child whose value property is to be
//                                set.  Since CTipbarAccessible only supports
//                                child IDs, the vt member of this
//                                structure must equal VT_I4.
//
//        szValue            [in]  String that specifies the new value for
//                                this child.
//
//    RETURNS:
//
//        HRESULT            S_FALSE because the value property for any
//                          child may not be changed.
//
//-----------------------------------------------------------------------

STDMETHODIMP CTipbarAccessible::put_accValue( VARIANT varChild, BSTR szValue )
{
    //
    //    We don't allow clients to change the value
    //      property of the status bar (the only child that
    //      has a value property) so we simply return S_FALSE.
    //

    return S_FALSE;
}


//----------------------------------------------------------------------------
//
// AccItemFromID
//
//----------------------------------------------------------------------------

CTipbarAccItem *CTipbarAccessible::AccItemFromID( int iID )
{
    if ((iID < 0) || (_rgAccItems.Count() <= iID))
        return NULL;

    return _rgAccItems.Get(iID);

}

//----------------------------------------------------------------------------
//
// ClearAccItems
//
//----------------------------------------------------------------------------

void CTipbarAccessible::ClearAccItems( void )
{
    _rgAccItems.Clear();
}

//----------------------------------------------------------------------------
//
// AddAccItem
//
//----------------------------------------------------------------------------

BOOL CTipbarAccessible::AddAccItem( CTipbarAccItem *pAccItem )
{
    CTipbarAccItem **ppItem;

    ppItem = _rgAccItems.Append(1);
    if (!ppItem)
       return FALSE;

    *ppItem = pAccItem;

    return TRUE;
}

//----------------------------------------------------------------------------
//
// RemoveAccItem
//
//----------------------------------------------------------------------------

BOOL CTipbarAccessible::RemoveAccItem( CTipbarAccItem *pAccItem )
{
    int i;

    for (i = 0; i < _rgAccItems.Count(); i++) 
    {
        CTipbarAccItem *pItem;

        pItem = _rgAccItems.Get(i);
        if (pItem == pAccItem)
        {
            _rgAccItems.Remove(i, 1);
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// DoDefaultActionReal
//
//----------------------------------------------------------------------------

BOOL CTipbarAccessible::DoDefaultActionReal(int nId)
{
    CTipbarAccItem *pItem = AccItemFromID(nId);
  
    //
    // is it a valid child id?
    //
    if (!pItem)
        return FALSE;

    return pItem->DoAccDefaultActionReal();
}

//----------------------------------------------------------------------------
//
// GetIDOfItem
//
//----------------------------------------------------------------------------

int CTipbarAccessible::GetIDOfItem( CTipbarAccItem *pAccItem )
{
    int i;

    for (i = 0; i < _rgAccItems.Count(); i++) 
    {
        CTipbarAccItem *pItem;

        pItem = _rgAccItems.Get(i);
        if (pItem == pAccItem)
        {
            return i;
        }
    }
    return -1;
}
 

//----------------------------------------------------------------------------
//
// NotifyWinEvent
//
//----------------------------------------------------------------------------

void CTipbarAccessible::NotifyWinEvent( DWORD dwEvent, CTipbarAccItem *pAccItem )
{
    Assert( pAccItem != NULL );

    int nId = GetIDOfItem(pAccItem);
    if (nId < 0)
    {
        // Assert(0);
        return;
    }

    OurNotifyWinEvent( dwEvent, _hWnd, OBJID_CLIENT, nId);
}

//----------------------------------------------------------------------------
//
// CreateRefToAccObj
//
//----------------------------------------------------------------------------

LRESULT CTipbarAccessible::CreateRefToAccObj( WPARAM wParam )
{
    return LresultFromObject( IID_IAccessible, wParam, (IAccessible *)this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\tipbar.cpp ===
//
// tipbar.cpp
//

#include "private.h"
#include "globals.h"
#include <initguid.h>
#include "tipbar.h"
#include "helpers.h"
#include "xstring.h"
#include "commctrl.h"
#include "resource.h"
#include "inatlib.h"
#include "thdutil.h"
#include "catutil.h"
#include "immxutil.h"
#include "utbmenu.h"
#include "balloon.h"
#include "cregkey.h"
#include "cuimenu.h"
#include "cuishadw.h"
#include "cuischem.h"
#include "cmydc.h"
#include "intlmenu.h"
#include "utbtray.h"
#include "catenum.h"
#include "asynccal.h"
#include "fontlink.h"
#include "cresstr.h"
#include "nuiinat.h"
#include "tlapi.h"
#include "cuiutil.h"
#include "cuischem.h"
#include "cuitip.h"
#include "utbdlgs.h"
#include <shlapip.h>
#include "deskband.h"
#include "lmcons.h" // for UNLEN
#include "sddl.h"

#include "winuserp.h"

const DWORD TF_LBESF_GLOBAL = 0x0001;
const DWORD TF_LBSMI_FILTERCURRENTTHREAD = 0x0001;

extern HINSTANCE g_hInst;
const TCHAR c_szTipbarWndClass[] = TEXT("TipbarWndClass");
const TCHAR c_szTipbarWndName[] = TEXT("Cicload Tipbar");

const TCHAR c_szCicKey[]                  = TEXT("SOFTWARE\\Microsoft\\CTF\\");
const TCHAR c_szUTBKey[]                  = TEXT("SOFTWARE\\Microsoft\\CTF\\MSUTB\\");
const TCHAR c_szSkipRedrawHKL[]           = TEXT("SOFTWARE\\Microsoft\\CTF\\MSUTB\\SkipRedrawHKL");
const TCHAR c_szShowTipbar[]              = TEXT("ShowTipbar");
const TCHAR c_szDontShowCloseLangBarDlg[] = TEXT("DontShowCloseLangBarDlg");
const TCHAR c_szDontShowMinimizeLangBarDlg[] = TEXT("DontShowMinimizeLangBarDlg");
const TCHAR c_szShowDebugMenu[]           = TEXT("ShowDebugMenu");
const TCHAR c_szShowDeskBand[]            = TEXT("ShowDeskBand");
const TCHAR c_szNewLook[]                 = TEXT("NewLook");
const TCHAR c_szIntelliSense[]            = TEXT("IntelliSense");
const TCHAR c_szTimeOutNonIntentional[]   = TEXT("TimeOutNonIntentional");
const TCHAR c_szTimeOutIntentional[]      = TEXT("TimeOutIntentional");
const TCHAR c_szShowCloseMenu[]           = TEXT("ShowCloseMenu");
const TCHAR c_szShowMinimizedBalloon[]    = TEXT("ShowMinimizedBalloon");
const TCHAR c_szLeft[]                    = TEXT("Left");
const TCHAR c_szTop[]                     = TEXT("Top");
const TCHAR c_szExcludeCaptionButtons[]   = TEXT("ExcludeCaptionButtons");
const TCHAR c_szShowShadow[]              = TEXT("ShowShadow");
const TCHAR c_szTaskbarTheme[]            = TEXT("TaskbarTheme");
const TCHAR c_szVertical[]                = TEXT("Vertical");
// const TCHAR c_szMoveToTray[]              = TEXT("MoveToTray");

BOOL g_bNewLook                = TRUE;
BOOL g_bIntelliSense           = FALSE;
BOOL  g_bShowTipbar            = TRUE;
BOOL  g_bShowDebugMenu         = FALSE;
BOOL  g_bShowCloseMenu         = FALSE;
BOOL  g_bShowMinimizedBalloon  = TRUE;
BOOL  g_bExcludeCaptionButtons = TRUE;
BOOL  g_bShowShadow            = FALSE;
BOOL  g_bShowDeskBand          = FALSE;
BOOL  g_nLeft = -1;
BOOL  g_nTop  = -1;
DWORD g_dwWndStyle            = 0;
DWORD g_dwChildWndStyle       = 0;
DWORD g_dwMenuStyle           = 0;
CTipbarWnd *g_pTipbarWnd;
CTrayIconWnd *g_pTrayIconWnd;
HWND g_hwndParent;
BOOL g_bWinLogon = FALSE;
BOOL g_fTaskbarTheme = TRUE;
BOOL g_fVertical = FALSE;
BOOL g_fInClosePopupTipbar = FALSE;
BOOL g_fRTL = FALSE;

const TCHAR c_szTimerElapseSTUBSTART[]          = TEXT("TimerElapseSTUBSTART");
const TCHAR c_szTimerElapseSTUBEND[]            = TEXT("TimerElapseSTUBEND");
const TCHAR c_szTimerElapseBACKTOALPHA[]        = TEXT("TimerElapseBACKTOALPHA");
const TCHAR c_szTimerElapseONTHREADITEMCHANGE[] = TEXT("TimerElapseONTHREADITEMCHANGE");
const TCHAR c_szTimerElapseSETWINDOWPOS[]       = TEXT("TimerElapseSETWINDOWPOS");
const TCHAR c_szTimerElapseONUPDATECALLED[]     = TEXT("TimerElapseONUPDATECALLED");
const TCHAR c_szTimerElapseSYSCOLORCHANGED[]    = TEXT("TimerElapseSYSCOLORCHANGED");
const TCHAR c_szTimerElapseDISPLAYCHANGE[]      = TEXT("TimerElapseDISPLAYCHANGE");
const TCHAR c_szTimerElapseUPDATEUI[]           = TEXT("TimerElapseUPDATEUI");
const TCHAR c_szTimerElapseSHOWWINDOW[]         = TEXT("TimerElapseSHOWWINDOW");
const TCHAR c_szTimerElapseMOVETOTRAY[]         = TEXT("TimerElapseMOVETOTRAY");
const TCHAR c_szTimerElapseTRAYWNDONDELAYMSG[]  = TEXT("TimerElapseTRAYWNDONDELAYMSG");
const TCHAR c_szTimerElapseDOACCDEFAULTACTION[] = TEXT("TimerElapseDOACCDEFAULTACTION");
const TCHAR c_szTimerElapseENSUREFOCUS[]        = TEXT("TimerElapseENSUREFOCUS");
const TCHAR c_szTimerElapseSHOWDESKBAND[]       = TEXT("TimerElapseSHOWWDESKBAND");

UINT g_uTimerElapseSTUBSTART          = 100;
UINT g_uTimerElapseSTUBEND            = 2000;
UINT g_uTimerElapseBACKTOALPHA        = 3000;
UINT g_uTimerElapseONTHREADITEMCHANGE = 200;
UINT g_uTimerElapseSETWINDOWPOS       = 100;
UINT g_uTimerElapseONUPDATECALLED     = 50; // Satori tune up 20,50,100 or 200
UINT g_uTimerElapseSYSCOLORCHANGED    = 20;
UINT g_uTimerElapseDISPLAYCHANGE      = 20;
UINT g_uTimerElapseUPDATEUI           = 70; // MSIME2002 JP needs 70ms.
UINT g_uTimerElapseSHOWWINDOW         = 50;
UINT g_uTimerElapseMOVETOTRAY         = 50;
UINT g_uTimerElapseTRAYWNDONDELAYMSG  = 50;
UINT g_uTimerElapseDOACCDEFAULTACTION = 200;
UINT g_uTimerElapseENSUREFOCUS        = 50;
UINT g_uTimerElapseSHOWDESKBAND       = 3000;


//
// from bandobjs.cpp
//
extern UINT  g_wmTaskbarCreated;

//
// from itemlist.cpp
//
extern UINT g_uTimeOutNonIntentional;
extern UINT g_uTimeOutIntentional;
extern UINT g_uTimeOutMax;


//
// SkipRedrawing Hack HKL list.
//
CStructArray<HKL> *g_prghklSkipRedrawing = NULL;
void UninitSkipRedrawHKLArray();

#define WM_LBWND_SHOWCONTEXTMENU      (WM_USER + 1)

// TM_LANGUAGEBAND is defined in "shell\inc\trayp.h"
#define TM_LANGUAGEBAND     WM_USER+0x105

/* 142b6d42-955d-4488-97c0-b23b23e6b048 */
const IID IID_PRIV_BUTTONITEM = { 
    0x142b6d42,
    0x955d,
    0x4488,
    {0x97, 0xc0, 0xb2, 0x3b, 0x23, 0xe6, 0xb0, 0x48}
  };

/* 8dd1cc81-fca0-4dd5-b848-2b85732d2fc4 */
const IID IID_PRIV_BITMAPBUTTONITEM = { 
    0x8dd1cc81,
    0xfca0,
    0x4dd5,
    {0xb8, 0x48, 0x2b, 0x85, 0x73, 0x2d, 0x2f, 0xc4}
  };

/* 36b40e05-7b3e-4a4a-bda7-2249ba17d3c4 */
const IID IID_PRIV_BITMAPITEM = { 
    0x36b40e05,
    0x7b3e,
    0x4a4a,
    {0xbd, 0xa7, 0x22, 0x49, 0xba, 0x17, 0xd3, 0xc4}
  };

/* 68831a74-6f86-447a-b2b8-634250ac445e */
const IID IID_PRIV_BALLOONITEM = { 
    0x68831a74,
    0x6f86,
    0x447a,
    {0xb2, 0xb8, 0x63, 0x42, 0x50, 0xac, 0x44, 0x5e}
  };

//
// from MSCTF.DLL.
//
extern "C" BOOL WINAPI TF_IsFullScreenWindowAcitvated();
extern "C" DWORD WINAPI TF_CheckThreadInputIdle(DWORD dwThreadId, DWORD dwTimeOut);

//
// from intlmenu.cpp
//
extern BOOL IsFELangId(LANGID langid);

//////////////////////////////////////////////////////////////////////////////
//
// predefined control buttons
//
//////////////////////////////////////////////////////////////////////////////

static CTRLBTNMAP g_cbCtrlBtn[NUM_CTRLBUTTONS] = {
   {ID_CBTN_CAPSKEY,  UIBUTTON_CENTER | UIBUTTON_VCENTER | UIBUTTON_TOGGLE, 
    0, 0, CTRL_ICONFROMRES | CTRL_TOGGLEBUTTON, {0x0, 0x0}},
   {ID_CBTN_KANAKEY,  UIBUTTON_CENTER | UIBUTTON_VCENTER | UIBUTTON_TOGGLE,
    0, 1, CTRL_ICONFROMRES | CTRL_TOGGLEBUTTON, {0x0, 0x0}},
   {ID_CBTN_MINIMIZE, UIBUTTON_CENTER | UIBUTTON_VCENTER,  
    1, 0, CTRL_USEMARLETT | CTRL_DISABLEONWINLOGON, {0x0030, 0x0000}},
   {ID_CBTN_EXTMENU,  UIBUTTON_CENTER | UIBUTTON_VCENTER,  
    1, 1, CTRL_USEMARLETT | CTRL_DISABLEONWINLOGON, {0x0075, 0x0000}},
   };

static CTRLBTNMAP g_cbCtrlBtnDeskBand[NUM_CTRLBUTTONS] = {
   {ID_CBTN_CAPSKEY,  UIBUTTON_CENTER | UIBUTTON_VCENTER | UIBUTTON_TOGGLE, 
    0, 0, CTRL_ICONFROMRES | CTRL_TOGGLEBUTTON, {0x0, 0x0}},
   {ID_CBTN_KANAKEY,  UIBUTTON_CENTER | UIBUTTON_VCENTER | UIBUTTON_TOGGLE,
    0, 1, CTRL_ICONFROMRES | CTRL_TOGGLEBUTTON, {0x0, 0x0}},
   {ID_CBTN_RESTORE, UIBUTTON_CENTER | UIBUTTON_VCENTER,  
    1, 0, CTRL_USEMARLETT | CTRL_DISABLEONWINLOGON, {0x0032, 0x0000}},
   {ID_CBTN_EXTMENU,  UIBUTTON_CENTER | UIBUTTON_V